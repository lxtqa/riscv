--- ./benchmark/25/test1.cc	2024-01-28 20:15:15
+++ ./benchmark/25/test1_.cc	2024-01-28 20:15:16
@@ -4275,11 +4275,13 @@ bool Assembler::IsImmFP64(double imm) {
   return true;
 }
 
-void Assembler::FixOnHeapReferences() {
+void Assembler::FixOnHeapReferences(bool update_embedded_objects) {
   Address base = reinterpret_cast<Address>(buffer_->start());
-  for (auto p : saved_handles_for_raw_object_ptr_) {
-    Handle<HeapObject> object = GetEmbeddedObject(p.second);
-    WriteUnalignedValue(base + p.first, object->ptr());
+  if (update_embedded_objects) {
+    for (auto p : saved_handles_for_raw_object_ptr_) {
+      Handle<HeapObject> object = GetEmbeddedObject(p.second);
+      WriteUnalignedValue(base + p.first, object->ptr());
+    }
   }
   for (auto p : saved_offsets_for_runtime_entries_) {
     Instruction* instr = reinterpret_cast<Instruction*>(base + p.first);
@@ -4295,16 +4297,19 @@ void Assembler::FixOnHeapReferencesToHandles() {
   for (auto p : saved_handles_for_raw_object_ptr_) {
     WriteUnalignedValue(base + p.first, p.second);
   }
+  saved_handles_for_raw_object_ptr_.clear();
   for (auto p : saved_offsets_for_runtime_entries_) {
     Instruction* instr = reinterpret_cast<Instruction*>(base + p.first);
     DCHECK(is_int26(p.second));
     DCHECK(instr->IsBranchAndLink() || instr->IsUnconditionalBranch());
     instr->SetInstructionBits(instr->Mask(UnconditionalBranchMask) | p.second);
   }
+  saved_offsets_for_runtime_entries_.clear();
 }
 
 void Assembler::GrowBuffer() {
   bool previously_on_heap = buffer_->IsOnHeap();
+  int previous_on_heap_gc_count = OnHeapGCCount();
 
   // Compute new buffer size.
   int old_size = buffer_->size();
@@ -4351,7 +4356,7 @@ void Assembler::GrowBuffer() {
   // Fix on-heap references.
   if (previously_on_heap) {
     if (buffer_->IsOnHeap()) {
-      FixOnHeapReferences();
+      FixOnHeapReferences(previous_on_heap_gc_count != OnHeapGCCount());
     } else {
       FixOnHeapReferencesToHandles();
     }

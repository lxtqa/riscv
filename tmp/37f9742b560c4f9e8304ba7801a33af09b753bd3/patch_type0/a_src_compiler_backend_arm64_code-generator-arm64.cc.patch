diff --git a/src/compiler/backend/arm64/code-generator-arm64.cc b/src/compiler/backend/arm64/code-generator-arm64.cc
index 70ae7ee950b..080dd641376 100644
--- a/src/compiler/backend/arm64/code-generator-arm64.cc
+++ b/src/compiler/backend/arm64/code-generator-arm64.cc
@@ -412,7 +412,7 @@ class WasmOutOfLineTrap : public OutOfLineCode {
                        0);
       __ LeaveFrame(StackFrame::WASM);
       auto call_descriptor = gen_->linkage()->GetIncomingDescriptor();
-      int pop_count = static_cast<int>(call_descriptor->StackParameterCount());
+      int pop_count = static_cast<int>(call_descriptor->ParameterSlotCount());
       pop_count += (pop_count & 1);  // align
       __ Drop(pop_count);
       __ Ret();
@@ -665,21 +665,21 @@ void AdjustStackPointerForTailCall(TurboAssembler* tasm,
 }  // namespace
 
 void CodeGenerator::AssembleTailCallBeforeGap(Instruction* instr,
-                                              int first_unused_stack_slot) {
+                                              int first_unused_slot_offset) {
   AdjustStackPointerForTailCall(tasm(), frame_access_state(),
-                                first_unused_stack_slot, false);
+                                first_unused_slot_offset, false);
 }
 
 void CodeGenerator::AssembleTailCallAfterGap(Instruction* instr,
-                                             int first_unused_stack_slot) {
-  DCHECK_EQ(first_unused_stack_slot % 2, 0);
+                                             int first_unused_slot_offset) {
+  DCHECK_EQ(first_unused_slot_offset % 2, 0);
   AdjustStackPointerForTailCall(tasm(), frame_access_state(),
-                                first_unused_stack_slot);
+                                first_unused_slot_offset);
   DCHECK(instr->IsTailCall());
   InstructionOperandConverter g(this, instr);
-  int optional_padding_slot = g.InputInt32(instr->InputCount() - 2);
-  if (optional_padding_slot % 2) {
-    __ Poke(padreg, optional_padding_slot * kSystemPointerSize);
+  int optional_padding_offset = g.InputInt32(instr->InputCount() - 2);
+  if (optional_padding_offset % 2) {
+    __ Poke(padreg, optional_padding_offset * kSystemPointerSize);
   }
 }
 
@@ -3242,13 +3242,13 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // We might need x3 for scratch.
   DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & x3.bit());
-  const int parameter_count =
-      static_cast<int>(call_descriptor->StackParameterCount());
+  const int parameter_slots =
+      static_cast<int>(call_descriptor->ParameterSlotCount());
   Arm64OperandConverter g(this, nullptr);
 
-  // {aditional_pop_count} is only greater than zero if {parameter_count = 0}.
+  // {aditional_pop_count} is only greater than zero if {parameter_slots = 0}.
   // Check RawMachineAssembler::PopAndReturn.
-  if (parameter_count != 0) {
+  if (parameter_slots != 0) {
     if (additional_pop_count->IsImmediate()) {
       DCHECK_EQ(g.ToConstant(additional_pop_count).ToInt32(), 0);
     } else if (__ emit_debug_code()) {
@@ -3259,12 +3259,12 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   Register argc_reg = x3;
   // Functions with JS linkage have at least one parameter (the receiver).
-  // If {parameter_count} == 0, it means it is a builtin with
+  // If {parameter_slots} == 0, it means it is a builtin with
   // kDontAdaptArgumentsSentinel, which takes care of JS arguments popping
   // itself.
   const bool drop_jsargs = frame_access_state()->has_frame() &&
                            call_descriptor->IsJSFunctionCall() &&
-                           parameter_count != 0;
+                           parameter_slots != 0;
   if (call_descriptor->IsCFunctionCall()) {
     AssembleDeconstructFrame();
   } else if (frame_access_state()->has_frame()) {
@@ -3288,25 +3288,25 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   if (drop_jsargs) {
     // We must pop all arguments from the stack (including the receiver). This
-    // number of arguments is given by max(1 + argc_reg, parameter_count).
+    // number of arguments is given by max(1 + argc_reg, parameter_slots).
     Label argc_reg_has_final_count;
     __ Add(argc_reg, argc_reg, 1);  // Consider the receiver.
-    if (parameter_count > 1) {
-      __ Cmp(argc_reg, Operand(parameter_count));
+    if (parameter_slots > 1) {
+      __ Cmp(argc_reg, Operand(parameter_slots));
       __ B(&argc_reg_has_final_count, ge);
-      __ Mov(argc_reg, Operand(parameter_count));
+      __ Mov(argc_reg, Operand(parameter_slots));
       __ Bind(&argc_reg_has_final_count);
     }
     __ DropArguments(argc_reg);
   } else if (additional_pop_count->IsImmediate()) {
     int additional_count = g.ToConstant(additional_pop_count).ToInt32();
-    __ DropArguments(parameter_count + additional_count);
-  } else if (parameter_count == 0) {
+    __ DropArguments(parameter_slots + additional_count);
+  } else if (parameter_slots == 0) {
     __ DropArguments(g.ToRegister(additional_pop_count));
   } else {
-    // {additional_pop_count} is guaranteed to be zero if {parameter_count !=
+    // {additional_pop_count} is guaranteed to be zero if {parameter_slots !=
     // 0}. Check RawMachineAssembler::PopAndReturn.
-    __ DropArguments(parameter_count);
+    __ DropArguments(parameter_slots);
   }
   __ AssertSpAligned();
   __ Ret();

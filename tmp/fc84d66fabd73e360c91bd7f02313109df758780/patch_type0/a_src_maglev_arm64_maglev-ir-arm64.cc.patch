diff --git a/src/maglev/arm64/maglev-ir-arm64.cc b/src/maglev/arm64/maglev-ir-arm64.cc
index ddb6e8bfb28..6f9454c9577 100644
--- a/src/maglev/arm64/maglev-ir-arm64.cc
+++ b/src/maglev/arm64/maglev-ir-arm64.cc
@@ -1471,90 +1471,19 @@ void HandleInterruptsAndTiering(MaglevAssembler* masm, ZoneLabelRef done,
 
   // No pending interrupts. Call into the TieringManager if needed.
   {
-    // Skip the runtime call if the tiering state is kInProgress. The runtime
-    // only performs simple bookkeeping in this case, which we can easily
-    // replicate here in generated code.
-    // TODO(jgruber): Use the correct feedback vector once Maglev inlining is
-    // enabled.
-    Label update_profiler_ticks_and_interrupt_budget;
-    {
-      MaglevAssembler::ScratchRegisterScope temps(masm);
-      Register scratch1 = temps.Acquire();
-      static_assert(kTieringStateInProgressBlocksTierup);
-      __ Move(scratch0, masm->compilation_info()
-                            ->toplevel_compilation_unit()
-                            ->feedback()
-                            .object());
-
-      // If tiering_state is kInProgress, skip the runtime call.
-      __ Ldrh(scratch1.W(),
-              FieldMemOperand(scratch0, FeedbackVector::kFlagsOffset));
-      __ DecodeField<FeedbackVector::TieringStateBits>(scratch1);
-      __ Cmp(scratch1.W(),
-             Immediate(static_cast<int>(TieringState::kInProgress)));
-      __ B(&update_profiler_ticks_and_interrupt_budget, eq);
-
-      // If osr_tiering_state is kInProgress, skip the runtime call.
-      __ Ldrh(scratch1.W(),
-              FieldMemOperand(scratch0, FeedbackVector::kFlagsOffset));
-      __ DecodeField<FeedbackVector::OsrTieringStateBit>(scratch1);
-      __ Cmp(scratch1.W(),
-             Immediate(static_cast<int>(TieringState::kInProgress)));
-      __ B(&update_profiler_ticks_and_interrupt_budget, eq);
-    }
-
-    {
-      SaveRegisterStateForCall save_register_state(masm,
-                                                   node->register_snapshot());
-      Register function = scratch0;
-      __ Ldr(function, MemOperand(fp, StandardFrameConstants::kFunctionOffset));
-      __ Push(function);
-      // Move into kContextRegister after the load into scratch0, just in case
-      // scratch0 happens to be kContextRegister.
-      __ Move(kContextRegister, masm->native_context().object());
-      // Note: must not cause a lazy deopt!
-      __ CallRuntime(Runtime::kBytecodeBudgetInterrupt_Maglev, 1);
-      save_register_state.DefineSafepoint();
-    }
-    __ B(*done);
-
-    __ Bind(&update_profiler_ticks_and_interrupt_budget);
-    {
-      MaglevAssembler::ScratchRegisterScope temps(masm);
-      Register feedback_vector = scratch0;
-      Register ticks = temps.Acquire().W();
-      // We are skipping the call to Runtime::kBytecodeBudgetInterrupt_Maglev
-      // since the tiering state is kInProgress. Perform bookkeeping that would
-      // have been done in the runtime function:
-      __ AssertFeedbackVector(feedback_vector);
-      // FeedbackVector::SaturatingIncrementProfilerTicks.
-      // TODO(jgruber): This isn't saturating and thus we may theoretically
-      // exceed Smi::kMaxValue. But, 1) this is very unlikely since it'd take
-      // quite some time to exhaust the budget that many times; and 2) even an
-      // overflow doesn't hurt us at all.
-      __ Ldr(ticks, FieldMemOperand(feedback_vector,
-                                    FeedbackVector::kProfilerTicksOffset));
-      __ Add(ticks, ticks, Immediate(1));
-      __ Str(ticks, FieldMemOperand(feedback_vector,
-                                    FeedbackVector::kProfilerTicksOffset));
-    }
-
-    // JSFunction::SetInterruptBudget.
-    {
-      MaglevAssembler::ScratchRegisterScope temps(masm);
-      Register feedback_cell = scratch0;
-      Register budget = temps.Acquire().W();
-      __ Ldr(feedback_cell,
-             MemOperand(fp, StandardFrameConstants::kFunctionOffset));
-      __ LoadTaggedField(
-          feedback_cell,
-          FieldMemOperand(feedback_cell, JSFunction::kFeedbackCellOffset));
-      __ Move(budget, v8_flags.interrupt_budget);
-      __ Str(budget, FieldMemOperand(feedback_cell,
-                                     FeedbackCell::kInterruptBudgetOffset));
-    }
-    __ B(*done);
+    SaveRegisterStateForCall save_register_state(masm,
+                                                 node->register_snapshot());
+    Register function = scratch0;
+    __ Ldr(function, MemOperand(fp, StandardFrameConstants::kFunctionOffset));
+    __ Push(function);
+    // Move into kContextRegister after the load into scratch0, just in case
+    // scratch0 happens to be kContextRegister.
+    __ Move(kContextRegister, masm->native_context().object());
+    // Note: must not cause a lazy deopt!
+    __ CallRuntime(Runtime::kBytecodeBudgetInterrupt_Maglev, 1);
+    save_register_state.DefineSafepoint();
   }
+  __ B(*done);
 }
 
 void GenerateReduceInterruptBudget(MaglevAssembler* masm, Node* node,

diff --git a/src/maglev/x64/maglev-ir-x64.cc b/src/maglev/x64/maglev-ir-x64.cc
index edfdeb9d069..52cfa64d4fb 100644
--- a/src/maglev/x64/maglev-ir-x64.cc
+++ b/src/maglev/x64/maglev-ir-x64.cc
@@ -2004,19 +2004,6 @@ void CheckedInt32ToUint32::GenerateCode(MaglevAssembler* masm,
   __ EmitEagerDeoptIf(negative, DeoptimizeReason::kNotUint32, this);
 }
 
-void CheckedUint32ToInt32::SetValueLocationConstraints() {
-  UseRegister(input());
-  DefineSameAsFirst(this);
-}
-void CheckedUint32ToInt32::GenerateCode(MaglevAssembler* masm,
-                                        const ProcessingState& state) {
-  Register input_reg = ToRegister(input());
-  // Check if the top bit is set -- if it is, then this is not a valid int32,
-  // otherwise it is.
-  __ testl(input_reg, Immediate(1 << 31));
-  __ EmitEagerDeoptIf(not_zero, DeoptimizeReason::kNotInt32, this);
-}
-
 void ChangeInt32ToFloat64::SetValueLocationConstraints() {
   UseRegister(input());
   DefineAsRegister(this);
@@ -2038,40 +2025,6 @@ void ChangeUint32ToFloat64::GenerateCode(MaglevAssembler* masm,
   __ Cvtlui2sd(ToDoubleRegister(result()), ToRegister(input()));
 }
 
-void CheckedTruncateFloat64ToInt32::SetValueLocationConstraints() {
-  UseRegister(input());
-  DefineAsRegister(this);
-}
-void CheckedTruncateFloat64ToInt32::GenerateCode(MaglevAssembler* masm,
-                                                 const ProcessingState& state) {
-  DoubleRegister input_reg = ToDoubleRegister(input());
-  Register result_reg = ToRegister(result());
-  DoubleRegister converted_back = kScratchDoubleReg;
-
-  // Convert the input float64 value to int32.
-  __ Cvttsd2si(result_reg, input_reg);
-  // Convert that int32 value back to float64.
-  __ Cvtlsi2sd(converted_back, result_reg);
-  // Check that the result of the float64->int32->float64 is equal to the input
-  // (i.e. that the conversion didn't truncate.
-  __ Ucomisd(input_reg, converted_back);
-  __ EmitEagerDeoptIf(parity_even, DeoptimizeReason::kNotInt32, this);
-  __ EmitEagerDeoptIf(not_equal, DeoptimizeReason::kNotInt32, this);
-
-  // Check if {input} is -0.
-  Label check_done;
-  __ cmpl(result_reg, Immediate(0));
-  __ j(not_equal, &check_done);
-
-  // In case of 0, we need to check the high bits for the IEEE -0 pattern.
-  Register high_word32_of_input = kScratchRegister;
-  __ Pextrd(high_word32_of_input, input_reg, 1);
-  __ cmpl(high_word32_of_input, Immediate(0));
-  __ EmitEagerDeoptIf(less, DeoptimizeReason::kNotInt32, this);
-
-  __ bind(&check_done);
-}
-
 void CheckedTruncateFloat64ToUint32::SetValueLocationConstraints() {
   UseRegister(input());
   DefineAsRegister(this);
diff --git a/test/mjsunit/maglev/regress/regress-crbug-1416795.js b/test/mjsunit/maglev/regress/regress-crbug-1416795.js
new file mode 100644
index 00000000000..a52ecaa5eb1

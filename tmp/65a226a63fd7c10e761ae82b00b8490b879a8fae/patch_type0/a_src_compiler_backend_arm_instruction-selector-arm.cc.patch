diff --git a/src/compiler/backend/arm/instruction-selector-arm.cc b/src/compiler/backend/arm/instruction-selector-arm.cc
index 1a6b14a2d16..7fd1224818a 100644
--- a/src/compiler/backend/arm/instruction-selector-arm.cc
+++ b/src/compiler/backend/arm/instruction-selector-arm.cc
@@ -15,10 +15,13 @@ namespace internal {
 namespace compiler {
 
 // Adds Arm-specific methods for generating InstructionOperands.
-class ArmOperandGenerator : public OperandGenerator {
+template <typename Adapter>
+class ArmOperandGeneratorT : public OperandGeneratorT<Adapter> {
  public:
-  explicit ArmOperandGenerator(InstructionSelector* selector)
-      : OperandGenerator(selector) {}
+  OPERAND_GENERATOR_T_BOILERPLATE(Adapter)
+
+  explicit ArmOperandGeneratorT(InstructionSelectorT<Adapter>* selector)
+      : super(selector) {}
 
   bool CanBeImmediate(int32_t value) const {
     return Assembler::ImmediateFitsAddrMode1Instruction(value);
@@ -79,24 +82,27 @@ class ArmOperandGenerator : public OperandGenerator {
 
 namespace {
 
-void VisitRR(InstructionSelector* selector, InstructionCode opcode,
+template <typename Adapter>
+void VisitRR(InstructionSelectorT<Adapter>* selector, InstructionCode opcode,
              Node* node) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)));
 }
 
-void VisitRRR(InstructionSelector* selector, InstructionCode opcode,
+template <typename Adapter>
+void VisitRRR(InstructionSelectorT<Adapter>* selector, InstructionCode opcode,
               Node* node) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)),
                  g.UseRegister(node->InputAt(1)));
 }
 
-void VisitSimdShiftRRR(InstructionSelector* selector, ArchOpcode opcode,
-                       Node* node, int width) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitSimdShiftRRR(InstructionSelectorT<Adapter>* selector,
+                       ArchOpcode opcode, Node* node, int width) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   Int32Matcher m(node->InputAt(1));
   if (m.HasResolvedValue()) {
     if (m.IsMultipleOf(width)) {
@@ -112,9 +118,10 @@ void VisitSimdShiftRRR(InstructionSelector* selector, ArchOpcode opcode,
 }
 
 #if V8_ENABLE_WEBASSEMBLY
-void VisitRRRShuffle(InstructionSelector* selector, ArchOpcode opcode,
+template <typename Adapter>
+void VisitRRRShuffle(InstructionSelectorT<Adapter>* selector, ArchOpcode opcode,
                      Node* node) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   // Swap inputs to save an instruction in the CodeGenerator for High ops.
   if (opcode == kArmS32x4ZipRight || opcode == kArmS32x4UnzipRight ||
       opcode == kArmS32x4TransposeRight || opcode == kArmS16x8ZipRight ||
@@ -134,28 +141,32 @@ void VisitRRRShuffle(InstructionSelector* selector, ArchOpcode opcode,
 }
 #endif  // V8_ENABLE_WEBASSEMBLY
 
-void VisitRRI(InstructionSelector* selector, ArchOpcode opcode, Node* node) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitRRI(InstructionSelectorT<Adapter>* selector, ArchOpcode opcode,
+              Node* node) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   int32_t imm = OpParameter<int32_t>(node->op());
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)), g.UseImmediate(imm));
 }
 
-void VisitRRIR(InstructionSelector* selector, ArchOpcode opcode, Node* node) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitRRIR(InstructionSelectorT<Adapter>* selector, ArchOpcode opcode,
+               Node* node) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   int32_t imm = OpParameter<int32_t>(node->op());
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)), g.UseImmediate(imm),
                  g.UseUniqueRegister(node->InputAt(1)));
 }
 
-template <IrOpcode::Value kOpcode, int kImmMin, int kImmMax,
+template <typename Adapter, IrOpcode::Value kOpcode, int kImmMin, int kImmMax,
           AddressingMode kImmMode, AddressingMode kRegMode>
-bool TryMatchShift(InstructionSelector* selector,
+bool TryMatchShift(InstructionSelectorT<Adapter>* selector,
                    InstructionCode* opcode_return, Node* node,
                    InstructionOperand* value_return,
                    InstructionOperand* shift_return) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   if (node->opcode() == kOpcode) {
     Int32BinopMatcher m(node);
     *value_return = g.UseRegister(m.left().node());
@@ -171,13 +182,13 @@ bool TryMatchShift(InstructionSelector* selector,
   return false;
 }
 
-template <IrOpcode::Value kOpcode, int kImmMin, int kImmMax,
+template <typename Adapter, IrOpcode::Value kOpcode, int kImmMin, int kImmMax,
           AddressingMode kImmMode>
-bool TryMatchShiftImmediate(InstructionSelector* selector,
+bool TryMatchShiftImmediate(InstructionSelectorT<Adapter>* selector,
                             InstructionCode* opcode_return, Node* node,
                             InstructionOperand* value_return,
                             InstructionOperand* shift_return) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   if (node->opcode() == kOpcode) {
     Int32BinopMatcher m(node);
     if (m.right().IsInRange(kImmMin, kImmMax)) {
@@ -190,48 +201,58 @@ bool TryMatchShiftImmediate(InstructionSelector* selector,
   return false;
 }
 
-bool TryMatchROR(InstructionSelector* selector, InstructionCode* opcode_return,
-                 Node* node, InstructionOperand* value_return,
+template <typename Adapter>
+bool TryMatchROR(InstructionSelectorT<Adapter>* selector,
+                 InstructionCode* opcode_return, Node* node,
+                 InstructionOperand* value_return,
                  InstructionOperand* shift_return) {
-  return TryMatchShift<IrOpcode::kWord32Ror, 1, 31, kMode_Operand2_R_ROR_I,
-                       kMode_Operand2_R_ROR_R>(selector, opcode_return, node,
-                                               value_return, shift_return);
+  return TryMatchShift<Adapter, IrOpcode::kWord32Ror, 1, 31,
+                       kMode_Operand2_R_ROR_I, kMode_Operand2_R_ROR_R>(
+      selector, opcode_return, node, value_return, shift_return);
 }
 
-bool TryMatchASR(InstructionSelector* selector, InstructionCode* opcode_return,
-                 Node* node, InstructionOperand* value_return,
+template <typename Adapter>
+bool TryMatchASR(InstructionSelectorT<Adapter>* selector,
+                 InstructionCode* opcode_return, Node* node,
+                 InstructionOperand* value_return,
                  InstructionOperand* shift_return) {
-  return TryMatchShift<IrOpcode::kWord32Sar, 1, 32, kMode_Operand2_R_ASR_I,
-                       kMode_Operand2_R_ASR_R>(selector, opcode_return, node,
-                                               value_return, shift_return);
+  return TryMatchShift<Adapter, IrOpcode::kWord32Sar, 1, 32,
+                       kMode_Operand2_R_ASR_I, kMode_Operand2_R_ASR_R>(
+      selector, opcode_return, node, value_return, shift_return);
 }
 
-bool TryMatchLSL(InstructionSelector* selector, InstructionCode* opcode_return,
-                 Node* node, InstructionOperand* value_return,
+template <typename Adapter>
+bool TryMatchLSL(InstructionSelectorT<Adapter>* selector,
+                 InstructionCode* opcode_return, Node* node,
+                 InstructionOperand* value_return,
                  InstructionOperand* shift_return) {
-  return TryMatchShift<IrOpcode::kWord32Shl, 0, 31, kMode_Operand2_R_LSL_I,
-                       kMode_Operand2_R_LSL_R>(selector, opcode_return, node,
-                                               value_return, shift_return);
+  return TryMatchShift<Adapter, IrOpcode::kWord32Shl, 0, 31,
+                       kMode_Operand2_R_LSL_I, kMode_Operand2_R_LSL_R>(
+      selector, opcode_return, node, value_return, shift_return);
 }
 
-bool TryMatchLSLImmediate(InstructionSelector* selector,
+template <typename Adapter>
+bool TryMatchLSLImmediate(InstructionSelectorT<Adapter>* selector,
                           InstructionCode* opcode_return, Node* node,
                           InstructionOperand* value_return,
                           InstructionOperand* shift_return) {
-  return TryMatchShiftImmediate<IrOpcode::kWord32Shl, 0, 31,
+  return TryMatchShiftImmediate<Adapter, IrOpcode::kWord32Shl, 0, 31,
                                 kMode_Operand2_R_LSL_I>(
       selector, opcode_return, node, value_return, shift_return);
 }
 
-bool TryMatchLSR(InstructionSelector* selector, InstructionCode* opcode_return,
-                 Node* node, InstructionOperand* value_return,
+template <typename Adapter>
+bool TryMatchLSR(InstructionSelectorT<Adapter>* selector,
+                 InstructionCode* opcode_return, Node* node,
+                 InstructionOperand* value_return,
                  InstructionOperand* shift_return) {
-  return TryMatchShift<IrOpcode::kWord32Shr, 1, 32, kMode_Operand2_R_LSR_I,
-                       kMode_Operand2_R_LSR_R>(selector, opcode_return, node,
-                                               value_return, shift_return);
+  return TryMatchShift<Adapter, IrOpcode::kWord32Shr, 1, 32,
+                       kMode_Operand2_R_LSR_I, kMode_Operand2_R_LSR_R>(
+      selector, opcode_return, node, value_return, shift_return);
 }
 
-bool TryMatchShift(InstructionSelector* selector,
+template <typename Adapter>
+bool TryMatchShift(InstructionSelectorT<Adapter>* selector,
                    InstructionCode* opcode_return, Node* node,
                    InstructionOperand* value_return,
                    InstructionOperand* shift_return) {
@@ -242,11 +263,12 @@ bool TryMatchShift(InstructionSelector* selector,
       TryMatchROR(selector, opcode_return, node, value_return, shift_return));
 }
 
-bool TryMatchImmediateOrShift(InstructionSelector* selector,
+template <typename Adapter>
+bool TryMatchImmediateOrShift(InstructionSelectorT<Adapter>* selector,
                               InstructionCode* opcode_return, Node* node,
                               size_t* input_count_return,
                               InstructionOperand* inputs) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   if (g.CanBeImmediate(node, *opcode_return)) {
     *opcode_return |= AddressingModeField::encode(kMode_Operand2_I);
     inputs[0] = g.UseImmediate(node);
@@ -260,10 +282,11 @@ bool TryMatchImmediateOrShift(InstructionSelector* selector,
   return false;
 }
 
-void VisitBinop(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                 InstructionCode opcode, InstructionCode reverse_opcode,
                 FlagsContinuation* cont) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   Int32BinopMatcher m(node);
   InstructionOperand inputs[3];
   size_t input_count = 0;
@@ -310,17 +333,19 @@ void VisitBinop(InstructionSelector* selector, Node* node,
                                  inputs, cont);
 }
 
-void VisitBinop(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                 InstructionCode opcode, InstructionCode reverse_opcode) {
   FlagsContinuation cont;
   VisitBinop(selector, node, opcode, reverse_opcode, &cont);
 }
 
-void EmitDiv(InstructionSelector* selector, ArchOpcode div_opcode,
+template <typename Adapter>
+void EmitDiv(InstructionSelectorT<Adapter>* selector, ArchOpcode div_opcode,
              ArchOpcode f64i32_opcode, ArchOpcode i32f64_opcode,
              InstructionOperand result_operand, InstructionOperand left_operand,
              InstructionOperand right_operand) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   if (selector->IsSupported(SUDIV)) {
     selector->Emit(div_opcode, result_operand, left_operand, right_operand);
     return;
@@ -335,18 +360,22 @@ void EmitDiv(InstructionSelector* selector, ArchOpcode div_opcode,
   selector->Emit(i32f64_opcode, result_operand, result_double_operand);
 }
 
-void VisitDiv(InstructionSelector* selector, Node* node, ArchOpcode div_opcode,
-              ArchOpcode f64i32_opcode, ArchOpcode i32f64_opcode) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitDiv(InstructionSelectorT<Adapter>* selector, Node* node,
+              ArchOpcode div_opcode, ArchOpcode f64i32_opcode,
+              ArchOpcode i32f64_opcode) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   Int32BinopMatcher m(node);
   EmitDiv(selector, div_opcode, f64i32_opcode, i32f64_opcode,
           g.DefineAsRegister(node), g.UseRegister(m.left().node()),
           g.UseRegister(m.right().node()));
 }
 
-void VisitMod(InstructionSelector* selector, Node* node, ArchOpcode div_opcode,
-              ArchOpcode f64i32_opcode, ArchOpcode i32f64_opcode) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitMod(InstructionSelectorT<Adapter>* selector, Node* node,
+              ArchOpcode div_opcode, ArchOpcode f64i32_opcode,
+              ArchOpcode i32f64_opcode) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   Int32BinopMatcher m(node);
   InstructionOperand div_operand = g.TempRegister();
   InstructionOperand result_operand = g.DefineAsRegister(node);
@@ -370,11 +399,12 @@ void VisitMod(InstructionSelector* selector, Node* node, ArchOpcode div_opcode,
 // vld1 and vst1, when given two registers, will post-increment the offset, i.e.
 // perform the operation at base, then add offset to base. What we intend is to
 // access at (base+offset).
-void EmitAddBeforeS128LoadStore(InstructionSelector* selector,
+template <typename Adapter>
+void EmitAddBeforeS128LoadStore(InstructionSelectorT<Adapter>* selector,
                                 InstructionCode* opcode_return,
                                 size_t* input_count_return,
                                 InstructionOperand* inputs) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   InstructionOperand addr = g.TempRegister();
   InstructionCode op = kArmAdd;
   op |= AddressingModeField::encode(kMode_Operand2_R);
@@ -384,9 +414,10 @@ void EmitAddBeforeS128LoadStore(InstructionSelector* selector,
   inputs[0] = addr;
 }
 
-void EmitLoad(InstructionSelector* selector, InstructionCode opcode,
+template <typename Adapter>
+void EmitLoad(InstructionSelectorT<Adapter>* selector, InstructionCode opcode,
               InstructionOperand* output, Node* base, Node* index) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   InstructionOperand inputs[3];
   size_t input_count = 2;
 
@@ -435,9 +466,10 @@ void EmitLoad(InstructionSelector* selector, InstructionCode opcode,
   selector->Emit(opcode, 1, output, input_count, inputs);
 }
 
-void EmitStore(InstructionSelector* selector, InstructionCode opcode,
+template <typename Adapter>
+void EmitStore(InstructionSelectorT<Adapter>* selector, InstructionCode opcode,
                size_t input_count, InstructionOperand* inputs, Node* index) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   ArchOpcode arch_opcode = ArchOpcodeField::decode(opcode);
 
   if (g.CanBeImmediate(index, opcode)) {
@@ -459,9 +491,10 @@ void EmitStore(InstructionSelector* selector, InstructionCode opcode,
   selector->Emit(opcode, 0, nullptr, input_count, inputs);
 }
 
-void VisitPairAtomicBinOp(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitPairAtomicBinOp(InstructionSelectorT<Adapter>* selector, Node* node,
                           ArchOpcode opcode) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -497,7 +530,8 @@ void VisitPairAtomicBinOp(InstructionSelector* selector, Node* node,
 
 }  // namespace
 
-void InstructionSelector::VisitStackSlot(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStackSlot(Node* node) {
   StackSlotRepresentation rep = StackSlotRepresentationOf(node->op());
   int slot = frame_->AllocateSpillSlot(rep.size(), rep.alignment());
   OperandGenerator g(this);
@@ -506,19 +540,21 @@ void InstructionSelector::VisitStackSlot(Node* node) {
        sequence()->AddImmediate(Constant(slot)), 0, nullptr);
 }
 
-void InstructionSelector::VisitAbortCSADcheck(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitAbortCSADcheck(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArchAbortCSADcheck, g.NoOutput(), g.UseFixed(node->InputAt(0), r1));
 }
 
-void InstructionSelector::VisitStoreLane(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStoreLane(Node* node) {
   StoreLaneParameters params = StoreLaneParametersOf(node->op());
   LoadStoreLaneParams f(params.rep, params.laneidx);
   InstructionCode opcode =
       f.low_op ? kArmS128StoreLaneLow : kArmS128StoreLaneHigh;
   opcode |= MiscField::encode(f.sz);
 
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand inputs[4];
   size_t input_count = 4;
   inputs[0] = g.UseRegister(node->InputAt(2));
@@ -529,14 +565,15 @@ void InstructionSelector::VisitStoreLane(Node* node) {
   Emit(opcode, 0, nullptr, input_count, inputs);
 }
 
-void InstructionSelector::VisitLoadLane(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoadLane(Node* node) {
   LoadLaneParameters params = LoadLaneParametersOf(node->op());
   LoadStoreLaneParams f(params.rep.representation(), params.laneidx);
   InstructionCode opcode =
       f.low_op ? kArmS128LoadLaneLow : kArmS128LoadLaneHigh;
   opcode |= MiscField::encode(f.sz);
 
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand output = g.DefineSameAsFirst(node);
   InstructionOperand inputs[4];
   size_t input_count = 4;
@@ -548,7 +585,8 @@ void InstructionSelector::VisitLoadLane(Node* node) {
   Emit(opcode, 1, &output, input_count, inputs);
 }
 
-void InstructionSelector::VisitLoadTransform(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoadTransform(Node* node) {
   LoadTransformParameters params = LoadTransformParametersOf(node->op());
   InstructionCode opcode = kArchNop;
   switch (params.transformation) {
@@ -592,7 +630,7 @@ void InstructionSelector::VisitLoadTransform(Node* node) {
       UNIMPLEMENTED();
   }
 
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand output = g.DefineAsRegister(node);
   InstructionOperand inputs[2];
   size_t input_count = 2;
@@ -602,9 +640,10 @@ void InstructionSelector::VisitLoadTransform(Node* node) {
   Emit(opcode, 1, &output, input_count, inputs);
 }
 
-void InstructionSelector::VisitLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoad(Node* node) {
   LoadRepresentation load_rep = LoadRepresentationOf(node->op());
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -646,7 +685,8 @@ void InstructionSelector::VisitLoad(Node* node) {
   EmitLoad(this, opcode, &output, base, index);
 }
 
-void InstructionSelector::VisitProtectedLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitProtectedLoad(Node* node) {
   // TODO(eholk)
   UNIMPLEMENTED();
 }
@@ -698,10 +738,11 @@ ArchOpcode GetAtomicStoreOpcode(MachineRepresentation rep) {
   }
 }
 
-void VisitStoreCommon(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitStoreCommon(InstructionSelectorT<Adapter>* selector, Node* node,
                       StoreRepresentation store_rep,
                       base::Optional<AtomicMemoryOrder> atomic_order) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -794,22 +835,28 @@ void VisitStoreCommon(InstructionSelector* selector, Node* node,
 
 }  // namespace
 
-void InstructionSelector::VisitStorePair(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStorePair(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitStore(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStore(Node* node) {
   VisitStoreCommon(this, node, StoreRepresentationOf(node->op()),
                    base::nullopt);
 }
 
-void InstructionSelector::VisitProtectedStore(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitProtectedStore(Node* node) {
   // TODO(eholk)
   UNIMPLEMENTED();
 }
 
-void InstructionSelector::VisitUnalignedLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUnalignedLoad(Node* node) {
   MachineRepresentation load_rep =
       LoadRepresentationOf(node->op()).representation();
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -871,8 +918,9 @@ void InstructionSelector::VisitUnalignedLoad(Node* node) {
   }
 }
 
-void InstructionSelector::VisitUnalignedStore(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUnalignedStore(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -959,9 +1007,10 @@ void InstructionSelector::VisitUnalignedStore(Node* node) {
 
 namespace {
 
-void EmitBic(InstructionSelector* selector, Node* node, Node* left,
+template <typename Adapter>
+void EmitBic(InstructionSelectorT<Adapter>* selector, Node* node, Node* left,
              Node* right) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   InstructionCode opcode = kArmBic;
   InstructionOperand value_operand;
   InstructionOperand shift_operand;
@@ -975,20 +1024,22 @@ void EmitBic(InstructionSelector* selector, Node* node, Node* left,
                  g.UseRegister(right));
 }
 
-void EmitUbfx(InstructionSelector* selector, Node* node, Node* left,
+template <typename Adapter>
+void EmitUbfx(InstructionSelectorT<Adapter>* selector, Node* node, Node* left,
               uint32_t lsb, uint32_t width) {
   DCHECK_LE(lsb, 31u);
   DCHECK_LE(1u, width);
   DCHECK_LE(width, 32u - lsb);
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   selector->Emit(kArmUbfx, g.DefineAsRegister(node), g.UseRegister(left),
                  g.TempImmediate(lsb), g.TempImmediate(width));
 }
 
 }  // namespace
 
-void InstructionSelector::VisitWord32And(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32And(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (m.left().IsWord32Xor() && CanCover(node, m.left().node())) {
     Int32BinopMatcher mleft(m.left().node());
@@ -1084,12 +1135,14 @@ void InstructionSelector::VisitWord32And(Node* node) {
   VisitBinop(this, node, kArmAnd, kArmAnd);
 }
 
-void InstructionSelector::VisitWord32Or(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Or(Node* node) {
   VisitBinop(this, node, kArmOrr, kArmOrr);
 }
 
-void InstructionSelector::VisitWord32Xor(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Xor(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (m.right().Is(-1)) {
     InstructionCode opcode = kArmMvn;
@@ -1107,13 +1160,14 @@ void InstructionSelector::VisitWord32Xor(Node* node) {
   VisitBinop(this, node, kArmEor, kArmEor);
 }
 
-void InstructionSelector::VisitStackPointerGreaterThan(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStackPointerGreaterThan(
     Node* node, FlagsContinuation* cont) {
   StackCheckKind kind = StackCheckKindOf(node->op());
   InstructionCode opcode =
       kArchStackPointerGreaterThan | MiscField::encode(static_cast<int>(kind));
 
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
 
   // No outputs.
   InstructionOperand* const outputs = nullptr;
@@ -1138,10 +1192,10 @@ void InstructionSelector::VisitStackPointerGreaterThan(
 
 namespace {
 
-template <typename TryMatchShift>
-void VisitShift(InstructionSelector* selector, Node* node,
+template <typename Adapter, typename TryMatchShift>
+void VisitShift(InstructionSelectorT<Adapter>* selector, Node* node,
                 TryMatchShift try_match_shift, FlagsContinuation* cont) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   InstructionCode opcode = kArmMov;
   InstructionOperand inputs[2];
   size_t input_count = 2;
@@ -1162,8 +1216,8 @@ void VisitShift(InstructionSelector* selector, Node* node,
                                  inputs, cont);
 }
 
-template <typename TryMatchShift>
-void VisitShift(InstructionSelector* selector, Node* node,
+template <typename Adapter, typename TryMatchShift>
+void VisitShift(InstructionSelectorT<Adapter>* selector, Node* node,
                 TryMatchShift try_match_shift) {
   FlagsContinuation cont;
   VisitShift(selector, node, try_match_shift, &cont);
@@ -1171,12 +1225,14 @@ void VisitShift(InstructionSelector* selector, Node* node,
 
 }  // namespace
 
-void InstructionSelector::VisitWord32Shl(Node* node) {
-  VisitShift(this, node, TryMatchLSL);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Shl(Node* node) {
+  VisitShift(this, node, TryMatchLSL<Adapter>);
 }
 
-void InstructionSelector::VisitWord32Shr(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Shr(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (IsSupported(ARMv7) && m.left().IsWord32And() &&
       m.right().IsInRange(0, 31)) {
@@ -1193,11 +1249,12 @@ void InstructionSelector::VisitWord32Shr(Node* node) {
       }
     }
   }
-  VisitShift(this, node, TryMatchLSR);
+  VisitShift(this, node, TryMatchLSR<Adapter>);
 }
 
-void InstructionSelector::VisitWord32Sar(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Sar(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (CanCover(m.node(), m.left().node()) && m.left().IsWord32Shl()) {
     Int32BinopMatcher mleft(m.left().node());
@@ -1220,11 +1277,12 @@ void InstructionSelector::VisitWord32Sar(Node* node) {
       }
     }
   }
-  VisitShift(this, node, TryMatchASR);
+  VisitShift(this, node, TryMatchASR<Adapter>);
 }
 
-void InstructionSelector::VisitInt32PairAdd(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32PairAdd(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
 
   Node* projection1 = NodeProperties::FindProjection(node, 1);
   if (projection1) {
@@ -1248,8 +1306,9 @@ void InstructionSelector::VisitInt32PairAdd(Node* node) {
   }
 }
 
-void InstructionSelector::VisitInt32PairSub(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32PairSub(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
 
   Node* projection1 = NodeProperties::FindProjection(node, 1);
   if (projection1) {
@@ -1273,8 +1332,9 @@ void InstructionSelector::VisitInt32PairSub(Node* node) {
   }
 }
 
-void InstructionSelector::VisitInt32PairMul(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32PairMul(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* projection1 = NodeProperties::FindProjection(node, 1);
   if (projection1) {
     InstructionOperand inputs[] = {g.UseUniqueRegister(node->InputAt(0)),
@@ -1298,9 +1358,10 @@ void InstructionSelector::VisitInt32PairMul(Node* node) {
 
 namespace {
 // Shared routine for multiple shift operations.
-void VisitWord32PairShift(InstructionSelector* selector, InstructionCode opcode,
-                          Node* node) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitWord32PairShift(InstructionSelectorT<Adapter>* selector,
+                          InstructionCode opcode, Node* node) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   // We use g.UseUniqueRegister here to guarantee that there is
   // no register aliasing of input registers with output registers.
   Int32Matcher m(node->InputAt(2));
@@ -1332,45 +1393,65 @@ void VisitWord32PairShift(InstructionSelector* selector, InstructionCode opcode,
   selector->Emit(opcode, output_count, outputs, 3, inputs, temp_count, temps);
 }
 }  // namespace
-void InstructionSelector::VisitWord32PairShl(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32PairShl(Node* node) {
   VisitWord32PairShift(this, kArmLslPair, node);
 }
 
-void InstructionSelector::VisitWord32PairShr(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32PairShr(Node* node) {
   VisitWord32PairShift(this, kArmLsrPair, node);
 }
 
-void InstructionSelector::VisitWord32PairSar(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32PairSar(Node* node) {
   VisitWord32PairShift(this, kArmAsrPair, node);
 }
 
-void InstructionSelector::VisitWord32Rol(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Rol(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord32Ror(Node* node) {
-  VisitShift(this, node, TryMatchROR);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Ror(Node* node) {
+  VisitShift(this, node, TryMatchROR<Adapter>);
 }
 
-void InstructionSelector::VisitWord32Ctz(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Ctz(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord32ReverseBits(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32ReverseBits(Node* node) {
   DCHECK(IsSupported(ARMv7));
   VisitRR(this, kArmRbit, node);
 }
 
-void InstructionSelector::VisitWord64ReverseBytes(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64ReverseBytes(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord32ReverseBytes(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32ReverseBytes(Node* node) {
   VisitRR(this, kArmRev, node);
 }
 
-void InstructionSelector::VisitSimd128ReverseBytes(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSimd128ReverseBytes(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitWord32Popcnt(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Popcnt(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitInt32Add(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Add(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (CanCover(node, m.left().node())) {
     switch (m.left().opcode()) {
@@ -1487,8 +1568,9 @@ void InstructionSelector::VisitInt32Add(Node* node) {
   VisitBinop(this, node, kArmAdd, kArmAdd);
 }
 
-void InstructionSelector::VisitInt32Sub(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Sub(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (IsSupported(ARMv7) && m.right().IsInt32Mul() &&
       CanCover(node, m.right().node())) {
@@ -1502,9 +1584,10 @@ void InstructionSelector::VisitInt32Sub(Node* node) {
 
 namespace {
 
-void EmitInt32MulWithOverflow(InstructionSelector* selector, Node* node,
-                              FlagsContinuation* cont) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void EmitInt32MulWithOverflow(InstructionSelectorT<Adapter>* selector,
+                              Node* node, FlagsContinuation* cont) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   Int32BinopMatcher m(node);
   InstructionOperand result_operand = g.DefineAsRegister(node);
   InstructionOperand temp_operand = g.TempRegister();
@@ -1523,8 +1606,9 @@ void EmitInt32MulWithOverflow(InstructionSelector* selector, Node* node,
 
 }  // namespace
 
-void InstructionSelector::VisitInt32Mul(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Mul(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (m.right().HasResolvedValue() && m.right().ResolvedValue() > 0) {
     int32_t value = m.right().ResolvedValue();
@@ -1546,27 +1630,32 @@ void InstructionSelector::VisitInt32Mul(Node* node) {
   VisitRRR(this, kArmMul, node);
 }
 
-void InstructionSelector::VisitUint32MulHigh(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32MulHigh(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand outputs[] = {g.TempRegister(), g.DefineAsRegister(node)};
   InstructionOperand inputs[] = {g.UseRegister(node->InputAt(0)),
                                  g.UseRegister(node->InputAt(1))};
   Emit(kArmUmull, arraysize(outputs), outputs, arraysize(inputs), inputs);
 }
 
-void InstructionSelector::VisitInt32Div(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Div(Node* node) {
   VisitDiv(this, node, kArmSdiv, kArmVcvtF64S32, kArmVcvtS32F64);
 }
 
-void InstructionSelector::VisitUint32Div(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32Div(Node* node) {
   VisitDiv(this, node, kArmUdiv, kArmVcvtF64U32, kArmVcvtU32F64);
 }
 
-void InstructionSelector::VisitInt32Mod(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Mod(Node* node) {
   VisitMod(this, node, kArmSdiv, kArmVcvtF64S32, kArmVcvtS32F64);
 }
 
-void InstructionSelector::VisitUint32Mod(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32Mod(Node* node) {
   VisitMod(this, node, kArmUdiv, kArmVcvtF64U32, kArmVcvtU32F64);
 }
 
@@ -1625,33 +1714,37 @@ void InstructionSelector::VisitUint32Mod(Node* node) {
   V(Float32Min, kArmFloat32Min) \
   V(Float64Min, kArmFloat64Min)
 
-#define RR_VISITOR(Name, opcode)                      \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRR(this, opcode, node);                      \
+#define RR_VISITOR(Name, opcode)                                \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRR(this, opcode, node);                                \
   }
 RR_OP_LIST(RR_VISITOR)
 #undef RR_VISITOR
 #undef RR_OP_LIST
 
-#define RR_VISITOR_V8(Name, opcode)                   \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    DCHECK(CpuFeatures::IsSupported(ARMv8));          \
-    VisitRR(this, opcode, node);                      \
+#define RR_VISITOR_V8(Name, opcode)                             \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    DCHECK(CpuFeatures::IsSupported(ARMv8));                    \
+    VisitRR(this, opcode, node);                                \
   }
 RR_OP_LIST_V8(RR_VISITOR_V8)
 #undef RR_VISITOR_V8
 #undef RR_OP_LIST_V8
 
-#define RRR_VISITOR(Name, opcode)                     \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRRR(this, opcode, node);                     \
+#define RRR_VISITOR(Name, opcode)                               \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRRR(this, opcode, node);                               \
   }
 RRR_OP_LIST(RRR_VISITOR)
 #undef RRR_VISITOR
 #undef RRR_OP_LIST
 
-void InstructionSelector::VisitFloat32Add(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Add(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Float32BinopMatcher m(node);
   if (m.left().IsFloat32Mul() && CanCover(node, m.left().node())) {
     Float32BinopMatcher mleft(m.left().node());
@@ -1670,8 +1763,9 @@ void InstructionSelector::VisitFloat32Add(Node* node) {
   VisitRRR(this, kArmVaddF32, node);
 }
 
-void InstructionSelector::VisitFloat64Add(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Add(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Float64BinopMatcher m(node);
   if (m.left().IsFloat64Mul() && CanCover(node, m.left().node())) {
     Float64BinopMatcher mleft(m.left().node());
@@ -1690,8 +1784,9 @@ void InstructionSelector::VisitFloat64Add(Node* node) {
   VisitRRR(this, kArmVaddF64, node);
 }
 
-void InstructionSelector::VisitFloat32Sub(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Sub(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Float32BinopMatcher m(node);
   if (m.right().IsFloat32Mul() && CanCover(node, m.right().node())) {
     Float32BinopMatcher mright(m.right().node());
@@ -1703,8 +1798,9 @@ void InstructionSelector::VisitFloat32Sub(Node* node) {
   VisitRRR(this, kArmVsubF32, node);
 }
 
-void InstructionSelector::VisitFloat64Sub(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Sub(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Float64BinopMatcher m(node);
   if (m.right().IsFloat64Mul() && CanCover(node, m.right().node())) {
     Float64BinopMatcher mright(m.right().node());
@@ -1716,37 +1812,43 @@ void InstructionSelector::VisitFloat64Sub(Node* node) {
   VisitRRR(this, kArmVsubF64, node);
 }
 
-void InstructionSelector::VisitFloat64Mod(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Mod(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmVmodF64, g.DefineAsFixed(node, d0), g.UseFixed(node->InputAt(0), d0),
        g.UseFixed(node->InputAt(1), d1))
       ->MarkAsCall();
 }
 
-void InstructionSelector::VisitFloat64Ieee754Binop(Node* node,
-                                                   InstructionCode opcode) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Ieee754Binop(
+    Node* node, InstructionCode opcode) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(opcode, g.DefineAsFixed(node, d0), g.UseFixed(node->InputAt(0), d0),
        g.UseFixed(node->InputAt(1), d1))
       ->MarkAsCall();
 }
 
-void InstructionSelector::VisitFloat64Ieee754Unop(Node* node,
-                                                  InstructionCode opcode) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Ieee754Unop(
+    Node* node, InstructionCode opcode) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(opcode, g.DefineAsFixed(node, d0), g.UseFixed(node->InputAt(0), d0))
       ->MarkAsCall();
 }
 
-void InstructionSelector::EmitMoveParamToFPR(Node* node, int index) {}
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitMoveParamToFPR(Node* node, int index) {}
 
-void InstructionSelector::EmitMoveFPRToParam(InstructionOperand* op,
-                                             LinkageLocation location) {}
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitMoveFPRToParam(
+    InstructionOperand* op, LinkageLocation location) {}
 
-void InstructionSelector::EmitPrepareArguments(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitPrepareArguments(
     ZoneVector<PushParameter>* arguments, const CallDescriptor* call_descriptor,
     Node* node) {
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
 
   // Prepare for C function call.
   if (call_descriptor->IsCFunctionCall()) {
@@ -1777,10 +1879,11 @@ void InstructionSelector::EmitPrepareArguments(
   }
 }
 
-void InstructionSelector::EmitPrepareResults(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitPrepareResults(
     ZoneVector<PushParameter>* results, const CallDescriptor* call_descriptor,
     Node* node) {
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
 
   for (PushParameter output : *results) {
     if (!output.location.IsCallerFrameSlot()) continue;
@@ -1802,21 +1905,26 @@ void InstructionSelector::EmitPrepareResults(
   }
 }
 
-bool InstructionSelector::IsTailCallAddressImmediate() { return false; }
+template <typename Adapter>
+bool InstructionSelectorT<Adapter>::IsTailCallAddressImmediate() {
+  return false;
+}
 
 namespace {
 
 // Shared routine for multiple compare operations.
-void VisitCompare(InstructionSelector* selector, InstructionCode opcode,
-                  InstructionOperand left, InstructionOperand right,
-                  FlagsContinuation* cont) {
+template <typename Adapter>
+void VisitCompare(InstructionSelectorT<Adapter>* selector,
+                  InstructionCode opcode, InstructionOperand left,
+                  InstructionOperand right, FlagsContinuation* cont) {
   selector->EmitWithContinuation(opcode, left, right, cont);
 }
 
 // Shared routine for multiple float32 compare operations.
-void VisitFloat32Compare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitFloat32Compare(InstructionSelectorT<Adapter>* selector, Node* node,
                          FlagsContinuation* cont) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   Float32BinopMatcher m(node);
   if (m.right().Is(0.0f)) {
     VisitCompare(selector, kArmVcmpF32, g.UseRegister(m.left().node()),
@@ -1832,9 +1940,10 @@ void VisitFloat32Compare(InstructionSelector* selector, Node* node,
 }
 
 // Shared routine for multiple float64 compare operations.
-void VisitFloat64Compare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitFloat64Compare(InstructionSelectorT<Adapter>* selector, Node* node,
                          FlagsContinuation* cont) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   Float64BinopMatcher m(node);
   if (m.right().Is(0.0)) {
     VisitCompare(selector, kArmVcmpF64, g.UseRegister(m.left().node()),
@@ -1901,11 +2010,10 @@ FlagsCondition MapForFlagSettingBinop(FlagsCondition cond) {
 // (a <ops> b), b.<cond'>
 // where <ops> is the flag setting version of <op>, and if so,
 // updates {node}, {opcode} and {cont} accordingly.
-void MaybeReplaceCmpZeroWithFlagSettingBinop(InstructionSelector* selector,
-                                             Node** node, Node* binop,
-                                             InstructionCode* opcode,
-                                             FlagsCondition cond,
-                                             FlagsContinuation* cont) {
+template <typename Adapter>
+void MaybeReplaceCmpZeroWithFlagSettingBinop(
+    InstructionSelectorT<Adapter>* selector, Node** node, Node* binop,
+    InstructionCode* opcode, FlagsCondition cond, FlagsContinuation* cont) {
   InstructionCode binop_opcode;
   InstructionCode no_output_opcode;
   switch (binop->opcode()) {
@@ -1944,9 +2052,10 @@ void MaybeReplaceCmpZeroWithFlagSettingBinop(InstructionSelector* selector,
 }
 
 // Shared routine for multiple word compare operations.
-void VisitWordCompare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitWordCompare(InstructionSelectorT<Adapter>* selector, Node* node,
                       InstructionCode opcode, FlagsContinuation* cont) {
-  ArmOperandGenerator g(selector);
+  ArmOperandGeneratorT<Adapter> g(selector);
   Int32BinopMatcher m(node);
   InstructionOperand inputs[3];
   size_t input_count = 0;
@@ -1989,7 +2098,8 @@ void VisitWordCompare(InstructionSelector* selector, Node* node,
                                  inputs, cont);
 }
 
-void VisitWordCompare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitWordCompare(InstructionSelectorT<Adapter>* selector, Node* node,
                       FlagsContinuation* cont) {
   InstructionCode opcode = kArmCmp;
   Int32BinopMatcher m(node);
@@ -2022,8 +2132,9 @@ void VisitWordCompare(InstructionSelector* selector, Node* node,
 }  // namespace
 
 // Shared routine for word comparisons against zero.
-void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
-                                               FlagsContinuation* cont) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWordCompareZero(
+    Node* user, Node* value, FlagsContinuation* cont) {
   // Try to combine with comparisons against 0 by simply inverting the branch.
   while (value->opcode() == IrOpcode::kWord32Equal && CanCover(user, value)) {
     Int32BinopMatcher m(value);
@@ -2112,13 +2223,13 @@ void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
       case IrOpcode::kWord32Xor:
         return VisitWordCompare(this, value, kArmTeq, cont);
       case IrOpcode::kWord32Sar:
-        return VisitShift(this, value, TryMatchASR, cont);
+        return VisitShift(this, value, TryMatchASR<Adapter>, cont);
       case IrOpcode::kWord32Shl:
-        return VisitShift(this, value, TryMatchLSL, cont);
+        return VisitShift(this, value, TryMatchLSL<Adapter>, cont);
       case IrOpcode::kWord32Shr:
-        return VisitShift(this, value, TryMatchLSR, cont);
+        return VisitShift(this, value, TryMatchLSR<Adapter>, cont);
       case IrOpcode::kWord32Ror:
-        return VisitShift(this, value, TryMatchROR, cont);
+        return VisitShift(this, value, TryMatchROR<Adapter>, cont);
       case IrOpcode::kStackPointerGreaterThan:
         cont->OverwriteAndNegateIfEqual(kStackPointerGreaterThanCondition);
         return VisitStackPointerGreaterThan(value, cont);
@@ -2132,15 +2243,17 @@ void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
   }
 
   // Continuation could not be combined with a compare, emit compare against 0.
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionCode const opcode =
       kArmTst | AddressingModeField::encode(kMode_Operand2_R);
   InstructionOperand const value_operand = g.UseRegister(value);
   EmitWithContinuation(opcode, value_operand, value_operand, cont);
 }
 
-void InstructionSelector::VisitSwitch(Node* node, const SwitchInfo& sw) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSwitch(Node* node,
+                                                const SwitchInfo& sw) {
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand value_operand = g.UseRegister(node->InputAt(0));
 
   // Emit either ArchTableSwitch or ArchBinarySearchSwitch.
@@ -2170,7 +2283,8 @@ void InstructionSelector::VisitSwitch(Node* node, const SwitchInfo& sw) {
   return EmitBinarySearchSwitch(sw, value_operand);
 }
 
-void InstructionSelector::VisitWord32Equal(Node* const node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Equal(Node* const node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   Int32BinopMatcher m(node);
   if (m.right().Is(0)) {
@@ -2179,29 +2293,34 @@ void InstructionSelector::VisitWord32Equal(Node* const node) {
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kSignedLessThan, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kSignedLessThanOrEqual, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kUnsignedLessThan, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kUnsignedLessThanOrEqual, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32AddWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32AddWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
     return VisitBinop(this, node, kArmAdd, kArmAdd, &cont);
@@ -2210,7 +2329,8 @@ void InstructionSelector::VisitInt32AddWithOverflow(Node* node) {
   VisitBinop(this, node, kArmAdd, kArmAdd, &cont);
 }
 
-void InstructionSelector::VisitInt32SubWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32SubWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
     return VisitBinop(this, node, kArmSub, kArmRsb, &cont);
@@ -2219,7 +2339,8 @@ void InstructionSelector::VisitInt32SubWithOverflow(Node* node) {
   VisitBinop(this, node, kArmSub, kArmRsb, &cont);
 }
 
-void InstructionSelector::VisitInt32MulWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32MulWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     // ARM doesn't set the overflow flag for multiplication, so we need to test
     // on kNotEqual. Here is the code sequence used:
@@ -2232,40 +2353,47 @@ void InstructionSelector::VisitInt32MulWithOverflow(Node* node) {
   EmitInt32MulWithOverflow(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat32Equal(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Equal(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   VisitFloat32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kFloatLessThan, node);
   VisitFloat32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kFloatLessThanOrEqual, node);
   VisitFloat32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64Equal(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Equal(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   VisitFloat64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kFloatLessThan, node);
   VisitFloat64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kFloatLessThanOrEqual, node);
   VisitFloat64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64InsertLowWord32(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64InsertLowWord32(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* left = node->InputAt(0);
   Node* right = node->InputAt(1);
   if (left->opcode() == IrOpcode::kFloat64InsertHighWord32 &&
@@ -2279,8 +2407,9 @@ void InstructionSelector::VisitFloat64InsertLowWord32(Node* node) {
        g.UseRegister(right));
 }
 
-void InstructionSelector::VisitFloat64InsertHighWord32(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64InsertHighWord32(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* left = node->InputAt(0);
   Node* right = node->InputAt(1);
   if (left->opcode() == IrOpcode::kFloat64InsertLowWord32 &&
@@ -2294,19 +2423,21 @@ void InstructionSelector::VisitFloat64InsertHighWord32(Node* node) {
        g.UseRegister(right));
 }
 
-void InstructionSelector::VisitMemoryBarrier(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitMemoryBarrier(Node* node) {
   // Use DMB ISH for both acquire-release and sequentially consistent barriers.
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmDmbIsh, g.NoOutput());
 }
 
-void InstructionSelector::VisitWord32AtomicLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicLoad(Node* node) {
   // The memory order is ignored as both acquire and sequentially consistent
   // loads can emit LDR; DMB ISH.
   // https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html
   AtomicLoadParameters atomic_load_params = AtomicLoadParametersOf(node->op());
   LoadRepresentation load_rep = atomic_load_params.representation();
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   ArchOpcode opcode;
@@ -2330,14 +2461,16 @@ void InstructionSelector::VisitWord32AtomicLoad(Node* node) {
        g.DefineAsRegister(node), g.UseRegister(base), g.UseRegister(index));
 }
 
-void InstructionSelector::VisitWord32AtomicStore(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicStore(Node* node) {
   AtomicStoreParameters store_params = AtomicStoreParametersOf(node->op());
   VisitStoreCommon(this, node, store_params.store_representation(),
                    store_params.order());
 }
 
-void InstructionSelector::VisitWord32AtomicExchange(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicExchange(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -2370,8 +2503,10 @@ void InstructionSelector::VisitWord32AtomicExchange(Node* node) {
   Emit(code, 1, outputs, input_count, inputs, arraysize(temps), temps);
 }
 
-void InstructionSelector::VisitWord32AtomicCompareExchange(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicCompareExchange(
+    Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* old_value = node->InputAt(2);
@@ -2407,10 +2542,11 @@ void InstructionSelector::VisitWord32AtomicCompareExchange(Node* node) {
   Emit(code, 1, outputs, input_count, inputs, arraysize(temps), temps);
 }
 
-void InstructionSelector::VisitWord32AtomicBinaryOperation(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicBinaryOperation(
     Node* node, ArchOpcode int8_op, ArchOpcode uint8_op, ArchOpcode int16_op,
     ArchOpcode uint16_op, ArchOpcode word32_op) {
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -2444,11 +2580,12 @@ void InstructionSelector::VisitWord32AtomicBinaryOperation(
   Emit(code, 1, outputs, input_count, inputs, arraysize(temps), temps);
 }
 
-#define VISIT_ATOMIC_BINOP(op)                                           \
-  void InstructionSelector::VisitWord32Atomic##op(Node* node) {          \
-    VisitWord32AtomicBinaryOperation(                                    \
-        node, kAtomic##op##Int8, kAtomic##op##Uint8, kAtomic##op##Int16, \
-        kAtomic##op##Uint16, kAtomic##op##Word32);                       \
+#define VISIT_ATOMIC_BINOP(op)                                            \
+  template <typename Adapter>                                             \
+  void InstructionSelectorT<Adapter>::VisitWord32Atomic##op(Node* node) { \
+    VisitWord32AtomicBinaryOperation(                                     \
+        node, kAtomic##op##Int8, kAtomic##op##Uint8, kAtomic##op##Int16,  \
+        kAtomic##op##Uint16, kAtomic##op##Word32);                        \
   }
 VISIT_ATOMIC_BINOP(Add)
 VISIT_ATOMIC_BINOP(Sub)
@@ -2457,8 +2594,9 @@ VISIT_ATOMIC_BINOP(Or)
 VISIT_ATOMIC_BINOP(Xor)
 #undef VISIT_ATOMIC_BINOP
 
-void InstructionSelector::VisitWord32AtomicPairLoad(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairLoad(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   InstructionOperand inputs[3];
@@ -2491,8 +2629,9 @@ void InstructionSelector::VisitWord32AtomicPairLoad(Node* node) {
        temp_count, temps);
 }
 
-void InstructionSelector::VisitWord32AtomicPairStore(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairStore(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value_low = node->InputAt(2);
@@ -2508,28 +2647,34 @@ void InstructionSelector::VisitWord32AtomicPairStore(Node* node) {
   Emit(code, 0, nullptr, arraysize(inputs), inputs, arraysize(temps), temps);
 }
 
-void InstructionSelector::VisitWord32AtomicPairAdd(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairAdd(Node* node) {
   VisitPairAtomicBinOp(this, node, kArmWord32AtomicPairAdd);
 }
 
-void InstructionSelector::VisitWord32AtomicPairSub(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairSub(Node* node) {
   VisitPairAtomicBinOp(this, node, kArmWord32AtomicPairSub);
 }
 
-void InstructionSelector::VisitWord32AtomicPairAnd(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairAnd(Node* node) {
   VisitPairAtomicBinOp(this, node, kArmWord32AtomicPairAnd);
 }
 
-void InstructionSelector::VisitWord32AtomicPairOr(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairOr(Node* node) {
   VisitPairAtomicBinOp(this, node, kArmWord32AtomicPairOr);
 }
 
-void InstructionSelector::VisitWord32AtomicPairXor(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairXor(Node* node) {
   VisitPairAtomicBinOp(this, node, kArmWord32AtomicPairXor);
 }
 
-void InstructionSelector::VisitWord32AtomicPairExchange(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairExchange(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -2562,8 +2707,10 @@ void InstructionSelector::VisitWord32AtomicPairExchange(Node* node) {
        temps);
 }
 
-void InstructionSelector::VisitWord32AtomicPairCompareExchange(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairCompareExchange(
+    Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   AddressingMode addressing_mode = kMode_Offset_RR;
   InstructionOperand inputs[] = {g.UseFixed(node->InputAt(2), r4),
                                  g.UseFixed(node->InputAt(3), r5),
@@ -2739,22 +2886,25 @@ void InstructionSelector::VisitWord32AtomicPairCompareExchange(Node* node) {
   V(S128Xor, kArmS128Xor)                             \
   V(S128AndNot, kArmS128AndNot)
 
-void InstructionSelector::VisitI32x4DotI16x8S(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4DotI16x8S(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmI32x4DotI16x8S, g.DefineAsRegister(node),
        g.UseUniqueRegister(node->InputAt(0)),
        g.UseUniqueRegister(node->InputAt(1)));
 }
 
-void InstructionSelector::VisitI16x8DotI8x16I7x16S(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI16x8DotI8x16I7x16S(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmI16x8DotI8x16S, g.DefineAsRegister(node),
        g.UseUniqueRegister(node->InputAt(0)),
        g.UseUniqueRegister(node->InputAt(1)));
 }
 
-void InstructionSelector::VisitI32x4DotI8x16I7x16AddS(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4DotI8x16I7x16AddS(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand temps[] = {g.TempSimd128Register()};
   Emit(kArmI32x4DotI8x16AddS, g.DefineSameAsInput(node, 2),
        g.UseUniqueRegister(node->InputAt(0)),
@@ -2762,8 +2912,9 @@ void InstructionSelector::VisitI32x4DotI8x16I7x16AddS(Node* node) {
        g.UseUniqueRegister(node->InputAt(2)), arraysize(temps), temps);
 }
 
-void InstructionSelector::VisitS128Const(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitS128Const(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   uint32_t val[kSimd128Size / sizeof(uint32_t)];
   memcpy(val, S128ImmediateParameterOf(node->op()).data(), kSimd128Size);
   // If all bytes are zeros, avoid emitting code for generic constants.
@@ -2781,22 +2932,26 @@ void InstructionSelector::VisitS128Const(Node* node) {
   }
 }
 
-void InstructionSelector::VisitS128Zero(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitS128Zero(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmS128Zero, g.DefineAsRegister(node));
 }
 
-#define SIMD_VISIT_SPLAT(Type)                               \
-  void InstructionSelector::Visit##Type##Splat(Node* node) { \
-    VisitRR(this, kArm##Type##Splat, node);                  \
+#define SIMD_VISIT_SPLAT(Type)                                         \
+  template <typename Adapter>                                          \
+  void InstructionSelectorT<Adapter>::Visit##Type##Splat(Node* node) { \
+    VisitRR(this, kArm##Type##Splat, node);                            \
   }
 SIMD_TYPE_LIST(SIMD_VISIT_SPLAT)
 SIMD_VISIT_SPLAT(F64x2)
 #undef SIMD_VISIT_SPLAT
 
-#define SIMD_VISIT_EXTRACT_LANE(Type, Sign)                              \
-  void InstructionSelector::Visit##Type##ExtractLane##Sign(Node* node) { \
-    VisitRRI(this, kArm##Type##ExtractLane##Sign, node);                 \
+#define SIMD_VISIT_EXTRACT_LANE(Type, Sign)                           \
+  template <typename Adapter>                                         \
+  void InstructionSelectorT<Adapter>::Visit##Type##ExtractLane##Sign( \
+      Node* node) {                                                   \
+    VisitRRI(this, kArm##Type##ExtractLane##Sign, node);              \
   }
 SIMD_VISIT_EXTRACT_LANE(F64x2, )
 SIMD_VISIT_EXTRACT_LANE(F32x4, )
@@ -2807,92 +2962,99 @@ SIMD_VISIT_EXTRACT_LANE(I8x16, U)
 SIMD_VISIT_EXTRACT_LANE(I8x16, S)
 #undef SIMD_VISIT_EXTRACT_LANE
 
-#define SIMD_VISIT_REPLACE_LANE(Type)                              \
-  void InstructionSelector::Visit##Type##ReplaceLane(Node* node) { \
-    VisitRRIR(this, kArm##Type##ReplaceLane, node);                \
+#define SIMD_VISIT_REPLACE_LANE(Type)                                        \
+  template <typename Adapter>                                                \
+  void InstructionSelectorT<Adapter>::Visit##Type##ReplaceLane(Node* node) { \
+    VisitRRIR(this, kArm##Type##ReplaceLane, node);                          \
   }
 SIMD_TYPE_LIST(SIMD_VISIT_REPLACE_LANE)
 SIMD_VISIT_REPLACE_LANE(F64x2)
 #undef SIMD_VISIT_REPLACE_LANE
 #undef SIMD_TYPE_LIST
 
-#define SIMD_VISIT_UNOP(Name, instruction)            \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRR(this, instruction, node);                 \
+#define SIMD_VISIT_UNOP(Name, instruction)                      \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRR(this, instruction, node);                           \
   }
 SIMD_UNOP_LIST(SIMD_VISIT_UNOP)
 #undef SIMD_VISIT_UNOP
 #undef SIMD_UNOP_LIST
 
-#define SIMD_VISIT_SHIFT_OP(Name, width)              \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitSimdShiftRRR(this, kArm##Name, node, width); \
+#define SIMD_VISIT_SHIFT_OP(Name, width)                        \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitSimdShiftRRR(this, kArm##Name, node, width);           \
   }
 SIMD_SHIFT_OP_LIST(SIMD_VISIT_SHIFT_OP)
 #undef SIMD_VISIT_SHIFT_OP
 #undef SIMD_SHIFT_OP_LIST
 
-#define SIMD_VISIT_BINOP(Name, instruction)           \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRRR(this, instruction, node);                \
+#define SIMD_VISIT_BINOP(Name, instruction)                     \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRRR(this, instruction, node);                          \
   }
 SIMD_BINOP_LIST(SIMD_VISIT_BINOP)
 #undef SIMD_VISIT_BINOP
 #undef SIMD_BINOP_LIST
 
-#define VISIT_SIMD_ADD(Type, PairwiseType, NeonWidth)             \
-  void InstructionSelector::Visit##Type##Add(Node* node) {        \
-    ArmOperandGenerator g(this);                                  \
-    Node* left = node->InputAt(0);                                \
-    Node* right = node->InputAt(1);                               \
-    if (left->opcode() ==                                         \
-            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##S && \
-        CanCover(node, left)) {                                   \
-      Emit(kArmVpadal | MiscField::encode(NeonS##NeonWidth),      \
-           g.DefineSameAsFirst(node), g.UseRegister(right),       \
-           g.UseRegister(left->InputAt(0)));                      \
-      return;                                                     \
-    }                                                             \
-    if (left->opcode() ==                                         \
-            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##U && \
-        CanCover(node, left)) {                                   \
-      Emit(kArmVpadal | MiscField::encode(NeonU##NeonWidth),      \
-           g.DefineSameAsFirst(node), g.UseRegister(right),       \
-           g.UseRegister(left->InputAt(0)));                      \
-      return;                                                     \
-    }                                                             \
-    if (right->opcode() ==                                        \
-            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##S && \
-        CanCover(node, right)) {                                  \
-      Emit(kArmVpadal | MiscField::encode(NeonS##NeonWidth),      \
-           g.DefineSameAsFirst(node), g.UseRegister(left),        \
-           g.UseRegister(right->InputAt(0)));                     \
-      return;                                                     \
-    }                                                             \
-    if (right->opcode() ==                                        \
-            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##U && \
-        CanCover(node, right)) {                                  \
-      Emit(kArmVpadal | MiscField::encode(NeonU##NeonWidth),      \
-           g.DefineSameAsFirst(node), g.UseRegister(left),        \
-           g.UseRegister(right->InputAt(0)));                     \
-      return;                                                     \
-    }                                                             \
-    VisitRRR(this, kArm##Type##Add, node);                        \
+#define VISIT_SIMD_ADD(Type, PairwiseType, NeonWidth)                \
+  template <typename Adapter>                                        \
+  void InstructionSelectorT<Adapter>::Visit##Type##Add(Node* node) { \
+    ArmOperandGeneratorT<Adapter> g(this);                           \
+    Node* left = node->InputAt(0);                                   \
+    Node* right = node->InputAt(1);                                  \
+    if (left->opcode() ==                                            \
+            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##S &&    \
+        CanCover(node, left)) {                                      \
+      Emit(kArmVpadal | MiscField::encode(NeonS##NeonWidth),         \
+           g.DefineSameAsFirst(node), g.UseRegister(right),          \
+           g.UseRegister(left->InputAt(0)));                         \
+      return;                                                        \
+    }                                                                \
+    if (left->opcode() ==                                            \
+            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##U &&    \
+        CanCover(node, left)) {                                      \
+      Emit(kArmVpadal | MiscField::encode(NeonU##NeonWidth),         \
+           g.DefineSameAsFirst(node), g.UseRegister(right),          \
+           g.UseRegister(left->InputAt(0)));                         \
+      return;                                                        \
+    }                                                                \
+    if (right->opcode() ==                                           \
+            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##S &&    \
+        CanCover(node, right)) {                                     \
+      Emit(kArmVpadal | MiscField::encode(NeonS##NeonWidth),         \
+           g.DefineSameAsFirst(node), g.UseRegister(left),           \
+           g.UseRegister(right->InputAt(0)));                        \
+      return;                                                        \
+    }                                                                \
+    if (right->opcode() ==                                           \
+            IrOpcode::k##Type##ExtAddPairwise##PairwiseType##U &&    \
+        CanCover(node, right)) {                                     \
+      Emit(kArmVpadal | MiscField::encode(NeonU##NeonWidth),         \
+           g.DefineSameAsFirst(node), g.UseRegister(left),           \
+           g.UseRegister(right->InputAt(0)));                        \
+      return;                                                        \
+    }                                                                \
+    VisitRRR(this, kArm##Type##Add, node);                           \
   }
 
 VISIT_SIMD_ADD(I16x8, I8x16, 8)
 VISIT_SIMD_ADD(I32x4, I16x8, 16)
 #undef VISIT_SIMD_ADD
 
-void InstructionSelector::VisitI64x2SplatI32Pair(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2SplatI32Pair(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand operand0 = g.UseRegister(node->InputAt(0));
   InstructionOperand operand1 = g.UseRegister(node->InputAt(1));
   Emit(kArmI64x2SplatI32Pair, g.DefineAsRegister(node), operand0, operand1);
 }
 
-void InstructionSelector::VisitI64x2ReplaceLaneI32Pair(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2ReplaceLaneI32Pair(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand operand = g.UseRegister(node->InputAt(0));
   InstructionOperand lane = g.UseImmediate(OpParameter<int32_t>(node->op()));
   InstructionOperand low = g.UseRegister(node->InputAt(1));
@@ -2901,66 +3063,76 @@ void InstructionSelector::VisitI64x2ReplaceLaneI32Pair(Node* node) {
        low, high);
 }
 
-void InstructionSelector::VisitI64x2Neg(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2Neg(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmI64x2Neg, g.DefineAsRegister(node),
        g.UseUniqueRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitI64x2Mul(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2Mul(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   InstructionOperand temps[] = {g.TempSimd128Register()};
   Emit(kArmI64x2Mul, g.DefineAsRegister(node),
        g.UseUniqueRegister(node->InputAt(0)),
        g.UseUniqueRegister(node->InputAt(1)), arraysize(temps), temps);
 }
 
-void InstructionSelector::VisitF32x4Sqrt(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF32x4Sqrt(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   // Use fixed registers in the lower 8 Q-registers so we can directly access
   // mapped registers S0-S31.
   Emit(kArmF32x4Sqrt, g.DefineAsFixed(node, q0),
        g.UseFixed(node->InputAt(0), q0));
 }
 
-void InstructionSelector::VisitF32x4Div(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF32x4Div(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   // Use fixed registers in the lower 8 Q-registers so we can directly access
   // mapped registers S0-S31.
   Emit(kArmF32x4Div, g.DefineAsFixed(node, q0),
        g.UseFixed(node->InputAt(0), q0), g.UseFixed(node->InputAt(1), q1));
 }
 
-void InstructionSelector::VisitS128Select(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitS128Select(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmS128Select, g.DefineSameAsFirst(node),
        g.UseRegister(node->InputAt(0)), g.UseRegister(node->InputAt(1)),
        g.UseRegister(node->InputAt(2)));
 }
 
-void InstructionSelector::VisitI8x16RelaxedLaneSelect(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI8x16RelaxedLaneSelect(Node* node) {
   VisitS128Select(node);
 }
 
-void InstructionSelector::VisitI16x8RelaxedLaneSelect(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI16x8RelaxedLaneSelect(Node* node) {
   VisitS128Select(node);
 }
 
-void InstructionSelector::VisitI32x4RelaxedLaneSelect(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4RelaxedLaneSelect(Node* node) {
   VisitS128Select(node);
 }
 
-void InstructionSelector::VisitI64x2RelaxedLaneSelect(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2RelaxedLaneSelect(Node* node) {
   VisitS128Select(node);
 }
 
-#define VISIT_SIMD_QFMOP(op)                        \
-  void InstructionSelector::Visit##op(Node* node) { \
-    ArmOperandGenerator g(this);                    \
-    Emit(kArm##op, g.DefineAsRegister(node),        \
-         g.UseUniqueRegister(node->InputAt(0)),     \
-         g.UseUniqueRegister(node->InputAt(1)),     \
-         g.UseUniqueRegister(node->InputAt(2)));    \
+#define VISIT_SIMD_QFMOP(op)                                  \
+  template <typename Adapter>                                 \
+  void InstructionSelectorT<Adapter>::Visit##op(Node* node) { \
+    ArmOperandGeneratorT<Adapter> g(this);                    \
+    Emit(kArm##op, g.DefineAsRegister(node),                  \
+         g.UseUniqueRegister(node->InputAt(0)),               \
+         g.UseUniqueRegister(node->InputAt(1)),               \
+         g.UseUniqueRegister(node->InputAt(2)));              \
   }
 VISIT_SIMD_QFMOP(F64x2Qfma)
 VISIT_SIMD_QFMOP(F64x2Qfms)
@@ -3042,8 +3214,10 @@ bool TryMatchArchShuffle(const uint8_t* shuffle, const ShuffleEntry* table,
   return false;
 }
 
-void ArrangeShuffleTable(ArmOperandGenerator* g, Node* input0, Node* input1,
-                         InstructionOperand* src0, InstructionOperand* src1) {
+template <typename Adapter>
+void ArrangeShuffleTable(ArmOperandGeneratorT<Adapter>* g, Node* input0,
+                         Node* input1, InstructionOperand* src0,
+                         InstructionOperand* src1) {
   if (input0 == input1) {
     // Unary, any q-register can be the table.
     *src0 = *src1 = g->UseRegister(input0);
@@ -3056,14 +3230,15 @@ void ArrangeShuffleTable(ArmOperandGenerator* g, Node* input0, Node* input1,
 
 }  // namespace
 
-void InstructionSelector::VisitI8x16Shuffle(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI8x16Shuffle(Node* node) {
   uint8_t shuffle[kSimd128Size];
   bool is_swizzle;
   CanonicalizeShuffle(node, shuffle, &is_swizzle);
   Node* input0 = node->InputAt(0);
   Node* input1 = node->InputAt(1);
   uint8_t shuffle32x4[4];
-  ArmOperandGenerator g(this);
+  ArmOperandGeneratorT<Adapter> g(this);
   int index = 0;
   if (wasm::SimdShuffle::TryMatch32x4Shuffle(shuffle, shuffle32x4)) {
     if (wasm::SimdShuffle::TryMatchSplat<4>(shuffle, &index)) {
@@ -3116,67 +3291,80 @@ void InstructionSelector::VisitI8x16Shuffle(Node* node) {
        g.UseImmediate(wasm::SimdShuffle::Pack4Lanes(shuffle + 12)));
 }
 #else
-void InstructionSelector::VisitI8x16Shuffle(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI8x16Shuffle(Node* node) {
+  UNREACHABLE();
+}
 #endif  // V8_ENABLE_WEBASSEMBLY
 
-void InstructionSelector::VisitI8x16Swizzle(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI8x16Swizzle(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   // We don't want input 0 (the table) to be the same as output, since we will
   // modify output twice (low and high), and need to keep the table the same.
   Emit(kArmI8x16Swizzle, g.DefineAsRegister(node),
        g.UseUniqueRegister(node->InputAt(0)), g.UseRegister(node->InputAt(1)));
 }
 
-void InstructionSelector::VisitSignExtendWord8ToInt32(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSignExtendWord8ToInt32(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmSxtb, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)),
        g.TempImmediate(0));
 }
 
-void InstructionSelector::VisitSignExtendWord16ToInt32(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSignExtendWord16ToInt32(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmSxth, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)),
        g.TempImmediate(0));
 }
 
-void InstructionSelector::VisitInt32AbsWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32AbsWithOverflow(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitInt64AbsWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64AbsWithOverflow(Node* node) {
   UNREACHABLE();
 }
 
 namespace {
-template <ArchOpcode opcode>
-void VisitBitMask(InstructionSelector* selector, Node* node) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter, ArchOpcode opcode>
+void VisitBitMask(InstructionSelectorT<Adapter>* selector, Node* node) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   InstructionOperand temps[] = {g.TempSimd128Register()};
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)), arraysize(temps), temps);
 }
 }  // namespace
 
-void InstructionSelector::VisitI8x16BitMask(Node* node) {
-  VisitBitMask<kArmI8x16BitMask>(this, node);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI8x16BitMask(Node* node) {
+  VisitBitMask<Adapter, kArmI8x16BitMask>(this, node);
 }
 
-void InstructionSelector::VisitI16x8BitMask(Node* node) {
-  VisitBitMask<kArmI16x8BitMask>(this, node);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI16x8BitMask(Node* node) {
+  VisitBitMask<Adapter, kArmI16x8BitMask>(this, node);
 }
 
-void InstructionSelector::VisitI32x4BitMask(Node* node) {
-  VisitBitMask<kArmI32x4BitMask>(this, node);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4BitMask(Node* node) {
+  VisitBitMask<Adapter, kArmI32x4BitMask>(this, node);
 }
 
-void InstructionSelector::VisitI64x2BitMask(Node* node) {
-  VisitBitMask<kArmI64x2BitMask>(this, node);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2BitMask(Node* node) {
+  VisitBitMask<Adapter, kArmI64x2BitMask>(this, node);
 }
 
 namespace {
-void VisitF32x4PminOrPmax(InstructionSelector* selector, ArchOpcode opcode,
-                          Node* node) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitF32x4PminOrPmax(InstructionSelectorT<Adapter>* selector,
+                          ArchOpcode opcode, Node* node) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   // Need all unique registers because we first compare the two inputs, then we
   // need the inputs to remain unchanged for the bitselect later.
   selector->Emit(opcode, g.DefineAsRegister(node),
@@ -3184,36 +3372,43 @@ void VisitF32x4PminOrPmax(InstructionSelector* selector, ArchOpcode opcode,
                  g.UseUniqueRegister(node->InputAt(1)));
 }
 
-void VisitF64x2PminOrPMax(InstructionSelector* selector, ArchOpcode opcode,
-                          Node* node) {
-  ArmOperandGenerator g(selector);
+template <typename Adapter>
+void VisitF64x2PminOrPMax(InstructionSelectorT<Adapter>* selector,
+                          ArchOpcode opcode, Node* node) {
+  ArmOperandGeneratorT<Adapter> g(selector);
   selector->Emit(opcode, g.DefineSameAsFirst(node),
                  g.UseRegister(node->InputAt(0)),
                  g.UseRegister(node->InputAt(1)));
 }
 }  // namespace
 
-void InstructionSelector::VisitF32x4Pmin(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF32x4Pmin(Node* node) {
   VisitF32x4PminOrPmax(this, kArmF32x4Pmin, node);
 }
 
-void InstructionSelector::VisitF32x4Pmax(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF32x4Pmax(Node* node) {
   VisitF32x4PminOrPmax(this, kArmF32x4Pmax, node);
 }
 
-void InstructionSelector::VisitF64x2Pmin(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2Pmin(Node* node) {
   VisitF64x2PminOrPMax(this, kArmF64x2Pmin, node);
 }
 
-void InstructionSelector::VisitF64x2Pmax(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2Pmax(Node* node) {
   VisitF64x2PminOrPMax(this, kArmF64x2Pmax, node);
 }
 
-void InstructionSelector::VisitF64x2RelaxedMin(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2RelaxedMin(Node* node) {
   VisitF64x2Pmin(node);
 }
 
-void InstructionSelector::VisitF64x2RelaxedMax(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2RelaxedMax(Node* node) {
   VisitF64x2Pmax(node);
 }
 
@@ -3231,9 +3426,10 @@ void InstructionSelector::VisitF64x2RelaxedMax(Node* node) {
   V(I64x2ExtMulLowI32x4U, kArmVmullLow, NeonU32)   \
   V(I64x2ExtMulHighI32x4U, kArmVmullHigh, NeonU32)
 
-#define VISIT_EXT_MUL(OPCODE, VMULL, NEONSIZE)                 \
-  void InstructionSelector::Visit##OPCODE(Node* node) {        \
-    VisitRRR(this, VMULL | MiscField::encode(NEONSIZE), node); \
+#define VISIT_EXT_MUL(OPCODE, VMULL, NEONSIZE)                    \
+  template <typename Adapter>                                     \
+  void InstructionSelectorT<Adapter>::Visit##OPCODE(Node* node) { \
+    VisitRRR(this, VMULL | MiscField::encode(NEONSIZE), node);    \
   }
 
 EXT_MUL_LIST(VISIT_EXT_MUL)
@@ -3242,7 +3438,8 @@ EXT_MUL_LIST(VISIT_EXT_MUL)
 #undef EXT_MUL_LIST
 
 #define VISIT_EXTADD_PAIRWISE(OPCODE, NEONSIZE)                    \
-  void InstructionSelector::Visit##OPCODE(Node* node) {            \
+  template <typename Adapter>                                      \
+  void InstructionSelectorT<Adapter>::Visit##OPCODE(Node* node) {  \
     VisitRR(this, kArmVpaddl | MiscField::encode(NEONSIZE), node); \
   }
 VISIT_EXTADD_PAIRWISE(I16x8ExtAddPairwiseI8x16S, NeonS8)
@@ -3251,8 +3448,9 @@ VISIT_EXTADD_PAIRWISE(I32x4ExtAddPairwiseI16x8S, NeonS16)
 VISIT_EXTADD_PAIRWISE(I32x4ExtAddPairwiseI16x8U, NeonU16)
 #undef VISIT_EXTADD_PAIRWISE
 
-void InstructionSelector::VisitTruncateFloat32ToInt32(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat32ToInt32(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
 
   InstructionCode opcode = kArmVcvtS32F32;
   TruncateKind kind = OpParameter<TruncateKind>(node->op());
@@ -3263,8 +3461,9 @@ void InstructionSelector::VisitTruncateFloat32ToInt32(Node* node) {
   Emit(opcode, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitTruncateFloat32ToUint32(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat32ToUint32(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
 
   InstructionCode opcode = kArmVcvtU32F32;
   TruncateKind kind = OpParameter<TruncateKind>(node->op());
@@ -3278,59 +3477,70 @@ void InstructionSelector::VisitTruncateFloat32ToUint32(Node* node) {
 // TODO(v8:9780)
 // These double precision conversion instructions need a low Q register (q0-q7)
 // because the codegen accesses the S registers they overlap with.
-void InstructionSelector::VisitF64x2ConvertLowI32x4S(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2ConvertLowI32x4S(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmF64x2ConvertLowI32x4S, g.DefineAsRegister(node),
        g.UseFixed(node->InputAt(0), q0));
 }
 
-void InstructionSelector::VisitF64x2ConvertLowI32x4U(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2ConvertLowI32x4U(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmF64x2ConvertLowI32x4U, g.DefineAsRegister(node),
        g.UseFixed(node->InputAt(0), q0));
 }
 
-void InstructionSelector::VisitI32x4TruncSatF64x2SZero(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4TruncSatF64x2SZero(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmI32x4TruncSatF64x2SZero, g.DefineAsFixed(node, q0),
        g.UseUniqueRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitI32x4TruncSatF64x2UZero(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4TruncSatF64x2UZero(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmI32x4TruncSatF64x2UZero, g.DefineAsFixed(node, q0),
        g.UseUniqueRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitF32x4DemoteF64x2Zero(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF32x4DemoteF64x2Zero(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmF32x4DemoteF64x2Zero, g.DefineAsFixed(node, q0),
        g.UseUniqueRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitF64x2PromoteLowF32x4(Node* node) {
-  ArmOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2PromoteLowF32x4(Node* node) {
+  ArmOperandGeneratorT<Adapter> g(this);
   Emit(kArmF64x2PromoteLowF32x4, g.DefineAsRegister(node),
        g.UseFixed(node->InputAt(0), q0));
 }
 
-void InstructionSelector::VisitI32x4RelaxedTruncF64x2SZero(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4RelaxedTruncF64x2SZero(
+    Node* node) {
   VisitI32x4TruncSatF64x2SZero(node);
 }
 
-void InstructionSelector::VisitI32x4RelaxedTruncF64x2UZero(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4RelaxedTruncF64x2UZero(
+    Node* node) {
   VisitI32x4TruncSatF64x2UZero(node);
 }
 
-void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
-                                                        int first_input_index,
-                                                        Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::AddOutputToSelectContinuation(
+    OperandGenerator* g, int first_input_index, Node* node) {
   UNREACHABLE();
 }
 
 // static
+template <typename Adapter>
 MachineOperatorBuilder::Flags
-InstructionSelector::SupportedMachineOperatorFlags() {
+InstructionSelectorT<Adapter>::SupportedMachineOperatorFlags() {
   MachineOperatorBuilder::Flags flags = MachineOperatorBuilder::kNoFlags;
   if (CpuFeatures::IsSupported(SUDIV)) {
     // The sdiv and udiv instructions correctly return 0 if the divisor is 0,
@@ -3357,8 +3567,9 @@ InstructionSelector::SupportedMachineOperatorFlags() {
 }
 
 // static
+template <typename Adapter>
 MachineOperatorBuilder::AlignmentRequirements
-InstructionSelector::AlignmentRequirements() {
+InstructionSelectorT<Adapter>::AlignmentRequirements() {
   base::EnumSet<MachineRepresentation> req_aligned;
   req_aligned.Add(MachineRepresentation::kFloat32);
   req_aligned.Add(MachineRepresentation::kFloat64);
@@ -3366,6 +3577,11 @@ InstructionSelector::AlignmentRequirements() {
       SomeUnalignedAccessUnsupported(req_aligned, req_aligned);
 }
 
+template class EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
+    InstructionSelectorT<TurbofanAdapter>;
+template class EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
+    InstructionSelectorT<TurboshaftAdapter>;
+
 }  // namespace compiler
 }  // namespace internal
 }  // namespace v8

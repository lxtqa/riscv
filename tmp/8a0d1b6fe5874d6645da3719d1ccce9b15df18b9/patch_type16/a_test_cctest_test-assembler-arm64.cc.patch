diff --git a/test/cctest/test-assembler-arm64.cc b/test/cctest/test-assembler-arm64.cc
index 0c41602514..fea98df487 100644
--- a/test/cctest/test-assembler-arm64.cc
+++ b/test/cctest/test-assembler-arm64.cc
@@ -9571,7 +9571,7 @@ TEST(fcmp) {
     // test. A UseScratchRegisterScope will make sure that they are restored to
     // the default values once we're finished.
     UseScratchRegisterScope temps(&masm);
-    masm.FPTmpList()->set_list(0);
+    masm.FPTmpList()->set_bits(0);
 
     __ Fmov(s8, 0.0);
     __ Fmov(s9, 0.5);
@@ -9590,9 +9590,9 @@ TEST(fcmp) {
     __ Mrs(x4, NZCV);
     __ Fcmp(s8, 0.0);
     __ Mrs(x5, NZCV);
-    masm.FPTmpList()->set_list(d0.bit());
+    masm.FPTmpList()->set_bits(DoubleRegList{d0}.bits());
     __ Fcmp(s8, 255.0);
-    masm.FPTmpList()->set_list(0);
+    masm.FPTmpList()->set_bits(0);
     __ Mrs(x6, NZCV);
 
     __ Fmov(d19, 0.0);
@@ -9612,9 +9612,9 @@ TEST(fcmp) {
     __ Mrs(x14, NZCV);
     __ Fcmp(d19, 0.0);
     __ Mrs(x15, NZCV);
-    masm.FPTmpList()->set_list(d0.bit());
+    masm.FPTmpList()->set_bits(DoubleRegList{d0}.bits());
     __ Fcmp(d19, 12.3456);
-    masm.FPTmpList()->set_list(0);
+    masm.FPTmpList()->set_bits(0);
     __ Mrs(x16, NZCV);
   }
 
@@ -12026,27 +12026,27 @@ TEST(register_bit) {
   // teardown.
 
   // Simple tests.
-  CHECK_EQ(x0.bit(), 1ULL << 0);
-  CHECK_EQ(x1.bit(), 1ULL << 1);
-  CHECK_EQ(x10.bit(), 1ULL << 10);
+  CHECK_EQ(RegList{x0}.bits(), 1ULL << 0);
+  CHECK_EQ(RegList{x1}.bits(), 1ULL << 1);
+  CHECK_EQ(RegList{x10}.bits(), 1ULL << 10);
 
   // AAPCS64 definitions.
-  CHECK_EQ(fp.bit(), 1ULL << kFramePointerRegCode);
-  CHECK_EQ(lr.bit(), 1ULL << kLinkRegCode);
+  CHECK_EQ(RegList{fp}.bits(), 1ULL << kFramePointerRegCode);
+  CHECK_EQ(RegList{lr}.bits(), 1ULL << kLinkRegCode);
 
   // Fixed (hardware) definitions.
-  CHECK_EQ(xzr.bit(), 1ULL << kZeroRegCode);
+  CHECK_EQ(RegList{xzr}.bits(), 1ULL << kZeroRegCode);
 
   // Internal ABI definitions.
-  CHECK_EQ(sp.bit(), 1ULL << kSPRegInternalCode);
-  CHECK_NE(sp.bit(), xzr.bit());
+  CHECK_EQ(RegList{sp}.bits(), 1ULL << kSPRegInternalCode);
+  CHECK_NE(RegList{sp}.bits(), RegList{xzr}.bits());
 
-  // xn.bit() == wn.bit() at all times, for the same n.
-  CHECK_EQ(x0.bit(), w0.bit());
-  CHECK_EQ(x1.bit(), w1.bit());
-  CHECK_EQ(x10.bit(), w10.bit());
-  CHECK_EQ(xzr.bit(), wzr.bit());
-  CHECK_EQ(sp.bit(), wsp.bit());
+  // RegList{xn}.bits() == RegList{wn}.bits() at all times, for the same n.
+  CHECK_EQ(RegList{x0}.bits(), RegList{w0}.bits());
+  CHECK_EQ(RegList{x1}.bits(), RegList{w1}.bits());
+  CHECK_EQ(RegList{x10}.bits(), RegList{w10}.bits());
+  CHECK_EQ(RegList{xzr}.bits(), RegList{wzr}.bits());
+  CHECK_EQ(RegList{sp}.bits(), RegList{wsp}.bits());
 }
 
 TEST(peek_poke_simple) {
@@ -12054,9 +12054,8 @@ TEST(peek_poke_simple) {
   SETUP();
   START();
 
-  static const RegList x0_to_x3 = x0.bit() | x1.bit() | x2.bit() | x3.bit();
-  static const RegList x10_to_x13 =
-      x10.bit() | x11.bit() | x12.bit() | x13.bit();
+  static const RegList x0_to_x3 = {x0, x1, x2, x3};
+  static const RegList x10_to_x13 = {x10, x11, x12, x13};
 
   // The literal base is chosen to have two useful properties:
   //  * When multiplied by small values (such as a register index), this value
@@ -12141,35 +12140,35 @@ TEST(peek_poke_unaligned) {
   //    x0-x6 should be unchanged.
   //    w10-w12 should contain the lower words of x0-x2.
   __ Poke(x0, 1);
-  Clobber(&masm, x0.bit());
+  Clobber(&masm, {x0});
   __ Peek(x0, 1);
   __ Poke(x1, 2);
-  Clobber(&masm, x1.bit());
+  Clobber(&masm, {x1});
   __ Peek(x1, 2);
   __ Poke(x2, 3);
-  Clobber(&masm, x2.bit());
+  Clobber(&masm, {x2});
   __ Peek(x2, 3);
   __ Poke(x3, 4);
-  Clobber(&masm, x3.bit());
+  Clobber(&masm, {x3});
   __ Peek(x3, 4);
   __ Poke(x4, 5);
-  Clobber(&masm, x4.bit());
+  Clobber(&masm, {x4});
   __ Peek(x4, 5);
   __ Poke(x5, 6);
-  Clobber(&masm, x5.bit());
+  Clobber(&masm, {x5});
   __ Peek(x5, 6);
   __ Poke(x6, 7);
-  Clobber(&masm, x6.bit());
+  Clobber(&masm, {x6});
   __ Peek(x6, 7);
 
   __ Poke(w0, 1);
-  Clobber(&masm, w10.bit());
+  Clobber(&masm, {w10});
   __ Peek(w10, 1);
   __ Poke(w1, 2);
-  Clobber(&masm, w11.bit());
+  Clobber(&masm, {w11});
   __ Peek(w11, 2);
   __ Poke(w2, 3);
-  Clobber(&masm, w12.bit());
+  Clobber(&masm, {w12});
   __ Peek(w12, 3);
 
   __ Drop(4);
@@ -12332,9 +12331,11 @@ static void PushPopSimpleHelper(int reg_count, int reg_size,
   // For simplicity, exclude LR as well, as we would need to sign it when
   // pushing it. This also ensures that the list has an even number of elements,
   // which is needed for alignment.
-  RegList allowed = ~(masm.TmpList()->list() | x18.bit() | lr.bit());
+  static RegList const allowed =
+      RegList::FromBits(static_cast<uint32_t>(~masm.TmpList()->bits())) -
+      RegList{x18, lr};
   if (reg_count == kPushPopMaxRegCount) {
-    reg_count = CountSetBits(allowed, kNumberOfRegisters);
+    reg_count = CountSetBits(allowed.bits(), kNumberOfRegisters);
   }
   DCHECK_EQ(reg_count % 2, 0);
   // Work out which registers to use, based on reg_size.
@@ -12480,15 +12481,15 @@ static void PushPopFPSimpleHelper(int reg_count, int reg_size,
 
   // We can use any floating-point register. None of them are reserved for
   // debug code, for example.
-  static RegList const allowed = ~0;
+  static DoubleRegList const allowed = DoubleRegList::FromBits(~0);
   if (reg_count == kPushPopFPMaxRegCount) {
-    reg_count = CountSetBits(allowed, kNumberOfVRegisters);
+    reg_count = CountSetBits(allowed.bits(), kNumberOfVRegisters);
   }
   // Work out which registers to use, based on reg_size.
   auto v = CreateRegisterArray<VRegister, kNumberOfRegisters>();
   auto d = CreateRegisterArray<VRegister, kNumberOfRegisters>();
-  RegList list = PopulateVRegisterArray(nullptr, d.data(), v.data(), reg_size,
-                                        reg_count, allowed);
+  DoubleRegList list = PopulateVRegisterArray(nullptr, d.data(), v.data(),
+                                              reg_size, reg_count, allowed);
 
   // The literal base is chosen to have two useful properties:
   //  * When multiplied (using an integer) by small values (such as a register
@@ -12530,7 +12531,7 @@ static void PushPopFPSimpleHelper(int reg_count, int reg_size,
         }
         break;
       case PushPopRegList:
-        __ PushSizeRegList(list, reg_size, CPURegister::kVRegister);
+        __ PushSizeRegList(list, reg_size);
         break;
     }
 
@@ -12554,7 +12555,7 @@ static void PushPopFPSimpleHelper(int reg_count, int reg_size,
         }
         break;
       case PushPopRegList:
-        __ PopSizeRegList(list, reg_size, CPURegister::kVRegister);
+        __ PopSizeRegList(list, reg_size);
         break;
     }
   }
@@ -12627,24 +12628,25 @@ static void PushPopMixedMethodsHelper(int reg_size) {
 
   // Registers in the TmpList can be used by the macro assembler for debug code
   // (for example in 'Pop'), so we can't use them here.
-  static RegList const allowed = ~(masm.TmpList()->list());
+  static RegList const allowed =
+      RegList::FromBits(static_cast<uint32_t>(~masm.TmpList()->bits()));
   // Work out which registers to use, based on reg_size.
   auto r = CreateRegisterArray<Register, 10>();
   auto x = CreateRegisterArray<Register, 10>();
   PopulateRegisterArray(nullptr, x.data(), r.data(), reg_size, 10, allowed);
 
   // Calculate some handy register lists.
-  RegList r0_to_r3 = 0;
+  RegList r0_to_r3;
   for (int i = 0; i <= 3; i++) {
-    r0_to_r3 |= x[i].bit();
+    r0_to_r3.set(x[i]);
   }
-  RegList r4_to_r5 = 0;
+  RegList r4_to_r5;
   for (int i = 4; i <= 5; i++) {
-    r4_to_r5 |= x[i].bit();
+    r4_to_r5.set(x[i]);
   }
-  RegList r6_to_r9 = 0;
+  RegList r6_to_r9;
   for (int i = 6; i <= 9; i++) {
-    r6_to_r9 |= x[i].bit();
+    r6_to_r9.set(x[i]);
   }
 
   // The literal base is chosen to have two useful properties:
@@ -12706,17 +12708,17 @@ TEST(push_pop) {
   __ Mov(x1, 0x1111111111111111UL);
   __ Mov(x0, 0x0000000000000000UL);
   __ Claim(2);
-  __ PushXRegList(x0.bit() | x1.bit() | x2.bit() | x3.bit());
+  __ PushXRegList({x0, x1, x2, x3});
   __ Push(x3, x2);
-  __ PopXRegList(x0.bit() | x1.bit() | x2.bit() | x3.bit());
+  __ PopXRegList({x0, x1, x2, x3});
   __ Push(x2, x1, x3, x0);
   __ Pop(x4, x5);
   __ Pop(x6, x7, x8, x9);
 
   __ Claim(2);
-  __ PushWRegList(w0.bit() | w1.bit() | w2.bit() | w3.bit());
+  __ PushWRegList({w0, w1, w2, w3});
   __ Push(w3, w1, w2, w0);
-  __ PopWRegList(w10.bit() | w11.bit() | w12.bit() | w13.bit());
+  __ PopWRegList({w10, w11, w12, w13});
   __ Pop(w14, w15, w16, w17);
 
   __ Claim(2);
@@ -12726,18 +12728,18 @@ TEST(push_pop) {
   __ Pop(x22, x23);
 
   __ Claim(2);
-  __ PushXRegList(x1.bit() | x22.bit());
-  __ PopXRegList(x24.bit() | x26.bit());
+  __ PushXRegList({x1, x22});
+  __ PopXRegList({x24, x26});
 
   __ Claim(2);
-  __ PushWRegList(w1.bit() | w2.bit() | w4.bit() | w22.bit());
-  __ PopWRegList(w25.bit() | w27.bit() | w28.bit() | w29.bit());
+  __ PushWRegList({w1, w2, w4, w22});
+  __ PopWRegList({w25, w27, w28, w29});
 
   __ Claim(2);
-  __ PushXRegList(0);
-  __ PopXRegList(0);
+  __ PushXRegList({});
+  __ PopXRegList({});
   // Don't push/pop x18 (platform register) or lr
-  RegList all_regs = 0xFFFFFFFF & ~(x18.bit() | lr.bit());
+  RegList all_regs = RegList::FromBits(0xFFFFFFFF) - RegList{x18, lr};
   __ PushXRegList<TurboAssembler::kDontStoreLR>(all_regs);
   __ PopXRegList<TurboAssembler::kDontLoadLR>(all_regs);
   __ Drop(12);
@@ -13891,10 +13893,10 @@ TEST(cpureglist_utils_empty) {
   // Test an empty list.
   // Empty lists can have type and size properties. Check that we can create
   // them, and that they are empty.
-  CPURegList reg32(CPURegister::kRegister, kWRegSizeInBits, 0);
-  CPURegList reg64(CPURegister::kRegister, kXRegSizeInBits, 0);
-  CPURegList fpreg32(CPURegister::kVRegister, kSRegSizeInBits, 0);
-  CPURegList fpreg64(CPURegister::kVRegister, kDRegSizeInBits, 0);
+  CPURegList reg32(kWRegSizeInBits, RegList{});
+  CPURegList reg64(kXRegSizeInBits, RegList{});
+  CPURegList fpreg32(kSRegSizeInBits, DoubleRegList{});
+  CPURegList fpreg64(kDRegSizeInBits, DoubleRegList{});
 
   CHECK(reg32.IsEmpty());
   CHECK(reg64.IsEmpty());

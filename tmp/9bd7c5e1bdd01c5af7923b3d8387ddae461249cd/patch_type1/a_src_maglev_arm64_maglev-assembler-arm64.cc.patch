diff --git a/src/maglev/arm64/maglev-assembler-arm64.cc b/src/maglev/arm64/maglev-assembler-arm64.cc
index 841b2ffd3c..6ca8a0b083 100644
--- a/src/maglev/arm64/maglev-assembler-arm64.cc
+++ b/src/maglev/arm64/maglev-assembler-arm64.cc
@@ -245,19 +245,24 @@ void MaglevAssembler::Prologue(Graph* graph) {
     ZoneLabelRef deferred_call_stack_guard_return(this);
     JumpToDeferredIf(
         lo,
-        [](MaglevAssembler* masm, ZoneLabelRef done, int max_stack_size) {
+        [](MaglevAssembler* masm, ZoneLabelRef done, RegList register_inputs,
+           int max_stack_size) {
           ASM_CODE_COMMENT_STRING(masm, "Stack/interrupt call");
-          // Save any registers that can be referenced by RegisterInput.
-          // TODO(leszeks): Only push those that are used by the graph.
-          __ PushAll(RegisterInput::kAllowedRegisters);
-          // Push the frame size
-          __ Mov(ip0, Smi::FromInt(max_stack_size * kSystemPointerSize));
-          __ PushArgument(ip0);
+          __ PushAll(register_inputs);
+          UseScratchRegisterScope temps(masm);
+          Register scratch = temps.AcquireX();
+          __ Mov(scratch, Smi::FromInt(max_stack_size * kSystemPointerSize));
+          __ PushArgument(scratch);
           __ CallRuntime(Runtime::kStackGuardWithGap, 1);
-          __ PopAll(RegisterInput::kAllowedRegisters);
+          auto safepoint =
+              masm->safepoint_table_builder()->DefineSafepoint(masm);
+          safepoint.DefineStackGuardSafepoint(
+              RoundUp<2>(register_inputs.Count()));
+          __ PopAll(register_inputs);
           __ B(*done);
         },
-        deferred_call_stack_guard_return, max_stack_size);
+        deferred_call_stack_guard_return, graph->register_inputs(),
+        max_stack_size);
     bind(*deferred_call_stack_guard_return);
   }
 

diff --git a/src/maglev/x64/maglev-ir-x64.cc b/src/maglev/x64/maglev-ir-x64.cc
index 2b2ad063246..a64bddd4adb 100644
--- a/src/maglev/x64/maglev-ir-x64.cc
+++ b/src/maglev/x64/maglev-ir-x64.cc
@@ -1333,86 +1333,6 @@ void Float64Ieee754Unary::GenerateCode(MaglevAssembler* masm,
   __ CallCFunction(ieee_function_, 1);
 }
 
-void CheckInt32IsSmi::SetValueLocationConstraints() { UseRegister(input()); }
-void CheckInt32IsSmi::GenerateCode(MaglevAssembler* masm,
-                                   const ProcessingState& state) {
-  // TODO(leszeks): This basically does a SmiTag and throws the result away.
-  // Don't throw the result away if we want to actually use it.
-  Register reg = ToRegister(input());
-  __ movl(kScratchRegister, reg);
-  __ addl(kScratchRegister, kScratchRegister);
-  __ EmitEagerDeoptIf(overflow, DeoptimizeReason::kNotASmi, this);
-}
-
-void CheckHoleyFloat64IsSmi::SetValueLocationConstraints() {
-  UseRegister(input());
-  set_temporaries_needed(1);
-}
-void CheckHoleyFloat64IsSmi::GenerateCode(MaglevAssembler* masm,
-                                          const ProcessingState& state) {
-  DoubleRegister value = ToDoubleRegister(input());
-  MaglevAssembler::ScratchRegisterScope temps(masm);
-  Register scratch = temps.Acquire();
-  Label not_a_smi, done;
-  __ TryTruncateDoubleToInt32(scratch, value, &not_a_smi);
-  __ addl(scratch, scratch);
-  __ JumpIf(no_overflow, &done);
-
-  __ bind(&not_a_smi);
-  __ EmitEagerDeopt(this, DeoptimizeReason::kNotASmi);
-
-  __ bind(&done);
-}
-
-void CheckedSmiTagInt32::SetValueLocationConstraints() {
-  UseAndClobberRegister(input());
-  DefineSameAsFirst(this);
-}
-void CheckedSmiTagInt32::GenerateCode(MaglevAssembler* masm,
-                                      const ProcessingState& state) {
-  Register reg = ToRegister(input());
-  __ addl(reg, reg);
-  // None of the mutated input registers should be a register input into the
-  // eager deopt info.
-  DCHECK_REGLIST_EMPTY(RegList{reg} &
-                       GetGeneralRegistersUsedAsInputs(eager_deopt_info()));
-  __ EmitEagerDeoptIf(overflow, DeoptimizeReason::kOverflow, this);
-}
-
-void CheckedSmiTagUint32::SetValueLocationConstraints() {
-  UseRegister(input());
-  DefineSameAsFirst(this);
-}
-void CheckedSmiTagUint32::GenerateCode(MaglevAssembler* masm,
-                                       const ProcessingState& state) {
-  Register reg = ToRegister(input());
-  // Perform an unsigned comparison against Smi::kMaxValue.
-  __ cmpl(reg, Immediate(Smi::kMaxValue));
-  __ EmitEagerDeoptIf(above, DeoptimizeReason::kOverflow, this);
-  __ addl(reg, reg);
-  __ Assert(no_overflow, AbortReason::kInputDoesNotFitSmi);
-}
-
-void UnsafeSmiTag::SetValueLocationConstraints() {
-  UseRegister(input());
-  DefineSameAsFirst(this);
-}
-void UnsafeSmiTag::GenerateCode(MaglevAssembler* masm,
-                                const ProcessingState& state) {
-  Register reg = ToRegister(input());
-  if (v8_flags.debug_code) {
-    if (input().node()->properties().value_representation() ==
-        ValueRepresentation::kUint32) {
-      __ cmpl(reg, Immediate(Smi::kMaxValue));
-      __ Check(below_equal, AbortReason::kInputDoesNotFitSmi);
-    }
-  }
-  __ addl(reg, reg);
-  if (v8_flags.debug_code) {
-    __ Check(no_overflow, AbortReason::kInputDoesNotFitSmi);
-  }
-}
-
 void Int32ToNumber::SetValueLocationConstraints() {
   UseRegister(input());
   DefineAsRegister(this);
-- 
2.35.1


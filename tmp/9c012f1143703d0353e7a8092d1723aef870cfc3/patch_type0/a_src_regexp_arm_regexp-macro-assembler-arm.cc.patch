diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index 4e6a0c893f2..8522b219f68 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -51,17 +51,18 @@ namespace internal {
  *  - fp[28]  old frame pointer  (r11).
  *  - fp[0..24]  backup of registers r4..r10.
  *  --- frame pointer ----
- *  - fp[-4]  end of input       (address of end of string).
- *  - fp[-8]  start of input     (address of first character in string).
- *  - fp[-12] start index        (character index of start).
- *  - fp[-16] void* input_string (location of a handle containing the string).
- *  - fp[-20] success counter    (only for global regexps to count matches).
- *  - fp[-24] Offset of location before start of input (effectively character
+ *  - fp[-4]  frame marker
+ *  - fp[-8]  end of input       (address of end of string).
+ *  - fp[-12]  start of input     (address of first character in string).
+ *  - fp[-16] start index        (character index of start).
+ *  - fp[-20] void* input_string (location of a handle containing the string).
+ *  - fp[-24] success counter    (only for global regexps to count matches).
+ *  - fp[-28] Offset of location before start of input (effectively character
  *            string start - 1). Used to initialize capture registers to a
  *            non-position.
- *  - fp[-28] At start (if 1, we are starting at the start of the
+ *  - fp[-32] At start (if 1, we are starting at the start of the
  *    string, otherwise 0)
- *  - fp[-32] register 0         (Only positions must be stored in the first
+ *  - fp[-36] register 0         (Only positions must be stored in the first
  *  -         register 1          num_saved_registers_ registers)
  *  -         ...
  *  -         register num_registers-1
@@ -155,9 +156,9 @@ void RegExpMacroAssemblerARM::Backtrack() {
   CheckPreemption();
   if (has_backtrack_limit()) {
     Label next;
-    __ ldr(r0, MemOperand(frame_pointer(), kBacktrackCount));
+    __ ldr(r0, MemOperand(frame_pointer(), kBacktrackCountOffset));
     __ add(r0, r0, Operand(1));
-    __ str(r0, MemOperand(frame_pointer(), kBacktrackCount));
+    __ str(r0, MemOperand(frame_pointer(), kBacktrackCountOffset));
     __ cmp(r0, Operand(backtrack_limit()));
     __ b(ne, &next);
 
@@ -195,7 +196,7 @@ void RegExpMacroAssemblerARM::CheckCharacterGT(base::uc16 limit,
 }
 
 void RegExpMacroAssemblerARM::CheckAtStart(int cp_offset, Label* on_at_start) {
-  __ ldr(r1, MemOperand(frame_pointer(), kStringStartMinusOne));
+  __ ldr(r1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
   __ add(r0, current_input_offset(),
          Operand(-char_size() + cp_offset * char_size()));
   __ cmp(r0, r1);
@@ -204,7 +205,7 @@ void RegExpMacroAssemblerARM::CheckAtStart(int cp_offset, Label* on_at_start) {
 
 void RegExpMacroAssemblerARM::CheckNotAtStart(int cp_offset,
                                               Label* on_not_at_start) {
-  __ ldr(r1, MemOperand(frame_pointer(), kStringStartMinusOne));
+  __ ldr(r1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
   __ add(r0, current_input_offset(),
          Operand(-char_size() + cp_offset * char_size()));
   __ cmp(r0, r1);
@@ -220,8 +221,8 @@ void RegExpMacroAssemblerARM::CheckCharacterLT(base::uc16 limit,
 void RegExpMacroAssemblerARM::CheckGreedyLoop(Label* on_equal) {
   __ ldr(r0, MemOperand(backtrack_stackpointer(), 0));
   __ cmp(current_input_offset(), r0);
-  __ add(backtrack_stackpointer(),
-         backtrack_stackpointer(), Operand(kPointerSize), LeaveCC, eq);
+  __ add(backtrack_stackpointer(), backtrack_stackpointer(),
+         Operand(kSystemPointerSize), LeaveCC, eq);
   BranchOrBacktrack(eq, on_equal);
 }
 
@@ -239,7 +240,7 @@ void RegExpMacroAssemblerARM::CheckNotBackReferenceIgnoreCase(
 
   // Check that there are enough characters left in the input.
   if (read_backward) {
-    __ ldr(r3, MemOperand(frame_pointer(), kStringStartMinusOne));
+    __ ldr(r3, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
     __ add(r3, r3, r1);
     __ cmp(current_input_offset(), r3);
     BranchOrBacktrack(le, on_no_match);
@@ -375,7 +376,7 @@ void RegExpMacroAssemblerARM::CheckNotBackReference(int start_reg,
 
   // Check that there are enough characters left in the input.
   if (read_backward) {
-    __ ldr(r3, MemOperand(frame_pointer(), kStringStartMinusOne));
+    __ ldr(r3, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
     __ add(r3, r3, r1);
     __ cmp(current_input_offset(), r3);
     BranchOrBacktrack(le, on_no_match);
@@ -670,7 +671,7 @@ void RegExpMacroAssemblerARM::PushRegExpBasePointer(Register stack_pointer,
   __ mov(scratch, Operand(ref));
   __ ldr(scratch, MemOperand(scratch));
   __ sub(scratch, stack_pointer, scratch);
-  __ str(scratch, MemOperand(frame_pointer(), kRegExpStackBasePointer));
+  __ str(scratch, MemOperand(frame_pointer(), kRegExpStackBasePointerOffset));
 }
 
 void RegExpMacroAssemblerARM::PopRegExpBasePointer(Register stack_pointer_out,
@@ -678,7 +679,7 @@ void RegExpMacroAssemblerARM::PopRegExpBasePointer(Register stack_pointer_out,
   ExternalReference ref =
       ExternalReference::address_of_regexp_stack_memory_top_address(isolate());
   __ ldr(stack_pointer_out,
-         MemOperand(frame_pointer(), kRegExpStackBasePointer));
+         MemOperand(frame_pointer(), kRegExpStackBasePointerOffset));
   __ mov(scratch, Operand(ref));
   __ ldr(scratch, MemOperand(scratch));
   __ add(stack_pointer_out, stack_pointer_out, scratch);
@@ -697,29 +698,42 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
   // is generated.
   FrameScope scope(masm_.get(), StackFrame::MANUAL);
 
-  // Actually emit code to start a new stack frame.
-  // Push arguments
-  // Save callee-save registers.
-  // Start new stack frame.
-  // Store link register in existing stack-cell.
-  // Order here should correspond to order of offset constants in header file.
+  // Emit code to start a new stack frame. In the following we push all
+  // callee-save registers (these end up above the fp) and all register
+  // arguments (in {r0,r1,r2,r3}, these end up below the fp).
   RegList registers_to_retain = {r4, r5, r6, r7, r8, r9, r10, fp};
+  __ stm(db_w, sp, registers_to_retain | lr);
+  __ mov(frame_pointer(), sp);
+
+  // Registers {r0,r1,r2,r3} are the first four arguments as per the C calling
+  // convention, and must match our specified offsets (e.g. kInputEndOffset).
+  //
+  // r0: input_string
+  // r1: start_offset
+  // r2: input_start
+  // r3: input_end
   RegList argument_registers = {r0, r1, r2, r3};
-  __ stm(db_w, sp, argument_registers | registers_to_retain | lr);
-  // Set frame pointer in space for it if this is not a direct call
-  // from generated code.
-  __ add(frame_pointer(), sp, Operand(4 * kPointerSize));
-
-  static_assert(kSuccessfulCaptures == kInputString - kSystemPointerSize);
+  // Also push the frame marker.
+  __ mov(r4, Operand(StackFrame::TypeToMarker(StackFrame::IRREGEXP)));
+  static_assert(kFrameTypeOffset == kFramePointerOffset - kSystemPointerSize);
+  static_assert(kInputEndOffset == kFrameTypeOffset - kSystemPointerSize);
+  static_assert(kInputStartOffset == kInputEndOffset - kSystemPointerSize);
+  static_assert(kStartIndexOffset == kInputStartOffset - kSystemPointerSize);
+  static_assert(kInputStringOffset == kStartIndexOffset - kSystemPointerSize);
+  __ stm(db_w, sp, argument_registers | r4);
+
+  static_assert(kSuccessfulCapturesOffset ==
+                kInputStringOffset - kSystemPointerSize);
   __ mov(r0, Operand::Zero());
   __ push(r0);  // Make room for success counter and initialize it to 0.
-  static_assert(kStringStartMinusOne ==
-                kSuccessfulCaptures - kSystemPointerSize);
+  static_assert(kStringStartMinusOneOffset ==
+                kSuccessfulCapturesOffset - kSystemPointerSize);
   __ push(r0);  // Make room for "string start - 1" constant.
-  static_assert(kBacktrackCount == kStringStartMinusOne - kSystemPointerSize);
+  static_assert(kBacktrackCountOffset ==
+                kStringStartMinusOneOffset - kSystemPointerSize);
   __ push(r0);  // The backtrack counter.
-  static_assert(kRegExpStackBasePointer ==
-                kBacktrackCount - kSystemPointerSize);
+  static_assert(kRegExpStackBasePointerOffset ==
+                kBacktrackCountOffset - kSystemPointerSize);
   __ push(r0);  // The regexp stack base ptr.
 
   // Initialize backtrack stack pointer. It must not be clobbered from here on.
@@ -744,7 +758,7 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
     __ b(ls, &stack_limit_hit);
     // Check if there is room for the variable number of registers above
     // the stack limit.
-    __ cmp(r0, Operand(num_registers_ * kPointerSize));
+    __ cmp(r0, Operand(num_registers_ * kSystemPointerSize));
     __ b(hs, &stack_ok);
     // Exit with OutOfMemory exception. There is not enough space on the stack
     // for our working registers.
@@ -761,21 +775,21 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
   }
 
   // Allocate space on stack for registers.
-  __ AllocateStackSpace(num_registers_ * kPointerSize);
+  __ AllocateStackSpace(num_registers_ * kSystemPointerSize);
   // Load string end.
-  __ ldr(end_of_input_address(), MemOperand(frame_pointer(), kInputEnd));
+  __ ldr(end_of_input_address(), MemOperand(frame_pointer(), kInputEndOffset));
   // Load input start.
-  __ ldr(r0, MemOperand(frame_pointer(), kInputStart));
+  __ ldr(r0, MemOperand(frame_pointer(), kInputStartOffset));
   // Find negative length (offset of start relative to end).
   __ sub(current_input_offset(), r0, end_of_input_address());
   // Set r0 to address of char before start of the input string
   // (effectively string position -1).
-  __ ldr(r1, MemOperand(frame_pointer(), kStartIndex));
+  __ ldr(r1, MemOperand(frame_pointer(), kStartIndexOffset));
   __ sub(r0, current_input_offset(), Operand(char_size()));
   __ sub(r0, r0, Operand(r1, LSL, (mode_ == UC16) ? 1 : 0));
   // Store this value in a local variable, for use when clearing
   // position registers.
-  __ str(r0, MemOperand(frame_pointer(), kStringStartMinusOne));
+  __ str(r0, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
 
   // Initialize code pointer register
   __ mov(code_pointer(), Operand(masm_->CodeObject()));
@@ -801,11 +815,11 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
     // Fill saved registers with initial value = start offset - 1
     if (num_saved_registers_ > 8) {
       // Address of register 0.
-      __ add(r1, frame_pointer(), Operand(kRegisterZero));
+      __ add(r1, frame_pointer(), Operand(kRegisterZeroOffset));
       __ mov(r2, Operand(num_saved_registers_));
       Label init_loop;
       __ bind(&init_loop);
-      __ str(r0, MemOperand(r1, kPointerSize, NegPostIndex));
+      __ str(r0, MemOperand(r1, kSystemPointerSize, NegPostIndex));
       __ sub(r2, r2, Operand(1), SetCC);
       __ b(ne, &init_loop);
     } else {
@@ -823,9 +837,9 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
     __ bind(&success_label_);
     if (num_saved_registers_ > 0) {
       // copy captures to output
-      __ ldr(r1, MemOperand(frame_pointer(), kInputStart));
-      __ ldr(r0, MemOperand(frame_pointer(), kRegisterOutput));
-      __ ldr(r2, MemOperand(frame_pointer(), kStartIndex));
+      __ ldr(r1, MemOperand(frame_pointer(), kInputStartOffset));
+      __ ldr(r0, MemOperand(frame_pointer(), kRegisterOutputOffset));
+      __ ldr(r2, MemOperand(frame_pointer(), kStartIndexOffset));
       __ sub(r1, end_of_input_address(), r1);
       // r1 is length of input in bytes.
       if (mode_ == UC16) {
@@ -853,19 +867,19 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
           __ add(r2, r1, Operand(r2));
           __ add(r3, r1, Operand(r3));
         }
-        __ str(r2, MemOperand(r0, kPointerSize, PostIndex));
-        __ str(r3, MemOperand(r0, kPointerSize, PostIndex));
+        __ str(r2, MemOperand(r0, kSystemPointerSize, PostIndex));
+        __ str(r3, MemOperand(r0, kSystemPointerSize, PostIndex));
       }
     }
 
     if (global()) {
       // Restart matching if the regular expression is flagged as global.
-      __ ldr(r0, MemOperand(frame_pointer(), kSuccessfulCaptures));
-      __ ldr(r1, MemOperand(frame_pointer(), kNumOutputRegisters));
-      __ ldr(r2, MemOperand(frame_pointer(), kRegisterOutput));
+      __ ldr(r0, MemOperand(frame_pointer(), kSuccessfulCapturesOffset));
+      __ ldr(r1, MemOperand(frame_pointer(), kNumOutputRegistersOffset));
+      __ ldr(r2, MemOperand(frame_pointer(), kRegisterOutputOffset));
       // Increment success counter.
       __ add(r0, r0, Operand(1));
-      __ str(r0, MemOperand(frame_pointer(), kSuccessfulCaptures));
+      __ str(r0, MemOperand(frame_pointer(), kSuccessfulCapturesOffset));
       // Capture results have been stored, so the number of remaining global
       // output registers is reduced by the number of stored captures.
       __ sub(r1, r1, Operand(num_saved_registers_));
@@ -873,13 +887,13 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
       __ cmp(r1, Operand(num_saved_registers_));
       __ b(lt, &return_r0);
 
-      __ str(r1, MemOperand(frame_pointer(), kNumOutputRegisters));
+      __ str(r1, MemOperand(frame_pointer(), kNumOutputRegistersOffset));
       // Advance the location for output.
-      __ add(r2, r2, Operand(num_saved_registers_ * kPointerSize));
-      __ str(r2, MemOperand(frame_pointer(), kRegisterOutput));
+      __ add(r2, r2, Operand(num_saved_registers_ * kSystemPointerSize));
+      __ str(r2, MemOperand(frame_pointer(), kRegisterOutputOffset));
 
       // Prepare r0 to initialize registers with its value in the next run.
-      __ ldr(r0, MemOperand(frame_pointer(), kStringStartMinusOne));
+      __ ldr(r0, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
 
       // Restore the original regexp stack pointer value (effectively, pop the
       // stored base pointer).
@@ -911,7 +925,7 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
   // Exit and return r0
   __ bind(&exit_label_);
   if (global()) {
-    __ ldr(r0, MemOperand(frame_pointer(), kSuccessfulCaptures));
+    __ ldr(r0, MemOperand(frame_pointer(), kSuccessfulCapturesOffset));
   }
 
   __ bind(&return_r0);
@@ -932,7 +946,7 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
 
   Label exit_with_exception;
 
-  // Preempt-code
+  // Preempt-code.
   if (check_preempt_label_.is_linked()) {
     SafeCallTarget(&check_preempt_label_);
 
@@ -947,7 +961,8 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
     LoadRegExpStackPointerFromMemory(backtrack_stackpointer());
 
     // String might have moved: Reload end of string from frame.
-    __ ldr(end_of_input_address(), MemOperand(frame_pointer(), kInputEnd));
+    __ ldr(end_of_input_address(),
+           MemOperand(frame_pointer(), kInputEndOffset));
     SafeReturn();
   }
 
@@ -1131,7 +1146,7 @@ void RegExpMacroAssemblerARM::WriteCurrentPositionToRegister(int reg,
 
 void RegExpMacroAssemblerARM::ClearRegisters(int reg_from, int reg_to) {
   DCHECK(reg_from <= reg_to);
-  __ ldr(r0, MemOperand(frame_pointer(), kStringStartMinusOne));
+  __ ldr(r0, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
   for (int reg = reg_from; reg <= reg_to; reg++) {
     __ str(r0, register_location(reg));
   }
@@ -1152,7 +1167,7 @@ void RegExpMacroAssemblerARM::CallCheckStackGuardState() {
 
   // We need to make room for the return address on the stack.
   int stack_alignment = base::OS::ActivationFrameAlignment();
-  DCHECK(IsAligned(stack_alignment, kPointerSize));
+  DCHECK(IsAligned(stack_alignment, kSystemPointerSize));
   __ AllocateStackSpace(stack_alignment);
 
   // r0 will point to the return address, placed by DirectCEntry.
@@ -1194,13 +1209,14 @@ int RegExpMacroAssemblerARM::CheckStackGuardState(Address* return_address,
                                                   Address re_frame) {
   InstructionStream re_code = InstructionStream::cast(Object(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
-      frame_entry<Isolate*>(re_frame, kIsolate),
-      frame_entry<int>(re_frame, kStartIndex),
-      static_cast<RegExp::CallOrigin>(frame_entry<int>(re_frame, kDirectCall)),
+      frame_entry<Isolate*>(re_frame, kIsolateOffset),
+      frame_entry<int>(re_frame, kStartIndexOffset),
+      static_cast<RegExp::CallOrigin>(
+          frame_entry<int>(re_frame, kDirectCallOffset)),
       return_address, re_code,
-      frame_entry_address<Address>(re_frame, kInputString),
-      frame_entry_address<const byte*>(re_frame, kInputStart),
-      frame_entry_address<const byte*>(re_frame, kInputEnd));
+      frame_entry_address<Address>(re_frame, kInputStringOffset),
+      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
+      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
 }
 
 
@@ -1210,7 +1226,7 @@ MemOperand RegExpMacroAssemblerARM::register_location(int register_index) {
     num_registers_ = register_index + 1;
   }
   return MemOperand(frame_pointer(),
-                    kRegisterZero - register_index * kPointerSize);
+                    kRegisterZeroOffset - register_index * kSystemPointerSize);
 }
 
 
@@ -1220,7 +1236,7 @@ void RegExpMacroAssemblerARM::CheckPosition(int cp_offset,
     __ cmp(current_input_offset(), Operand(-cp_offset * char_size()));
     BranchOrBacktrack(ge, on_outside_input);
   } else {
-    __ ldr(r1, MemOperand(frame_pointer(), kStringStartMinusOne));
+    __ ldr(r1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
     __ add(r0, current_input_offset(), Operand(cp_offset * char_size()));
     __ cmp(r0, r1);
     BranchOrBacktrack(le, on_outside_input);
@@ -1267,14 +1283,14 @@ void RegExpMacroAssemblerARM::SafeCallTarget(Label* name) {
 void RegExpMacroAssemblerARM::Push(Register source) {
   DCHECK(source != backtrack_stackpointer());
   __ str(source,
-         MemOperand(backtrack_stackpointer(), kPointerSize, NegPreIndex));
+         MemOperand(backtrack_stackpointer(), kSystemPointerSize, NegPreIndex));
 }
 
 
 void RegExpMacroAssemblerARM::Pop(Register target) {
   DCHECK(target != backtrack_stackpointer());
   __ ldr(target,
-         MemOperand(backtrack_stackpointer(), kPointerSize, PostIndex));
+         MemOperand(backtrack_stackpointer(), kSystemPointerSize, PostIndex));
 }
 
 

diff --git a/src/maglev/arm64/maglev-assembler-arm64.cc b/src/maglev/arm64/maglev-assembler-arm64.cc
index 5c6b662761e..69a5d3c9257 100644
--- a/src/maglev/arm64/maglev-assembler-arm64.cc
+++ b/src/maglev/arm64/maglev-assembler-arm64.cc
@@ -79,6 +79,50 @@ void MaglevAssembler::Allocate(RegisterSnapshot register_snapshot,
   bind(*done);
 }
 
+void MaglevAssembler::OSRPrologue(Graph* graph) {
+  DCHECK(graph->is_osr());
+  CHECK(!graph->has_recursive_calls());
+
+  uint32_t source_frame_size =
+      graph->min_maglev_stackslots_for_unoptimized_frame_size();
+
+  static_assert(StandardFrameConstants::kFixedSlotCount % 2 == 1);
+  if (source_frame_size % 2 == 0) source_frame_size++;
+
+  if (v8_flags.maglev_assert_stack_size && v8_flags.debug_code) {
+    ScratchRegisterScope temps(this);
+    Register scratch = temps.Acquire();
+    Add(scratch, sp,
+        source_frame_size * kSystemPointerSize +
+            StandardFrameConstants::kFixedFrameSizeFromFp);
+    Cmp(scratch, fp);
+    Assert(eq, AbortReason::kOsrUnexpectedStackSize);
+  }
+
+  uint32_t target_frame_size =
+      graph->tagged_stack_slots() + graph->untagged_stack_slots();
+  CHECK_EQ(target_frame_size % 2, 1);
+  CHECK_LE(source_frame_size, target_frame_size);
+  if (source_frame_size < target_frame_size) {
+    ASM_CODE_COMMENT_STRING(this, "Growing frame for OSR");
+    uint32_t additional_tagged =
+        source_frame_size < graph->tagged_stack_slots()
+            ? graph->tagged_stack_slots() - source_frame_size
+            : 0;
+    uint32_t additional_tagged_double =
+        additional_tagged / 2 + additional_tagged % 2;
+    for (size_t i = 0; i < additional_tagged_double; ++i) {
+      Push(xzr, xzr);
+    }
+    uint32_t size_so_far = source_frame_size + additional_tagged_double * 2;
+    CHECK_LE(size_so_far, target_frame_size);
+    if (size_so_far < target_frame_size) {
+      Sub(sp, sp,
+          Immediate((target_frame_size - size_so_far) * kSystemPointerSize));
+    }
+  }
+}
+
 void MaglevAssembler::Prologue(Graph* graph) {
   ScratchRegisterScope temps(this);
   //  We add two extra registers to the scope. Ideally we could add all the
@@ -90,19 +134,18 @@ void MaglevAssembler::Prologue(Graph* graph) {
   // used registers manually.
   temps.Include({x14, x15});
 
-  if (!graph->is_osr()) {
-    CallTarget();
-    BailoutIfDeoptimized();
-  }
+  DCHECK(!graph->is_osr());
+
+  CallTarget();
+  BailoutIfDeoptimized();
 
-  CHECK_IMPLIES(graph->is_osr(), !graph->has_recursive_calls());
   if (graph->has_recursive_calls()) {
     BindCallTarget(code_gen_state()->entry_label());
   }
 
   // Tiering support.
   // TODO(jgruber): Extract to a builtin.
-  if (v8_flags.turbofan && !graph->is_osr()) {
+  if (v8_flags.turbofan) {
     ScratchRegisterScope temps(this);
     Register flags = temps.Acquire();
     Register feedback_vector = temps.Acquire();
@@ -124,47 +167,6 @@ void MaglevAssembler::Prologue(Graph* graph) {
         deferred_flags_need_processing);
   }
 
-  if (graph->is_osr()) {
-    uint32_t source_frame_size =
-        graph->min_maglev_stackslots_for_unoptimized_frame_size();
-
-    static_assert(StandardFrameConstants::kFixedSlotCount % 2 == 1);
-    if (source_frame_size % 2 == 0) source_frame_size++;
-
-    if (v8_flags.maglev_assert_stack_size && v8_flags.debug_code) {
-      Register scratch = temps.Acquire();
-      Add(scratch, sp,
-          source_frame_size * kSystemPointerSize +
-              StandardFrameConstants::kFixedFrameSizeFromFp);
-      Cmp(scratch, fp);
-      Assert(eq, AbortReason::kOsrUnexpectedStackSize);
-    }
-
-    uint32_t target_frame_size =
-        graph->tagged_stack_slots() + graph->untagged_stack_slots();
-    CHECK_EQ(target_frame_size % 2, 1);
-    CHECK_LE(source_frame_size, target_frame_size);
-    if (source_frame_size < target_frame_size) {
-      ASM_CODE_COMMENT_STRING(this, "Growing frame for OSR");
-      uint32_t additional_tagged =
-          source_frame_size < graph->tagged_stack_slots()
-              ? graph->tagged_stack_slots() - source_frame_size
-              : 0;
-      uint32_t additional_tagged_double =
-          additional_tagged / 2 + additional_tagged % 2;
-      for (size_t i = 0; i < additional_tagged_double; ++i) {
-        Push(xzr, xzr);
-      }
-      uint32_t size_so_far = source_frame_size + additional_tagged_double * 2;
-      CHECK_LE(size_so_far, target_frame_size);
-      if (size_so_far < target_frame_size) {
-        Sub(sp, sp,
-            Immediate((target_frame_size - size_so_far) * kSystemPointerSize));
-      }
-    }
-    return;
-  }
-
   EnterFrame(StackFrame::MAGLEV);
 
   // Save arguments in frame.

diff --git a/src/regexp/loong64/regexp-macro-assembler-loong64.cc b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
index 534664d1b21..1e61bb8dd21 100644
--- a/src/regexp/loong64/regexp-macro-assembler-loong64.cc
+++ b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
@@ -36,26 +36,27 @@ namespace internal {
  *
  * The stack will have the following structure:
  *
- *  - fp[80]  Isolate* isolate   (address of the current isolate)               kIsolate
- *                                                                              kStackFrameHeader
+ *  - fp[80]  Isolate* isolate   (address of the current isolate)               kIsolateOffset
+ *                                                                              kStackFrameHeaderOffset
  *  --- sp when called ---
- *  - fp[72]  ra                 Return from RegExp code (ra).                  kReturnAddress
+ *  - fp[72]  ra                 Return from RegExp code (ra).                  kReturnAddressOffset
  *  - fp[64]  old-fp             Old fp, callee saved.
  *  - fp[0..63]  s0..s7          Callee-saved registers s0..s7.
  *  --- frame pointer ----
- *  - fp[-8]  direct_call        (1 = direct call from JS, 0 = from runtime)    kDirectCall
- *  - fp[-16] capture array size (may fit multiple sets of matches)             kNumOutputRegisters
- *  - fp[-24] int* capture_array (int[num_saved_registers_], for output).       kRegisterOutput
- *  - fp[-32] end of input       (address of end of string).                    kInputEnd
- *  - fp[-40] start of input     (address of first character in string).        kInputStart
- *  - fp[-48] start index        (character index of start).                    kStartIndex
- *  - fp[-56] void* input_string (location of a handle containing the string).  kInputString
- *  - fp[-64] success counter    (only for global regexps to count matches).    kSuccessfulCaptures
- *  - fp[-72] Offset of location before start of input (effectively character   kStringStartMinusOne
+ *  - fp[-8]  frame marker
+ *  - fp[-16] direct_call        (1 = direct call from JS, 0 = from runtime)    kDirectCallOffset
+ *  - fp[-24] capture array size (may fit multiple sets of matches)             kNumOutputRegistersOffset
+ *  - fp[-32] int* capture_array (int[num_saved_registers_], for output).       kRegisterOutputOffset
+ *  - fp[-40] end of input       (address of end of string).                    kInputEndOffset
+ *  - fp[-48] start of input     (address of first character in string).        kInputStartOffset
+ *  - fp[-56] start index        (character index of start).                    kStartIndexOffset
+ *  - fp[-64] void* input_string (location of a handle containing the string).  kInputStringOffset
+ *  - fp[-72] success counter    (only for global regexps to count matches).    kSuccessfulCapturesOffset
+ *  - fp[-80] Offset of location before start of input (effectively character   kStringStartMinusOneOffsetOffset
  *            position -1). Used to initialize capture registers to a
  *            non-position.
  *  --------- The following output registers are 32-bit values. ---------
- *  - fp[-80] register 0         (Only positions must be stored in the first    kRegisterZero
+ *  - fp[-88] register 0         (Only positions must be stored in the first    kRegisterZeroOffset
  *  -         register 1          num_saved_registers_ registers)
  *  -         ...
  *  -         register num_registers-1
@@ -84,15 +85,13 @@ namespace internal {
 
 #define __ ACCESS_MASM(masm_)
 
-const int RegExpMacroAssemblerLOONG64::kRegExpCodeSize;
-
 RegExpMacroAssemblerLOONG64::RegExpMacroAssemblerLOONG64(Isolate* isolate,
                                                          Zone* zone, Mode mode,
                                                          int registers_to_save)
     : NativeRegExpMacroAssembler(isolate, zone),
       masm_(std::make_unique<MacroAssembler>(
           isolate, CodeObjectRequired::kYes,
-          NewAssemblerBuffer(kRegExpCodeSize))),
+          NewAssemblerBuffer(kInitialBufferSize))),
       no_root_array_scope_(masm_.get()),
       mode_(mode),
       num_registers_(registers_to_save),
@@ -151,9 +150,9 @@ void RegExpMacroAssemblerLOONG64::Backtrack() {
   CheckPreemption();
   if (has_backtrack_limit()) {
     Label next;
-    __ Ld_d(a0, MemOperand(frame_pointer(), kBacktrackCount));
+    __ Ld_d(a0, MemOperand(frame_pointer(), kBacktrackCountOffset));
     __ Add_d(a0, a0, Operand(1));
-    __ St_d(a0, MemOperand(frame_pointer(), kBacktrackCount));
+    __ St_d(a0, MemOperand(frame_pointer(), kBacktrackCountOffset));
     __ Branch(&next, ne, a0, Operand(backtrack_limit()));
 
     // Backtrack limit exceeded.
@@ -185,7 +184,7 @@ void RegExpMacroAssemblerLOONG64::CheckCharacterGT(base::uc16 limit,
 
 void RegExpMacroAssemblerLOONG64::CheckAtStart(int cp_offset,
                                                Label* on_at_start) {
-  __ Ld_d(a1, MemOperand(frame_pointer(), kStringStartMinusOne));
+  __ Ld_d(a1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
   __ Add_d(a0, current_input_offset(),
            Operand(-char_size() + cp_offset * char_size()));
   BranchOrBacktrack(on_at_start, eq, a0, Operand(a1));
@@ -193,7 +192,7 @@ void RegExpMacroAssemblerLOONG64::CheckAtStart(int cp_offset,
 
 void RegExpMacroAssemblerLOONG64::CheckNotAtStart(int cp_offset,
                                                   Label* on_not_at_start) {
-  __ Ld_d(a1, MemOperand(frame_pointer(), kStringStartMinusOne));
+  __ Ld_d(a1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
   __ Add_d(a0, current_input_offset(),
            Operand(-char_size() + cp_offset * char_size()));
   BranchOrBacktrack(on_not_at_start, ne, a0, Operand(a1));
@@ -227,7 +226,7 @@ void RegExpMacroAssemblerLOONG64::CheckNotBackReferenceIgnoreCase(
   __ Branch(&fallthrough, eq, a1, Operand(zero_reg));
 
   if (read_backward) {
-    __ Ld_d(t1, MemOperand(frame_pointer(), kStringStartMinusOne));
+    __ Ld_d(t1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
     __ Add_d(t1, t1, a1);
     BranchOrBacktrack(on_no_match, le, current_input_offset(), Operand(t1));
   } else {
@@ -361,7 +360,7 @@ void RegExpMacroAssemblerLOONG64::CheckNotBackReference(int start_reg,
   __ Branch(&fallthrough, eq, a1, Operand(zero_reg));
 
   if (read_backward) {
-    __ Ld_d(t1, MemOperand(frame_pointer(), kStringStartMinusOne));
+    __ Ld_d(t1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
     __ Add_d(t1, t1, a1);
     BranchOrBacktrack(on_no_match, le, current_input_offset(), Operand(t1));
   } else {
@@ -626,7 +625,7 @@ void RegExpMacroAssemblerLOONG64::PushRegExpBasePointer(Register stack_pointer,
   __ li(scratch, ref);
   __ Ld_d(scratch, MemOperand(scratch, 0));
   __ Sub_d(scratch, stack_pointer, scratch);
-  __ St_d(scratch, MemOperand(frame_pointer(), kRegExpStackBasePointer));
+  __ St_d(scratch, MemOperand(frame_pointer(), kRegExpStackBasePointerOffset));
 }
 
 void RegExpMacroAssemblerLOONG64::PopRegExpBasePointer(
@@ -634,7 +633,7 @@ void RegExpMacroAssemblerLOONG64::PopRegExpBasePointer(
   ExternalReference ref =
       ExternalReference::address_of_regexp_stack_memory_top_address(isolate());
   __ Ld_d(stack_pointer_out,
-          MemOperand(frame_pointer(), kRegExpStackBasePointer));
+          MemOperand(frame_pointer(), kRegExpStackBasePointerOffset));
   __ li(scratch, ref);
   __ Ld_d(scratch, MemOperand(scratch, 0));
   __ Add_d(stack_pointer_out, stack_pointer_out, scratch);
@@ -659,34 +658,48 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
     // no is generated.
     FrameScope scope(masm_.get(), StackFrame::MANUAL);
 
-    // Actually emit code to start a new stack frame.
-    // Push arguments
-    // Save callee-save registers.
-    // Start new stack frame.
-    // Store link register in existing stack-cell.
-    // Order here should correspond to order of offset constants in header file.
+    // Emit code to start a new stack frame. In the following we push all
+    // callee-save registers (these end up above the fp) and all register
+    // arguments (in {a0,a1,a2,a3}, these end up below the fp).
     // TODO(plind): we save s0..s7, but ONLY use s3 here - use the regs
     // or dont save.
     RegList registers_to_retain = {s0, s1, s2, s3, s4, s5, s6, s7};
-    RegList argument_registers = {a0, a1, a2, a3};
 
+    __ MultiPush({ra}, {fp}, registers_to_retain);
+    __ mov(frame_pointer(), sp);
+
+    // Registers {a0,a1,a2,a3} are the first four arguments as per the C calling
+    // convention, and must match our specified offsets (e.g. kInputEndOffset).
+    //
+    // a0: input_string
+    // a1: start_offset
+    // a2: input_start
+    // a3: input_end
+    RegList argument_registers = {a0, a1, a2, a3};
     argument_registers |= {a4, a5, a6, a7};
 
-    __ MultiPush({ra}, {fp}, argument_registers | registers_to_retain);
-    // Set frame pointer in space for it if this is not a direct call
-    // from generated code.
-    // TODO(plind): this 8 is the # of argument regs, should have definition.
-    __ Add_d(frame_pointer(), sp, Operand(8 * kPointerSize));
-    static_assert(kSuccessfulCaptures == kInputString - kSystemPointerSize);
+    // Also push the frame marker.
+    __ li(kScratchReg, Operand(StackFrame::TypeToMarker(StackFrame::IRREGEXP)));
+    static_assert(kFrameTypeOffset == kFramePointerOffset - kSystemPointerSize);
+    static_assert(kInputEndOffset ==
+                  kRegisterOutputOffset - kSystemPointerSize);
+    static_assert(kInputStartOffset == kInputEndOffset - kSystemPointerSize);
+    static_assert(kStartIndexOffset == kInputStartOffset - kSystemPointerSize);
+    static_assert(kInputStringOffset == kStartIndexOffset - kSystemPointerSize);
+    __ MultiPush(argument_registers | kScratchReg);
+
+    static_assert(kSuccessfulCapturesOffset ==
+                  kInputStringOffset - kSystemPointerSize);
     __ mov(a0, zero_reg);
     __ Push(a0);  // Make room for success counter and initialize it to 0.
-    static_assert(kStringStartMinusOne ==
-                  kSuccessfulCaptures - kSystemPointerSize);
+    static_assert(kStringStartMinusOneOffset ==
+                  kSuccessfulCapturesOffset - kSystemPointerSize);
     __ Push(a0);  // Make room for "string start - 1" constant.
-    static_assert(kBacktrackCount == kStringStartMinusOne - kSystemPointerSize);
+    static_assert(kBacktrackCountOffset ==
+                  kStringStartMinusOneOffset - kSystemPointerSize);
     __ Push(a0);  // The backtrack counter
-    static_assert(kRegExpStackBasePointer ==
-                  kBacktrackCount - kSystemPointerSize);
+    static_assert(kRegExpStackBasePointerOffset ==
+                  kBacktrackCountOffset - kSystemPointerSize);
     __ Push(a0);  // The regexp stack base ptr.
 
     // Initialize backtrack stack pointer. It must not be clobbered from here
@@ -729,20 +742,21 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
     // Allocate space on stack for registers.
     __ Sub_d(sp, sp, Operand(num_registers_ * kPointerSize));
     // Load string end.
-    __ Ld_d(end_of_input_address(), MemOperand(frame_pointer(), kInputEnd));
+    __ Ld_d(end_of_input_address(),
+            MemOperand(frame_pointer(), kInputEndOffset));
     // Load input start.
-    __ Ld_d(a0, MemOperand(frame_pointer(), kInputStart));
+    __ Ld_d(a0, MemOperand(frame_pointer(), kInputStartOffset));
     // Find negative length (offset of start relative to end).
     __ Sub_d(current_input_offset(), a0, end_of_input_address());
     // Set a0 to address of char before start of the input string
     // (effectively string position -1).
-    __ Ld_d(a1, MemOperand(frame_pointer(), kStartIndex));
+    __ Ld_d(a1, MemOperand(frame_pointer(), kStartIndexOffset));
     __ Sub_d(a0, current_input_offset(), Operand(char_size()));
     __ slli_d(t1, a1, (mode_ == UC16) ? 1 : 0);
     __ Sub_d(a0, a0, t1);
     // Store this value in a local variable, for use when clearing
     // position registers.
-    __ St_d(a0, MemOperand(frame_pointer(), kStringStartMinusOne));
+    __ St_d(a0, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
 
     // Initialize code pointer register
     __ li(code_pointer(), Operand(masm_->CodeObject()), CONSTANT_SIZE);
@@ -767,7 +781,7 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
       // Fill saved registers with initial value = start offset - 1.
       if (num_saved_registers_ > 8) {
         // Address of register 0.
-        __ Add_d(a1, frame_pointer(), Operand(kRegisterZero));
+        __ Add_d(a1, frame_pointer(), Operand(kRegisterZeroOffset));
         __ li(a2, Operand(num_saved_registers_));
         Label init_loop;
         __ bind(&init_loop);
@@ -790,9 +804,9 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
       __ bind(&success_label_);
       if (num_saved_registers_ > 0) {
         // Copy captures to output.
-        __ Ld_d(a1, MemOperand(frame_pointer(), kInputStart));
-        __ Ld_d(a0, MemOperand(frame_pointer(), kRegisterOutput));
-        __ Ld_d(a2, MemOperand(frame_pointer(), kStartIndex));
+        __ Ld_d(a1, MemOperand(frame_pointer(), kInputStartOffset));
+        __ Ld_d(a0, MemOperand(frame_pointer(), kRegisterOutputOffset));
+        __ Ld_d(a2, MemOperand(frame_pointer(), kStartIndexOffset));
         __ Sub_d(a1, end_of_input_address(), a1);
         // a1 is length of input in bytes.
         if (mode_ == UC16) {
@@ -832,12 +846,12 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
 
       if (global()) {
         // Restart matching if the regular expression is flagged as global.
-        __ Ld_d(a0, MemOperand(frame_pointer(), kSuccessfulCaptures));
-        __ Ld_d(a1, MemOperand(frame_pointer(), kNumOutputRegisters));
-        __ Ld_d(a2, MemOperand(frame_pointer(), kRegisterOutput));
+        __ Ld_d(a0, MemOperand(frame_pointer(), kSuccessfulCapturesOffset));
+        __ Ld_d(a1, MemOperand(frame_pointer(), kNumOutputRegistersOffset));
+        __ Ld_d(a2, MemOperand(frame_pointer(), kRegisterOutputOffset));
         // Increment success counter.
         __ Add_d(a0, a0, 1);
-        __ St_d(a0, MemOperand(frame_pointer(), kSuccessfulCaptures));
+        __ St_d(a0, MemOperand(frame_pointer(), kSuccessfulCapturesOffset));
         // Capture results have been stored, so the number of remaining global
         // output registers is reduced by the number of stored captures.
         __ Sub_d(a1, a1, num_saved_registers_);
@@ -845,13 +859,13 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
         //__ mov(v0, a0);
         __ Branch(&return_v0, lt, a1, Operand(num_saved_registers_));
 
-        __ St_d(a1, MemOperand(frame_pointer(), kNumOutputRegisters));
+        __ St_d(a1, MemOperand(frame_pointer(), kNumOutputRegistersOffset));
         // Advance the location for output.
         __ Add_d(a2, a2, num_saved_registers_ * kIntSize);
-        __ St_d(a2, MemOperand(frame_pointer(), kRegisterOutput));
+        __ St_d(a2, MemOperand(frame_pointer(), kRegisterOutputOffset));
 
         // Prepare a0 to initialize registers with its value in the next run.
-        __ Ld_d(a0, MemOperand(frame_pointer(), kStringStartMinusOne));
+        __ Ld_d(a0, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
 
         // Restore the original regexp stack pointer value (effectively, pop the
         // stored base pointer).
@@ -882,7 +896,7 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
     // Exit and return v0.
     __ bind(&exit_label_);
     if (global()) {
-      __ Ld_d(a0, MemOperand(frame_pointer(), kSuccessfulCaptures));
+      __ Ld_d(a0, MemOperand(frame_pointer(), kSuccessfulCapturesOffset));
     }
 
     __ bind(&return_v0);
@@ -918,7 +932,8 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
       LoadRegExpStackPointerFromMemory(backtrack_stackpointer());
 
       // String might have moved: Reload end of string from frame.
-      __ Ld_d(end_of_input_address(), MemOperand(frame_pointer(), kInputEnd));
+      __ Ld_d(end_of_input_address(),
+              MemOperand(frame_pointer(), kInputEndOffset));
 
       SafeReturn();
     }
@@ -1104,7 +1119,7 @@ void RegExpMacroAssemblerLOONG64::WriteCurrentPositionToRegister(
 
 void RegExpMacroAssemblerLOONG64::ClearRegisters(int reg_from, int reg_to) {
   DCHECK(reg_from <= reg_to);
-  __ Ld_d(a0, MemOperand(frame_pointer(), kStringStartMinusOne));
+  __ Ld_d(a0, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
   for (int reg = reg_from; reg <= reg_to; reg++) {
     __ St_d(a0, register_location(reg));
   }
@@ -1187,14 +1202,14 @@ int64_t RegExpMacroAssemblerLOONG64::CheckStackGuardState(
     Address* return_address, Address raw_code, Address re_frame) {
   InstructionStream re_code = InstructionStream::cast(Object(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
-      frame_entry<Isolate*>(re_frame, kIsolate),
-      static_cast<int>(frame_entry<int64_t>(re_frame, kStartIndex)),
+      frame_entry<Isolate*>(re_frame, kIsolateOffset),
+      static_cast<int>(frame_entry<int64_t>(re_frame, kStartIndexOffset)),
       static_cast<RegExp::CallOrigin>(
-          frame_entry<int64_t>(re_frame, kDirectCall)),
+          frame_entry<int64_t>(re_frame, kDirectCallOffset)),
       return_address, re_code,
-      frame_entry_address<Address>(re_frame, kInputString),
-      frame_entry_address<const byte*>(re_frame, kInputStart),
-      frame_entry_address<const byte*>(re_frame, kInputEnd));
+      frame_entry_address<Address>(re_frame, kInputStringOffset),
+      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
+      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
 }
 
 MemOperand RegExpMacroAssemblerLOONG64::register_location(int register_index) {
@@ -1203,7 +1218,7 @@ MemOperand RegExpMacroAssemblerLOONG64::register_location(int register_index) {
     num_registers_ = register_index + 1;
   }
   return MemOperand(frame_pointer(),
-                    kRegisterZero - register_index * kPointerSize);
+                    kRegisterZeroOffset - register_index * kPointerSize);
 }
 
 void RegExpMacroAssemblerLOONG64::CheckPosition(int cp_offset,
@@ -1212,7 +1227,7 @@ void RegExpMacroAssemblerLOONG64::CheckPosition(int cp_offset,
     BranchOrBacktrack(on_outside_input, ge, current_input_offset(),
                       Operand(-cp_offset * char_size()));
   } else {
-    __ Ld_d(a1, MemOperand(frame_pointer(), kStringStartMinusOne));
+    __ Ld_d(a1, MemOperand(frame_pointer(), kStringStartMinusOneOffset));
     __ Add_d(a0, current_input_offset(), Operand(cp_offset * char_size()));
     BranchOrBacktrack(on_outside_input, le, a0, Operand(a1));
   }

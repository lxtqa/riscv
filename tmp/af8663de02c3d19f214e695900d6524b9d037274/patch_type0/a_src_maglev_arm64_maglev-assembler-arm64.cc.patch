diff --git a/src/maglev/arm64/maglev-assembler-arm64.cc b/src/maglev/arm64/maglev-assembler-arm64.cc
index 2a2969877c6..bd7a76d975d 100644
--- a/src/maglev/arm64/maglev-assembler-arm64.cc
+++ b/src/maglev/arm64/maglev-assembler-arm64.cc
@@ -410,8 +410,8 @@ void MaglevAssembler::Prologue(Graph* graph) {
     ZoneLabelRef deferred_call_stack_guard_return(this);
     JumpToDeferredIf(
         lo,
-        [](MaglevAssembler* masm, ZoneLabelRef done, RegList register_inputs,
-           int stack_check_offset) {
+        [](MaglevAssembler* masm, LazyDeoptInfo* stack_check_deopt,
+           ZoneLabelRef done, RegList register_inputs, int stack_check_offset) {
           ASM_CODE_COMMENT_STRING(masm, "Stack/interrupt call");
           __ PushAll(register_inputs);
           ScratchRegisterScope temps(masm);
@@ -420,10 +420,14 @@ void MaglevAssembler::Prologue(Graph* graph) {
                  Smi::FromInt(stack_check_offset * kSystemPointerSize));
           __ PushArgument(scratch);
           __ CallRuntime(Runtime::kStackGuardWithGap, 1);
+          stack_check_deopt->set_deopting_call_return_pc(
+              __ pc_offset_for_safepoint());
+          __ code_gen_state()->PushLazyDeopt(stack_check_deopt);
           masm->safepoint_table_builder()->DefineSafepoint(masm);
           __ PopAll(register_inputs);
           __ B(*done);
         },
+        graph->function_entry_stack_check()->lazy_deopt_info(),
         deferred_call_stack_guard_return, graph->register_inputs(),
         stack_check_offset);
     bind(*deferred_call_stack_guard_return);

diff --git a/src/diagnostics/ia32/disasm-ia32.cc b/src/diagnostics/ia32/disasm-ia32.cc
index 5f19dd03e0..92929b0917 100644
--- a/src/diagnostics/ia32/disasm-ia32.cc
+++ b/src/diagnostics/ia32/disasm-ia32.cc
@@ -115,7 +115,7 @@ struct InstructionDesc {
 class InstructionTable {
  public:
   InstructionTable();
-  const InstructionDesc& Get(byte x) const { return instructions_[x]; }
+  const InstructionDesc& Get(uint8_t x) const { return instructions_[x]; }
   static InstructionTable* get_instance() {
     static InstructionTable table;
     return &table;
@@ -126,7 +126,7 @@ class InstructionTable {
   void Clear();
   void Init();
   void CopyTable(const ByteMnemonic bm[], InstructionType type);
-  void SetTableRange(InstructionType type, byte start, byte end,
+  void SetTableRange(InstructionType type, uint8_t start, uint8_t end,
                      const char* mnem);
   void AddJumpConditionalShort();
 };
@@ -170,9 +170,9 @@ void InstructionTable::CopyTable(const ByteMnemonic bm[],
   }
 }
 
-void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
-                                     const char* mnem) {
-  for (byte b = start; b <= end; b++) {
+void InstructionTable::SetTableRange(InstructionType type, uint8_t start,
+                                     uint8_t end, const char* mnem) {
+  for (uint8_t b = start; b <= end; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered.
     id->mnem = mnem;
@@ -181,7 +181,7 @@ void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
 }
 
 void InstructionTable::AddJumpConditionalShort() {
-  for (byte b = 0x70; b <= 0x7F; b++) {
+  for (uint8_t b = 0x70; b <= 0x7F; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered.
     id->mnem = jump_conditional_mnem[b & 0x0F];
@@ -227,13 +227,13 @@ class DisassemblerIA32 {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(v8::base::Vector<char> buffer, byte* instruction);
+  int InstructionDecode(v8::base::Vector<char> buffer, uint8_t* instruction);
 
  private:
   const NameConverter& converter_;
-  byte vex_byte0_;  // 0xC4 or 0xC5
-  byte vex_byte1_;
-  byte vex_byte2_;  // only for 3 bytes vex prefix
+  uint8_t vex_byte0_;  // 0xC4 or 0xC5
+  uint8_t vex_byte1_;
+  uint8_t vex_byte2_;  // only for 3 bytes vex prefix
   InstructionTable* instruction_table_;
   v8::base::EmbeddedVector<char, 128> tmp_buffer_;
   unsigned int tmp_buffer_pos_;
@@ -262,31 +262,31 @@ class DisassemblerIA32 {
 
   bool vex_128() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 4) == 0;
   }
 
   bool vex_none() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 0;
   }
 
   bool vex_66() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 1;
   }
 
   bool vex_f3() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 2;
   }
 
   bool vex_f2() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 3;
   }
 
@@ -312,7 +312,7 @@ class DisassemblerIA32 {
 
   int vex_vreg() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return ~(checked >> 3) & 0xF;
   }
 
@@ -330,18 +330,18 @@ class DisassemblerIA32 {
     return converter_.NameOfXMMRegister(reg);
   }
 
-  const char* NameOfAddress(byte* addr) const {
+  const char* NameOfAddress(uint8_t* addr) const {
     return converter_.NameOfAddress(addr);
   }
 
   // Disassembler helper functions.
-  static void get_modrm(byte data, int* mod, int* regop, int* rm) {
+  static void get_modrm(uint8_t data, int* mod, int* regop, int* rm) {
     *mod = (data >> 6) & 3;
     *regop = (data & 0x38) >> 3;
     *rm = data & 7;
   }
 
-  static void get_sib(byte data, int* scale, int* index, int* base) {
+  static void get_sib(uint8_t data, int* scale, int* index, int* base) {
     *scale = (data >> 6) & 3;
     *index = (data >> 3) & 7;
     *base = data & 7;
@@ -349,23 +349,24 @@ class DisassemblerIA32 {
 
   using RegisterNameMapping = const char* (DisassemblerIA32::*)(int reg) const;
 
-  int PrintRightOperandHelper(byte* modrmp, RegisterNameMapping register_name);
-  int PrintRightOperand(byte* modrmp);
-  int PrintRightByteOperand(byte* modrmp);
-  int PrintRightXMMOperand(byte* modrmp);
-  int PrintOperands(const char* mnem, OperandOrder op_order, byte* data);
-  int PrintImmediateOp(byte* data);
-  int F7Instruction(byte* data);
-  int D1D3C1Instruction(byte* data);
-  int JumpShort(byte* data);
-  int JumpConditional(byte* data, const char* comment);
-  int JumpConditionalShort(byte* data, const char* comment);
-  int SetCC(byte* data);
-  int CMov(byte* data);
-  int FPUInstruction(byte* data);
-  int MemoryFPUInstruction(int escape_opcode, int regop, byte* modrm_start);
-  int RegisterFPUInstruction(int escape_opcode, byte modrm_byte);
-  int AVXInstruction(byte* data);
+  int PrintRightOperandHelper(uint8_t* modrmp,
+                              RegisterNameMapping register_name);
+  int PrintRightOperand(uint8_t* modrmp);
+  int PrintRightByteOperand(uint8_t* modrmp);
+  int PrintRightXMMOperand(uint8_t* modrmp);
+  int PrintOperands(const char* mnem, OperandOrder op_order, uint8_t* data);
+  int PrintImmediateOp(uint8_t* data);
+  int F7Instruction(uint8_t* data);
+  int D1D3C1Instruction(uint8_t* data);
+  int JumpShort(uint8_t* data);
+  int JumpConditional(uint8_t* data, const char* comment);
+  int JumpConditionalShort(uint8_t* data, const char* comment);
+  int SetCC(uint8_t* data);
+  int CMov(uint8_t* data);
+  int FPUInstruction(uint8_t* data);
+  int MemoryFPUInstruction(int escape_opcode, int regop, uint8_t* modrm_start);
+  int RegisterFPUInstruction(int escape_opcode, uint8_t modrm_byte);
+  int AVXInstruction(uint8_t* data);
   PRINTF_FORMAT(2, 3) void AppendToBuffer(const char* format, ...);
 
   void UnimplementedInstruction() {
@@ -388,7 +389,7 @@ void DisassemblerIA32::AppendToBuffer(const char* format, ...) {
 }
 
 int DisassemblerIA32::PrintRightOperandHelper(
-    byte* modrmp, RegisterNameMapping direct_register_name) {
+    uint8_t* modrmp, RegisterNameMapping direct_register_name) {
   int mod, regop, rm;
   get_modrm(*modrmp, &mod, &regop, &rm);
   RegisterNameMapping register_name =
@@ -399,7 +400,7 @@ int DisassemblerIA32::PrintRightOperandHelper(
         AppendToBuffer("[0x%x]", Imm32(modrmp + 1));
         return 5;
       } else if (rm == esp) {
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         if (index == esp && base == esp && scale == 0 /*times_1*/) {
@@ -426,7 +427,7 @@ int DisassemblerIA32::PrintRightOperandHelper(
     case 1:  // fall through
     case 2: {
       if (rm == esp) {
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         int disp = mod == 2 ? Imm32(modrmp + 2) : Imm8(modrmp + 2);
@@ -456,24 +457,24 @@ int DisassemblerIA32::PrintRightOperandHelper(
   UNREACHABLE();
 }
 
-int DisassemblerIA32::PrintRightOperand(byte* modrmp) {
+int DisassemblerIA32::PrintRightOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerIA32::NameOfCPURegister);
 }
 
-int DisassemblerIA32::PrintRightByteOperand(byte* modrmp) {
+int DisassemblerIA32::PrintRightByteOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp,
                                  &DisassemblerIA32::NameOfByteCPURegister);
 }
 
-int DisassemblerIA32::PrintRightXMMOperand(byte* modrmp) {
+int DisassemblerIA32::PrintRightXMMOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerIA32::NameOfXMMRegister);
 }
 
 // Returns number of bytes used including the current *data.
 // Writes instruction's mnemonic, left and right operands to 'tmp_buffer_'.
 int DisassemblerIA32::PrintOperands(const char* mnem, OperandOrder op_order,
-                                    byte* data) {
-  byte modrm = *data;
+                                    uint8_t* data) {
+  uint8_t modrm = *data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   int advance = 0;
@@ -497,9 +498,9 @@ int DisassemblerIA32::PrintOperands(const char* mnem, OperandOrder op_order,
 
 // Returns number of bytes used by machine instruction, including *data byte.
 // Writes immediate instructions to 'tmp_buffer_'.
-int DisassemblerIA32::PrintImmediateOp(byte* data) {
+int DisassemblerIA32::PrintImmediateOp(uint8_t* data) {
   bool sign_extension_bit = (*data & 0x02) != 0;
-  byte modrm = *(data + 1);
+  uint8_t modrm = *(data + 1);
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   const char* mnem = "Imm???";
@@ -540,9 +541,9 @@ int DisassemblerIA32::PrintImmediateOp(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::F7Instruction(byte* data) {
+int DisassemblerIA32::F7Instruction(uint8_t* data) {
   DCHECK_EQ(0xF7, *data);
-  byte modrm = *++data;
+  uint8_t modrm = *++data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   const char* mnem = "";
@@ -580,10 +581,10 @@ int DisassemblerIA32::F7Instruction(byte* data) {
   return 1 + count;
 }
 
-int DisassemblerIA32::D1D3C1Instruction(byte* data) {
-  byte op = *data;
+int DisassemblerIA32::D1D3C1Instruction(uint8_t* data) {
+  uint8_t op = *data;
   DCHECK(op == 0xD1 || op == 0xD3 || op == 0xC1);
-  byte modrm = *++data;
+  uint8_t modrm = *++data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   int imm8 = -1;
@@ -632,19 +633,19 @@ int DisassemblerIA32::D1D3C1Instruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::JumpShort(byte* data) {
+int DisassemblerIA32::JumpShort(uint8_t* data) {
   DCHECK_EQ(0xEB, *data);
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   AppendToBuffer("jmp %s", NameOfAddress(dest));
   return 2;
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::JumpConditional(byte* data, const char* comment) {
+int DisassemblerIA32::JumpConditional(uint8_t* data, const char* comment) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
-  byte* dest = data + Imm32(data + 2) + 6;
+  uint8_t cond = *(data + 1) & 0x0F;
+  uint8_t* dest = data + Imm32(data + 2) + 6;
   const char* mnem = jump_conditional_mnem[cond];
   AppendToBuffer("%s %s", mnem, NameOfAddress(dest));
   if (comment != nullptr) {
@@ -654,10 +655,10 @@ int DisassemblerIA32::JumpConditional(byte* data, const char* comment) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::JumpConditionalShort(byte* data, const char* comment) {
-  byte cond = *data & 0x0F;
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+int DisassemblerIA32::JumpConditionalShort(uint8_t* data, const char* comment) {
+  uint8_t cond = *data & 0x0F;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   const char* mnem = jump_conditional_mnem[cond];
   AppendToBuffer("%s %s", mnem, NameOfAddress(dest));
   if (comment != nullptr) {
@@ -667,9 +668,9 @@ int DisassemblerIA32::JumpConditionalShort(byte* data, const char* comment) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::SetCC(byte* data) {
+int DisassemblerIA32::SetCC(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
+  uint8_t cond = *(data + 1) & 0x0F;
   const char* mnem = set_conditional_mnem[cond];
   AppendToBuffer("%s ", mnem);
   PrintRightByteOperand(data + 2);
@@ -677,9 +678,9 @@ int DisassemblerIA32::SetCC(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::CMov(byte* data) {
+int DisassemblerIA32::CMov(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
+  uint8_t cond = *(data + 1) & 0x0F;
   const char* mnem = conditional_move_mnem[cond];
   int op_size = PrintOperands(mnem, REG_OPER_OP_ORDER, data + 2);
   return 2 + op_size;  // includes 0x0F
@@ -687,9 +688,9 @@ int DisassemblerIA32::CMov(byte* data) {
 
 const char* sf_str[4] = {"", "rl", "ra", "ll"};
 
-int DisassemblerIA32::AVXInstruction(byte* data) {
-  byte opcode = *data;
-  byte* current = data + 1;
+int DisassemblerIA32::AVXInstruction(uint8_t* data) {
+  uint8_t opcode = *data;
+  uint8_t* current = data + 1;
   if (vex_66() && vex_0f38()) {
     int mod, regop, rm, vvvv = vex_vreg();
     get_modrm(*current, &mod, &regop, &rm);
@@ -1406,10 +1407,10 @@ int DisassemblerIA32::AVXInstruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::FPUInstruction(byte* data) {
-  byte escape_opcode = *data;
+int DisassemblerIA32::FPUInstruction(uint8_t* data) {
+  uint8_t escape_opcode = *data;
   DCHECK_EQ(0xD8, escape_opcode & 0xF8);
-  byte modrm_byte = *(data + 1);
+  uint8_t modrm_byte = *(data + 1);
 
   if (modrm_byte >= 0xC0) {
     return RegisterFPUInstruction(escape_opcode, modrm_byte);
@@ -1419,7 +1420,7 @@ int DisassemblerIA32::FPUInstruction(byte* data) {
 }
 
 int DisassemblerIA32::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
-                                           byte* modrm_start) {
+                                           uint8_t* modrm_start) {
   const char* mnem = "?";
   int regop = (modrm_byte >> 3) & 0x7;  // reg/op field of modrm byte.
   switch (escape_opcode) {
@@ -1502,7 +1503,7 @@ int DisassemblerIA32::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
 }
 
 int DisassemblerIA32::RegisterFPUInstruction(int escape_opcode,
-                                             byte modrm_byte) {
+                                             uint8_t modrm_byte) {
   bool has_register = false;  // Is the FPU register encoded in modrm_byte?
   const char* mnem = "?";
 
@@ -1701,7 +1702,7 @@ int DisassemblerIA32::RegisterFPUInstruction(int escape_opcode,
 
 // Mnemonics for instructions 0xF0 byte.
 // Returns nullptr if the instruction is not handled here.
-static const char* F0Mnem(byte f0byte) {
+static const char* F0Mnem(uint8_t f0byte) {
   switch (f0byte) {
     case 0x0B:
       return "ud2";
@@ -1746,9 +1747,9 @@ static const char* F0Mnem(byte f0byte) {
 
 // Disassembled instruction '*instr' and writes it into 'out_buffer'.
 int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
-                                        byte* instr) {
+                                        uint8_t* instr) {
   tmp_buffer_pos_ = 0;  // starting to write as position 0
-  byte* data = instr;
+  uint8_t* data = instr;
   // Check for hints.
   const char* branch_hint = nullptr;
   // We use these two prefixes only with branch prediction
@@ -1800,7 +1801,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
         break;
 
       case MOVE_REG_INSTR: {
-        byte* addr = reinterpret_cast<byte*>(Imm32(data + 1));
+        uint8_t* addr = reinterpret_cast<uint8_t*>(Imm32(data + 1));
         AppendToBuffer("mov %s,%s", NameOfCPURegister(*data & 0x07),
                        NameOfAddress(addr));
         data += 5;
@@ -1808,14 +1809,14 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
       }
 
       case CALL_JUMP_INSTR: {
-        byte* addr = data + Imm32(data + 1) + 5;
+        uint8_t* addr = data + Imm32(data + 1) + 5;
         AppendToBuffer("%s %s", idesc.mnem, NameOfAddress(addr));
         data += 5;
         break;
       }
 
       case SHORT_IMMEDIATE_INSTR: {
-        byte* addr = reinterpret_cast<byte*>(Imm32(data + 1));
+        uint8_t* addr = reinterpret_cast<uint8_t*>(Imm32(data + 1));
         AppendToBuffer("%s eax,%s", idesc.mnem, NameOfAddress(addr));
         data += 5;
         break;
@@ -1878,7 +1879,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
         break;
 
       case 0x0F: {
-        byte f0byte = data[1];
+        uint8_t f0byte = data[1];
         const char* f0mnem = F0Mnem(f0byte);
         int mod, regop, rm;
         // Not every instruction use this, and it is safe to index data+2 as all
@@ -2220,7 +2221,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
             data += PrintRightXMMOperand(data);
           } else if (*data == 0x38) {
             data++;
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2268,7 +2269,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
                   "roundss",
                   "roundsd",
               };
-              byte op = *data;
+              uint8_t op = *data;
               data++;
               int mod, regop, rm;
               get_modrm(*data, &mod, &regop, &rm);
@@ -2376,7 +2377,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
             const char* const pseudo_op[] = {"andpd",   "andnpd", "orpd",
                                              "xorpd",   "addpd",  "mulpd",
                                              "cvtpd2ps"};
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2390,7 +2391,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
                 "divpd",
                 "maxpd",
             };
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2514,7 +2515,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
                            NameOfXMMRegister(rm));
             data++;
           } else {
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2592,7 +2593,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
 
       case 0xF2:
         if (*(data + 1) == 0x0F) {
-          byte b2 = *(data + 2);
+          uint8_t b2 = *(data + 2);
           if (b2 == 0x11) {
             AppendToBuffer("movsd ");
             data += 3;
@@ -2675,7 +2676,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
 
       case 0xF3:
         if (*(data + 1) == 0x0F) {
-          byte b2 = *(data + 2);
+          uint8_t b2 = *(data + 2);
           if (b2 == 0x11) {
             AppendToBuffer("movss ");
             data += 3;
@@ -2841,7 +2842,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
 
   int outp = 0;
   // Instruction bytes.
-  for (byte* bp = instr; bp < data; bp++) {
+  for (uint8_t* bp = instr; bp < data; bp++) {
     outp += v8::base::SNPrintF(out_buffer + outp, "%02x", *bp);
   }
   // Indent instruction, leaving space for 6 bytes, i.e. 12 characters in hex.
@@ -2864,12 +2865,12 @@ static const char* const byte_cpu_regs[8] = {"al", "cl", "dl", "bl",
 static const char* const xmm_regs[8] = {"xmm0", "xmm1", "xmm2", "xmm3",
                                         "xmm4", "xmm5", "xmm6", "xmm7"};
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -2888,7 +2889,7 @@ const char* NameConverter::NameOfXMMRegister(int reg) const {
   return "noxmmreg";
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // IA32 does not embed debug strings at the moment.
   UNREACHABLE();
 }
@@ -2896,28 +2897,28 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   DisassemblerIA32 d(converter_, unimplemented_opcode_action());
   return d.InstructionDecode(buffer, instruction);
 }
 
 // The IA-32 assembler does not currently use constant pools.
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
 // static
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     fprintf(f, "%p", static_cast<void*>(prev_pc));
     fprintf(f, "    ");
 
-    for (byte* bp = prev_pc; bp < pc; bp++) {
+    for (uint8_t* bp = prev_pc; bp < pc; bp++) {
       fprintf(f, "%02x", *bp);
     }
     for (int i = 6 - (pc - prev_pc); i >= 0; i--) {

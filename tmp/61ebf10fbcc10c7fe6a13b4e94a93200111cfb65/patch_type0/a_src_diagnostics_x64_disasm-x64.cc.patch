diff --git a/src/diagnostics/x64/disasm-x64.cc b/src/diagnostics/x64/disasm-x64.cc
index d569d0d4e6..74e80b26d2 100644
--- a/src/diagnostics/x64/disasm-x64.cc
+++ b/src/diagnostics/x64/disasm-x64.cc
@@ -153,15 +153,15 @@ struct InstructionDesc {
 class InstructionTable {
  public:
   InstructionTable();
-  const InstructionDesc& Get(byte x) const { return instructions_[x]; }
+  const InstructionDesc& Get(uint8_t x) const { return instructions_[x]; }
 
  private:
   InstructionDesc instructions_[256];
   void Clear();
   void Init();
   void CopyTable(const ByteMnemonic bm[], InstructionType type);
-  void SetTableRange(InstructionType type, byte start, byte end, bool byte_size,
-                     const char* mnem);
+  void SetTableRange(InstructionType type, uint8_t start, uint8_t end,
+                     bool byte_size, const char* mnem);
   void AddJumpConditionalShort();
 };
 
@@ -204,9 +204,10 @@ void InstructionTable::CopyTable(const ByteMnemonic bm[],
   }
 }
 
-void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
-                                     bool byte_size, const char* mnem) {
-  for (byte b = start; b <= end; b++) {
+void InstructionTable::SetTableRange(InstructionType type, uint8_t start,
+                                     uint8_t end, bool byte_size,
+                                     const char* mnem) {
+  for (uint8_t b = start; b <= end; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered
     id->mnem = mnem;
@@ -216,7 +217,7 @@ void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
 }
 
 void InstructionTable::AddJumpConditionalShort() {
-  for (byte b = 0x70; b <= 0x7F; b++) {
+  for (uint8_t b = 0x70; b <= 0x7F; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered
     id->mnem = nullptr;             // Computed depending on condition code.
@@ -311,7 +312,7 @@ class DisassemblerX64 {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(v8::base::Vector<char> buffer, byte* instruction);
+  int InstructionDecode(v8::base::Vector<char> buffer, uint8_t* instruction);
 
  private:
   enum OperandSize {
@@ -325,20 +326,20 @@ class DisassemblerX64 {
   v8::base::EmbeddedVector<char, 128> tmp_buffer_;
   unsigned int tmp_buffer_pos_;
   bool abort_on_unimplemented_;
-  // Prefixes parsed
-  byte rex_;
-  byte operand_size_;    // 0x66 or (if no group 3 prefix is present) 0x0.
-  byte group_1_prefix_;  // 0xF2, 0xF3, or (if no group 1 prefix is present) 0.
-  byte segment_prefix_;  // 0x64 or (if no group 2 prefix is present) 0.
-  byte address_size_prefix_;  // 0x67 or (if no group 4 prefix is present) 0.
-  byte vex_byte0_;            // 0xC4 or 0xC5
-  byte vex_byte1_;
-  byte vex_byte2_;  // only for 3 bytes vex prefix
+  // Prefixes parsed.
+  uint8_t rex_;
+  uint8_t operand_size_;         // 0x66 or (without group 3 prefix) 0x0.
+  uint8_t group_1_prefix_;       // 0xF2, 0xF3, or (without group 1 prefix) 0.
+  uint8_t segment_prefix_;       // 0x64 or (without group 2 prefix) 0.
+  uint8_t address_size_prefix_;  // 0x67 or (without group 4 prefix) 0.
+  uint8_t vex_byte0_;            // 0xC4 or 0xC5.
+  uint8_t vex_byte1_;
+  uint8_t vex_byte2_;  // only for 3 bytes vex prefix.
   // Byte size operand override.
   bool byte_size_operand_;
   const InstructionTable* const instruction_table_;
 
-  void setRex(byte rex) {
+  void setRex(uint8_t rex) {
     DCHECK_EQ(0x40, rex & 0xF0);
     rex_ = rex;
   }
@@ -363,37 +364,37 @@ class DisassemblerX64 {
 
   bool vex_128() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 4) == 0;
   }
 
   bool vex_256() const {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 4) != 0;
   }
 
   bool vex_none() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 0;
   }
 
   bool vex_66() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 1;
   }
 
   bool vex_f3() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 2;
   }
 
   bool vex_f2() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 3;
   }
 
@@ -414,7 +415,7 @@ class DisassemblerX64 {
 
   int vex_vreg() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return ~(checked >> 3) & 0xF;
   }
 
@@ -449,18 +450,18 @@ class DisassemblerX64 {
     }
   }
 
-  const char* NameOfAddress(byte* addr) const {
+  const char* NameOfAddress(uint8_t* addr) const {
     return converter_.NameOfAddress(addr);
   }
 
   // Disassembler helper functions.
-  void get_modrm(byte data, int* mod, int* regop, int* rm) {
+  void get_modrm(uint8_t data, int* mod, int* regop, int* rm) {
     *mod = (data >> 6) & 3;
     *regop = ((data & 0x38) >> 3) | (rex_r() ? 8 : 0);
     *rm = (data & 7) | (rex_b() ? 8 : 0);
   }
 
-  void get_sib(byte data, int* scale, int* index, int* base) {
+  void get_sib(uint8_t data, int* scale, int* index, int* base) {
     *scale = (data >> 6) & 3;
     *index = ((data >> 3) & 7) | (rex_x() ? 8 : 0);
     *base = (data & 7) | (rex_b() ? 8 : 0);
@@ -469,27 +470,27 @@ class DisassemblerX64 {
   using RegisterNameMapping = const char* (DisassemblerX64::*)(int reg) const;
 
   void TryAppendRootRelativeName(int offset);
-  int PrintRightOperandHelper(byte* modrmp, RegisterNameMapping register_name);
-  int PrintRightOperand(byte* modrmp);
-  int PrintRightByteOperand(byte* modrmp);
-  int PrintRightXMMOperand(byte* modrmp);
-  int PrintRightAVXOperand(byte* modrmp);
-  int PrintOperands(const char* mnem, OperandType op_order, byte* data);
-  int PrintImmediate(byte* data, OperandSize size);
-  int PrintImmediateOp(byte* data);
-  const char* TwoByteMnemonic(byte opcode);
-  int TwoByteOpcodeInstruction(byte* data);
-  int ThreeByteOpcodeInstruction(byte* data);
-  int F6F7Instruction(byte* data);
-  int ShiftInstruction(byte* data);
-  int JumpShort(byte* data);
-  int JumpConditional(byte* data);
-  int JumpConditionalShort(byte* data);
-  int SetCC(byte* data);
-  int FPUInstruction(byte* data);
-  int MemoryFPUInstruction(int escape_opcode, int regop, byte* modrm_start);
-  int RegisterFPUInstruction(int escape_opcode, byte modrm_byte);
-  int AVXInstruction(byte* data);
+  int PrintRightOperandHelper(uint8_t* modrmp, RegisterNameMapping);
+  int PrintRightOperand(uint8_t* modrmp);
+  int PrintRightByteOperand(uint8_t* modrmp);
+  int PrintRightXMMOperand(uint8_t* modrmp);
+  int PrintRightAVXOperand(uint8_t* modrmp);
+  int PrintOperands(const char* mnem, OperandType op_order, uint8_t* data);
+  int PrintImmediate(uint8_t* data, OperandSize size);
+  int PrintImmediateOp(uint8_t* data);
+  const char* TwoByteMnemonic(uint8_t opcode);
+  int TwoByteOpcodeInstruction(uint8_t* data);
+  int ThreeByteOpcodeInstruction(uint8_t* data);
+  int F6F7Instruction(uint8_t* data);
+  int ShiftInstruction(uint8_t* data);
+  int JumpShort(uint8_t* data);
+  int JumpConditional(uint8_t* data);
+  int JumpConditionalShort(uint8_t* data);
+  int SetCC(uint8_t* data);
+  int FPUInstruction(uint8_t* data);
+  int MemoryFPUInstruction(int escape_opcode, int regop, uint8_t* modrm_start);
+  int RegisterFPUInstruction(int escape_opcode, uint8_t modrm_byte);
+  int AVXInstruction(uint8_t* data);
   PRINTF_FORMAT(2, 3) void AppendToBuffer(const char* format, ...);
 
   void UnimplementedInstruction() {
@@ -516,7 +517,7 @@ void DisassemblerX64::TryAppendRootRelativeName(int offset) {
 }
 
 int DisassemblerX64::PrintRightOperandHelper(
-    byte* modrmp, RegisterNameMapping direct_register_name) {
+    uint8_t* modrmp, RegisterNameMapping direct_register_name) {
   int mod, regop, rm;
   get_modrm(*modrmp, &mod, &regop, &rm);
   RegisterNameMapping register_name =
@@ -528,7 +529,7 @@ int DisassemblerX64::PrintRightOperandHelper(
         return 5;
       } else if ((rm & 7) == 4) {
         // Codes for SIB byte.
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         if (index == 4 && (base & 7) == 4 && scale == 0 /*times_1*/) {
@@ -558,7 +559,7 @@ int DisassemblerX64::PrintRightOperandHelper(
     case 1:  // fall through
     case 2:
       if ((rm & 7) == 4) {
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         int disp = (mod == 2) ? Imm32(modrmp + 2) : Imm8(modrmp + 2);
@@ -592,7 +593,7 @@ int DisassemblerX64::PrintRightOperandHelper(
   UNREACHABLE();
 }
 
-int DisassemblerX64::PrintImmediate(byte* data, OperandSize size) {
+int DisassemblerX64::PrintImmediate(uint8_t* data, OperandSize size) {
   int64_t value;
   int count;
   switch (size) {
@@ -619,28 +620,28 @@ int DisassemblerX64::PrintImmediate(byte* data, OperandSize size) {
   return count;
 }
 
-int DisassemblerX64::PrintRightOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerX64::NameOfCPURegister);
 }
 
-int DisassemblerX64::PrintRightByteOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightByteOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp,
                                  &DisassemblerX64::NameOfByteCPURegister);
 }
 
-int DisassemblerX64::PrintRightXMMOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightXMMOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerX64::NameOfXMMRegister);
 }
 
-int DisassemblerX64::PrintRightAVXOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightAVXOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerX64::NameOfAVXRegister);
 }
 
 // Returns number of bytes used including the current *data.
 // Writes instruction's mnemonic, left and right operands to 'tmp_buffer_'.
 int DisassemblerX64::PrintOperands(const char* mnem, OperandType op_order,
-                                   byte* data) {
-  byte modrm = *data;
+                                   uint8_t* data) {
+  uint8_t modrm = *data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   int advance = 0;
@@ -690,10 +691,10 @@ int DisassemblerX64::PrintOperands(const char* mnem, OperandType op_order,
 
 // Returns number of bytes used by machine instruction, including *data byte.
 // Writes immediate instructions to 'tmp_buffer_'.
-int DisassemblerX64::PrintImmediateOp(byte* data) {
+int DisassemblerX64::PrintImmediateOp(uint8_t* data) {
   DCHECK(*data == 0x80 || *data == 0x81 || *data == 0x83);
   bool byte_size_immediate = *data != 0x81;
-  byte modrm = *(data + 1);
+  uint8_t modrm = *(data + 1);
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   const char* mnem = "Imm???";
@@ -736,9 +737,9 @@ int DisassemblerX64::PrintImmediateOp(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::F6F7Instruction(byte* data) {
+int DisassemblerX64::F6F7Instruction(uint8_t* data) {
   DCHECK(*data == 0xF7 || *data == 0xF6);
-  byte modrm = *(data + 1);
+  uint8_t modrm = *(data + 1);
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   if (regop != 0) {
@@ -790,8 +791,8 @@ int DisassemblerX64::F6F7Instruction(byte* data) {
   }
 }
 
-int DisassemblerX64::ShiftInstruction(byte* data) {
-  byte op = *data & (~1);
+int DisassemblerX64::ShiftInstruction(uint8_t* data) {
+  uint8_t op = *data & (~1);
   int count = 1;
   if (op != 0xD0 && op != 0xD2 && op != 0xC0) {
     UnimplementedInstruction();
@@ -799,7 +800,7 @@ int DisassemblerX64::ShiftInstruction(byte* data) {
   }
   // Print mneumonic.
   {
-    byte modrm = *(data + count);
+    uint8_t modrm = *(data + count);
     int mod, regop, rm;
     get_modrm(modrm, &mod, &regop, &rm);
     regop &= 0x7;  // The REX.R bit does not affect the operation.
@@ -851,38 +852,38 @@ int DisassemblerX64::ShiftInstruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::JumpShort(byte* data) {
+int DisassemblerX64::JumpShort(uint8_t* data) {
   DCHECK_EQ(0xEB, *data);
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   AppendToBuffer("jmp %s", NameOfAddress(dest));
   return 2;
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::JumpConditional(byte* data) {
+int DisassemblerX64::JumpConditional(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
-  byte* dest = data + Imm32(data + 2) + 6;
+  uint8_t cond = *(data + 1) & 0x0F;
+  uint8_t* dest = data + Imm32(data + 2) + 6;
   const char* mnem = conditional_code_suffix[cond];
   AppendToBuffer("j%s %s", mnem, NameOfAddress(dest));
   return 6;  // includes 0x0F
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::JumpConditionalShort(byte* data) {
-  byte cond = *data & 0x0F;
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+int DisassemblerX64::JumpConditionalShort(uint8_t* data) {
+  uint8_t cond = *data & 0x0F;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   const char* mnem = conditional_code_suffix[cond];
   AppendToBuffer("j%s %s", mnem, NameOfAddress(dest));
   return 2;
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::SetCC(byte* data) {
+int DisassemblerX64::SetCC(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
+  uint8_t cond = *(data + 1) & 0x0F;
   const char* mnem = conditional_code_suffix[cond];
   AppendToBuffer("set%s%c ", mnem, operand_size_code());
   PrintRightByteOperand(data + 2);
@@ -891,9 +892,9 @@ int DisassemblerX64::SetCC(byte* data) {
 
 const char* sf_str[4] = {"", "rl", "ra", "ll"};
 
-int DisassemblerX64::AVXInstruction(byte* data) {
-  byte opcode = *data;
-  byte* current = data + 1;
+int DisassemblerX64::AVXInstruction(uint8_t* data) {
+  uint8_t opcode = *data;
+  uint8_t* current = data + 1;
   if (vex_66() && vex_0f38()) {
     int mod, regop, rm, vvvv = vex_vreg();
     get_modrm(*current, &mod, &regop, &rm);
@@ -1574,10 +1575,10 @@ int DisassemblerX64::AVXInstruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::FPUInstruction(byte* data) {
-  byte escape_opcode = *data;
+int DisassemblerX64::FPUInstruction(uint8_t* data) {
+  uint8_t escape_opcode = *data;
   DCHECK_EQ(0xD8, escape_opcode & 0xF8);
-  byte modrm_byte = *(data + 1);
+  uint8_t modrm_byte = *(data + 1);
 
   if (modrm_byte >= 0xC0) {
     return RegisterFPUInstruction(escape_opcode, modrm_byte);
@@ -1587,7 +1588,7 @@ int DisassemblerX64::FPUInstruction(byte* data) {
 }
 
 int DisassemblerX64::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
-                                          byte* modrm_start) {
+                                          uint8_t* modrm_start) {
   const char* mnem = "?";
   int regop = (modrm_byte >> 3) & 0x7;  // reg/op field of modrm byte.
   switch (escape_opcode) {
@@ -1661,7 +1662,7 @@ int DisassemblerX64::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
 }
 
 int DisassemblerX64::RegisterFPUInstruction(int escape_opcode,
-                                            byte modrm_byte) {
+                                            uint8_t modrm_byte) {
   bool has_register = false;  // Is the FPU register encoded in modrm_byte?
   const char* mnem = "?";
 
@@ -1844,9 +1845,9 @@ int DisassemblerX64::RegisterFPUInstruction(int escape_opcode,
 
 // Handle all two-byte opcodes, which start with 0x0F.
 // These instructions may be affected by an 0x66, 0xF2, or 0xF3 prefix.
-int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
-  byte opcode = *(data + 1);
-  byte* current = data + 2;
+int DisassemblerX64::TwoByteOpcodeInstruction(uint8_t* data) {
+  uint8_t opcode = *(data + 1);
+  uint8_t* current = data + 2;
   // At return, "current" points to the start of the next instruction.
   const char* mnemonic = TwoByteMnemonic(opcode);
   // Not every instruction will use this, but it doesn't hurt to figure it out
@@ -2180,13 +2181,13 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
 // Handle all three-byte opcodes, which start with 0x0F38 or 0x0F3A.
 // These instructions may be affected by an 0x66, 0xF2, or 0xF3 prefix, but we
 // only have instructions prefixed with 0x66 for now.
-int DisassemblerX64::ThreeByteOpcodeInstruction(byte* data) {
+int DisassemblerX64::ThreeByteOpcodeInstruction(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
   // Only support 3-byte opcodes prefixed with 0x66 for now.
   DCHECK_EQ(0x66, operand_size_);
-  byte second_byte = *(data + 1);
-  byte third_byte = *(data + 2);
-  byte* current = data + 3;
+  uint8_t second_byte = *(data + 1);
+  uint8_t third_byte = *(data + 2);
+  uint8_t* current = data + 3;
   int mod, regop, rm;
   get_modrm(*current, &mod, &regop, &rm);
   if (second_byte == 0x38) {
@@ -2274,7 +2275,7 @@ int DisassemblerX64::ThreeByteOpcodeInstruction(byte* data) {
 // Mnemonics for two-byte opcode instructions starting with 0x0F.
 // The argument is the second byte of the two-byte opcode.
 // Returns nullptr if the instruction is not handled here.
-const char* DisassemblerX64::TwoByteMnemonic(byte opcode) {
+const char* DisassemblerX64::TwoByteMnemonic(uint8_t opcode) {
   if (opcode >= 0xC8 && opcode <= 0xCF) return "bswap";
   switch (opcode) {
     case 0x1F:
@@ -2335,12 +2336,12 @@ const char* DisassemblerX64::TwoByteMnemonic(byte opcode) {
 
 // Disassembles the instruction at instr, and writes it into out_buffer.
 int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
-                                       byte* instr) {
+                                       uint8_t* instr) {
   tmp_buffer_pos_ = 0;  // starting to write as position 0
-  byte* data = instr;
+  uint8_t* data = instr;
   bool processed = true;  // Will be set to false if the current instruction
                           // is not in 'instructions' table.
-  byte current;
+  uint8_t current;
 
   // Scan for prefixes.
   while (true) {
@@ -2426,18 +2427,18 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
         data++;
         break;
       case MOVE_REG_INSTR: {
-        byte* addr = nullptr;
+        uint8_t* addr = nullptr;
         switch (operand_size()) {
           case OPERAND_WORD_SIZE:
-            addr = reinterpret_cast<byte*>(Imm16(data + 1));
+            addr = reinterpret_cast<uint8_t*>(Imm16(data + 1));
             data += 3;
             break;
           case OPERAND_DOUBLEWORD_SIZE:
-            addr = reinterpret_cast<byte*>(Imm32_U(data + 1));
+            addr = reinterpret_cast<uint8_t*>(Imm32_U(data + 1));
             data += 5;
             break;
           case OPERAND_QUADWORD_SIZE:
-            addr = reinterpret_cast<byte*>(Imm64(data + 1));
+            addr = reinterpret_cast<uint8_t*>(Imm64(data + 1));
             data += 9;
             break;
           default:
@@ -2450,7 +2451,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
       }
 
       case CALL_JUMP_INSTR: {
-        byte* addr = data + Imm32(data + 1) + 5;
+        uint8_t* addr = data + Imm32(data + 1) + 5;
         AppendToBuffer("%s %s", idesc.mnem, NameOfAddress(addr));
         data += 5;
         break;
@@ -2638,7 +2639,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
       case 0xBE:
       case 0xBF: {
         // mov reg8,imm8 or mov reg32,imm32
-        byte opcode = *data;
+        uint8_t opcode = *data;
         data++;
         bool is_32bit = (opcode >= 0xB8);
         int reg = (opcode & 0x7) | (rex_b() ? 8 : 0);
@@ -2679,7 +2680,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
         switch (operand_size()) {
           case OPERAND_DOUBLEWORD_SIZE: {
             const char* memory_location =
-                NameOfAddress(reinterpret_cast<byte*>(Imm32(data + 1)));
+                NameOfAddress(reinterpret_cast<uint8_t*>(Imm32(data + 1)));
             if (*data == 0xA1) {  // Opcode 0xA1
               AppendToBuffer("movzxlq rax,(%s)", memory_location);
             } else {  // Opcode 0xA3
@@ -2691,7 +2692,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
           case OPERAND_QUADWORD_SIZE: {
             // New x64 instruction mov rax,(imm_64).
             const char* memory_location =
-                NameOfAddress(reinterpret_cast<byte*>(Imm64(data + 1)));
+                NameOfAddress(reinterpret_cast<uint8_t*>(Imm64(data + 1)));
             if (*data == 0xA1) {  // Opcode 0xA1
               AppendToBuffer("movq rax,(%s)", memory_location);
             } else {  // Opcode 0xA3
@@ -2785,7 +2786,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
 
   int outp = 0;
   // Instruction bytes.
-  for (byte* bp = instr; bp < data; bp++) {
+  for (uint8_t* bp = instr; bp < data; bp++) {
     outp += v8::base::SNPrintF(out_buffer + outp, "%02x", *bp);
   }
   // Indent instruction, leaving space for 10 bytes, i.e. 20 characters in hex.
@@ -2816,12 +2817,12 @@ static const char* const ymm_regs[16] = {
     "ymm0", "ymm1", "ymm2",  "ymm3",  "ymm4",  "ymm5",  "ymm6",  "ymm7",
     "ymm8", "ymm9", "ymm10", "ymm11", "ymm12", "ymm13", "ymm14", "ymm15"};
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -2845,7 +2846,7 @@ const char* NameOfYMMRegister(int reg) {
   return "noymmreg";
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // X64 does not embed debug strings at the moment.
   UNREACHABLE();
 }
@@ -2853,27 +2854,27 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   DisassemblerX64 d(converter_, unimplemented_opcode_action());
   return d.InstructionDecode(buffer, instruction);
 }
 
 // The X64 assembler does not use constant pools.
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     fprintf(f, "%p", static_cast<void*>(prev_pc));
     fprintf(f, "    ");
 
-    for (byte* bp = prev_pc; bp < pc; bp++) {
+    for (uint8_t* bp = prev_pc; bp < pc; bp++) {
       fprintf(f, "%02x", *bp);
     }
     for (int i = 6 - static_cast<int>(pc - prev_pc); i >= 0; i--) {
-- 
2.35.1


diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index 738337eab7b..8837aea3ce8 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -384,7 +384,7 @@ void MacroAssembler::DecompressTagged(Register destination,
 void MacroAssembler::RecordWriteField(Register object, int offset,
                                       Register value, Register slot_address,
                                       SaveFPRegsMode save_fp,
-                                      SmiCheck smi_check, PointerType type) {
+                                      SmiCheck smi_check, SlotDescriptor slot) {
   ASM_CODE_COMMENT(this);
   DCHECK(!AreAliased(object, value, slot_address));
   // First, check if a write barrier is even needed. The tests below
@@ -410,7 +410,7 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
     bind(&ok);
   }
 
-  RecordWrite(object, slot_address, value, save_fp, SmiCheck::kOmit, type);
+  RecordWrite(object, slot_address, value, save_fp, SmiCheck::kOmit, slot);
 
   bind(&done);
 
@@ -470,6 +470,7 @@ void MacroAssembler::LoadExternalPointerField(
   DCHECK(!field_operand.AddressUsesRegister(scratch));
   if (isolateRootLocation == IsolateRootLocation::kInRootRegister) {
     DCHECK(root_array_available_);
+    // TODO(saelo): consider using an ExternalReference here.
     movq(scratch,
          Operand(kRootRegister,
                  IsolateData::external_pointer_table_offset() +
@@ -494,17 +495,32 @@ void MacroAssembler::LoadExternalPointerField(
 
 void MacroAssembler::LoadIndirectPointerField(Register destination,
                                               Operand field_operand,
+                                              IndirectPointerTag tag,
                                               Register scratch) {
-  DCHECK(!AreAliased(destination, scratch));
 #ifdef V8_CODE_POINTER_SANDBOXING
+  DCHECK(!AreAliased(destination, scratch));
   DCHECK(!field_operand.AddressUsesRegister(scratch));
-  static_assert(kAllIndirectPointerObjectsAreCode);
-  LoadAddress(scratch, ExternalReference::code_pointer_table_address());
+
+  // Move the IndirectPointerHandle into destination
   movl(destination, field_operand);
-  shrl(destination, Immediate(kCodePointerHandleShift));
-  shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
-  movq(destination, Operand(scratch, destination, times_1,
-                            kCodePointerTableEntryCodeObjectOffset));
+
+  if (tag == kCodeIndirectPointerTag) {
+    LoadAddress(scratch, ExternalReference::code_pointer_table_address());
+    shrl(destination, Immediate(kCodePointerHandleShift));
+    // The code pointer table entry size is 16 bytes, so we have to do an
+    // explicit shift first (times_16 doesn't exist).
+    shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
+    movq(destination, Operand(scratch, destination, times_1,
+                              kCodePointerTableEntryCodeObjectOffset));
+  } else {
+    CHECK(root_array_available_);
+    LoadAddress(scratch, ExternalReference::indirect_pointer_table_base_address(
+                             isolate()));
+    shrl(destination, Immediate(kIndirectPointerHandleShift));
+    static_assert(kIndirectPointerTableEntrySize == 8);
+    movq(destination, Operand(scratch, destination, times_8, 0));
+  }
+
   // The LSB is used as marking bit by the code pointer table, so here we have
   // to set it using a bitwise OR as it may or may not be set.
   orq(destination, Immediate(kHeapObjectTag));
@@ -569,11 +585,39 @@ void MacroAssembler::CallEphemeronKeyBarrier(Register object,
   PopAll(registers);
 }
 
+void MacroAssembler::CallIndirectPointerBarrier(Register object,
+                                                Register slot_address,
+                                                SaveFPRegsMode fp_mode,
+                                                IndirectPointerTag tag) {
+  ASM_CODE_COMMENT(this);
+  DCHECK(!AreAliased(object, slot_address));
+  // TODO(saelo) if necessary, we could introduce a "SaveRegisters version of
+  // this function and make this code not save clobbered registers. It's
+  // probably not currently worth the effort though since stores to indirect
+  // pointer fields are fairly rare.
+  RegList registers =
+      IndirectPointerWriteBarrierDescriptor::ComputeSavedRegisters(
+          object, slot_address);
+  PushAll(registers);
+
+  Register object_parameter =
+      IndirectPointerWriteBarrierDescriptor::ObjectRegister();
+  Register slot_address_parameter =
+      IndirectPointerWriteBarrierDescriptor::SlotAddressRegister();
+  MovePair(slot_address_parameter, slot_address, object_parameter, object);
+
+  Register tag_parameter =
+      IndirectPointerWriteBarrierDescriptor::IndirectPointerTagRegister();
+  Move(tag_parameter, tag);
+
+  CallBuiltin(Builtins::GetIndirectPointerBarrierStub(fp_mode));
+  PopAll(registers);
+}
+
 void MacroAssembler::CallRecordWriteStubSaveRegisters(Register object,
                                                       Register slot_address,
                                                       SaveFPRegsMode fp_mode,
-                                                      StubCallMode mode,
-                                                      PointerType type) {
+                                                      StubCallMode mode) {
   ASM_CODE_COMMENT(this);
   DCHECK(!AreAliased(object, slot_address));
   RegList registers =
@@ -584,14 +628,13 @@ void MacroAssembler::CallRecordWriteStubSaveRegisters(Register object,
       WriteBarrierDescriptor::SlotAddressRegister();
   MovePair(object_parameter, object, slot_address_parameter, slot_address);
 
-  CallRecordWriteStub(object_parameter, slot_address_parameter, fp_mode, mode,
-                      type);
+  CallRecordWriteStub(object_parameter, slot_address_parameter, fp_mode, mode);
   PopAll(registers);
 }
 
 void MacroAssembler::CallRecordWriteStub(Register object, Register slot_address,
                                          SaveFPRegsMode fp_mode,
-                                         StubCallMode mode, PointerType type) {
+                                         StubCallMode mode) {
   ASM_CODE_COMMENT(this);
   // Use CallRecordWriteStubSaveRegisters if the object and slot registers
   // need to be caller saved.
@@ -599,7 +642,6 @@ void MacroAssembler::CallRecordWriteStub(Register object, Register slot_address,
   DCHECK_EQ(WriteBarrierDescriptor::SlotAddressRegister(), slot_address);
 #if V8_ENABLE_WEBASSEMBLY
   if (mode == StubCallMode::kCallWasmRuntimeStub) {
-    DCHECK_EQ(type, PointerType::kDirect);
     // Use {near_call} for direct Wasm call within a module.
     intptr_t wasm_target =
         static_cast<intptr_t>(wasm::WasmCode::GetRecordWriteBuiltin(fp_mode));
@@ -608,7 +650,7 @@ void MacroAssembler::CallRecordWriteStub(Register object, Register slot_address,
   if (false) {
 #endif
   } else {
-    Builtin builtin = Builtins::GetRecordWriteStub(fp_mode, type);
+    Builtin builtin = Builtins::GetRecordWriteStub(fp_mode);
     CallBuiltin(builtin);
   }
 }
@@ -706,7 +748,7 @@ void MacroAssembler::CallTSANRelaxedLoadStub(Register address,
 
 void MacroAssembler::RecordWrite(Register object, Register slot_address,
                                  Register value, SaveFPRegsMode fp_mode,
-                                 SmiCheck smi_check, PointerType type) {
+                                 SmiCheck smi_check, SlotDescriptor slot) {
   ASM_CODE_COMMENT(this);
   DCHECK(!AreAliased(object, slot_address, value));
   AssertNotSmi(object);
@@ -718,13 +760,13 @@ void MacroAssembler::RecordWrite(Register object, Register slot_address,
   if (v8_flags.debug_code) {
     ASM_CODE_COMMENT_STRING(this, "Debug check slot_address");
     Label ok;
-    if (type == PointerType::kIndirect) {
+    if (slot.contains_indirect_pointer()) {
       Push(object);  // Use object register as scratch
       Register scratch = object;
       Push(slot_address);  // Use slot address register to load the value into
       Register value_in_slot = slot_address;
       LoadIndirectPointerField(value_in_slot, Operand(slot_address, 0),
-                               scratch);
+                               slot.indirect_pointer_tag(), scratch);
       cmp_tagged(value, value_in_slot);
       // These pops don't affect the flag registers, so we can do them before
       // the conditional jump below.
@@ -757,8 +799,14 @@ void MacroAssembler::RecordWrite(Register object, Register slot_address,
                 MemoryChunk::kPointersFromHereAreInterestingMask, zero, &done,
                 Label::kNear);
 
-  CallRecordWriteStub(object, slot_address, fp_mode,
-                      StubCallMode::kCallBuiltinPointer, type);
+  if (slot.contains_direct_pointer()) {
+    CallRecordWriteStub(object, slot_address, fp_mode,
+                        StubCallMode::kCallBuiltinPointer);
+  } else {
+    DCHECK(slot.contains_indirect_pointer());
+    CallIndirectPointerBarrier(object, slot_address, fp_mode,
+                               slot.indirect_pointer_tag());
+  }
 
   bind(&done);
 
@@ -1000,8 +1048,10 @@ void MacroAssembler::ReplaceClosureCodeWithOptimizedCode(
   Register value = scratch1;
   movq(value, optimized_code);
 
-  RecordWriteField(closure, JSFunction::kCodeOffset, value, slot_address,
-                   SaveFPRegsMode::kIgnore, SmiCheck::kOmit, kCodePointerType);
+  RecordWriteField(
+      closure, JSFunction::kCodeOffset, value, slot_address,
+      SaveFPRegsMode::kIgnore, SmiCheck::kOmit,
+      SlotDescriptor::ForMaybeIndirectPointerSlot(kCodeIndirectPointerTag));
 }
 
 // Read off the flags in the feedback vector and check if there

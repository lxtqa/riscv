diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h
index a9067a2ba80..b032af5c76b 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h
@@ -1631,64 +1631,62 @@ void LiftoffAssembler::emit_i16x8_extadd_pairwise_i8x16_u(LiftoffRegister dst,
   vwaddu_vv(dst.fp().toV(), kSimd128ScratchReg, kSimd128ScratchReg2);
 }
 
-void LiftoffAssembler::CallC(const ValueKindSig* sig, const VarState* args,
-                             const LiftoffRegister* rets,
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
                              ValueKind out_argument_kind, int stack_bytes,
                              ExternalReference ext_ref) {
   AddWord(sp, sp, Operand(-stack_bytes));
 
   int arg_offset = 0;
-  const VarState* current_arg = args;
-  for (ValueKind param_kind : sig->parameters()) {
+  for (const VarState& arg : args) {
     UseScratchRegisterScope temps(this);
     Register src = no_reg;
     MemOperand dst{sp, arg_offset};
-    if (current_arg->is_reg()) {
-      switch (param_kind) {
+    if (arg.is_reg()) {
+      switch (arg.kind()) {
         case kI32:
-          Sw(current_arg->reg().gp(), dst);
+          Sw(arg.reg().gp(), dst);
           break;
         case kI64:
-          StoreWord(current_arg->reg().gp(), dst);
+          StoreWord(arg.reg().gp(), dst);
           break;
         case kF32:
-          StoreFloat(current_arg->reg().fp(), dst);
+          StoreFloat(arg.reg().fp(), dst);
           break;
         case kF64:
-          StoreDouble(current_arg->reg().fp(), dst);
+          StoreDouble(arg.reg().fp(), dst);
           break;
         case kS128: {
           auto scratch = temps.Acquire();
           AddWord(scratch, sp, Operand(arg_offset));
-          vs(current_arg->reg().fp().toV(), scratch, 0, VSew::E8);
+          vs(arg.reg().fp().toV(), scratch, 0, VSew::E8);
           break;
         }
         default:
           UNREACHABLE();
       }
-    } else if (current_arg->is_const()) {
-      DCHECK_EQ(kI32, param_kind);
-      if (current_arg->i32_const() == 0) {
+    } else if (arg.is_const()) {
+      DCHECK_EQ(kI32, arg.kind());
+      if (arg.i32_const() == 0) {
         src = zero_reg;
       } else {
         src = temps.Acquire();
-        li(src, current_arg->i32_const());
+        li(src, arg.i32_const());
       }
       StoreWord(src, dst);
-    } else if (value_kind_size(current_arg->kind()) == 4) {
-      MemOperand src = liftoff::GetStackSlot(current_arg->offset());
+    } else if (value_kind_size(arg.kind()) == 4) {
+      MemOperand src = liftoff::GetStackSlot(arg.offset());
       auto scratch = temps.Acquire();
       Lw(scratch, src);
       Sw(scratch, dst);
     } else {
-      DCHECK_EQ(8, value_kind_size(current_arg->kind()));
-      MemOperand src = liftoff::GetStackSlot(current_arg->offset());
+      DCHECK_EQ(8, value_kind_size(arg.kind()));
+      MemOperand src = liftoff::GetStackSlot(arg.offset());
       auto scratch = temps.Acquire();
       Ld(scratch, src);
       Sd(scratch, dst);
     }
-    ++current_arg;
-    arg_offset += value_kind_size(param_kind);
+    arg_offset += value_kind_size(arg.kind());
   }
   DCHECK_LE(arg_offset, stack_bytes);
 
@@ -1704,11 +1702,10 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig, const VarState* args,
 
   // Move return value to the right register.
   const LiftoffRegister* next_result_reg = rets;
-  if (sig->return_count() > 0) {
-    DCHECK_EQ(1, sig->return_count());
+  if (return_kind != kVoid) {
     constexpr Register kReturnReg = a0;
     if (kReturnReg != next_result_reg->gp()) {
-      Move(*next_result_reg, LiftoffRegister(kReturnReg), sig->GetReturn(0));
+      Move(*next_result_reg, LiftoffRegister(kReturnReg), return_kind);
     }
     ++next_result_reg;
   }
-- 
2.35.1


diff --git a/src/codegen/ia32/assembler-ia32.h b/src/codegen/ia32/assembler-ia32.h
index 1c1cf86393..8251a5d587 100644
--- a/src/codegen/ia32/assembler-ia32.h
+++ b/src/codegen/ia32/assembler-ia32.h
@@ -281,7 +281,7 @@ class V8_EXPORT_PRIVATE Operand {
   // register.
   Register reg() const;
 
-  base::Vector<const byte> encoded_bytes() const { return {buf_, len_}; }
+  base::Vector<const uint8_t> encoded_bytes() const { return {buf_, len_}; }
   RelocInfo::Mode rmode() { return rmode_; }
 
  private:
@@ -308,7 +308,7 @@ class V8_EXPORT_PRIVATE Operand {
            && ((buf_[0] & 0x07) == reg_code);  // register codes match.
   }
 
-  byte buf_[6];
+  uint8_t buf_[6];
   // The number of bytes in buf_.
   uint8_t len_ = 0;
   // Only valid if len_ > 4.
@@ -435,18 +435,18 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   static constexpr int kSpecialTargetSize = kSystemPointerSize;
 
   // One byte opcode for test al, 0xXX.
-  static constexpr byte kTestAlByte = 0xA8;
+  static constexpr uint8_t kTestAlByte = 0xA8;
   // One byte opcode for nop.
-  static constexpr byte kNopByte = 0x90;
+  static constexpr uint8_t kNopByte = 0x90;
 
   // One byte opcode for a short unconditional jump.
-  static constexpr byte kJmpShortOpcode = 0xEB;
+  static constexpr uint8_t kJmpShortOpcode = 0xEB;
   // One byte prefix for a short conditional jump.
-  static constexpr byte kJccShortPrefix = 0x70;
-  static constexpr byte kJncShortOpcode = kJccShortPrefix | not_carry;
-  static constexpr byte kJcShortOpcode = kJccShortPrefix | carry;
-  static constexpr byte kJnzShortOpcode = kJccShortPrefix | not_zero;
-  static constexpr byte kJzShortOpcode = kJccShortPrefix | zero;
+  static constexpr uint8_t kJccShortPrefix = 0x70;
+  static constexpr uint8_t kJncShortOpcode = kJccShortPrefix | not_carry;
+  static constexpr uint8_t kJcShortOpcode = kJccShortPrefix | carry;
+  static constexpr uint8_t kJnzShortOpcode = kJccShortPrefix | not_zero;
+  static constexpr uint8_t kJzShortOpcode = kJccShortPrefix | zero;
 
   // ---------------------------------------------------------------------------
   // InstructionStream generation
@@ -778,7 +778,7 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
 
   // Conditional jumps
   void j(Condition cc, Label* L, Label::Distance distance = Label::kFar);
-  void j(Condition cc, byte* entry, RelocInfo::Mode rmode);
+  void j(Condition cc, uint8_t* entry, RelocInfo::Mode rmode);
   void j(Condition cc, Handle<Code> code,
          RelocInfo::Mode rmode = RelocInfo::CODE_TARGET);
 
@@ -880,8 +880,8 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   void movups(XMMRegister dst, XMMRegister src) { movups(dst, Operand(src)); }
   void movups(XMMRegister dst, Operand src);
   void movups(Operand dst, XMMRegister src);
-  void shufps(XMMRegister dst, XMMRegister src, byte imm8);
-  void shufpd(XMMRegister dst, XMMRegister src, byte imm8);
+  void shufps(XMMRegister dst, XMMRegister src, uint8_t imm8);
+  void shufpd(XMMRegister dst, XMMRegister src, uint8_t imm8);
 
   void movhlps(XMMRegister dst, XMMRegister src);
   void movlhps(XMMRegister dst, XMMRegister src);
@@ -1006,8 +1006,8 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   void movss(Operand dst, XMMRegister src);
   void movss(XMMRegister dst, XMMRegister src) { movss(dst, Operand(src)); }
 
-  void extractps(Operand dst, XMMRegister src, byte imm8);
-  void extractps(Register dst, XMMRegister src, byte imm8);
+  void extractps(Operand dst, XMMRegister src, uint8_t imm8);
+  void extractps(Register dst, XMMRegister src, uint8_t imm8);
 
   void pcmpgtq(XMMRegister dst, XMMRegister src);
 
@@ -1125,7 +1125,7 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   void vsqrtss(XMMRegister dst, XMMRegister src1, Operand src2) {
     vss(0x51, dst, src1, src2);
   }
-  void vss(byte op, XMMRegister dst, XMMRegister src1, Operand src2);
+  void vss(uint8_t op, XMMRegister dst, XMMRegister src1, Operand src2);
 
   void vhaddps(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
     vhaddps(dst, src1, Operand(src2));
@@ -1156,7 +1156,7 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
     vinstr(0x10, dst, xmm0, src, kF2, k0F, kWIG);
   }
 
-  void vextractps(Operand dst, XMMRegister src, byte imm8);
+  void vextractps(Operand dst, XMMRegister src, uint8_t imm8);
 
   void vpcmpgtq(XMMRegister dst, XMMRegister src1, XMMRegister src2);
 
@@ -1168,14 +1168,16 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   void vmovups(XMMRegister dst, XMMRegister src) { vmovups(dst, Operand(src)); }
   void vmovups(XMMRegister dst, Operand src) { vps(0x10, dst, xmm0, src); }
   void vmovupd(XMMRegister dst, Operand src) { vpd(0x10, dst, xmm0, src); }
-  void vshufps(XMMRegister dst, XMMRegister src1, XMMRegister src2, byte imm8) {
+  void vshufps(XMMRegister dst, XMMRegister src1, XMMRegister src2,
+               uint8_t imm8) {
     vshufps(dst, src1, Operand(src2), imm8);
   }
-  void vshufps(XMMRegister dst, XMMRegister src1, Operand src2, byte imm8);
-  void vshufpd(XMMRegister dst, XMMRegister src1, XMMRegister src2, byte imm8) {
+  void vshufps(XMMRegister dst, XMMRegister src1, Operand src2, uint8_t imm8);
+  void vshufpd(XMMRegister dst, XMMRegister src1, XMMRegister src2,
+               uint8_t imm8) {
     vshufpd(dst, src1, Operand(src2), imm8);
   }
-  void vshufpd(XMMRegister dst, XMMRegister src1, Operand src2, byte imm8);
+  void vshufpd(XMMRegister dst, XMMRegister src1, Operand src2, uint8_t imm8);
 
   void vmovhlps(XMMRegister dst, XMMRegister src1, XMMRegister src2);
   void vmovlhps(XMMRegister dst, XMMRegister src1, XMMRegister src2);
@@ -1429,15 +1431,15 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   void shrx(Register dst, Operand src1, Register src2) {
     bmi2(kF2, 0xf7, dst, src2, src1);
   }
-  void rorx(Register dst, Register src, byte imm8) {
+  void rorx(Register dst, Register src, uint8_t imm8) {
     rorx(dst, Operand(src), imm8);
   }
-  void rorx(Register dst, Operand src, byte imm8);
+  void rorx(Register dst, Operand src, uint8_t imm8);
 
   // Implementation of packed single-precision floating-point SSE instructions.
-  void ps(byte op, XMMRegister dst, Operand src);
+  void ps(uint8_t op, XMMRegister dst, Operand src);
   // Implementation of packed double-precision floating-point SSE instructions.
-  void pd(byte op, XMMRegister dst, Operand src);
+  void pd(uint8_t op, XMMRegister dst, Operand src);
 
 #define PACKED_OP_LIST(V) \
   V(unpckl, 0x14)         \
@@ -1483,8 +1485,8 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
 #undef AVX_PACKED_OP_DECLARE
 #undef PACKED_OP_LIST
 
-  void vps(byte op, XMMRegister dst, XMMRegister src1, Operand src2);
-  void vpd(byte op, XMMRegister dst, XMMRegister src1, Operand src2);
+  void vps(uint8_t op, XMMRegister dst, XMMRegister src1, Operand src2);
+  void vpd(uint8_t op, XMMRegister dst, XMMRegister src1, Operand src2);
 
   void vcmpps(XMMRegister dst, XMMRegister src1, Operand src2, uint8_t cmp);
   void vcmppd(XMMRegister dst, XMMRegister src1, Operand src2, uint8_t cmp);
@@ -1674,8 +1676,8 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   // Avoid overflows for displacements etc.
   static constexpr int kMaximalBufferSize = 512 * MB;
 
-  byte byte_at(int pos) { return buffer_start_[pos]; }
-  void set_byte_at(int pos, byte value) { buffer_start_[pos] = value; }
+  uint8_t byte_at(int pos) { return buffer_start_[pos]; }
+  void set_byte_at(int pos, uint8_t value) { buffer_start_[pos] = value; }
 
  protected:
   void emit_sse_operand(XMMRegister reg, Operand adr);
@@ -1748,29 +1750,30 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
   inline void emit_disp(Label* L, Displacement::Type type);
   inline void emit_near_disp(Label* L);
 
-  void sse_instr(XMMRegister dst, Operand src, byte prefix, byte opcode);
-  void sse2_instr(XMMRegister dst, Operand src, byte prefix, byte escape,
-                  byte opcode);
-  void ssse3_instr(XMMRegister dst, Operand src, byte prefix, byte escape1,
-                   byte escape2, byte opcode);
-  void sse4_instr(XMMRegister dst, Operand src, byte prefix, byte escape1,
-                  byte escape2, byte opcode);
-  void vinstr(byte op, XMMRegister dst, XMMRegister src1, XMMRegister src2,
+  void sse_instr(XMMRegister dst, Operand src, uint8_t prefix, uint8_t opcode);
+  void sse2_instr(XMMRegister dst, Operand src, uint8_t prefix, uint8_t escape,
+                  uint8_t opcode);
+  void ssse3_instr(XMMRegister dst, Operand src, uint8_t prefix,
+                   uint8_t escape1, uint8_t escape2, uint8_t opcode);
+  void sse4_instr(XMMRegister dst, Operand src, uint8_t prefix, uint8_t escape1,
+                  uint8_t escape2, uint8_t opcode);
+  void vinstr(uint8_t op, XMMRegister dst, XMMRegister src1, XMMRegister src2,
               SIMDPrefix pp, LeadingOpcode m, VexW w, CpuFeature = AVX);
-  void vinstr(byte op, XMMRegister dst, XMMRegister src1, Operand src2,
+  void vinstr(uint8_t op, XMMRegister dst, XMMRegister src1, Operand src2,
               SIMDPrefix pp, LeadingOpcode m, VexW w, CpuFeature = AVX);
-  void vinstr(byte op, XMMRegister dst, XMMRegister src1, XMMRegister src2,
+  void vinstr(uint8_t op, XMMRegister dst, XMMRegister src1, XMMRegister src2,
               VectorLength l, SIMDPrefix pp, LeadingOpcode m, VexW w,
               CpuFeature = AVX);
-  void vinstr(byte op, XMMRegister dst, XMMRegister src1, Operand src2,
+  void vinstr(uint8_t op, XMMRegister dst, XMMRegister src1, Operand src2,
               VectorLength l, SIMDPrefix pp, LeadingOpcode m, VexW w,
               CpuFeature = AVX);
   // Most BMI instructions are similar.
-  void bmi1(byte op, Register reg, Register vreg, Operand rm);
-  void bmi2(SIMDPrefix pp, byte op, Register reg, Register vreg, Operand rm);
-  void fma_instr(byte op, XMMRegister dst, XMMRegister src1, XMMRegister src2,
-                 VectorLength l, SIMDPrefix pp, LeadingOpcode m, VexW w);
-  void fma_instr(byte op, XMMRegister dst, XMMRegister src1, Operand src2,
+  void bmi1(uint8_t op, Register reg, Register vreg, Operand rm);
+  void bmi2(SIMDPrefix pp, uint8_t op, Register reg, Register vreg, Operand rm);
+  void fma_instr(uint8_t op, XMMRegister dst, XMMRegister src1,
+                 XMMRegister src2, VectorLength l, SIMDPrefix pp,
+                 LeadingOpcode m, VexW w);
+  void fma_instr(uint8_t op, XMMRegister dst, XMMRegister src1, Operand src2,
                  VectorLength l, SIMDPrefix pp, LeadingOpcode m, VexW w);
 
   // record reloc info for current pc_

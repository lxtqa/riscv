diff --git a/src/codegen/s390/assembler-s390-inl.h b/src/codegen/s390/assembler-s390-inl.h
index 6b48c28394..585b59739d 100644
--- a/src/codegen/s390/assembler-s390-inl.h
+++ b/src/codegen/s390/assembler-s390-inl.h
@@ -56,14 +56,14 @@ void RelocInfo::apply(intptr_t delta) {
     Memory<Address>(pc_) = target + delta;
   } else if (IsCodeTarget(rmode_)) {
     SixByteInstr instr =
-        Instruction::InstructionBits(reinterpret_cast<const byte*>(pc_));
+        Instruction::InstructionBits(reinterpret_cast<const uint8_t*>(pc_));
     int32_t dis = static_cast<int32_t>(instr & 0xFFFFFFFF) * 2  // halfwords
                   - static_cast<int32_t>(delta);
     instr >>= 32;  // Clear the 4-byte displacement field.
     instr <<= 32;
     instr |= static_cast<uint32_t>(dis / 2);
-    Instruction::SetInstructionBits<SixByteInstr>(reinterpret_cast<byte*>(pc_),
-                                                  instr);
+    Instruction::SetInstructionBits<SixByteInstr>(
+        reinterpret_cast<uint8_t*>(pc_), instr);
   } else {
     // mov sequence
     DCHECK(IsInternalReferenceEncoded(rmode_));
@@ -134,7 +134,7 @@ Tagged_t Assembler::target_compressed_address_at(Address pc,
 
 Handle<Object> Assembler::code_target_object_handle_at(Address pc) {
   SixByteInstr instr =
-      Instruction::InstructionBits(reinterpret_cast<const byte*>(pc));
+      Instruction::InstructionBits(reinterpret_cast<const uint8_t*>(pc));
   int index = instr & 0xFFFFFFFF;
   return GetCodeTarget(index);
 }
@@ -231,9 +231,10 @@ Operand::Operand(Register rm) : rm_(rm), rmode_(RelocInfo::NO_INFO) {}
 Address Assembler::target_address_at(Address pc, Address constant_pool) {
   // S390 Instruction!
   // We want to check for instructions generated by Asm::mov()
-  Opcode op1 = Instruction::S390OpcodeValue(reinterpret_cast<const byte*>(pc));
+  Opcode op1 =
+      Instruction::S390OpcodeValue(reinterpret_cast<const uint8_t*>(pc));
   SixByteInstr instr_1 =
-      Instruction::InstructionBits(reinterpret_cast<const byte*>(pc));
+      Instruction::InstructionBits(reinterpret_cast<const uint8_t*>(pc));
 
   if (BRASL == op1 || BRCL == op1) {
     int32_t dis = static_cast<int32_t>(instr_1 & 0xFFFFFFFF) * 2;
@@ -242,11 +243,11 @@ Address Assembler::target_address_at(Address pc, Address constant_pool) {
 
 #if V8_TARGET_ARCH_S390X
   int instr1_length =
-      Instruction::InstructionLength(reinterpret_cast<const byte*>(pc));
+      Instruction::InstructionLength(reinterpret_cast<const uint8_t*>(pc));
   Opcode op2 = Instruction::S390OpcodeValue(
-      reinterpret_cast<const byte*>(pc + instr1_length));
+      reinterpret_cast<const uint8_t*>(pc + instr1_length));
   SixByteInstr instr_2 = Instruction::InstructionBits(
-      reinterpret_cast<const byte*>(pc + instr1_length));
+      reinterpret_cast<const uint8_t*>(pc + instr1_length));
   // IIHF for hi_32, IILF for lo_32
   if (IIHF == op1 && IILF == op2) {
     return static_cast<Address>(((instr_1 & 0xFFFFFFFF) << 32) |
@@ -293,9 +294,10 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,
                                       Address target,
                                       ICacheFlushMode icache_flush_mode) {
   // Check for instructions generated by Asm::mov()
-  Opcode op1 = Instruction::S390OpcodeValue(reinterpret_cast<const byte*>(pc));
+  Opcode op1 =
+      Instruction::S390OpcodeValue(reinterpret_cast<const uint8_t*>(pc));
   SixByteInstr instr_1 =
-      Instruction::InstructionBits(reinterpret_cast<const byte*>(pc));
+      Instruction::InstructionBits(reinterpret_cast<const uint8_t*>(pc));
   bool patched = false;
 
   if (BRASL == op1 || BRCL == op1) {
@@ -303,8 +305,8 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,
     instr_1 <<= 32;
     int32_t halfwords = (target - pc) / 2;  // number of halfwords
     instr_1 |= static_cast<uint32_t>(halfwords);
-    Instruction::SetInstructionBits<SixByteInstr>(reinterpret_cast<byte*>(pc),
-                                                  instr_1);
+    Instruction::SetInstructionBits<SixByteInstr>(
+        reinterpret_cast<uint8_t*>(pc), instr_1);
     if (icache_flush_mode != SKIP_ICACHE_FLUSH) {
       FlushInstructionCache(pc, 6);
     }
@@ -312,11 +314,11 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,
   } else {
 #if V8_TARGET_ARCH_S390X
     int instr1_length =
-        Instruction::InstructionLength(reinterpret_cast<const byte*>(pc));
+        Instruction::InstructionLength(reinterpret_cast<const uint8_t*>(pc));
     Opcode op2 = Instruction::S390OpcodeValue(
-        reinterpret_cast<const byte*>(pc + instr1_length));
+        reinterpret_cast<const uint8_t*>(pc + instr1_length));
     SixByteInstr instr_2 = Instruction::InstructionBits(
-        reinterpret_cast<const byte*>(pc + instr1_length));
+        reinterpret_cast<const uint8_t*>(pc + instr1_length));
     // IIHF for hi_32, IILF for lo_32
     if (IIHF == op1 && IILF == op2) {
       // IIHF
@@ -324,8 +326,8 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,
       instr_1 <<= 32;
       instr_1 |= reinterpret_cast<uint64_t>(target) >> 32;
 
-      Instruction::SetInstructionBits<SixByteInstr>(reinterpret_cast<byte*>(pc),
-                                                    instr_1);
+      Instruction::SetInstructionBits<SixByteInstr>(
+          reinterpret_cast<uint8_t*>(pc), instr_1);
 
       // IILF
       instr_2 >>= 32;
@@ -333,7 +335,7 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,
       instr_2 |= reinterpret_cast<uint64_t>(target) & 0xFFFFFFFF;
 
       Instruction::SetInstructionBits<SixByteInstr>(
-          reinterpret_cast<byte*>(pc + instr1_length), instr_2);
+          reinterpret_cast<uint8_t*>(pc + instr1_length), instr_2);
       if (icache_flush_mode != SKIP_ICACHE_FLUSH) {
         FlushInstructionCache(pc, 12);
       }
@@ -346,8 +348,8 @@ void Assembler::set_target_address_at(Address pc, Address constant_pool,
       instr_1 <<= 32;
       instr_1 |= reinterpret_cast<uint32_t>(target);
 
-      Instruction::SetInstructionBits<SixByteInstr>(reinterpret_cast<byte*>(pc),
-                                                    instr_1);
+      Instruction::SetInstructionBits<SixByteInstr>(
+          reinterpret_cast<uint8_t*>(pc), instr_1);
       if (icache_flush_mode != SKIP_ICACHE_FLUSH) {
         FlushInstructionCache(pc, 6);
       }

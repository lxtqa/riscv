diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index d49002954c2..2ea1ab2520a 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -493,35 +493,37 @@ void MacroAssembler::LoadExternalPointerField(
 #endif  // V8_ENABLE_SANDBOX
 }
 
-void MacroAssembler::StoreTrustedPointerField(Operand dst_field_operand,
-                                              Register value) {
-#ifdef V8_ENABLE_SANDBOX
-  StoreIndirectPointerField(dst_field_operand, value);
-#else
-  StoreTaggedField(dst_field_operand, value);
-#endif  // V8_ENABLE_SANDBOX
-}
-
 void MacroAssembler::LoadIndirectPointerField(Register destination,
                                               Operand field_operand,
                                               IndirectPointerTag tag,
                                               Register scratch) {
 #ifdef V8_ENABLE_SANDBOX
   DCHECK(!AreAliased(destination, scratch));
+  DCHECK(!field_operand.AddressUsesRegister(scratch));
 
-  // Move the IndirectPointerHandle into the scratch register.
-  Register handle = scratch;
-  movl(handle, field_operand);
+  // Move the IndirectPointerHandle into destination
+  movl(destination, field_operand);
 
-  // Resolve the handle. The tag implies the pointer table to use.
-  if (tag == kUnknownIndirectPointerTag) {
-    // TODO(saelo): implement once needed.
-    UNIMPLEMENTED();
-  } else if (tag == kCodeIndirectPointerTag) {
-    ResolveCodePointerHandle(destination, handle);
+  if (tag == kCodeIndirectPointerTag) {
+    LoadAddress(scratch, ExternalReference::code_pointer_table_address());
+    shrl(destination, Immediate(kCodePointerHandleShift));
+    // The code pointer table entry size is 16 bytes, so we have to do an
+    // explicit shift first (times_16 doesn't exist).
+    shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
+    movq(destination, Operand(scratch, destination, times_1,
+                              kCodePointerTableEntryCodeObjectOffset));
   } else {
-    ResolveTrustedPointerHandle(destination, handle, tag);
+    CHECK(root_array_available_);
+    LoadAddress(scratch, ExternalReference::trusted_pointer_table_base_address(
+                             isolate()));
+    shrl(destination, Immediate(kTrustedPointerHandleShift));
+    static_assert(kTrustedPointerTableEntrySize == 8);
+    movq(destination, Operand(scratch, destination, times_8, 0));
   }
+
+  // The LSB is used as marking bit by the code pointer table, so here we have
+  // to set it using a bitwise OR as it may or may not be set.
+  orq(destination, Immediate(kHeapObjectTag));
 #else
   UNREACHABLE();
 #endif  // V8_ENABLE_SANDBOX
@@ -535,47 +537,22 @@ void MacroAssembler::StoreIndirectPointerField(Operand dst_field_operand,
   movl(dst_field_operand, kScratchRegister);
 #else
   UNREACHABLE();
-#endif  // V8_ENABLE_SANDBOX
+#endif
 }
 
+void MacroAssembler::StoreTrustedPointerField(Operand dst_field_operand,
+                                              Register value) {
 #ifdef V8_ENABLE_SANDBOX
-void MacroAssembler::ResolveTrustedPointerHandle(Register destination,
-                                                 Register handle,
-                                                 IndirectPointerTag tag) {
-  DCHECK_NE(tag, kCodeIndirectPointerTag);
-  DCHECK_NE(tag, kUnknownIndirectPointerTag);
-  DCHECK(!AreAliased(handle, destination));
-  CHECK(root_array_available_);
-  Register table = destination;
-  LoadAddress(table,
-              ExternalReference::trusted_pointer_table_base_address(isolate()));
-  shrl(handle, Immediate(kTrustedPointerHandleShift));
-  static_assert(kTrustedPointerTableEntrySize == 8);
-  movq(destination, Operand(table, handle, times_8, 0));
-  // The LSB is used as marking bit by the trusted pointer table, so here we
-  // have to set it using a bitwise OR as it may or may not be set.
-  orq(destination, Immediate(kHeapObjectTag));
-}
-
-void MacroAssembler::ResolveCodePointerHandle(Register destination,
-                                              Register handle) {
-  DCHECK(!AreAliased(handle, destination));
-  Register table = destination;
-  LoadAddress(table, ExternalReference::code_pointer_table_address());
-  shrl(handle, Immediate(kCodePointerHandleShift));
-  // The code pointer table entry size is 16 bytes, so we have to do an
-  // explicit shift first (times_16 doesn't exist).
-  shll(handle, Immediate(kCodePointerTableEntrySizeLog2));
-  movq(destination,
-       Operand(table, handle, times_1, kCodePointerTableEntryCodeObjectOffset));
-  // The LSB is used as marking bit by the code pointer table, so here we have
-  // to set it using a bitwise OR as it may or may not be set.
-  orq(destination, Immediate(kHeapObjectTag));
+  StoreIndirectPointerField(dst_field_operand, value);
+#else
+  StoreTaggedField(dst_field_operand, value);
+#endif  // V8_ENABLE_SANDBOX
 }
 
 void MacroAssembler::LoadCodeEntrypointViaCodePointer(Register destination,
                                                       Operand field_operand) {
   DCHECK(!AreAliased(destination, kScratchRegister));
+#ifdef V8_ENABLE_SANDBOX
   DCHECK(!field_operand.AddressUsesRegister(kScratchRegister));
   LoadAddress(kScratchRegister,
               ExternalReference::code_pointer_table_address());
@@ -583,8 +560,10 @@ void MacroAssembler::LoadCodeEntrypointViaCodePointer(Register destination,
   shrl(destination, Immediate(kCodePointerHandleShift));
   shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
   movq(destination, Operand(kScratchRegister, destination, times_1, 0));
-}
+#else
+  UNREACHABLE();
 #endif  // V8_ENABLE_SANDBOX
+}
 
 void MacroAssembler::CallEphemeronKeyBarrier(Register object,
                                              Register slot_address,

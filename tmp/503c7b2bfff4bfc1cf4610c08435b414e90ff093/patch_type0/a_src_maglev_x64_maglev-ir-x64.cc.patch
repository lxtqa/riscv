diff --git a/src/maglev/x64/maglev-ir-x64.cc b/src/maglev/x64/maglev-ir-x64.cc
index 28b0ad0819c..a4067f0216c 100644
--- a/src/maglev/x64/maglev-ir-x64.cc
+++ b/src/maglev/x64/maglev-ir-x64.cc
@@ -731,7 +731,7 @@ enum class ReduceInterruptBudgetType { kLoop, kReturn };
 
 void HandleInterruptsAndTiering(MaglevAssembler* masm, ZoneLabelRef done,
                                 Node* node, ReduceInterruptBudgetType type,
-                                Input function) {
+                                Register scratch0) {
   // For loops, first check for interrupts. Don't do this for returns, as we
   // can't lazy deopt to the end of a return.
   if (type == ReduceInterruptBudgetType::kLoop) {
@@ -748,10 +748,8 @@ void HandleInterruptsAndTiering(MaglevAssembler* masm, ZoneLabelRef done,
     {
       SaveRegisterStateForCall save_register_state(masm,
                                                    node->register_snapshot());
-      __ Push(function);
-      // Move into kContextRegister after the push, in case that one clobbers
-      // kContextRegister.
       __ Move(kContextRegister, masm->native_context().object());
+      __ Push(MemOperand(rbp, StandardFrameConstants::kFunctionOffset));
       __ CallRuntime(Runtime::kBytecodeBudgetInterruptWithStackCheck_Maglev, 1);
       save_register_state.DefineSafepointWithLazyDeopt(node->lazy_deopt_info());
     }
@@ -764,10 +762,8 @@ void HandleInterruptsAndTiering(MaglevAssembler* masm, ZoneLabelRef done,
   {
     SaveRegisterStateForCall save_register_state(masm,
                                                  node->register_snapshot());
-    __ Push(function);
-    // Move into kContextRegister after the push, in case that one clobbers
-    // kContextRegister.
     __ Move(kContextRegister, masm->native_context().object());
+    __ Push(MemOperand(rbp, StandardFrameConstants::kFunctionOffset));
     // Note: must not cause a lazy deopt!
     __ CallRuntime(Runtime::kBytecodeBudgetInterrupt_Maglev, 1);
     save_register_state.DefineSafepoint();
@@ -776,20 +772,17 @@ void HandleInterruptsAndTiering(MaglevAssembler* masm, ZoneLabelRef done,
 }
 
 void GenerateReduceInterruptBudget(MaglevAssembler* masm, Node* node,
-                                   ReduceInterruptBudgetType type, int amount,
-                                   Input& function) {
-  {
-    MaglevAssembler::ScratchRegisterScope temps(masm);
-    Register scratch = temps.Acquire();
-    __ movq(scratch, MemOperand(rbp, StandardFrameConstants::kFunctionOffset));
-    __ LoadTaggedField(scratch,
-                       FieldOperand(scratch, JSFunction::kFeedbackCellOffset));
-    __ subl(FieldOperand(scratch, FeedbackCell::kInterruptBudgetOffset),
-            Immediate(amount));
-  }
+                                   ReduceInterruptBudgetType type, int amount) {
+  MaglevAssembler::ScratchRegisterScope temps(masm);
+  Register scratch = temps.Acquire();
+  __ movq(scratch, MemOperand(rbp, StandardFrameConstants::kFunctionOffset));
+  __ LoadTaggedField(scratch,
+                     FieldOperand(scratch, JSFunction::kFeedbackCellOffset));
+  __ subl(FieldOperand(scratch, FeedbackCell::kInterruptBudgetOffset),
+          Immediate(amount));
   ZoneLabelRef done(masm);
   __ JumpToDeferredIf(less, HandleInterruptsAndTiering, done, node, type,
-                      function);
+                      scratch);
   __ bind(*done);
 }
 
@@ -797,24 +790,22 @@ void GenerateReduceInterruptBudget(MaglevAssembler* masm, Node* node,
 
 int ReduceInterruptBudgetForLoop::MaxCallStackArgs() const { return 1; }
 void ReduceInterruptBudgetForLoop::SetValueLocationConstraints() {
-  UseAny(function());
   set_temporaries_needed(1);
 }
 void ReduceInterruptBudgetForLoop::GenerateCode(MaglevAssembler* masm,
                                                 const ProcessingState& state) {
   GenerateReduceInterruptBudget(masm, this, ReduceInterruptBudgetType::kLoop,
-                                amount(), function());
+                                amount());
 }
 
 int ReduceInterruptBudgetForReturn::MaxCallStackArgs() const { return 1; }
 void ReduceInterruptBudgetForReturn::SetValueLocationConstraints() {
-  UseAny(function());
   set_temporaries_needed(1);
 }
 void ReduceInterruptBudgetForReturn::GenerateCode(
     MaglevAssembler* masm, const ProcessingState& state) {
   GenerateReduceInterruptBudget(masm, this, ReduceInterruptBudgetType::kReturn,
-                                amount(), function());
+                                amount());
 }
 
 int FunctionEntryStackCheck::MaxCallStackArgs() const { return 1; }
-- 
2.35.1


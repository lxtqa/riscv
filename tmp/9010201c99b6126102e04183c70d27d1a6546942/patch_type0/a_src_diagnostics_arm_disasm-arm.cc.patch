diff --git a/src/diagnostics/arm/disasm-arm.cc b/src/diagnostics/arm/disasm-arm.cc
index e23e2a815d8..38596295ce6 100644
--- a/src/diagnostics/arm/disasm-arm.cc
+++ b/src/diagnostics/arm/disasm-arm.cc
@@ -32,6 +32,7 @@
 
 #include "src/base/bits.h"
 #include "src/base/platform/platform.h"
+#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/codegen/arm/assembler-arm.h"
 #include "src/codegen/arm/constants-arm.h"
@@ -210,13 +211,13 @@ void Decoder::PrintShiftRm(Instruction* instr) {
     } else if (((shift == LSR) || (shift == ASR)) && (shift_amount == 0)) {
       shift_amount = 32;
     }
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, ", %s #%d",
-                                shift_names[shift_index], shift_amount);
+    out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, ", %s #%d",
+                                      shift_names[shift_index], shift_amount);
   } else {
     // by register
     int rs = instr->RsValue();
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, ", %s ",
-                                shift_names[shift_index]);
+    out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, ", %s ",
+                                      shift_names[shift_index]);
     PrintRegister(rs);
   }
 }
@@ -227,7 +228,7 @@ void Decoder::PrintShiftImm(Instruction* instr) {
   int rotate = instr->RotateValue() * 2;
   int immed8 = instr->Immed8Value();
   int imm = base::bits::RotateRight32(immed8, rotate);
-  out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "#%d", imm);
+  out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, "#%d", imm);
 }
 
 // Print the optional shift and immediate used by saturating instructions.
@@ -235,8 +236,8 @@ void Decoder::PrintShiftSat(Instruction* instr) {
   int shift = instr->Bits(11, 7);
   if (shift > 0) {
     out_buffer_pos_ +=
-        SNPrintF(out_buffer_ + out_buffer_pos_, ", %s #%d",
-                 shift_names[instr->Bit(6) * 2], instr->Bits(11, 7));
+        base::SNPrintF(out_buffer_ + out_buffer_pos_, ", %s #%d",
+                       shift_names[instr->Bit(6) * 2], instr->Bits(11, 7));
   }
 }
 
@@ -277,10 +278,12 @@ void Decoder::PrintSoftwareInterrupt(SoftwareInterruptCodes svc) {
       return;
     default:
       if (svc >= kStopCode) {
-        out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%d - 0x%x",
-                                    svc & kStopCodeMask, svc & kStopCodeMask);
+        out_buffer_pos_ +=
+            base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d - 0x%x",
+                           svc & kStopCodeMask, svc & kStopCodeMask);
       } else {
-        out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%d", svc);
+        out_buffer_pos_ +=
+            base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d", svc);
       }
       return;
   }
@@ -382,34 +385,35 @@ int Decoder::FormatVFPinstruction(Instruction* instr, const char* format) {
 
 void Decoder::FormatNeonList(int Vd, int type) {
   if (type == nlt_1) {
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "{d%d}", Vd);
+    out_buffer_pos_ +=
+        base::SNPrintF(out_buffer_ + out_buffer_pos_, "{d%d}", Vd);
   } else if (type == nlt_2) {
     out_buffer_pos_ +=
-        SNPrintF(out_buffer_ + out_buffer_pos_, "{d%d, d%d}", Vd, Vd + 1);
+        base::SNPrintF(out_buffer_ + out_buffer_pos_, "{d%d, d%d}", Vd, Vd + 1);
   } else if (type == nlt_3) {
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                "{d%d, d%d, d%d}", Vd, Vd + 1, Vd + 2);
+    out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                      "{d%d, d%d, d%d}", Vd, Vd + 1, Vd + 2);
   } else if (type == nlt_4) {
     out_buffer_pos_ +=
-        SNPrintF(out_buffer_ + out_buffer_pos_, "{d%d, d%d, d%d, d%d}", Vd,
-                 Vd + 1, Vd + 2, Vd + 3);
+        base::SNPrintF(out_buffer_ + out_buffer_pos_, "{d%d, d%d, d%d, d%d}",
+                       Vd, Vd + 1, Vd + 2, Vd + 3);
   }
 }
 
 void Decoder::FormatNeonMemory(int Rn, int align, int Rm) {
-  out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "[%s",
-                              converter_.NameOfCPURegister(Rn));
+  out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, "[%s",
+                                    converter_.NameOfCPURegister(Rn));
   if (align != 0) {
     out_buffer_pos_ +=
-        SNPrintF(out_buffer_ + out_buffer_pos_, ":%d", (1 << align) << 6);
+        base::SNPrintF(out_buffer_ + out_buffer_pos_, ":%d", (1 << align) << 6);
   }
   if (Rm == 15) {
     Print("]");
   } else if (Rm == 13) {
     Print("]!");
   } else {
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "], %s",
-                                converter_.NameOfCPURegister(Rm));
+    out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, "], %s",
+                                      converter_.NameOfCPURegister(Rm));
   }
 }
 
@@ -418,7 +422,8 @@ void Decoder::PrintMovwMovt(Instruction* instr) {
   int imm = instr->ImmedMovwMovtValue();
   int rd = instr->RdValue();
   PrintRegister(rd);
-  out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, ", #%d", imm);
+  out_buffer_pos_ +=
+      base::SNPrintF(out_buffer_ + out_buffer_pos_, ", #%d", imm);
 }
 
 // FormatOption takes a formatting string and interprets it based on
@@ -449,7 +454,8 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
     }
     case 'd': {  // 'd: vmov double immediate.
       double d = instr->DoubleImmedVmov().get_scalar();
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "#%g", d);
+      out_buffer_pos_ +=
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, "#%g", d);
       return 1;
     }
     case 'f': {  // 'f: bitfield instructions - v7 and above.
@@ -462,8 +468,8 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
         DCHECK_GT(width, 0);
       }
       DCHECK_LE(width + lsbit, 32);
-      out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, "#%d, #%d", lsbit, width);
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                        "#%d, #%d", lsbit, width);
       return 1;
     }
     case 'h': {  // 'h: halfword operation for extra loads and stores
@@ -483,8 +489,8 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
       DCHECK((lsb >= 0) && (lsb <= 31));
       DCHECK_LE(width + lsb, 32);
 
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%d",
-                                  instr->Bits(width + lsb - 1, lsb));
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d",
+                                        instr->Bits(width + lsb - 1, lsb));
       return 8;
     }
     case 'l': {  // 'l: branch and link
@@ -521,29 +527,30 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
       DCHECK(STRING_STARTS_WITH(format, "msg"));
       byte* str =
           reinterpret_cast<byte*>(instr->InstructionBits() & 0x0FFFFFFF);
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%s",
-                                  converter_.NameInCode(str));
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s",
+                                        converter_.NameInCode(str));
       return 3;
     }
     case 'o': {
       if ((format[3] == '1') && (format[4] == '2')) {
         // 'off12: 12-bit offset for load and store instructions
         DCHECK(STRING_STARTS_WITH(format, "off12"));
-        out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%d",
-                                    instr->Offset12Value());
+        out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d",
+                                          instr->Offset12Value());
         return 5;
       } else if (format[3] == '0') {
         // 'off0to3and8to19 16-bit immediate encoded in bits 19-8 and 3-0.
         DCHECK(STRING_STARTS_WITH(format, "off0to3and8to19"));
         out_buffer_pos_ +=
-            SNPrintF(out_buffer_ + out_buffer_pos_, "%d",
-                     (instr->Bits(19, 8) << 4) + instr->Bits(3, 0));
+            base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d",
+                           (instr->Bits(19, 8) << 4) + instr->Bits(3, 0));
         return 15;
       }
       // 'off8: 8-bit offset for extra load and store instructions
       DCHECK(STRING_STARTS_WITH(format, "off8"));
       int offs8 = (instr->ImmedHValue() << 4) | instr->ImmedLValue();
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%d", offs8);
+      out_buffer_pos_ +=
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d", offs8);
       return 4;
     }
     case 'p': {  // 'pu: P and U bits for load and store instructions
@@ -591,7 +598,8 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
                  STRING_STARTS_WITH(format, "size3"));
           int sz = 8 << (format[4] == '2' ? instr->Bits(19, 18)
                                           : instr->Bits(21, 20));
-          out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%d", sz);
+          out_buffer_pos_ +=
+              base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d", sz);
           return 5;
         }
       } else if (format[1] == 'p') {
@@ -624,7 +632,7 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
     case 't': {  // 'target: target of branch instructions
       DCHECK(STRING_STARTS_WITH(format, "target"));
       int off = (static_cast<uint32_t>(instr->SImmed24Value()) << 2) + 8u;
-      out_buffer_pos_ += SNPrintF(
+      out_buffer_pos_ += base::SNPrintF(
           out_buffer_ + out_buffer_pos_, "%+d -> %s", off,
           converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + off));
       return 6;
@@ -672,8 +680,8 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
         }
       }
       out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, "0x%08" PRIxPTR,
-                   reinterpret_cast<uintptr_t>(addr));
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, "0x%08" PRIxPTR,
+                         reinterpret_cast<uintptr_t>(addr));
       return 1;
     }
     case 'S':
@@ -1470,8 +1478,8 @@ void Decoder::DecodeTypeVFP(Instruction* instr) {
         // vcvt.f64.s32 Dd, Dd, #<fbits>
         int fraction_bits = 32 - ((instr->Bits(3, 0) << 1) | instr->Bit(5));
         Format(instr, "vcvt'cond.f64.s32 'Dd, 'Dd");
-        out_buffer_pos_ +=
-            SNPrintF(out_buffer_ + out_buffer_pos_, ", #%d", fraction_bits);
+        out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                          ", #%d", fraction_bits);
       } else if (((instr->Opc2Value() >> 1) == 0x6) &&
                  (instr->Opc3Value() & 0x1)) {
         DecodeVCVTBetweenFloatingPointAndInteger(instr);
@@ -1560,13 +1568,15 @@ void Decoder::DecodeTypeVFP(Instruction* instr) {
           if ((opc1_opc2 & 0x8) != 0) {
             // NeonS8 / NeonU8
             int i = opc1_opc2 & 0x7;
-            out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                        "vmov.8 d%d[%d], %s", vd, i, rt_name);
+            out_buffer_pos_ +=
+                base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                               "vmov.8 d%d[%d], %s", vd, i, rt_name);
           } else if ((opc1_opc2 & 0x1) != 0) {
             // NeonS16 / NeonU16
             int i = (opc1_opc2 >> 1) & 0x3;
-            out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                        "vmov.16 d%d[%d], %s", vd, i, rt_name);
+            out_buffer_pos_ +=
+                base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                               "vmov.16 d%d[%d], %s", vd, i, rt_name);
           } else {
             Unknown(instr);
           }
@@ -1579,8 +1589,8 @@ void Decoder::DecodeTypeVFP(Instruction* instr) {
           size = 8;
         }
         int Vd = instr->VFPNRegValue(kSimd128Precision);
-        out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                    "vdup.%i q%d, %s", size, Vd, rt_name);
+        out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                          "vdup.%i q%d, %s", size, Vd, rt_name);
       }
     } else if ((instr->VLValue() == 0x1) && (instr->VCValue() == 0x1)) {
       int opc1_opc2 = (instr->Bits(22, 21) << 2) | instr->Bits(6, 5);
@@ -1599,14 +1609,14 @@ void Decoder::DecodeTypeVFP(Instruction* instr) {
           // NeonS8 / NeonU8
           int i = opc1_opc2 & 0x7;
           out_buffer_pos_ +=
-              SNPrintF(out_buffer_ + out_buffer_pos_, "vmov.%c8 %s, d%d[%d]",
-                       sign, rt_name, vn, i);
+              base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                             "vmov.%c8 %s, d%d[%d]", sign, rt_name, vn, i);
         } else if ((opc1_opc2 & 0x1) != 0) {
           // NeonS16 / NeonU16
           int i = (opc1_opc2 >> 1) & 0x3;
           out_buffer_pos_ +=
-              SNPrintF(out_buffer_ + out_buffer_pos_, "vmov.%c16 %s, d%d[%d]",
-                       sign, rt_name, vn, i);
+              base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                             "vmov.%c16 %s, d%d[%d]", sign, rt_name, vn, i);
         } else {
           Unknown(instr);
         }
@@ -1770,13 +1780,13 @@ void Decoder::DecodeVmovImmediate(Instruction* instr) {
   switch (cmode) {
     case 0: {
       uint32_t imm32 = imm;
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                  "vmov.i32 q%d, %d", vd, imm32);
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                        "vmov.i32 q%d, %d", vd, imm32);
       break;
     }
     case 0xe: {
-      out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, "vmov.i8 q%d, %d", vd, imm);
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                        "vmov.i8 q%d, %d", vd, imm);
       break;
     }
     default:
@@ -2161,15 +2171,15 @@ void Decoder::DecodeAdvancedSIMDDataProcessing(Instruction* instr) {
         if (q) {
           int Vd = instr->VFPDRegValue(kSimd128Precision);
           int Vm = instr->VFPMRegValue(kSimd128Precision);
-          out_buffer_pos_ +=
-              SNPrintF(out_buffer_ + out_buffer_pos_, "vshr.%s%d q%d, q%d, #%d",
-                       u ? "u" : "s", size, Vd, Vm, shift);
+          out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                            "vshr.%s%d q%d, q%d, #%d",
+                                            u ? "u" : "s", size, Vd, Vm, shift);
         } else {
           int Vd = instr->VFPDRegValue(kDoublePrecision);
           int Vm = instr->VFPMRegValue(kDoublePrecision);
-          out_buffer_pos_ +=
-              SNPrintF(out_buffer_ + out_buffer_pos_, "vshr.%s%d d%d, d%d, #%d",
-                       u ? "u" : "s", size, Vd, Vm, shift);
+          out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                            "vshr.%s%d d%d, d%d, #%d",
+                                            u ? "u" : "s", size, Vd, Vm, shift);
         }
       } else if (imm3H_L != 0 && opc == 1) {
         // vsra.<type><size> Qd, Qm, shift
@@ -2180,15 +2190,15 @@ void Decoder::DecodeAdvancedSIMDDataProcessing(Instruction* instr) {
         if (q) {
           int Vd = instr->VFPDRegValue(kSimd128Precision);
           int Vm = instr->VFPMRegValue(kSimd128Precision);
-          out_buffer_pos_ +=
-              SNPrintF(out_buffer_ + out_buffer_pos_, "vsra.%s%d q%d, q%d, #%d",
-                       u ? "u" : "s", size, Vd, Vm, shift);
+          out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                            "vsra.%s%d q%d, q%d, #%d",
+                                            u ? "u" : "s", size, Vd, Vm, shift);
         } else {
           int Vd = instr->VFPDRegValue(kDoublePrecision);
           int Vm = instr->VFPMRegValue(kDoublePrecision);
-          out_buffer_pos_ +=
-              SNPrintF(out_buffer_ + out_buffer_pos_, "vsra.%s%d d%d, d%d, #%d",
-                       u ? "u" : "s", size, Vd, Vm, shift);
+          out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                            "vsra.%s%d d%d, d%d, #%d",
+                                            u ? "u" : "s", size, Vd, Vm, shift);
         }
       } else if (imm3H_L != 0 && imm3L == 0 && opc == 0b1010 && !q) {
         // vmovl
@@ -2197,8 +2207,8 @@ void Decoder::DecodeAdvancedSIMDDataProcessing(Instruction* instr) {
         int Vm = instr->VFPMRegValue(kDoublePrecision);
         int imm3H = instr->Bits(21, 19);
         out_buffer_pos_ +=
-            SNPrintF(out_buffer_ + out_buffer_pos_, "vmovl.%s%d q%d, d%d",
-                     u ? "u" : "s", imm3H * 8, Vd, Vm);
+            base::SNPrintF(out_buffer_ + out_buffer_pos_, "vmovl.%s%d q%d, d%d",
+                           u ? "u" : "s", imm3H * 8, Vd, Vm);
       } else if (!u && imm3H_L != 0 && opc == 0b0101) {
         // vshl.i<size> Qd, Qm, shift
         int imm7 = (l << 6) | instr->Bits(21, 16);
@@ -2207,8 +2217,8 @@ void Decoder::DecodeAdvancedSIMDDataProcessing(Instruction* instr) {
         int Vd = instr->VFPDRegValue(kSimd128Precision);
         int Vm = instr->VFPMRegValue(kSimd128Precision);
         out_buffer_pos_ +=
-            SNPrintF(out_buffer_ + out_buffer_pos_, "vshl.i%d q%d, q%d, #%d",
-                     size, Vd, Vm, shift);
+            base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                           "vshl.i%d q%d, q%d, #%d", size, Vd, Vm, shift);
       } else if (u && imm3H_L != 0 && (opc & 0b1110) == 0b0100) {
         // vsli.<size> Dd, Dm, shift
         // vsri.<size> Dd, Dm, shift
@@ -2225,9 +2235,9 @@ void Decoder::DecodeAdvancedSIMDDataProcessing(Instruction* instr) {
         }
         int Vd = instr->VFPDRegValue(kDoublePrecision);
         int Vm = instr->VFPMRegValue(kDoublePrecision);
-        out_buffer_pos_ +=
-            SNPrintF(out_buffer_ + out_buffer_pos_, "vs%ci.%d d%d, d%d, #%d",
-                     direction, size, Vd, Vm, shift);
+        out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                          "vs%ci.%d d%d, d%d, #%d", direction,
+                                          size, Vd, Vm, shift);
       }
     }
   } else {
@@ -2247,8 +2257,9 @@ void Decoder::DecodeAdvancedSIMDTwoOrThreeRegisters(Instruction* instr) {
     int Vd = instr->VFPDRegValue(kSimd128Precision);
     int Vm = instr->VFPMRegValue(kSimd128Precision);
     int Vn = instr->VFPNRegValue(kSimd128Precision);
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                "vext.8 q%d, q%d, q%d, #%d", Vd, Vn, Vm, imm4);
+    out_buffer_pos_ +=
+        base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                       "vext.8 q%d, q%d, q%d, #%d", Vd, Vn, Vm, imm4);
   } else if (op0 && op1 == 0b11 && ((op2 >> 1) == 0)) {
     // Advanced SIMD two registers misc
     int size = instr->Bits(19, 18);
@@ -2262,8 +2273,9 @@ void Decoder::DecodeAdvancedSIMDTwoOrThreeRegisters(Instruction* instr) {
     if (opc1 == 0 && (opc2 >> 2) == 0) {
       int op = kBitsPerByte << (static_cast<int>(Neon64) - instr->Bits(8, 7));
       // vrev<op>.<esize> Qd, Qm.
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                  "vrev%d.%d q%d, q%d", op, esize, Vd, Vm);
+      out_buffer_pos_ +=
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, "vrev%d.%d q%d, q%d",
+                         op, esize, Vd, Vm);
     } else if (opc1 == 0 && opc2 == 0b0100) {
       Format(instr, q ? "vpaddl.s'size2 'Qd, 'Qm" : "vpaddl.s'size2 'Dd, 'Dm");
     } else if (opc1 == 0 && opc2 == 0b0101) {
@@ -2305,8 +2317,8 @@ void Decoder::DecodeAdvancedSIMDTwoOrThreeRegisters(Instruction* instr) {
       const char* name = op == 0b01 ? "vqmovun" : "vqmovn";
       char type = op == 0b11 ? 'u' : 's';
       out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, "%s.%c%i d%d, q%d", name,
-                   type, esize << 1, Vd, Vm);
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s.%c%i d%d, q%d",
+                         name, type, esize << 1, Vd, Vm);
     } else if (opc1 == 0b10 && opc2 == 0b1000) {
       Format(instr, q ? "vrintn.f32 'Qd, 'Qm" : "vrintn.f32 'Dd, 'Dm");
     } else if (opc1 == 0b10 && opc2 == 0b1011) {
@@ -2336,8 +2348,8 @@ void Decoder::DecodeAdvancedSIMDTwoOrThreeRegisters(Instruction* instr) {
           suffix = "u32.f32";
           break;
       }
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                  "vcvt.%s q%d, q%d", suffix, Vd, Vm);
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                        "vcvt.%s q%d, q%d", suffix, Vd, Vm);
     }
   } else if (op0 && op1 == 0b11 && op2 == 0b10) {
     // VTBL, VTBX
@@ -2346,8 +2358,9 @@ void Decoder::DecodeAdvancedSIMDTwoOrThreeRegisters(Instruction* instr) {
     int Vm = instr->VFPMRegValue(kDoublePrecision);
     int len = instr->Bits(9, 8);
     NeonListOperand list(DwVfpRegister::from_code(Vn), len + 1);
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%s d%d, ",
-                                instr->Bit(6) == 0 ? "vtbl.8" : "vtbx.8", Vd);
+    out_buffer_pos_ +=
+        base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s d%d, ",
+                       instr->Bit(6) == 0 ? "vtbl.8" : "vtbx.8", Vd);
     FormatNeonList(Vn, list.type());
     Print(", ");
     PrintDRegister(Vm);
@@ -2371,13 +2384,13 @@ void Decoder::DecodeAdvancedSIMDTwoOrThreeRegisters(Instruction* instr) {
       if (instr->Bit(6) == 0) {
         int Vd = instr->VFPDRegValue(kDoublePrecision);
         out_buffer_pos_ +=
-            SNPrintF(out_buffer_ + out_buffer_pos_, "vdup.%i d%d, d%d[%d]",
-                     esize, Vd, Vm, index);
+            base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                           "vdup.%i d%d, d%d[%d]", esize, Vd, Vm, index);
       } else {
         int Vd = instr->VFPDRegValue(kSimd128Precision);
         out_buffer_pos_ +=
-            SNPrintF(out_buffer_ + out_buffer_pos_, "vdup.%i q%d, d%d[%d]",
-                     esize, Vd, Vm, index);
+            base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                           "vdup.%i q%d, d%d[%d]", esize, Vd, Vm, index);
       }
     } else {
       Unknown(instr);
@@ -2408,16 +2421,19 @@ void Decoder::DecodeMemoryHintsAndBarriers(Instruction* instr) {
     int option = instr->Bits(3, 0);
     switch (instr->Bits(7, 4)) {
       case 4:
-        out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "dsb %s",
-                                    barrier_option_names[option]);
+        out_buffer_pos_ +=
+            base::SNPrintF(out_buffer_ + out_buffer_pos_, "dsb %s",
+                           barrier_option_names[option]);
         break;
       case 5:
-        out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "dmb %s",
-                                    barrier_option_names[option]);
+        out_buffer_pos_ +=
+            base::SNPrintF(out_buffer_ + out_buffer_pos_, "dmb %s",
+                           barrier_option_names[option]);
         break;
       case 6:
-        out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "isb %s",
-                                    barrier_option_names[option]);
+        out_buffer_pos_ +=
+            base::SNPrintF(out_buffer_ + out_buffer_pos_, "isb %s",
+                           barrier_option_names[option]);
         break;
       default:
         Unknown(instr);
@@ -2428,13 +2444,13 @@ void Decoder::DecodeMemoryHintsAndBarriers(Instruction* instr) {
     int offset = instr->Bits(11, 0);
     if (offset == 0) {
       out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, "pld [%s]", rn_name);
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, "pld [%s]", rn_name);
     } else if (instr->Bit(23) == 0) {
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                  "pld [%s, #-%d]", rn_name, offset);
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                        "pld [%s, #-%d]", rn_name, offset);
     } else {
-      out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                  "pld [%s, #+%d]", rn_name, offset);
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                        "pld [%s, #+%d]", rn_name, offset);
     }
   } else {
     Unknown(instr);
@@ -2460,7 +2476,7 @@ void Decoder::DecodeAdvancedSIMDElementOrStructureLoadStore(
       int align = instr->Bits(5, 4);
       const char* op = l ? "vld1.%d " : "vst1.%d ";
       out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, op, (1 << size) << 3);
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, op, (1 << size) << 3);
       FormatNeonList(Vd, itype);
       Print(", ");
       FormatNeonMemory(Rn, align, Rm);
@@ -2474,8 +2490,8 @@ void Decoder::DecodeAdvancedSIMDElementOrStructureLoadStore(
       int size = instr->Bits(7, 6);
       DCHECK_NE(0b11, size);
       int type = instr->Bit(5) ? nlt_2 : nlt_1;
-      out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, "vld1.%d ", (1 << size) << 3);
+      out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                        "vld1.%d ", (1 << size) << 3);
       FormatNeonList(Vd, type);
       DCHECK_EQ(0, instr->Bit(4));  // Alignment not supported.
       Print(", ");
@@ -2493,8 +2509,8 @@ void Decoder::DecodeAdvancedSIMDElementOrStructureLoadStore(
       // vst1 (single element to one lane) - A1, A2, A3.
       // Omit alignment.
       out_buffer_pos_ +=
-          SNPrintF(out_buffer_ + out_buffer_pos_, "v%s1.%d {d%d[%d]}",
-                   (l ? "ld" : "st"), (1 << size) << 3, Vd, index);
+          base::SNPrintF(out_buffer_ + out_buffer_pos_, "v%s1.%d {d%d[%d]}",
+                         (l ? "ld" : "st"), (1 << size) << 3, Vd, index);
       Print(", ");
       FormatNeonMemory(Rn, 0, Rm);
     } else {
@@ -2525,17 +2541,17 @@ int Decoder::ConstantPoolSizeAt(byte* instr_ptr) {
 int Decoder::InstructionDecode(byte* instr_ptr) {
   Instruction* instr = Instruction::At(reinterpret_cast<Address>(instr_ptr));
   // Print raw instruction bytes.
-  out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_, "%08x       ",
-                              instr->InstructionBits());
+  out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
+                                    "%08x       ", instr->InstructionBits());
   if (instr->ConditionField() == kSpecialCondition) {
     DecodeSpecialCondition(instr);
     return kInstrSize;
   }
   int instruction_bits = *(reinterpret_cast<int*>(instr_ptr));
   if ((instruction_bits & kConstantPoolMarkerMask) == kConstantPoolMarker) {
-    out_buffer_pos_ += SNPrintF(out_buffer_ + out_buffer_pos_,
-                                "constant pool begin (length %d)",
-                                DecodeConstantPoolLength(instruction_bits));
+    out_buffer_pos_ += base::SNPrintF(
+        out_buffer_ + out_buffer_pos_, "constant pool begin (length %d)",
+        DecodeConstantPoolLength(instruction_bits));
     return kInstrSize;
   }
   switch (instr->TypeValue()) {
@@ -2583,7 +2599,7 @@ int Decoder::InstructionDecode(byte* instr_ptr) {
 namespace disasm {
 
 const char* NameConverter::NameOfAddress(byte* addr) const {
-  v8::internal::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
+  v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 

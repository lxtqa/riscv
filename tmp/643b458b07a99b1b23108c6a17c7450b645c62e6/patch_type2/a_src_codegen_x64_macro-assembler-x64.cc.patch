diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index 6c5ae64da41..035629ca8dd 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -163,7 +163,20 @@ Operand TurboAssembler::RootAsOperand(RootIndex index) {
   return Operand(kRootRegister, RootRegisterOffsetForRootIndex(index));
 }
 
+void TurboAssembler::LoadTaggedRoot(Register destination, RootIndex index) {
+  if (V8_STATIC_ROOTS_BOOL && RootsTable::IsReadOnly(index)) {
+    mov_tagged(destination, Immediate(ReadOnlyRootPtr(index)));
+    return;
+  }
+  DCHECK(root_array_available_);
+  movq(destination, RootAsOperand(index));
+}
+
 void TurboAssembler::LoadRoot(Register destination, RootIndex index) {
+  if (V8_STATIC_ROOTS_BOOL && RootsTable::IsReadOnly(index)) {
+    DecompressTaggedPointer(destination, ReadOnlyRootPtr(index));
+    return;
+  }
   DCHECK(root_array_available_);
   movq(destination, RootAsOperand(index));
 }
@@ -174,6 +187,10 @@ void MacroAssembler::PushRoot(RootIndex index) {
 }
 
 void TurboAssembler::CompareRoot(Register with, RootIndex index) {
+  if (V8_STATIC_ROOTS_BOOL && RootsTable::IsReadOnly(index)) {
+    cmp_tagged(with, Immediate(ReadOnlyRootPtr(index)));
+    return;
+  }
   DCHECK(root_array_available_);
   if (base::IsInRange(index, RootIndex::kFirstStrongOrReadOnlyRoot,
                       RootIndex::kLastStrongOrReadOnlyRoot)) {
@@ -185,6 +202,10 @@ void TurboAssembler::CompareRoot(Register with, RootIndex index) {
 }
 
 void TurboAssembler::CompareRoot(Operand with, RootIndex index) {
+  if (V8_STATIC_ROOTS_BOOL && RootsTable::IsReadOnly(index)) {
+    cmp_tagged(with, Immediate(ReadOnlyRootPtr(index)));
+    return;
+  }
   DCHECK(root_array_available_);
   DCHECK(!with.AddressUsesRegister(kScratchRegister));
   if (base::IsInRange(index, RootIndex::kFirstStrongOrReadOnlyRoot,
@@ -357,6 +378,13 @@ void TurboAssembler::DecompressAnyTagged(Register destination,
   addq(destination, kPtrComprCageBaseRegister);
 }
 
+void TurboAssembler::DecompressTaggedPointer(Register destination,
+                                             Tagged_t immediate) {
+  ASM_CODE_COMMENT(this);
+  leaq(destination,
+       Operand(kPtrComprCageBaseRegister, static_cast<int32_t>(immediate)));
+}
+
 void MacroAssembler::RecordWriteField(Register object, int offset,
                                       Register value, Register slot_address,
                                       SaveFPRegsMode save_fp,

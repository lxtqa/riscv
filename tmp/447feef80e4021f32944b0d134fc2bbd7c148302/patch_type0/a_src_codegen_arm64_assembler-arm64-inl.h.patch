diff --git a/src/codegen/arm64/assembler-arm64-inl.h b/src/codegen/arm64/assembler-arm64-inl.h
index 0ce128682b..ee15bd74f4 100644
--- a/src/codegen/arm64/assembler-arm64-inl.h
+++ b/src/codegen/arm64/assembler-arm64-inl.h
@@ -528,6 +528,15 @@ Handle<HeapObject> Assembler::target_object_handle_at(Address pc) {
       Assembler::embedded_object_index_referenced_from(pc));
 }
 
+Builtin Assembler::target_builtin_at(Address pc) {
+  Instruction* instr = reinterpret_cast<Instruction*>(pc);
+  DCHECK(instr->IsBranchAndLink() || instr->IsUnconditionalBranch());
+  DCHECK_EQ(instr->ImmPCOffset() % kInstrSize, 0);
+  int builtin_id = static_cast<int>(instr->ImmPCOffset() / kInstrSize);
+  DCHECK(Builtins::IsBuiltinId(builtin_id));
+  return static_cast<Builtin>(builtin_id);
+}
+
 Address Assembler::runtime_entry_at(Address pc) {
   Instruction* instr = reinterpret_cast<Instruction*>(pc);
   if (instr->IsLdrLiteralX()) {
@@ -620,7 +629,8 @@ int RelocInfo::target_address_size() {
 }
 
 Address RelocInfo::target_address() {
-  DCHECK(IsCodeTarget(rmode_) || IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));
+  DCHECK(IsCodeTarget(rmode_) || IsNearBuiltinEntry(rmode_) ||
+         IsRuntimeEntry(rmode_) || IsWasmCall(rmode_));
   return Assembler::target_address_at(pc_, constant_pool_);
 }
 
@@ -726,9 +736,14 @@ Address RelocInfo::target_internal_reference_address() {
   return pc_;
 }
 
+Builtin RelocInfo::target_builtin_at(Assembler* origin) {
+  DCHECK(IsNearBuiltinEntry(rmode_));
+  return Assembler::target_builtin_at(pc_);
+}
+
 Address RelocInfo::target_runtime_entry(Assembler* origin) {
   DCHECK(IsRuntimeEntry(rmode_));
-  return origin->runtime_entry_at(pc_);
+  return target_address();
 }
 
 void RelocInfo::set_target_runtime_entry(Address target,

diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index 2ea1ab2520a..d49002954c2 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -493,37 +493,35 @@ void MacroAssembler::LoadExternalPointerField(
 #endif  // V8_ENABLE_SANDBOX
 }
 
+void MacroAssembler::StoreTrustedPointerField(Operand dst_field_operand,
+                                              Register value) {
+#ifdef V8_ENABLE_SANDBOX
+  StoreIndirectPointerField(dst_field_operand, value);
+#else
+  StoreTaggedField(dst_field_operand, value);
+#endif  // V8_ENABLE_SANDBOX
+}
+
 void MacroAssembler::LoadIndirectPointerField(Register destination,
                                               Operand field_operand,
                                               IndirectPointerTag tag,
                                               Register scratch) {
 #ifdef V8_ENABLE_SANDBOX
   DCHECK(!AreAliased(destination, scratch));
-  DCHECK(!field_operand.AddressUsesRegister(scratch));
 
-  // Move the IndirectPointerHandle into destination
-  movl(destination, field_operand);
+  // Move the IndirectPointerHandle into the scratch register.
+  Register handle = scratch;
+  movl(handle, field_operand);
 
-  if (tag == kCodeIndirectPointerTag) {
-    LoadAddress(scratch, ExternalReference::code_pointer_table_address());
-    shrl(destination, Immediate(kCodePointerHandleShift));
-    // The code pointer table entry size is 16 bytes, so we have to do an
-    // explicit shift first (times_16 doesn't exist).
-    shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
-    movq(destination, Operand(scratch, destination, times_1,
-                              kCodePointerTableEntryCodeObjectOffset));
+  // Resolve the handle. The tag implies the pointer table to use.
+  if (tag == kUnknownIndirectPointerTag) {
+    // TODO(saelo): implement once needed.
+    UNIMPLEMENTED();
+  } else if (tag == kCodeIndirectPointerTag) {
+    ResolveCodePointerHandle(destination, handle);
   } else {
-    CHECK(root_array_available_);
-    LoadAddress(scratch, ExternalReference::trusted_pointer_table_base_address(
-                             isolate()));
-    shrl(destination, Immediate(kTrustedPointerHandleShift));
-    static_assert(kTrustedPointerTableEntrySize == 8);
-    movq(destination, Operand(scratch, destination, times_8, 0));
+    ResolveTrustedPointerHandle(destination, handle, tag);
   }
-
-  // The LSB is used as marking bit by the code pointer table, so here we have
-  // to set it using a bitwise OR as it may or may not be set.
-  orq(destination, Immediate(kHeapObjectTag));
 #else
   UNREACHABLE();
 #endif  // V8_ENABLE_SANDBOX
@@ -537,22 +535,47 @@ void MacroAssembler::StoreIndirectPointerField(Operand dst_field_operand,
   movl(dst_field_operand, kScratchRegister);
 #else
   UNREACHABLE();
-#endif
+#endif  // V8_ENABLE_SANDBOX
 }
 
-void MacroAssembler::StoreTrustedPointerField(Operand dst_field_operand,
-                                              Register value) {
 #ifdef V8_ENABLE_SANDBOX
-  StoreIndirectPointerField(dst_field_operand, value);
-#else
-  StoreTaggedField(dst_field_operand, value);
-#endif  // V8_ENABLE_SANDBOX
+void MacroAssembler::ResolveTrustedPointerHandle(Register destination,
+                                                 Register handle,
+                                                 IndirectPointerTag tag) {
+  DCHECK_NE(tag, kCodeIndirectPointerTag);
+  DCHECK_NE(tag, kUnknownIndirectPointerTag);
+  DCHECK(!AreAliased(handle, destination));
+  CHECK(root_array_available_);
+  Register table = destination;
+  LoadAddress(table,
+              ExternalReference::trusted_pointer_table_base_address(isolate()));
+  shrl(handle, Immediate(kTrustedPointerHandleShift));
+  static_assert(kTrustedPointerTableEntrySize == 8);
+  movq(destination, Operand(table, handle, times_8, 0));
+  // The LSB is used as marking bit by the trusted pointer table, so here we
+  // have to set it using a bitwise OR as it may or may not be set.
+  orq(destination, Immediate(kHeapObjectTag));
+}
+
+void MacroAssembler::ResolveCodePointerHandle(Register destination,
+                                              Register handle) {
+  DCHECK(!AreAliased(handle, destination));
+  Register table = destination;
+  LoadAddress(table, ExternalReference::code_pointer_table_address());
+  shrl(handle, Immediate(kCodePointerHandleShift));
+  // The code pointer table entry size is 16 bytes, so we have to do an
+  // explicit shift first (times_16 doesn't exist).
+  shll(handle, Immediate(kCodePointerTableEntrySizeLog2));
+  movq(destination,
+       Operand(table, handle, times_1, kCodePointerTableEntryCodeObjectOffset));
+  // The LSB is used as marking bit by the code pointer table, so here we have
+  // to set it using a bitwise OR as it may or may not be set.
+  orq(destination, Immediate(kHeapObjectTag));
 }
 
 void MacroAssembler::LoadCodeEntrypointViaCodePointer(Register destination,
                                                       Operand field_operand) {
   DCHECK(!AreAliased(destination, kScratchRegister));
-#ifdef V8_ENABLE_SANDBOX
   DCHECK(!field_operand.AddressUsesRegister(kScratchRegister));
   LoadAddress(kScratchRegister,
               ExternalReference::code_pointer_table_address());
@@ -560,10 +583,8 @@ void MacroAssembler::LoadCodeEntrypointViaCodePointer(Register destination,
   shrl(destination, Immediate(kCodePointerHandleShift));
   shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
   movq(destination, Operand(kScratchRegister, destination, times_1, 0));
-#else
-  UNREACHABLE();
-#endif  // V8_ENABLE_SANDBOX
 }
+#endif  // V8_ENABLE_SANDBOX
 
 void MacroAssembler::CallEphemeronKeyBarrier(Register object,
                                              Register slot_address,

diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index fc86e56aedc..262296f08be 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -902,39 +902,28 @@ void Builtins::Generate_InterpreterEntryTrampoline(
   __ CmpObjectType(ecx, BYTECODE_ARRAY_TYPE, eax);
   __ j(not_equal, &compile_lazy);
 
-#ifndef V8_JITLESS
-  Register closure = edi;
-  Register feedback_vector = ecx;
   Label push_stack_frame;
-  // Load feedback vector and check if it is valid. If valid, check for
-  // optimized code and update invocation count. Otherwise, setup the stack
-  // frame.
-  __ mov(feedback_vector,
-         FieldOperand(closure, JSFunction::kFeedbackCellOffset));
-  __ mov(feedback_vector,
-         FieldOperand(feedback_vector, FeedbackCell::kValueOffset));
-  __ mov(eax, FieldOperand(feedback_vector, HeapObject::kMapOffset));
-  __ CmpInstanceType(eax, FEEDBACK_VECTOR_TYPE);
-  __ j(not_equal, &push_stack_frame);
+  Register feedback_vector = ecx;
+  Register closure = edi;
+  Register scratch = eax;
+  __ LoadFeedbackVector(feedback_vector, closure, scratch, &push_stack_frame,
+                        Label::kNear);
 
-  // Load the optimization state from the feedback vector and re-use the
+#ifndef V8_JITLESS
+  // If feedback vector is valid, check for optimized code and update invocation
+  // count. Load the optimization state from the feedback vector and re-use the
   // register.
   Label flags_need_processing;
   Register flags = ecx;
+  XMMRegister saved_feedback_vector = xmm1;
   __ LoadFeedbackVectorFlagsAndJumpIfNeedsProcessing(
-      flags, xmm1, CodeKind::INTERPRETED_FUNCTION, &flags_need_processing);
+      flags, saved_feedback_vector, CodeKind::INTERPRETED_FUNCTION,
+      &flags_need_processing);
 
   // Reload the feedback vector.
-  // TODO(jgruber): Don't clobber it above.
-  __ mov(feedback_vector,
-         FieldOperand(closure, JSFunction::kFeedbackCellOffset));
-  __ mov(feedback_vector,
-         FieldOperand(feedback_vector, FeedbackCell::kValueOffset));
+  __ movd(feedback_vector, saved_feedback_vector);
 
-  {
-    static constexpr Register scratch = eax;
-    ResetFeedbackVectorOsrUrgency(masm, feedback_vector, scratch);
-  }
+  ResetFeedbackVectorOsrUrgency(masm, feedback_vector, scratch);
 
   // Increment the invocation count.
   __ inc(FieldOperand(feedback_vector, FeedbackVector::kInvocationCountOffset));
@@ -942,13 +931,14 @@ void Builtins::Generate_InterpreterEntryTrampoline(
   // Open a frame scope to indicate that there is a frame on the stack.  The
   // MANUAL indicates that the scope shouldn't actually generate code to set
   // up the frame (that is done below).
-  __ bind(&push_stack_frame);
 #else
   // Note: By omitting the above code in jitless mode we also disable:
   // - kFlagsLogNextExecution: only used for logging/profiling; and
   // - kInvocationCountOffset: only used for tiering heuristics and code
   //   coverage.
 #endif  // !V8_JITLESS
+
+  __ bind(&push_stack_frame);
   FrameScope frame_scope(masm, StackFrame::MANUAL);
   __ push(ebp);  // Caller's frame pointer.
   __ mov(ebp, esp);
@@ -979,6 +969,7 @@ void Builtins::Generate_InterpreterEntryTrampoline(
   __ push(kInterpreterBytecodeArrayRegister);
   // Push Smi tagged initial bytecode array offset.
   __ push(Immediate(Smi::FromInt(BytecodeArray::kHeaderSize - kHeapObjectTag)));
+  __ push(feedback_vector);
 
   // Allocate the local and temporary register file on the stack.
   Label stack_overflow;
@@ -1809,6 +1800,8 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
 
     // Baseline code frames store the feedback vector where interpreter would
     // store the bytecode offset.
+    // TODO(victorgomes): The first push should actually be a free slot.
+    __ Push(saved_feedback_vector, scratch);
     __ Push(saved_feedback_vector, scratch);
   }
 
@@ -1877,6 +1870,8 @@ void Builtins::Generate_BaselineOutOfLinePrologueDeopt(MacroAssembler* masm) {
   // We're here because we got deopted during BaselineOutOfLinePrologue's stack
   // check. Undo all its frame creation and call into the interpreter instead.
 
+  // Drop the feedback vector.
+  __ Pop(ecx);
   // Drop bytecode offset (was the feedback vector but got replaced during
   // deopt).
   __ Pop(ecx);

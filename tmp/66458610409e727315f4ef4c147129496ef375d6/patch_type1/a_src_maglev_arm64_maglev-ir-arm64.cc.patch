diff --git a/src/maglev/arm64/maglev-ir-arm64.cc b/src/maglev/arm64/maglev-ir-arm64.cc
index de87b45e048..2604a1aeb43 100644
--- a/src/maglev/arm64/maglev-ir-arm64.cc
+++ b/src/maglev/arm64/maglev-ir-arm64.cc
@@ -1386,132 +1386,6 @@ void UnsafeFloat64Unbox::GenerateCode(MaglevAssembler* masm,
   TryUnboxTagged(masm, ToDoubleRegister(result()), value, nullptr);
 }
 
-int GeneratorStore::MaxCallStackArgs() const {
-  return WriteBarrierDescriptor::GetStackParameterCount();
-}
-void GeneratorStore::SetValueLocationConstraints() {
-  UseAny(context_input());
-  UseRegister(generator_input());
-  for (int i = 0; i < num_parameters_and_registers(); i++) {
-    UseAny(parameters_and_registers(i));
-  }
-  RequireSpecificTemporary(WriteBarrierDescriptor::ObjectRegister());
-  RequireSpecificTemporary(WriteBarrierDescriptor::SlotAddressRegister());
-}
-void GeneratorStore::GenerateCode(MaglevAssembler* masm,
-                                  const ProcessingState& state) {
-  Register generator = ToRegister(generator_input());
-  Register array = WriteBarrierDescriptor::ObjectRegister();
-  __ LoadTaggedField(
-      array, FieldMemOperand(generator,
-                             JSGeneratorObject::kParametersAndRegistersOffset));
-
-  for (int i = 0; i < num_parameters_and_registers(); i++) {
-    // Use WriteBarrierDescriptor::SlotAddressRegister() as the scratch
-    // register since it's a known temporary, and the write barrier slow path
-    // generates better code when value == scratch.
-    Input value_input = parameters_and_registers(i);
-    Register value = __ FromAnyToRegister(
-        value_input, WriteBarrierDescriptor::SlotAddressRegister());
-
-    ZoneLabelRef done(masm);
-    Label* deferred_write_barrier = __ MakeDeferredCode(
-        [](MaglevAssembler* masm, ZoneLabelRef done, ValueNode* value_node,
-           Register value, Register array, GeneratorStore* node,
-           int32_t offset) {
-          ASM_CODE_COMMENT_STRING(masm, "Write barrier slow path");
-          if (!value_node->decompresses_tagged_result()) {
-            __ DecompressTagged(value, value);
-          }
-          __ CheckPageFlag(
-              value, MemoryChunk::kPointersToHereAreInterestingMask, eq, *done);
-
-          Register slot_reg = WriteBarrierDescriptor::SlotAddressRegister();
-          __ Add(slot_reg, array, offset - kHeapObjectTag);
-
-          // TODO(leszeks): Add an interface for flushing all double registers
-          // before this Node, to avoid needing to save them here.
-          SaveFPRegsMode const save_fp_mode =
-              !node->register_snapshot().live_double_registers.is_empty()
-                  ? SaveFPRegsMode::kSave
-                  : SaveFPRegsMode::kIgnore;
-
-          __ CallRecordWriteStub(array, slot_reg, save_fp_mode);
-
-          __ B(*done);
-        },
-        done, value_input.node(), value, array, this,
-        FixedArray::OffsetOfElementAt(i));
-
-    __ StoreTaggedField(
-        value, FieldMemOperand(array, FixedArray::OffsetOfElementAt(i)));
-    __ JumpIfSmi(value, *done);
-    // TODO(leszeks): This will stay either false or true throughout this loop.
-    // Consider hoisting the check out of the loop and duplicating the loop into
-    // with and without write barrier.
-    __ CheckPageFlag(array, MemoryChunk::kPointersFromHereAreInterestingMask,
-                     ne, deferred_write_barrier);
-
-    __ Bind(*done);
-  }
-
-  // Use WriteBarrierDescriptor::SlotAddressRegister() as the scratch
-  // register, see comment above.
-  Register context = __ FromAnyToRegister(
-      context_input(), WriteBarrierDescriptor::SlotAddressRegister());
-
-  ZoneLabelRef done(masm);
-  Label* deferred_context_write_barrier = __ MakeDeferredCode(
-      [](MaglevAssembler* masm, ZoneLabelRef done, ValueNode* context_node,
-         Register context, Register generator, GeneratorStore* node) {
-        ASM_CODE_COMMENT_STRING(masm, "Write barrier slow path");
-        if (!context_node->decompresses_tagged_result()) {
-          __ DecompressTagged(context, context);
-        }
-        // TODO(leszeks): The context is almost always going to be in
-        // old-space, consider moving this check to the fast path, maybe even
-        // as the first bailout.
-        __ CheckPageFlag(
-            context, MemoryChunk::kPointersToHereAreInterestingMask, eq, *done);
-
-        __ Move(WriteBarrierDescriptor::ObjectRegister(), generator);
-        generator = WriteBarrierDescriptor::ObjectRegister();
-
-        Register slot_reg = WriteBarrierDescriptor::SlotAddressRegister();
-        __ Add(slot_reg, generator,
-               JSGeneratorObject::kContextOffset - kHeapObjectTag);
-
-        // TODO(leszeks): Add an interface for flushing all double registers
-        // before this Node, to avoid needing to save them here.
-        SaveFPRegsMode const save_fp_mode =
-            !node->register_snapshot().live_double_registers.is_empty()
-                ? SaveFPRegsMode::kSave
-                : SaveFPRegsMode::kIgnore;
-
-        __ CallRecordWriteStub(generator, slot_reg, save_fp_mode);
-
-        __ B(*done);
-      },
-      done, context_input().node(), context, generator, this);
-  __ StoreTaggedField(
-      context, FieldMemOperand(generator, JSGeneratorObject::kContextOffset));
-  __ AssertNotSmi(context);
-  __ CheckPageFlag(generator, MemoryChunk::kPointersFromHereAreInterestingMask,
-                   ne, deferred_context_write_barrier);
-  __ Bind(*done);
-
-  MaglevAssembler::ScratchRegisterScope temps(masm);
-  Register scratch = temps.Acquire();
-  __ Mov(scratch, Smi::FromInt(suspend_id()));
-  __ StoreTaggedField(
-      scratch,
-      FieldMemOperand(generator, JSGeneratorObject::kContinuationOffset));
-  __ Mov(scratch, Smi::FromInt(bytecode_offset()));
-  __ StoreTaggedField(
-      scratch,
-      FieldMemOperand(generator, JSGeneratorObject::kInputOrDebugPosOffset));
-}
-
 void IncreaseInterruptBudget::SetValueLocationConstraints() {
   set_temporaries_needed(1);
 }
@@ -1941,63 +1815,6 @@ void StoreDoubleField::GenerateCode(MaglevAssembler* masm,
   __ Move(FieldMemOperand(tmp, HeapNumber::kValueOffset), value);
 }
 
-int StoreMap::MaxCallStackArgs() const {
-  return WriteBarrierDescriptor::GetStackParameterCount();
-}
-void StoreMap::SetValueLocationConstraints() {
-  UseFixed(object_input(), WriteBarrierDescriptor::ObjectRegister());
-  set_temporaries_needed(1);
-}
-void StoreMap::GenerateCode(MaglevAssembler* masm,
-                            const ProcessingState& state) {
-  // TODO(leszeks): Consider making this an arbitrary register and push/popping
-  // in the deferred path.
-  Register object = WriteBarrierDescriptor::ObjectRegister();
-  DCHECK_EQ(object, ToRegister(object_input()));
-
-  __ AssertNotSmi(object);
-  // Since {value} will be passed to deferred code, we have to use a general
-  // temporary for it, rather than the regular scratch registers.
-  MaglevAssembler::ScratchRegisterScope temps(masm);
-  Register value = temps.Acquire();
-  __ Move(value, map_.object());
-  __ StoreTaggedField(value, FieldMemOperand(object, HeapObject::kMapOffset));
-
-  ZoneLabelRef done(masm);
-  Label* deferred_write_barrier = __ MakeDeferredCode(
-      [](MaglevAssembler* masm, ZoneLabelRef done, Register value,
-         Register object, StoreMap* node) {
-        ASM_CODE_COMMENT_STRING(masm, "Write barrier slow path");
-        __ CheckPageFlag(value, MemoryChunk::kPointersToHereAreInterestingMask,
-                         eq, *done);
-
-        Register slot_reg = WriteBarrierDescriptor::SlotAddressRegister();
-        RegList saved;
-        if (node->register_snapshot().live_registers.has(slot_reg)) {
-          saved.set(slot_reg);
-        }
-
-        __ PushAll(saved);
-        __ Add(slot_reg, object, HeapObject::kMapOffset - kHeapObjectTag);
-
-        SaveFPRegsMode const save_fp_mode =
-            !node->register_snapshot().live_double_registers.is_empty()
-                ? SaveFPRegsMode::kSave
-                : SaveFPRegsMode::kIgnore;
-
-        __ CallRecordWriteStub(object, slot_reg, save_fp_mode);
-
-        __ PopAll(saved);
-        __ B(*done);
-      },
-      done, value, object, this);
-
-  __ JumpIfSmi(value, *done);
-  __ CheckPageFlag(object, MemoryChunk::kPointersFromHereAreInterestingMask, ne,
-                   deferred_write_barrier);
-  __ Bind(*done);
-}
-
 void LoadSignedIntDataViewElement::SetValueLocationConstraints() {
   UseRegister(object_input());
   UseRegister(index_input());
@@ -2233,64 +2050,6 @@ void StoreDoubleDataViewElement::GenerateCode(MaglevAssembler* masm,
   }
 }
 
-int StoreTaggedFieldWithWriteBarrier::MaxCallStackArgs() const {
-  return WriteBarrierDescriptor::GetStackParameterCount();
-}
-void StoreTaggedFieldWithWriteBarrier::SetValueLocationConstraints() {
-  UseFixed(object_input(), WriteBarrierDescriptor::ObjectRegister());
-  UseRegister(value_input());
-}
-void StoreTaggedFieldWithWriteBarrier::GenerateCode(
-    MaglevAssembler* masm, const ProcessingState& state) {
-  // TODO(leszeks): Consider making this an arbitrary register and push/popping
-  // in the deferred path.
-  Register object = WriteBarrierDescriptor::ObjectRegister();
-  DCHECK_EQ(object, ToRegister(object_input()));
-
-  Register value = ToRegister(value_input());
-
-  __ AssertNotSmi(object);
-  __ StoreTaggedField(FieldMemOperand(object, offset()), value);
-
-  ZoneLabelRef done(masm);
-  Label* deferred_write_barrier = __ MakeDeferredCode(
-      [](MaglevAssembler* masm, ZoneLabelRef done, Register value,
-         Register object, StoreTaggedFieldWithWriteBarrier* node) {
-        ASM_CODE_COMMENT_STRING(masm, "Write barrier slow path");
-        if (!node->value_input().node()->decompresses_tagged_result()) {
-          __ DecompressTagged(value, value);
-        }
-        __ CheckPageFlag(value, MemoryChunk::kPointersToHereAreInterestingMask,
-                         eq, *done);
-
-        Register slot_reg = WriteBarrierDescriptor::SlotAddressRegister();
-        RegList saved;
-        if (node->register_snapshot().live_registers.has(slot_reg)) {
-          saved.set(slot_reg);
-        }
-
-        __ PushAll(saved);
-        __ Add(slot_reg, object, node->offset() - kHeapObjectTag);
-
-        SaveFPRegsMode const save_fp_mode =
-            !node->register_snapshot().live_double_registers.is_empty()
-                ? SaveFPRegsMode::kSave
-                : SaveFPRegsMode::kIgnore;
-
-        __ CallRecordWriteStub(object, slot_reg, save_fp_mode);
-
-        __ PopAll(saved);
-        __ B(*done);
-      },
-      done, value, object, this);
-
-  __ JumpIfSmi(value, *done);
-  __ CheckPageFlag(object, MemoryChunk::kPointersFromHereAreInterestingMask, ne,
-                   deferred_write_barrier);
-
-  __ Bind(*done);
-}
-
 void SetPendingMessage::SetValueLocationConstraints() {
   UseRegister(value());
   DefineAsRegister(this);

diff --git a/test/cctest/test-assembler-arm.cc b/test/cctest/test-assembler-arm.cc
index 475fe71e928..38fdbba447b 100644
--- a/test/cctest/test-assembler-arm.cc
+++ b/test/cctest/test-assembler-arm.cc
@@ -27,6 +27,7 @@
 
 #include <iostream>
 
+#include "src/base/numbers/double.h"
 #include "src/base/utils/random-number-generator.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
@@ -34,7 +35,6 @@
 #include "src/execution/simulator.h"
 #include "src/heap/factory.h"
 #include "src/init/v8.h"
-#include "src/numbers/double.h"
 #include "src/utils/ostreams.h"
 #include "test/cctest/assembler-helper-arm.h"
 #include "test/cctest/cctest.h"
@@ -266,16 +266,16 @@ TEST(4) {
     __ vstr(s1, r4, offsetof(T, y));
 
     // Move a literal into a register that can be encoded in the instruction.
-    __ vmov(d4, Double(1.0));
+    __ vmov(d4, base::Double(1.0));
     __ vstr(d4, r4, offsetof(T, e));
 
     // Move a literal into a register that requires 64 bits to encode.
     // 0x3FF0000010000000 = 1.000000059604644775390625
-    __ vmov(d4, Double(1.000000059604644775390625));
+    __ vmov(d4, base::Double(1.000000059604644775390625));
     __ vstr(d4, r4, offsetof(T, d));
 
     // Convert from floating point to integer.
-    __ vmov(d4, Double(2.0));
+    __ vmov(d4, base::Double(2.0));
     __ vcvt_s32_f64(s1, d4);
     __ vstr(s1, r4, offsetof(T, i));
 
@@ -447,7 +447,7 @@ static void TestRoundingMode(VCVTTypes types,
   __ vmsr(r2);
 
   // Load value, convert, and move back result to r0 if everything went well.
-  __ vmov(d1, Double(value));
+  __ vmov(d1, base::Double(value));
   switch (types) {
     case s32_f64:
       __ vcvt_s32_f64(s0, d1, kFPSCRRounding);
@@ -1074,8 +1074,8 @@ TEST(13) {
     __ vstm(ia_w, r4, d29, d31);
 
     // Move constants into d20, d21, d22 and store into i, j, k.
-    __ vmov(d20, Double(14.7610017472335499));
-    __ vmov(d21, Double(16.0));
+    __ vmov(d20, base::Double(14.7610017472335499));
+    __ vmov(d21, base::Double(16.0));
     __ mov(r1, Operand(372106121));
     __ mov(r2, Operand(1079146608));
     __ vmov(NeonS32, d22, 0, r1);
@@ -1364,12 +1364,12 @@ TEST(15) {
 
     // ARM core register to scalar.
     __ mov(r4, Operand(0xFFFFFFF8));
-    __ vmov(d0, Double(0.0));
+    __ vmov(d0, base::Double(0.0));
     __ vmov(NeonS8, d0, 1, r4);
     __ vmov(NeonS16, d0, 1, r4);
     __ vmov(NeonS32, d0, 1, r4);
     __ vstr(d0, r0, offsetof(T, vmov_to_scalar1));
-    __ vmov(d0, Double(0.0));
+    __ vmov(d0, base::Double(0.0));
     __ vmov(NeonS8, d0, 3, r4);
     __ vmov(NeonS16, d0, 3, r4);
     __ vstr(d0, r0, offsetof(T, vmov_to_scalar2));
@@ -3285,8 +3285,8 @@ TEST(ARMv8_vsel) {
     __ vsel(vc, s0, s1, s2);
     __ vstr(s0, r1, offsetof(ResultsF32, vselvc_));
 
-    __ vmov(d1, Double(kResultPass));
-    __ vmov(d2, Double(kResultFail));
+    __ vmov(d1, base::Double(kResultPass));
+    __ vmov(d2, base::Double(kResultFail));
 
     __ vsel(eq, d0, d1, d2);
     __ vstr(d0, r2, offsetof(ResultsF64, vseleq_));

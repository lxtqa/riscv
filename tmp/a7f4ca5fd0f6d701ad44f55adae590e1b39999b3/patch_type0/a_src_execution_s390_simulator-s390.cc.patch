diff --git a/src/execution/s390/simulator-s390.cc b/src/execution/s390/simulator-s390.cc
index 77b6dd22ba..aa331ec9d5 100644
--- a/src/execution/s390/simulator-s390.cc
+++ b/src/execution/s390/simulator-s390.cc
@@ -316,7 +316,7 @@ void S390Debugger::Debug() {
           } else if (strcmp(arg1, "allf") == 0) {
             for (int i = 0; i < DoubleRegister::kNumRegisters; i++) {
               float fvalue = GetFPFloatRegisterValue(i);
-              uint32_t as_words = bit_cast<uint32_t>(fvalue);
+              uint32_t as_words = base::bit_cast<uint32_t>(fvalue);
               PrintF("%3s: %f 0x%08x\n",
                      RegisterName(DoubleRegister::from_code(i)), fvalue,
                      as_words);
@@ -324,7 +324,7 @@ void S390Debugger::Debug() {
           } else if (strcmp(arg1, "alld") == 0) {
             for (int i = 0; i < DoubleRegister::kNumRegisters; i++) {
               dvalue = GetFPDoubleRegisterValue(i);
-              uint64_t as_words = bit_cast<uint64_t>(dvalue);
+              uint64_t as_words = base::bit_cast<uint64_t>(dvalue);
               PrintF("%3s: %f 0x%08x %08x\n",
                      RegisterName(DoubleRegister::from_code(i)), dvalue,
                      static_cast<uint32_t>(as_words >> 32),
@@ -347,7 +347,7 @@ void S390Debugger::Debug() {
               PrintF("%s: 0x%08" V8PRIxPTR " %" V8PRIdPTR "\n", arg1, value,
                      value);
             } else if (GetFPDoubleValue(arg1, &dvalue)) {
-              uint64_t as_words = bit_cast<uint64_t>(dvalue);
+              uint64_t as_words = base::bit_cast<uint64_t>(dvalue);
               PrintF("%s: %f 0x%08x %08x\n", arg1, dvalue,
                      static_cast<uint32_t>(as_words >> 32),
                      static_cast<uint32_t>(as_words & 0xFFFFFFFF));
@@ -2009,8 +2009,8 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
           (redirection->type() == ExternalReference::BUILTIN_FP_INT_CALL);
 
       // Place the return address on the stack, making the call GC safe.
-      *bit_cast<intptr_t*>(get_register(sp) +
-                           kStackFrameRASlot * kSystemPointerSize) =
+      *base::bit_cast<intptr_t*>(get_register(sp) +
+                                 kStackFrameRASlot * kSystemPointerSize) =
           get_register(r14);
 
       intptr_t external =
@@ -2147,7 +2147,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         SimulatorRuntimeDirectGetterCall target =
             reinterpret_cast<SimulatorRuntimeDirectGetterCall>(external);
         if (!ABI_PASSES_HANDLES_IN_REGS) {
-          arg[0] = bit_cast<intptr_t>(arg[0]);
+          arg[0] = base::bit_cast<intptr_t>(arg[0]);
         }
         target(arg[0], arg[1]);
       } else if (redirection->type() ==
@@ -2166,7 +2166,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         SimulatorRuntimeProfilingGetterCall target =
             reinterpret_cast<SimulatorRuntimeProfilingGetterCall>(external);
         if (!ABI_PASSES_HANDLES_IN_REGS) {
-          arg[0] = bit_cast<intptr_t>(arg[0]);
+          arg[0] = base::bit_cast<intptr_t>(arg[0]);
         }
         target(arg[0], arg[1], Redirection::ReverseRedirection(arg[2]));
       } else {
@@ -2294,7 +2294,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         //         }
         // #endif
       }
-      int64_t saved_lr = *bit_cast<intptr_t*>(
+      int64_t saved_lr = *base::bit_cast<intptr_t*>(
           get_register(sp) + kStackFrameRASlot * kSystemPointerSize);
 #if (!V8_TARGET_ARCH_S390X && V8_HOST_ARCH_S390)
       // On zLinux-31, the saved_lr might be tagged with a high bit of 1.
@@ -2511,7 +2511,7 @@ void Simulator::CallInternal(Address entry, int reg_arg_count) {
   // Prepare to execute the code at entry
   if (ABI_USES_FUNCTION_DESCRIPTORS) {
     // entry is the function descriptor
-    set_pc(*(bit_cast<intptr_t*>(entry)));
+    set_pc(*(base::bit_cast<intptr_t*>(entry)));
   } else {
     // entry is the instruction address
     set_pc(static_cast<intptr_t>(entry));
@@ -2633,7 +2633,7 @@ intptr_t Simulator::CallImpl(Address entry, int argument_count,
 // Prepare to execute the code at entry
 #if ABI_USES_FUNCTION_DESCRIPTORS
   // entry is the function descriptor
-  set_pc(*(bit_cast<intptr_t*>(entry)));
+  set_pc(*(base::bit_cast<intptr_t*>(entry)));
 #else
   // entry is the instruction address
   set_pc(static_cast<intptr_t>(entry));
@@ -3160,12 +3160,12 @@ EVALUATE(VLREP) {
   DCHECK_OPCODE(VLREP);
   DECODE_VRX_INSTRUCTION(r1, x2, b2, d2, m3);
   intptr_t addr = GET_ADDRESS(x2, b2, d2);
-#define CASE(i, type)                                                 \
-  case i: {                                                           \
-    FOR_EACH_LANE(j, type) {                                          \
-      set_simd_register_by_lane<type>(r1, j, *bit_cast<type*>(addr)); \
-    }                                                                 \
-    break;                                                            \
+#define CASE(i, type)                                                       \
+  case i: {                                                                 \
+    FOR_EACH_LANE(j, type) {                                                \
+      set_simd_register_by_lane<type>(r1, j, *base::bit_cast<type*>(addr)); \
+    }                                                                       \
+    break;                                                                  \
   }
   switch (m3) {
     CASE(0, uint8_t);
@@ -4030,7 +4030,8 @@ EVALUATE(VBPERM) {
   USE(m5);
   USE(m6);
   uint16_t result_bits = 0;
-  unsigned __int128 src_bits = bit_cast<__int128>(get_simd_register(r2).int8);
+  unsigned __int128 src_bits =
+      base::bit_cast<__int128>(get_simd_register(r2).int8);
   for (int i = 0; i < kSimd128Size; i++) {
     result_bits <<= 1;
     uint8_t selected_bit_index = get_simd_register_by_lane<uint8_t>(r3, i);
@@ -4055,11 +4056,14 @@ EVALUATE(VSEL) {
   DECODE_VRR_E_INSTRUCTION(r1, r2, r3, r4, m6, m5);
   USE(m5);
   USE(m6);
-  unsigned __int128 src_1 = bit_cast<__int128>(get_simd_register(r2).int8);
-  unsigned __int128 src_2 = bit_cast<__int128>(get_simd_register(r3).int8);
-  unsigned __int128 src_3 = bit_cast<__int128>(get_simd_register(r4).int8);
+  unsigned __int128 src_1 =
+      base::bit_cast<__int128>(get_simd_register(r2).int8);
+  unsigned __int128 src_2 =
+      base::bit_cast<__int128>(get_simd_register(r3).int8);
+  unsigned __int128 src_3 =
+      base::bit_cast<__int128>(get_simd_register(r4).int8);
   unsigned __int128 tmp = (src_1 & src_3) | (src_2 & ~src_3);
-  fpr_t* result = bit_cast<fpr_t*>(&tmp);
+  fpr_t* result = base::bit_cast<fpr_t*>(&tmp);
   set_simd_register(r1, *result);
   return length;
 }
@@ -5582,7 +5586,7 @@ EVALUATE(LD) {
   int64_t b2_val = (b2 == 0) ? 0 : get_register(b2);
   int64_t x2_val = (x2 == 0) ? 0 : get_register(x2);
   intptr_t addr = b2_val + x2_val + d2_val;
-  int64_t dbl_val = *bit_cast<int64_t*>(addr);
+  int64_t dbl_val = *base::bit_cast<int64_t*>(addr);
   set_fpr(r1, dbl_val);
   return length;
 }
@@ -5621,7 +5625,7 @@ EVALUATE(LE) {
   int64_t b2_val = (b2 == 0) ? 0 : get_register(b2);
   int64_t x2_val = (x2 == 0) ? 0 : get_register(x2);
   intptr_t addr = b2_val + x2_val + d2_val;
-  float float_val = *bit_cast<float*>(addr);
+  float float_val = *base::bit_cast<float*>(addr);
   set_fpr(r1, float_val);
   return length;
 }
@@ -7303,7 +7307,7 @@ EVALUATE(LTDBR) {
   DCHECK_OPCODE(LTDBR);
   DECODE_RRE_INSTRUCTION(r1, r2);
   int64_t r2_val = get_fpr<int64_t>(r2);
-  SetS390ConditionCode<double>(bit_cast<double, int64_t>(r2_val), 0.0);
+  SetS390ConditionCode<double>(base::bit_cast<double, int64_t>(r2_val), 0.0);
   set_fpr(r1, r2_val);
   return length;
 }
@@ -11302,7 +11306,7 @@ EVALUATE(LEY) {
   int64_t x2_val = (x2 == 0) ? 0 : get_register(x2);
   int64_t b2_val = (b2 == 0) ? 0 : get_register(b2);
   intptr_t addr = x2_val + b2_val + d2;
-  float float_val = *bit_cast<float*>(addr);
+  float float_val = *base::bit_cast<float*>(addr);
   set_fpr(r1, float_val);
   return length;
 }
@@ -11314,7 +11318,7 @@ EVALUATE(LDY) {
   int64_t x2_val = (x2 == 0) ? 0 : get_register(x2);
   int64_t b2_val = (b2 == 0) ? 0 : get_register(b2);
   intptr_t addr = x2_val + b2_val + d2;
-  uint64_t dbl_val = *bit_cast<uint64_t*>(addr);
+  uint64_t dbl_val = *base::bit_cast<uint64_t*>(addr);
   set_fpr(r1, dbl_val);
   return length;
 }

diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index 8837aea3ce8..738337eab7b 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -384,7 +384,7 @@ void MacroAssembler::DecompressTagged(Register destination,
 void MacroAssembler::RecordWriteField(Register object, int offset,
                                       Register value, Register slot_address,
                                       SaveFPRegsMode save_fp,
-                                      SmiCheck smi_check, SlotDescriptor slot) {
+                                      SmiCheck smi_check, PointerType type) {
   ASM_CODE_COMMENT(this);
   DCHECK(!AreAliased(object, value, slot_address));
   // First, check if a write barrier is even needed. The tests below
@@ -410,7 +410,7 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
     bind(&ok);
   }
 
-  RecordWrite(object, slot_address, value, save_fp, SmiCheck::kOmit, slot);
+  RecordWrite(object, slot_address, value, save_fp, SmiCheck::kOmit, type);
 
   bind(&done);
 
@@ -470,7 +470,6 @@ void MacroAssembler::LoadExternalPointerField(
   DCHECK(!field_operand.AddressUsesRegister(scratch));
   if (isolateRootLocation == IsolateRootLocation::kInRootRegister) {
     DCHECK(root_array_available_);
-    // TODO(saelo): consider using an ExternalReference here.
     movq(scratch,
          Operand(kRootRegister,
                  IsolateData::external_pointer_table_offset() +
@@ -495,32 +494,17 @@ void MacroAssembler::LoadExternalPointerField(
 
 void MacroAssembler::LoadIndirectPointerField(Register destination,
                                               Operand field_operand,
-                                              IndirectPointerTag tag,
                                               Register scratch) {
-#ifdef V8_CODE_POINTER_SANDBOXING
   DCHECK(!AreAliased(destination, scratch));
+#ifdef V8_CODE_POINTER_SANDBOXING
   DCHECK(!field_operand.AddressUsesRegister(scratch));
-
-  // Move the IndirectPointerHandle into destination
+  static_assert(kAllIndirectPointerObjectsAreCode);
+  LoadAddress(scratch, ExternalReference::code_pointer_table_address());
   movl(destination, field_operand);
-
-  if (tag == kCodeIndirectPointerTag) {
-    LoadAddress(scratch, ExternalReference::code_pointer_table_address());
-    shrl(destination, Immediate(kCodePointerHandleShift));
-    // The code pointer table entry size is 16 bytes, so we have to do an
-    // explicit shift first (times_16 doesn't exist).
-    shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
-    movq(destination, Operand(scratch, destination, times_1,
-                              kCodePointerTableEntryCodeObjectOffset));
-  } else {
-    CHECK(root_array_available_);
-    LoadAddress(scratch, ExternalReference::indirect_pointer_table_base_address(
-                             isolate()));
-    shrl(destination, Immediate(kIndirectPointerHandleShift));
-    static_assert(kIndirectPointerTableEntrySize == 8);
-    movq(destination, Operand(scratch, destination, times_8, 0));
-  }
-
+  shrl(destination, Immediate(kCodePointerHandleShift));
+  shll(destination, Immediate(kCodePointerTableEntrySizeLog2));
+  movq(destination, Operand(scratch, destination, times_1,
+                            kCodePointerTableEntryCodeObjectOffset));
   // The LSB is used as marking bit by the code pointer table, so here we have
   // to set it using a bitwise OR as it may or may not be set.
   orq(destination, Immediate(kHeapObjectTag));
@@ -585,39 +569,11 @@ void MacroAssembler::CallEphemeronKeyBarrier(Register object,
   PopAll(registers);
 }
 
-void MacroAssembler::CallIndirectPointerBarrier(Register object,
-                                                Register slot_address,
-                                                SaveFPRegsMode fp_mode,
-                                                IndirectPointerTag tag) {
-  ASM_CODE_COMMENT(this);
-  DCHECK(!AreAliased(object, slot_address));
-  // TODO(saelo) if necessary, we could introduce a "SaveRegisters version of
-  // this function and make this code not save clobbered registers. It's
-  // probably not currently worth the effort though since stores to indirect
-  // pointer fields are fairly rare.
-  RegList registers =
-      IndirectPointerWriteBarrierDescriptor::ComputeSavedRegisters(
-          object, slot_address);
-  PushAll(registers);
-
-  Register object_parameter =
-      IndirectPointerWriteBarrierDescriptor::ObjectRegister();
-  Register slot_address_parameter =
-      IndirectPointerWriteBarrierDescriptor::SlotAddressRegister();
-  MovePair(slot_address_parameter, slot_address, object_parameter, object);
-
-  Register tag_parameter =
-      IndirectPointerWriteBarrierDescriptor::IndirectPointerTagRegister();
-  Move(tag_parameter, tag);
-
-  CallBuiltin(Builtins::GetIndirectPointerBarrierStub(fp_mode));
-  PopAll(registers);
-}
-
 void MacroAssembler::CallRecordWriteStubSaveRegisters(Register object,
                                                       Register slot_address,
                                                       SaveFPRegsMode fp_mode,
-                                                      StubCallMode mode) {
+                                                      StubCallMode mode,
+                                                      PointerType type) {
   ASM_CODE_COMMENT(this);
   DCHECK(!AreAliased(object, slot_address));
   RegList registers =
@@ -628,13 +584,14 @@ void MacroAssembler::CallRecordWriteStubSaveRegisters(Register object,
       WriteBarrierDescriptor::SlotAddressRegister();
   MovePair(object_parameter, object, slot_address_parameter, slot_address);
 
-  CallRecordWriteStub(object_parameter, slot_address_parameter, fp_mode, mode);
+  CallRecordWriteStub(object_parameter, slot_address_parameter, fp_mode, mode,
+                      type);
   PopAll(registers);
 }
 
 void MacroAssembler::CallRecordWriteStub(Register object, Register slot_address,
                                          SaveFPRegsMode fp_mode,
-                                         StubCallMode mode) {
+                                         StubCallMode mode, PointerType type) {
   ASM_CODE_COMMENT(this);
   // Use CallRecordWriteStubSaveRegisters if the object and slot registers
   // need to be caller saved.
@@ -642,6 +599,7 @@ void MacroAssembler::CallRecordWriteStub(Register object, Register slot_address,
   DCHECK_EQ(WriteBarrierDescriptor::SlotAddressRegister(), slot_address);
 #if V8_ENABLE_WEBASSEMBLY
   if (mode == StubCallMode::kCallWasmRuntimeStub) {
+    DCHECK_EQ(type, PointerType::kDirect);
     // Use {near_call} for direct Wasm call within a module.
     intptr_t wasm_target =
         static_cast<intptr_t>(wasm::WasmCode::GetRecordWriteBuiltin(fp_mode));
@@ -650,7 +608,7 @@ void MacroAssembler::CallRecordWriteStub(Register object, Register slot_address,
   if (false) {
 #endif
   } else {
-    Builtin builtin = Builtins::GetRecordWriteStub(fp_mode);
+    Builtin builtin = Builtins::GetRecordWriteStub(fp_mode, type);
     CallBuiltin(builtin);
   }
 }
@@ -748,7 +706,7 @@ void MacroAssembler::CallTSANRelaxedLoadStub(Register address,
 
 void MacroAssembler::RecordWrite(Register object, Register slot_address,
                                  Register value, SaveFPRegsMode fp_mode,
-                                 SmiCheck smi_check, SlotDescriptor slot) {
+                                 SmiCheck smi_check, PointerType type) {
   ASM_CODE_COMMENT(this);
   DCHECK(!AreAliased(object, slot_address, value));
   AssertNotSmi(object);
@@ -760,13 +718,13 @@ void MacroAssembler::RecordWrite(Register object, Register slot_address,
   if (v8_flags.debug_code) {
     ASM_CODE_COMMENT_STRING(this, "Debug check slot_address");
     Label ok;
-    if (slot.contains_indirect_pointer()) {
+    if (type == PointerType::kIndirect) {
       Push(object);  // Use object register as scratch
       Register scratch = object;
       Push(slot_address);  // Use slot address register to load the value into
       Register value_in_slot = slot_address;
       LoadIndirectPointerField(value_in_slot, Operand(slot_address, 0),
-                               slot.indirect_pointer_tag(), scratch);
+                               scratch);
       cmp_tagged(value, value_in_slot);
       // These pops don't affect the flag registers, so we can do them before
       // the conditional jump below.
@@ -799,14 +757,8 @@ void MacroAssembler::RecordWrite(Register object, Register slot_address,
                 MemoryChunk::kPointersFromHereAreInterestingMask, zero, &done,
                 Label::kNear);
 
-  if (slot.contains_direct_pointer()) {
-    CallRecordWriteStub(object, slot_address, fp_mode,
-                        StubCallMode::kCallBuiltinPointer);
-  } else {
-    DCHECK(slot.contains_indirect_pointer());
-    CallIndirectPointerBarrier(object, slot_address, fp_mode,
-                               slot.indirect_pointer_tag());
-  }
+  CallRecordWriteStub(object, slot_address, fp_mode,
+                      StubCallMode::kCallBuiltinPointer, type);
 
   bind(&done);
 
@@ -1048,10 +1000,8 @@ void MacroAssembler::ReplaceClosureCodeWithOptimizedCode(
   Register value = scratch1;
   movq(value, optimized_code);
 
-  RecordWriteField(
-      closure, JSFunction::kCodeOffset, value, slot_address,
-      SaveFPRegsMode::kIgnore, SmiCheck::kOmit,
-      SlotDescriptor::ForMaybeIndirectPointerSlot(kCodeIndirectPointerTag));
+  RecordWriteField(closure, JSFunction::kCodeOffset, value, slot_address,
+                   SaveFPRegsMode::kIgnore, SmiCheck::kOmit, kCodePointerType);
 }
 
 // Read off the flags in the feedback vector and check if there

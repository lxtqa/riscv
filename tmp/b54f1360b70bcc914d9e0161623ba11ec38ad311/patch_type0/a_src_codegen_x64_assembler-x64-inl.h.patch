diff --git a/src/codegen/x64/assembler-x64-inl.h b/src/codegen/x64/assembler-x64-inl.h
index 851e9c2957..d170c2ea67 100644
--- a/src/codegen/x64/assembler-x64-inl.h
+++ b/src/codegen/x64/assembler-x64-inl.h
@@ -41,15 +41,7 @@ void Assembler::emit_runtime_entry(Address entry, RelocInfo::Mode rmode) {
   DCHECK_NE(options().code_range_start, 0);
   RecordRelocInfo(rmode);
   uint32_t offset = static_cast<uint32_t>(entry - options().code_range_start);
-  if (IsOnHeap()) {
-    saved_offsets_for_runtime_entries_.emplace_back(pc_offset(), offset);
-    emitl(relative_target_offset(entry, reinterpret_cast<Address>(pc_)));
-    // We must ensure that `emitl` is not growing the assembler buffer
-    // and falling back to off-heap compilation.
-    DCHECK(IsOnHeap());
-  } else {
-    emitl(offset);
-  }
+  emitl(offset);
 }
 
 void Assembler::emit(Immediate x) {
@@ -62,14 +54,6 @@ void Assembler::emit(Immediate x) {
 void Assembler::emit(Immediate64 x) {
   if (!RelocInfo::IsNone(x.rmode_)) {
     RecordRelocInfo(x.rmode_);
-    if (x.rmode_ == RelocInfo::FULL_EMBEDDED_OBJECT && IsOnHeap()) {
-      int offset = pc_offset();
-      Handle<HeapObject> object(reinterpret_cast<Address*>(x.value_));
-      saved_handles_for_raw_object_ptr_.emplace_back(offset, x.value_);
-      emitq(static_cast<uint64_t>(object->ptr()));
-      DCHECK(EmbeddedObjectMatches(offset, object));
-      return;
-    }
   }
   emitq(static_cast<uint64_t>(x.value_));
 }

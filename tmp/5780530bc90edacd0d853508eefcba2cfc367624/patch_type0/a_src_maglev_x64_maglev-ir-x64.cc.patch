diff --git a/src/maglev/x64/maglev-ir-x64.cc b/src/maglev/x64/maglev-ir-x64.cc
index 52cfa64d4fb..d4dbd039842 100644
--- a/src/maglev/x64/maglev-ir-x64.cc
+++ b/src/maglev/x64/maglev-ir-x64.cc
@@ -1661,6 +1661,28 @@ void Float64Negate::GenerateCode(MaglevAssembler* masm,
   __ Negpd(value, value, kScratchRegister);
 }
 
+void Float64Round::GenerateCode(MaglevAssembler* masm,
+                                const ProcessingState& state) {
+  DoubleRegister in = ToDoubleRegister(input());
+  DoubleRegister out = ToDoubleRegister(result());
+  MaglevAssembler::ScratchRegisterScope temps(masm);
+  DoubleRegister temp = temps.AcquireDouble();
+  __ Move(temp, in);
+  __ Roundsd(out, in, kRoundToNearest);
+  // RoundToNearest rounds to even on tie, while JS expects it to round towards
+  // +Infinity. Fix the difference by checking if we rounded down by exactly
+  // 0.5, and if so, round to the other side.
+  __ Subsd(temp, out);
+  __ Move(kScratchDoubleReg, 0.5);
+  Label done;
+  __ Ucomisd(temp, kScratchDoubleReg);
+  __ JumpIf(not_equal, &done, Label::kNear);
+  // Fix wrong tie-to-even by adding 0.5 twice.
+  __ Addsd(out, kScratchDoubleReg);
+  __ Addsd(out, kScratchDoubleReg);
+  __ bind(&done);
+}
+
 int Float64Exponentiate::MaxCallStackArgs() const {
   return MaglevAssembler::ArgumentStackSlotsForCFunctionCall(2);
 }
diff --git a/test/mjsunit/maglev/math-round.js b/test/mjsunit/maglev/math-round.js
new file mode 100644
index 00000000000..2e16fd9fa59

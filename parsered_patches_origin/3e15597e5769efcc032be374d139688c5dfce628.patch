From 3e15597e5769efcc032be374d139688c5dfce628 Mon Sep 17 00:00:00 2001
From: jingpeiyang <jingpeiyang@eswincomputing.com>
Date: Mon, 17 Apr 2023 17:14:27 +0800
Subject: [PATCH] [riscv]Add signaling NaN test for vfmv instruction

- Modified the simulator implementation of vfslide* and vfmv/vfmerge.
- The above instructions do not need to normalize NaN values, so the signaling NaN test is added.

Signed-off-by: jingpeiyang <jingpeiyang@eswincomputing.com>
Change-Id: Iab3431683bd0af639e91c17b3e78c3974ef9dda8
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4410610
Reviewed-by: Ji Qiu <qiuji@iscas.ac.cn>
Commit-Queue: Ji Qiu <qiuji@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#87130}
---
 src/execution/riscv/simulator-riscv.cc |  76 +++++++------
 test/cctest/test-assembler-riscv64.cc  | 145 ++++++++++++++++++-------
 2 files changed, 146 insertions(+), 75 deletions(-)

diff --git a/src/execution/riscv/simulator-riscv.cc b/src/execution/riscv/simulator-riscv.cc
index f35a512f9b..4831495dbf 100644
--- a/src/execution/riscv/simulator-riscv.cc
+++ b/src/execution/riscv/simulator-riscv.cc
@@ -304,21 +304,23 @@ struct type_sew_t<128> {
     vd = src;                                                                 \
   }
 
-#define VF_SLIDE1DOWN_PARAMS(x, offset, ftype)                         \
+#define VF_SLIDE1DOWN_PARAMS(x, offset)                                \
   auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);       \
   if ((i + offset) == rvv_vlmax()) {                                   \
-    ftype src = (ftype)get_fpu_register_##ftype(rs1_reg());            \
-    vd = base::bit_cast<type_sew_t<x>::type>(src);                     \
+    auto src = base::bit_cast<type_sew_t<x>::type>(                    \
+        get_fpu_register_Float##x(rs1_reg()).get_bits());              \
+    vd = src;                                                          \
   } else {                                                             \
     auto src = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i + offset); \
     vd = src;                                                          \
   }
 
-#define VF_SLIDE1UP_PARAMS(x, offset, ftype)                           \
+#define VF_SLIDE1UP_PARAMS(x, offset)                                  \
   auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);       \
   if (i == rvv_vstart() && i == 0) {                                   \
-    ftype src = (ftype)get_fpu_register_##ftype(rs1_reg());            \
-    vd = base::bit_cast<type_sew_t<x>::type>(src);                     \
+    auto src = base::bit_cast<type_sew_t<x>::type>(                    \
+        get_fpu_register_Float##x(rs1_reg()).get_bits());              \
+    vd = src;                                                          \
   } else {                                                             \
     auto src = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i - offset); \
     vd = src;                                                          \
@@ -836,31 +838,33 @@ struct type_sew_t<128> {
   set_rvv_vstart(0);             \
   }
 
-#define RVV_VI_VF_MERGE_LOOP(BODY16, BODY32, BODY64)      \
-  RVV_VI_VF_MERGE_LOOP_BASE                               \
-  switch (rvv_vsew()) {                                   \
-    case E16: {                                           \
-      UNIMPLEMENTED();                                    \
-    }                                                     \
-    case E32: {                                           \
-      float& vd = Rvvelt<float>(rvv_vd_reg(), i, true);   \
-      float fs1 = get_fpu_register_float(rs1_reg());      \
-      float vs2 = Rvvelt<float>(rvv_vs2_reg(), i);        \
-      BODY32;                                             \
-      break;                                              \
-    }                                                     \
-    case E64: {                                           \
-      double& vd = Rvvelt<double>(rvv_vd_reg(), i, true); \
-      double fs1 = get_fpu_register_double(rs1_reg());    \
-      double vs2 = Rvvelt<double>(rvv_vs2_reg(), i);      \
-      BODY64;                                             \
-      break;                                              \
-    }                                                     \
-    default:                                              \
-      UNREACHABLE();                                      \
-      break;                                              \
-  }                                                       \
-  RVV_VI_VF_MERGE_LOOP_END                                \
+#define RVV_VI_VF_MERGE_LOOP(BODY16, BODY32, BODY64)        \
+  RVV_VI_VF_MERGE_LOOP_BASE                                 \
+  switch (rvv_vsew()) {                                     \
+    case E16: {                                             \
+      UNIMPLEMENTED();                                      \
+    }                                                       \
+    case E32: {                                             \
+      int32_t& vd = Rvvelt<int32_t>(rvv_vd_reg(), i, true); \
+      int32_t fs1 = base::bit_cast<int32_t>(                \
+          get_fpu_register_Float32(rs1_reg()).get_bits());  \
+      int32_t vs2 = Rvvelt<int32_t>(rvv_vs2_reg(), i);      \
+      BODY32;                                               \
+      break;                                                \
+    }                                                       \
+    case E64: {                                             \
+      int64_t& vd = Rvvelt<int64_t>(rvv_vd_reg(), i, true); \
+      int64_t fs1 = base::bit_cast<int64_t>(                \
+          get_fpu_register_Float64(rs1_reg()).get_bits());  \
+      int64_t vs2 = Rvvelt<int64_t>(rvv_vs2_reg(), i);      \
+      BODY64;                                               \
+      break;                                                \
+    }                                                       \
+    default:                                                \
+      UNREACHABLE();                                        \
+      break;                                                \
+  }                                                         \
+  RVV_VI_VF_MERGE_LOOP_END                                  \
   rvv_trace_vd();
 
 #define RVV_VI_VFP_LOOP_BASE                           \
@@ -2510,7 +2514,7 @@ Float32 Simulator::get_fpu_register_Float32(int fpureg) const {
   DCHECK((fpureg >= 0) && (fpureg < kNumFPURegisters));
   if (!is_boxed_float(FPUregisters_[fpureg])) {
     std::cout << std::hex << FPUregisters_[fpureg] << std::endl;
-    return Float32::FromBits(0x7ffc0000);
+    return Float32::FromBits(0x7fc00000);
   }
   return Float32::FromBits(
       *base::bit_cast<uint32_t*>(const_cast<int64_t*>(&FPUregisters_[fpureg])));
@@ -7354,10 +7358,10 @@ void Simulator::DecodeRvvFVF() {
           UNSUPPORTED();
         }
         case E32: {
-          VF_SLIDE1DOWN_PARAMS(32, 1, float);
+          VF_SLIDE1DOWN_PARAMS(32, 1);
         } break;
         default: {
-          VF_SLIDE1DOWN_PARAMS(64, 1, double);
+          VF_SLIDE1DOWN_PARAMS(64, 1);
         } break;
       }
       RVV_VI_LOOP_END
@@ -7376,10 +7380,10 @@ void Simulator::DecodeRvvFVF() {
           UNSUPPORTED();
         }
         case E32: {
-          VF_SLIDE1UP_PARAMS(32, 1, float);
+          VF_SLIDE1UP_PARAMS(32, 1);
         } break;
         default: {
-          VF_SLIDE1UP_PARAMS(64, 1, double);
+          VF_SLIDE1UP_PARAMS(64, 1);
         } break;
       }
       RVV_VI_LOOP_END
diff --git a/test/cctest/test-assembler-riscv64.cc b/test/cctest/test-assembler-riscv64.cc
index b1e018e9a3..c9627faa9c 100644
--- a/test/cctest/test-assembler-riscv64.cc
+++ b/test/cctest/test-assembler-riscv64.cc
@@ -1214,7 +1214,7 @@ TEST(NAN_BOX) {
     CHECK_EQ((uint64_t)base::bit_cast<uint32_t>(1234.56f), res);
   }
 
-  // Test NaN boxing in FMV.S
+  // Test signaling NaN in FMV.S
   {
     auto fn = [](MacroAssembler& assm) {
       __ fmv_w_x(fa0, a0);
@@ -1225,7 +1225,7 @@ TEST(NAN_BOX) {
     CHECK_EQ((uint32_t)base::bit_cast<uint32_t>(0x7f400000), res);
   }
 
-  // Test NaN boxing in FMV.D
+  // Test signaling NaN in FMV.D
   {
     auto fn = [](MacroAssembler& assm) {
       __ fmv_d_x(fa0, a0);
@@ -2073,6 +2073,43 @@ TEST(RVV_VFMV) {
   }
 }
 
+TEST(RVV_VFMV_signaling_NaN) {
+  if (!CpuFeatures::IsSupported(RISCV_SIMD)) return;
+  CcTest::InitializeVM();
+
+  {
+    constexpr uint32_t n = 2;
+    int64_t rs1_fval = 0x7FF4000000000000;
+    int64_t dst[n] = {0};
+    auto fn = [](MacroAssembler& assm) {
+      __ VU.set(t0, VSew::E64, Vlmul::m1);
+      __ fmv_d_x(ft0, a0);
+      __ vfmv_vf(v1, ft0);
+      __ vs(v1, a1, 0, VSew::E64);
+    };
+    GenAndRunTest<int64_t, int64_t>((int64_t)rs1_fval, (int64_t)dst, fn);
+    for (uint32_t i = 0; i < n; i++) {
+      CHECK_EQ(rs1_fval, dst[i]);
+    }
+  }
+
+  {
+    constexpr uint32_t n = 4;
+    int32_t rs1_fval = 0x7F400000;
+    int32_t dst[n] = {0};
+    auto fn = [](MacroAssembler& assm) {
+      __ VU.set(t0, VSew::E32, Vlmul::m1);
+      __ fmv_w_x(ft0, a0);
+      __ vfmv_vf(v1, ft0);
+      __ vs(v1, a1, 0, VSew::E32);
+    };
+    GenAndRunTest<int64_t, int64_t>((int64_t)rs1_fval, (int64_t)dst, fn);
+    for (uint32_t i = 0; i < n; i++) {
+      CHECK_EQ(rs1_fval, dst[i]);
+    }
+  }
+}
+
 inline int32_t ToImm5(int32_t v) {
   int32_t smax = (int32_t)(INT64_MAX >> (64 - 5));
   int32_t smin = (int32_t)(INT64_MIN >> (64 - 5));
@@ -2780,40 +2817,54 @@ UTEST_RVV_VI_VIE_FORM_WITH_RES(vsext_vf2, int16_t, 16, 8, ARRAY(int8_t),
 
 #undef UTEST_RVV_VI_VIE_FORM_WITH_RES
 
+static constexpr double double_sNaN[] = {
+    std::numeric_limits<double>::signaling_NaN(),
+    -std::numeric_limits<double>::signaling_NaN()};
+static constexpr float float_sNaN[] = {
+    std::numeric_limits<float>::signaling_NaN(),
+    -std::numeric_limits<float>::signaling_NaN()};
 // Tests for vector Floating-Point merge instruction
-#define UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(type, int_type, width,     \
-                                              expect_res)                \
-  TEST(RISCV_UTEST_vfmerge_vf_##type) {                                  \
-    if (!CpuFeatures::IsSupported(RISCV_SIMD)) return;                   \
-    constexpr uint32_t n = kRvvVLEN / width;                             \
-    CcTest::InitializeVM();                                              \
-    for (type fval : compiler::ValueHelper::GetVector<type>()) {         \
-      int_type rs1_fval = base::bit_cast<int_type>(fval);                \
-      for (uint32_t mask = 0; mask < (1 << n); mask++) {                 \
-        int_type src[n] = {0};                                           \
-        int_type dst[n] = {0};                                           \
-        dst[0] = rs1_fval;                                               \
-        for (uint32_t i = 0; i < n; i++) src[i] = i;                     \
-        auto fn = [mask](MacroAssembler& assm) {                         \
-          __ VU.set(t0, VSew::E##width, Vlmul::m1);                      \
-          __ vl(v1, a0, 0, VSew::E##width);                              \
-          __ vl(v24, a1, 0, VSew::E##width);                             \
-          __ vmv_vi(v0, mask);                                           \
-          __ vfmv_fs(ft0, v24);                                          \
-          __ vfmerge_vf(v2, ft0, v1);                                    \
-          __ vs(v2, a1, 0, VSew::E##width);                              \
-        };                                                               \
-        GenAndRunTest<int64_t, int64_t>((int64_t)src, (int64_t)dst, fn); \
-        for (uint32_t i = 0; i < n; i++) {                               \
-          CHECK_EQ(expect_res, dst[i]);                                  \
-        }                                                                \
-      }                                                                  \
-    }                                                                    \
-  }
-
-UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(double, int64_t, 64,
+#define UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(                                 \
+    number /*prevent redefinition*/, type, int_type, width, array, expect_res) \
+  TEST(RISCV_UTEST_vfmerge_vf_##type##_##number) {                             \
+    if (!CpuFeatures::IsSupported(RISCV_SIMD)) return;                         \
+    constexpr uint32_t n = kRvvVLEN / width;                                   \
+    CcTest::InitializeVM();                                                    \
+    for (type fval : array) {                                                  \
+      int_type rs1_fval = base::bit_cast<int_type>(fval);                      \
+      for (uint32_t mask = 0; mask < (1 << n); mask++) {                       \
+        int_type src[n] = {0};                                                 \
+        int_type dst[n] = {0};                                                 \
+        dst[0] = rs1_fval;                                                     \
+        for (uint32_t i = 0; i < n; i++) src[i] = i;                           \
+        auto fn = [mask](MacroAssembler& assm) {                               \
+          __ VU.set(t0, VSew::E##width, Vlmul::m1);                            \
+          __ vl(v1, a0, 0, VSew::E##width);                                    \
+          __ vl(v24, a1, 0, VSew::E##width);                                   \
+          __ vmv_vi(v0, mask);                                                 \
+          __ vfmv_fs(ft0, v24);                                                \
+          __ vfmerge_vf(v2, ft0, v1);                                          \
+          __ vs(v2, a1, 0, VSew::E##width);                                    \
+        };                                                                     \
+        GenAndRunTest<int64_t, int64_t>((int64_t)src, (int64_t)dst, fn);       \
+        for (uint32_t i = 0; i < n; i++) {                                     \
+          CHECK_EQ(expect_res, dst[i]);                                        \
+        }                                                                      \
+      }                                                                        \
+    }                                                                          \
+  }
+
+UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(
+    1, double, int64_t, 64, compiler::ValueHelper::GetVector<double>(),
+    ((mask >> i) & 0x1) ? rs1_fval : src[i])
+UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(2, float, int32_t, 32,
+                                      compiler::ValueHelper::GetVector<float>(),
                                       ((mask >> i) & 0x1) ? rs1_fval : src[i])
-UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(float, int32_t, 32,
+UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(3, double, int64_t, 64,
+                                      base::ArrayVector(double_sNaN),
+                                      ((mask >> i) & 0x1) ? rs1_fval : src[i])
+UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES(4, float, int32_t, 32,
+                                      base::ArrayVector(float_sNaN),
                                       ((mask >> i) & 0x1) ? rs1_fval : src[i])
 #undef UTEST_RVV_VF_VFMERGE_VF_FORM_WITH_RES
 
@@ -3021,7 +3072,7 @@ UTEST_RVV_VP_VSLIDE1_VX_FORM_WITH_RES(vslide1up_vx, uint8_t, 8, ARRAY(uint8_t),
 
 #define UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(instr_name, type, width, fval, \
                                               array, expect_res)             \
-  TEST(RISCV_UTEST_##instr_name##_##width) {                                 \
+  TEST(RISCV_UTEST_##instr_name##_##width##_##fval) {                        \
     if (!CpuFeatures::IsSupported(RISCV_SIMD)) return;                       \
     constexpr uint32_t n = kRvvVLEN / width;                                 \
     CcTest::InitializeVM();                                                  \
@@ -3045,17 +3096,33 @@ UTEST_RVV_VP_VSLIDE1_VX_FORM_WITH_RES(vslide1up_vx, uint8_t, 8, ARRAY(uint8_t),
   }
 
 // Test for vfslide1down_vf
-UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1down_vf, int64_t, 64, 1234.56,
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1down_vf, int64_t, 64,
+                                      0x40934A3D70A3D70A /*1234.56*/,
                                       ARRAY(int64_t),
                                       (i + 1) < n ? src[i + 1] : src[0])
-UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1down_vf, int32_t, 32, 1234.56f,
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1down_vf, int32_t, 32,
+                                      0x449A51EC /*1234.56f*/, ARRAY(int32_t),
+                                      (i + 1) < n ? src[i + 1] : src[0])
+// Test for vfslide1down_vf_signaling_NaN
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1down_vf, int64_t, 64,
+                                      0x7FF4000000000000, ARRAY(int64_t),
+                                      (i + 1) < n ? src[i + 1] : src[0])
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1down_vf, int32_t, 32, 0x7F400000,
                                       ARRAY(int32_t),
                                       (i + 1) < n ? src[i + 1] : src[0])
 // Test for vfslide1up_vf
-UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1up_vf, int64_t, 64, 1234.56,
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1up_vf, int64_t, 64,
+                                      0x40934A3D70A3D70A /*1234.56*/,
                                       ARRAY(int64_t),
                                       (int64_t)i < 1 ? src[0] : src[i - 1])
-UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1up_vf, int32_t, 32, 1234.56f,
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1up_vf, int32_t, 32,
+                                      0x449A51EC /*1234.56f*/, ARRAY(int32_t),
+                                      (int32_t)i < 1 ? src[0] : src[i - 1])
+// Test for vfslide1up_vf_signaling_NaN
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1up_vf, int64_t, 64,
+                                      0x7FF4000000000000, ARRAY(int64_t),
+                                      (int64_t)i < 1 ? src[0] : src[i - 1])
+UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES(vfslide1up_vf, int32_t, 32, 0x7F400000,
                                       ARRAY(int32_t),
                                       (int32_t)i < 1 ? src[0] : src[i - 1])
 #undef UTEST_RVV_VP_VSLIDE1_VF_FORM_WITH_RES
-- 
2.35.1


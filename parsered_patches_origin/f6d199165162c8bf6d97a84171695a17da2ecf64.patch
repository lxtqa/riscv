From f6d199165162c8bf6d97a84171695a17da2ecf64 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Mon, 15 May 2023 21:36:35 +0800
Subject: [PATCH] [riscv] Implement probe mmu mode

There are three mmu modes in the riscv architecture sv39,sv48,sv57, which represent 39-bit, 48-bit and 57-bit virtual addresses respectively. When mmu mode is sv39 or sv48, riscv backend can use less instr to load a address. So we need to read cpuinfo to determine the current mmu mode.

Change-Id: I397b6914cea7115c1c46808c0f85f832fc1052d2
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4525059
Reviewed-by: Michael Lippautz <mlippautz@chromium.org>
Commit-Queue: Yahan Lu <yahan@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#87726}
---
 src/base/cpu.cc                      | 13 +++++++++
 src/base/cpu.h                       |  9 ++++++-
 src/codegen/riscv/assembler-riscv.cc | 40 +++++++++++++++++-----------
 3 files changed, 46 insertions(+), 16 deletions(-)

diff --git a/src/base/cpu.cc b/src/base/cpu.cc
index fdef3c6695..e63896bca5 100644
--- a/src/base/cpu.cc
+++ b/src/base/cpu.cc
@@ -410,6 +410,7 @@ CPU::CPU()
       has_non_stop_time_stamp_counter_(false),
       is_running_in_vm_(false),
       has_msa_(false),
+      riscv_mmu_(RV_MMU_MODE::kRiscvSV48),
       has_rvv_(false) {
   memcpy(vendor_, "Unknown", 8);
 
@@ -868,6 +869,7 @@ CPU::CPU()
 #endif  // !USE_SIMULATOR
 
 #elif V8_HOST_ARCH_RISCV64
+#if V8_OS_LINUX
   CPUInfo cpu_info;
   char* features = cpu_info.ExtractField("isa");
 
@@ -878,6 +880,17 @@ CPU::CPU()
     has_fpu_ = true;
     has_rvv_ = true;
   }
+  char* mmu = cpu_info.ExtractField("mmu");
+  if (HasListItem(mmu, "sv48")) {
+    riscv_mmu_ = RV_MMU_MODE::kRiscvSV48;
+  }
+  if (HasListItem(mmu, "sv39")) {
+    riscv_mmu_ = RV_MMU_MODE::kRiscvSV39;
+  }
+  if (HasListItem(mmu, "sv57")) {
+    riscv_mmu_ = RV_MMU_MODE::kRiscvSV57;
+  }
+#endif
 #endif  // V8_HOST_ARCH_RISCV64
 }
 
diff --git a/src/base/cpu.h b/src/base/cpu.h
index ff22712625..a1537faa75 100644
--- a/src/base/cpu.h
+++ b/src/base/cpu.h
@@ -130,8 +130,14 @@ class V8_BASE_EXPORT CPU final {
   bool is_fp64_mode() const { return is_fp64_mode_; }
   bool has_msa() const { return has_msa_; }
 
-  // riscv features
+  // riscv-specific part codes
   bool has_rvv() const { return has_rvv_; }
+  enum class RV_MMU_MODE {
+    kRiscvSV39,
+    kRiscvSV48,
+    kRiscvSV57,
+  };
+  RV_MMU_MODE riscv_mmu() const { return riscv_mmu_; }
 
  private:
 #if defined(V8_OS_STARBOARD)
@@ -184,6 +190,7 @@ class V8_BASE_EXPORT CPU final {
   bool has_non_stop_time_stamp_counter_;
   bool is_running_in_vm_;
   bool has_msa_;
+  RV_MMU_MODE riscv_mmu_;
   bool has_rvv_;
 };
 
diff --git a/src/codegen/riscv/assembler-riscv.cc b/src/codegen/riscv/assembler-riscv.cc
index 7e66b509dc..db5b12139e 100644
--- a/src/codegen/riscv/assembler-riscv.cc
+++ b/src/codegen/riscv/assembler-riscv.cc
@@ -72,6 +72,10 @@ void CpuFeatures::ProbeImpl(bool cross_compile) {
   base::CPU cpu;
   if (cpu.has_fpu()) supported_ |= 1u << FPU;
   if (cpu.has_rvv()) supported_ |= 1u << RISCV_SIMD;
+  if (cpu.riscv_mmu() == base::CPU::RV_MMU_MODE::kRiscvSV57) {
+    FATAL("SV57 is not supported");
+    UNIMPLEMENTED();
+  }
   // Set a static value on whether SIMD is supported.
   // This variable is only used for certain archs to query SupportWasmSimd128()
   // at runtime in builtins using an extern ref. Other callers should use
@@ -1061,21 +1065,27 @@ void Assembler::GeneralLi(Register rd, int64_t imm) {
 }
 
 void Assembler::li_ptr(Register rd, int64_t imm) {
-  // Initialize rd with an address
-  // Pointers are 48 bits
-  // 6 fixed instructions are generated
-  DCHECK_EQ((imm & 0xfff0000000000000ll), 0);
-  int64_t a6 = imm & 0x3f;                      // bits 0:5. 6 bits
-  int64_t b11 = (imm >> 6) & 0x7ff;             // bits 6:11. 11 bits
-  int64_t high_31 = (imm >> 17) & 0x7fffffff;   // 31 bits
-  int64_t high_20 = ((high_31 + 0x800) >> 12);  // 19 bits
-  int64_t low_12 = high_31 & 0xfff;             // 12 bits
-  lui(rd, (int32_t)high_20);
-  addi(rd, rd, low_12);  // 31 bits in rd.
-  slli(rd, rd, 11);      // Space for next 11 bis
-  ori(rd, rd, b11);      // 11 bits are put in. 42 bit in rd
-  slli(rd, rd, 6);       // Space for next 6 bits
-  ori(rd, rd, a6);       // 6 bits are put in. 48 bis in rd
+  base::CPU cpu;
+  if (cpu.riscv_mmu() != base::CPU::RV_MMU_MODE::kRiscvSV57) {
+    // Initialize rd with an address
+    // Pointers are 48 bits
+    // 6 fixed instructions are generated
+    DCHECK_EQ((imm & 0xfff0000000000000ll), 0);
+    int64_t a6 = imm & 0x3f;                      // bits 0:5. 6 bits
+    int64_t b11 = (imm >> 6) & 0x7ff;             // bits 6:11. 11 bits
+    int64_t high_31 = (imm >> 17) & 0x7fffffff;   // 31 bits
+    int64_t high_20 = ((high_31 + 0x800) >> 12);  // 19 bits
+    int64_t low_12 = high_31 & 0xfff;             // 12 bits
+    lui(rd, (int32_t)high_20);
+    addi(rd, rd, low_12);  // 31 bits in rd.
+    slli(rd, rd, 11);      // Space for next 11 bis
+    ori(rd, rd, b11);      // 11 bits are put in. 42 bit in rd
+    slli(rd, rd, 6);       // Space for next 6 bits
+    ori(rd, rd, a6);       // 6 bits are put in. 48 bis in rd
+  } else {
+    FATAL("SV57 is not supported");
+    UNIMPLEMENTED();
+  }
 }
 
 void Assembler::li_constant(Register rd, int64_t imm) {
-- 
2.35.1


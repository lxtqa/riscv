From 96ec62aa687717eda51c70e553ab9c2361c64764 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=A8=E6=96=87=E6=98=8E?= <yangwenming@bytedance.com>
Date: Thu, 2 Mar 2023 20:57:24 +0800
Subject: [PATCH] [wasm] support wasm-trace-memory for memory64.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

With this CL, tracing wasm memory64 is enabled.
Given that 32-bit machines actually do not support allocating memory
more than 4GB, message tests of memory64 are skipped on 32-bits
machines. Besides, tests added by this CL are relavant to SIMD, so
they are also skipped on no_simd_hardware.

Bug: v8:13782
Change-Id: Ib911cc07d8d4d6e81d5e1f01786ae42662bd35d4
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4297292
Auto-Submit: 杨文明 <yangwenming@bytedance.com>
Reviewed-by: Clemens Backes <clemensb@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#86212}
---
 src/wasm/baseline/liftoff-compiler.cc        |  24 +++-
 test/message/message.status                  |  12 ++
 test/message/wasm-trace-memory-liftoff.js    |   2 -
 test/message/wasm-trace-memory64-liftoff.js  |   7 ++
 test/message/wasm-trace-memory64-liftoff.out |  28 +++++
 test/message/wasm-trace-memory64.js          | 116 +++++++++++++++++++
 test/message/wasm-trace-memory64.out         |  28 +++++
 test/mjsunit/wasm/wasm-module-builder.js     |   1 +
 8 files changed, 210 insertions(+), 8 deletions(-)
 create mode 100644 test/message/wasm-trace-memory64-liftoff.js
 create mode 100644 test/message/wasm-trace-memory64-liftoff.out
 create mode 100644 test/message/wasm-trace-memory64.js
 create mode 100644 test/message/wasm-trace-memory64.out

diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index 34466b651d..782e03a546 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -3104,11 +3104,23 @@ class LiftoffCompiler {
     // Get one register for computing the effective offset (offset + index).
     LiftoffRegister effective_offset =
         pinned.set(__ GetUnusedRegister(kGpReg, pinned));
-    DCHECK_GE(kMaxUInt32, offset);
-    __ LoadConstant(effective_offset, WasmValue(static_cast<uint32_t>(offset)));
-    if (index != no_reg) {
-      // TODO(clemensb): Do a 64-bit addition here if memory64 is used.
-      __ emit_i32_add(effective_offset.gp(), effective_offset.gp(), index);
+    bool is_memory64 = env_->module->is_memory64;
+    if (is_memory64 && !kNeedI64RegPair) {
+      __ LoadConstant(effective_offset,
+                      WasmValue(static_cast<uint64_t>(offset)));
+      if (index != no_reg) {
+        __ emit_i64_add(effective_offset, effective_offset,
+                        LiftoffRegister(index));
+      }
+    } else {
+      // The offset is actually a 32-bits number when 'kNeedI64RegPair'
+      // is true, so we just do 32-bits operations on it under memory64.
+      DCHECK_GE(kMaxUInt32, offset);
+      __ LoadConstant(effective_offset,
+                      WasmValue(static_cast<uint32_t>(offset)));
+      if (index != no_reg) {
+        __ emit_i32_add(effective_offset.gp(), effective_offset.gp(), index);
+      }
     }
 
     // Get a register to hold the stack slot for MemoryTracingInfo.
@@ -3121,7 +3133,7 @@ class LiftoffCompiler {
     LiftoffRegister data = effective_offset;
 
     // Now store all information into the MemoryTracingInfo struct.
-    if (kSystemPointerSize == 8) {
+    if (kSystemPointerSize == 8 && !is_memory64) {
       // Zero-extend the effective offset to u64.
       CHECK(__ emit_type_conversion(kExprI64UConvertI32, data, effective_offset,
                                     nullptr));
diff --git a/test/message/message.status b/test/message/message.status
index 0d76cb9bcd..637bca760e 100644
--- a/test/message/message.status
+++ b/test/message/message.status
@@ -40,6 +40,7 @@
 # Skip Liftoff tests on platforms that don't support Liftoff.
 ['arch != x64 and arch != ia32 and arch != arm64 and arch != arm and arch != s390x', {
   'wasm-trace-memory-liftoff': [SKIP],
+  'wasm-trace-memory64-liftoff': [SKIP],
   'wasm-trace-liftoff': [SKIP],
 }], # arch != x64 and arch != ia32 and arch != arm64 and arch != arm and arch != s390x
 
@@ -79,12 +80,15 @@
 ['arch == mips64el or arch == riscv64 or arch == loong64', {
   # Tests that require Simd enabled.
   'wasm-trace-memory': [SKIP],
+  'wasm-trace-memory64': [SKIP],
 }], # arch == mips64el or arch == riscv64 or arch == loong64
 
 ##############################################################################
 ['no_simd_hardware == True', {
   'wasm-trace-memory': [SKIP],
   'wasm-trace-memory-liftoff': [SKIP],
+  'wasm-trace-memory64': [SKIP],
+  'wasm-trace-memory64-liftoff': [SKIP],
 }],  # no_simd_hardware == True
 
 ################################################################################
@@ -105,4 +109,12 @@
 ['arch == riscv32', {
   'wasm-trace-turbofan':[SKIP],
 }],  # (arch == riscv32)
+
+##############################################################################
+# 32-bit platforms
+['arch in (ia32, arm, riscv32)', {
+  # Needs >4GB of available contiguous memory.
+  'wasm-trace-memory64': [SKIP],
+  'wasm-trace-memory64-liftoff': [SKIP],
+}],  # 'arch in (ia32, arm, riscv32)'
 ]
diff --git a/test/message/wasm-trace-memory-liftoff.js b/test/message/wasm-trace-memory-liftoff.js
index bdad488e4c..248aad0149 100644
--- a/test/message/wasm-trace-memory-liftoff.js
+++ b/test/message/wasm-trace-memory-liftoff.js
@@ -4,6 +4,4 @@
 
 // Flags: --trace-wasm-memory --liftoff --no-wasm-tier-up
 
-// Force enable sse3 and sse4-1, since that will determine which execution tier
-// we use, and thus the expected output message will differ.
 d8.file.execute("test/message/wasm-trace-memory.js");
diff --git a/test/message/wasm-trace-memory64-liftoff.js b/test/message/wasm-trace-memory64-liftoff.js
new file mode 100644
index 0000000000..84bbc010eb
--- /dev/null
+++ b/test/message/wasm-trace-memory64-liftoff.js
@@ -0,0 +1,7 @@
+// Copyright 2023 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Flags: --trace-wasm-memory --liftoff --no-wasm-tier-up --experimental-wasm-memory64
+
+d8.file.execute("test/message/wasm-trace-memory64.js");
diff --git a/test/message/wasm-trace-memory64-liftoff.out b/test/message/wasm-trace-memory64-liftoff.out
new file mode 100644
index 0000000000..2cc0ff5ba4
--- /dev/null
+++ b/test/message/wasm-trace-memory64-liftoff.out
@@ -0,0 +1,28 @@
+liftoff     func:     0:0x151   load from 0000004294970004 val: i32:0 / 00000000
+liftoff     func:     1:0x15e   load from 0000004294970001 val:  i8:0 / 00
+liftoff     func:     3:0x17a    store to 0000004294970004 val: i32:305419896 / 12345678
+liftoff     func:     0:0x151   load from 0000004294970002 val: i32:1450704896 / 56780000
+liftoff     func:     1:0x15e   load from 0000004294970006 val:  i8:52 / 34
+liftoff     func:     2:0x16b   load from 0000004294970002 val: f32:68169720922112.000000 / 56780000
+liftoff     func:     4:0x188    store to 0000004294970004 val:  i8:171 / ab
+liftoff     func:     0:0x151   load from 0000004294970002 val: i32:1454047232 / 56ab0000
+liftoff     func:     2:0x16b   load from 0000004294970002 val: f32:94008244174848.000000 / 56ab0000
+liftoff     func:     6:0x1a6    store to 0000004294970004 val: s128:48879 48879 48879 48879 / 0000beef 0000beef 0000beef 0000beef
+liftoff     func:     5:0x194   load from 0000004294970002 val: s128:-1091633152 -1091633152 -1091633152 -1091633152 / beef0000 beef0000 beef0000 beef0000
+liftoff     func:     7:0x1b3   load from 0000004294970004 val: i16:48879 / beef
+liftoff     func:     8:0x1c0   load from 0000004294970002 val: i64:-4688528683866062848 / beef0000beef0000
+liftoff     func:     9:0x1cd   load from 0000004294970002 val: f64:-0.000015 / beef0000beef0000
+liftoff     func:    10:0x1da   load from 0000004294970004 val: i32:48879 / 0000beef
+liftoff     func:    11:0x1e3   load from 0000004294970001 val:  i8:0 / 00
+liftoff     func:    13:0x1f7    store to 0000004294970004 val: i32:305419896 / 12345678
+liftoff     func:    10:0x1da   load from 0000004294970002 val: i32:1450704896 / 56780000
+liftoff     func:    11:0x1e3   load from 0000004294970006 val:  i8:52 / 34
+liftoff     func:    12:0x1ec   load from 0000004294970002 val: f32:68169720922112.000000 / 56780000
+liftoff     func:    14:0x201    store to 0000004294970004 val:  i8:171 / ab
+liftoff     func:    10:0x1da   load from 0000004294970002 val: i32:1454047232 / 56ab0000
+liftoff     func:    12:0x1ec   load from 0000004294970002 val: f32:94008244174848.000000 / 56ab0000
+liftoff     func:    16:0x217    store to 0000004294970004 val: s128:48879 48879 48879 48879 / 0000beef 0000beef 0000beef 0000beef
+liftoff     func:    15:0x209   load from 0000004294970002 val: s128:-1091633152 -1091633152 -1091633152 -1091633152 / beef0000 beef0000 beef0000 beef0000
+liftoff     func:    17:0x220   load from 0000004294970004 val: i16:48879 / beef
+liftoff     func:    18:0x229   load from 0000004294970002 val: i64:-4688528683866062848 / beef0000beef0000
+liftoff     func:    19:0x232   load from 0000004294970002 val: f64:-0.000015 / beef0000beef0000
diff --git a/test/message/wasm-trace-memory64.js b/test/message/wasm-trace-memory64.js
new file mode 100644
index 0000000000..339ce112db
--- /dev/null
+++ b/test/message/wasm-trace-memory64.js
@@ -0,0 +1,116 @@
+// Copyright 2023 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Flags: --trace-wasm-memory --no-liftoff --experimental-wasm-memory64
+
+d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
+
+const GB = 1024 * 1024 * 1024;
+const BIG_OFFSET = 4294970000n; // 0x100000a90n
+const BIG_OFFSET_LEB = [0x90, 0x95, 0x80, 0x80, 0x10];
+
+var builder = new WasmModuleBuilder();
+builder.addMemory64(5 * GB / kPageSize);
+
+// Functions for testing big offsets.
+builder.addFunction('load', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, ...BIG_OFFSET_LEB, kExprDrop])
+    .exportFunc();
+builder.addFunction('load8', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI32LoadMem8U, 0, ...BIG_OFFSET_LEB, kExprDrop])
+    .exportFunc();
+builder.addFunction('loadf', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprF32LoadMem, 0, ...BIG_OFFSET_LEB, kExprDrop])
+    .exportFunc();
+builder.addFunction('store', kSig_v_li)
+    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0,  ...BIG_OFFSET_LEB])
+    .exportFunc();
+builder.addFunction('store8', kSig_v_li)
+    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem8, 0, ...BIG_OFFSET_LEB])
+    .exportFunc();
+builder.addFunction('load128', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kSimdPrefix, kExprS128LoadMem, 0, ...BIG_OFFSET_LEB, kExprDrop])
+    .exportFunc();
+// SIMD is not exposed to JS, so use splat to construct a s128 value.
+builder.addFunction('store128', kSig_v_li)
+    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kSimdPrefix, kExprI32x4Splat, kSimdPrefix, kExprS128StoreMem, 0, ...BIG_OFFSET_LEB])
+    .exportFunc();
+// We add functions after, rather than sorting in some order, so as to keep
+// the .out changes small (due to function index).
+builder.addFunction('load16', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI32LoadMem16U, 0, ...BIG_OFFSET_LEB, kExprDrop])
+    .exportFunc();
+builder.addFunction('load64', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI64LoadMem, 0, ...BIG_OFFSET_LEB, kExprDrop])
+    .exportFunc();
+builder.addFunction('loadf64', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprF64LoadMem, 0, ...BIG_OFFSET_LEB, kExprDrop])
+    .exportFunc();
+
+// Functions for testing big indexes.
+builder.addFunction('load_L', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0, kExprDrop])
+    .exportFunc();
+builder.addFunction('load8_L', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI32LoadMem8U, 0, 0, kExprDrop])
+    .exportFunc();
+builder.addFunction('loadf_L', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprF32LoadMem, 0, 0, kExprDrop])
+    .exportFunc();
+builder.addFunction('store_L', kSig_v_li)
+    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0,  0])
+    .exportFunc();
+builder.addFunction('store8_L', kSig_v_li)
+    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem8, 0, 0])
+    .exportFunc();
+builder.addFunction('load128_L', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kSimdPrefix, kExprS128LoadMem, 0, 0, kExprDrop])
+    .exportFunc();
+// SIMD is not exposed to JS, so use splat to construct a s128 value.
+builder.addFunction('store128_L', kSig_v_li)
+    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kSimdPrefix, kExprI32x4Splat, kSimdPrefix, kExprS128StoreMem, 0, 0])
+    .exportFunc();
+// We add functions after, rather than sorting in some order, so as to keep
+// the .out changes small (due to function index).
+builder.addFunction('load16_L', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI32LoadMem16U, 0, 0, kExprDrop])
+    .exportFunc();
+builder.addFunction('load64_L', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprI64LoadMem, 0, 0, kExprDrop])
+    .exportFunc();
+builder.addFunction('loadf64_L', kSig_v_l)
+    .addBody([kExprLocalGet, 0, kExprF64LoadMem, 0, 0, kExprDrop])
+    .exportFunc();
+
+var module = builder.instantiate();
+
+module.exports.load(4n)
+module.exports.load8(1n);
+module.exports.store(4n, 0x12345678);
+module.exports.load(2n);
+module.exports.load8(6n);
+module.exports.loadf(2n);
+module.exports.store8(4n, 0xab);
+module.exports.load(2n);
+module.exports.loadf(2n);
+module.exports.store128(4n, 0xbeef);
+module.exports.load128(2n);
+module.exports.load16(4n);
+module.exports.load64(2n);
+module.exports.loadf64(2n);
+
+module.exports.load_L(BIG_OFFSET + 4n)
+module.exports.load8_L(BIG_OFFSET + 1n);
+module.exports.store_L(BIG_OFFSET + 4n, 0x12345678);
+module.exports.load_L(BIG_OFFSET + 2n);
+module.exports.load8_L(BIG_OFFSET + 6n);
+module.exports.loadf_L(BIG_OFFSET + 2n);
+module.exports.store8_L(BIG_OFFSET + 4n, 0xab);
+module.exports.load_L(BIG_OFFSET + 2n);
+module.exports.loadf_L(BIG_OFFSET + 2n);
+module.exports.store128_L(BIG_OFFSET + 4n, 0xbeef);
+module.exports.load128_L(BIG_OFFSET + 2n);
+module.exports.load16_L(BIG_OFFSET + 4n);
+module.exports.load64_L(BIG_OFFSET + 2n);
+module.exports.loadf64_L(BIG_OFFSET + 2n);
diff --git a/test/message/wasm-trace-memory64.out b/test/message/wasm-trace-memory64.out
new file mode 100644
index 0000000000..8f6cf28223
--- /dev/null
+++ b/test/message/wasm-trace-memory64.out
@@ -0,0 +1,28 @@
+turbofan    func:     0:0x151   load from 0000004294970004 val: i32:0 / 00000000
+turbofan    func:     1:0x15e   load from 0000004294970001 val:  i8:0 / 00
+turbofan    func:     3:0x17a    store to 0000004294970004 val: i32:305419896 / 12345678
+turbofan    func:     0:0x151   load from 0000004294970002 val: i32:1450704896 / 56780000
+turbofan    func:     1:0x15e   load from 0000004294970006 val:  i8:52 / 34
+turbofan    func:     2:0x16b   load from 0000004294970002 val: f32:68169720922112.000000 / 56780000
+turbofan    func:     4:0x188    store to 0000004294970004 val:  i8:171 / ab
+turbofan    func:     0:0x151   load from 0000004294970002 val: i32:1454047232 / 56ab0000
+turbofan    func:     2:0x16b   load from 0000004294970002 val: f32:94008244174848.000000 / 56ab0000
+turbofan    func:     6:0x1a6    store to 0000004294970004 val: s128:48879 48879 48879 48879 / 0000beef 0000beef 0000beef 0000beef
+turbofan    func:     5:0x194   load from 0000004294970002 val: s128:-1091633152 -1091633152 -1091633152 -1091633152 / beef0000 beef0000 beef0000 beef0000
+turbofan    func:     7:0x1b3   load from 0000004294970004 val: i16:48879 / beef
+turbofan    func:     8:0x1c0   load from 0000004294970002 val: i64:-4688528683866062848 / beef0000beef0000
+turbofan    func:     9:0x1cd   load from 0000004294970002 val: f64:-0.000015 / beef0000beef0000
+turbofan    func:    10:0x1da   load from 0000004294970004 val: i32:48879 / 0000beef
+turbofan    func:    11:0x1e3   load from 0000004294970001 val:  i8:0 / 00
+turbofan    func:    13:0x1f7    store to 0000004294970004 val: i32:305419896 / 12345678
+turbofan    func:    10:0x1da   load from 0000004294970002 val: i32:1450704896 / 56780000
+turbofan    func:    11:0x1e3   load from 0000004294970006 val:  i8:52 / 34
+turbofan    func:    12:0x1ec   load from 0000004294970002 val: f32:68169720922112.000000 / 56780000
+turbofan    func:    14:0x201    store to 0000004294970004 val:  i8:171 / ab
+turbofan    func:    10:0x1da   load from 0000004294970002 val: i32:1454047232 / 56ab0000
+turbofan    func:    12:0x1ec   load from 0000004294970002 val: f32:94008244174848.000000 / 56ab0000
+turbofan    func:    16:0x217    store to 0000004294970004 val: s128:48879 48879 48879 48879 / 0000beef 0000beef 0000beef 0000beef
+turbofan    func:    15:0x209   load from 0000004294970002 val: s128:-1091633152 -1091633152 -1091633152 -1091633152 / beef0000 beef0000 beef0000 beef0000
+turbofan    func:    17:0x220   load from 0000004294970004 val: i16:48879 / beef
+turbofan    func:    18:0x229   load from 0000004294970002 val: i64:-4688528683866062848 / beef0000beef0000
+turbofan    func:    19:0x232   load from 0000004294970002 val: f64:-0.000015 / beef0000beef0000
diff --git a/test/mjsunit/wasm/wasm-module-builder.js b/test/mjsunit/wasm/wasm-module-builder.js
index 10f2803562..68758c0171 100644
--- a/test/mjsunit/wasm/wasm-module-builder.js
+++ b/test/mjsunit/wasm/wasm-module-builder.js
@@ -196,6 +196,7 @@ let kSig_v_i = makeSig([kWasmI32], []);
 let kSig_v_ii = makeSig([kWasmI32, kWasmI32], []);
 let kSig_v_iii = makeSig([kWasmI32, kWasmI32, kWasmI32], []);
 let kSig_v_l = makeSig([kWasmI64], []);
+let kSig_v_li = makeSig([kWasmI64, kWasmI32], []);
 let kSig_v_d = makeSig([kWasmF64], []);
 let kSig_v_dd = makeSig([kWasmF64, kWasmF64], []);
 let kSig_v_ddi = makeSig([kWasmF64, kWasmF64, kWasmI32], []);
-- 
2.35.1


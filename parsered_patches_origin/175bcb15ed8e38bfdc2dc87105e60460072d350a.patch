From 175bcb15ed8e38bfdc2dc87105e60460072d350a Mon Sep 17 00:00:00 2001
From: pthier <pthier@chromium.org>
Date: Wed, 12 Oct 2022 18:33:49 +0200
Subject: [PATCH] [regexp][cleanup] Rename CharacterClass to ClassRanges

... and ClassSet to ClassSetExpression to match the spec (changed with
the introduction of unicode sets).

Bug: v8:11935
Change-Id: I73b50de0a3436df7b2282c6168410ee2f7045978
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3929039
Reviewed-by: Jakob Linke <jgruber@chromium.org>
Commit-Queue: Patrick Thier <pthier@chromium.org>
Cr-Commit-Position: refs/heads/main@{#83662}
---
 src/objects/js-regexp.cc                      |  20 ++--
 src/regexp/arm/regexp-macro-assembler-arm.cc  |   4 +-
 src/regexp/arm/regexp-macro-assembler-arm.h   |   4 +-
 .../arm64/regexp-macro-assembler-arm64.cc     |   2 +-
 .../arm64/regexp-macro-assembler-arm64.h      |   4 +-
 .../experimental/experimental-compiler.cc     |  10 +-
 .../ia32/regexp-macro-assembler-ia32.cc       |   2 +-
 src/regexp/ia32/regexp-macro-assembler-ia32.h |   4 +-
 .../loong64/regexp-macro-assembler-loong64.cc |   2 +-
 .../loong64/regexp-macro-assembler-loong64.h  |   4 +-
 .../mips64/regexp-macro-assembler-mips64.cc   |   2 +-
 .../mips64/regexp-macro-assembler-mips64.h    |   4 +-
 src/regexp/ppc/regexp-macro-assembler-ppc.cc  |   4 +-
 src/regexp/ppc/regexp-macro-assembler-ppc.h   |   4 +-
 src/regexp/regexp-ast.cc                      |  13 +--
 src/regexp/regexp-ast.h                       |  49 ++++----
 src/regexp/regexp-compiler-tonode.cc          |  53 +++++----
 src/regexp/regexp-compiler.cc                 | 106 +++++++++---------
 src/regexp/regexp-dotprinter.cc               |   4 +-
 src/regexp/regexp-macro-assembler-tracer.cc   |   7 +-
 src/regexp/regexp-macro-assembler-tracer.h    |   4 +-
 src/regexp/regexp-macro-assembler.h           |   4 +-
 src/regexp/regexp-nodes.h                     |   5 +-
 src/regexp/regexp-parser.cc                   |  91 ++++++++-------
 .../riscv/regexp-macro-assembler-riscv.cc     |   2 +-
 .../riscv/regexp-macro-assembler-riscv.h      |   4 +-
 .../s390/regexp-macro-assembler-s390.cc       |   2 +-
 src/regexp/s390/regexp-macro-assembler-s390.h |   4 +-
 src/regexp/x64/regexp-macro-assembler-x64.cc  |   4 +-
 src/regexp/x64/regexp-macro-assembler-x64.h   |   4 +-
 30 files changed, 211 insertions(+), 215 deletions(-)

diff --git a/src/objects/js-regexp.cc b/src/objects/js-regexp.cc
index e76ee87b89..d90e88dc1e 100644
--- a/src/objects/js-regexp.cc
+++ b/src/objects/js-regexp.cc
@@ -258,7 +258,7 @@ int CountAdditionalEscapeChars(Handle<String> source, bool* needs_escapes_out) {
   DisallowGarbageCollection no_gc;
   int escapes = 0;
   bool needs_escapes = false;
-  bool in_char_class = false;
+  bool in_character_class = false;
   base::Vector<const Char> src = source->GetCharVector<Char>(no_gc);
   for (int i = 0; i < src.length(); i++) {
     const Char c = src[i];
@@ -270,14 +270,14 @@ int CountAdditionalEscapeChars(Handle<String> source, bool* needs_escapes_out) {
         // Escape. Skip next character, which will be copied verbatim;
         i++;
       }
-    } else if (c == '/' && !in_char_class) {
+    } else if (c == '/' && !in_character_class) {
       // Not escaped forward-slash needs escape.
       needs_escapes = true;
       escapes++;
     } else if (c == '[') {
-      in_char_class = true;
+      in_character_class = true;
     } else if (c == ']') {
-      in_char_class = false;
+      in_character_class = false;
     } else if (c == '\n') {
       needs_escapes = true;
       escapes++;
@@ -294,7 +294,7 @@ int CountAdditionalEscapeChars(Handle<String> source, bool* needs_escapes_out) {
       DCHECK(!IsLineTerminator(c));
     }
   }
-  DCHECK(!in_char_class);
+  DCHECK(!in_character_class);
   DCHECK_GE(escapes, 0);
   DCHECK_IMPLIES(escapes != 0, needs_escapes);
   *needs_escapes_out = needs_escapes;
@@ -315,7 +315,7 @@ Handle<StringType> WriteEscapedRegExpSource(Handle<String> source,
   base::Vector<Char> dst(result->GetChars(no_gc), result->length());
   int s = 0;
   int d = 0;
-  bool in_char_class = false;
+  bool in_character_class = false;
   while (s < src.length()) {
     const Char c = src[s];
     if (c == '\\') {
@@ -328,13 +328,13 @@ Handle<StringType> WriteEscapedRegExpSource(Handle<String> source,
         dst[d++] = src[s++];
       }
       if (s == src.length()) break;
-    } else if (c == '/' && !in_char_class) {
+    } else if (c == '/' && !in_character_class) {
       // Not escaped forward-slash needs escape.
       dst[d++] = '\\';
     } else if (c == '[') {
-      in_char_class = true;
+      in_character_class = true;
     } else if (c == ']') {
-      in_char_class = false;
+      in_character_class = false;
     } else if (c == '\n') {
       WriteStringToCharVector(dst, &d, "\\n");
       s++;
@@ -357,7 +357,7 @@ Handle<StringType> WriteEscapedRegExpSource(Handle<String> source,
     dst[d++] = src[s++];
   }
   DCHECK_EQ(result->length(), d);
-  DCHECK(!in_char_class);
+  DCHECK(!in_character_class);
   return result;
 }
 
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index 1988a1759d..2658068b6f 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -529,8 +529,8 @@ void RegExpMacroAssemblerARM::CheckBitInTable(
   BranchOrBacktrack(ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerARM::CheckSpecialCharacterClass(
-    StandardCharacterSet type, Label* on_no_match) {
+bool RegExpMacroAssemblerARM::CheckSpecialClassRanges(StandardCharacterSet type,
+                                                      Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
   // TODO(jgruber): No custom implementation (yet): s(UC16), S(UC16).
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.h b/src/regexp/arm/regexp-macro-assembler-arm.h
index ab550d5376..edf7650bd5 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.h
+++ b/src/regexp/arm/regexp-macro-assembler-arm.h
@@ -57,8 +57,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.cc b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
index ec7808d44e..2e462ba748 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.cc
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
@@ -640,7 +640,7 @@ void RegExpMacroAssemblerARM64::CheckBitInTable(
   CompareAndBranchOrBacktrack(w11, 0, ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerARM64::CheckSpecialCharacterClass(
+bool RegExpMacroAssemblerARM64::CheckSpecialClassRanges(
     StandardCharacterSet type, Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.h b/src/regexp/arm64/regexp-macro-assembler-arm64.h
index bda529c7a6..3801591b64 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.h
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.h
@@ -61,8 +61,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM64
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void BindJumpTarget(Label* label = nullptr) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
diff --git a/src/regexp/experimental/experimental-compiler.cc b/src/regexp/experimental/experimental-compiler.cc
index 7d87852c36..ce6e0c75ca 100644
--- a/src/regexp/experimental/experimental-compiler.cc
+++ b/src/regexp/experimental/experimental-compiler.cc
@@ -65,11 +65,12 @@ class CanBeHandledVisitor final : private RegExpVisitor {
     return nullptr;
   }
 
-  void* VisitCharacterClass(RegExpCharacterClass* node, void*) override {
+  void* VisitClassRanges(RegExpClassRanges* node, void*) override {
     return nullptr;
   }
 
-  void* VisitClassSet(RegExpClassSet* node, void*) override {
+  void* VisitClassSetExpression(RegExpClassSetExpression* node,
+                                void*) override {
     result_ = false;
     return nullptr;
   }
@@ -390,7 +391,7 @@ class CompileVisitor : private RegExpVisitor {
     return nullptr;
   }
 
-  void* VisitCharacterClass(RegExpCharacterClass* node, void*) override {
+  void* VisitClassRanges(RegExpClassRanges* node, void*) override {
     // A character class is compiled as Disjunction over its `CharacterRange`s.
     ZoneList<CharacterRange>* ranges = node->ranges(zone_);
     CharacterRange::Canonicalize(ranges);
@@ -424,7 +425,8 @@ class CompileVisitor : private RegExpVisitor {
     return nullptr;
   }
 
-  void* VisitClassSet(RegExpClassSet* node, void*) override {
+  void* VisitClassSetExpression(RegExpClassSetExpression* node,
+                                void*) override {
     // TODO(v8:11935): Add support.
     UNREACHABLE();
   }
diff --git a/src/regexp/ia32/regexp-macro-assembler-ia32.cc b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
index 093931fa9d..6002345420 100644
--- a/src/regexp/ia32/regexp-macro-assembler-ia32.cc
+++ b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
@@ -567,7 +567,7 @@ void RegExpMacroAssemblerIA32::CheckBitInTable(
   BranchOrBacktrack(not_equal, on_bit_set);
 }
 
-bool RegExpMacroAssemblerIA32::CheckSpecialCharacterClass(
+bool RegExpMacroAssemblerIA32::CheckSpecialClassRanges(
     StandardCharacterSet type, Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
diff --git a/src/regexp/ia32/regexp-macro-assembler-ia32.h b/src/regexp/ia32/regexp-macro-assembler-ia32.h
index 3933a68b1f..96d3163429 100644
--- a/src/regexp/ia32/regexp-macro-assembler-ia32.h
+++ b/src/regexp/ia32/regexp-macro-assembler-ia32.h
@@ -58,8 +58,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerIA32
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/loong64/regexp-macro-assembler-loong64.cc b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
index a55ea6557a..35fd95bd0f 100644
--- a/src/regexp/loong64/regexp-macro-assembler-loong64.cc
+++ b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
@@ -496,7 +496,7 @@ void RegExpMacroAssemblerLOONG64::CheckBitInTable(Handle<ByteArray> table,
   BranchOrBacktrack(on_bit_set, ne, a0, Operand(zero_reg));
 }
 
-bool RegExpMacroAssemblerLOONG64::CheckSpecialCharacterClass(
+bool RegExpMacroAssemblerLOONG64::CheckSpecialClassRanges(
     StandardCharacterSet type, Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check.
diff --git a/src/regexp/loong64/regexp-macro-assembler-loong64.h b/src/regexp/loong64/regexp-macro-assembler-loong64.h
index a141936613..fe40a4e74f 100644
--- a/src/regexp/loong64/regexp-macro-assembler-loong64.h
+++ b/src/regexp/loong64/regexp-macro-assembler-loong64.h
@@ -56,8 +56,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerLOONG64
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.cc b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
index 598083dcbb..456e166ade 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.cc
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
@@ -545,7 +545,7 @@ void RegExpMacroAssemblerMIPS::CheckBitInTable(
   BranchOrBacktrack(on_bit_set, ne, a0, Operand(zero_reg));
 }
 
-bool RegExpMacroAssemblerMIPS::CheckSpecialCharacterClass(
+bool RegExpMacroAssemblerMIPS::CheckSpecialClassRanges(
     StandardCharacterSet type, Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check.
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.h b/src/regexp/mips64/regexp-macro-assembler-mips64.h
index 9b8c7c26d8..449084b0da 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.h
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.h
@@ -56,8 +56,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerMIPS
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index 483c4f395a..4fdad87894 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -562,8 +562,8 @@ void RegExpMacroAssemblerPPC::CheckBitInTable(Handle<ByteArray> table,
   BranchOrBacktrack(ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerPPC::CheckSpecialCharacterClass(
-    StandardCharacterSet type, Label* on_no_match) {
+bool RegExpMacroAssemblerPPC::CheckSpecialClassRanges(StandardCharacterSet type,
+                                                      Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
   // TODO(jgruber): No custom implementation (yet): s(UC16), S(UC16).
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.h b/src/regexp/ppc/regexp-macro-assembler-ppc.h
index 5760809d96..db2783ff72 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.h
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.h
@@ -57,8 +57,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerPPC
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/regexp-ast.cc b/src/regexp/regexp-ast.cc
index 992c5498b6..ef0f153c68 100644
--- a/src/regexp/regexp-ast.cc
+++ b/src/regexp/regexp-ast.cc
@@ -182,9 +182,7 @@ void RegExpUnparser::VisitCharacterRange(CharacterRange that) {
   }
 }
 
-
-void* RegExpUnparser::VisitCharacterClass(RegExpCharacterClass* that,
-                                          void* data) {
+void* RegExpUnparser::VisitClassRanges(RegExpClassRanges* that, void* data) {
   if (that->is_negated()) os_ << "^";
   os_ << "[";
   for (int i = 0; i < that->ranges(zone_)->length(); i++) {
@@ -195,15 +193,16 @@ void* RegExpUnparser::VisitCharacterClass(RegExpCharacterClass* that,
   return nullptr;
 }
 
-void* RegExpUnparser::VisitClassSet(RegExpClassSet* that, void* data) {
+void* RegExpUnparser::VisitClassSetExpression(RegExpClassSetExpression* that,
+                                              void* data) {
   switch (that->operation()) {
-    case RegExpClassSet::OperationType::kUnion:
+    case RegExpClassSetExpression::OperationType::kUnion:
       os_ << "++";
       break;
-    case RegExpClassSet::OperationType::kIntersection:
+    case RegExpClassSetExpression::OperationType::kIntersection:
       os_ << "&&";
       break;
-    case RegExpClassSet::OperationType::kSubtraction:
+    case RegExpClassSetExpression::OperationType::kSubtraction:
       os_ << "--";
       break;
   }
diff --git a/src/regexp/regexp-ast.h b/src/regexp/regexp-ast.h
index c7fee53dcd..718ecb2b50 100644
--- a/src/regexp/regexp-ast.h
+++ b/src/regexp/regexp-ast.h
@@ -18,8 +18,8 @@ namespace internal {
   VISIT(Disjunction)                      \
   VISIT(Alternative)                      \
   VISIT(Assertion)                        \
-  VISIT(CharacterClass)                   \
-  VISIT(ClassSet)                         \
+  VISIT(ClassRanges)                      \
+  VISIT(ClassSetExpression)               \
   VISIT(Atom)                             \
   VISIT(Quantifier)                       \
   VISIT(Capture)                          \
@@ -299,7 +299,7 @@ class CharacterSet final {
   base::Optional<StandardCharacterSet> standard_set_type_;
 };
 
-class RegExpCharacterClass final : public RegExpTree {
+class RegExpClassRanges final : public RegExpTree {
  public:
   // NEGATED: The character class is negated and should match everything but
   //     the specified ranges.
@@ -309,22 +309,21 @@ class RegExpCharacterClass final : public RegExpTree {
     NEGATED = 1 << 0,
     CONTAINS_SPLIT_SURROGATE = 1 << 1,
   };
-  using CharacterClassFlags = base::Flags<Flag>;
+  using ClassRangesFlags = base::Flags<Flag>;
 
-  RegExpCharacterClass(
-      Zone* zone, ZoneList<CharacterRange>* ranges,
-      CharacterClassFlags character_class_flags = CharacterClassFlags())
-      : set_(ranges), character_class_flags_(character_class_flags) {
+  RegExpClassRanges(Zone* zone, ZoneList<CharacterRange>* ranges,
+                    ClassRangesFlags class_ranges_flags = ClassRangesFlags())
+      : set_(ranges), class_ranges_flags_(class_ranges_flags) {
     // Convert the empty set of ranges to the negated Everything() range.
     if (ranges->is_empty()) {
       ranges->Add(CharacterRange::Everything(), zone);
-      character_class_flags_ ^= NEGATED;
+      class_ranges_flags_ ^= NEGATED;
     }
   }
-  explicit RegExpCharacterClass(StandardCharacterSet standard_set_type)
-      : set_(standard_set_type), character_class_flags_() {}
+  explicit RegExpClassRanges(StandardCharacterSet standard_set_type)
+      : set_(standard_set_type), class_ranges_flags_() {}
 
-  DECL_BOILERPLATE(CharacterClass);
+  DECL_BOILERPLATE(ClassRanges);
 
   bool IsTextElement() override { return true; }
   int min_match() override { return 1; }
@@ -347,25 +346,25 @@ class RegExpCharacterClass final : public RegExpTree {
   CharacterSet character_set() const { return set_; }
   ZoneList<CharacterRange>* ranges(Zone* zone) { return set_.ranges(zone); }
 
-  bool is_negated() const { return (character_class_flags_ & NEGATED) != 0; }
+  bool is_negated() const { return (class_ranges_flags_ & NEGATED) != 0; }
   bool contains_split_surrogate() const {
-    return (character_class_flags_ & CONTAINS_SPLIT_SURROGATE) != 0;
+    return (class_ranges_flags_ & CONTAINS_SPLIT_SURROGATE) != 0;
   }
 
  private:
   CharacterSet set_;
-  CharacterClassFlags character_class_flags_;
+  ClassRangesFlags class_ranges_flags_;
 };
 
-class RegExpClassSet final : public RegExpTree {
+class RegExpClassSetExpression final : public RegExpTree {
  public:
   enum class OperationType { kUnion, kIntersection, kSubtraction };
 
-  RegExpClassSet(OperationType op, bool is_negated,
-                 ZoneList<RegExpTree*>* operands)
+  RegExpClassSetExpression(OperationType op, bool is_negated,
+                           ZoneList<RegExpTree*>* operands)
       : operation_(op), is_negated_(is_negated), operands_(operands) {}
 
-  DECL_BOILERPLATE(ClassSet);
+  DECL_BOILERPLATE(ClassSetExpression);
 
   bool IsTextElement() override { return true; }
   // At least 1 character is consumed.
@@ -378,7 +377,7 @@ class RegExpClassSet final : public RegExpTree {
   const ZoneList<RegExpTree*>* operands() const { return operands_; }
 
  private:
-  RegExpCharacterClass* ToCharacterClass(Zone* zone);
+  RegExpClassRanges* ToCharacterClass(Zone* zone);
 
   // Recursively evaluates the tree rooted at |root|, computing the valid
   // CharacterRanges after applying all set operations and storing the result in
@@ -418,10 +417,10 @@ class RegExpAtom final : public RegExpTree {
 
 class TextElement final {
  public:
-  enum TextType { ATOM, CHAR_CLASS };
+  enum TextType { ATOM, CLASS_RANGES };
 
   static TextElement Atom(RegExpAtom* atom);
-  static TextElement CharClass(RegExpCharacterClass* char_class);
+  static TextElement ClassRanges(RegExpClassRanges* class_ranges);
 
   int cp_offset() const { return cp_offset_; }
   void set_cp_offset(int cp_offset) { cp_offset_ = cp_offset; }
@@ -436,9 +435,9 @@ class TextElement final {
     return reinterpret_cast<RegExpAtom*>(tree());
   }
 
-  RegExpCharacterClass* char_class() const {
-    DCHECK(text_type() == CHAR_CLASS);
-    return reinterpret_cast<RegExpCharacterClass*>(tree());
+  RegExpClassRanges* class_ranges() const {
+    DCHECK(text_type() == CLASS_RANGES);
+    return reinterpret_cast<RegExpClassRanges*>(tree());
   }
 
  private:
diff --git a/src/regexp/regexp-compiler-tonode.cc b/src/regexp/regexp-compiler-tonode.cc
index 1873f182f6..22f53831cd 100644
--- a/src/regexp/regexp-compiler-tonode.cc
+++ b/src/regexp/regexp-compiler-tonode.cc
@@ -93,7 +93,7 @@ bool CompareRanges(ZoneList<CharacterRange>* ranges, const int* special_class,
 
 }  // namespace
 
-bool RegExpCharacterClass::is_standard(Zone* zone) {
+bool RegExpClassRanges::is_standard(Zone* zone) {
   // TODO(lrn): Remove need for this function, by not throwing away information
   // along the way.
   if (is_negated()) {
@@ -465,8 +465,8 @@ void CharacterRange::AddUnicodeCaseEquivalents(ZoneList<CharacterRange>* ranges,
 #endif  // V8_INTL_SUPPORT
 }
 
-RegExpNode* RegExpCharacterClass::ToNode(RegExpCompiler* compiler,
-                                         RegExpNode* on_success) {
+RegExpNode* RegExpClassRanges::ToNode(RegExpCompiler* compiler,
+                                      RegExpNode* on_success) {
   set_.Canonicalize();
   Zone* const zone = compiler->zone();
   ZoneList<CharacterRange>* ranges = this->ranges(zone);
@@ -500,7 +500,7 @@ RegExpNode* RegExpCharacterClass::ToNode(RegExpCompiler* compiler,
 
   if (ranges->length() == 0) {
     // The empty character class is used as a 'fail' node.
-    RegExpCharacterClass* fail = zone->New<RegExpCharacterClass>(zone, ranges);
+    RegExpClassRanges* fail = zone->New<RegExpClassRanges>(zone, ranges);
     return zone->New<TextNode>(fail, compiler->read_backward(), on_success);
   }
 
@@ -527,8 +527,8 @@ RegExpNode* RegExpCharacterClass::ToNode(RegExpCompiler* compiler,
   return result;
 }
 
-RegExpNode* RegExpClassSet::ToNode(RegExpCompiler* compiler,
-                                   RegExpNode* on_success) {
+RegExpNode* RegExpClassSetExpression::ToNode(RegExpCompiler* compiler,
+                                             RegExpNode* on_success) {
   return ToCharacterClass(compiler->zone())->ToNode(compiler, on_success);
 }
 
@@ -826,12 +826,12 @@ void RegExpDisjunction::FixSingleCharacterDisjunctions(
         DCHECK_EQ(old_atom->length(), 1);
         ranges->Add(CharacterRange::Singleton(old_atom->data().at(0)), zone);
       }
-      RegExpCharacterClass::CharacterClassFlags character_class_flags;
+      RegExpClassRanges::ClassRangesFlags class_ranges_flags;
       if (IsEitherUnicode(flags) && contains_trail_surrogate) {
-        character_class_flags = RegExpCharacterClass::CONTAINS_SPLIT_SURROGATE;
+        class_ranges_flags = RegExpClassRanges::CONTAINS_SPLIT_SURROGATE;
       }
       alternatives->at(write_posn++) =
-          zone->New<RegExpCharacterClass>(zone, ranges, character_class_flags);
+          zone->New<RegExpClassRanges>(zone, ranges, class_ranges_flags);
     } else {
       // Just copy any trivial alternatives.
       for (int j = first_in_run; j < i; j++) {
@@ -949,8 +949,8 @@ RegExpNode* RegExpAssertion::ToNode(RegExpCompiler* compiler,
           zone->New<ZoneList<CharacterRange>>(3, zone);
       CharacterRange::AddClassEscape(StandardCharacterSet::kLineTerminator,
                                      newline_ranges, false, zone);
-      RegExpCharacterClass* newline_atom = zone->New<RegExpCharacterClass>(
-          StandardCharacterSet::kLineTerminator);
+      RegExpClassRanges* newline_atom =
+          zone->New<RegExpClassRanges>(StandardCharacterSet::kLineTerminator);
       TextNode* newline_matcher =
           zone->New<TextNode>(newline_atom, false,
                               ActionNode::PositiveSubmatchSuccess(
@@ -1137,7 +1137,7 @@ class AssertionSequenceRewriter final {
     // negated '*' (everything) range serves the purpose.
     ZoneList<CharacterRange>* ranges =
         zone_->New<ZoneList<CharacterRange>>(0, zone_);
-    RegExpCharacterClass* cc = zone_->New<RegExpCharacterClass>(zone_, ranges);
+    RegExpClassRanges* cc = zone_->New<RegExpClassRanges>(zone_, ranges);
     terms_->Set(from, cc);
 
     // Zero out the rest.
@@ -1490,29 +1490,29 @@ void CharacterSet::Canonicalize() {
   CharacterRange::Canonicalize(ranges_);
 }
 
-RegExpCharacterClass* RegExpClassSet::ToCharacterClass(Zone* zone) {
+RegExpClassRanges* RegExpClassSetExpression::ToCharacterClass(Zone* zone) {
   ZoneList<CharacterRange>* result_ranges =
       zone->template New<ZoneList<CharacterRange>>(2, zone);
   ZoneList<CharacterRange>* temp_ranges =
       zone->template New<ZoneList<CharacterRange>>(2, zone);
   ComputeCharacterRanges(this, result_ranges, temp_ranges, zone);
-  return zone->template New<RegExpCharacterClass>(zone, result_ranges);
+  return zone->template New<RegExpClassRanges>(zone, result_ranges);
 }
 
 // static
-void RegExpClassSet::ComputeCharacterRanges(
+void RegExpClassSetExpression::ComputeCharacterRanges(
     RegExpTree* root, ZoneList<CharacterRange>* result_ranges,
     ZoneList<CharacterRange>* temp_ranges, Zone* zone) {
   DCHECK_EQ(temp_ranges->length(), 0);
-  DCHECK(root->IsCharacterClass() || root->IsClassSet());
-  if (root->IsCharacterClass()) {
-    DCHECK(!root->AsCharacterClass()->is_negated());
-    ZoneList<CharacterRange>* ranges = root->AsCharacterClass()->ranges(zone);
+  DCHECK(root->IsClassRanges() || root->IsClassSetExpression());
+  if (root->IsClassRanges()) {
+    DCHECK(!root->AsClassRanges()->is_negated());
+    ZoneList<CharacterRange>* ranges = root->AsClassRanges()->ranges(zone);
     CharacterRange::Canonicalize(ranges);
     result_ranges->AddAll(*ranges, zone);
     return;
   }
-  RegExpClassSet* node = root->AsClassSet();
+  RegExpClassSetExpression* node = root->AsClassSetExpression();
   switch (node->operation()) {
     case OperationType::kUnion: {
       ZoneList<CharacterRange>* op_ranges =
@@ -1564,17 +1564,16 @@ void RegExpClassSet::ComputeCharacterRanges(
       // TODO(pthier): It is unclear whether this variant is faster or slower
       // than subtracting multiple ranges in practice.
       ZoneList<CharacterRange>* lhs_range =
-          // node->operands()->at(0)->AsCharacterClass()->ranges(zone);
-          node->operands()->at(0)->IsCharacterClass()
-              ? node->operands()->at(0)->AsCharacterClass()->ranges(zone)
-              : node->operands()->at(0)->AsClassSet()->ranges_;
+          node->operands()->at(0)->IsClassRanges()
+              ? node->operands()->at(0)->AsClassRanges()->ranges(zone)
+              : node->operands()->at(0)->AsClassSetExpression()->ranges_;
       ZoneList<CharacterRange>* rhs_union =
           zone->template New<ZoneList<CharacterRange>>(2, zone);
       for (int i = 1; i < node->operands()->length(); i++) {
         ZoneList<CharacterRange>* op_range =
-            node->operands()->at(i)->IsCharacterClass()
-                ? node->operands()->at(i)->AsCharacterClass()->ranges(zone)
-                : node->operands()->at(i)->AsClassSet()->ranges_;
+            node->operands()->at(i)->IsClassRanges()
+                ? node->operands()->at(i)->AsClassRanges()->ranges(zone)
+                : node->operands()->at(i)->AsClassSetExpression()->ranges_;
         rhs_union->AddAll(*op_range, zone);
       }
       CharacterRange::Canonicalize(rhs_union);
diff --git a/src/regexp/regexp-compiler.cc b/src/regexp/regexp-compiler.cc
index 60a77ecabc..6b76c8ab1a 100644
--- a/src/regexp/regexp-compiler.cc
+++ b/src/regexp/regexp-compiler.cc
@@ -196,8 +196,8 @@ void RegExpAtom::AppendToText(RegExpText* text, Zone* zone) {
   text->AddElement(TextElement::Atom(this), zone);
 }
 
-void RegExpCharacterClass::AppendToText(RegExpText* text, Zone* zone) {
-  text->AddElement(TextElement::CharClass(this), zone);
+void RegExpClassRanges::AppendToText(RegExpText* text, Zone* zone) {
+  text->AddElement(TextElement::ClassRanges(this), zone);
 }
 
 void RegExpText::AppendToText(RegExpText* text, Zone* zone) {
@@ -209,8 +209,8 @@ TextElement TextElement::Atom(RegExpAtom* atom) {
   return TextElement(ATOM, atom);
 }
 
-TextElement TextElement::CharClass(RegExpCharacterClass* char_class) {
-  return TextElement(CHAR_CLASS, char_class);
+TextElement TextElement::ClassRanges(RegExpClassRanges* class_ranges) {
+  return TextElement(CLASS_RANGES, class_ranges);
 }
 
 int TextElement::length() const {
@@ -218,7 +218,7 @@ int TextElement::length() const {
     case ATOM:
       return atom()->length();
 
-    case CHAR_CLASS:
+    case CLASS_RANGES:
       return 1;
   }
   UNREACHABLE();
@@ -1215,11 +1215,11 @@ void GenerateBranches(RegExpMacroAssembler* masm, ZoneList<base::uc32>* ranges,
   }
 }
 
-void EmitCharClass(RegExpMacroAssembler* macro_assembler,
-                   RegExpCharacterClass* cc, bool one_byte, Label* on_failure,
-                   int cp_offset, bool check_offset, bool preloaded,
-                   Zone* zone) {
-  ZoneList<CharacterRange>* ranges = cc->ranges(zone);
+void EmitClassRanges(RegExpMacroAssembler* macro_assembler,
+                     RegExpClassRanges* cr, bool one_byte, Label* on_failure,
+                     int cp_offset, bool check_offset, bool preloaded,
+                     Zone* zone) {
+  ZoneList<CharacterRange>* ranges = cr->ranges(zone);
   CharacterRange::Canonicalize(ranges);
 
   // Now that all processing (like case-insensitivity) is done, clamp the
@@ -1228,7 +1228,7 @@ void EmitCharClass(RegExpMacroAssembler* macro_assembler,
 
   const int ranges_length = ranges->length();
   if (ranges_length == 0) {
-    if (!cc->is_negated()) {
+    if (!cr->is_negated()) {
       macro_assembler->GoTo(on_failure);
     }
     if (check_offset) {
@@ -1239,7 +1239,7 @@ void EmitCharClass(RegExpMacroAssembler* macro_assembler,
 
   const base::uc32 max_char = MaxCodeUnit(one_byte);
   if (ranges_length == 1 && ranges->at(0).IsEverything(max_char)) {
-    if (cc->is_negated()) {
+    if (cr->is_negated()) {
       macro_assembler->GoTo(on_failure);
     } else {
       // This is a common case hit by non-anchored expressions.
@@ -1254,8 +1254,8 @@ void EmitCharClass(RegExpMacroAssembler* macro_assembler,
     macro_assembler->LoadCurrentCharacter(cp_offset, on_failure, check_offset);
   }
 
-  if (cc->is_standard(zone) && macro_assembler->CheckSpecialCharacterClass(
-                                   cc->standard_type(), on_failure)) {
+  if (cr->is_standard(zone) && macro_assembler->CheckSpecialClassRanges(
+                                   cr->standard_type(), on_failure)) {
     return;
   }
 
@@ -1266,7 +1266,7 @@ void EmitCharClass(RegExpMacroAssembler* macro_assembler,
     // Note the flipped logic below (we check InRange if negated, NotInRange if
     // not negated); this is necessary since the method falls through on
     // failure whereas we want to fall through on success.
-    if (cc->is_negated()) {
+    if (cr->is_negated()) {
       if (macro_assembler->CheckCharacterInRangeArray(ranges, on_failure)) {
         return;
       }
@@ -1283,7 +1283,7 @@ void EmitCharClass(RegExpMacroAssembler* macro_assembler,
   ZoneList<base::uc32>* range_boundaries =
       zone->New<ZoneList<base::uc32>>(ranges_length * 2, zone);
 
-  bool zeroth_entry_is_failure = !cc->is_negated();
+  bool zeroth_entry_is_failure = !cr->is_negated();
 
   for (int i = 0; i < ranges_length; i++) {
     CharacterRange& range = ranges->at(i);
@@ -1659,7 +1659,7 @@ void TextNode::GetQuickCheckDetails(QuickCheckDetails* details,
     } else {
       QuickCheckDetails::Position* pos =
           details->positions(characters_filled_in);
-      RegExpCharacterClass* tree = elm.char_class();
+      RegExpClassRanges* tree = elm.class_ranges();
       ZoneList<CharacterRange>* ranges = tree->ranges(zone());
       if (tree->is_negated() || ranges->is_empty()) {
         // A quick check uses multi-character mask and compare.  There is no
@@ -1887,13 +1887,13 @@ RegExpNode* TextNode::FilterOneByte(int depth, RegExpFlags flags) {
         writable_quarks[j] = c;
       }
     } else {
-      DCHECK(elm.text_type() == TextElement::CHAR_CLASS);
-      RegExpCharacterClass* cc = elm.char_class();
-      ZoneList<CharacterRange>* ranges = cc->ranges(zone());
+      DCHECK(elm.text_type() == TextElement::CLASS_RANGES);
+      RegExpClassRanges* cr = elm.class_ranges();
+      ZoneList<CharacterRange>* ranges = cr->ranges(zone());
       CharacterRange::Canonicalize(ranges);
       // Now they are in order so we only need to look at the first.
       int range_count = ranges->length();
-      if (cc->is_negated()) {
+      if (cr->is_negated()) {
         if (range_count != 0 && ranges->at(0).from() == 0 &&
             ranges->at(0).to() >= String::kMaxOneByteCharCode) {
           // This will be handled in a later filter.
@@ -2091,7 +2091,7 @@ namespace {
 // Check for [0-9A-Z_a-z].
 void EmitWordCheck(RegExpMacroAssembler* assembler, Label* word,
                    Label* non_word, bool fall_through_on_word) {
-  if (assembler->CheckSpecialCharacterClass(
+  if (assembler->CheckSpecialClassRanges(
           fall_through_on_word ? StandardCharacterSet::kWord
                                : StandardCharacterSet::kNotWord,
           fall_through_on_word ? non_word : word)) {
@@ -2139,8 +2139,8 @@ void EmitHat(RegExpCompiler* compiler, RegExpNode* on_success, Trace* trace) {
   const bool can_skip_bounds_check = !may_be_at_or_before_subject_string_start;
   assembler->LoadCurrentCharacter(new_trace.cp_offset() - 1,
                                   new_trace.backtrack(), can_skip_bounds_check);
-  if (!assembler->CheckSpecialCharacterClass(
-          StandardCharacterSet::kLineTerminator, new_trace.backtrack())) {
+  if (!assembler->CheckSpecialClassRanges(StandardCharacterSet::kLineTerminator,
+                                          new_trace.backtrack())) {
     // Newline means \n, \r, 0x2028 or 0x2029.
     if (!compiler->one_byte()) {
       assembler->CheckCharacterAfterAnd(0x2028, 0xFFFE, &ok);
@@ -2388,14 +2388,14 @@ void TextNode::TextEmitPass(RegExpCompiler* compiler, TextEmitPassType pass,
         if (bounds_checked) UpdateBoundsCheck(cp_offset + j, checked_up_to);
       }
     } else {
-      DCHECK_EQ(TextElement::CHAR_CLASS, elm.text_type());
+      DCHECK_EQ(TextElement::CLASS_RANGES, elm.text_type());
       if (pass == CHARACTER_CLASS_MATCH) {
         if (first_element_checked && i == 0) continue;
         if (DeterminedAlready(quick_check, elm.cp_offset())) continue;
-        RegExpCharacterClass* cc = elm.char_class();
+        RegExpClassRanges* cr = elm.class_ranges();
         bool bounds_check = *checked_up_to < cp_offset || read_backward();
-        EmitCharClass(assembler, cc, one_byte, backtrack, cp_offset,
-                      bounds_check, preloaded, zone());
+        EmitClassRanges(assembler, cr, one_byte, backtrack, cp_offset,
+                        bounds_check, preloaded, zone());
         UpdateBoundsCheck(cp_offset, checked_up_to);
       }
     }
@@ -2422,8 +2422,8 @@ TextNode* TextNode::CreateForCharacterRanges(Zone* zone,
                                              RegExpNode* on_success) {
   DCHECK_NOT_NULL(ranges);
   // TODO(jgruber): There's no fundamental need to create this
-  // RegExpCharacterClass; we could refactor to avoid the allocation.
-  return zone->New<TextNode>(zone->New<RegExpCharacterClass>(zone, ranges),
+  // RegExpClassRanges; we could refactor to avoid the allocation.
+  return zone->New<TextNode>(zone->New<RegExpClassRanges>(zone, ranges),
                              read_backward, on_success);
 }
 
@@ -2432,11 +2432,11 @@ TextNode* TextNode::CreateForSurrogatePair(
     bool read_backward, RegExpNode* on_success) {
   ZoneList<CharacterRange>* lead_ranges = CharacterRange::List(zone, lead);
   ZoneList<TextElement>* elms = zone->New<ZoneList<TextElement>>(2, zone);
-  elms->Add(TextElement::CharClass(
-                zone->New<RegExpCharacterClass>(zone, lead_ranges)),
-            zone);
-  elms->Add(TextElement::CharClass(
-                zone->New<RegExpCharacterClass>(zone, trail_ranges)),
+  elms->Add(
+      TextElement::ClassRanges(zone->New<RegExpClassRanges>(zone, lead_ranges)),
+      zone);
+  elms->Add(TextElement::ClassRanges(
+                zone->New<RegExpClassRanges>(zone, trail_ranges)),
             zone);
   return zone->New<TextNode>(elms, read_backward, on_success);
 }
@@ -2446,11 +2446,11 @@ TextNode* TextNode::CreateForSurrogatePair(
     bool read_backward, RegExpNode* on_success) {
   ZoneList<CharacterRange>* trail_ranges = CharacterRange::List(zone, trail);
   ZoneList<TextElement>* elms = zone->New<ZoneList<TextElement>>(2, zone);
-  elms->Add(TextElement::CharClass(
-                zone->New<RegExpCharacterClass>(zone, lead_ranges)),
-            zone);
-  elms->Add(TextElement::CharClass(
-                zone->New<RegExpCharacterClass>(zone, trail_ranges)),
+  elms->Add(
+      TextElement::ClassRanges(zone->New<RegExpClassRanges>(zone, lead_ranges)),
+      zone);
+  elms->Add(TextElement::ClassRanges(
+                zone->New<RegExpClassRanges>(zone, trail_ranges)),
             zone);
   return zone->New<TextNode>(elms, read_backward, on_success);
 }
@@ -2534,12 +2534,12 @@ void TextNode::MakeCaseIndependent(Isolate* isolate, bool is_one_byte,
   int element_count = elements()->length();
   for (int i = 0; i < element_count; i++) {
     TextElement elm = elements()->at(i);
-    if (elm.text_type() == TextElement::CHAR_CLASS) {
-      RegExpCharacterClass* cc = elm.char_class();
+    if (elm.text_type() == TextElement::CLASS_RANGES) {
+      RegExpClassRanges* cr = elm.class_ranges();
       // None of the standard character classes is different in the case
       // independent case and it slows us down if we don't know that.
-      if (cc->is_standard(zone())) continue;
-      ZoneList<CharacterRange>* ranges = cc->ranges(zone());
+      if (cr->is_standard(zone())) continue;
+      ZoneList<CharacterRange>* ranges = cr->ranges(zone());
       CharacterRange::AddCaseEquivalents(isolate, zone(), ranges, is_one_byte);
     }
   }
@@ -2552,8 +2552,8 @@ RegExpNode* TextNode::GetSuccessorOfOmnivorousTextNode(
   if (read_backward()) return nullptr;
   if (elements()->length() != 1) return nullptr;
   TextElement elm = elements()->at(0);
-  if (elm.text_type() != TextElement::CHAR_CLASS) return nullptr;
-  RegExpCharacterClass* node = elm.char_class();
+  if (elm.text_type() != TextElement::CLASS_RANGES) return nullptr;
+  RegExpClassRanges* node = elm.class_ranges();
   ZoneList<CharacterRange>* ranges = node->ranges(zone());
   CharacterRange::Canonicalize(ranges);
   if (node->is_negated()) {
@@ -3856,10 +3856,10 @@ void TextNode::FillInBMInfo(Isolate* isolate, int initial_offset, int budget,
         }
       }
     } else {
-      DCHECK_EQ(TextElement::CHAR_CLASS, text.text_type());
-      RegExpCharacterClass* char_class = text.char_class();
-      ZoneList<CharacterRange>* ranges = char_class->ranges(zone());
-      if (char_class->is_negated()) {
+      DCHECK_EQ(TextElement::CLASS_RANGES, text.text_type());
+      RegExpClassRanges* class_ranges = text.class_ranges();
+      ZoneList<CharacterRange>* ranges = class_ranges->ranges(zone());
+      if (class_ranges->is_negated()) {
         bm->SetAll(offset);
       } else {
         for (int k = 0; k < ranges->length(); k++) {
@@ -3919,8 +3919,8 @@ RegExpNode* RegExpCompiler::PreprocessRegExp(RegExpCompileData* data,
     // this expression is anchored at the beginning or sticky.
     RegExpNode* loop_node = RegExpQuantifier::ToNode(
         0, RegExpTree::kInfinity, false,
-        zone()->New<RegExpCharacterClass>(StandardCharacterSet::kEverything),
-        this, captured_body, data->contains_anchor);
+        zone()->New<RegExpClassRanges>(StandardCharacterSet::kEverything), this,
+        captured_body, data->contains_anchor);
 
     if (data->contains_anchor) {
       // Unroll loop once, to take care of the case that might start
@@ -3928,7 +3928,7 @@ RegExpNode* RegExpCompiler::PreprocessRegExp(RegExpCompileData* data,
       ChoiceNode* first_step_node = zone()->New<ChoiceNode>(2, zone());
       first_step_node->AddAlternative(GuardedAlternative(captured_body));
       first_step_node->AddAlternative(GuardedAlternative(zone()->New<TextNode>(
-          zone()->New<RegExpCharacterClass>(StandardCharacterSet::kEverything),
+          zone()->New<RegExpClassRanges>(StandardCharacterSet::kEverything),
           false, loop_node)));
       node = first_step_node;
     } else {
diff --git a/src/regexp/regexp-dotprinter.cc b/src/regexp/regexp-dotprinter.cc
index bf651963af..3ce86cd619 100644
--- a/src/regexp/regexp-dotprinter.cc
+++ b/src/regexp/regexp-dotprinter.cc
@@ -135,8 +135,8 @@ void DotPrinterImpl::VisitText(TextNode* that) {
         }
         break;
       }
-      case TextElement::CHAR_CLASS: {
-        RegExpCharacterClass* node = elm.char_class();
+      case TextElement::CLASS_RANGES: {
+        RegExpClassRanges* node = elm.class_ranges();
         os_ << "[";
         if (node->is_negated()) os_ << "^";
         for (int j = 0; j < node->ranges(zone)->length(); j++) {
diff --git a/src/regexp/regexp-macro-assembler-tracer.cc b/src/regexp/regexp-macro-assembler-tracer.cc
index 916cedb640..50a467a980 100644
--- a/src/regexp/regexp-macro-assembler-tracer.cc
+++ b/src/regexp/regexp-macro-assembler-tracer.cc
@@ -392,11 +392,10 @@ void RegExpMacroAssemblerTracer::CheckPosition(int cp_offset,
   assembler_->CheckPosition(cp_offset, on_outside_input);
 }
 
-bool RegExpMacroAssemblerTracer::CheckSpecialCharacterClass(
+bool RegExpMacroAssemblerTracer::CheckSpecialClassRanges(
     StandardCharacterSet type, Label* on_no_match) {
-  bool supported = assembler_->CheckSpecialCharacterClass(type,
-                                                          on_no_match);
-  PrintF(" CheckSpecialCharacterClass(type='%c', label[%08x]): %s;\n",
+  bool supported = assembler_->CheckSpecialClassRanges(type, on_no_match);
+  PrintF(" CheckSpecialClassRanges(type='%c', label[%08x]): %s;\n",
          static_cast<char>(type), LabelToInt(on_no_match),
          supported ? "true" : "false");
   return supported;
diff --git a/src/regexp/regexp-macro-assembler-tracer.h b/src/regexp/regexp-macro-assembler-tracer.h
index 82e6b9e89e..5f9da29144 100644
--- a/src/regexp/regexp-macro-assembler-tracer.h
+++ b/src/regexp/regexp-macro-assembler-tracer.h
@@ -54,8 +54,8 @@ class RegExpMacroAssemblerTracer: public RegExpMacroAssembler {
                                      Label* on_not_in_range) override;
   void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set) override;
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/regexp-macro-assembler.h b/src/regexp/regexp-macro-assembler.h
index e27e90b8d0..e75489398f 100644
--- a/src/regexp/regexp-macro-assembler.h
+++ b/src/regexp/regexp-macro-assembler.h
@@ -114,8 +114,8 @@ class RegExpMacroAssembler {
   // character. Returns false if the type of special character class does
   // not have custom support.
   // May clobber the current loaded character.
-  virtual bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                          Label* on_no_match) {
+  virtual bool CheckSpecialClassRanges(StandardCharacterSet type,
+                                       Label* on_no_match) {
     return false;
   }
 
diff --git a/src/regexp/regexp-nodes.h b/src/regexp/regexp-nodes.h
index 121980b411..b3d6e1aa80 100644
--- a/src/regexp/regexp-nodes.h
+++ b/src/regexp/regexp-nodes.h
@@ -397,12 +397,11 @@ class TextNode : public SeqRegExpNode {
   TextNode(ZoneList<TextElement>* elms, bool read_backward,
            RegExpNode* on_success)
       : SeqRegExpNode(on_success), elms_(elms), read_backward_(read_backward) {}
-  TextNode(RegExpCharacterClass* that, bool read_backward,
-           RegExpNode* on_success)
+  TextNode(RegExpClassRanges* that, bool read_backward, RegExpNode* on_success)
       : SeqRegExpNode(on_success),
         elms_(zone()->New<ZoneList<TextElement>>(1, zone())),
         read_backward_(read_backward) {
-    elms_->Add(TextElement::CharClass(that), zone());
+    elms_->Add(TextElement::ClassRanges(that), zone());
   }
   // Create TextNode for a single character class for the given ranges.
   static TextNode* CreateForCharacterRanges(Zone* zone,
diff --git a/src/regexp/regexp-parser.cc b/src/regexp/regexp-parser.cc
index 3ef40c5ea7..040dc93017 100644
--- a/src/regexp/regexp-parser.cc
+++ b/src/regexp/regexp-parser.cc
@@ -57,8 +57,8 @@ class RegExpBuilder {
   // "Adds" an empty expression. Does nothing except consume a
   // following quantifier
   void AddEmpty();
-  void AddCharacterClass(RegExpCharacterClass* cc);
-  void AddCharacterClassForDesugaring(base::uc32 c);
+  void AddClassRanges(RegExpClassRanges* cc);
+  void AddClassRangesForDesugaring(base::uc32 c);
   void AddAtom(RegExpTree* tree);
   void AddTerm(RegExpTree* tree);
   void AddAssertion(RegExpTree* tree);
@@ -80,7 +80,7 @@ class RegExpBuilder {
   void FlushPendingSurrogate();
   void FlushCharacters();
   void FlushTerms();
-  bool NeedsDesugaringForUnicode(RegExpCharacterClass* cc);
+  bool NeedsDesugaringForUnicode(RegExpClassRanges* cc);
   bool NeedsDesugaringForIgnoreCase(base::uc32 c);
   bool IsUnicodeMode() const {
     // Either /v or /u enable UnicodeMode
@@ -752,9 +752,9 @@ RegExpTree* RegExpParserImpl<CharT>::ParseDisjunction() {
               StandardCharacterSet::kNotLineTerminator, ranges, false, zone());
         }
 
-        RegExpCharacterClass* cc =
-            zone()->template New<RegExpCharacterClass>(zone(), ranges);
-        builder->AddCharacterClass(cc);
+        RegExpClassRanges* cc =
+            zone()->template New<RegExpClassRanges>(zone(), ranges);
+        builder->AddClassRanges(cc);
         break;
       }
       case '(': {
@@ -764,10 +764,10 @@ RegExpTree* RegExpParserImpl<CharT>::ParseDisjunction() {
       }
       case '[': {
         RegExpTree* cc = ParseCharacterClass(builder CHECK_FAILED);
-        if (cc->IsCharacterClass()) {
-          builder->AddCharacterClass(cc->AsCharacterClass());
+        if (cc->IsClassRanges()) {
+          builder->AddClassRanges(cc->AsClassRanges());
         } else {
-          DCHECK(cc->IsClassSet());
+          DCHECK(cc->IsClassSetExpression());
           builder->AddTerm(cc);
         }
         break;
@@ -872,9 +872,9 @@ RegExpTree* RegExpParserImpl<CharT>::ParseDisjunction() {
                 add_unicode_case_equivalents CHECK_FAILED);
 
             if (parsed_character_class_escape) {
-              RegExpCharacterClass* cc =
-                  zone()->template New<RegExpCharacterClass>(zone(), ranges);
-              builder->AddCharacterClass(cc);
+              RegExpClassRanges* cc =
+                  zone()->template New<RegExpClassRanges>(zone(), ranges);
+              builder->AddClassRanges(cc);
             } else {
               CHECK(!IsUnicodeMode());
               Advance(2);
@@ -2179,8 +2179,8 @@ RegExpTree* RegExpParserImpl<CharT>::ParseClassStringDisjunction() {
 // https://arai-a.github.io/ecma262-compare/snapshot.html?pr=2418#prod-ClassSetOperand
 // Tree returned based on type_out:
 //  * kClassStringDisjunction: RegExpAlternative | RegExpAtom
-//  * kNestedClass: RegExpClassSet
-//  * For all other types: RegExpCharacterClass
+//  * kNestedClass: RegExpClassSetExpression
+//  * For all other types: RegExpClassRanges
 template <class CharT>
 RegExpTree* RegExpParserImpl<CharT>::ParseClassSetOperand(
     const RegExpBuilder* builder, ClassSetOperandType* type_out) {
@@ -2203,11 +2203,11 @@ RegExpTree* RegExpParserImpl<CharT>::ParseClassSetOperand(
   DCHECK_IMPLIES(*type_out == ClassSetOperandType::kNestedClass,
                  ranges->is_empty());
   DCHECK_IMPLIES(*type_out == ClassSetOperandType::kNestedClass,
-                 tree->IsClassSet());
+                 tree->IsClassSetExpression());
   // ClassSetRange is only used within ClassSetUnion().
   DCHECK_NE(*type_out, ClassSetOperandType::kClassSetRange);
   if (tree == nullptr) {
-    tree = zone()->template New<RegExpCharacterClass>(zone(), ranges);
+    tree = zone()->template New<RegExpClassRanges>(zone(), ranges);
   }
   return tree;
 }
@@ -2217,7 +2217,7 @@ RegExpTree* RegExpParserImpl<CharT>::ParseClassSetOperand(
 // Based on |type_out| either a tree is returned or ranges modifed (never both).
 // Tree returned based on type_out:
 //  * kClassStringDisjunction: RegExpAlternative | RegExpAtom
-//  * kNestedClass: RegExpClassSet
+//  * kNestedClass: RegExpClassSetExpression
 // For all other types, ranges is modified and nullptr is returned.
 template <class CharT>
 RegExpTree* RegExpParserImpl<CharT>::ParseClassSetOperand(
@@ -2339,9 +2339,8 @@ RegExpTree* RegExpParserImpl<CharT>::ParseClassUnion(
           if (needs_case_folding) {
             CharacterRange::AddUnicodeCaseEquivalents(ranges, zone());
           }
-          operands->Add(
-              zone()->template New<RegExpCharacterClass>(zone(), ranges),
-              zone());
+          operands->Add(zone()->template New<RegExpClassRanges>(zone(), ranges),
+                        zone());
           ranges = zone()->template New<ZoneList<CharacterRange>>(2, zone());
         }
         operands->Add(operand, zone());
@@ -2358,13 +2357,13 @@ RegExpTree* RegExpParserImpl<CharT>::ParseClassUnion(
     if (needs_case_folding) {
       CharacterRange::AddUnicodeCaseEquivalents(ranges, zone());
     }
-    operands->Add(zone()->template New<RegExpCharacterClass>(zone(), ranges),
+    operands->Add(zone()->template New<RegExpClassRanges>(zone(), ranges),
                   zone());
   }
   DCHECK_EQ(current(), ']');
   Advance();
-  return zone()->template New<RegExpClassSet>(
-      RegExpClassSet::OperationType::kUnion, is_negated, operands);
+  return zone()->template New<RegExpClassSetExpression>(
+      RegExpClassSetExpression::OperationType::kUnion, is_negated, operands);
 }
 
 // TODO(v8:11935): Change permalink once proposal is in stage 4.
@@ -2396,8 +2395,9 @@ RegExpTree* RegExpParserImpl<CharT>::ParseClassIntersection(
   }
   DCHECK_EQ(current(), ']');
   Advance();
-  return zone()->template New<RegExpClassSet>(
-      RegExpClassSet::OperationType::kIntersection, is_negated, operands);
+  return zone()->template New<RegExpClassSetExpression>(
+      RegExpClassSetExpression::OperationType::kIntersection, is_negated,
+      operands);
 }
 
 // TODO(v8:11935): Change permalink once proposal is in stage 4.
@@ -2424,8 +2424,9 @@ RegExpTree* RegExpParserImpl<CharT>::ParseClassSubtraction(
   }
   DCHECK_EQ(current(), ']');
   Advance();
-  return zone()->template New<RegExpClassSet>(
-      RegExpClassSet::OperationType::kSubtraction, is_negated, operands);
+  return zone()->template New<RegExpClassSetExpression>(
+      RegExpClassSetExpression::OperationType::kSubtraction, is_negated,
+      operands);
 }
 
 // https://tc39.es/ecma262/#prod-CharacterClass
@@ -2443,10 +2444,10 @@ RegExpTree* RegExpParserImpl<CharT>::ParseCharacterClass(
       zone()->template New<ZoneList<CharacterRange>>(2, zone());
   if (current() == ']') {
     Advance();
-    RegExpCharacterClass::CharacterClassFlags character_class_flags;
-    if (is_negated) character_class_flags = RegExpCharacterClass::NEGATED;
-    return zone()->template New<RegExpCharacterClass>(zone(), ranges,
-                                                      character_class_flags);
+    RegExpClassRanges::ClassRangesFlags class_ranges_flags;
+    if (is_negated) class_ranges_flags = RegExpClassRanges::NEGATED;
+    return zone()->template New<RegExpClassRanges>(zone(), ranges,
+                                                   class_ranges_flags);
   }
 
   if (!unicode_sets()) {
@@ -2457,10 +2458,10 @@ RegExpTree* RegExpParserImpl<CharT>::ParseCharacterClass(
     }
     DCHECK_EQ(current(), ']');
     Advance();
-    RegExpCharacterClass::CharacterClassFlags character_class_flags;
-    if (is_negated) character_class_flags = RegExpCharacterClass::NEGATED;
-    return zone()->template New<RegExpCharacterClass>(zone(), ranges,
-                                                      character_class_flags);
+    RegExpClassRanges::ClassRangesFlags character_class_flags;
+    if (is_negated) character_class_flags = RegExpClassRanges::NEGATED;
+    return zone()->template New<RegExpClassRanges>(zone(), ranges,
+                                                   character_class_flags);
   } else {
     ClassSetOperandType operand_type;
     RegExpTree* operand =
@@ -2469,8 +2470,7 @@ RegExpTree* RegExpParserImpl<CharT>::ParseCharacterClass(
       case '-':
         if (Next() == '-') {
           if (operand == nullptr) {
-            operand =
-                zone()->template New<RegExpCharacterClass>(zone(), ranges);
+            operand = zone()->template New<RegExpClassRanges>(zone(), ranges);
           }
           return ParseClassSubtraction(builder, is_negated, operand);
         }
@@ -2479,8 +2479,7 @@ RegExpTree* RegExpParserImpl<CharT>::ParseCharacterClass(
       case '&':
         if (Next() == '&') {
           if (operand == nullptr) {
-            operand =
-                zone()->template New<RegExpCharacterClass>(zone(), ranges);
+            operand = zone()->template New<RegExpClassRanges>(zone(), ranges);
           }
           return ParseClassIntersection(builder, is_negated, operand);
         }
@@ -2537,7 +2536,7 @@ void RegExpBuilder::AddTrailSurrogate(base::uc16 trail_surrogate) {
     base::uc32 combined =
         unibrow::Utf16::CombineSurrogatePair(lead_surrogate, trail_surrogate);
     if (NeedsDesugaringForIgnoreCase(combined)) {
-      AddCharacterClassForDesugaring(combined);
+      AddClassRangesForDesugaring(combined);
     } else {
       ZoneList<base::uc16> surrogate_pair(2, zone());
       surrogate_pair.Add(lead_surrogate, zone());
@@ -2557,7 +2556,7 @@ void RegExpBuilder::FlushPendingSurrogate() {
     DCHECK(IsUnicodeMode());
     base::uc32 c = pending_surrogate_;
     pending_surrogate_ = kNoPendingSurrogate;
-    AddCharacterClassForDesugaring(c);
+    AddClassRangesForDesugaring(c);
   }
 }
 
@@ -2593,7 +2592,7 @@ void RegExpBuilder::AddCharacter(base::uc16 c) {
   FlushPendingSurrogate();
   pending_empty_ = false;
   if (NeedsDesugaringForIgnoreCase(c)) {
-    AddCharacterClassForDesugaring(c);
+    AddClassRangesForDesugaring(c);
   } else {
     if (characters_ == nullptr) {
       characters_ = zone()->New<ZoneList<base::uc16>>(4, zone());
@@ -2627,7 +2626,7 @@ void RegExpBuilder::AddEscapedUnicodeCharacter(base::uc32 character) {
 
 void RegExpBuilder::AddEmpty() { pending_empty_ = true; }
 
-void RegExpBuilder::AddCharacterClass(RegExpCharacterClass* cc) {
+void RegExpBuilder::AddClassRanges(RegExpClassRanges* cc) {
   if (NeedsDesugaringForUnicode(cc)) {
     // With /u, character class needs to be desugared, so it
     // must be a standalone term instead of being part of a RegExpText.
@@ -2637,8 +2636,8 @@ void RegExpBuilder::AddCharacterClass(RegExpCharacterClass* cc) {
   }
 }
 
-void RegExpBuilder::AddCharacterClassForDesugaring(base::uc32 c) {
-  AddTerm(zone()->New<RegExpCharacterClass>(
+void RegExpBuilder::AddClassRangesForDesugaring(base::uc32 c) {
+  AddTerm(zone()->New<RegExpClassRanges>(
       zone(), CharacterRange::List(zone(), CharacterRange::Singleton(c))));
 }
 
@@ -2689,7 +2688,7 @@ void RegExpBuilder::FlushTerms() {
   LAST(ADD_NONE);
 }
 
-bool RegExpBuilder::NeedsDesugaringForUnicode(RegExpCharacterClass* cc) {
+bool RegExpBuilder::NeedsDesugaringForUnicode(RegExpClassRanges* cc) {
   if (!IsUnicodeMode()) return false;
   // TODO(yangguo): we could be smarter than this. Case-insensitivity does not
   // necessarily mean that we need to desugar. It's probably nicer to have a
diff --git a/src/regexp/riscv/regexp-macro-assembler-riscv.cc b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
index 93da768d86..c8f3eb551e 100644
--- a/src/regexp/riscv/regexp-macro-assembler-riscv.cc
+++ b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
@@ -499,7 +499,7 @@ void RegExpMacroAssemblerRISCV::CheckBitInTable(Handle<ByteArray> table,
   BranchOrBacktrack(on_bit_set, ne, a0, Operand(zero_reg));
 }
 
-bool RegExpMacroAssemblerRISCV::CheckSpecialCharacterClass(
+bool RegExpMacroAssemblerRISCV::CheckSpecialClassRanges(
     StandardCharacterSet type, Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check.
diff --git a/src/regexp/riscv/regexp-macro-assembler-riscv.h b/src/regexp/riscv/regexp-macro-assembler-riscv.h
index 2352af8a17..1080e72a7e 100644
--- a/src/regexp/riscv/regexp-macro-assembler-riscv.h
+++ b/src/regexp/riscv/regexp-macro-assembler-riscv.h
@@ -58,8 +58,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerRISCV
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.cc b/src/regexp/s390/regexp-macro-assembler-s390.cc
index ab9528dbc4..a61bc379ba 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.cc
+++ b/src/regexp/s390/regexp-macro-assembler-s390.cc
@@ -539,7 +539,7 @@ void RegExpMacroAssemblerS390::CheckBitInTable(Handle<ByteArray> table,
   BranchOrBacktrack(ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerS390::CheckSpecialCharacterClass(
+bool RegExpMacroAssemblerS390::CheckSpecialClassRanges(
     StandardCharacterSet type, Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.h b/src/regexp/s390/regexp-macro-assembler-s390.h
index 645b01faa5..f0b4833eb8 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.h
+++ b/src/regexp/s390/regexp-macro-assembler-s390.h
@@ -57,8 +57,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerS390
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/x64/regexp-macro-assembler-x64.cc b/src/regexp/x64/regexp-macro-assembler-x64.cc
index 1b4aa566f8..89fd2e34f1 100644
--- a/src/regexp/x64/regexp-macro-assembler-x64.cc
+++ b/src/regexp/x64/regexp-macro-assembler-x64.cc
@@ -578,8 +578,8 @@ void RegExpMacroAssemblerX64::CheckBitInTable(
   BranchOrBacktrack(not_equal, on_bit_set);
 }
 
-bool RegExpMacroAssemblerX64::CheckSpecialCharacterClass(
-    StandardCharacterSet type, Label* on_no_match) {
+bool RegExpMacroAssemblerX64::CheckSpecialClassRanges(StandardCharacterSet type,
+                                                      Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check, using the sequence:
   //   leal(rax, Operand(current_character(), -min)) or sub(rax, Immediate(min))
diff --git a/src/regexp/x64/regexp-macro-assembler-x64.h b/src/regexp/x64/regexp-macro-assembler-x64.h
index c0a743afc6..683d3bc428 100644
--- a/src/regexp/x64/regexp-macro-assembler-x64.h
+++ b/src/regexp/x64/regexp-macro-assembler-x64.h
@@ -57,8 +57,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerX64
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(StandardCharacterSet type,
-                                  Label* on_no_match) override;
+  bool CheckSpecialClassRanges(StandardCharacterSet type,
+                               Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
-- 
2.35.1


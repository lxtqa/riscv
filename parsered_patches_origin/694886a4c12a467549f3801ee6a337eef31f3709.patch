From 694886a4c12a467549f3801ee6a337eef31f3709 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Wed, 14 Jun 2023 11:16:11 +0800
Subject: [PATCH] [riscv][compiler] Add Adapter template argument to
 InstructionSelector

[wasm] Generic js-to-wasm wrapper written in Torque

Port commit 31c15897a3a6a5f3ed36ef0c89c2eb7d38a0e093
Port commit 65a226a63fd7c10e761ae82b00b8490b879a8fae

Bug: v8:12783


Change-Id: Ie30f0bde1cb18130c1cc3881b7929558ddb88b8e
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4612048
Commit-Queue: Yahan Lu <yahan@iscas.ac.cn>
Reviewed-by: Ji Qiu <qiuji@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#88277}
---
 src/builtins/riscv/builtins-riscv.cc          |   4 +
 .../riscv/interface-descriptors-riscv-inl.h   |   5 +
 .../riscv/instruction-selector-riscv.h        | 541 ++++++++------
 .../riscv/instruction-selector-riscv32.cc     | 452 +++++++-----
 .../riscv/instruction-selector-riscv64.cc     | 672 +++++++++++-------
 5 files changed, 1055 insertions(+), 619 deletions(-)

diff --git a/src/builtins/riscv/builtins-riscv.cc b/src/builtins/riscv/builtins-riscv.cc
index 1474260fa7..e0dc7194ba 100644
--- a/src/builtins/riscv/builtins-riscv.cc
+++ b/src/builtins/riscv/builtins-riscv.cc
@@ -3108,6 +3108,10 @@ void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
 }
+
+void Builtins::Generate_NewGenericJSToWasmWrapper(MacroAssembler* masm) {
+  __ Trap();
+}
 namespace {
 
 // Calls an API function. Allocates HandleScope, extracts returned value
diff --git a/src/codegen/riscv/interface-descriptors-riscv-inl.h b/src/codegen/riscv/interface-descriptors-riscv-inl.h
index 82281eabae..8affc87052 100644
--- a/src/codegen/riscv/interface-descriptors-riscv-inl.h
+++ b/src/codegen/riscv/interface-descriptors-riscv-inl.h
@@ -349,6 +349,11 @@ constexpr auto RunMicrotasksEntryDescriptor::registers() {
   return RegisterArray(a0, a1);
 }
 
+constexpr auto WasmNewJSToWasmWrapperDescriptor::registers() {
+  // Arbitrarily picked register.
+  return RegisterArray(a7);
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/compiler/backend/riscv/instruction-selector-riscv.h b/src/compiler/backend/riscv/instruction-selector-riscv.h
index 8c15b98f7d..910c579a07 100644
--- a/src/compiler/backend/riscv/instruction-selector-riscv.h
+++ b/src/compiler/backend/riscv/instruction-selector-riscv.h
@@ -19,10 +19,14 @@ namespace compiler {
 #define TRACE() PrintF("instr_sel: %s at line %d\n", __FUNCTION__, __LINE__)
 
 // Adds RISC-V-specific methods for generating InstructionOperands.
-class RiscvOperandGenerator final : public OperandGenerator {
+template <typename Adapter>
+class RiscvOperandGeneratorT final : public OperandGeneratorT<Adapter> {
  public:
-  explicit RiscvOperandGenerator(InstructionSelector* selector)
-      : OperandGenerator(selector) {}
+  OPERAND_GENERATOR_T_BOILERPLATE(Adapter)
+
+  explicit RiscvOperandGeneratorT<Adapter>(
+      InstructionSelectorT<Adapter>* selector)
+      : super(selector) {}
 
   InstructionOperand UseOperand(Node* node, InstructionCode opcode) {
     if (CanBeImmediate(node, opcode)) {
@@ -91,34 +95,39 @@ class RiscvOperandGenerator final : public OperandGenerator {
   }
 };
 
-void InstructionSelector::VisitProtectedStore(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitProtectedStore(Node* node) {
   // TODO(eholk)
   UNIMPLEMENTED();
 }
 
-void InstructionSelector::VisitProtectedLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitProtectedLoad(Node* node) {
   // TODO(eholk)
   UNIMPLEMENTED();
 }
 
-static void VisitRR(InstructionSelector* selector, ArchOpcode opcode,
-                    Node* node) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+void VisitRR(InstructionSelectorT<Adapter>* selector, InstructionCode opcode,
+             Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)));
 }
 
-static void VisitRRI(InstructionSelector* selector, ArchOpcode opcode,
+template <typename Adapter>
+static void VisitRRI(InstructionSelectorT<Adapter>* selector, ArchOpcode opcode,
                      Node* node) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   int32_t imm = OpParameter<int32_t>(node->op());
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)), g.UseImmediate(imm));
 }
 
-static void VisitSimdShift(InstructionSelector* selector, ArchOpcode opcode,
-                           Node* node) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+static void VisitSimdShift(InstructionSelectorT<Adapter>* selector,
+                           ArchOpcode opcode, Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   if (g.IsIntegerConstant(node->InputAt(1))) {
     selector->Emit(opcode, g.DefineAsRegister(node),
                    g.UseRegister(node->InputAt(0)),
@@ -130,50 +139,57 @@ static void VisitSimdShift(InstructionSelector* selector, ArchOpcode opcode,
   }
 }
 
-static void VisitRRIR(InstructionSelector* selector, ArchOpcode opcode,
-                      Node* node) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+static void VisitRRIR(InstructionSelectorT<Adapter>* selector,
+                      ArchOpcode opcode, Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   int32_t imm = OpParameter<int32_t>(node->op());
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)), g.UseImmediate(imm),
                  g.UseRegister(node->InputAt(1)));
 }
 
-static void VisitRRR(InstructionSelector* selector, ArchOpcode opcode,
+template <typename Adapter>
+static void VisitRRR(InstructionSelectorT<Adapter>* selector, ArchOpcode opcode,
                      Node* node) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)),
                  g.UseRegister(node->InputAt(1)));
 }
 
-static void VisitUniqueRRR(InstructionSelector* selector, ArchOpcode opcode,
-                           Node* node) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+static void VisitUniqueRRR(InstructionSelectorT<Adapter>* selector,
+                           ArchOpcode opcode, Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseUniqueRegister(node->InputAt(0)),
                  g.UseUniqueRegister(node->InputAt(1)));
 }
 
-void VisitRRRR(InstructionSelector* selector, ArchOpcode opcode, Node* node) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+void VisitRRRR(InstructionSelectorT<Adapter>* selector, ArchOpcode opcode,
+               Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   selector->Emit(
       opcode, g.DefineSameAsFirst(node), g.UseRegister(node->InputAt(0)),
       g.UseRegister(node->InputAt(1)), g.UseRegister(node->InputAt(2)));
 }
 
-static void VisitRRO(InstructionSelector* selector, ArchOpcode opcode,
+template <typename Adapter>
+static void VisitRRO(InstructionSelectorT<Adapter>* selector, ArchOpcode opcode,
                      Node* node) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   selector->Emit(opcode, g.DefineAsRegister(node),
                  g.UseRegister(node->InputAt(0)),
                  g.UseOperand(node->InputAt(1), opcode));
 }
 
-bool TryMatchImmediate(InstructionSelector* selector,
+template <typename Adapter>
+bool TryMatchImmediate(InstructionSelectorT<Adapter>* selector,
                        InstructionCode* opcode_return, Node* node,
                        size_t* input_count_return, InstructionOperand* inputs) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   if (g.CanBeImmediate(node, *opcode_return)) {
     *opcode_return |= AddressingModeField::encode(kMode_MRI);
     inputs[0] = g.UseImmediate(node);
@@ -183,11 +199,13 @@ bool TryMatchImmediate(InstructionSelector* selector,
   return false;
 }
 
-static void VisitBinop(InstructionSelector* selector, Node* node,
+// Shared routine for multiple binary operations.
+template <typename Adapter, typename Matcher>
+static void VisitBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                        InstructionCode opcode, bool has_reverse_opcode,
                        InstructionCode reverse_opcode,
                        FlagsContinuation* cont) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Int32BinopMatcher m(node);
   InstructionOperand inputs[2];
   size_t input_count = 0;
@@ -227,24 +245,29 @@ static void VisitBinop(InstructionSelector* selector, Node* node,
                                  inputs, cont);
 }
 
-static void VisitBinop(InstructionSelector* selector, Node* node,
+template <typename Adapter, typename Matcher>
+static void VisitBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                        InstructionCode opcode, bool has_reverse_opcode,
                        InstructionCode reverse_opcode) {
   FlagsContinuation cont;
-  VisitBinop(selector, node, opcode, has_reverse_opcode, reverse_opcode, &cont);
+  VisitBinop<Adapter, Matcher>(selector, node, opcode, has_reverse_opcode,
+                               reverse_opcode, &cont);
 }
 
-static void VisitBinop(InstructionSelector* selector, Node* node,
+template <typename Adapter, typename Matcher>
+static void VisitBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                        InstructionCode opcode, FlagsContinuation* cont) {
-  VisitBinop(selector, node, opcode, false, kArchNop, cont);
+  VisitBinop<Adapter, Matcher>(selector, node, opcode, false, kArchNop, cont);
 }
 
-static void VisitBinop(InstructionSelector* selector, Node* node,
+template <typename Adapter, typename Matcher>
+static void VisitBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                        InstructionCode opcode) {
-  VisitBinop(selector, node, opcode, false, kArchNop);
+  VisitBinop<Adapter, Matcher>(selector, node, opcode, false, kArchNop);
 }
 
-void InstructionSelector::VisitStackSlot(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStackSlot(Node* node) {
   StackSlotRepresentation rep = StackSlotRepresentationOf(node->op());
   int alignment = rep.alignment();
   int slot = frame_->AllocateSpillSlot(rep.size(), alignment);
@@ -255,15 +278,18 @@ void InstructionSelector::VisitStackSlot(Node* node) {
        sequence()->AddImmediate(Constant(alignment)), 0, nullptr);
 }
 
-void InstructionSelector::VisitAbortCSADcheck(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitAbortCSADcheck(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kArchAbortCSADcheck, g.NoOutput(), g.UseFixed(node->InputAt(0), a0));
 }
 
-void EmitS128Load(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void EmitS128Load(InstructionSelectorT<Adapter>* selector, Node* node,
                   InstructionCode opcode, VSew sew, Vlmul lmul);
 
-void InstructionSelector::VisitLoadTransform(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoadTransform(Node* node) {
   LoadTransformParameters params = LoadTransformParametersOf(node->op());
 
   switch (params.transformation) {
@@ -309,23 +335,26 @@ void InstructionSelector::VisitLoadTransform(Node* node) {
 }
 
 // Shared routine for multiple compare operations.
-static void VisitCompare(InstructionSelector* selector, InstructionCode opcode,
-                         InstructionOperand left, InstructionOperand right,
-                         FlagsContinuation* cont) {
+template <typename Adapter>
+static void VisitCompare(InstructionSelectorT<Adapter>* selector,
+                         InstructionCode opcode, InstructionOperand left,
+                         InstructionOperand right, FlagsContinuation* cont) {
   selector->EmitWithContinuation(opcode, left, right, cont);
 }
 
 // Shared routine for multiple compare operations.
-static void VisitWordCompareZero(InstructionSelector* selector,
+template <typename Adapter>
+static void VisitWordCompareZero(InstructionSelectorT<Adapter>* selector,
                                  InstructionOperand value,
                                  FlagsContinuation* cont) {
   selector->EmitWithContinuation(kRiscvCmpZero, value, cont);
 }
 
 // Shared routine for multiple float32 compare operations.
-void VisitFloat32Compare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitFloat32Compare(InstructionSelectorT<Adapter>* selector, Node* node,
                          FlagsContinuation* cont) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Float32BinopMatcher m(node);
   InstructionOperand lhs, rhs;
 
@@ -337,9 +366,10 @@ void VisitFloat32Compare(InstructionSelector* selector, Node* node,
 }
 
 // Shared routine for multiple float64 compare operations.
-void VisitFloat64Compare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitFloat64Compare(InstructionSelectorT<Adapter>* selector, Node* node,
                          FlagsContinuation* cont) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Float64BinopMatcher m(node);
   InstructionOperand lhs, rhs;
 
@@ -351,10 +381,11 @@ void VisitFloat64Compare(InstructionSelector* selector, Node* node,
 }
 
 // Shared routine for multiple word compare operations.
-void VisitWordCompare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitWordCompare(InstructionSelectorT<Adapter>* selector, Node* node,
                       InstructionCode opcode, FlagsContinuation* cont,
                       bool commutative) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* left = node->InputAt(0);
   Node* right = node->InputAt(1);
   // If one of the two inputs is an immediate, make sure it's on the right.
@@ -425,8 +456,10 @@ void VisitWordCompare(InstructionSelector* selector, Node* node,
   }
 }
 
-void InstructionSelector::VisitSwitch(Node* node, const SwitchInfo& sw) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSwitch(Node* node,
+                                                const SwitchInfo& sw) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand value_operand = g.UseRegister(node->InputAt(0));
 
   // Emit either ArchTableSwitch or ArchBinarySearchSwitch.
@@ -456,16 +489,18 @@ void InstructionSelector::VisitSwitch(Node* node, const SwitchInfo& sw) {
   return EmitBinarySearchSwitch(sw, value_operand);
 }
 
-void EmitWordCompareZero(InstructionSelector* selector, Node* value,
+template <typename Adapter>
+void EmitWordCompareZero(InstructionSelectorT<Adapter>* selector, Node* value,
                          FlagsContinuation* cont) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   selector->EmitWithContinuation(kRiscvCmpZero,
                                  g.UseRegisterOrImmediateZero(value), cont);
 }
 
-void VisitAtomicExchange(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitAtomicExchange(InstructionSelectorT<Adapter>* selector, Node* node,
                          ArchOpcode opcode, AtomicWidth width) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -487,9 +522,11 @@ void VisitAtomicExchange(InstructionSelector* selector, Node* node,
   selector->Emit(code, 1, outputs, input_count, inputs, 3, temp);
 }
 
-void VisitAtomicCompareExchange(InstructionSelector* selector, Node* node,
-                                ArchOpcode opcode, AtomicWidth width) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+void VisitAtomicCompareExchange(InstructionSelectorT<Adapter>* selector,
+                                Node* node, ArchOpcode opcode,
+                                AtomicWidth width) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* old_value = node->InputAt(2);
@@ -513,77 +550,93 @@ void VisitAtomicCompareExchange(InstructionSelector* selector, Node* node,
   selector->Emit(code, 1, outputs, input_count, inputs, 3, temp);
 }
 
-void InstructionSelector::VisitFloat32Equal(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Equal(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   VisitFloat32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kUnsignedLessThan, node);
   VisitFloat32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kUnsignedLessThanOrEqual, node);
   VisitFloat32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64Equal(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Equal(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   VisitFloat64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kUnsignedLessThan, node);
   VisitFloat64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kUnsignedLessThanOrEqual, node);
   VisitFloat64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitFloat64ExtractLowWord32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64ExtractLowWord32(Node* node) {
   VisitRR(this, kRiscvFloat64ExtractLowWord32, node);
 }
 
-void InstructionSelector::VisitFloat64ExtractHighWord32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64ExtractHighWord32(Node* node) {
   VisitRR(this, kRiscvFloat64ExtractHighWord32, node);
 }
 
-void InstructionSelector::VisitFloat64SilenceNaN(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64SilenceNaN(Node* node) {
   VisitRR(this, kRiscvFloat64SilenceNaN, node);
 }
 
-void InstructionSelector::VisitFloat64InsertLowWord32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64InsertLowWord32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* left = node->InputAt(0);
   Node* right = node->InputAt(1);
   Emit(kRiscvFloat64InsertLowWord32, g.DefineSameAsFirst(node),
        g.UseRegister(left), g.UseRegister(right));
 }
 
-void InstructionSelector::VisitFloat64InsertHighWord32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64InsertHighWord32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* left = node->InputAt(0);
   Node* right = node->InputAt(1);
   Emit(kRiscvFloat64InsertHighWord32, g.DefineSameAsFirst(node),
        g.UseRegister(left), g.UseRegister(right));
 }
 
-void InstructionSelector::VisitMemoryBarrier(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitMemoryBarrier(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvSync, g.NoOutput());
 }
 
-bool InstructionSelector::IsTailCallAddressImmediate() { return false; }
+template <typename Adapter>
+bool InstructionSelectorT<Adapter>::IsTailCallAddressImmediate() {
+  return false;
+}
 
-void InstructionSelector::EmitPrepareResults(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitPrepareResults(
     ZoneVector<PushParameter>* results, const CallDescriptor* call_descriptor,
     Node* node) {
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
 
   int reverse_slot = 1;
   for (PushParameter output : *results) {
@@ -603,104 +656,127 @@ void InstructionSelector::EmitPrepareResults(
   }
 }
 
-void InstructionSelector::EmitMoveParamToFPR(Node* node, int index) {}
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitMoveParamToFPR(Node* node, int index) {}
 
-void InstructionSelector::EmitMoveFPRToParam(InstructionOperand* op,
-                                             LinkageLocation location) {}
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitMoveFPRToParam(
+    InstructionOperand* op, LinkageLocation location) {}
 
-void InstructionSelector::VisitFloat32Abs(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Abs(Node* node) {
   VisitRR(this, kRiscvAbsS, node);
 }
 
-void InstructionSelector::VisitFloat64Abs(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Abs(Node* node) {
   VisitRR(this, kRiscvAbsD, node);
 }
 
-void InstructionSelector::VisitFloat32Sqrt(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Sqrt(Node* node) {
   VisitRR(this, kRiscvSqrtS, node);
 }
 
-void InstructionSelector::VisitFloat64Sqrt(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Sqrt(Node* node) {
   VisitRR(this, kRiscvSqrtD, node);
 }
 
-void InstructionSelector::VisitFloat32RoundDown(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32RoundDown(Node* node) {
   VisitRR(this, kRiscvFloat32RoundDown, node);
 }
 
-void InstructionSelector::VisitFloat32Add(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Add(Node* node) {
   VisitRRR(this, kRiscvAddS, node);
 }
 
-void InstructionSelector::VisitFloat64Add(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Add(Node* node) {
   VisitRRR(this, kRiscvAddD, node);
 }
 
-void InstructionSelector::VisitFloat32Sub(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Sub(Node* node) {
   VisitRRR(this, kRiscvSubS, node);
 }
 
-void InstructionSelector::VisitFloat64Sub(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Sub(Node* node) {
   VisitRRR(this, kRiscvSubD, node);
 }
 
-void InstructionSelector::VisitFloat32Mul(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Mul(Node* node) {
   VisitRRR(this, kRiscvMulS, node);
 }
 
-void InstructionSelector::VisitFloat64Mul(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Mul(Node* node) {
   VisitRRR(this, kRiscvMulD, node);
 }
 
-void InstructionSelector::VisitFloat32Div(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Div(Node* node) {
   VisitRRR(this, kRiscvDivS, node);
 }
 
-void InstructionSelector::VisitFloat64Div(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Div(Node* node) {
   VisitRRR(this, kRiscvDivD, node);
 }
 
-void InstructionSelector::VisitFloat64Mod(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Mod(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvModD, g.DefineAsFixed(node, fa0),
        g.UseFixed(node->InputAt(0), fa0), g.UseFixed(node->InputAt(1), fa1))
       ->MarkAsCall();
 }
 
-void InstructionSelector::VisitFloat32Max(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Max(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvFloat32Max, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)), g.UseRegister(node->InputAt(1)));
 }
 
-void InstructionSelector::VisitFloat64Max(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Max(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvFloat64Max, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)), g.UseRegister(node->InputAt(1)));
 }
 
-void InstructionSelector::VisitFloat32Min(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Min(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvFloat32Min, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)), g.UseRegister(node->InputAt(1)));
 }
 
-void InstructionSelector::VisitFloat64Min(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Min(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvFloat64Min, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)), g.UseRegister(node->InputAt(1)));
 }
 
-void InstructionSelector::VisitTruncateFloat64ToWord32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat64ToWord32(Node* node) {
   VisitRR(this, kArchTruncateDoubleToI, node);
 }
 
-void InstructionSelector::VisitRoundFloat64ToInt32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundFloat64ToInt32(Node* node) {
   VisitRR(this, kRiscvTruncWD, node);
 }
 
-void InstructionSelector::VisitTruncateFloat64ToFloat32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat64ToFloat32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* value = node->InputAt(0);
   // Match TruncateFloat64ToFloat32(ChangeInt32ToFloat64) to corresponding
   // instruction.
@@ -713,11 +789,12 @@ void InstructionSelector::VisitTruncateFloat64ToFloat32(Node* node) {
   VisitRR(this, kRiscvCvtSD, node);
 }
 
-void InstructionSelector::VisitWord32Shl(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Shl(Node* node) {
   Int32BinopMatcher m(node);
   if (m.left().IsWord32And() && CanCover(node, m.left().node()) &&
       m.right().IsInRange(1, 31)) {
-    RiscvOperandGenerator g(this);
+    RiscvOperandGeneratorT<Adapter> g(this);
     Int32BinopMatcher mleft(m.left().node());
     // Match Word32Shl(Word32And(x, mask), imm) to Shl where the mask is
     // contiguous, and the shift immediate non-zero.
@@ -743,14 +820,16 @@ void InstructionSelector::VisitWord32Shl(Node* node) {
   VisitRRO(this, kRiscvShl32, node);
 }
 
-void InstructionSelector::VisitWord32Shr(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Shr(Node* node) {
   VisitRRO(this, kRiscvShr32, node);
 }
 
-void InstructionSelector::VisitWord32Sar(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Sar(Node* node) {
   Int32BinopMatcher m(node);
   if (CanCover(node, m.left().node())) {
-    RiscvOperandGenerator g(this);
+    RiscvOperandGeneratorT<Adapter> g(this);
     if (m.left().IsWord32Shl()) {
       Int32BinopMatcher mleft(m.left().node());
       if (m.right().HasResolvedValue() && mleft.right().HasResolvedValue()) {
@@ -775,8 +854,9 @@ void InstructionSelector::VisitWord32Sar(Node* node) {
   VisitRRO(this, kRiscvSar32, node);
 }
 
-void InstructionSelector::VisitI32x4ExtAddPairwiseI16x8S(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4ExtAddPairwiseI16x8S(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand src1 = g.TempSimd128Register();
   InstructionOperand src2 = g.TempSimd128Register();
   InstructionOperand src = g.UseUniqueRegister(node->InputAt(0));
@@ -788,8 +868,9 @@ void InstructionSelector::VisitI32x4ExtAddPairwiseI16x8S(Node* node) {
        g.UseImmediate(int8_t(E16)), g.UseImmediate(int8_t(mf2)));
 }
 
-void InstructionSelector::VisitI32x4ExtAddPairwiseI16x8U(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4ExtAddPairwiseI16x8U(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand src1 = g.TempSimd128Register();
   InstructionOperand src2 = g.TempSimd128Register();
   InstructionOperand src = g.UseUniqueRegister(node->InputAt(0));
@@ -801,8 +882,9 @@ void InstructionSelector::VisitI32x4ExtAddPairwiseI16x8U(Node* node) {
        g.UseImmediate(int8_t(E16)), g.UseImmediate(int8_t(mf2)));
 }
 
-void InstructionSelector::VisitI16x8ExtAddPairwiseI8x16S(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI16x8ExtAddPairwiseI8x16S(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand src1 = g.TempSimd128Register();
   InstructionOperand src2 = g.TempSimd128Register();
   InstructionOperand src = g.UseUniqueRegister(node->InputAt(0));
@@ -814,8 +896,9 @@ void InstructionSelector::VisitI16x8ExtAddPairwiseI8x16S(Node* node) {
        g.UseImmediate(int8_t(E8)), g.UseImmediate(int8_t(mf2)));
 }
 
-void InstructionSelector::VisitI16x8ExtAddPairwiseI8x16U(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI16x8ExtAddPairwiseI8x16U(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand src1 = g.TempSimd128Register();
   InstructionOperand src2 = g.TempSimd128Register();
   InstructionOperand src = g.UseUniqueRegister(node->InputAt(0));
@@ -1000,8 +1083,9 @@ void InstructionSelector::VisitI16x8ExtAddPairwiseI8x16U(Node* node) {
   V(S128Xor, kRiscvS128Xor)                             \
   V(S128AndNot, kRiscvS128AndNot)
 
-void InstructionSelector::VisitS128Const(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitS128Const(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   static const int kUint32Immediates = kSimd128Size / sizeof(uint32_t);
   uint32_t val[kUint32Immediates];
   memcpy(val, S128ImmediateParameterOf(node->op()).data(), kSimd128Size);
@@ -1020,22 +1104,26 @@ void InstructionSelector::VisitS128Const(Node* node) {
   }
 }
 
-void InstructionSelector::VisitS128Zero(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitS128Zero(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvS128Zero, g.DefineAsRegister(node));
 }
 
-#define SIMD_VISIT_SPLAT(Type)                               \
-  void InstructionSelector::Visit##Type##Splat(Node* node) { \
-    VisitRR(this, kRiscv##Type##Splat, node);                \
+#define SIMD_VISIT_SPLAT(Type)                                         \
+  template <typename Adapter>                                          \
+  void InstructionSelectorT<Adapter>::Visit##Type##Splat(Node* node) { \
+    VisitRR(this, kRiscv##Type##Splat, node);                          \
   }
 SIMD_TYPE_LIST(SIMD_VISIT_SPLAT)
 SIMD_VISIT_SPLAT(F64x2)
 #undef SIMD_VISIT_SPLAT
 
-#define SIMD_VISIT_EXTRACT_LANE(Type, Sign)                              \
-  void InstructionSelector::Visit##Type##ExtractLane##Sign(Node* node) { \
-    VisitRRI(this, kRiscv##Type##ExtractLane##Sign, node);               \
+#define SIMD_VISIT_EXTRACT_LANE(Type, Sign)                           \
+  template <typename Adapter>                                         \
+  void InstructionSelectorT<Adapter>::Visit##Type##ExtractLane##Sign( \
+      Node* node) {                                                   \
+    VisitRRI(this, kRiscv##Type##ExtractLane##Sign, node);            \
   }
 SIMD_VISIT_EXTRACT_LANE(F64x2, )
 SIMD_VISIT_EXTRACT_LANE(F32x4, )
@@ -1047,42 +1135,48 @@ SIMD_VISIT_EXTRACT_LANE(I8x16, U)
 SIMD_VISIT_EXTRACT_LANE(I8x16, S)
 #undef SIMD_VISIT_EXTRACT_LANE
 
-#define SIMD_VISIT_REPLACE_LANE(Type)                              \
-  void InstructionSelector::Visit##Type##ReplaceLane(Node* node) { \
-    VisitRRIR(this, kRiscv##Type##ReplaceLane, node);              \
+#define SIMD_VISIT_REPLACE_LANE(Type)                                        \
+  template <typename Adapter>                                                \
+  void InstructionSelectorT<Adapter>::Visit##Type##ReplaceLane(Node* node) { \
+    VisitRRIR(this, kRiscv##Type##ReplaceLane, node);                        \
   }
 SIMD_TYPE_LIST(SIMD_VISIT_REPLACE_LANE)
 SIMD_VISIT_REPLACE_LANE(F64x2)
 #undef SIMD_VISIT_REPLACE_LANE
 
-#define SIMD_VISIT_UNOP(Name, instruction)            \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRR(this, instruction, node);                 \
+#define SIMD_VISIT_UNOP(Name, instruction)                      \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRR(this, instruction, node);                           \
   }
 SIMD_UNOP_LIST(SIMD_VISIT_UNOP)
 #undef SIMD_VISIT_UNOP
 
-#define SIMD_VISIT_SHIFT_OP(Name)                     \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitSimdShift(this, kRiscv##Name, node);         \
+#define SIMD_VISIT_SHIFT_OP(Name)                               \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitSimdShift(this, kRiscv##Name, node);                   \
   }
 SIMD_SHIFT_OP_LIST(SIMD_VISIT_SHIFT_OP)
 #undef SIMD_VISIT_SHIFT_OP
 
-#define SIMD_VISIT_BINOP(Name, instruction)           \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRRR(this, instruction, node);                \
+#define SIMD_VISIT_BINOP(Name, instruction)                     \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRRR(this, instruction, node);                          \
   }
 SIMD_BINOP_LIST(SIMD_VISIT_BINOP)
 #undef SIMD_VISIT_BINOP
 
-void InstructionSelector::VisitS128Select(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitS128Select(Node* node) {
   VisitRRRR(this, kRiscvS128Select, node);
 }
 
-#define SIMD_VISIT_SELECT_LANE(Name)                  \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRRRR(this, kRiscvS128Select, node);          \
+#define SIMD_VISIT_SELECT_LANE(Name)                            \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRRRR(this, kRiscvS128Select, node);                    \
   }
 SIMD_VISIT_SELECT_LANE(I8x16RelaxedLaneSelect)
 SIMD_VISIT_SELECT_LANE(I16x8RelaxedLaneSelect)
@@ -1090,9 +1184,10 @@ SIMD_VISIT_SELECT_LANE(I32x4RelaxedLaneSelect)
 SIMD_VISIT_SELECT_LANE(I64x2RelaxedLaneSelect)
 #undef SIMD_VISIT_SELECT_LANE
 
-#define VISIT_SIMD_QFMOP(Name, instruction)           \
-  void InstructionSelector::Visit##Name(Node* node) { \
-    VisitRRRR(this, instruction, node);               \
+#define VISIT_SIMD_QFMOP(Name, instruction)                     \
+  template <typename Adapter>                                   \
+  void InstructionSelectorT<Adapter>::Visit##Name(Node* node) { \
+    VisitRRRR(this, instruction, node);                         \
   }
 VISIT_SIMD_QFMOP(F64x2Qfma, kRiscvF64x2Qfma)
 VISIT_SIMD_QFMOP(F64x2Qfms, kRiscvF64x2Qfms)
@@ -1100,10 +1195,11 @@ VISIT_SIMD_QFMOP(F32x4Qfma, kRiscvF32x4Qfma)
 VISIT_SIMD_QFMOP(F32x4Qfms, kRiscvF32x4Qfms)
 #undef VISIT_SIMD_QFMOP
 
-void InstructionSelector::VisitI32x4DotI16x8S(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4DotI16x8S(Node* node) {
   constexpr int32_t FIRST_INDEX = 0b01010101;
   constexpr int32_t SECOND_INDEX = 0b10101010;
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand temp = g.TempFpRegister(v16);
   InstructionOperand temp1 = g.TempFpRegister(v14);
   InstructionOperand temp2 = g.TempFpRegister(v30);
@@ -1119,10 +1215,11 @@ void InstructionSelector::VisitI32x4DotI16x8S(Node* node) {
              g.UseImmediate(m1));
 }
 
-void InstructionSelector::VisitI16x8DotI8x16I7x16S(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI16x8DotI8x16I7x16S(Node* node) {
   constexpr int32_t FIRST_INDEX = 0b0101010101010101;
   constexpr int32_t SECOND_INDEX = 0b1010101010101010;
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand temp = g.TempFpRegister(v16);
   InstructionOperand temp1 = g.TempFpRegister(v14);
   InstructionOperand temp2 = g.TempFpRegister(v30);
@@ -1138,12 +1235,13 @@ void InstructionSelector::VisitI16x8DotI8x16I7x16S(Node* node) {
              g.UseImmediate(m1));
 }
 
-void InstructionSelector::VisitI32x4DotI8x16I7x16AddS(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI32x4DotI8x16I7x16AddS(Node* node) {
   constexpr int32_t FIRST_INDEX = 0b0001000100010001;
   constexpr int32_t SECOND_INDEX = 0b0010001000100010;
   constexpr int32_t THIRD_INDEX = 0b0100010001000100;
   constexpr int32_t FOURTH_INDEX = 0b1000100010001000;
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand intermediate = g.TempFpRegister(v12);
   this->Emit(kRiscvVwmul, intermediate, g.UseRegister(node->InputAt(0)),
              g.UseRegister(node->InputAt(1)), g.UseImmediate(E8),
@@ -1182,13 +1280,14 @@ void InstructionSelector::VisitI32x4DotI8x16I7x16AddS(Node* node) {
              g.UseImmediate(E32), g.UseImmediate(m1));
 }
 
-void InstructionSelector::VisitI8x16Shuffle(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI8x16Shuffle(Node* node) {
   uint8_t shuffle[kSimd128Size];
   bool is_swizzle;
   CanonicalizeShuffle(node, shuffle, &is_swizzle);
   Node* input0 = node->InputAt(0);
   Node* input1 = node->InputAt(1);
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   // uint8_t shuffle32x4[4];
   // ArchOpcode opcode;
   // if (TryMatchArchShuffle(shuffle, arch_shuffles, arraysize(arch_shuffles),
@@ -1216,8 +1315,9 @@ void InstructionSelector::VisitI8x16Shuffle(Node* node) {
        g.UseImmediate(wasm::SimdShuffle::Pack4Lanes(shuffle + 12)));
 }
 
-void InstructionSelector::VisitI8x16Swizzle(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI8x16Swizzle(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand temps[] = {g.TempSimd128Register()};
   // We don't want input 0 or input 1 to be the same as output, since we will
   // modify output before do the calculation.
@@ -1227,62 +1327,68 @@ void InstructionSelector::VisitI8x16Swizzle(Node* node) {
        g.UseImmediate(m1), arraysize(temps), temps);
 }
 
-void InstructionSelector::VisitSignExtendWord8ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSignExtendWord8ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvSignExtendByte, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitSignExtendWord16ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSignExtendWord16ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvSignExtendShort, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-#define VISIT_EXT_MUL(OPCODE1, OPCODE2, TYPE)                            \
-  void InstructionSelector::Visit##OPCODE1##ExtMulLow##OPCODE2##S(       \
-      Node* node) {                                                      \
-    RiscvOperandGenerator g(this);                                       \
-    Emit(kRiscvVwmul, g.DefineAsRegister(node),                          \
-         g.UseUniqueRegister(node->InputAt(0)),                          \
-         g.UseUniqueRegister(node->InputAt(1)), g.UseImmediate(E##TYPE), \
-         g.UseImmediate(mf2));                                           \
-  }                                                                      \
-  void InstructionSelector::Visit##OPCODE1##ExtMulHigh##OPCODE2##S(      \
-      Node* node) {                                                      \
-    RiscvOperandGenerator g(this);                                       \
-    InstructionOperand t1 = g.TempFpRegister(v16);                       \
-    Emit(kRiscvVslidedown, t1, g.UseUniqueRegister(node->InputAt(0)),    \
-         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),   \
-         g.UseImmediate(m1));                                            \
-    InstructionOperand t2 = g.TempFpRegister(v17);                       \
-    Emit(kRiscvVslidedown, t2, g.UseUniqueRegister(node->InputAt(1)),    \
-         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),   \
-         g.UseImmediate(m1));                                            \
-    Emit(kRiscvVwmul, g.DefineAsRegister(node), t1, t2,                  \
-         g.UseImmediate(E##TYPE), g.UseImmediate(mf2));                  \
-  }                                                                      \
-  void InstructionSelector::Visit##OPCODE1##ExtMulLow##OPCODE2##U(       \
-      Node* node) {                                                      \
-    RiscvOperandGenerator g(this);                                       \
-    Emit(kRiscvVwmulu, g.DefineAsRegister(node),                         \
-         g.UseUniqueRegister(node->InputAt(0)),                          \
-         g.UseUniqueRegister(node->InputAt(1)), g.UseImmediate(E##TYPE), \
-         g.UseImmediate(mf2));                                           \
-  }                                                                      \
-  void InstructionSelector::Visit##OPCODE1##ExtMulHigh##OPCODE2##U(      \
-      Node* node) {                                                      \
-    RiscvOperandGenerator g(this);                                       \
-    InstructionOperand t1 = g.TempFpRegister(v16);                       \
-    Emit(kRiscvVslidedown, t1, g.UseUniqueRegister(node->InputAt(0)),    \
-         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),   \
-         g.UseImmediate(m1));                                            \
-    InstructionOperand t2 = g.TempFpRegister(v17);                       \
-    Emit(kRiscvVslidedown, t2, g.UseUniqueRegister(node->InputAt(1)),    \
-         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),   \
-         g.UseImmediate(m1));                                            \
-    Emit(kRiscvVwmulu, g.DefineAsRegister(node), t1, t2,                 \
-         g.UseImmediate(E##TYPE), g.UseImmediate(mf2));                  \
+#define VISIT_EXT_MUL(OPCODE1, OPCODE2, TYPE)                                 \
+  template <typename Adapter>                                                 \
+  void InstructionSelectorT<Adapter>::Visit##OPCODE1##ExtMulLow##OPCODE2##S(  \
+      Node* node) {                                                           \
+    RiscvOperandGeneratorT<Adapter> g(this);                                  \
+    Emit(kRiscvVwmul, g.DefineAsRegister(node),                               \
+         g.UseUniqueRegister(node->InputAt(0)),                               \
+         g.UseUniqueRegister(node->InputAt(1)), g.UseImmediate(E##TYPE),      \
+         g.UseImmediate(mf2));                                                \
+  }                                                                           \
+  template <typename Adapter>                                                 \
+  void InstructionSelectorT<Adapter>::Visit##OPCODE1##ExtMulHigh##OPCODE2##S( \
+      Node* node) {                                                           \
+    RiscvOperandGeneratorT<Adapter> g(this);                                  \
+    InstructionOperand t1 = g.TempFpRegister(v16);                            \
+    Emit(kRiscvVslidedown, t1, g.UseUniqueRegister(node->InputAt(0)),         \
+         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),        \
+         g.UseImmediate(m1));                                                 \
+    InstructionOperand t2 = g.TempFpRegister(v17);                            \
+    Emit(kRiscvVslidedown, t2, g.UseUniqueRegister(node->InputAt(1)),         \
+         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),        \
+         g.UseImmediate(m1));                                                 \
+    Emit(kRiscvVwmul, g.DefineAsRegister(node), t1, t2,                       \
+         g.UseImmediate(E##TYPE), g.UseImmediate(mf2));                       \
+  }                                                                           \
+  template <typename Adapter>                                                 \
+  void InstructionSelectorT<Adapter>::Visit##OPCODE1##ExtMulLow##OPCODE2##U(  \
+      Node* node) {                                                           \
+    RiscvOperandGeneratorT<Adapter> g(this);                                  \
+    Emit(kRiscvVwmulu, g.DefineAsRegister(node),                              \
+         g.UseUniqueRegister(node->InputAt(0)),                               \
+         g.UseUniqueRegister(node->InputAt(1)), g.UseImmediate(E##TYPE),      \
+         g.UseImmediate(mf2));                                                \
+  }                                                                           \
+  template <typename Adapter>                                                 \
+  void InstructionSelectorT<Adapter>::Visit##OPCODE1##ExtMulHigh##OPCODE2##U( \
+      Node* node) {                                                           \
+    RiscvOperandGeneratorT<Adapter> g(this);                                  \
+    InstructionOperand t1 = g.TempFpRegister(v16);                            \
+    Emit(kRiscvVslidedown, t1, g.UseUniqueRegister(node->InputAt(0)),         \
+         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),        \
+         g.UseImmediate(m1));                                                 \
+    InstructionOperand t2 = g.TempFpRegister(v17);                            \
+    Emit(kRiscvVslidedown, t2, g.UseUniqueRegister(node->InputAt(1)),         \
+         g.UseImmediate(kRvvVLEN / TYPE / 2), g.UseImmediate(E##TYPE),        \
+         g.UseImmediate(m1));                                                 \
+    Emit(kRiscvVwmulu, g.DefineAsRegister(node), t1, t2,                      \
+         g.UseImmediate(E##TYPE), g.UseImmediate(mf2));                       \
   }
 
 VISIT_EXT_MUL(I64x2, I32x4, 32)
@@ -1290,25 +1396,30 @@ VISIT_EXT_MUL(I32x4, I16x8, 16)
 VISIT_EXT_MUL(I16x8, I8x16, 8)
 #undef VISIT_EXT_MUL
 
-void InstructionSelector::VisitF32x4Pmin(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF32x4Pmin(Node* node) {
   VisitUniqueRRR(this, kRiscvF32x4Pmin, node);
 }
 
-void InstructionSelector::VisitF32x4Pmax(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF32x4Pmax(Node* node) {
   VisitUniqueRRR(this, kRiscvF32x4Pmax, node);
 }
 
-void InstructionSelector::VisitF64x2Pmin(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2Pmin(Node* node) {
   VisitUniqueRRR(this, kRiscvF64x2Pmin, node);
 }
 
-void InstructionSelector::VisitF64x2Pmax(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitF64x2Pmax(Node* node) {
   VisitUniqueRRR(this, kRiscvF64x2Pmax, node);
 }
 
 // static
+template <typename Adapter>
 MachineOperatorBuilder::AlignmentRequirements
-InstructionSelector::AlignmentRequirements() {
+InstructionSelectorT<Adapter>::AlignmentRequirements() {
 #ifdef RISCV_HAS_NO_UNALIGNED
   return MachineOperatorBuilder::AlignmentRequirements::
       NoUnalignedAccessSupport();
@@ -1318,9 +1429,9 @@ InstructionSelector::AlignmentRequirements() {
 #endif
 }
 
-void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
-                                                        int first_input_index,
-                                                        Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::AddOutputToSelectContinuation(
+    OperandGenerator* g, int first_input_index, Node* node) {
   UNREACHABLE();
 }
 }  // namespace compiler
diff --git a/src/compiler/backend/riscv/instruction-selector-riscv32.cc b/src/compiler/backend/riscv/instruction-selector-riscv32.cc
index 78ed60c534..48eff28d98 100644
--- a/src/compiler/backend/riscv/instruction-selector-riscv32.cc
+++ b/src/compiler/backend/riscv/instruction-selector-riscv32.cc
@@ -3,6 +3,8 @@
 // found in the LICENSE file.
 
 #include "src/base/bits.h"
+#include "src/codegen/assembler-inl.h"
+#include "src/codegen/machine-type.h"
 #include "src/compiler/backend/instruction-selector-impl.h"
 #include "src/compiler/backend/riscv/instruction-selector-riscv.h"
 #include "src/compiler/node-matchers.h"
@@ -12,17 +14,20 @@ namespace v8 {
 namespace internal {
 namespace compiler {
 
-bool RiscvOperandGenerator::IsIntegerConstant(Node* node) {
+template <typename Adapter>
+bool RiscvOperandGeneratorT<Adapter>::IsIntegerConstant(Node* node) {
   return (node->opcode() == IrOpcode::kInt32Constant);
 }
 
-int64_t RiscvOperandGenerator::GetIntegerConstantValue(Node* node) {
+template <typename Adapter>
+int64_t RiscvOperandGeneratorT<Adapter>::GetIntegerConstantValue(Node* node) {
   DCHECK_EQ(IrOpcode::kInt32Constant, node->opcode());
   return OpParameter<int32_t>(node->op());
 }
 
-bool RiscvOperandGenerator::CanBeImmediate(int64_t value,
-                                           InstructionCode opcode) {
+template <typename Adapter>
+bool RiscvOperandGeneratorT<Adapter>::CanBeImmediate(int64_t value,
+                                                     InstructionCode opcode) {
   switch (ArchOpcodeField::decode(opcode)) {
     case kRiscvShl32:
     case kRiscvSar32:
@@ -54,9 +59,10 @@ bool RiscvOperandGenerator::CanBeImmediate(int64_t value,
   }
 }
 
-void EmitLoad(InstructionSelector* selector, Node* node, InstructionCode opcode,
-              Node* output = nullptr) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+void EmitLoad(InstructionSelectorT<Adapter>* selector, Node* node,
+              InstructionCode opcode, Node* output = nullptr) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -100,9 +106,10 @@ void EmitLoad(InstructionSelector* selector, Node* node, InstructionCode opcode,
   }
 }
 
-void EmitS128Load(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void EmitS128Load(InstructionSelectorT<Adapter>* selector, Node* node,
                   InstructionCode opcode, VSew sew, Vlmul lmul) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -122,13 +129,14 @@ void EmitS128Load(InstructionSelector* selector, Node* node,
   }
 }
 
-void InstructionSelector::VisitStoreLane(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStoreLane(Node* node) {
   StoreLaneParameters params = StoreLaneParametersOf(node->op());
   LoadStoreLaneParams f(params.rep, params.laneidx);
   InstructionCode opcode = kRiscvS128StoreLane;
   opcode |= MiscField::encode(f.sz);
 
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   InstructionOperand addr_reg = g.TempRegister();
@@ -143,13 +151,14 @@ void InstructionSelector::VisitStoreLane(Node* node) {
   Emit(opcode, 0, nullptr, 4, inputs);
 }
 
-void InstructionSelector::VisitLoadLane(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoadLane(Node* node) {
   LoadLaneParameters params = LoadLaneParametersOf(node->op());
   LoadStoreLaneParams f(params.rep.representation(), params.laneidx);
   InstructionCode opcode = kRiscvS128LoadLane;
   opcode |= MiscField::encode(f.sz);
 
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   InstructionOperand addr_reg = g.TempRegister();
@@ -159,7 +168,8 @@ void InstructionSelector::VisitLoadLane(Node* node) {
        g.UseImmediate(params.laneidx), addr_reg, g.TempImmediate(0));
 }
 
-void InstructionSelector::VisitLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoad(Node* node) {
   LoadRepresentation load_rep = LoadRepresentationOf(node->op());
 
   InstructionCode opcode = kArchNop;
@@ -199,10 +209,14 @@ void InstructionSelector::VisitLoad(Node* node) {
   EmitLoad(this, node, opcode);
 }
 
-void InstructionSelector::VisitStorePair(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStorePair(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitStore(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStore(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -284,21 +298,25 @@ void InstructionSelector::VisitStore(Node* node) {
   }
 }
 
-void InstructionSelector::VisitWord32And(Node* node) {
-  VisitBinop(this, node, kRiscvAnd, true, kRiscvAnd);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32And(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAnd, true,
+                                         kRiscvAnd);
 }
 
-void InstructionSelector::VisitWord32Or(Node* node) {
-  VisitBinop(this, node, kRiscvOr, true, kRiscvOr);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Or(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvOr, true, kRiscvOr);
 }
 
-void InstructionSelector::VisitWord32Xor(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Xor(Node* node) {
   Int32BinopMatcher m(node);
   if (m.left().IsWord32Or() && CanCover(node, m.left().node()) &&
       m.right().Is(-1)) {
     Int32BinopMatcher mleft(m.left().node());
     if (!mleft.right().HasResolvedValue()) {
-      RiscvOperandGenerator g(this);
+      RiscvOperandGeneratorT<Adapter> g(this);
       Emit(kRiscvNor, g.DefineAsRegister(node),
            g.UseRegister(mleft.left().node()),
            g.UseRegister(mleft.right().node()));
@@ -307,59 +325,79 @@ void InstructionSelector::VisitWord32Xor(Node* node) {
   }
   if (m.right().Is(-1)) {
     // Use Nor for bit negation and eliminate constant loading for xori.
-    RiscvOperandGenerator g(this);
+    RiscvOperandGeneratorT<Adapter> g(this);
     Emit(kRiscvNor, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
          g.TempImmediate(0));
     return;
   }
-  VisitBinop(this, node, kRiscvXor, true, kRiscvXor);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvXor, true,
+                                         kRiscvXor);
 }
 
-void InstructionSelector::VisitWord32Rol(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Rol(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord32Ror(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Ror(Node* node) {
   VisitRRO(this, kRiscvRor32, node);
 }
 
-void InstructionSelector::VisitWord32Clz(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Clz(Node* node) {
   VisitRR(this, kRiscvClz32, node);
 }
 
-void InstructionSelector::VisitWord32ReverseBits(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32ReverseBits(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord64ReverseBytes(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64ReverseBytes(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord32ReverseBytes(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32ReverseBytes(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvByteSwap32, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitSimd128ReverseBytes(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSimd128ReverseBytes(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitWord32Ctz(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Ctz(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvCtz32, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitWord32Popcnt(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Popcnt(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvPopcnt32, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitInt32Add(Node* node) {
-  VisitBinop(this, node, kRiscvAdd32, true, kRiscvAdd32);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Add(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAdd32, true,
+                                         kRiscvAdd32);
 }
 
-void InstructionSelector::VisitInt32Sub(Node* node) {
-  VisitBinop(this, node, kRiscvSub32);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Sub(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvSub32);
 }
 
-void InstructionSelector::VisitInt32Mul(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Mul(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (m.right().HasResolvedValue() && m.right().ResolvedValue() > 0) {
     uint32_t value = static_cast<uint32_t>(m.right().ResolvedValue());
@@ -383,64 +421,76 @@ void InstructionSelector::VisitInt32Mul(Node* node) {
   VisitRRR(this, kRiscvMul32, node);
 }
 
-void InstructionSelector::VisitInt32MulHigh(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32MulHigh(Node* node) {
   VisitRRR(this, kRiscvMulHigh32, node);
 }
 
-void InstructionSelector::VisitUint32MulHigh(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32MulHigh(Node* node) {
   VisitRRR(this, kRiscvMulHighU32, node);
 }
 
-void InstructionSelector::VisitInt32Div(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Div(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Emit(kRiscvDiv32, g.DefineSameAsFirst(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitUint32Div(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32Div(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Emit(kRiscvDivU32, g.DefineSameAsFirst(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitInt32Mod(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Mod(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Emit(kRiscvMod32, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitUint32Mod(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32Mod(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Emit(kRiscvModU32, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitChangeFloat32ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat32ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDS, node);
 }
 
-void InstructionSelector::VisitRoundInt32ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundInt32ToFloat32(Node* node) {
   VisitRR(this, kRiscvCvtSW, node);
 }
 
-void InstructionSelector::VisitRoundUint32ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundUint32ToFloat32(Node* node) {
   VisitRR(this, kRiscvCvtSUw, node);
 }
 
-void InstructionSelector::VisitChangeInt32ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeInt32ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDW, node);
 }
 
-void InstructionSelector::VisitChangeUint32ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeUint32ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDUw, node);
 }
 
-void InstructionSelector::VisitTruncateFloat32ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat32ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionCode opcode = kRiscvTruncWS;
   TruncateKind kind = OpParameter<TruncateKind>(node->op());
   if (kind == TruncateKind::kSetOverflowToMin) {
@@ -449,8 +499,9 @@ void InstructionSelector::VisitTruncateFloat32ToInt32(Node* node) {
   Emit(opcode, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitTruncateFloat32ToUint32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat32ToUint32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionCode opcode = kRiscvTruncUwS;
   TruncateKind kind = OpParameter<TruncateKind>(node->op());
   if (kind == TruncateKind::kSetOverflowToMin) {
@@ -459,8 +510,9 @@ void InstructionSelector::VisitTruncateFloat32ToUint32(Node* node) {
   Emit(opcode, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitChangeFloat64ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat64ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* value = node->InputAt(0);
   if (CanCover(node, value)) {
     if (value->opcode() == IrOpcode::kChangeFloat32ToFloat64) {
@@ -473,77 +525,98 @@ void InstructionSelector::VisitChangeFloat64ToInt32(Node* node) {
   VisitRR(this, kRiscvTruncWD, node);
 }
 
-void InstructionSelector::VisitChangeFloat64ToUint32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat64ToUint32(Node* node) {
   VisitRR(this, kRiscvTruncUwD, node);
 }
 
-void InstructionSelector::VisitTruncateFloat64ToUint32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat64ToUint32(Node* node) {
   VisitRR(this, kRiscvTruncUwD, node);
 }
 
-void InstructionSelector::VisitBitcastFloat32ToInt32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitBitcastFloat32ToInt32(Node* node) {
   VisitRR(this, kRiscvBitcastFloat32ToInt32, node);
 }
 
-void InstructionSelector::VisitBitcastInt32ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitBitcastInt32ToFloat32(Node* node) {
   VisitRR(this, kRiscvBitcastInt32ToFloat32, node);
 }
 
-void InstructionSelector::VisitFloat64RoundDown(Node* node) { UNIMPLEMENTED(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundDown(Node* node) {
+  UNIMPLEMENTED();
+}
 
-void InstructionSelector::VisitFloat32RoundUp(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32RoundUp(Node* node) {
   VisitRR(this, kRiscvFloat32RoundUp, node);
 }
 
-void InstructionSelector::VisitFloat64RoundUp(Node* node) { UNIMPLEMENTED(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundUp(Node* node) {
+  UNIMPLEMENTED();
+}
 
-void InstructionSelector::VisitFloat32RoundTruncate(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32RoundTruncate(Node* node) {
   VisitRR(this, kRiscvFloat32RoundTruncate, node);
 }
 
-void InstructionSelector::VisitFloat64RoundTruncate(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundTruncate(Node* node) {
   UNIMPLEMENTED();
 }
 
-void InstructionSelector::VisitFloat64RoundTiesAway(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundTiesAway(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitFloat32RoundTiesEven(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32RoundTiesEven(Node* node) {
   VisitRR(this, kRiscvFloat32RoundTiesEven, node);
 }
 
-void InstructionSelector::VisitFloat64RoundTiesEven(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundTiesEven(Node* node) {
   UNIMPLEMENTED();
 }
 
-void InstructionSelector::VisitFloat32Neg(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Neg(Node* node) {
   VisitRR(this, kRiscvNegS, node);
 }
 
-void InstructionSelector::VisitFloat64Neg(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Neg(Node* node) {
   VisitRR(this, kRiscvNegD, node);
 }
 
-void InstructionSelector::VisitFloat64Ieee754Binop(Node* node,
-                                                   InstructionCode opcode) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Ieee754Binop(
+    Node* node, InstructionCode opcode) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(opcode, g.DefineAsFixed(node, fa0), g.UseFixed(node->InputAt(0), fa0),
        g.UseFixed(node->InputAt(1), fa1))
       ->MarkAsCall();
 }
 
-void InstructionSelector::VisitFloat64Ieee754Unop(Node* node,
-                                                  InstructionCode opcode) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Ieee754Unop(
+    Node* node, InstructionCode opcode) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(opcode, g.DefineAsFixed(node, fa0), g.UseFixed(node->InputAt(0), fa1))
       ->MarkAsCall();
 }
 
-void InstructionSelector::EmitPrepareArguments(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitPrepareArguments(
     ZoneVector<PushParameter>* arguments, const CallDescriptor* call_descriptor,
     Node* node) {
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
 
   // Prepare for C function call.
   if (call_descriptor->IsCFunctionCall()) {
@@ -574,9 +647,10 @@ void InstructionSelector::EmitPrepareArguments(
   }
 }
 
-void InstructionSelector::VisitUnalignedLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUnalignedLoad(Node* node) {
   LoadRepresentation load_rep = LoadRepresentationOf(node->op());
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -627,8 +701,9 @@ void InstructionSelector::VisitUnalignedLoad(Node* node) {
   }
 }
 
-void InstructionSelector::VisitUnalignedStore(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUnalignedStore(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -684,14 +759,16 @@ void InstructionSelector::VisitUnalignedStore(Node* node) {
 
 namespace {
 
-void VisitWordCompare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitWordCompare(InstructionSelectorT<Adapter>* selector, Node* node,
                       FlagsContinuation* cont) {
   VisitWordCompare(selector, node, kRiscvCmp, cont, false);
 }
 
-void VisitAtomicLoad(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitAtomicLoad(InstructionSelectorT<Adapter>* selector, Node* node,
                      ArchOpcode opcode, AtomicWidth width) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   if (g.CanBeImmediate(index, opcode)) {
@@ -710,9 +787,10 @@ void VisitAtomicLoad(InstructionSelector* selector, Node* node,
   }
 }
 
-void VisitAtomicStore(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitAtomicStore(InstructionSelectorT<Adapter>* selector, Node* node,
                       ArchOpcode opcode, AtomicWidth width) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -734,9 +812,10 @@ void VisitAtomicStore(InstructionSelector* selector, Node* node,
   }
 }
 
-void VisitAtomicBinop(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitAtomicBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                       ArchOpcode opcode) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -760,13 +839,14 @@ void VisitAtomicBinop(InstructionSelector* selector, Node* node,
 
 }  // namespace
 
-void InstructionSelector::VisitStackPointerGreaterThan(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStackPointerGreaterThan(
     Node* node, FlagsContinuation* cont) {
   StackCheckKind kind = StackCheckKindOf(node->op());
   InstructionCode opcode =
       kArchStackPointerGreaterThan | MiscField::encode(static_cast<int>(kind));
 
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
 
   // No outputs.
   InstructionOperand* const outputs = nullptr;
@@ -790,8 +870,9 @@ void InstructionSelector::VisitStackPointerGreaterThan(
 }
 
 // Shared routine for word comparisons against zero.
-void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
-                                               FlagsContinuation* cont) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWordCompareZero(
+    Node* user, Node* value, FlagsContinuation* cont) {
   // Try to combine with comparisons against 0 by simply inverting the branch.
   while (CanCover(user, value)) {
     if (value->opcode() == IrOpcode::kWord32Equal) {
@@ -861,13 +942,16 @@ void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
             switch (node->opcode()) {
               case IrOpcode::kInt32AddWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvAddOvf, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvAddOvf, cont);
               case IrOpcode::kInt32SubWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvSubOvf, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvSubOvf, cont);
               case IrOpcode::kInt32MulWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvMulOvf32, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvMulOvf32, cont);
               case IrOpcode::kInt64AddWithOverflow:
               case IrOpcode::kInt64SubWithOverflow:
                 TRACE_UNIMPL();
@@ -892,7 +976,8 @@ void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
   EmitWordCompareZero(this, value, cont);
 }
 
-void InstructionSelector::VisitWord32Equal(Node* const node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Equal(Node* const node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   Int32BinopMatcher m(node);
   if (m.right().Is(0)) {
@@ -902,56 +987,67 @@ void InstructionSelector::VisitWord32Equal(Node* const node) {
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kSignedLessThan, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kSignedLessThanOrEqual, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kUnsignedLessThan, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kUnsignedLessThanOrEqual, node);
   VisitWordCompare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32AddWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32AddWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvAddOvf, &cont);
+    return VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAddOvf,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvAddOvf, &cont);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAddOvf, &cont);
 }
 
-void InstructionSelector::VisitInt32SubWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32SubWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvSubOvf, &cont);
+    return VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvSubOvf,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvSubOvf, &cont);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvSubOvf, &cont);
 }
 
-void InstructionSelector::VisitInt32MulWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32MulWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvMulOvf32, &cont);
+    return VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvMulOvf32,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvMulOvf32, &cont);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvMulOvf32, &cont);
 }
 
-void InstructionSelector::VisitWord32AtomicLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicLoad(Node* node) {
   AtomicLoadParameters atomic_load_params = AtomicLoadParametersOf(node->op());
   LoadRepresentation load_rep = atomic_load_params.representation();
   ArchOpcode opcode;
@@ -974,7 +1070,8 @@ void InstructionSelector::VisitWord32AtomicLoad(Node* node) {
   VisitAtomicLoad(this, node, opcode, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord32AtomicStore(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicStore(Node* node) {
   AtomicStoreParameters store_params = AtomicStoreParametersOf(node->op());
   MachineRepresentation rep = store_params.representation();
   ArchOpcode opcode;
@@ -998,7 +1095,8 @@ void InstructionSelector::VisitWord32AtomicStore(Node* node) {
   VisitAtomicStore(this, node, opcode, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord32AtomicExchange(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicExchange(Node* node) {
   ArchOpcode opcode;
   MachineType type = AtomicOpType(node->op());
   if (type == MachineType::Int8()) {
@@ -1018,7 +1116,9 @@ void InstructionSelector::VisitWord32AtomicExchange(Node* node) {
   VisitAtomicExchange(this, node, opcode, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord32AtomicCompareExchange(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicCompareExchange(
+    Node* node) {
   ArchOpcode opcode;
   MachineType type = AtomicOpType(node->op());
   if (type == MachineType::Int8()) {
@@ -1038,7 +1138,8 @@ void InstructionSelector::VisitWord32AtomicCompareExchange(Node* node) {
   VisitAtomicCompareExchange(this, node, opcode, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord32AtomicBinaryOperation(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicBinaryOperation(
     Node* node, ArchOpcode int8_op, ArchOpcode uint8_op, ArchOpcode int16_op,
     ArchOpcode uint16_op, ArchOpcode word32_op) {
   ArchOpcode opcode;
@@ -1060,11 +1161,12 @@ void InstructionSelector::VisitWord32AtomicBinaryOperation(
   VisitAtomicBinop(this, node, opcode);
 }
 
-#define VISIT_ATOMIC_BINOP(op)                                           \
-  void InstructionSelector::VisitWord32Atomic##op(Node* node) {          \
-    VisitWord32AtomicBinaryOperation(                                    \
-        node, kAtomic##op##Int8, kAtomic##op##Uint8, kAtomic##op##Int16, \
-        kAtomic##op##Uint16, kAtomic##op##Word32);                       \
+#define VISIT_ATOMIC_BINOP(op)                                            \
+  template <typename Adapter>                                             \
+  void InstructionSelectorT<Adapter>::VisitWord32Atomic##op(Node* node) { \
+    VisitWord32AtomicBinaryOperation(                                     \
+        node, kAtomic##op##Int8, kAtomic##op##Uint8, kAtomic##op##Int16,  \
+        kAtomic##op##Uint16, kAtomic##op##Word32);                        \
   }
 VISIT_ATOMIC_BINOP(Add)
 VISIT_ATOMIC_BINOP(Sub)
@@ -1073,22 +1175,24 @@ VISIT_ATOMIC_BINOP(Or)
 VISIT_ATOMIC_BINOP(Xor)
 #undef VISIT_ATOMIC_BINOP
 
-void InstructionSelector::VisitInt32AbsWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32AbsWithOverflow(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitInt64AbsWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64AbsWithOverflow(Node* node) {
   UNREACHABLE();
 }
 
-template <unsigned N>
-static void VisitInt32PairBinop(InstructionSelector* selector,
+template <unsigned N, typename Adapter>
+static void VisitInt32PairBinop(InstructionSelectorT<Adapter>* selector,
                                 InstructionCode pair_opcode,
                                 InstructionCode single_opcode, Node* node) {
   static_assert(N == 3 || N == 4,
                 "Pair operations can only have 3 or 4 inputs");
 
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
 
   Node* projection1 = NodeProperties::FindProjection(node, 1);
 
@@ -1126,27 +1230,32 @@ static void VisitInt32PairBinop(InstructionSelector* selector,
   }
 }
 
-void InstructionSelector::VisitInt32PairAdd(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32PairAdd(Node* node) {
   VisitInt32PairBinop<4>(this, kRiscvAddPair, kRiscvAdd32, node);
 }
 
-void InstructionSelector::VisitInt32PairSub(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32PairSub(Node* node) {
   VisitInt32PairBinop<4>(this, kRiscvSubPair, kRiscvSub32, node);
 }
 
-void InstructionSelector::VisitInt32PairMul(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32PairMul(Node* node) {
   VisitInt32PairBinop<4>(this, kRiscvMulPair, kRiscvMul32, node);
 }
 
-void InstructionSelector::VisitI64x2SplatI32Pair(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2SplatI32Pair(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand low = g.UseRegister(node->InputAt(0));
   InstructionOperand high = g.UseRegister(node->InputAt(1));
   Emit(kRiscvI64x2SplatI32Pair, g.DefineAsRegister(node), low, high);
 }
 
-void InstructionSelector::VisitI64x2ReplaceLaneI32Pair(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitI64x2ReplaceLaneI32Pair(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand operand = g.UseRegister(node->InputAt(0));
   InstructionOperand lane = g.UseImmediate(OpParameter<int32_t>(node->op()));
   InstructionOperand low = g.UseRegister(node->InputAt(1));
@@ -1156,9 +1265,10 @@ void InstructionSelector::VisitI64x2ReplaceLaneI32Pair(Node* node) {
 }
 
 // Shared routine for multiple shift operations.
-static void VisitWord32PairShift(InstructionSelector* selector,
+template <typename Adapter>
+static void VisitWord32PairShift(InstructionSelectorT<Adapter>* selector,
                                  InstructionCode opcode, Node* node) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Int32Matcher m(node->InputAt(2));
   InstructionOperand shift_operand;
   if (m.HasResolvedValue()) {
@@ -1190,20 +1300,24 @@ static void VisitWord32PairShift(InstructionSelector* selector,
   selector->Emit(opcode, output_count, outputs, 3, inputs, temp_count, temps);
 }
 
-void InstructionSelector::VisitWord32PairShl(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32PairShl(Node* node) {
   VisitWord32PairShift(this, kRiscvShlPair, node);
 }
 
-void InstructionSelector::VisitWord32PairShr(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32PairShr(Node* node) {
   VisitWord32PairShift(this, kRiscvShrPair, node);
 }
 
-void InstructionSelector::VisitWord32PairSar(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32PairSar(Node* node) {
   VisitWord32PairShift(this, kRiscvSarPair, node);
 }
 
-void InstructionSelector::VisitWord32AtomicPairLoad(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairLoad(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   ArchOpcode opcode = kRiscvWord32AtomicPairLoad;
@@ -1232,8 +1346,9 @@ void InstructionSelector::VisitWord32AtomicPairLoad(Node* node) {
        temps);
 }
 
-void InstructionSelector::VisitWord32AtomicPairStore(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairStore(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value_low = node->InputAt(2);
@@ -1248,9 +1363,10 @@ void InstructionSelector::VisitWord32AtomicPairStore(Node* node) {
        nullptr, arraysize(inputs), inputs, arraysize(temps), temps);
 }
 
-static void VisitPairAtomicBinop(InstructionSelector* selector, Node* node,
-                                 ArchOpcode opcode) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+static void VisitPairAtomicBinop(InstructionSelectorT<Adapter>* selector,
+                                 Node* node, ArchOpcode opcode) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -1282,31 +1398,40 @@ static void VisitPairAtomicBinop(InstructionSelector* selector, Node* node,
                  temp_count, temps);
 }
 
-void InstructionSelector::VisitWord32AtomicPairAdd(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairAdd(Node* node) {
   VisitPairAtomicBinop(this, node, kRiscvWord32AtomicPairAdd);
 }
 
-void InstructionSelector::VisitWord32AtomicPairSub(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairSub(Node* node) {
   VisitPairAtomicBinop(this, node, kRiscvWord32AtomicPairSub);
 }
 
-void InstructionSelector::VisitWord32AtomicPairAnd(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairAnd(Node* node) {
   VisitPairAtomicBinop(this, node, kRiscvWord32AtomicPairAnd);
 }
 
-void InstructionSelector::VisitWord32AtomicPairOr(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairOr(Node* node) {
   VisitPairAtomicBinop(this, node, kRiscvWord32AtomicPairOr);
 }
 
-void InstructionSelector::VisitWord32AtomicPairXor(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairXor(Node* node) {
   VisitPairAtomicBinop(this, node, kRiscvWord32AtomicPairXor);
 }
 
-void InstructionSelector::VisitWord32AtomicPairExchange(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairExchange(Node* node) {
   VisitPairAtomicBinop(this, node, kRiscvWord32AtomicPairExchange);
 }
-void InstructionSelector::VisitWord32AtomicPairCompareExchange(Node* node) {
-  RiscvOperandGenerator g(this);
+
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicPairCompareExchange(
+    Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand inputs[] = {
       g.UseRegister(node->InputAt(0)),  g.UseRegister(node->InputAt(1)),
       g.UseFixed(node->InputAt(2), a1), g.UseFixed(node->InputAt(3), a2),
@@ -1335,8 +1460,9 @@ void InstructionSelector::VisitWord32AtomicPairCompareExchange(Node* node) {
        temps);
 }
 // static
+template <typename Adapter>
 MachineOperatorBuilder::Flags
-InstructionSelector::SupportedMachineOperatorFlags() {
+InstructionSelectorT<Adapter>::SupportedMachineOperatorFlags() {
   MachineOperatorBuilder::Flags flags = MachineOperatorBuilder::kNoFlags;
   return flags | MachineOperatorBuilder::kWord32Ctz |
          MachineOperatorBuilder::kWord32Ctz |
@@ -1351,6 +1477,10 @@ InstructionSelector::SupportedMachineOperatorFlags() {
 #undef TRACE_UNIMPL
 #undef TRACE
 
+template class EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
+    InstructionSelectorT<TurbofanAdapter>;
+template class EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
+    InstructionSelectorT<TurboshaftAdapter>;
 }  // namespace compiler
 }  // namespace internal
 }  // namespace v8
diff --git a/src/compiler/backend/riscv/instruction-selector-riscv64.cc b/src/compiler/backend/riscv/instruction-selector-riscv64.cc
index 3369833d47..c564e6d40c 100644
--- a/src/compiler/backend/riscv/instruction-selector-riscv64.cc
+++ b/src/compiler/backend/riscv/instruction-selector-riscv64.cc
@@ -14,7 +14,8 @@ namespace v8 {
 namespace internal {
 namespace compiler {
 
-bool RiscvOperandGenerator::IsIntegerConstant(Node* node) {
+template <typename Adapter>
+bool RiscvOperandGeneratorT<Adapter>::IsIntegerConstant(Node* node) {
   if (node->opcode() == IrOpcode::kNumberConstant) {
     const double value = OpParameter<double>(node->op());
     return base::bit_cast<int64_t>(value) == 0;
@@ -23,7 +24,8 @@ bool RiscvOperandGenerator::IsIntegerConstant(Node* node) {
          (node->opcode() == IrOpcode::kInt64Constant);
 }
 
-int64_t RiscvOperandGenerator::GetIntegerConstantValue(Node* node) {
+template <typename Adapter>
+int64_t RiscvOperandGeneratorT<Adapter>::GetIntegerConstantValue(Node* node) {
   if (node->opcode() == IrOpcode::kInt32Constant) {
     return OpParameter<int32_t>(node->op());
   } else if (node->opcode() == IrOpcode::kInt64Constant) {
@@ -35,8 +37,9 @@ int64_t RiscvOperandGenerator::GetIntegerConstantValue(Node* node) {
   return base::bit_cast<int64_t>(value);
 }
 
-bool RiscvOperandGenerator::CanBeImmediate(int64_t value,
-                                           InstructionCode opcode) {
+template <typename Adapter>
+bool RiscvOperandGeneratorT<Adapter>::CanBeImmediate(int64_t value,
+                                                     InstructionCode opcode) {
   switch (ArchOpcodeField::decode(opcode)) {
     case kRiscvShl32:
     case kRiscvSar32:
@@ -76,8 +79,9 @@ bool RiscvOperandGenerator::CanBeImmediate(int64_t value,
   }
 }
 
+template <typename Adapter>
 struct ExtendingLoadMatcher {
-  ExtendingLoadMatcher(Node* node, InstructionSelector* selector)
+  ExtendingLoadMatcher(Node* node, InstructionSelectorT<Adapter>* selector)
       : matches_(false), selector_(selector), base_(nullptr), immediate_(0) {
     Initialize(node);
   }
@@ -99,7 +103,7 @@ struct ExtendingLoadMatcher {
 
  private:
   bool matches_;
-  InstructionSelector* selector_;
+  InstructionSelectorT<Adapter>* selector_;
   Node* base_;
   int64_t immediate_;
   ArchOpcode opcode_;
@@ -124,7 +128,7 @@ struct ExtendingLoadMatcher {
         return;
       }
 
-      RiscvOperandGenerator g(selector_);
+      RiscvOperandGeneratorT<Adapter> g(selector_);
       Node* load = m.left().node();
       Node* offset = load->InputAt(1);
       base_ = load->InputAt(0);
@@ -141,10 +145,11 @@ struct ExtendingLoadMatcher {
   }
 };
 
-bool TryEmitExtendingLoad(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+bool TryEmitExtendingLoad(InstructionSelectorT<Adapter>* selector, Node* node,
                           Node* output_node) {
-  ExtendingLoadMatcher m(node, selector);
-  RiscvOperandGenerator g(selector);
+  ExtendingLoadMatcher<Adapter> m(node, selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   if (m.Matches()) {
     InstructionOperand inputs[2];
     inputs[0] = g.UseRegister(m.base());
@@ -160,9 +165,10 @@ bool TryEmitExtendingLoad(InstructionSelector* selector, Node* node,
   return false;
 }
 
-void EmitLoad(InstructionSelector* selector, Node* node, InstructionCode opcode,
-              Node* output = nullptr) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+void EmitLoad(InstructionSelectorT<Adapter>* selector, Node* node,
+              InstructionCode opcode, Node* output = nullptr) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -206,9 +212,10 @@ void EmitLoad(InstructionSelector* selector, Node* node, InstructionCode opcode,
   }
 }
 
-void EmitS128Load(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void EmitS128Load(InstructionSelectorT<Adapter>* selector, Node* node,
                   InstructionCode opcode, VSew sew, Vlmul lmul) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -228,13 +235,14 @@ void EmitS128Load(InstructionSelector* selector, Node* node,
   }
 }
 
-void InstructionSelector::VisitStoreLane(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStoreLane(Node* node) {
   StoreLaneParameters params = StoreLaneParametersOf(node->op());
   LoadStoreLaneParams f(params.rep, params.laneidx);
   InstructionCode opcode = kRiscvS128StoreLane;
   opcode |= MiscField::encode(f.sz);
 
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   InstructionOperand addr_reg = g.TempRegister();
@@ -248,13 +256,15 @@ void InstructionSelector::VisitStoreLane(Node* node) {
   opcode |= AddressingModeField::encode(kMode_MRI);
   Emit(opcode, 0, nullptr, 4, inputs);
 }
-void InstructionSelector::VisitLoadLane(Node* node) {
+
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoadLane(Node* node) {
   LoadLaneParameters params = LoadLaneParametersOf(node->op());
   LoadStoreLaneParams f(params.rep.representation(), params.laneidx);
   InstructionCode opcode = kRiscvS128LoadLane;
   opcode |= MiscField::encode(f.sz);
 
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   InstructionOperand addr_reg = g.TempRegister();
@@ -264,7 +274,8 @@ void InstructionSelector::VisitLoadLane(Node* node) {
        g.UseImmediate(params.laneidx), addr_reg, g.TempImmediate(0));
 }
 
-void InstructionSelector::VisitLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitLoad(Node* node) {
   LoadRepresentation load_rep = LoadRepresentationOf(node->op());
 
   InstructionCode opcode = kArchNop;
@@ -324,10 +335,14 @@ void InstructionSelector::VisitLoad(Node* node) {
   EmitLoad(this, node, opcode);
 }
 
-void InstructionSelector::VisitStorePair(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStorePair(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitStore(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStore(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -420,12 +435,15 @@ void InstructionSelector::VisitStore(Node* node) {
   }
 }
 
-void InstructionSelector::VisitWord32And(Node* node) {
-  VisitBinop(this, node, kRiscvAnd32, true, kRiscvAnd32);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32And(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAnd32, true,
+                                         kRiscvAnd32);
 }
 
-void InstructionSelector::VisitWord64And(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64And(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int64BinopMatcher m(node);
   if (m.left().IsWord64Shr() && CanCover(node, m.left().node()) &&
       m.right().HasResolvedValue()) {
@@ -458,24 +476,29 @@ void InstructionSelector::VisitWord64And(Node* node) {
       // Other cases fall through to the normal And operation.
     }
   }
-  VisitBinop(this, node, kRiscvAnd, true, kRiscvAnd);
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvAnd, true,
+                                         kRiscvAnd);
 }
 
-void InstructionSelector::VisitWord32Or(Node* node) {
-  VisitBinop(this, node, kRiscvOr32, true, kRiscvOr32);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Or(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvOr32, true,
+                                         kRiscvOr32);
 }
 
-void InstructionSelector::VisitWord64Or(Node* node) {
-  VisitBinop(this, node, kRiscvOr, true, kRiscvOr);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Or(Node* node) {
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvOr, true, kRiscvOr);
 }
 
-void InstructionSelector::VisitWord32Xor(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Xor(Node* node) {
   Int32BinopMatcher m(node);
   if (m.left().IsWord32Or() && CanCover(node, m.left().node()) &&
       m.right().Is(-1)) {
     Int32BinopMatcher mleft(m.left().node());
     if (!mleft.right().HasResolvedValue()) {
-      RiscvOperandGenerator g(this);
+      RiscvOperandGeneratorT<Adapter> g(this);
       Emit(kRiscvNor32, g.DefineAsRegister(node),
            g.UseRegister(mleft.left().node()),
            g.UseRegister(mleft.right().node()));
@@ -484,21 +507,23 @@ void InstructionSelector::VisitWord32Xor(Node* node) {
   }
   if (m.right().Is(-1)) {
     // Use Nor for bit negation and eliminate constant loading for xori.
-    RiscvOperandGenerator g(this);
+    RiscvOperandGeneratorT<Adapter> g(this);
     Emit(kRiscvNor32, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
          g.TempImmediate(0));
     return;
   }
-  VisitBinop(this, node, kRiscvXor32, true, kRiscvXor32);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvXor32, true,
+                                         kRiscvXor32);
 }
 
-void InstructionSelector::VisitWord64Xor(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Xor(Node* node) {
   Int64BinopMatcher m(node);
   if (m.left().IsWord64Or() && CanCover(node, m.left().node()) &&
       m.right().Is(-1)) {
     Int64BinopMatcher mleft(m.left().node());
     if (!mleft.right().HasResolvedValue()) {
-      RiscvOperandGenerator g(this);
+      RiscvOperandGeneratorT<Adapter> g(this);
       Emit(kRiscvNor, g.DefineAsRegister(node),
            g.UseRegister(mleft.left().node()),
            g.UseRegister(mleft.right().node()));
@@ -507,16 +532,18 @@ void InstructionSelector::VisitWord64Xor(Node* node) {
   }
   if (m.right().Is(-1)) {
     // Use Nor for bit negation and eliminate constant loading for xori.
-    RiscvOperandGenerator g(this);
+    RiscvOperandGeneratorT<Adapter> g(this);
     Emit(kRiscvNor, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
          g.TempImmediate(0));
     return;
   }
-  VisitBinop(this, node, kRiscvXor, true, kRiscvXor);
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvXor, true,
+                                         kRiscvXor);
 }
 
-void InstructionSelector::VisitWord64Shl(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Shl(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int64BinopMatcher m(node);
   if ((m.left().IsChangeInt32ToInt64() || m.left().IsChangeUint32ToUint64()) &&
       m.right().IsInRange(32, 63) && CanCover(node, m.left().node())) {
@@ -555,11 +582,13 @@ void InstructionSelector::VisitWord64Shl(Node* node) {
   VisitRRO(this, kRiscvShl64, node);
 }
 
-void InstructionSelector::VisitWord64Shr(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Shr(Node* node) {
   VisitRRO(this, kRiscvShr64, node);
 }
 
-void InstructionSelector::VisitWord64Sar(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Sar(Node* node) {
   if (TryEmitExtendingLoad(this, node, node)) return;
   Int64BinopMatcher m(node);
   if (m.left().IsChangeInt32ToInt64() && m.right().HasResolvedValue() &&
@@ -567,7 +596,7 @@ void InstructionSelector::VisitWord64Sar(Node* node) {
     if ((m.left().InputAt(0)->opcode() != IrOpcode::kLoad &&
          m.left().InputAt(0)->opcode() != IrOpcode::kLoadImmutable) ||
         !CanCover(m.left().node(), m.left().InputAt(0))) {
-      RiscvOperandGenerator g(this);
+      RiscvOperandGeneratorT<Adapter> g(this);
       Emit(kRiscvSar32, g.DefineAsRegister(node),
            g.UseRegister(m.left().node()->InputAt(0)),
            g.UseImmediate(m.right().node()));
@@ -577,86 +606,116 @@ void InstructionSelector::VisitWord64Sar(Node* node) {
   VisitRRO(this, kRiscvSar64, node);
 }
 
-void InstructionSelector::VisitWord32Rol(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Rol(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord64Rol(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Rol(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord32Ror(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Ror(Node* node) {
   VisitRRO(this, kRiscvRor32, node);
 }
 
-void InstructionSelector::VisitWord32Clz(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Clz(Node* node) {
   VisitRR(this, kRiscvClz32, node);
 }
 
-void InstructionSelector::VisitWord32ReverseBits(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32ReverseBits(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord64ReverseBits(Node* node) { UNREACHABLE(); }
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64ReverseBits(Node* node) {
+  UNREACHABLE();
+}
 
-void InstructionSelector::VisitWord64ReverseBytes(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64ReverseBytes(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvByteSwap64, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitWord32ReverseBytes(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32ReverseBytes(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvByteSwap32, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitSimd128ReverseBytes(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSimd128ReverseBytes(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitWord32Ctz(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Ctz(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvCtz32, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitWord64Ctz(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Ctz(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvCtz64, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitWord32Popcnt(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Popcnt(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvPopcnt32, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitWord64Popcnt(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Popcnt(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvPopcnt64, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitWord64Ror(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Ror(Node* node) {
   VisitRRO(this, kRiscvRor64, node);
 }
 
-void InstructionSelector::VisitWord64Clz(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Clz(Node* node) {
   VisitRR(this, kRiscvClz64, node);
 }
 
-void InstructionSelector::VisitInt32Add(Node* node) {
-  VisitBinop(this, node, kRiscvAdd32, true, kRiscvAdd32);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Add(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAdd32, true,
+                                         kRiscvAdd32);
 }
 
-void InstructionSelector::VisitInt64Add(Node* node) {
-  VisitBinop(this, node, kRiscvAdd64, true, kRiscvAdd64);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64Add(Node* node) {
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvAdd64, true,
+                                         kRiscvAdd64);
 }
 
-void InstructionSelector::VisitInt32Sub(Node* node) {
-  VisitBinop(this, node, kRiscvSub32);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Sub(Node* node) {
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvSub32);
 }
 
-void InstructionSelector::VisitInt64Sub(Node* node) {
-  VisitBinop(this, node, kRiscvSub64);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64Sub(Node* node) {
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvSub64);
 }
 
-void InstructionSelector::VisitInt32Mul(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Mul(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   if (m.right().HasResolvedValue() && m.right().ResolvedValue() > 0) {
     uint32_t value = static_cast<uint32_t>(m.right().ResolvedValue());
@@ -694,24 +753,29 @@ void InstructionSelector::VisitInt32Mul(Node* node) {
   VisitRRR(this, kRiscvMul32, node);
 }
 
-void InstructionSelector::VisitInt32MulHigh(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32MulHigh(Node* node) {
   VisitRRR(this, kRiscvMulHigh32, node);
 }
 
-void InstructionSelector::VisitInt64MulHigh(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64MulHigh(Node* node) {
   VisitRRR(this, kRiscvMulHigh64, node);
 }
 
-void InstructionSelector::VisitUint32MulHigh(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32MulHigh(Node* node) {
   VisitRRR(this, kRiscvMulHighU32, node);
 }
 
-void InstructionSelector::VisitUint64MulHigh(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint64MulHigh(Node* node) {
   VisitRRR(this, kRiscvMulHighU64, node);
 }
 
-void InstructionSelector::VisitInt64Mul(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64Mul(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int64BinopMatcher m(node);
   // TODO(dusmil): Add optimization for shifts larger than 32.
   if (m.right().HasResolvedValue() && m.right().ResolvedValue() > 0) {
@@ -736,8 +800,9 @@ void InstructionSelector::VisitInt64Mul(Node* node) {
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitInt32Div(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Div(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Node* left = node->InputAt(0);
   Node* right = node->InputAt(1);
@@ -758,15 +823,17 @@ void InstructionSelector::VisitInt32Div(Node* node) {
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitUint32Div(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32Div(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Emit(kRiscvDivU32, g.DefineSameAsFirst(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitInt32Mod(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32Mod(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Node* left = node->InputAt(0);
   Node* right = node->InputAt(1);
@@ -787,67 +854,79 @@ void InstructionSelector::VisitInt32Mod(Node* node) {
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitUint32Mod(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32Mod(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int32BinopMatcher m(node);
   Emit(kRiscvModU32, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitInt64Div(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64Div(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int64BinopMatcher m(node);
   Emit(kRiscvDiv64, g.DefineSameAsFirst(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitUint64Div(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint64Div(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int64BinopMatcher m(node);
   Emit(kRiscvDivU64, g.DefineSameAsFirst(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitInt64Mod(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64Mod(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int64BinopMatcher m(node);
   Emit(kRiscvMod64, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitUint64Mod(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint64Mod(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Int64BinopMatcher m(node);
   Emit(kRiscvModU64, g.DefineAsRegister(node), g.UseRegister(m.left().node()),
        g.UseRegister(m.right().node()));
 }
 
-void InstructionSelector::VisitChangeFloat32ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat32ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDS, node);
 }
 
-void InstructionSelector::VisitRoundInt32ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundInt32ToFloat32(Node* node) {
   VisitRR(this, kRiscvCvtSW, node);
 }
 
-void InstructionSelector::VisitRoundUint32ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundUint32ToFloat32(Node* node) {
   VisitRR(this, kRiscvCvtSUw, node);
 }
 
-void InstructionSelector::VisitChangeInt32ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeInt32ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDW, node);
 }
 
-void InstructionSelector::VisitChangeInt64ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeInt64ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDL, node);
 }
 
-void InstructionSelector::VisitChangeUint32ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeUint32ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDUw, node);
 }
 
-void InstructionSelector::VisitTruncateFloat32ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat32ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionCode opcode = kRiscvTruncWS;
   TruncateKind kind = OpParameter<TruncateKind>(node->op());
   if (kind == TruncateKind::kSetOverflowToMin) {
@@ -856,8 +935,9 @@ void InstructionSelector::VisitTruncateFloat32ToInt32(Node* node) {
   Emit(opcode, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitTruncateFloat32ToUint32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat32ToUint32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionCode opcode = kRiscvTruncUwS;
   TruncateKind kind = OpParameter<TruncateKind>(node->op());
   if (kind == TruncateKind::kSetOverflowToMin) {
@@ -866,8 +946,9 @@ void InstructionSelector::VisitTruncateFloat32ToUint32(Node* node) {
   Emit(opcode, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitChangeFloat64ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat64ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* value = node->InputAt(0);
   // Match ChangeFloat64ToInt32(Float64Round##OP) to corresponding instruction
   // which does rounding and conversion to integer format.
@@ -929,8 +1010,9 @@ void InstructionSelector::VisitChangeFloat64ToInt32(Node* node) {
   VisitRR(this, kRiscvTruncWD, node);
 }
 
-void InstructionSelector::VisitTryTruncateFloat64ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTryTruncateFloat64ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand inputs[] = {g.UseRegister(node->InputAt(0))};
   InstructionOperand outputs[2];
   size_t output_count = 0;
@@ -944,8 +1026,10 @@ void InstructionSelector::VisitTryTruncateFloat64ToInt32(Node* node) {
   this->Emit(kRiscvTruncWD, output_count, outputs, 1, inputs);
 }
 
-void InstructionSelector::VisitTryTruncateFloat64ToUint32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTryTruncateFloat64ToUint32(
+    Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand inputs[] = {g.UseRegister(node->InputAt(0))};
   InstructionOperand outputs[2];
   size_t output_count = 0;
@@ -959,24 +1043,29 @@ void InstructionSelector::VisitTryTruncateFloat64ToUint32(Node* node) {
   Emit(kRiscvTruncUwD, output_count, outputs, 1, inputs);
 }
 
-void InstructionSelector::VisitChangeFloat64ToInt64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat64ToInt64(Node* node) {
   VisitRR(this, kRiscvTruncLD, node);
 }
 
-void InstructionSelector::VisitChangeFloat64ToUint32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat64ToUint32(Node* node) {
   VisitRR(this, kRiscvTruncUwD, node);
 }
 
-void InstructionSelector::VisitChangeFloat64ToUint64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeFloat64ToUint64(Node* node) {
   VisitRR(this, kRiscvTruncUlD, node);
 }
 
-void InstructionSelector::VisitTruncateFloat64ToUint32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat64ToUint32(Node* node) {
   VisitRR(this, kRiscvTruncUwD, node);
 }
 
-void InstructionSelector::VisitTruncateFloat64ToInt64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateFloat64ToInt64(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionCode opcode = kRiscvTruncLD;
   TruncateKind kind = OpParameter<TruncateKind>(node->op());
   if (kind == TruncateKind::kSetOverflowToMin) {
@@ -985,8 +1074,9 @@ void InstructionSelector::VisitTruncateFloat64ToInt64(Node* node) {
   Emit(opcode, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitTryTruncateFloat32ToInt64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTryTruncateFloat32ToInt64(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand inputs[] = {g.UseRegister(node->InputAt(0))};
   InstructionOperand outputs[2];
   size_t output_count = 0;
@@ -1000,8 +1090,9 @@ void InstructionSelector::VisitTryTruncateFloat32ToInt64(Node* node) {
   this->Emit(kRiscvTruncLS, output_count, outputs, 1, inputs);
 }
 
-void InstructionSelector::VisitTryTruncateFloat64ToInt64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTryTruncateFloat64ToInt64(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand inputs[] = {g.UseRegister(node->InputAt(0))};
   InstructionOperand outputs[2];
   size_t output_count = 0;
@@ -1015,8 +1106,10 @@ void InstructionSelector::VisitTryTruncateFloat64ToInt64(Node* node) {
   Emit(kRiscvTruncLD, output_count, outputs, 1, inputs);
 }
 
-void InstructionSelector::VisitTryTruncateFloat32ToUint64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTryTruncateFloat32ToUint64(
+    Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   InstructionOperand inputs[] = {g.UseRegister(node->InputAt(0))};
   InstructionOperand outputs[2];
   size_t output_count = 0;
@@ -1030,8 +1123,10 @@ void InstructionSelector::VisitTryTruncateFloat32ToUint64(Node* node) {
   Emit(kRiscvTruncUlS, output_count, outputs, 1, inputs);
 }
 
-void InstructionSelector::VisitTryTruncateFloat64ToUint64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTryTruncateFloat64ToUint64(
+    Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
 
   InstructionOperand inputs[] = {g.UseRegister(node->InputAt(0))};
   InstructionOperand outputs[2];
@@ -1046,22 +1141,25 @@ void InstructionSelector::VisitTryTruncateFloat64ToUint64(Node* node) {
   Emit(kRiscvTruncUlD, output_count, outputs, 1, inputs);
 }
 
-void InstructionSelector::VisitBitcastWord32ToWord64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitBitcastWord32ToWord64(Node* node) {
   DCHECK(SmiValuesAre31Bits());
   DCHECK(COMPRESS_POINTERS_BOOL);
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvZeroExtendWord, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void EmitSignExtendWord(InstructionSelector* selector, Node* node) {
-  RiscvOperandGenerator g(selector);
+template <typename Adapter>
+void EmitSignExtendWord(InstructionSelectorT<Adapter>* selector, Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* value = node->InputAt(0);
   selector->Emit(kRiscvSignExtendWord, g.DefineAsRegister(node),
                  g.UseRegister(value));
 }
 
-void InstructionSelector::VisitChangeInt32ToInt64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeInt32ToInt64(Node* node) {
   Node* value = node->InputAt(0);
   if ((value->opcode() == IrOpcode::kLoad ||
        value->opcode() == IrOpcode::kLoadImmutable) &&
@@ -1098,7 +1196,9 @@ void InstructionSelector::VisitChangeInt32ToInt64(Node* node) {
   }
 }
 
-bool InstructionSelector::ZeroExtendsWord32ToWord64NoPhis(Node* node) {
+template <typename Adapter>
+bool InstructionSelectorT<Adapter>::ZeroExtendsWord32ToWord64NoPhis(
+    Node* node) {
   DCHECK_NE(node->opcode(), IrOpcode::kPhi);
   if (node->opcode() == IrOpcode::kLoad ||
       node->opcode() == IrOpcode::kLoadImmutable) {
@@ -1118,8 +1218,9 @@ bool InstructionSelector::ZeroExtendsWord32ToWord64NoPhis(Node* node) {
   return false;
 }
 
-void InstructionSelector::VisitChangeUint32ToUint64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitChangeUint32ToUint64(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* value = node->InputAt(0);
   if (ZeroExtendsWord32ToWord64(value)) {
     Emit(kArchNop, g.DefineSameAsFirst(node), g.Use(value));
@@ -1129,8 +1230,9 @@ void InstructionSelector::VisitChangeUint32ToUint64(Node* node) {
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitTruncateInt64ToInt32(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitTruncateInt64ToInt32(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* value = node->InputAt(0);
   if (CanCover(node, value)) {
     switch (value->opcode()) {
@@ -1162,97 +1264,118 @@ void InstructionSelector::VisitTruncateInt64ToInt32(Node* node) {
        g.UseRegister(node->InputAt(0)), g.TempImmediate(0));
 }
 
-void InstructionSelector::VisitRoundInt64ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundInt64ToFloat32(Node* node) {
   VisitRR(this, kRiscvCvtSL, node);
 }
 
-void InstructionSelector::VisitRoundInt64ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundInt64ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDL, node);
 }
 
-void InstructionSelector::VisitRoundUint64ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundUint64ToFloat32(Node* node) {
   VisitRR(this, kRiscvCvtSUl, node);
 }
 
-void InstructionSelector::VisitRoundUint64ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitRoundUint64ToFloat64(Node* node) {
   VisitRR(this, kRiscvCvtDUl, node);
 }
 
-void InstructionSelector::VisitBitcastFloat32ToInt32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitBitcastFloat32ToInt32(Node* node) {
   VisitRR(this, kRiscvBitcastFloat32ToInt32, node);
 }
 
-void InstructionSelector::VisitBitcastFloat64ToInt64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitBitcastFloat64ToInt64(Node* node) {
   VisitRR(this, kRiscvBitcastDL, node);
 }
 
-void InstructionSelector::VisitBitcastInt32ToFloat32(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitBitcastInt32ToFloat32(Node* node) {
   VisitRR(this, kRiscvBitcastInt32ToFloat32, node);
 }
 
-void InstructionSelector::VisitBitcastInt64ToFloat64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitBitcastInt64ToFloat64(Node* node) {
   VisitRR(this, kRiscvBitcastLD, node);
 }
 
-void InstructionSelector::VisitFloat64RoundDown(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundDown(Node* node) {
   VisitRR(this, kRiscvFloat64RoundDown, node);
 }
 
-void InstructionSelector::VisitFloat32RoundUp(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32RoundUp(Node* node) {
   VisitRR(this, kRiscvFloat32RoundUp, node);
 }
 
-void InstructionSelector::VisitFloat64RoundUp(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundUp(Node* node) {
   VisitRR(this, kRiscvFloat64RoundUp, node);
 }
 
-void InstructionSelector::VisitFloat32RoundTruncate(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32RoundTruncate(Node* node) {
   VisitRR(this, kRiscvFloat32RoundTruncate, node);
 }
 
-void InstructionSelector::VisitFloat64RoundTruncate(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundTruncate(Node* node) {
   VisitRR(this, kRiscvFloat64RoundTruncate, node);
 }
 
-void InstructionSelector::VisitFloat64RoundTiesAway(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundTiesAway(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitFloat32RoundTiesEven(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32RoundTiesEven(Node* node) {
   VisitRR(this, kRiscvFloat32RoundTiesEven, node);
 }
 
-void InstructionSelector::VisitFloat64RoundTiesEven(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64RoundTiesEven(Node* node) {
   VisitRR(this, kRiscvFloat64RoundTiesEven, node);
 }
 
-void InstructionSelector::VisitFloat32Neg(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat32Neg(Node* node) {
   VisitRR(this, kRiscvNegS, node);
 }
 
-void InstructionSelector::VisitFloat64Neg(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Neg(Node* node) {
   VisitRR(this, kRiscvNegD, node);
 }
 
-void InstructionSelector::VisitFloat64Ieee754Binop(Node* node,
-                                                   InstructionCode opcode) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Ieee754Binop(
+    Node* node, InstructionCode opcode) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(opcode, g.DefineAsFixed(node, fa0), g.UseFixed(node->InputAt(0), fa0),
        g.UseFixed(node->InputAt(1), fa1))
       ->MarkAsCall();
 }
 
-void InstructionSelector::VisitFloat64Ieee754Unop(Node* node,
-                                                  InstructionCode opcode) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitFloat64Ieee754Unop(
+    Node* node, InstructionCode opcode) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(opcode, g.DefineAsFixed(node, fa0), g.UseFixed(node->InputAt(0), fa1))
       ->MarkAsCall();
 }
 
-void InstructionSelector::EmitPrepareArguments(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::EmitPrepareArguments(
     ZoneVector<PushParameter>* arguments, const CallDescriptor* call_descriptor,
     Node* node) {
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
 
   // Prepare for C function call.
   if (call_descriptor->IsCFunctionCall()) {
@@ -1290,9 +1413,10 @@ void InstructionSelector::EmitPrepareArguments(
   }
 }
 
-void InstructionSelector::VisitUnalignedLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUnalignedLoad(Node* node) {
   LoadRepresentation load_rep = LoadRepresentationOf(node->op());
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -1345,8 +1469,9 @@ void InstructionSelector::VisitUnalignedLoad(Node* node) {
   }
 }
 
-void InstructionSelector::VisitUnalignedStore(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUnalignedStore(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -1425,9 +1550,10 @@ bool IsNodeUnsigned(Node* n) {
 #endif
 
 // Shared routine for multiple word compare operations.
-void VisitFullWord32Compare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitFullWord32Compare(InstructionSelectorT<Adapter>* selector, Node* node,
                             InstructionCode opcode, FlagsContinuation* cont) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   InstructionOperand leftOp = g.TempRegister();
   InstructionOperand rightOp = g.TempRegister();
 
@@ -1440,11 +1566,12 @@ void VisitFullWord32Compare(InstructionSelector* selector, Node* node,
 }
 
 #ifndef V8_COMPRESS_POINTERS
-void VisitOptimizedWord32Compare(InstructionSelector* selector, Node* node,
-                                 InstructionCode opcode,
+template <typename Adapter>
+void VisitOptimizedWord32Compare(InstructionSelectorT<Adapter>* selector,
+                                 Node* node, InstructionCode opcode,
                                  FlagsContinuation* cont) {
   if (v8_flags.debug_code) {
-    RiscvOperandGenerator g(selector);
+    RiscvOperandGeneratorT<Adapter> g(selector);
     InstructionOperand leftOp = g.TempRegister();
     InstructionOperand rightOp = g.TempRegister();
     InstructionOperand optimizedResult = g.TempRegister();
@@ -1471,7 +1598,8 @@ void VisitOptimizedWord32Compare(InstructionSelector* selector, Node* node,
   VisitWordCompare(selector, node, opcode, cont, false);
 }
 #endif
-void VisitWord32Compare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitWord32Compare(InstructionSelectorT<Adapter>* selector, Node* node,
                         FlagsContinuation* cont) {
   // RISC-V doesn't support Word32 compare instructions. Instead it relies
   // that the values in registers are correctly sign-extended and uses
@@ -1506,14 +1634,16 @@ void VisitWord32Compare(InstructionSelector* selector, Node* node,
 #endif
 }
 
-void VisitWord64Compare(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitWord64Compare(InstructionSelectorT<Adapter>* selector, Node* node,
                         FlagsContinuation* cont) {
   VisitWordCompare(selector, node, kRiscvCmp, cont, false);
 }
 
-void VisitAtomicLoad(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitAtomicLoad(InstructionSelectorT<Adapter>* selector, Node* node,
                      AtomicWidth width) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
 
@@ -1572,9 +1702,10 @@ void VisitAtomicLoad(InstructionSelector* selector, Node* node,
   }
 }
 
-void VisitAtomicStore(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitAtomicStore(InstructionSelectorT<Adapter>* selector, Node* node,
                       AtomicWidth width) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -1652,9 +1783,10 @@ void VisitAtomicStore(InstructionSelector* selector, Node* node,
   }
 }
 
-void VisitAtomicBinop(InstructionSelector* selector, Node* node,
+template <typename Adapter>
+void VisitAtomicBinop(InstructionSelectorT<Adapter>* selector, Node* node,
                       ArchOpcode opcode, AtomicWidth width) {
-  RiscvOperandGenerator g(selector);
+  RiscvOperandGeneratorT<Adapter> g(selector);
   Node* base = node->InputAt(0);
   Node* index = node->InputAt(1);
   Node* value = node->InputAt(2);
@@ -1679,13 +1811,14 @@ void VisitAtomicBinop(InstructionSelector* selector, Node* node,
 
 }  // namespace
 
-void InstructionSelector::VisitStackPointerGreaterThan(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitStackPointerGreaterThan(
     Node* node, FlagsContinuation* cont) {
   StackCheckKind kind = StackCheckKindOf(node->op());
   InstructionCode opcode =
       kArchStackPointerGreaterThan | MiscField::encode(static_cast<int>(kind));
 
-  RiscvOperandGenerator g(this);
+  RiscvOperandGeneratorT<Adapter> g(this);
 
   // No outputs.
   InstructionOperand* const outputs = nullptr;
@@ -1721,8 +1854,9 @@ bool CanCoverTrap(Node* user, Node* value) {
   return true;
 }
 // Shared routine for word comparisons against zero.
-void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
-                                               FlagsContinuation* cont) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWordCompareZero(
+    Node* user, Node* value, FlagsContinuation* cont) {
   // Try to combine with comparisons against 0 by simply inverting the branch.
   while (CanCover(user, value)) {
     if (value->opcode() == IrOpcode::kWord32Equal) {
@@ -1806,19 +1940,24 @@ void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
             switch (node->opcode()) {
               case IrOpcode::kInt32AddWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvAdd64, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvAdd64, cont);
               case IrOpcode::kInt32SubWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvSub64, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvSub64, cont);
               case IrOpcode::kInt32MulWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvMulOvf32, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvMulOvf32, cont);
               case IrOpcode::kInt64AddWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvAddOvf64, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvAddOvf64, cont);
               case IrOpcode::kInt64SubWithOverflow:
                 cont->OverwriteAndNegateIfEqual(kOverflow);
-                return VisitBinop(this, node, kRiscvSubOvf64, cont);
+                return VisitBinop<Adapter, Int32BinopMatcher>(
+                    this, node, kRiscvSubOvf64, cont);
               default:
                 break;
             }
@@ -1843,7 +1982,8 @@ void InstructionSelector::VisitWordCompareZero(Node* user, Node* value,
   EmitWordCompareZero(this, value, cont);
 }
 
-void InstructionSelector::VisitWord32Equal(Node* const node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32Equal(Node* const node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   Int32BinopMatcher m(node);
   if (m.right().Is(0)) {
@@ -1851,7 +1991,7 @@ void InstructionSelector::VisitWord32Equal(Node* const node) {
   }
   if (isolate() && (V8_STATIC_ROOTS_BOOL ||
                     (COMPRESS_POINTERS_BOOL && !isolate()->bootstrapper()))) {
-    RiscvOperandGenerator g(this);
+    RiscvOperandGeneratorT<Adapter> g(this);
     const RootsTable& roots_table = isolate()->roots_table();
     RootIndex root_index;
     Node* left = nullptr;
@@ -1887,74 +2027,89 @@ void InstructionSelector::VisitWord32Equal(Node* const node) {
   VisitWord32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kSignedLessThan, node);
   VisitWord32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kSignedLessThanOrEqual, node);
   VisitWord32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint32LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kUnsignedLessThan, node);
   VisitWord32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint32LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint32LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kUnsignedLessThanOrEqual, node);
   VisitWord32Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt32AddWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32AddWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvAdd64, &cont);
+    return VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAdd64,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvAdd64, &cont);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvAdd64, &cont);
 }
 
-void InstructionSelector::VisitInt32SubWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32SubWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvSub64, &cont);
+    return VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvSub64,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvSub64, &cont);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvSub64, &cont);
 }
 
-void InstructionSelector::VisitInt32MulWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32MulWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvMulOvf32, &cont);
+    return VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvMulOvf32,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvMulOvf32, &cont);
+  VisitBinop<Adapter, Int32BinopMatcher>(this, node, kRiscvMulOvf32, &cont);
 }
 
-void InstructionSelector::VisitInt64AddWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64AddWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvAddOvf64, &cont);
+    return VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvAddOvf64,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvAddOvf64, &cont);
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvAddOvf64, &cont);
 }
 
-void InstructionSelector::VisitInt64SubWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64SubWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     FlagsContinuation cont = FlagsContinuation::ForSet(kOverflow, ovf);
-    return VisitBinop(this, node, kRiscvSubOvf64, &cont);
+    return VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvSubOvf64,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvSubOvf64, &cont);
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvSubOvf64, &cont);
 }
 
-void InstructionSelector::VisitInt64MulWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64MulWithOverflow(Node* node) {
   if (Node* ovf = NodeProperties::FindProjection(node, 1)) {
     // RISCV64 doesn't set the overflow flag for multiplication, so we need to
     // test on kNotEqual. Here is the code sequence used:
@@ -1963,13 +2118,15 @@ void InstructionSelector::VisitInt64MulWithOverflow(Node* node) {
     //   srai temp, rdl, 63
     //   xor overflow, rdl, temp
     FlagsContinuation cont = FlagsContinuation::ForSet(kNotEqual, ovf);
-    return VisitBinop(this, node, kRiscvMulOvf64, &cont);
+    return VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvMulOvf64,
+                                                  &cont);
   }
   FlagsContinuation cont;
-  VisitBinop(this, node, kRiscvMulOvf64, &cont);
+  VisitBinop<Adapter, Int64BinopMatcher>(this, node, kRiscvMulOvf64, &cont);
 }
 
-void InstructionSelector::VisitWord64Equal(Node* const node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64Equal(Node* const node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kEqual, node);
   Int64BinopMatcher m(node);
   if (m.right().Is(0)) {
@@ -1979,45 +2136,54 @@ void InstructionSelector::VisitWord64Equal(Node* const node) {
   VisitWord64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt64LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kSignedLessThan, node);
   VisitWord64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitInt64LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kSignedLessThanOrEqual, node);
   VisitWord64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint64LessThan(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint64LessThan(Node* node) {
   FlagsContinuation cont = FlagsContinuation::ForSet(kUnsignedLessThan, node);
   VisitWord64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitUint64LessThanOrEqual(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitUint64LessThanOrEqual(Node* node) {
   FlagsContinuation cont =
       FlagsContinuation::ForSet(kUnsignedLessThanOrEqual, node);
   VisitWord64Compare(this, node, &cont);
 }
 
-void InstructionSelector::VisitWord32AtomicLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicLoad(Node* node) {
   VisitAtomicLoad(this, node, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord32AtomicStore(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicStore(Node* node) {
   VisitAtomicStore(this, node, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord64AtomicLoad(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64AtomicLoad(Node* node) {
   VisitAtomicLoad(this, node, AtomicWidth::kWord64);
 }
 
-void InstructionSelector::VisitWord64AtomicStore(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64AtomicStore(Node* node) {
   VisitAtomicStore(this, node, AtomicWidth::kWord64);
 }
 
-void InstructionSelector::VisitWord32AtomicExchange(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicExchange(Node* node) {
   ArchOpcode opcode;
   MachineType type = AtomicOpType(node->op());
   if (type == MachineType::Int8()) {
@@ -2037,7 +2203,8 @@ void InstructionSelector::VisitWord32AtomicExchange(Node* node) {
   VisitAtomicExchange(this, node, opcode, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord64AtomicExchange(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64AtomicExchange(Node* node) {
   ArchOpcode opcode;
   MachineType type = AtomicOpType(node->op());
   if (type == MachineType::Uint8()) {
@@ -2054,7 +2221,9 @@ void InstructionSelector::VisitWord64AtomicExchange(Node* node) {
   VisitAtomicExchange(this, node, opcode, AtomicWidth::kWord64);
 }
 
-void InstructionSelector::VisitWord32AtomicCompareExchange(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicCompareExchange(
+    Node* node) {
   ArchOpcode opcode;
   MachineType type = AtomicOpType(node->op());
   if (type == MachineType::Int8()) {
@@ -2074,7 +2243,9 @@ void InstructionSelector::VisitWord32AtomicCompareExchange(Node* node) {
   VisitAtomicCompareExchange(this, node, opcode, AtomicWidth::kWord32);
 }
 
-void InstructionSelector::VisitWord64AtomicCompareExchange(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64AtomicCompareExchange(
+    Node* node) {
   ArchOpcode opcode;
   MachineType type = AtomicOpType(node->op());
   if (type == MachineType::Uint8()) {
@@ -2090,7 +2261,8 @@ void InstructionSelector::VisitWord64AtomicCompareExchange(Node* node) {
   }
   VisitAtomicCompareExchange(this, node, opcode, AtomicWidth::kWord64);
 }
-void InstructionSelector::VisitWord32AtomicBinaryOperation(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord32AtomicBinaryOperation(
     Node* node, ArchOpcode int8_op, ArchOpcode uint8_op, ArchOpcode int16_op,
     ArchOpcode uint16_op, ArchOpcode word32_op) {
   ArchOpcode opcode;
@@ -2112,11 +2284,12 @@ void InstructionSelector::VisitWord32AtomicBinaryOperation(
   VisitAtomicBinop(this, node, opcode, AtomicWidth::kWord32);
 }
 
-#define VISIT_ATOMIC_BINOP(op)                                           \
-  void InstructionSelector::VisitWord32Atomic##op(Node* node) {          \
-    VisitWord32AtomicBinaryOperation(                                    \
-        node, kAtomic##op##Int8, kAtomic##op##Uint8, kAtomic##op##Int16, \
-        kAtomic##op##Uint16, kAtomic##op##Word32);                       \
+#define VISIT_ATOMIC_BINOP(op)                                            \
+  template <typename Adapter>                                             \
+  void InstructionSelectorT<Adapter>::VisitWord32Atomic##op(Node* node) { \
+    VisitWord32AtomicBinaryOperation(                                     \
+        node, kAtomic##op##Int8, kAtomic##op##Uint8, kAtomic##op##Int16,  \
+        kAtomic##op##Uint16, kAtomic##op##Word32);                        \
   }
 VISIT_ATOMIC_BINOP(Add)
 VISIT_ATOMIC_BINOP(Sub)
@@ -2125,7 +2298,8 @@ VISIT_ATOMIC_BINOP(Or)
 VISIT_ATOMIC_BINOP(Xor)
 #undef VISIT_ATOMIC_BINOP
 
-void InstructionSelector::VisitWord64AtomicBinaryOperation(
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitWord64AtomicBinaryOperation(
     Node* node, ArchOpcode uint8_op, ArchOpcode uint16_op, ArchOpcode uint32_op,
     ArchOpcode uint64_op) {
   ArchOpcode opcode;
@@ -2145,7 +2319,8 @@ void InstructionSelector::VisitWord64AtomicBinaryOperation(
 }
 
 #define VISIT_ATOMIC_BINOP(op)                                                 \
-  void InstructionSelector::VisitWord64Atomic##op(Node* node) {                \
+  template <typename Adapter>                                                  \
+  void InstructionSelectorT<Adapter>::VisitWord64Atomic##op(Node* node) {      \
     VisitWord64AtomicBinaryOperation(node, kAtomic##op##Uint8,                 \
                                      kAtomic##op##Uint16, kAtomic##op##Word32, \
                                      kRiscvWord64Atomic##op##Uint64);          \
@@ -2157,33 +2332,39 @@ VISIT_ATOMIC_BINOP(Or)
 VISIT_ATOMIC_BINOP(Xor)
 #undef VISIT_ATOMIC_BINOP
 
-void InstructionSelector::VisitInt32AbsWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt32AbsWithOverflow(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitInt64AbsWithOverflow(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitInt64AbsWithOverflow(Node* node) {
   UNREACHABLE();
 }
 
-void InstructionSelector::VisitSignExtendWord8ToInt64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSignExtendWord8ToInt64(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvSignExtendByte, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitSignExtendWord16ToInt64(Node* node) {
-  RiscvOperandGenerator g(this);
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSignExtendWord16ToInt64(Node* node) {
+  RiscvOperandGeneratorT<Adapter> g(this);
   Emit(kRiscvSignExtendShort, g.DefineAsRegister(node),
        g.UseRegister(node->InputAt(0)));
 }
 
-void InstructionSelector::VisitSignExtendWord32ToInt64(Node* node) {
+template <typename Adapter>
+void InstructionSelectorT<Adapter>::VisitSignExtendWord32ToInt64(Node* node) {
   EmitSignExtendWord(this, node);
 }
 
 // static
+template <typename Adapter>
 MachineOperatorBuilder::Flags
-InstructionSelector::SupportedMachineOperatorFlags() {
+InstructionSelectorT<Adapter>::SupportedMachineOperatorFlags() {
   MachineOperatorBuilder::Flags flags = MachineOperatorBuilder::kNoFlags;
   return flags | MachineOperatorBuilder::kWord32Ctz |
          MachineOperatorBuilder::kWord64Ctz |
@@ -2204,6 +2385,11 @@ InstructionSelector::SupportedMachineOperatorFlags() {
 #undef TRACE_UNIMPL
 #undef TRACE
 
+template class EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
+    InstructionSelectorT<TurbofanAdapter>;
+template class EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
+    InstructionSelectorT<TurboshaftAdapter>;
+
 }  // namespace compiler
 }  // namespace internal
 }  // namespace v8
-- 
2.35.1


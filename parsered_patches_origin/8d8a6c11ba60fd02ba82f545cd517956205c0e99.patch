From 8d8a6c11ba60fd02ba82f545cd517956205c0e99 Mon Sep 17 00:00:00 2001
From: jingpeiyang <jingpeiyang@eswincomputing.com>
Date: Mon, 15 May 2023 14:13:16 +0800
Subject: [PATCH] [riscv][simulator]Modify the implementation of the vfsgnj

Because the riscv32 simulator runs on x86_32, x86_32 will normalize the signaling_NaN in the return value. So modify the implementation of the vfsgnj/vfsgnjn/vfsgnjx in the simulator to adapt to riscv32 in the future.

Bug: v8:13986
Signed-off-by: jingpeiyang <jingpeiyang@eswincomputing.com>
Change-Id: Ic1dea994fc1938638fb2a6b7bb42579a465c6c3e
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4516778
Reviewed-by: Yahan Lu <yahan@iscas.ac.cn>
Commit-Queue: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#87724}
---
 src/diagnostics/riscv/disasm-riscv.cc  |   9 +-
 src/execution/riscv/simulator-riscv.cc | 117 +++++++++++++++++++++----
 test/cctest/test-assembler-riscv64.cc  |  41 +++++++++
 3 files changed, 146 insertions(+), 21 deletions(-)

diff --git a/src/diagnostics/riscv/disasm-riscv.cc b/src/diagnostics/riscv/disasm-riscv.cc
index 7419659ef0..8278ba069b 100644
--- a/src/diagnostics/riscv/disasm-riscv.cc
+++ b/src/diagnostics/riscv/disasm-riscv.cc
@@ -2114,7 +2114,7 @@ void Decoder::DecodeRvvIVI(Instruction* instr) {
       Format(instr, "vslidedown.vi 'vd, 'vs2, 'uimm5'vm");
       break;
     case RO_V_VSLIDEUP_VI:
-      Format(instr, "vslideup.vi   'vd, 'vs2, 'uimm5'vm");
+      Format(instr, "vslideup.vi 'vd, 'vs2, 'uimm5'vm");
       break;
     case RO_V_VSRL_VI:
       Format(instr, "vsrl.vi   'vd, 'vs2, 'uimm5'vm");
@@ -2169,7 +2169,10 @@ void Decoder::DecodeRvvIVX(Instruction* instr) {
       Format(instr, "vssub.vx  'vd, 'vs2, 'rs1'vm");
       break;
     case RO_V_VRSUB_VX:
-      Format(instr, "vrsub.vx  'vd, 'vs2, 'rs1'vm");
+      if (instr->Rs1Value() == zero_reg.code())
+        Format(instr, "vneg.vv   'vd, 'vs2'vm");
+      else
+        Format(instr, "vrsub.vx  'vd, 'vs2, 'rs1'vm");
       break;
     case RO_V_VMIN_VX:
       Format(instr, "vmin.vx   'vd, 'vs2, 'rs1'vm");
@@ -2489,7 +2492,7 @@ void Decoder::DecodeRvvFVV(Instruction* instr) {
       break;
     case RO_V_VFSGNJN_VV:
       if (instr->Vs1Value() == instr->Vs2Value()) {
-        Format(instr, "vneg.vv   'vd, 'vs1'vm");
+        Format(instr, "vfneg.vv  'vd, 'vs1'vm");
       } else {
         Format(instr, "vfsgnjn.vv   'vd, 'vs2, 'vs1'vm");
       }
diff --git a/src/execution/riscv/simulator-riscv.cc b/src/execution/riscv/simulator-riscv.cc
index 7e43f92cf4..d670a05f56 100644
--- a/src/execution/riscv/simulator-riscv.cc
+++ b/src/execution/riscv/simulator-riscv.cc
@@ -930,6 +930,36 @@ struct type_sew_t<128> {
   RVV_VI_VFP_LOOP_END                                     \
   rvv_trace_vd();
 
+#define RVV_VFSGNJ_VV_VF_LOOP(BODY16, BODY32, BODY64)         \
+  RVV_VI_VFP_LOOP_BASE                                        \
+  switch (rvv_vsew()) {                                       \
+    case E16: {                                               \
+      UNIMPLEMENTED();                                        \
+      break;                                                  \
+    }                                                         \
+    case E32: {                                               \
+      uint32_t& vd = Rvvelt<uint32_t>(rvv_vd_reg(), i, true); \
+      uint32_t vs1 = Rvvelt<uint32_t>(rvv_vs1_reg(), i);      \
+      uint32_t vs2 = Rvvelt<uint32_t>(rvv_vs2_reg(), i);      \
+      Float32 fs1 = get_fpu_register_Float32(rs1_reg());      \
+      BODY32;                                                 \
+      break;                                                  \
+    }                                                         \
+    case E64: {                                               \
+      uint64_t& vd = Rvvelt<uint64_t>(rvv_vd_reg(), i, true); \
+      uint64_t vs1 = Rvvelt<uint64_t>(rvv_vs1_reg(), i);      \
+      uint64_t vs2 = Rvvelt<uint64_t>(rvv_vs2_reg(), i);      \
+      Float64 fs1 = get_fpu_register_Float64(rs1_reg());      \
+      BODY64;                                                 \
+      break;                                                  \
+    }                                                         \
+    default:                                                  \
+      require(0);                                             \
+      break;                                                  \
+  }                                                           \
+  RVV_VI_VFP_LOOP_END                                         \
+  rvv_trace_vd();
+
 #define RVV_VI_VFP_VF_LOOP_WIDEN(BODY32, vs2_is_widen)                         \
   RVV_VI_VFP_LOOP_BASE                                                         \
   switch (rvv_vsew()) {                                                        \
@@ -6912,19 +6942,49 @@ void Simulator::DecodeRvvFVV() {
       break;
     }
     case RO_V_VFSGNJ_VV:
-      RVV_VI_VFP_VV_LOOP({ UNIMPLEMENTED(); },
-                         { vd = fsgnj32(vs2, vs1, false, false); },
-                         { vd = fsgnj64(vs2, vs1, false, false); })
+      RVV_VFSGNJ_VV_VF_LOOP({ UNIMPLEMENTED(); },
+                            {
+                              vd = fsgnj32(Float32::FromBits(vs2),
+                                           Float32::FromBits(vs1), false, false)
+                                       .get_bits();
+                              USE(fs1);
+                            },
+                            {
+                              vd = fsgnj64(Float64::FromBits(vs2),
+                                           Float64::FromBits(vs1), false, false)
+                                       .get_bits();
+                              USE(fs1);
+                            })
       break;
     case RO_V_VFSGNJN_VV:
-      RVV_VI_VFP_VV_LOOP({ UNIMPLEMENTED(); },
-                         { vd = fsgnj32(vs2, vs1, true, false); },
-                         { vd = fsgnj64(vs2, vs1, true, false); })
+      RVV_VFSGNJ_VV_VF_LOOP({ UNIMPLEMENTED(); },
+                            {
+                              vd = fsgnj32(Float32::FromBits(vs2),
+                                           Float32::FromBits(vs1), true, false)
+                                       .get_bits();
+                              USE(fs1);
+                            },
+                            {
+                              vd = fsgnj64(Float64::FromBits(vs2),
+                                           Float64::FromBits(vs1), true, false)
+                                       .get_bits();
+                              USE(fs1);
+                            })
       break;
     case RO_V_VFSGNJX_VV:
-      RVV_VI_VFP_VV_LOOP({ UNIMPLEMENTED(); },
-                         { vd = fsgnj32(vs2, vs1, false, true); },
-                         { vd = fsgnj64(vs2, vs1, false, true); })
+      RVV_VFSGNJ_VV_VF_LOOP({ UNIMPLEMENTED(); },
+                            {
+                              vd = fsgnj32(Float32::FromBits(vs2),
+                                           Float32::FromBits(vs1), false, true)
+                                       .get_bits();
+                              USE(fs1);
+                            },
+                            {
+                              vd = fsgnj64(Float64::FromBits(vs2),
+                                           Float64::FromBits(vs1), false, true)
+                                       .get_bits();
+                              USE(fs1);
+                            })
       break;
     case RO_V_VFADD_VV:
       RVV_VI_VFP_VV_LOOP(
@@ -7170,19 +7230,40 @@ void Simulator::DecodeRvvFVF() {
   DCHECK_EQ(instr_.InstructionBits() & (kBaseOpcodeMask | kFunct3Mask), OP_FVF);
   switch (instr_.InstructionBits() & kVTypeMask) {
     case RO_V_VFSGNJ_VF:
-      RVV_VI_VFP_VF_LOOP(
-          {}, { vd = fsgnj32(vs2, fs1, false, false); },
-          { vd = fsgnj64(vs2, fs1, false, false); })
+      RVV_VFSGNJ_VV_VF_LOOP(
+          {},
+          {
+            vd = fsgnj32(Float32::FromBits(vs2), fs1, false, false).get_bits();
+            USE(vs1);
+          },
+          {
+            vd = fsgnj64(Float64::FromBits(vs2), fs1, false, false).get_bits();
+            USE(vs1);
+          })
       break;
     case RO_V_VFSGNJN_VF:
-      RVV_VI_VFP_VF_LOOP(
-          {}, { vd = fsgnj32(vs2, fs1, true, false); },
-          { vd = fsgnj64(vs2, fs1, true, false); })
+      RVV_VFSGNJ_VV_VF_LOOP(
+          {},
+          {
+            vd = fsgnj32(Float32::FromBits(vs2), fs1, true, false).get_bits();
+            USE(vs1);
+          },
+          {
+            vd = fsgnj64(Float64::FromBits(vs2), fs1, true, false).get_bits();
+            USE(vs1);
+          })
       break;
     case RO_V_VFSGNJX_VF:
-      RVV_VI_VFP_VF_LOOP(
-          {}, { vd = fsgnj32(vs2, fs1, false, true); },
-          { vd = fsgnj64(vs2, fs1, false, true); })
+      RVV_VFSGNJ_VV_VF_LOOP(
+          {},
+          {
+            vd = fsgnj32(Float32::FromBits(vs2), fs1, false, true).get_bits();
+            USE(vs1);
+          },
+          {
+            vd = fsgnj64(Float64::FromBits(vs2), fs1, false, true).get_bits();
+            USE(vs1);
+          })
       break;
     case RO_V_VFMV_VF:
       if (instr_.RvvVM()) {
diff --git a/test/cctest/test-assembler-riscv64.cc b/test/cctest/test-assembler-riscv64.cc
index 8267fd27f8..0d1643e806 100644
--- a/test/cctest/test-assembler-riscv64.cc
+++ b/test/cctest/test-assembler-riscv64.cc
@@ -2110,6 +2110,47 @@ TEST(RVV_VFMV_signaling_NaN) {
   }
 }
 
+TEST(RVV_VFNEG_signaling_NaN) {
+  if (!CpuFeatures::IsSupported(RISCV_SIMD)) return;
+  CcTest::InitializeVM();
+
+  {
+    constexpr uint32_t n = 2;
+    int64_t rs1_fval = 0x7FF4000000000000;
+    int64_t expected_fval = 0xFFF4000000000000;
+    int64_t dst[n] = {0};
+    auto fn = [](MacroAssembler& assm) {
+      __ VU.set(t0, VSew::E64, Vlmul::m1);
+      __ fmv_d_x(ft0, a0);
+      __ vfmv_vf(v1, ft0);
+      __ vfneg_vv(v2, v1);
+      __ vs(v2, a1, 0, VSew::E64);
+    };
+    GenAndRunTest<int64_t, int64_t>((int64_t)rs1_fval, (int64_t)dst, fn);
+    for (uint32_t i = 0; i < n; i++) {
+      CHECK_EQ(expected_fval, dst[i]);
+    }
+  }
+
+  {
+    constexpr uint32_t n = 4;
+    int32_t rs1_fval = 0x7F400000;
+    int32_t expected_fval = 0xFF400000;
+    int32_t dst[n] = {0};
+    auto fn = [](MacroAssembler& assm) {
+      __ VU.set(t0, VSew::E32, Vlmul::m1);
+      __ fmv_w_x(ft0, a0);
+      __ vfmv_vf(v1, ft0);
+      __ vfneg_vv(v2, v1);
+      __ vs(v2, a1, 0, VSew::E32);
+    };
+    GenAndRunTest<int64_t, int64_t>((int64_t)rs1_fval, (int64_t)dst, fn);
+    for (uint32_t i = 0; i < n; i++) {
+      CHECK_EQ(expected_fval, dst[i]);
+    }
+  }
+}
+
 // Tests for Floating-Point scalar move instructions between vector and scalar f
 // register
 #define UTEST_RVV_VF_MV_FORM_WITH_RES(instr_name, reg1, reg2, width, type)   \
-- 
2.35.1


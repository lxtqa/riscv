From 8a0d1b6fe5874d6645da3719d1ccce9b15df18b9 Mon Sep 17 00:00:00 2001
From: Leszek Swirski <leszeks@chromium.org>
Date: Mon, 14 Mar 2022 13:14:35 +0100
Subject: [PATCH] [codegen] Change RegList into a class

Modernise the RegList interface to be a proper class, rather than a
typedef to an integer, and add proper methods onto it rather than ad-hoc
bit manipulation.

In particular, this makes RegList typesafe, adding a DoubleRegList for
DoubleRegisters.

The Arm64 CPURegList isn't updated to use (or extend) the new RegList
interface, because of its weird type-erasing semantics (it can store
Registers and VRegisters). Maybe in the future we'll want to get rid of
CPURegList entirely and use RegList/DoubleRegList directly.

Change-Id: I3cb2a4d386cb92a4dcd2edbdd3fba9ef71f354d6
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3516747
Commit-Queue: Leszek Swirski <leszeks@chromium.org>
Reviewed-by: Jakob Gruber <jgruber@chromium.org>
Reviewed-by: Camillo Bruni <cbruni@chromium.org>
Reviewed-by: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#79460}
---
 BUILD.bazel                                   |   9 +
 BUILD.gn                                      |  13 +
 .../loong64/baseline-assembler-loong64-inl.h  |   2 +-
 .../mips/baseline-assembler-mips-inl.h        |   2 +-
 .../mips64/baseline-assembler-mips64-inl.h    |   2 +-
 src/builtins/arm/builtins-arm.cc              |  37 ++-
 src/builtins/arm64/builtins-arm64.cc          |  31 +--
 src/builtins/ia32/builtins-ia32.cc            |  22 +-
 src/builtins/loong64/builtins-loong64.cc      |  30 +--
 src/builtins/mips/builtins-mips.cc            |  28 +--
 src/builtins/mips64/builtins-mips64.cc        |  28 +--
 src/builtins/ppc/builtins-ppc.cc              |  27 +-
 src/builtins/riscv64/builtins-riscv64.cc      |  34 +--
 src/builtins/s390/builtins-s390.cc            |  16 +-
 src/builtins/x64/builtins-x64.cc              |  22 +-
 src/codegen/arm/assembler-arm.cc              |  16 +-
 src/codegen/arm/assembler-arm.h               |  16 +-
 .../arm/interface-descriptors-arm-inl.h       |  18 +-
 src/codegen/arm/macro-assembler-arm.cc        |  92 ++-----
 src/codegen/arm/macro-assembler-arm.h         |  37 ++-
 src/codegen/arm/register-arm.h                |  37 +--
 src/codegen/arm/reglist-arm.h                 |  56 +++++
 src/codegen/arm64/assembler-arm64-inl.h       |   4 +-
 src/codegen/arm64/assembler-arm64.cc          |   8 +-
 .../arm64/interface-descriptors-arm64-inl.h   |  19 +-
 src/codegen/arm64/macro-assembler-arm64.cc    |  36 +--
 src/codegen/arm64/macro-assembler-arm64.h     |  52 ++--
 src/codegen/arm64/register-arm64.h            | 161 ------------
 src/codegen/arm64/reglist-arm64.h             | 176 +++++++++++++
 .../ia32/interface-descriptors-ia32-inl.h     |   4 +-
 src/codegen/ia32/macro-assembler-ia32.cc      |  16 +-
 src/codegen/ia32/register-ia32.h              |  10 -
 src/codegen/ia32/reglist-ia32.h               |  30 +++
 src/codegen/interface-descriptors-inl.h       |  12 +-
 src/codegen/interface-descriptors.cc          |  10 +-
 src/codegen/interface-descriptors.h           |   8 +-
 src/codegen/loong64/assembler-loong64.cc      |   2 +-
 src/codegen/loong64/assembler-loong64.h       |   4 +-
 .../interface-descriptors-loong64-inl.h       |  16 +-
 .../loong64/macro-assembler-loong64.cc        |  82 ++-----
 src/codegen/loong64/register-loong64.h        |  70 ------
 src/codegen/loong64/reglist-loong64.h         |  50 ++++
 src/codegen/mips/assembler-mips.cc            |   3 +-
 src/codegen/mips/assembler-mips.h             |   4 +-
 .../mips/interface-descriptors-mips-inl.h     |   8 +-
 src/codegen/mips/macro-assembler-mips.cc      |  82 ++-----
 src/codegen/mips/register-mips.h              |  58 -----
 src/codegen/mips/reglist-mips.h               |  57 +++++
 src/codegen/mips64/assembler-mips64.cc        |   2 +-
 src/codegen/mips64/assembler-mips64.h         |   4 +-
 .../mips64/interface-descriptors-mips64-inl.h |  16 +-
 src/codegen/mips64/macro-assembler-mips64.cc  |  84 ++-----
 src/codegen/mips64/register-mips64.h          |  52 ----
 src/codegen/mips64/reglist-mips64.h           |  57 +++++
 src/codegen/ppc/assembler-ppc.cc              |   8 +-
 .../ppc/interface-descriptors-ppc-inl.h       |  16 +-
 src/codegen/ppc/macro-assembler-ppc.cc        |  84 ++-----
 src/codegen/ppc/register-ppc.h                |  80 ------
 src/codegen/ppc/reglist-ppc.h                 |  59 +++++
 src/codegen/register-arch.h                   |  34 +++
 src/codegen/register-base.h                   |  34 ---
 src/codegen/register-configuration.cc         |   4 +-
 src/codegen/register-configuration.h          |  11 -
 src/codegen/register.h                        |  56 +----
 src/codegen/reglist-base.h                    | 232 ++++++++++++++++++
 src/codegen/reglist.h                         |  58 +++--
 src/codegen/riscv64/assembler-riscv64.cc      |   2 +-
 src/codegen/riscv64/assembler-riscv64.h       |   4 +-
 .../interface-descriptors-riscv64-inl.h       |  16 +-
 .../riscv64/macro-assembler-riscv64.cc        |  97 ++------
 src/codegen/riscv64/register-riscv64.h        |   6 +-
 src/codegen/riscv64/reglist-riscv64.h         |  64 +++++
 src/codegen/s390/assembler-s390.cc            |   9 +-
 .../s390/interface-descriptors-s390-inl.h     |  16 +-
 src/codegen/s390/macro-assembler-s390.cc      |  84 ++-----
 src/codegen/s390/register-s390.h              |  52 ----
 src/codegen/s390/reglist-s390.h               |  57 +++++
 .../x64/interface-descriptors-x64-inl.h       |   8 +-
 src/codegen/x64/macro-assembler-x64.cc        |  16 +-
 src/codegen/x64/register-x64.h                |  16 --
 src/codegen/x64/reglist-x64.h                 |  37 +++
 src/common/globals.h                          |  11 +
 .../backend/arm/code-generator-arm.cc         |  49 ++--
 .../backend/arm64/code-generator-arm64.cc     |  32 +--
 .../backend/ia32/code-generator-ia32.cc       |  37 ++-
 .../backend/loong64/code-generator-loong64.cc |  16 +-
 .../backend/mips/code-generator-mips.cc       |  16 +-
 .../backend/mips64/code-generator-mips64.cc   |  16 +-
 .../backend/ppc/code-generator-ppc.cc         |  53 ++--
 .../backend/riscv64/code-generator-riscv64.cc |  16 +-
 .../backend/s390/code-generator-s390.cc       |  29 ++-
 .../backend/x64/code-generator-x64.cc         |  76 +++---
 src/compiler/c-linkage.cc                     | 104 +++-----
 src/compiler/linkage.cc                       |  10 +-
 src/compiler/linkage.h                        |  15 +-
 src/compiler/pipeline.cc                      |   4 +-
 src/compiler/wasm-compiler.cc                 |   6 +-
 src/execution/arm/frame-constants-arm.h       |  26 +-
 src/execution/arm64/frame-constants-arm64.h   |  29 ++-
 src/execution/arm64/simulator-arm64.cc        |   2 +-
 src/execution/ia32/frame-constants-ia32.h     |  25 +-
 .../loong64/frame-constants-loong64.h         |  18 +-
 src/execution/mips/frame-constants-mips.h     |  18 +-
 src/execution/mips64/frame-constants-mips64.h |  18 +-
 src/execution/ppc/frame-constants-ppc.h       |  28 +--
 .../riscv64/frame-constants-riscv64.h         |  24 +-
 src/execution/s390/frame-constants-s390.h     |  25 +-
 src/execution/x64/frame-constants-x64.h       |  25 +-
 src/maglev/maglev-interpreter-frame-state.h   |   9 +-
 src/maglev/maglev-ir.cc                       |   2 +-
 src/maglev/maglev-ir.h                        |  12 +-
 src/maglev/maglev-regalloc.cc                 |  45 ++--
 src/maglev/maglev-regalloc.h                  |   6 +-
 src/regexp/arm/regexp-macro-assembler-arm.cc  |   9 +-
 .../loong64/regexp-macro-assembler-loong64.cc |  11 +-
 .../mips/regexp-macro-assembler-mips.cc       |   9 +-
 .../mips64/regexp-macro-assembler-mips64.cc   |  11 +-
 src/regexp/ppc/regexp-macro-assembler-ppc.cc  |  17 +-
 .../riscv64/regexp-macro-assembler-riscv64.cc |  32 ++-
 .../s390/regexp-macro-assembler-s390.cc       |  14 +-
 src/wasm/baseline/arm/liftoff-assembler-arm.h |  13 +-
 .../baseline/arm64/liftoff-assembler-arm64.h  |  13 +-
 .../baseline/ia32/liftoff-assembler-ia32.h    |   4 +-
 src/wasm/baseline/liftoff-assembler-defs.h    |  94 +++----
 src/wasm/baseline/liftoff-compiler.cc         |   2 +-
 src/wasm/baseline/liftoff-register.h          |  27 +-
 src/wasm/baseline/x64/liftoff-assembler-x64.h |   7 +-
 test/cctest/compiler/test-code-generator.cc   |   9 +-
 test/cctest/compiler/test-run-native-calls.cc |   4 +-
 test/cctest/compiler/test-run-tail-calls.cc   |   2 +-
 test/cctest/test-assembler-arm.cc             |  59 +++--
 test/cctest/test-assembler-arm64.cc           | 126 +++++-----
 test/cctest/test-assembler-ppc.cc             |  16 +-
 test/cctest/test-macro-assembler-arm.cc       |   8 +-
 test/cctest/test-utils-arm64.cc               | 140 +++++------
 test/cctest/test-utils-arm64.h                |   7 +-
 .../backend/instruction-selector-unittest.h   |   4 +-
 .../compiler/linkage-tail-call-unittest.cc    |   6 +-
 138 files changed, 2126 insertions(+), 2252 deletions(-)
 create mode 100644 src/codegen/arm/reglist-arm.h
 create mode 100644 src/codegen/arm64/reglist-arm64.h
 create mode 100644 src/codegen/ia32/reglist-ia32.h
 create mode 100644 src/codegen/loong64/reglist-loong64.h
 create mode 100644 src/codegen/mips/reglist-mips.h
 create mode 100644 src/codegen/mips64/reglist-mips64.h
 create mode 100644 src/codegen/ppc/reglist-ppc.h
 create mode 100644 src/codegen/register-arch.h
 create mode 100644 src/codegen/reglist-base.h
 create mode 100644 src/codegen/riscv64/reglist-riscv64.h
 create mode 100644 src/codegen/s390/reglist-s390.h
 create mode 100644 src/codegen/x64/reglist-x64.h

diff --git a/BUILD.bazel b/BUILD.bazel
index 6f8bdef7b7..f04d5d3721 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -1116,10 +1116,12 @@ filegroup(
         "src/codegen/optimized-compilation-info.h",
         "src/codegen/pending-optimization-table.cc",
         "src/codegen/pending-optimization-table.h",
+        "src/codegen/register-arch.h",
         "src/codegen/register-base.h",
         "src/codegen/register-configuration.cc",
         "src/codegen/register-configuration.h",
         "src/codegen/register.h",
+        "src/codegen/reglist-base.h",
         "src/codegen/reglist.h",
         "src/codegen/reloc-info.cc",
         "src/codegen/reloc-info.h",
@@ -2102,6 +2104,7 @@ filegroup(
             "src/codegen/ia32/macro-assembler-ia32.cc",
             "src/codegen/ia32/macro-assembler-ia32.h",
             "src/codegen/ia32/register-ia32.h",
+            "src/codegen/ia32/reglist-ia32.h",
             "src/compiler/backend/ia32/code-generator-ia32.cc",
             "src/compiler/backend/ia32/instruction-codes-ia32.h",
             "src/compiler/backend/ia32/instruction-scheduler-ia32.cc",
@@ -2131,6 +2134,7 @@ filegroup(
             "src/codegen/x64/macro-assembler-x64.cc",
             "src/codegen/x64/macro-assembler-x64.h",
             "src/codegen/x64/register-x64.h",
+            "src/codegen/x64/reglist-x64.h",
             "src/compiler/backend/x64/code-generator-x64.cc",
             "src/compiler/backend/x64/instruction-codes-x64.h",
             "src/compiler/backend/x64/instruction-scheduler-x64.cc",
@@ -2160,6 +2164,7 @@ filegroup(
             "src/codegen/arm/macro-assembler-arm.cc",
             "src/codegen/arm/macro-assembler-arm.h",
             "src/codegen/arm/register-arm.h",
+            "src/codegen/arm/reglist-arm.h",
             "src/compiler/backend/arm/code-generator-arm.cc",
             "src/compiler/backend/arm/instruction-codes-arm.h",
             "src/compiler/backend/arm/instruction-scheduler-arm.cc",
@@ -2198,6 +2203,7 @@ filegroup(
             "src/codegen/arm64/macro-assembler-arm64.h",
             "src/codegen/arm64/register-arm64.cc",
             "src/codegen/arm64/register-arm64.h",
+            "src/codegen/arm64/reglist-arm64.h",
             "src/codegen/arm64/utils-arm64.cc",
             "src/codegen/arm64/utils-arm64.h",
             "src/compiler/backend/arm64/code-generator-arm64.cc",
@@ -2234,6 +2240,7 @@ filegroup(
             "src/codegen/s390/macro-assembler-s390.cc",
             "src/codegen/s390/macro-assembler-s390.h",
             "src/codegen/s390/register-s390.h",
+            "src/codegen/s390/reglist-s390.h",
             "src/compiler/backend/s390/code-generator-s390.cc",
             "src/compiler/backend/s390/instruction-codes-s390.h",
             "src/compiler/backend/s390/instruction-scheduler-s390.cc",
@@ -2265,6 +2272,7 @@ filegroup(
             "src/codegen/riscv64/macro-assembler-riscv64.cc",
             "src/codegen/riscv64/macro-assembler-riscv64.h",
             "src/codegen/riscv64/register-riscv64.h",
+            "src/codegen/riscv64/reglist-riscv64.h",
             "src/compiler/backend/riscv64/code-generator-riscv64.cc",
             "src/compiler/backend/riscv64/instruction-codes-riscv64.h",
             "src/compiler/backend/riscv64/instruction-scheduler-riscv64.cc",
@@ -2293,6 +2301,7 @@ filegroup(
             "src/codegen/ppc/macro-assembler-ppc.cc",
             "src/codegen/ppc/macro-assembler-ppc.h",
             "src/codegen/ppc/register-ppc.h",
+            "src/codegen/ppc/reglist-ppc.h",
             "src/compiler/backend/ppc/code-generator-ppc.cc",
             "src/compiler/backend/ppc/instruction-codes-ppc.h",
             "src/compiler/backend/ppc/instruction-scheduler-ppc.cc",
diff --git a/BUILD.gn b/BUILD.gn
index 54e60d9c61..d4db25efcd 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -2728,9 +2728,11 @@ v8_header_set("v8_internal_headers") {
     "src/codegen/macro-assembler.h",
     "src/codegen/optimized-compilation-info.h",
     "src/codegen/pending-optimization-table.h",
+    "src/codegen/register-arch.h",
     "src/codegen/register-base.h",
     "src/codegen/register-configuration.h",
     "src/codegen/register.h",
+    "src/codegen/reglist-base.h",
     "src/codegen/reglist.h",
     "src/codegen/reloc-info.h",
     "src/codegen/safepoint-table.h",
@@ -3629,6 +3631,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/ia32/interface-descriptors-ia32-inl.h",
       "src/codegen/ia32/macro-assembler-ia32.h",
       "src/codegen/ia32/register-ia32.h",
+      "src/codegen/ia32/reglist-ia32.h",
       "src/codegen/ia32/sse-instr.h",
       "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.h",
       "src/compiler/backend/ia32/instruction-codes-ia32.h",
@@ -3648,6 +3651,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/x64/interface-descriptors-x64-inl.h",
       "src/codegen/x64/macro-assembler-x64.h",
       "src/codegen/x64/register-x64.h",
+      "src/codegen/x64/reglist-x64.h",
       "src/codegen/x64/sse-instr.h",
       "src/compiler/backend/x64/instruction-codes-x64.h",
       "src/compiler/backend/x64/unwinding-info-writer-x64.h",
@@ -3681,6 +3685,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/arm/interface-descriptors-arm-inl.h",
       "src/codegen/arm/macro-assembler-arm.h",
       "src/codegen/arm/register-arm.h",
+      "src/codegen/arm/reglist-arm.h",
       "src/compiler/backend/arm/instruction-codes-arm.h",
       "src/compiler/backend/arm/unwinding-info-writer-arm.h",
       "src/execution/arm/frame-constants-arm.h",
@@ -3702,6 +3707,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/arm64/macro-assembler-arm64-inl.h",
       "src/codegen/arm64/macro-assembler-arm64.h",
       "src/codegen/arm64/register-arm64.h",
+      "src/codegen/arm64/reglist-arm64.h",
       "src/codegen/arm64/utils-arm64.h",
       "src/compiler/backend/arm64/instruction-codes-arm64.h",
       "src/compiler/backend/arm64/unwinding-info-writer-arm64.h",
@@ -3738,6 +3744,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/mips/constants-mips.h",
       "src/codegen/mips/macro-assembler-mips.h",
       "src/codegen/mips/register-mips.h",
+      "src/codegen/mips/reglist-mips.h",
       "src/compiler/backend/mips/instruction-codes-mips.h",
       "src/execution/mips/frame-constants-mips.h",
       "src/execution/mips/simulator-mips.h",
@@ -3753,6 +3760,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/mips64/constants-mips64.h",
       "src/codegen/mips64/macro-assembler-mips64.h",
       "src/codegen/mips64/register-mips64.h",
+      "src/codegen/mips64/reglist-mips64.h",
       "src/compiler/backend/mips64/instruction-codes-mips64.h",
       "src/execution/mips64/frame-constants-mips64.h",
       "src/execution/mips64/simulator-mips64.h",
@@ -3768,6 +3776,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/loong64/constants-loong64.h",
       "src/codegen/loong64/macro-assembler-loong64.h",
       "src/codegen/loong64/register-loong64.h",
+      "src/codegen/loong64/reglist-loong64.h",
       "src/compiler/backend/loong64/instruction-codes-loong64.h",
       "src/execution/loong64/frame-constants-loong64.h",
       "src/execution/loong64/simulator-loong64.h",
@@ -3782,6 +3791,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/ppc/interface-descriptors-ppc-inl.h",
       "src/codegen/ppc/macro-assembler-ppc.h",
       "src/codegen/ppc/register-ppc.h",
+      "src/codegen/ppc/reglist-ppc.h",
       "src/compiler/backend/ppc/instruction-codes-ppc.h",
       "src/compiler/backend/ppc/unwinding-info-writer-ppc.h",
       "src/execution/ppc/frame-constants-ppc.h",
@@ -3799,6 +3809,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/ppc/interface-descriptors-ppc-inl.h",
       "src/codegen/ppc/macro-assembler-ppc.h",
       "src/codegen/ppc/register-ppc.h",
+      "src/codegen/ppc/reglist-ppc.h",
       "src/compiler/backend/ppc/instruction-codes-ppc.h",
       "src/compiler/backend/ppc/unwinding-info-writer-ppc.h",
       "src/execution/ppc/frame-constants-ppc.h",
@@ -3816,6 +3827,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/s390/interface-descriptors-s390-inl.h",
       "src/codegen/s390/macro-assembler-s390.h",
       "src/codegen/s390/register-s390.h",
+      "src/codegen/s390/reglist-s390.h",
       "src/compiler/backend/s390/instruction-codes-s390.h",
       "src/compiler/backend/s390/unwinding-info-writer-s390.h",
       "src/execution/s390/frame-constants-s390.h",
@@ -3832,6 +3844,7 @@ v8_header_set("v8_internal_headers") {
       "src/codegen/riscv64/constants-riscv64.h",
       "src/codegen/riscv64/macro-assembler-riscv64.h",
       "src/codegen/riscv64/register-riscv64.h",
+      "src/codegen/riscv64/reglist-riscv64.h",
       "src/compiler/backend/riscv64/instruction-codes-riscv64.h",
       "src/execution/riscv64/frame-constants-riscv64.h",
       "src/execution/riscv64/simulator-riscv64.h",
diff --git a/src/baseline/loong64/baseline-assembler-loong64-inl.h b/src/baseline/loong64/baseline-assembler-loong64-inl.h
index 594a8a19b6..25b279ff8e 100644
--- a/src/baseline/loong64/baseline-assembler-loong64-inl.h
+++ b/src/baseline/loong64/baseline-assembler-loong64-inl.h
@@ -22,7 +22,7 @@ class BaselineAssembler::ScratchRegisterScope {
     if (!assembler_->scratch_register_scope_) {
       // If we haven't opened a scratch scope yet, for the first one add a
       // couple of extra registers.
-      wrapped_scope_.Include(t0.bit() | t1.bit() | t2.bit() | t3.bit());
+      wrapped_scope_.Include({t0, t1, t2, t3});
     }
     assembler_->scratch_register_scope_ = this;
   }
diff --git a/src/baseline/mips/baseline-assembler-mips-inl.h b/src/baseline/mips/baseline-assembler-mips-inl.h
index 8373c87dce..c33ff88024 100644
--- a/src/baseline/mips/baseline-assembler-mips-inl.h
+++ b/src/baseline/mips/baseline-assembler-mips-inl.h
@@ -22,7 +22,7 @@ class BaselineAssembler::ScratchRegisterScope {
     if (!assembler_->scratch_register_scope_) {
       // If we haven't opened a scratch scope yet, for the first one add a
       // couple of extra registers.
-      wrapped_scope_.Include(t4.bit() | t5.bit() | t6.bit() | t7.bit());
+      wrapped_scope_.Include({t4, t5, t6, t7});
     }
     assembler_->scratch_register_scope_ = this;
   }
diff --git a/src/baseline/mips64/baseline-assembler-mips64-inl.h b/src/baseline/mips64/baseline-assembler-mips64-inl.h
index de7b362cf2..8aa9122f51 100644
--- a/src/baseline/mips64/baseline-assembler-mips64-inl.h
+++ b/src/baseline/mips64/baseline-assembler-mips64-inl.h
@@ -22,7 +22,7 @@ class BaselineAssembler::ScratchRegisterScope {
     if (!assembler_->scratch_register_scope_) {
       // If we haven't opened a scratch scope yet, for the first one add a
       // couple of extra registers.
-      wrapped_scope_.Include(t0.bit() | t1.bit() | t2.bit() | t3.bit());
+      wrapped_scope_.Include({t0, t1, t2, t3});
     }
     assembler_->scratch_register_scope_ = this;
   }
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index c388d25508..fe2536fa0a 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -555,7 +555,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   //   r1: microtask_queue
   // Preserve all but r0 and pass them to entry_trampoline.
   Label invoke, handler_entry, exit;
-  const RegList kCalleeSavedWithoutFp = kCalleeSaved & ~fp.bit();
+  const RegList kCalleeSavedWithoutFp = kCalleeSaved - fp;
 
   // Update |pushed_stack_space| when we manipulate the stack.
   int pushed_stack_space = EntryFrameConstants::kCallerFPOffset;
@@ -589,7 +589,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
                                         masm->isolate()));
   __ ldr(r5, MemOperand(r4));
 
-  __ stm(db_w, sp, r5.bit() | r6.bit() | r7.bit() | fp.bit() | lr.bit());
+  __ stm(db_w, sp, {r5, r6, r7, fp, lr});
   pushed_stack_space += 5 * kPointerSize /* r5, r6, r7, fp, lr */;
 
   // Clear c_entry_fp, now we've pushed its previous value to the stack.
@@ -690,7 +690,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
          Operand(-EntryFrameConstants::kCallerFPOffset -
                  kSystemPointerSize /* already popped one */));
 
-  __ ldm(ia_w, sp, fp.bit() | lr.bit());
+  __ ldm(ia_w, sp, {fp, lr});
 
   // Restore callee-saved vfp registers.
   __ vldm(ia_w, sp, kFirstCalleeSavedDoubleReg, kLastCalleeSavedDoubleReg);
@@ -1202,7 +1202,7 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
     temps.Exclude(optimization_state);
 
     // Drop the frame created by the baseline call.
-    __ ldm(ia_w, sp, fp.bit() | lr.bit());
+    __ ldm(ia_w, sp, {fp, lr});
     MaybeOptimizeCodeOrTailCallOptimizedCodeSlot(masm, optimization_state,
                                                  feedback_vector);
     __ Trap();
@@ -2628,9 +2628,9 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see wasm-linkage.h). They might be
     // overwritten in the runtime call below. We don't have any callee-saved
     // registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
     DwVfpRegister lowest_fp_reg = std::begin(wasm::kFpParamRegisters)[0];
     DwVfpRegister highest_fp_reg = std::end(wasm::kFpParamRegisters)[-1];
@@ -2639,10 +2639,10 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
             fp_param_reg.code() <= highest_fp_reg.code());
     }
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters));
     CHECK_EQ(highest_fp_reg.code() - lowest_fp_reg.code() + 1,
              arraysize(wasm::kFpParamRegisters));
-    CHECK_EQ(NumRegs(gp_regs),
+    CHECK_EQ(gp_regs.Count(),
              WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs);
     CHECK_EQ(highest_fp_reg.code() - lowest_fp_reg.code() + 1,
              WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs);
@@ -2675,20 +2675,19 @@ void Builtins::Generate_WasmDebugBreak(MacroAssembler* masm) {
     FrameAndConstantPoolScope scope(masm, StackFrame::WASM_DEBUG_BREAK);
 
     STATIC_ASSERT(DwVfpRegister::kNumRegisters == 32);
-    constexpr uint32_t last =
-        31 - base::bits::CountLeadingZeros32(
-                 WasmDebugBreakFrameConstants::kPushedFpRegs);
-    constexpr uint32_t first = base::bits::CountTrailingZeros32(
-        WasmDebugBreakFrameConstants::kPushedFpRegs);
+    constexpr DwVfpRegister last =
+        WasmDebugBreakFrameConstants::kPushedFpRegs.last();
+    constexpr DwVfpRegister first =
+        WasmDebugBreakFrameConstants::kPushedFpRegs.first();
     static_assert(
-        base::bits::CountPopulation(
-            WasmDebugBreakFrameConstants::kPushedFpRegs) == last - first + 1,
+        WasmDebugBreakFrameConstants::kPushedFpRegs.Count() ==
+            last.code() - first.code() + 1,
         "All registers in the range from first to last have to be set");
 
     // Save all parameter registers. They might hold live values, we restore
     // them after the runtime call.
-    constexpr DwVfpRegister lowest_fp_reg = DwVfpRegister::from_code(first);
-    constexpr DwVfpRegister highest_fp_reg = DwVfpRegister::from_code(last);
+    constexpr DwVfpRegister lowest_fp_reg = first;
+    constexpr DwVfpRegister highest_fp_reg = last;
 
     // Store gp parameter registers.
     __ stm(db_w, sp, WasmDebugBreakFrameConstants::kPushedGpRegs);
@@ -3340,12 +3339,12 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   STATIC_ASSERT(kNumberOfRegisters == 16);
 
   // Everything but pc, lr and ip which will be saved but not restored.
-  RegList restored_regs = kJSCallerSaved | kCalleeSaved | ip.bit();
+  RegList restored_regs = kJSCallerSaved | kCalleeSaved | RegList{ip};
 
   // Push all 16 registers (needed to populate FrameDescription::registers_).
   // TODO(v8:1588): Note that using pc with stm is deprecated, so we should
   // perhaps handle this a bit differently.
-  __ stm(db_w, sp, restored_regs | sp.bit() | lr.bit() | pc.bit());
+  __ stm(db_w, sp, restored_regs | RegList{sp, lr, pc});
 
   {
     UseScratchRegisterScope temps(masm);
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index ce5e571007..e6321c614c 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -3037,27 +3037,27 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see wasm-linkage.h). They might be
     // overwritten in the runtime call below. We don't have any callee-saved
     // registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
     // Also push x1, because we must push multiples of 16 bytes (see
     // {TurboAssembler::PushCPURegList}.
-    CHECK_EQ(1, NumRegs(gp_regs) % 2);
-    gp_regs |= x1.bit();
-    CHECK_EQ(0, NumRegs(gp_regs) % 2);
+    CHECK_EQ(1, gp_regs.Count() % 2);
+    gp_regs.set(x1);
+    CHECK_EQ(0, gp_regs.Count() % 2);
 
-    RegList fp_regs = 0;
+    DoubleRegList fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs |= fp_param_reg.bit();
+      fp_regs.set(fp_param_reg);
     }
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters) + 1);
-    CHECK_EQ(NumRegs(fp_regs), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters) + 1);
+    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             NumRegs(gp_regs));
+             gp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(fp_regs));
+             fp_regs.Count());
 
     __ PushXRegList(gp_regs);
     __ PushQRegList(fp_regs);
@@ -3868,8 +3868,9 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
 
   // Save all allocatable double registers.
   CPURegList saved_double_registers(
-      CPURegister::kVRegister, kDRegSizeInBits,
-      RegisterConfiguration::Default()->allocatable_double_codes_mask());
+      kDRegSizeInBits,
+      DoubleRegList::FromBits(
+          RegisterConfiguration::Default()->allocatable_double_codes_mask()));
   DCHECK_EQ(saved_double_registers.Count() % 2, 0);
   __ PushCPURegList(saved_double_registers);
 
@@ -4273,7 +4274,9 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
-  if (FLAG_debug_code) registers |= kCallerSaved.list();
+  if (FLAG_debug_code) {
+    registers |= RegList::FromBits(static_cast<uint32_t>(kCallerSaved.bits()));
+  }
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 560150ec65..c217c6c7c3 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -2923,19 +2923,19 @@ void Builtins::Generate_WasmDebugBreak(MacroAssembler* masm) {
 
     // Save all parameter registers. They might hold live values, we restore
     // them after the runtime call.
-    for (int reg_code : base::bits::IterateBitsBackwards(
-             WasmDebugBreakFrameConstants::kPushedGpRegs)) {
-      __ Push(Register::from_code(reg_code));
+    for (Register reg :
+         base::Reversed(WasmDebugBreakFrameConstants::kPushedGpRegs)) {
+      __ Push(reg);
     }
 
     constexpr int kFpStackSize =
         kSimd128Size * WasmDebugBreakFrameConstants::kNumPushedFpRegisters;
     __ AllocateStackSpace(kFpStackSize);
     int offset = kFpStackSize;
-    for (int reg_code : base::bits::IterateBitsBackwards(
-             WasmDebugBreakFrameConstants::kPushedFpRegs)) {
+    for (DoubleRegister reg :
+         base::Reversed(WasmDebugBreakFrameConstants::kPushedFpRegs)) {
       offset -= kSimd128Size;
-      __ movdqu(Operand(esp, offset), DoubleRegister::from_code(reg_code));
+      __ movdqu(Operand(esp, offset), reg);
     }
 
     // Initialize the JavaScript context with 0. CEntry will use it to
@@ -2944,15 +2944,13 @@ void Builtins::Generate_WasmDebugBreak(MacroAssembler* masm) {
     __ CallRuntime(Runtime::kWasmDebugBreak, 0);
 
     // Restore registers.
-    for (int reg_code :
-         base::bits::IterateBits(WasmDebugBreakFrameConstants::kPushedFpRegs)) {
-      __ movdqu(DoubleRegister::from_code(reg_code), Operand(esp, offset));
+    for (DoubleRegister reg : WasmDebugBreakFrameConstants::kPushedFpRegs) {
+      __ movdqu(reg, Operand(esp, offset));
       offset += kSimd128Size;
     }
     __ add(esp, Immediate(kFpStackSize));
-    for (int reg_code :
-         base::bits::IterateBits(WasmDebugBreakFrameConstants::kPushedGpRegs)) {
-      __ Pop(Register::from_code(reg_code));
+    for (Register reg : WasmDebugBreakFrameConstants::kPushedGpRegs) {
+      __ Pop(reg);
     }
   }
 
diff --git a/src/builtins/loong64/builtins-loong64.cc b/src/builtins/loong64/builtins-loong64.cc
index cbd943a8c5..14206ae5f0 100644
--- a/src/builtins/loong64/builtins-loong64.cc
+++ b/src/builtins/loong64/builtins-loong64.cc
@@ -553,7 +553,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
     //   a1: microtask_queue
 
     // Save callee saved registers on the stack.
-    __ MultiPush(kCalleeSaved | ra.bit());
+    __ MultiPush(kCalleeSaved | ra);
 
     // Save callee-saved FPU registers.
     __ MultiPushFPU(kCalleeSavedFPU);
@@ -707,7 +707,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   __ MultiPopFPU(kCalleeSavedFPU);
 
   // Restore callee saved registers from the stack.
-  __ MultiPop(kCalleeSaved | ra.bit());
+  __ MultiPop(kCalleeSaved | ra);
   // Return.
   __ Jump(ra);
 }
@@ -1053,8 +1053,8 @@ static void MaybeOptimizeCodeOrTailCallOptimizedCodeSlot(
 // static
 void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   UseScratchRegisterScope temps(masm);
-  temps.Include(s1.bit() | s2.bit());
-  temps.Exclude(t7.bit());
+  temps.Include({s1, s2});
+  temps.Exclude({t7});
   auto descriptor =
       Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
@@ -1197,7 +1197,7 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
     __ Pop(kJavaScriptCallNewTargetRegister);
   }
   __ Ret();
-  temps.Exclude(s1.bit() | s2.bit());
+  temps.Exclude({s1, s2});
 }
 
 // Generate code for entering a JS function with the interpreter.
@@ -2664,22 +2664,22 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see wasm-linkage.h). They might be
     // overwritten in the runtime call below. We don't have any callee-saved
     // registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
 
-    RegList fp_regs = 0;
+    RegList fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs |= fp_param_reg.bit();
+      fp_regs.set(fp_param_reg);
     }
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters));
-    CHECK_EQ(NumRegs(fp_regs), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters));
+    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             NumRegs(gp_regs));
+             gp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(fp_regs));
+             fp_regs.Count());
 
     __ MultiPush(gp_regs);
     __ MultiPushFPU(fp_regs);
@@ -3375,7 +3375,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   const int kNumberOfRegisters = Register::kNumRegisters;
 
   RegList restored_regs = kJSCallerSaved | kCalleeSaved;
-  RegList saved_regs = restored_regs | sp.bit() | ra.bit();
+  RegList saved_regs = restored_regs | sp | ra;
 
   const int kDoubleRegsSize = kDoubleSize * DoubleRegister::kNumRegisters;
 
@@ -3539,7 +3539,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
 
   // Technically restoring 'at' should work unless zero_reg is also restored
   // but it's safer to check for this.
-  DCHECK(!(t7.bit() & restored_regs));
+  DCHECK(!(restored_regs.has(t7)));
   // Restore the registers from the last output frame.
   __ mov(t7, a2);
   for (int i = kNumberOfRegisters - 1; i >= 0; i--) {
diff --git a/src/builtins/mips/builtins-mips.cc b/src/builtins/mips/builtins-mips.cc
index d98b2d7341..3569377e4d 100644
--- a/src/builtins/mips/builtins-mips.cc
+++ b/src/builtins/mips/builtins-mips.cc
@@ -390,7 +390,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
     // a0: root_register_value
 
     // Save callee saved registers on the stack.
-    __ MultiPush(kCalleeSaved | ra.bit());
+    __ MultiPush(kCalleeSaved | ra);
     pushed_stack_space +=
         kNumCalleeSaved * kPointerSize + kPointerSize /* ra */;
 
@@ -524,7 +524,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   __ MultiPopFPU(kCalleeSavedFPU);
 
   // Restore callee saved registers from the stack.
-  __ MultiPop(kCalleeSaved | ra.bit());
+  __ MultiPop(kCalleeSaved | ra);
   // Return.
   __ Jump(ra);
 }
@@ -1052,7 +1052,7 @@ static void MaybeOptimizeCodeOrTailCallOptimizedCodeSlot(
 // static
 void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   UseScratchRegisterScope temps(masm);
-  temps.Include(s1.bit() | s2.bit());
+  temps.Include({s1, s2});
   auto descriptor =
       Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
@@ -1193,7 +1193,7 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
     __ Pop(kJavaScriptCallNewTargetRegister);
   }
   __ Ret();
-  temps.Exclude(kScratchReg.bit() | kScratchReg2.bit());
+  temps.Exclude({kScratchReg, kScratchReg2});
 }
 
 // Generate code for entering a JS function with the interpreter.
@@ -2608,22 +2608,22 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see wasm-linkage.h). They might be
     // overwritten in the runtime call below. We don't have any callee-saved
     // registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
 
-    RegList fp_regs = 0;
+    RegList fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs |= fp_param_reg.bit();
+      fp_regs.set(fp_param_reg);
     }
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters));
-    CHECK_EQ(NumRegs(fp_regs), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters));
+    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             NumRegs(gp_regs));
+             gp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(fp_regs));
+             fp_regs.Count());
 
     __ MultiPush(gp_regs);
     __ MultiPushFPU(fp_regs);
@@ -3821,7 +3821,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   static constexpr int kNumberOfRegisters = Register::kNumRegisters;
 
   RegList restored_regs = kJSCallerSaved | kCalleeSaved;
-  RegList saved_regs = restored_regs | sp.bit() | ra.bit();
+  RegList saved_regs = restored_regs | sp | ra;
 
   static constexpr int kDoubleRegsSize =
       kDoubleSize * DoubleRegister::kNumRegisters;
@@ -3987,7 +3987,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
 
   // Technically restoring 'at' should work unless zero_reg is also restored
   // but it's safer to check for this.
-  DCHECK(!(at.bit() & restored_regs));
+  DCHECK(!(restored_regs.has(at)));
   // Restore the registers from the last output frame.
   __ mov(at, a2);
   for (int i = kNumberOfRegisters - 1; i >= 0; i--) {
diff --git a/src/builtins/mips64/builtins-mips64.cc b/src/builtins/mips64/builtins-mips64.cc
index cee8868d3c..0c9e1364f3 100644
--- a/src/builtins/mips64/builtins-mips64.cc
+++ b/src/builtins/mips64/builtins-mips64.cc
@@ -556,7 +556,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
     // 0 arg slots on mips64 (4 args slots on mips)
 
     // Save callee saved registers on the stack.
-    __ MultiPush(kCalleeSaved | ra.bit());
+    __ MultiPush(kCalleeSaved | ra);
 
     // Save callee-saved FPU registers.
     __ MultiPushFPU(kCalleeSavedFPU);
@@ -709,7 +709,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   __ MultiPopFPU(kCalleeSavedFPU);
 
   // Restore callee saved registers from the stack.
-  __ MultiPop(kCalleeSaved | ra.bit());
+  __ MultiPop(kCalleeSaved | ra);
   // Return.
   __ Jump(ra);
 }
@@ -1059,7 +1059,7 @@ static void MaybeOptimizeCodeOrTailCallOptimizedCodeSlot(
 // static
 void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   UseScratchRegisterScope temps(masm);
-  temps.Include(s1.bit() | s2.bit());
+  temps.Include({s1, s2});
   auto descriptor =
       Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
@@ -1200,7 +1200,7 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
     __ Pop(kJavaScriptCallNewTargetRegister);
   }
   __ Ret();
-  temps.Exclude(kScratchReg.bit() | kScratchReg2.bit());
+  temps.Exclude({kScratchReg, kScratchReg2});
 }
 
 // Generate code for entering a JS function with the interpreter.
@@ -2658,22 +2658,22 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see wasm-linkage.h). They might be
     // overwritten in the runtime call below. We don't have any callee-saved
     // registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
 
-    RegList fp_regs = 0;
+    RegList fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs |= fp_param_reg.bit();
+      fp_regs.set(fp_param_reg);
     }
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters));
-    CHECK_EQ(NumRegs(fp_regs), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters));
+    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             NumRegs(gp_regs));
+             gp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(fp_regs));
+             fp_regs.Count());
 
     __ MultiPush(gp_regs);
     // Check if machine has simd enabled, if so push vector registers. If not
@@ -3400,7 +3400,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   const int kNumberOfRegisters = Register::kNumRegisters;
 
   RegList restored_regs = kJSCallerSaved | kCalleeSaved;
-  RegList saved_regs = restored_regs | sp.bit() | ra.bit();
+  RegList saved_regs = restored_regs | sp | ra;
 
   const int kDoubleRegsSize = kDoubleSize * DoubleRegister::kNumRegisters;
 
@@ -3565,7 +3565,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
 
   // Technically restoring 'at' should work unless zero_reg is also restored
   // but it's safer to check for this.
-  DCHECK(!(at.bit() & restored_regs));
+  DCHECK(!(restored_regs.has(at)));
   // Restore the registers from the last output frame.
   __ mov(at, a2);
   for (int i = kNumberOfRegisters - 1; i >= 0; i--) {
diff --git a/src/builtins/ppc/builtins-ppc.cc b/src/builtins/ppc/builtins-ppc.cc
index d8ccf644c5..62b69fa5da 100644
--- a/src/builtins/ppc/builtins-ppc.cc
+++ b/src/builtins/ppc/builtins-ppc.cc
@@ -2470,29 +2470,28 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see wasm-linkage.h). They might be
     // overwritten in the runtime call below. We don't have any callee-saved
     // registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
 
-    RegList fp_regs = 0;
+    RegList fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs |= fp_param_reg.bit();
+      fp_regs.set(fp_param_reg);
     }
 
     // List must match register numbers under kFpParamRegisters.
-    constexpr RegList simd_regs =
-        Simd128Register::ListOf(v1, v2, v3, v4, v5, v6, v7, v8);
+    constexpr RegList simd_regs = {v1, v2, v3, v4, v5, v6, v7, v8};
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters));
-    CHECK_EQ(NumRegs(fp_regs), arraysize(wasm::kFpParamRegisters));
-    CHECK_EQ(NumRegs(simd_regs), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters));
+    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(simd_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             NumRegs(gp_regs));
+             gp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(fp_regs));
+             fp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(simd_regs));
+             simd_regs.Count());
 
     __ MultiPush(gp_regs);
     __ MultiPushF64AndV128(fp_regs, simd_regs);
@@ -3246,7 +3245,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   const int kNumberOfRegisters = Register::kNumRegisters;
 
   RegList restored_regs = kJSCallerSaved | kCalleeSaved;
-  RegList saved_regs = restored_regs | sp.bit();
+  RegList saved_regs = restored_regs | sp;
 
   const int kDoubleRegsSize = kDoubleSize * DoubleRegister::kNumRegisters;
 
@@ -3429,7 +3428,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   {
     UseScratchRegisterScope temps(masm);
     Register scratch = temps.Acquire();
-    DCHECK(!(scratch.bit() & restored_regs));
+    DCHECK(!(restored_regs.has(scratch)));
     __ mr(scratch, r5);
     for (int i = kNumberOfRegisters - 1; i >= 0; i--) {
       int offset =
diff --git a/src/builtins/riscv64/builtins-riscv64.cc b/src/builtins/riscv64/builtins-riscv64.cc
index 9d41647613..ff6610de2f 100644
--- a/src/builtins/riscv64/builtins-riscv64.cc
+++ b/src/builtins/riscv64/builtins-riscv64.cc
@@ -587,7 +587,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
     //   a1: microtask_queue
 
     // Save callee saved registers on the stack.
-    __ MultiPush(kCalleeSaved | ra.bit());
+    __ MultiPush(kCalleeSaved | ra);
 
     // Save callee-saved FPU registers.
     __ MultiPushFPU(kCalleeSavedFPU);
@@ -743,7 +743,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   __ MultiPopFPU(kCalleeSavedFPU);
 
   // Restore callee saved registers from the stack.
-  __ MultiPop(kCalleeSaved | ra.bit());
+  __ MultiPop(kCalleeSaved | ra);
   // Return.
   __ Jump(ra);
 }
@@ -1121,7 +1121,7 @@ static void MaybeOptimizeCodeOrTailCallOptimizedCodeSlot(
 // static
 void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   UseScratchRegisterScope temps(masm);
-  temps.Include(kScratchReg.bit() | kScratchReg2.bit());
+  temps.Include({kScratchReg, kScratchReg2});
   auto descriptor =
       Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
@@ -1255,7 +1255,7 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
     __ Pop(kJavaScriptCallNewTargetRegister);
   }
   __ Ret();
-  temps.Exclude(kScratchReg.bit() | kScratchReg2.bit());
+  temps.Exclude({kScratchReg, kScratchReg2});
 }
 
 // Generate code for entering a JS function with the interpreter.
@@ -2766,28 +2766,28 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see kGpParamRegisters in wasm-linkage.cc).
     // They might be overwritten in the runtime call below. We don't have any
     // callee-saved registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
     // Also push a1, because we must push multiples of 16 bytes (see
     // {TurboAssembler::PushCPURegList}.
-    CHECK_EQ(1, NumRegs(gp_regs) % 2);
-    gp_regs |= a1.bit();
+    CHECK_EQ(1, gp_regs.Count() % 2);
+    gp_regs.set(a1);
     // Ensure that A1 will not be repeated.
-    CHECK_EQ(0, NumRegs(gp_regs) % 2);
+    CHECK_EQ(0, gp_regs.Count() % 2);
 
-    RegList fp_regs = 0;
+    RegList fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs |= fp_param_reg.bit();
+      fp_regs.set(fp_param_reg);
     }
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters) + 1);
-    CHECK_EQ(NumRegs(fp_regs), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters) + 1);
+    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             NumRegs(gp_regs));
+             gp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(fp_regs));
+             fp_regs.Count());
     __ MultiPush(gp_regs);
     __ MultiPushFPU(fp_regs);
 
@@ -3486,7 +3486,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
   const int kNumberOfRegisters = Register::kNumRegisters;
 
   RegList restored_regs = kJSCallerSaved | kCalleeSaved;
-  RegList saved_regs = restored_regs | sp.bit() | ra.bit();
+  RegList saved_regs = restored_regs | sp | ra;
 
   const int kDoubleRegsSize = kDoubleSize * DoubleRegister::kNumRegisters;
 
@@ -3651,7 +3651,7 @@ void Generate_DeoptimizationEntry(MacroAssembler* masm,
 
   // Technically restoring 't3' should work unless zero_reg is also restored
   // but it's safer to check for this.
-  DCHECK(!(t3.bit() & restored_regs));
+  DCHECK(!(restored_regs.has(t3)));
   // Restore the registers from the last output frame.
   __ Move(t3, a2);
   for (int i = kNumberOfRegisters - 1; i >= 0; i--) {
diff --git a/src/builtins/s390/builtins-s390.cc b/src/builtins/s390/builtins-s390.cc
index 79b5ee2ad7..a567215dc9 100644
--- a/src/builtins/s390/builtins-s390.cc
+++ b/src/builtins/s390/builtins-s390.cc
@@ -2899,22 +2899,22 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     // Save all parameter registers (see wasm-linkage.h). They might be
     // overwritten in the runtime call below. We don't have any callee-saved
     // registers in wasm, so no need to store anything else.
-    RegList gp_regs = 0;
+    RegList gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs |= gp_param_reg.bit();
+      gp_regs.set(gp_param_reg);
     }
 
-    RegList fp_regs = 0;
+    RegList fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs |= fp_param_reg.bit();
+      fp_regs.set(fp_param_reg);
     }
 
-    CHECK_EQ(NumRegs(gp_regs), arraysize(wasm::kGpParamRegisters));
-    CHECK_EQ(NumRegs(fp_regs), arraysize(wasm::kFpParamRegisters));
+    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters));
+    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             NumRegs(gp_regs));
+             gp_regs.Count());
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             NumRegs(fp_regs));
+             fp_regs.Count());
 
     __ MultiPush(gp_regs);
     __ MultiPushF64OrV128(fp_regs);
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index 5958bab7e2..9ffd1ea2be 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -2845,19 +2845,19 @@ void Builtins::Generate_WasmDebugBreak(MacroAssembler* masm) {
 
     // Save all parameter registers. They might hold live values, we restore
     // them after the runtime call.
-    for (int reg_code : base::bits::IterateBitsBackwards(
-             WasmDebugBreakFrameConstants::kPushedGpRegs)) {
-      __ Push(Register::from_code(reg_code));
+    for (Register reg :
+         base::Reversed(WasmDebugBreakFrameConstants::kPushedGpRegs)) {
+      __ Push(reg);
     }
 
     constexpr int kFpStackSize =
         kSimd128Size * WasmDebugBreakFrameConstants::kNumPushedFpRegisters;
     __ AllocateStackSpace(kFpStackSize);
     int offset = kFpStackSize;
-    for (int reg_code : base::bits::IterateBitsBackwards(
-             WasmDebugBreakFrameConstants::kPushedFpRegs)) {
+    for (DoubleRegister reg :
+         base::Reversed(WasmDebugBreakFrameConstants::kPushedFpRegs)) {
       offset -= kSimd128Size;
-      __ movdqu(Operand(rsp, offset), DoubleRegister::from_code(reg_code));
+      __ movdqu(Operand(rsp, offset), reg);
     }
 
     // Initialize the JavaScript context with 0. CEntry will use it to
@@ -2866,15 +2866,13 @@ void Builtins::Generate_WasmDebugBreak(MacroAssembler* masm) {
     __ CallRuntime(Runtime::kWasmDebugBreak, 0);
 
     // Restore registers.
-    for (int reg_code :
-         base::bits::IterateBits(WasmDebugBreakFrameConstants::kPushedFpRegs)) {
-      __ movdqu(DoubleRegister::from_code(reg_code), Operand(rsp, offset));
+    for (DoubleRegister reg : WasmDebugBreakFrameConstants::kPushedFpRegs) {
+      __ movdqu(reg, Operand(rsp, offset));
       offset += kSimd128Size;
     }
     __ addq(rsp, Immediate(kFpStackSize));
-    for (int reg_code :
-         base::bits::IterateBits(WasmDebugBreakFrameConstants::kPushedGpRegs)) {
-      __ Pop(Register::from_code(reg_code));
+    for (Register reg : WasmDebugBreakFrameConstants::kPushedGpRegs) {
+      __ Pop(reg);
     }
   }
 
diff --git a/src/codegen/arm/assembler-arm.cc b/src/codegen/arm/assembler-arm.cc
index 73f16dc57c..ff612406f6 100644
--- a/src/codegen/arm/assembler-arm.cc
+++ b/src/codegen/arm/assembler-arm.cc
@@ -533,7 +533,7 @@ Assembler::Assembler(const AssemblerOptions& options,
                      std::unique_ptr<AssemblerBuffer> buffer)
     : AssemblerBase(options, std::move(buffer)),
       pending_32_bit_constants_(),
-      scratch_register_list_(ip.bit()) {
+      scratch_register_list_({ip}) {
   reloc_info_writer.Reposition(buffer_start_ + buffer_->size(), pc_);
   constant_pool_deadline_ = kMaxInt;
   const_pool_blocked_nesting_ = 0;
@@ -1412,9 +1412,9 @@ void Assembler::AddrMode3(Instr instr, Register rd, const MemOperand& x) {
 
 void Assembler::AddrMode4(Instr instr, Register rn, RegList rl) {
   DCHECK((instr & ~(kCondMask | P | U | W | L)) == B27);
-  DCHECK_NE(rl, 0);
+  DCHECK(!rl.is_empty());
   DCHECK(rn != pc);
-  emit(instr | rn.code() * B16 | rl);
+  emit(instr | rn.code() * B16 | rl.bits());
 }
 
 void Assembler::AddrMode5(Instr instr, CRegister crd, const MemOperand& x) {
@@ -2251,12 +2251,12 @@ void Assembler::pld(const MemOperand& address) {
 void Assembler::ldm(BlockAddrMode am, Register base, RegList dst,
                     Condition cond) {
   // ABI stack constraint: ldmxx base, {..sp..}  base != sp  is not restartable.
-  DCHECK(base == sp || (dst & sp.bit()) == 0);
+  DCHECK(base == sp || !dst.has(sp));
 
   AddrMode4(cond | B27 | am | L, base, dst);
 
   // Emit the constant pool after a function return implemented by ldm ..{..pc}.
-  if (cond == al && (dst & pc.bit()) != 0) {
+  if (cond == al && dst.has(pc)) {
     // There is a slight chance that the ldm instruction was actually a call,
     // in which case it would be wrong to return into the constant pool; we
     // recognize this case by checking if the emission of the pool was blocked
@@ -5499,11 +5499,7 @@ UseScratchRegisterScope::~UseScratchRegisterScope() {
 Register UseScratchRegisterScope::Acquire() {
   RegList* available = assembler_->GetScratchRegisterList();
   DCHECK_NOT_NULL(available);
-  DCHECK_NE(*available, 0);
-  int index = static_cast<int>(base::bits::CountTrailingZeros32(*available));
-  Register reg = Register::from_code(index);
-  *available &= ~reg.bit();
-  return reg;
+  return available->PopFirst();
 }
 
 LoadStoreLaneParams::LoadStoreLaneParams(MachineRepresentation rep,
diff --git a/src/codegen/arm/assembler-arm.h b/src/codegen/arm/assembler-arm.h
index ca4a79469a..9408dd0793 100644
--- a/src/codegen/arm/assembler-arm.h
+++ b/src/codegen/arm/assembler-arm.h
@@ -1399,21 +1399,25 @@ class V8_EXPORT_PRIVATE V8_NODISCARD UseScratchRegisterScope {
   }
 
   // Check if we have registers available to acquire.
-  bool CanAcquire() const { return *assembler_->GetScratchRegisterList() != 0; }
+  bool CanAcquire() const {
+    return !assembler_->GetScratchRegisterList()->is_empty();
+  }
   bool CanAcquireD() const { return CanAcquireVfp<DwVfpRegister>(); }
 
   void Include(const Register& reg1, const Register& reg2 = no_reg) {
     RegList* available = assembler_->GetScratchRegisterList();
     DCHECK_NOT_NULL(available);
-    DCHECK_EQ((*available) & (reg1.bit() | reg2.bit()), 0);
-    *available |= reg1.bit() | reg2.bit();
+    DCHECK(!available->has(reg1));
+    DCHECK(!available->has(reg2));
+    available->set(reg1);
+    available->set(reg2);
   }
   void Exclude(const Register& reg1, const Register& reg2 = no_reg) {
     RegList* available = assembler_->GetScratchRegisterList();
     DCHECK_NOT_NULL(available);
-    DCHECK_EQ((*available) & (reg1.bit() | reg2.bit()),
-              reg1.bit() | reg2.bit());
-    *available &= ~(reg1.bit() | reg2.bit());
+    DCHECK(available->has(reg1));
+    DCHECK_IMPLIES(reg2.is_valid(), available->has(reg2));
+    available->clear(RegList{reg1, reg2});
   }
 
  private:
diff --git a/src/codegen/arm/interface-descriptors-arm-inl.h b/src/codegen/arm/interface-descriptors-arm-inl.h
index 03512d90c1..70e8e9f361 100644
--- a/src/codegen/arm/interface-descriptors-arm-inl.h
+++ b/src/codegen/arm/interface-descriptors-arm-inl.h
@@ -24,21 +24,21 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | r0.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | r1.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | r2.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | r3.bit());
-  if (argc >= 5) DCHECK(allocatable_regs | r4.bit());
-  if (argc >= 6) DCHECK(allocatable_regs | r5.bit());
-  if (argc >= 7) DCHECK(allocatable_regs | r6.bit());
-  if (argc >= 8) DCHECK(allocatable_regs | r7.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(r0));
+  if (argc >= 2) DCHECK(allocatable_regs.has(r1));
+  if (argc >= 3) DCHECK(allocatable_regs.has(r2));
+  if (argc >= 4) DCHECK(allocatable_regs.has(r3));
+  if (argc >= 5) DCHECK(allocatable_regs.has(r4));
+  if (argc >= 6) DCHECK(allocatable_regs.has(r5));
+  if (argc >= 7) DCHECK(allocatable_regs.has(r6));
+  if (argc >= 8) DCHECK(allocatable_regs.has(r7));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
 
 // static
 constexpr auto WriteBarrierDescriptor::registers() {
-  return RegisterArray(r1, r5, r4, r2, r0);
+  return RegisterArray(r1, r5, r4, r2, r0, r3, kContextRegister);
 }
 
 // static
diff --git a/src/codegen/arm/macro-assembler-arm.cc b/src/codegen/arm/macro-assembler-arm.cc
index 323125f263..d0d854dc50 100644
--- a/src/codegen/arm/macro-assembler-arm.cc
+++ b/src/codegen/arm/macro-assembler-arm.cc
@@ -45,20 +45,10 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
                                                     Register exclusion2,
                                                     Register exclusion3) const {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = (kCallerSaved | lr.bit()) & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = (kCallerSaved | lr) - exclusions;
 
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     bytes += DwVfpRegister::kNumRegisters * DwVfpRegister::kSizeInBytes;
@@ -71,21 +61,11 @@ int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
                                     Register exclusion2, Register exclusion3) {
   ASM_CODE_COMMENT(this);
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = (kCallerSaved | lr.bit()) & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = (kCallerSaved | lr) - exclusions;
   stm(db_w, sp, list);
 
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     SaveFPRegs(sp, lr);
@@ -104,21 +84,11 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
     bytes += DwVfpRegister::kNumRegisters * DwVfpRegister::kSizeInBytes;
   }
 
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = (kCallerSaved | lr.bit()) & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = (kCallerSaved | lr) - exclusions;
   ldm(ia_w, sp, list);
 
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   return bytes;
 }
@@ -696,27 +666,15 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
+  if (registers.is_empty()) return;
   ASM_CODE_COMMENT(this);
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  stm(db_w, sp, regs);
+  stm(db_w, sp, registers);
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
+  if (registers.is_empty()) return;
   ASM_CODE_COMMENT(this);
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  ldm(ia_w, sp, regs);
+  ldm(ia_w, sp, registers);
 }
 
 void TurboAssembler::CallEphemeronKeyBarrier(Register object, Operand offset,
@@ -876,15 +834,15 @@ void TurboAssembler::PushCommonFrame(Register marker_reg) {
   ASM_CODE_COMMENT(this);
   if (marker_reg.is_valid()) {
     if (marker_reg.code() > fp.code()) {
-      stm(db_w, sp, fp.bit() | lr.bit());
+      stm(db_w, sp, {fp, lr});
       mov(fp, Operand(sp));
       Push(marker_reg);
     } else {
-      stm(db_w, sp, marker_reg.bit() | fp.bit() | lr.bit());
+      stm(db_w, sp, {marker_reg, fp, lr});
       add(fp, sp, Operand(kPointerSize));
     }
   } else {
-    stm(db_w, sp, fp.bit() | lr.bit());
+    stm(db_w, sp, {fp, lr});
     mov(fp, sp);
   }
 }
@@ -892,9 +850,7 @@ void TurboAssembler::PushCommonFrame(Register marker_reg) {
 void TurboAssembler::PushStandardFrame(Register function_reg) {
   ASM_CODE_COMMENT(this);
   DCHECK(!function_reg.is_valid() || function_reg.code() < cp.code());
-  stm(db_w, sp,
-      (function_reg.is_valid() ? function_reg.bit() : 0) | cp.bit() | fp.bit() |
-          lr.bit());
+  stm(db_w, sp, {function_reg, cp, fp, lr});
   int offset = -StandardFrameConstants::kContextOffset;
   offset += function_reg.is_valid() ? kPointerSize : 0;
   add(fp, sp, Operand(offset));
@@ -1426,7 +1382,7 @@ int TurboAssembler::LeaveFrame(StackFrame::Type type) {
   // the caller frame pointer and return address.
   mov(sp, fp);
   int frame_ends = pc_offset();
-  ldm(ia_w, sp, fp.bit() | lr.bit());
+  ldm(ia_w, sp, {fp, lr});
   return frame_ends;
 }
 
@@ -1575,7 +1531,7 @@ void MacroAssembler::LeaveExitFrame(bool save_doubles, Register argument_count,
 
   // Tear down the exit frame, pop the arguments, and return.
   mov(sp, Operand(fp));
-  ldm(ia_w, sp, fp.bit() | lr.bit());
+  ldm(ia_w, sp, {fp, lr});
   if (argument_count.is_valid()) {
     if (argument_count_is_length) {
       add(sp, sp, argument_count);
@@ -2659,19 +2615,13 @@ void TurboAssembler::CheckPageFlag(Register object, int mask, Condition cc,
 Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
                                    Register reg4, Register reg5,
                                    Register reg6) {
-  RegList regs = 0;
-  if (reg1.is_valid()) regs |= reg1.bit();
-  if (reg2.is_valid()) regs |= reg2.bit();
-  if (reg3.is_valid()) regs |= reg3.bit();
-  if (reg4.is_valid()) regs |= reg4.bit();
-  if (reg5.is_valid()) regs |= reg5.bit();
-  if (reg6.is_valid()) regs |= reg6.bit();
+  RegList regs = {reg1, reg2, reg3, reg4, reg5, reg6};
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
   for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
     int code = config->GetAllocatableGeneralCode(i);
     Register candidate = Register::from_code(code);
-    if (regs & candidate.bit()) continue;
+    if (regs.has(candidate)) continue;
     return candidate;
   }
   UNREACHABLE();
diff --git a/src/codegen/arm/macro-assembler-arm.h b/src/codegen/arm/macro-assembler-arm.h
index e43aec485f..a17e1a964f 100644
--- a/src/codegen/arm/macro-assembler-arm.h
+++ b/src/codegen/arm/macro-assembler-arm.h
@@ -97,7 +97,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // Push two registers.  Pushes leftmost register first (to highest address).
   void Push(Register src1, Register src2, Condition cond = al) {
     if (src1.code() > src2.code()) {
-      stm(db_w, sp, src1.bit() | src2.bit(), cond);
+      stm(db_w, sp, {src1, src2}, cond);
     } else {
       str(src1, MemOperand(sp, 4, NegPreIndex), cond);
       str(src2, MemOperand(sp, 4, NegPreIndex), cond);
@@ -108,9 +108,9 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   void Push(Register src1, Register src2, Register src3, Condition cond = al) {
     if (src1.code() > src2.code()) {
       if (src2.code() > src3.code()) {
-        stm(db_w, sp, src1.bit() | src2.bit() | src3.bit(), cond);
+        stm(db_w, sp, {src1, src2, src3}, cond);
       } else {
-        stm(db_w, sp, src1.bit() | src2.bit(), cond);
+        stm(db_w, sp, {src1, src2}, cond);
         str(src3, MemOperand(sp, 4, NegPreIndex), cond);
       }
     } else {
@@ -125,14 +125,13 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
     if (src1.code() > src2.code()) {
       if (src2.code() > src3.code()) {
         if (src3.code() > src4.code()) {
-          stm(db_w, sp, src1.bit() | src2.bit() | src3.bit() | src4.bit(),
-              cond);
+          stm(db_w, sp, {src1, src2, src3, src4}, cond);
         } else {
-          stm(db_w, sp, src1.bit() | src2.bit() | src3.bit(), cond);
+          stm(db_w, sp, {src1, src2, src3}, cond);
           str(src4, MemOperand(sp, 4, NegPreIndex), cond);
         }
       } else {
-        stm(db_w, sp, src1.bit() | src2.bit(), cond);
+        stm(db_w, sp, {src1, src2}, cond);
         Push(src3, src4, cond);
       }
     } else {
@@ -148,20 +147,17 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
       if (src2.code() > src3.code()) {
         if (src3.code() > src4.code()) {
           if (src4.code() > src5.code()) {
-            stm(db_w, sp,
-                src1.bit() | src2.bit() | src3.bit() | src4.bit() | src5.bit(),
-                cond);
+            stm(db_w, sp, {src1, src2, src3, src4, src5}, cond);
           } else {
-            stm(db_w, sp, src1.bit() | src2.bit() | src3.bit() | src4.bit(),
-                cond);
+            stm(db_w, sp, {src1, src2, src3, src4}, cond);
             str(src5, MemOperand(sp, 4, NegPreIndex), cond);
           }
         } else {
-          stm(db_w, sp, src1.bit() | src2.bit() | src3.bit(), cond);
+          stm(db_w, sp, {src1, src2, src3}, cond);
           Push(src4, src5, cond);
         }
       } else {
-        stm(db_w, sp, src1.bit() | src2.bit(), cond);
+        stm(db_w, sp, {src1, src2}, cond);
         Push(src3, src4, src5, cond);
       }
     } else {
@@ -182,7 +178,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   void Pop(Register src1, Register src2, Condition cond = al) {
     DCHECK(src1 != src2);
     if (src1.code() > src2.code()) {
-      ldm(ia_w, sp, src1.bit() | src2.bit(), cond);
+      ldm(ia_w, sp, {src1, src2}, cond);
     } else {
       ldr(src2, MemOperand(sp, 4, PostIndex), cond);
       ldr(src1, MemOperand(sp, 4, PostIndex), cond);
@@ -194,10 +190,10 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
     DCHECK(!AreAliased(src1, src2, src3));
     if (src1.code() > src2.code()) {
       if (src2.code() > src3.code()) {
-        ldm(ia_w, sp, src1.bit() | src2.bit() | src3.bit(), cond);
+        ldm(ia_w, sp, {src1, src2, src3}, cond);
       } else {
         ldr(src3, MemOperand(sp, 4, PostIndex), cond);
-        ldm(ia_w, sp, src1.bit() | src2.bit(), cond);
+        ldm(ia_w, sp, {src1, src2}, cond);
       }
     } else {
       Pop(src2, src3, cond);
@@ -212,15 +208,14 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
     if (src1.code() > src2.code()) {
       if (src2.code() > src3.code()) {
         if (src3.code() > src4.code()) {
-          ldm(ia_w, sp, src1.bit() | src2.bit() | src3.bit() | src4.bit(),
-              cond);
+          ldm(ia_w, sp, {src1, src2, src3, src4}, cond);
         } else {
           ldr(src4, MemOperand(sp, 4, PostIndex), cond);
-          ldm(ia_w, sp, src1.bit() | src2.bit() | src3.bit(), cond);
+          ldm(ia_w, sp, {src1, src2, src3}, cond);
         }
       } else {
         Pop(src3, src4, cond);
-        ldm(ia_w, sp, src1.bit() | src2.bit(), cond);
+        ldm(ia_w, sp, {src1, src2}, cond);
       }
     } else {
       Pop(src2, src3, src4, cond);
diff --git a/src/codegen/arm/register-arm.h b/src/codegen/arm/register-arm.h
index 7a186f5e9c..810abcbdb0 100644
--- a/src/codegen/arm/register-arm.h
+++ b/src/codegen/arm/register-arm.h
@@ -6,8 +6,6 @@
 #define V8_CODEGEN_ARM_REGISTER_ARM_H_
 
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -62,40 +60,6 @@ namespace internal {
 // leave it alone. Adjust the value of kR9Available accordingly:
 const int kR9Available = 1;  // 1 if available to us, 0 if reserved
 
-// Register list in load/store instructions
-// Note that the bit values must match those used in actual instruction encoding
-
-// Caller-saved/arguments registers
-const RegList kJSCallerSaved = 1 << 0 |  // r0 a1
-                               1 << 1 |  // r1 a2
-                               1 << 2 |  // r2 a3
-                               1 << 3;   // r3 a4
-
-const int kNumJSCallerSaved = 4;
-
-// Callee-saved registers preserved when switching from C to JavaScript
-const RegList kCalleeSaved = 1 << 4 |  //  r4 v1
-                             1 << 5 |  //  r5 v2
-                             1 << 6 |  //  r6 v3
-                             1 << 7 |  //  r7 v4 (cp in JavaScript code)
-                             1 << 8 |  //  r8 v5 (pp in JavaScript code)
-                             kR9Available << 9 |  //  r9 v6
-                             1 << 10 |            // r10 v7
-                             1 << 11;  // r11 v8 (fp in JavaScript code)
-
-// When calling into C++ (only for C++ calls that can't cause a GC).
-// The call code will take care of lr, fp, etc.
-const RegList kCallerSaved = 1 << 0 |  // r0
-                             1 << 1 |  // r1
-                             1 << 2 |  // r2
-                             1 << 3 |  // r3
-                             1 << 9;   // r9
-
-const int kNumCalleeSaved = 7 + kR9Available;
-
-// Double registers d8 to d15 are callee-saved.
-const int kNumDoubleCalleeSaved = 8;
-
 enum RegisterCode {
 #define REGISTER_CODE(R) kRegCode_##R,
   GENERAL_REGISTERS(REGISTER_CODE)
@@ -357,6 +321,7 @@ constexpr Register kWasmCompileLazyFuncIndexRegister = r4;
 
 // Give alias names to registers
 constexpr Register cp = r7;              // JavaScript context pointer.
+constexpr Register r11 = fp;
 constexpr Register kRootRegister = r10;  // Roots array pointer.
 
 constexpr DoubleRegister kFPReturnRegister0 = d0;
diff --git a/src/codegen/arm/reglist-arm.h b/src/codegen/arm/reglist-arm.h
new file mode 100644
index 0000000000..c6834a5db5
--- /dev/null
+++ b/src/codegen/arm/reglist-arm.h
@@ -0,0 +1,56 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_ARM_REGLIST_ARM_H_
+#define V8_CODEGEN_ARM_REGLIST_ARM_H_
+
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+// Register list in load/store instructions
+// Note that the bit values must match those used in actual instruction encoding
+
+// Caller-saved/arguments registers
+const RegList kJSCallerSaved = {r0,   // r0 a1
+                                r1,   // r1 a2
+                                r2,   // r2 a3
+                                r3};  // r3 a4
+
+const int kNumJSCallerSaved = 4;
+
+// Callee-saved registers preserved when switching from C to JavaScript
+const RegList kCalleeSaved = {r4,  //  r4 v1
+                              r5,  //  r5 v2
+                              r6,  //  r6 v3
+                              r7,  //  r7 v4 (cp in JavaScript code)
+                              r8,  //  r8 v5 (pp in JavaScript code)
+                              kR9Available ? r9 : Register::no_reg(),  //  r9 v6
+                              r10,                                     // r10 v7
+                              r11};  // r11 v8 (fp in JavaScript code)
+
+// When calling into C++ (only for C++ calls that can't cause a GC).
+// The call code will take care of lr, fp, etc.
+const RegList kCallerSaved = {r0,   // r0
+                              r1,   // r1
+                              r2,   // r2
+                              r3,   // r3
+                              r9};  // r9
+
+const int kNumCalleeSaved = 7 + kR9Available;
+
+// Double registers d8 to d15 are callee-saved.
+const int kNumDoubleCalleeSaved = 8;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_ARM_REGLIST_ARM_H_
diff --git a/src/codegen/arm64/assembler-arm64-inl.h b/src/codegen/arm64/assembler-arm64-inl.h
index 51b72ceca0..4b22127696 100644
--- a/src/codegen/arm64/assembler-arm64-inl.h
+++ b/src/codegen/arm64/assembler-arm64-inl.h
@@ -54,12 +54,12 @@ inline bool CPURegister::IsSP() const {
 inline void CPURegList::Combine(const CPURegList& other) {
   DCHECK(other.type() == type_);
   DCHECK(other.RegisterSizeInBits() == size_);
-  list_ |= other.list();
+  list_ |= other.list_;
 }
 
 inline void CPURegList::Remove(const CPURegList& other) {
   if (other.type() == type_) {
-    list_ &= ~other.list();
+    list_ &= ~other.list_;
   }
 }
 
diff --git a/src/codegen/arm64/assembler-arm64.cc b/src/codegen/arm64/assembler-arm64.cc
index cef21d0106..1edc2bd6cb 100644
--- a/src/codegen/arm64/assembler-arm64.cc
+++ b/src/codegen/arm64/assembler-arm64.cc
@@ -228,18 +228,18 @@ bool AreAliased(const CPURegister& reg1, const CPURegister& reg2,
   int number_of_valid_regs = 0;
   int number_of_valid_fpregs = 0;
 
-  RegList unique_regs = 0;
-  RegList unique_fpregs = 0;
+  uint64_t unique_regs = 0;
+  uint64_t unique_fpregs = 0;
 
   const CPURegister regs[] = {reg1, reg2, reg3, reg4, reg5, reg6, reg7, reg8};
 
   for (unsigned i = 0; i < arraysize(regs); i++) {
     if (regs[i].IsRegister()) {
       number_of_valid_regs++;
-      unique_regs |= regs[i].bit();
+      unique_regs |= (uint64_t{1} << regs[i].code());
     } else if (regs[i].IsVRegister()) {
       number_of_valid_fpregs++;
-      unique_fpregs |= regs[i].bit();
+      unique_fpregs |= (uint64_t{1} << regs[i].code());
     } else {
       DCHECK(!regs[i].is_valid());
     }
diff --git a/src/codegen/arm64/interface-descriptors-arm64-inl.h b/src/codegen/arm64/interface-descriptors-arm64-inl.h
index 0990ce981e..709a01264d 100644
--- a/src/codegen/arm64/interface-descriptors-arm64-inl.h
+++ b/src/codegen/arm64/interface-descriptors-arm64-inl.h
@@ -25,20 +25,21 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | x0.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | x1.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | x2.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | x3.bit());
-  if (argc >= 5) DCHECK(allocatable_regs | x4.bit());
-  if (argc >= 6) DCHECK(allocatable_regs | x5.bit());
-  if (argc >= 7) DCHECK(allocatable_regs | x6.bit());
-  if (argc >= 8) DCHECK(allocatable_regs | x7.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(x0));
+  if (argc >= 2) DCHECK(allocatable_regs.has(x1));
+  if (argc >= 3) DCHECK(allocatable_regs.has(x2));
+  if (argc >= 4) DCHECK(allocatable_regs.has(x3));
+  if (argc >= 5) DCHECK(allocatable_regs.has(x4));
+  if (argc >= 6) DCHECK(allocatable_regs.has(x5));
+  if (argc >= 7) DCHECK(allocatable_regs.has(x6));
+  if (argc >= 8) DCHECK(allocatable_regs.has(x7));
 }
 #endif  // DEBUG
 
 // static
 constexpr auto WriteBarrierDescriptor::registers() {
-  return RegisterArray(x1, x5, x4, x2, x0, x3);
+  // TODO(leszeks): Remove x7 which is just there for padding.
+  return RegisterArray(x1, x5, x4, x2, x0, x3, kContextRegister, x7);
 }
 
 // static
diff --git a/src/codegen/arm64/macro-assembler-arm64.cc b/src/codegen/arm64/macro-assembler-arm64.cc
index ee13836872..6ea0322afe 100644
--- a/src/codegen/arm64/macro-assembler-arm64.cc
+++ b/src/codegen/arm64/macro-assembler-arm64.cc
@@ -3134,9 +3134,9 @@ void TurboAssembler::LoadExternalPointerField(Register destination,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
+  if (registers.is_empty()) return;
   ASM_CODE_COMMENT(this);
-  CPURegList regs(CPURegister::kRegister, kXRegSizeInBits, registers);
+  CPURegList regs(kXRegSizeInBits, registers);
   // If we were saving LR, we might need to sign it.
   DCHECK(!regs.IncludesAliasOf(lr));
   regs.Align();
@@ -3144,9 +3144,9 @@ void TurboAssembler::MaybeSaveRegisters(RegList registers) {
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
+  if (registers.is_empty()) return;
   ASM_CODE_COMMENT(this);
-  CPURegList regs(CPURegister::kRegister, kXRegSizeInBits, registers);
+  CPURegList regs(kXRegSizeInBits, registers);
   // If we were saving LR, we might need to sign it.
   DCHECK(!regs.IncludesAliasOf(lr));
   regs.Align();
@@ -3346,7 +3346,7 @@ void TurboAssembler::Abort(AbortReason reason) {
 
   // We need some scratch registers for the MacroAssembler, so make sure we have
   // some. This is safe here because Abort never returns.
-  RegList old_tmp_list = TmpList()->list();
+  uint64_t old_tmp_list = TmpList()->bits();
   TmpList()->Combine(MacroAssembler::DefaultTmpList());
 
   if (should_abort_hard()) {
@@ -3371,7 +3371,7 @@ void TurboAssembler::Abort(AbortReason reason) {
     Call(BUILTIN_CODE(isolate(), Abort), RelocInfo::CODE_TARGET);
   }
 
-  TmpList()->set_list(old_tmp_list);
+  TmpList()->set_bits(old_tmp_list);
 }
 
 void MacroAssembler::LoadNativeContextSlot(Register dst, int index) {
@@ -3421,8 +3421,8 @@ void TurboAssembler::PrintfNoPreserve(const char* format,
   // Override the TurboAssembler's scratch register list. The lists will be
   // reset automatically at the end of the UseScratchRegisterScope.
   UseScratchRegisterScope temps(this);
-  TmpList()->set_list(tmp_list.list());
-  FPTmpList()->set_list(fp_tmp_list.list());
+  TmpList()->set_bits(tmp_list.bits());
+  FPTmpList()->set_bits(fp_tmp_list.bits());
 
   // Copies of the printf vararg registers that we can pop from.
   CPURegList pcs_varargs = kPCSVarargs;
@@ -3570,10 +3570,10 @@ void TurboAssembler::Printf(const char* format, CPURegister arg0,
   ASM_CODE_COMMENT(this);
   // Printf is expected to preserve all registers, so make sure that none are
   // available as scratch registers until we've preserved them.
-  RegList old_tmp_list = TmpList()->list();
-  RegList old_fp_tmp_list = FPTmpList()->list();
-  TmpList()->set_list(0);
-  FPTmpList()->set_list(0);
+  uint64_t old_tmp_list = TmpList()->bits();
+  uint64_t old_fp_tmp_list = FPTmpList()->bits();
+  TmpList()->set_bits(0);
+  FPTmpList()->set_bits(0);
 
   CPURegList saved_registers = kCallerSaved;
   saved_registers.Align();
@@ -3589,8 +3589,8 @@ void TurboAssembler::Printf(const char* format, CPURegister arg0,
   CPURegList fp_tmp_list = kCallerSavedV;
   tmp_list.Remove(arg0, arg1, arg2, arg3);
   fp_tmp_list.Remove(arg0, arg1, arg2, arg3);
-  TmpList()->set_list(tmp_list.list());
-  FPTmpList()->set_list(fp_tmp_list.list());
+  TmpList()->set_bits(tmp_list.bits());
+  FPTmpList()->set_bits(fp_tmp_list.bits());
 
   {
     UseScratchRegisterScope temps(this);
@@ -3636,13 +3636,13 @@ void TurboAssembler::Printf(const char* format, CPURegister arg0,
   PopCPURegList(kCallerSavedV);
   PopCPURegList<kDontLoadLR>(saved_registers);
 
-  TmpList()->set_list(old_tmp_list);
-  FPTmpList()->set_list(old_fp_tmp_list);
+  TmpList()->set_bits(old_tmp_list);
+  FPTmpList()->set_bits(old_fp_tmp_list);
 }
 
 UseScratchRegisterScope::~UseScratchRegisterScope() {
-  available_->set_list(old_available_);
-  availablefp_->set_list(old_availablefp_);
+  available_->set_bits(old_available_);
+  availablefp_->set_bits(old_availablefp_);
 }
 
 Register UseScratchRegisterScope::AcquireSameSizeAs(const Register& reg) {
diff --git a/src/codegen/arm64/macro-assembler-arm64.h b/src/codegen/arm64/macro-assembler-arm64.h
index 3a54283d5a..022d84cb60 100644
--- a/src/codegen/arm64/macro-assembler-arm64.h
+++ b/src/codegen/arm64/macro-assembler-arm64.h
@@ -1755,16 +1755,20 @@ class V8_EXPORT_PRIVATE MacroAssembler : public TurboAssembler {
   // For the 'lr_mode' template argument of the following methods, see
   // PushCPURegList/PopCPURegList.
   template <StoreLRMode lr_mode = kDontStoreLR>
-  inline void PushSizeRegList(
-      RegList registers, unsigned reg_size,
-      CPURegister::RegisterType type = CPURegister::kRegister) {
-    PushCPURegList<lr_mode>(CPURegList(type, reg_size, registers));
+  inline void PushSizeRegList(RegList registers, unsigned reg_size) {
+    PushCPURegList<lr_mode>(CPURegList(reg_size, registers));
+  }
+  template <StoreLRMode lr_mode = kDontStoreLR>
+  inline void PushSizeRegList(DoubleRegList registers, unsigned reg_size) {
+    PushCPURegList<lr_mode>(CPURegList(reg_size, registers));
+  }
+  template <LoadLRMode lr_mode = kDontLoadLR>
+  inline void PopSizeRegList(RegList registers, unsigned reg_size) {
+    PopCPURegList<lr_mode>(CPURegList(reg_size, registers));
   }
   template <LoadLRMode lr_mode = kDontLoadLR>
-  inline void PopSizeRegList(
-      RegList registers, unsigned reg_size,
-      CPURegister::RegisterType type = CPURegister::kRegister) {
-    PopCPURegList<lr_mode>(CPURegList(type, reg_size, registers));
+  inline void PopSizeRegList(DoubleRegList registers, unsigned reg_size) {
+    PopCPURegList<lr_mode>(CPURegList(reg_size, registers));
   }
   template <StoreLRMode lr_mode = kDontStoreLR>
   inline void PushXRegList(RegList regs) {
@@ -1780,23 +1784,23 @@ class V8_EXPORT_PRIVATE MacroAssembler : public TurboAssembler {
   inline void PopWRegList(RegList regs) {
     PopSizeRegList(regs, kWRegSizeInBits);
   }
-  inline void PushQRegList(RegList regs) {
-    PushSizeRegList(regs, kQRegSizeInBits, CPURegister::kVRegister);
+  inline void PushQRegList(DoubleRegList regs) {
+    PushSizeRegList(regs, kQRegSizeInBits);
   }
-  inline void PopQRegList(RegList regs) {
-    PopSizeRegList(regs, kQRegSizeInBits, CPURegister::kVRegister);
+  inline void PopQRegList(DoubleRegList regs) {
+    PopSizeRegList(regs, kQRegSizeInBits);
   }
-  inline void PushDRegList(RegList regs) {
-    PushSizeRegList(regs, kDRegSizeInBits, CPURegister::kVRegister);
+  inline void PushDRegList(DoubleRegList regs) {
+    PushSizeRegList(regs, kDRegSizeInBits);
   }
-  inline void PopDRegList(RegList regs) {
-    PopSizeRegList(regs, kDRegSizeInBits, CPURegister::kVRegister);
+  inline void PopDRegList(DoubleRegList regs) {
+    PopSizeRegList(regs, kDRegSizeInBits);
   }
-  inline void PushSRegList(RegList regs) {
-    PushSizeRegList(regs, kSRegSizeInBits, CPURegister::kVRegister);
+  inline void PushSRegList(DoubleRegList regs) {
+    PushSizeRegList(regs, kSRegSizeInBits);
   }
-  inline void PopSRegList(RegList regs) {
-    PopSizeRegList(regs, kSRegSizeInBits, CPURegister::kVRegister);
+  inline void PopSRegList(DoubleRegList regs) {
+    PopSizeRegList(regs, kSRegSizeInBits);
   }
 
   // Push the specified register 'count' times.
@@ -2154,8 +2158,8 @@ class V8_NODISCARD UseScratchRegisterScope {
   explicit UseScratchRegisterScope(TurboAssembler* tasm)
       : available_(tasm->TmpList()),
         availablefp_(tasm->FPTmpList()),
-        old_available_(available_->list()),
-        old_availablefp_(availablefp_->list()) {
+        old_available_(available_->bits()),
+        old_availablefp_(availablefp_->bits()) {
     DCHECK_EQ(available_->type(), CPURegister::kRegister);
     DCHECK_EQ(availablefp_->type(), CPURegister::kVRegister);
   }
@@ -2205,8 +2209,8 @@ class V8_NODISCARD UseScratchRegisterScope {
   CPURegList* availablefp_;  // kVRegister
 
   // The state of the available lists at the start of this scope.
-  RegList old_available_;    // kRegister
-  RegList old_availablefp_;  // kVRegister
+  uint64_t old_available_;    // kRegister
+  uint64_t old_availablefp_;  // kVRegister
 };
 
 }  // namespace internal
diff --git a/src/codegen/arm64/register-arm64.h b/src/codegen/arm64/register-arm64.h
index 7fdd2ee5b8..83fb23098a 100644
--- a/src/codegen/arm64/register-arm64.h
+++ b/src/codegen/arm64/register-arm64.h
@@ -7,8 +7,6 @@
 
 #include "src/codegen/arm64/utils-arm64.h"
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 #include "src/common/globals.h"
 
 namespace v8 {
@@ -80,8 +78,6 @@ namespace internal {
   R(d25) R(d26) R(d27) R(d28)
 // clang-format on
 
-constexpr int kRegListSizeInBits = sizeof(RegList) * kBitsPerByte;
-
 // Some CPURegister methods can return Register and VRegister types, so we
 // need to declare them in advance.
 class Register;
@@ -244,19 +240,6 @@ class Register : public CPURegister {
     return Register::Create(code, kXRegSizeInBits);
   }
 
-  // Copied from RegisterBase since there's no CPURegister::from_code.
-  static constexpr Register FirstOf(RegList list) {
-    DCHECK_NE(kEmptyRegList, list);
-    return from_code(base::bits::CountTrailingZerosNonZero(list));
-  }
-
-  static constexpr Register TakeFirst(RegList* list) {
-    RegList value = *list;
-    Register result = FirstOf(value);
-    result.RemoveFrom(list);
-    return result;
-  }
-
   static const char* GetSpecialRegisterName(int code) {
     return (code == kSPRegInternalCode) ? "sp" : "UNKNOWN";
   }
@@ -563,150 +546,6 @@ using FloatRegister = VRegister;
 using DoubleRegister = VRegister;
 using Simd128Register = VRegister;
 
-// -----------------------------------------------------------------------------
-// Lists of registers.
-class V8_EXPORT_PRIVATE CPURegList {
- public:
-  template <typename... CPURegisters>
-  explicit CPURegList(CPURegister reg0, CPURegisters... regs)
-      : list_(CPURegister::ListOf(reg0, regs...)),
-        size_(reg0.SizeInBits()),
-        type_(reg0.type()) {
-    DCHECK(AreSameSizeAndType(reg0, regs...));
-    DCHECK(is_valid());
-  }
-
-  CPURegList(CPURegister::RegisterType type, int size, RegList list)
-      : list_(list), size_(size), type_(type) {
-    DCHECK(is_valid());
-  }
-
-  CPURegList(CPURegister::RegisterType type, int size, int first_reg,
-             int last_reg)
-      : size_(size), type_(type) {
-    DCHECK(
-        ((type == CPURegister::kRegister) && (last_reg < kNumberOfRegisters)) ||
-        ((type == CPURegister::kVRegister) &&
-         (last_reg < kNumberOfVRegisters)));
-    DCHECK(last_reg >= first_reg);
-    list_ = (1ULL << (last_reg + 1)) - 1;
-    list_ &= ~((1ULL << first_reg) - 1);
-    DCHECK(is_valid());
-  }
-
-  CPURegister::RegisterType type() const {
-    return type_;
-  }
-
-  RegList list() const {
-    return list_;
-  }
-
-  inline void set_list(RegList new_list) {
-    list_ = new_list;
-    DCHECK(is_valid());
-  }
-
-  // Combine another CPURegList into this one. Registers that already exist in
-  // this list are left unchanged. The type and size of the registers in the
-  // 'other' list must match those in this list.
-  void Combine(const CPURegList& other);
-
-  // Remove every register in the other CPURegList from this one. Registers that
-  // do not exist in this list are ignored. The type of the registers in the
-  // 'other' list must match those in this list.
-  void Remove(const CPURegList& other);
-
-  // Variants of Combine and Remove which take CPURegisters.
-  void Combine(const CPURegister& other);
-  void Remove(const CPURegister& other1, const CPURegister& other2 = NoCPUReg,
-              const CPURegister& other3 = NoCPUReg,
-              const CPURegister& other4 = NoCPUReg);
-
-  // Variants of Combine and Remove which take a single register by its code;
-  // the type and size of the register is inferred from this list.
-  void Combine(int code);
-  void Remove(int code);
-
-  // Align the list to 16 bytes.
-  void Align();
-
-  CPURegister PopLowestIndex();
-  CPURegister PopHighestIndex();
-
-  // AAPCS64 callee-saved registers.
-  static CPURegList GetCalleeSaved(int size = kXRegSizeInBits);
-  static CPURegList GetCalleeSavedV(int size = kDRegSizeInBits);
-
-  // AAPCS64 caller-saved registers. Note that this includes lr.
-  // TODO(all): Determine how we handle d8-d15 being callee-saved, but the top
-  // 64-bits being caller-saved.
-  static CPURegList GetCallerSaved(int size = kXRegSizeInBits);
-  static CPURegList GetCallerSavedV(int size = kDRegSizeInBits);
-
-  bool IsEmpty() const {
-    return list_ == 0;
-  }
-
-  bool IncludesAliasOf(const CPURegister& other1,
-                       const CPURegister& other2 = NoCPUReg,
-                       const CPURegister& other3 = NoCPUReg,
-                       const CPURegister& other4 = NoCPUReg) const {
-    RegList list = 0;
-    if (!other1.IsNone() && (other1.type() == type_)) list |= other1.bit();
-    if (!other2.IsNone() && (other2.type() == type_)) list |= other2.bit();
-    if (!other3.IsNone() && (other3.type() == type_)) list |= other3.bit();
-    if (!other4.IsNone() && (other4.type() == type_)) list |= other4.bit();
-    return (list_ & list) != 0;
-  }
-
-  int Count() const {
-    return CountSetBits(list_, kRegListSizeInBits);
-  }
-
-  int RegisterSizeInBits() const {
-    return size_;
-  }
-
-  int RegisterSizeInBytes() const {
-    int size_in_bits = RegisterSizeInBits();
-    DCHECK_EQ(size_in_bits % kBitsPerByte, 0);
-    return size_in_bits / kBitsPerByte;
-  }
-
-  int TotalSizeInBytes() const {
-    return RegisterSizeInBytes() * Count();
-  }
-
- private:
-  RegList list_;
-  int size_;
-  CPURegister::RegisterType type_;
-
-  bool is_valid() const {
-    constexpr RegList kValidRegisters{0x8000000ffffffff};
-    constexpr RegList kValidVRegisters{0x0000000ffffffff};
-    switch (type_) {
-      case CPURegister::kRegister:
-        return (list_ & kValidRegisters) == list_;
-      case CPURegister::kVRegister:
-        return (list_ & kValidVRegisters) == list_;
-      case CPURegister::kNoRegister:
-        return list_ == 0;
-      default:
-        UNREACHABLE();
-    }
-  }
-};
-
-// AAPCS64 callee-saved registers.
-#define kCalleeSaved CPURegList::GetCalleeSaved()
-#define kCalleeSavedV CPURegList::GetCalleeSavedV()
-
-// AAPCS64 caller-saved registers. Note that this includes lr.
-#define kCallerSaved CPURegList::GetCallerSaved()
-#define kCallerSavedV CPURegList::GetCallerSavedV()
-
 // Define a {RegisterName} method for {Register} and {VRegister}.
 DEFINE_REGISTER_NAMES(Register, GENERAL_REGISTERS)
 DEFINE_REGISTER_NAMES(VRegister, VECTOR_REGISTERS)
diff --git a/src/codegen/arm64/reglist-arm64.h b/src/codegen/arm64/reglist-arm64.h
new file mode 100644
index 0000000000..9f29589098
--- /dev/null
+++ b/src/codegen/arm64/reglist-arm64.h
@@ -0,0 +1,176 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_ARM64_REGLIST_ARM64_H_
+#define V8_CODEGEN_ARM64_REGLIST_ARM64_H_
+
+#include "src/codegen/arm64/utils-arm64.h"
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+#include "src/common/globals.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+constexpr int kRegListSizeInBits = sizeof(RegList) * kBitsPerByte;
+
+// -----------------------------------------------------------------------------
+// Lists of registers.
+class V8_EXPORT_PRIVATE CPURegList {
+ public:
+  template <typename... CPURegisters>
+  explicit CPURegList(CPURegister reg0, CPURegisters... regs)
+      : list_(base::fold(
+            [](uint64_t acc, CPURegister v) {
+              if (!v.is_valid()) return acc;
+              return acc | (uint64_t{1} << v.code());
+            },
+            0, reg0, regs...)),
+        size_(reg0.SizeInBits()),
+        type_(reg0.type()) {
+    DCHECK(AreSameSizeAndType(reg0, regs...));
+    DCHECK(is_valid());
+  }
+
+  CPURegList(int size, RegList list)
+      : list_(list.bits()), size_(size), type_(CPURegister::kRegister) {
+    DCHECK(is_valid());
+  }
+
+  CPURegList(int size, DoubleRegList list)
+      : list_(list.bits()), size_(size), type_(CPURegister::kVRegister) {
+    DCHECK(is_valid());
+  }
+
+  CPURegList(CPURegister::RegisterType type, int size, int first_reg,
+             int last_reg)
+      : size_(size), type_(type) {
+    DCHECK(
+        ((type == CPURegister::kRegister) && (last_reg < kNumberOfRegisters)) ||
+        ((type == CPURegister::kVRegister) &&
+         (last_reg < kNumberOfVRegisters)));
+    DCHECK(last_reg >= first_reg);
+    list_ = (1ULL << (last_reg + 1)) - 1;
+    list_ &= ~((1ULL << first_reg) - 1);
+    DCHECK(is_valid());
+  }
+
+  CPURegister::RegisterType type() const { return type_; }
+
+  uint64_t bits() const { return list_; }
+
+  inline void set_bits(uint64_t new_bits) {
+    list_ = new_bits;
+    DCHECK(is_valid());
+  }
+
+  // Combine another CPURegList into this one. Registers that already exist in
+  // this list are left unchanged. The type and size of the registers in the
+  // 'other' list must match those in this list.
+  void Combine(const CPURegList& other);
+
+  // Remove every register in the other CPURegList from this one. Registers that
+  // do not exist in this list are ignored. The type of the registers in the
+  // 'other' list must match those in this list.
+  void Remove(const CPURegList& other);
+
+  // Variants of Combine and Remove which take CPURegisters.
+  void Combine(const CPURegister& other);
+  void Remove(const CPURegister& other1, const CPURegister& other2 = NoCPUReg,
+              const CPURegister& other3 = NoCPUReg,
+              const CPURegister& other4 = NoCPUReg);
+
+  // Variants of Combine and Remove which take a single register by its code;
+  // the type and size of the register is inferred from this list.
+  void Combine(int code);
+  void Remove(int code);
+
+  // Align the list to 16 bytes.
+  void Align();
+
+  CPURegister PopLowestIndex();
+  CPURegister PopHighestIndex();
+
+  // AAPCS64 callee-saved registers.
+  static CPURegList GetCalleeSaved(int size = kXRegSizeInBits);
+  static CPURegList GetCalleeSavedV(int size = kDRegSizeInBits);
+
+  // AAPCS64 caller-saved registers. Note that this includes lr.
+  // TODO(all): Determine how we handle d8-d15 being callee-saved, but the top
+  // 64-bits being caller-saved.
+  static CPURegList GetCallerSaved(int size = kXRegSizeInBits);
+  static CPURegList GetCallerSavedV(int size = kDRegSizeInBits);
+
+  bool IsEmpty() const { return list_ == 0; }
+
+  bool IncludesAliasOf(const CPURegister& other1,
+                       const CPURegister& other2 = NoCPUReg,
+                       const CPURegister& other3 = NoCPUReg,
+                       const CPURegister& other4 = NoCPUReg) const {
+    uint64_t list = 0;
+    if (!other1.IsNone() && (other1.type() == type_)) {
+      list |= (uint64_t{1} << other1.code());
+    }
+    if (!other2.IsNone() && (other2.type() == type_)) {
+      list |= (uint64_t{1} << other2.code());
+    }
+    if (!other3.IsNone() && (other3.type() == type_)) {
+      list |= (uint64_t{1} << other3.code());
+    }
+    if (!other4.IsNone() && (other4.type() == type_)) {
+      list |= (uint64_t{1} << other4.code());
+    }
+    return (list_ & list) != 0;
+  }
+
+  int Count() const { return CountSetBits(list_, kRegListSizeInBits); }
+
+  int RegisterSizeInBits() const { return size_; }
+
+  int RegisterSizeInBytes() const {
+    int size_in_bits = RegisterSizeInBits();
+    DCHECK_EQ(size_in_bits % kBitsPerByte, 0);
+    return size_in_bits / kBitsPerByte;
+  }
+
+  int TotalSizeInBytes() const { return RegisterSizeInBytes() * Count(); }
+
+ private:
+  uint64_t list_;
+  int size_;
+  CPURegister::RegisterType type_;
+
+  bool is_valid() const {
+    constexpr uint64_t kValidRegisters{0x8000000ffffffff};
+    constexpr uint64_t kValidVRegisters{0x0000000ffffffff};
+    switch (type_) {
+      case CPURegister::kRegister:
+        return (list_ & kValidRegisters) == list_;
+      case CPURegister::kVRegister:
+        return (list_ & kValidVRegisters) == list_;
+      case CPURegister::kNoRegister:
+        return list_ == 0;
+      default:
+        UNREACHABLE();
+    }
+  }
+};
+
+// AAPCS64 callee-saved registers.
+#define kCalleeSaved CPURegList::GetCalleeSaved()
+#define kCalleeSavedV CPURegList::GetCalleeSavedV()
+
+// AAPCS64 caller-saved registers. Note that this includes lr.
+#define kCallerSaved CPURegList::GetCallerSaved()
+#define kCallerSavedV CPURegList::GetCallerSavedV()
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_ARM64_REGLIST_ARM64_H_
diff --git a/src/codegen/ia32/interface-descriptors-ia32-inl.h b/src/codegen/ia32/interface-descriptors-ia32-inl.h
index 09b6a6a635..2da91a0f59 100644
--- a/src/codegen/ia32/interface-descriptors-ia32-inl.h
+++ b/src/codegen/ia32/interface-descriptors-ia32-inl.h
@@ -24,8 +24,8 @@ void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data,
                                 int nof_expected_args) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (nof_expected_args >= 1) DCHECK(allocatable_regs | esi.bit());
-  if (nof_expected_args >= 2) DCHECK(allocatable_regs | edi.bit());
+  if (nof_expected_args >= 1) DCHECK(allocatable_regs.has(esi));
+  if (nof_expected_args >= 2) DCHECK(allocatable_regs.has(edi));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/ia32/macro-assembler-ia32.cc b/src/codegen/ia32/macro-assembler-ia32.cc
index de0e083c4b..0678ad31c5 100644
--- a/src/codegen/ia32/macro-assembler-ia32.cc
+++ b/src/codegen/ia32/macro-assembler-ia32.cc
@@ -428,22 +428,14 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  ASM_CODE_COMMENT(this);
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      push(Register::from_code(i));
-    }
+  for (Register reg : registers) {
+    push(reg);
   }
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  ASM_CODE_COMMENT(this);
-  for (int i = Register::kNumRegisters - 1; i >= 0; --i) {
-    if ((registers >> i) & 1u) {
-      pop(Register::from_code(i));
-    }
+  for (Register reg : base::Reversed(registers)) {
+    pop(reg);
   }
 }
 
diff --git a/src/codegen/ia32/register-ia32.h b/src/codegen/ia32/register-ia32.h
index 9337fdfa10..e06a372ea6 100644
--- a/src/codegen/ia32/register-ia32.h
+++ b/src/codegen/ia32/register-ia32.h
@@ -6,8 +6,6 @@
 #define V8_CODEGEN_IA32_REGISTER_IA32_H_
 
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -113,14 +111,6 @@ constexpr DoubleRegister no_dreg = DoubleRegister::no_reg();
 // Note that the bit values must match those used in actual instruction encoding
 constexpr int kNumRegs = 8;
 
-// Caller-saved registers
-constexpr RegList kJSCallerSaved =
-    Register::ListOf(eax, ecx, edx,
-                     ebx,   // used as caller-saved register in JavaScript code
-                     edi);  // callee function
-
-constexpr int kNumJSCallerSaved = 5;
-
 // Define {RegisterName} methods for the register types.
 DEFINE_REGISTER_NAMES(Register, GENERAL_REGISTERS)
 DEFINE_REGISTER_NAMES(XMMRegister, DOUBLE_REGISTERS)
diff --git a/src/codegen/ia32/reglist-ia32.h b/src/codegen/ia32/reglist-ia32.h
new file mode 100644
index 0000000000..e8f3448dd9
--- /dev/null
+++ b/src/codegen/ia32/reglist-ia32.h
@@ -0,0 +1,30 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_IA32_REGLIST_IA32_H_
+#define V8_CODEGEN_IA32_REGLIST_IA32_H_
+
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+// Caller-saved registers
+constexpr RegList kJSCallerSaved = {
+    eax, ecx, edx,
+    ebx,   // used as caller-saved register in JavaScript code
+    edi};  // callee function
+
+constexpr int kNumJSCallerSaved = 5;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_IA32_REGLIST_IA32_H_
diff --git a/src/codegen/interface-descriptors-inl.h b/src/codegen/interface-descriptors-inl.h
index 8f26b88cd0..349874e2b7 100644
--- a/src/codegen/interface-descriptors-inl.h
+++ b/src/codegen/interface-descriptors-inl.h
@@ -217,24 +217,24 @@ constexpr Register WriteBarrierDescriptor::ValueRegister() {
 constexpr RegList WriteBarrierDescriptor::ComputeSavedRegisters(
     Register object, Register slot_address) {
   DCHECK(!AreAliased(object, slot_address));
-  RegList saved_registers = 0;
+  RegList saved_registers;
 #if V8_TARGET_ARCH_X64
   // Only push clobbered registers.
-  if (object != ObjectRegister()) saved_registers |= ObjectRegister().bit();
+  if (object != ObjectRegister()) saved_registers.set(ObjectRegister());
   if (slot_address != no_reg && slot_address != SlotAddressRegister()) {
-    saved_registers |= SlotAddressRegister().bit();
+    saved_registers.set(SlotAddressRegister());
   }
 #elif V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_LOONG64 || \
     V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_MIPS
-  if (object != ObjectRegister()) saved_registers |= ObjectRegister().bit();
+  if (object != ObjectRegister()) saved_registers.set(ObjectRegister());
   // The slot address is always clobbered.
-  saved_registers |= SlotAddressRegister().bit();
+  saved_registers.set(SlotAddressRegister());
 #else
   // TODO(cbruni): Enable callee-saved registers for other platforms.
   // This is a temporary workaround to prepare code for callee-saved registers.
   constexpr auto allocated_registers = registers();
   for (size_t i = 0; i < allocated_registers.size(); ++i) {
-    saved_registers |= allocated_registers[i].bit();
+    saved_registers.set(allocated_registers[i]);
   }
 #endif
   return saved_registers;
diff --git a/src/codegen/interface-descriptors.cc b/src/codegen/interface-descriptors.cc
index a30299011d..5f7d09fb2a 100644
--- a/src/codegen/interface-descriptors.cc
+++ b/src/codegen/interface-descriptors.cc
@@ -19,16 +19,16 @@ void CallInterfaceDescriptorData::InitializeRegisters(
 #ifdef DEBUG
   {
     // Make sure that the registers are all valid, and don't alias each other.
-    RegList reglist = 0;
+    RegList reglist;
     for (int i = 0; i < register_parameter_count; ++i) {
       Register reg = registers[i];
       DCHECK(reg.is_valid());
-      DCHECK_EQ(reglist & reg.bit(), 0);
+      DCHECK(!reglist.has(reg));
       DCHECK_NE(reg, kRootRegister);
 #ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE
       DCHECK_NE(reg, kPtrComprCageBaseRegister);
 #endif
-      reglist = CombineRegLists(reglist, reg.bit());
+      reglist.set(reg);
     }
   }
 #endif
@@ -145,8 +145,8 @@ void WriteBarrierDescriptor::Verify(CallInterfaceDescriptorData* data) {
   DCHECK_EQ(ObjectRegister(), kJSFunctionRegister);
   // We need a certain set of registers by default:
   RegList allocatable_regs = data->allocatable_registers();
-  DCHECK(allocatable_regs | kContextRegister.bit());
-  DCHECK(allocatable_regs | kReturnRegister0.bit());
+  DCHECK(allocatable_regs.has(kContextRegister));
+  DCHECK(allocatable_regs.has(kReturnRegister0));
   VerifyArgumentRegisterCount(data, 4);
 }
 #endif  // DEBUG
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index df857ae349..3e10c6dcd7 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -213,11 +213,11 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   StackArgumentOrder stack_order() const { return stack_order_; }
 
   void RestrictAllocatableRegisters(const Register* registers, size_t num) {
-    DCHECK_EQ(allocatable_registers_, 0);
+    DCHECK(allocatable_registers_.is_empty());
     for (size_t i = 0; i < num; ++i) {
-      allocatable_registers_ |= registers[i].bit();
+      allocatable_registers_.set(registers[i]);
     }
-    DCHECK_GT(NumRegs(allocatable_registers_), 0);
+    DCHECK(!allocatable_registers_.is_empty());
   }
 
   RegList allocatable_registers() const { return allocatable_registers_; }
@@ -249,7 +249,7 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
 
   // Specifying the set of registers that could be used by the register
   // allocator. Currently, it's only used by RecordWrite code stub.
-  RegList allocatable_registers_ = 0;
+  RegList allocatable_registers_;
 
   // |registers_params_| defines registers that are used for parameter passing.
   // |machine_types_| defines machine types for resulting values and incomping
diff --git a/src/codegen/loong64/assembler-loong64.cc b/src/codegen/loong64/assembler-loong64.cc
index ba6ce33508..dc2a5a3b42 100644
--- a/src/codegen/loong64/assembler-loong64.cc
+++ b/src/codegen/loong64/assembler-loong64.cc
@@ -167,7 +167,7 @@ void Assembler::AllocateAndInstallRequestedHeapObjects(Isolate* isolate) {
 Assembler::Assembler(const AssemblerOptions& options,
                      std::unique_ptr<AssemblerBuffer> buffer)
     : AssemblerBase(options, std::move(buffer)),
-      scratch_register_list_(t7.bit() | t6.bit()) {
+      scratch_register_list_({t7, t6}) {
   reloc_info_writer.Reposition(buffer_start_ + buffer_->size(), pc_);
 
   last_trampoline_pool_end_ = 0;
diff --git a/src/codegen/loong64/assembler-loong64.h b/src/codegen/loong64/assembler-loong64.h
index 63fe001d22..6725c3279e 100644
--- a/src/codegen/loong64/assembler-loong64.h
+++ b/src/codegen/loong64/assembler-loong64.h
@@ -1093,11 +1093,11 @@ class V8_EXPORT_PRIVATE V8_NODISCARD UseScratchRegisterScope {
   void Include(const RegList& list) { *available_ |= list; }
   void Exclude(const RegList& list) { *available_ &= ~list; }
   void Include(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Include(list);
   }
   void Exclude(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Exclude(list);
   }
 
diff --git a/src/codegen/loong64/interface-descriptors-loong64-inl.h b/src/codegen/loong64/interface-descriptors-loong64-inl.h
index fbd28380ea..54baac761f 100644
--- a/src/codegen/loong64/interface-descriptors-loong64-inl.h
+++ b/src/codegen/loong64/interface-descriptors-loong64-inl.h
@@ -24,14 +24,14 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | a0.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | a1.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | a2.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | a3.bit());
-  if (argc >= 5) DCHECK(allocatable_regs | a4.bit());
-  if (argc >= 6) DCHECK(allocatable_regs | a5.bit());
-  if (argc >= 7) DCHECK(allocatable_regs | a6.bit());
-  if (argc >= 8) DCHECK(allocatable_regs | a7.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(a0));
+  if (argc >= 2) DCHECK(allocatable_regs.has(a1));
+  if (argc >= 3) DCHECK(allocatable_regs.has(a2));
+  if (argc >= 4) DCHECK(allocatable_regs.has(a3));
+  if (argc >= 5) DCHECK(allocatable_regs.has(a4));
+  if (argc >= 6) DCHECK(allocatable_regs.has(a5));
+  if (argc >= 7) DCHECK(allocatable_regs.has(a6));
+  if (argc >= 8) DCHECK(allocatable_regs.has(a7));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/loong64/macro-assembler-loong64.cc b/src/codegen/loong64/macro-assembler-loong64.cc
index 43a4372db5..f2d0663945 100644
--- a/src/codegen/loong64/macro-assembler-loong64.cc
+++ b/src/codegen/loong64/macro-assembler-loong64.cc
@@ -51,22 +51,13 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
                                                     Register exclusion2,
                                                     Register exclusion3) const {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
-  bytes += NumRegs(list) * kPointerSize;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -76,24 +67,15 @@ int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
                                     Register exclusion2, Register exclusion3) {
   ASM_CODE_COMMENT(this);
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPush(list);
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPushFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -105,23 +87,13 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
   int bytes = 0;
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPopFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
-  }
-
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPop(list);
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   return bytes;
 }
@@ -193,25 +165,13 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPush(regs);
+  if (registers.is_empty()) return;
+  MultiPush(registers);
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPop(regs);
+  if (registers.is_empty()) return;
+  MultiPop(registers);
 }
 
 void TurboAssembler::CallEphemeronKeyBarrier(Register object, Operand offset,
@@ -4101,19 +4061,13 @@ void TurboAssembler::CheckPageFlag(const Register& object, int mask,
 Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
                                    Register reg4, Register reg5,
                                    Register reg6) {
-  RegList regs = 0;
-  if (reg1.is_valid()) regs |= reg1.bit();
-  if (reg2.is_valid()) regs |= reg2.bit();
-  if (reg3.is_valid()) regs |= reg3.bit();
-  if (reg4.is_valid()) regs |= reg4.bit();
-  if (reg5.is_valid()) regs |= reg5.bit();
-  if (reg6.is_valid()) regs |= reg6.bit();
+  RegList regs = {reg1, reg2, reg3, reg4, reg5, reg6};
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
   for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
     int code = config->GetAllocatableGeneralCode(i);
     Register candidate = Register::from_code(code);
-    if (regs & candidate.bit()) continue;
+    if (regs.has(candidate)) continue;
     return candidate;
   }
   UNREACHABLE();
diff --git a/src/codegen/loong64/register-loong64.h b/src/codegen/loong64/register-loong64.h
index 7a9434040c..8e8fb282e0 100644
--- a/src/codegen/loong64/register-loong64.h
+++ b/src/codegen/loong64/register-loong64.h
@@ -7,8 +7,6 @@
 
 #include "src/codegen/loong64/constants-loong64.h"
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -49,74 +47,6 @@ namespace internal {
 // encoding.
 const int kNumRegs = 32;
 
-const RegList kJSCallerSaved = 1 << 4 |   // a0
-                               1 << 5 |   // a1
-                               1 << 6 |   // a2
-                               1 << 7 |   // a3
-                               1 << 8 |   // a4
-                               1 << 9 |   // a5
-                               1 << 10 |  // a6
-                               1 << 11 |  // a7
-                               1 << 12 |  // t0
-                               1 << 13 |  // t1
-                               1 << 14 |  // t2
-                               1 << 15 |  // t3
-                               1 << 16 |  // t4
-                               1 << 17 |  // t5
-                               1 << 20;   // t8
-
-const int kNumJSCallerSaved = 15;
-
-// Callee-saved registers preserved when switching from C to JavaScript.
-const RegList kCalleeSaved = 1 << 22 |  // fp
-                             1 << 23 |  // s0
-                             1 << 24 |  // s1
-                             1 << 25 |  // s2
-                             1 << 26 |  // s3
-                             1 << 27 |  // s4
-                             1 << 28 |  // s5
-                             1 << 29 |  // s6 (roots in Javascript code)
-                             1 << 30 |  // s7 (cp in Javascript code)
-                             1 << 31;   // s8
-
-const int kNumCalleeSaved = 10;
-
-const RegList kCalleeSavedFPU = 1 << 24 |  // f24
-                                1 << 25 |  // f25
-                                1 << 26 |  // f26
-                                1 << 27 |  // f27
-                                1 << 28 |  // f28
-                                1 << 29 |  // f29
-                                1 << 30 |  // f30
-                                1 << 31;   // f31
-
-const int kNumCalleeSavedFPU = 8;
-
-const RegList kCallerSavedFPU = 1 << 0 |   // f0
-                                1 << 1 |   // f1
-                                1 << 2 |   // f2
-                                1 << 3 |   // f3
-                                1 << 4 |   // f4
-                                1 << 5 |   // f5
-                                1 << 6 |   // f6
-                                1 << 7 |   // f7
-                                1 << 8 |   // f8
-                                1 << 9 |   // f9
-                                1 << 10 |  // f10
-                                1 << 11 |  // f11
-                                1 << 12 |  // f12
-                                1 << 13 |  // f13
-                                1 << 14 |  // f14
-                                1 << 15 |  // f15
-                                1 << 16 |  // f16
-                                1 << 17 |  // f17
-                                1 << 18 |  // f18
-                                1 << 19 |  // f19
-                                1 << 20 |  // f20
-                                1 << 21 |  // f21
-                                1 << 22 |  // f22
-                                1 << 23;   // f23
-
 // CPU Registers.
 //
 // 1) We would prefer to use an enum, but enum values are assignment-
diff --git a/src/codegen/loong64/reglist-loong64.h b/src/codegen/loong64/reglist-loong64.h
new file mode 100644
index 0000000000..c0922e3ec6
--- /dev/null
+++ b/src/codegen/loong64/reglist-loong64.h
@@ -0,0 +1,50 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can b in the
+// LICENSE file.
+
+#ifndef V8_CODEGEN_LOONG64_REGLIST_LOONG64_H_
+#define V8_CODEGEN_LOONG64_REGLIST_LOONG64_H_
+
+#include "src/codegen/loong64/constants-loong64.h"
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+const RegList kJSCallerSaved = {a0, a1, a2, a3, a4, a5, a6, a7,
+                                t0, t1, t2, t3, t4, t5, t8};
+
+const int kNumJSCallerSaved = 15;
+
+// Callee-saved registers preserved when switching from C to JavaScript.
+const RegList kCalleeSaved = {fp,   // fp
+                              s0,   // s0
+                              s1,   // s1
+                              s2,   // s2
+                              s3,   // s3
+                              s4,   // s4
+                              s5,   // s5
+                              s6,   // s6 (roots in Javascript code)
+                              s7,   // s7 (cp in Javascript code)
+                              s8};  // s8
+
+const int kNumCalleeSaved = 10;
+
+const RegList kCalleeSavedFPU = {f24, f25, f26, f27, f28, f29, f30, f31};
+
+const int kNumCalleeSavedFPU = 8;
+
+const RegList kCallerSavedFPU = {f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,
+                                 f8,  f9,  f10, f11, f12, f13, f14, f15,
+                                 f16, f17, f18, f19, f20, f21, f22, f23};
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_LOONG64_REGLIST_LOONG64_H_
diff --git a/src/codegen/mips/assembler-mips.cc b/src/codegen/mips/assembler-mips.cc
index 53511c0d78..66d5c091f6 100644
--- a/src/codegen/mips/assembler-mips.cc
+++ b/src/codegen/mips/assembler-mips.cc
@@ -290,8 +290,7 @@ const Instr kLwSwOffsetMask = kImm16Mask;
 
 Assembler::Assembler(const AssemblerOptions& options,
                      std::unique_ptr<AssemblerBuffer> buffer)
-    : AssemblerBase(options, std::move(buffer)),
-      scratch_register_list_(at.bit()) {
+    : AssemblerBase(options, std::move(buffer)), scratch_register_list_({at}) {
   reloc_info_writer.Reposition(buffer_start_ + buffer_->size(), pc_);
 
   last_trampoline_pool_end_ = 0;
diff --git a/src/codegen/mips/assembler-mips.h b/src/codegen/mips/assembler-mips.h
index 0acee5e39d..3cfebc390d 100644
--- a/src/codegen/mips/assembler-mips.h
+++ b/src/codegen/mips/assembler-mips.h
@@ -1905,11 +1905,11 @@ class V8_EXPORT_PRIVATE V8_NODISCARD UseScratchRegisterScope {
   void Include(const RegList& list) { *available_ |= list; }
   void Exclude(const RegList& list) { *available_ &= ~list; }
   void Include(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Include(list);
   }
   void Exclude(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Exclude(list);
   }
 
diff --git a/src/codegen/mips/interface-descriptors-mips-inl.h b/src/codegen/mips/interface-descriptors-mips-inl.h
index 1e1c3a33a8..ef2e481e7f 100644
--- a/src/codegen/mips/interface-descriptors-mips-inl.h
+++ b/src/codegen/mips/interface-descriptors-mips-inl.h
@@ -24,10 +24,10 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | a0.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | a1.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | a2.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | a3.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(a0));
+  if (argc >= 2) DCHECK(allocatable_regs.has(a1));
+  if (argc >= 3) DCHECK(allocatable_regs.has(a2));
+  if (argc >= 4) DCHECK(allocatable_regs.has(a3));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/mips/macro-assembler-mips.cc b/src/codegen/mips/macro-assembler-mips.cc
index fc4651ad7d..136345be89 100644
--- a/src/codegen/mips/macro-assembler-mips.cc
+++ b/src/codegen/mips/macro-assembler-mips.cc
@@ -51,22 +51,13 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
                                                     Register exclusion2,
                                                     Register exclusion3) const {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
-  bytes += NumRegs(list) * kPointerSize;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -76,24 +67,15 @@ int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
                                     Register exclusion2, Register exclusion3) {
   ASM_CODE_COMMENT(this);
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPush(list);
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPushFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -105,23 +87,13 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
   int bytes = 0;
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPopFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
-  }
-
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPop(list);
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   return bytes;
 }
@@ -215,25 +187,13 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPush(regs);
+  if (registers.is_empty()) return;
+  MultiPush(registers);
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPop(regs);
+  if (registers.is_empty()) return;
+  MultiPop(registers);
 }
 
 void TurboAssembler::CallEphemeronKeyBarrier(Register object,
@@ -5576,19 +5536,13 @@ void TurboAssembler::CheckPageFlag(Register object, Register scratch, int mask,
 Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
                                    Register reg4, Register reg5,
                                    Register reg6) {
-  RegList regs = 0;
-  if (reg1.is_valid()) regs |= reg1.bit();
-  if (reg2.is_valid()) regs |= reg2.bit();
-  if (reg3.is_valid()) regs |= reg3.bit();
-  if (reg4.is_valid()) regs |= reg4.bit();
-  if (reg5.is_valid()) regs |= reg5.bit();
-  if (reg6.is_valid()) regs |= reg6.bit();
+  RegList regs = {reg1, reg2, reg3, reg4, reg5, reg6};
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
   for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
     int code = config->GetAllocatableGeneralCode(i);
     Register candidate = Register::from_code(code);
-    if (regs & candidate.bit()) continue;
+    if (regs.has(candidate)) continue;
     return candidate;
   }
   UNREACHABLE();
diff --git a/src/codegen/mips/register-mips.h b/src/codegen/mips/register-mips.h
index c194a0bd72..190048190d 100644
--- a/src/codegen/mips/register-mips.h
+++ b/src/codegen/mips/register-mips.h
@@ -7,8 +7,6 @@
 
 #include "src/codegen/mips/constants-mips.h"
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -48,66 +46,10 @@ namespace internal {
 // encoding.
 const int kNumRegs = 32;
 
-const RegList kJSCallerSaved = 1 << 2 |   // v0
-                               1 << 3 |   // v1
-                               1 << 4 |   // a0
-                               1 << 5 |   // a1
-                               1 << 6 |   // a2
-                               1 << 7 |   // a3
-                               1 << 8 |   // t0
-                               1 << 9 |   // t1
-                               1 << 10 |  // t2
-                               1 << 11 |  // t3
-                               1 << 12 |  // t4
-                               1 << 13 |  // t5
-                               1 << 14 |  // t6
-                               1 << 15;   // t7
-
-const int kNumJSCallerSaved = 14;
-
-// Callee-saved registers preserved when switching from C to JavaScript.
-const RegList kCalleeSaved = 1 << 16 |  // s0
-                             1 << 17 |  // s1
-                             1 << 18 |  // s2
-                             1 << 19 |  // s3
-                             1 << 20 |  // s4
-                             1 << 21 |  // s5
-                             1 << 22 |  // s6 (roots in Javascript code)
-                             1 << 23 |  // s7 (cp in Javascript code)
-                             1 << 30;   // fp/s8
-
-const int kNumCalleeSaved = 9;
-
-const RegList kCalleeSavedFPU = 1 << 20 |  // f20
-                                1 << 22 |  // f22
-                                1 << 24 |  // f24
-                                1 << 26 |  // f26
-                                1 << 28 |  // f28
-                                1 << 30;   // f30
-
-const int kNumCalleeSavedFPU = 6;
-
-const RegList kCallerSavedFPU = 1 << 0 |   // f0
-                                1 << 2 |   // f2
-                                1 << 4 |   // f4
-                                1 << 6 |   // f6
-                                1 << 8 |   // f8
-                                1 << 10 |  // f10
-                                1 << 12 |  // f12
-                                1 << 14 |  // f14
-                                1 << 16 |  // f16
-                                1 << 18;   // f18
-
 // Number of registers for which space is reserved in safepoints. Must be a
 // multiple of 8.
 const int kNumSafepointRegisters = 24;
 
-// Define the list of registers actually saved at safepoints.
-// Note that the number of saved registers may be smaller than the reserved
-// space, i.e. kNumSafepointSavedRegisters <= kNumSafepointRegisters.
-const RegList kSafepointSavedRegisters = kJSCallerSaved | kCalleeSaved;
-const int kNumSafepointSavedRegisters = kNumJSCallerSaved + kNumCalleeSaved;
-
 const int kUndefIndex = -1;
 // Map with indexes on stack that corresponds to codes of saved registers.
 const int kSafepointRegisterStackIndexMap[kNumRegs] = {kUndefIndex,  // zero_reg
diff --git a/src/codegen/mips/reglist-mips.h b/src/codegen/mips/reglist-mips.h
new file mode 100644
index 0000000000..0de14fcb41
--- /dev/null
+++ b/src/codegen/mips/reglist-mips.h
@@ -0,0 +1,57 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_MIPS_REGLIST_MIPS_H_
+#define V8_CODEGEN_MIPS_REGLIST_MIPS_H_
+
+#include "src/codegen/mips/constants-mips.h"
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+const RegList kJSCallerSaved = {v0, v1, a0, a1, a2, a3, t0,
+                                t1, t2, t3, t4, t5, t6, t7}
+
+const int kNumJSCallerSaved = 14;
+
+// Callee-saved registers preserved when switching from C to JavaScript.
+const RegList kCalleeSaved = {s0,   // s0
+                              s1,   // s1
+                              s2,   // s2
+                              s3,   // s3
+                              s4,   // s4
+                              s5,   // s5
+                              s6,   // s6 (roots in Javascript code)
+                              s7,   // s7 (cp in Javascript code)
+                              fp};  // fp/s8
+
+const int kNumCalleeSaved = 9;
+
+const RegList kCalleeSavedFPU = {f20, f22, f24, f26, f28, f30};
+
+const int kNumCalleeSavedFPU = 6;
+
+const RegList kCallerSavedFPU = {f0, f2, f4, f6, f8, f10, f12, f14, f16, f18};
+
+// Number of registers for which space is reserved in safepoints. Must be a
+// multiple of 8.
+const int kNumSafepointRegisters = 24;
+
+// Define the list of registers actually saved at safepoints.
+// Note that the number of saved registers may be smaller than the reserved
+// space, i.e. kNumSafepointSavedRegisters <= kNumSafepointRegisters.
+const RegList kSafepointSavedRegisters = kJSCallerSaved | kCalleeSaved;
+const int kNumSafepointSavedRegisters = kNumJSCallerSaved + kNumCalleeSaved;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_MIPS_REGLIST_MIPS_H_
diff --git a/src/codegen/mips64/assembler-mips64.cc b/src/codegen/mips64/assembler-mips64.cc
index 3701c652a9..c0026d1529 100644
--- a/src/codegen/mips64/assembler-mips64.cc
+++ b/src/codegen/mips64/assembler-mips64.cc
@@ -265,7 +265,7 @@ const Instr kLwSwOffsetMask = kImm16Mask;
 Assembler::Assembler(const AssemblerOptions& options,
                      std::unique_ptr<AssemblerBuffer> buffer)
     : AssemblerBase(options, std::move(buffer)),
-      scratch_register_list_(at.bit() | s0.bit()) {
+      scratch_register_list_({at, s0}) {
   if (CpuFeatures::IsSupported(MIPS_SIMD)) {
     EnableCpuFeature(MIPS_SIMD);
   }
diff --git a/src/codegen/mips64/assembler-mips64.h b/src/codegen/mips64/assembler-mips64.h
index f17d47e990..2d871105a0 100644
--- a/src/codegen/mips64/assembler-mips64.h
+++ b/src/codegen/mips64/assembler-mips64.h
@@ -1935,11 +1935,11 @@ class V8_EXPORT_PRIVATE V8_NODISCARD UseScratchRegisterScope {
   void Include(const RegList& list) { *available_ |= list; }
   void Exclude(const RegList& list) { *available_ &= ~list; }
   void Include(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Include(list);
   }
   void Exclude(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Exclude(list);
   }
 
diff --git a/src/codegen/mips64/interface-descriptors-mips64-inl.h b/src/codegen/mips64/interface-descriptors-mips64-inl.h
index 1c484c21b2..d75998dd79 100644
--- a/src/codegen/mips64/interface-descriptors-mips64-inl.h
+++ b/src/codegen/mips64/interface-descriptors-mips64-inl.h
@@ -24,14 +24,14 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | a0.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | a1.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | a2.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | a3.bit());
-  if (argc >= 5) DCHECK(allocatable_regs | a4.bit());
-  if (argc >= 6) DCHECK(allocatable_regs | a5.bit());
-  if (argc >= 7) DCHECK(allocatable_regs | a6.bit());
-  if (argc >= 8) DCHECK(allocatable_regs | a7.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(a0));
+  if (argc >= 2) DCHECK(allocatable_regs.has(a1));
+  if (argc >= 3) DCHECK(allocatable_regs.has(a2));
+  if (argc >= 4) DCHECK(allocatable_regs.has(a3));
+  if (argc >= 5) DCHECK(allocatable_regs.has(a4));
+  if (argc >= 6) DCHECK(allocatable_regs.has(a5));
+  if (argc >= 7) DCHECK(allocatable_regs.has(a6));
+  if (argc >= 8) DCHECK(allocatable_regs.has(a7));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/mips64/macro-assembler-mips64.cc b/src/codegen/mips64/macro-assembler-mips64.cc
index 763112bf91..61d1dd059a 100644
--- a/src/codegen/mips64/macro-assembler-mips64.cc
+++ b/src/codegen/mips64/macro-assembler-mips64.cc
@@ -51,22 +51,12 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
                                                     Register exclusion2,
                                                     Register exclusion3) const {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = kJSCallerSaved & ~exclusions;
-  bytes += NumRegs(list) * kPointerSize;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -76,24 +66,14 @@ int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
                                     Register exclusion2, Register exclusion3) {
   ASM_CODE_COMMENT(this);
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPush(list);
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPushFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -105,23 +85,13 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
   int bytes = 0;
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPopFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPop(list);
-  bytes += NumRegs(list) * kPointerSize;
+  bytes += list.Count() * kPointerSize;
 
   return bytes;
 }
@@ -213,25 +183,13 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPush(regs);
+  if (registers.is_empty()) return;
+  MultiPush(registers);
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPop(regs);
+  if (registers.is_empty()) return;
+  MultiPop(registers);
 }
 
 void TurboAssembler::CallEphemeronKeyBarrier(Register object,
@@ -6121,19 +6079,13 @@ void TurboAssembler::CheckPageFlag(Register object, Register scratch, int mask,
 Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
                                    Register reg4, Register reg5,
                                    Register reg6) {
-  RegList regs = 0;
-  if (reg1.is_valid()) regs |= reg1.bit();
-  if (reg2.is_valid()) regs |= reg2.bit();
-  if (reg3.is_valid()) regs |= reg3.bit();
-  if (reg4.is_valid()) regs |= reg4.bit();
-  if (reg5.is_valid()) regs |= reg5.bit();
-  if (reg6.is_valid()) regs |= reg6.bit();
+  RegList regs = {reg1, reg2, reg3, reg4, reg5, reg6};
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
   for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
     int code = config->GetAllocatableGeneralCode(i);
     Register candidate = Register::from_code(code);
-    if (regs & candidate.bit()) continue;
+    if (regs.has(candidate)) continue;
     return candidate;
   }
   UNREACHABLE();
diff --git a/src/codegen/mips64/register-mips64.h b/src/codegen/mips64/register-mips64.h
index 23e1f4911c..6ada58dd67 100644
--- a/src/codegen/mips64/register-mips64.h
+++ b/src/codegen/mips64/register-mips64.h
@@ -7,8 +7,6 @@
 
 #include "src/codegen/mips64/constants-mips64.h"
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -47,56 +45,6 @@ namespace internal {
 // encoding.
 const int kNumRegs = 32;
 
-const RegList kJSCallerSaved = 1 << 2 |   // v0
-                               1 << 3 |   // v1
-                               1 << 4 |   // a0
-                               1 << 5 |   // a1
-                               1 << 6 |   // a2
-                               1 << 7 |   // a3
-                               1 << 8 |   // a4
-                               1 << 9 |   // a5
-                               1 << 10 |  // a6
-                               1 << 11 |  // a7
-                               1 << 12 |  // t0
-                               1 << 13 |  // t1
-                               1 << 14 |  // t2
-                               1 << 15;   // t3
-
-const int kNumJSCallerSaved = 14;
-
-// Callee-saved registers preserved when switching from C to JavaScript.
-const RegList kCalleeSaved = 1 << 16 |  // s0
-                             1 << 17 |  // s1
-                             1 << 18 |  // s2
-                             1 << 19 |  // s3
-                             1 << 20 |  // s4
-                             1 << 21 |  // s5
-                             1 << 22 |  // s6 (roots in Javascript code)
-                             1 << 23 |  // s7 (cp in Javascript code)
-                             1 << 30;   // fp/s8
-
-const int kNumCalleeSaved = 9;
-
-const RegList kCalleeSavedFPU = 1 << 20 |  // f20
-                                1 << 22 |  // f22
-                                1 << 24 |  // f24
-                                1 << 26 |  // f26
-                                1 << 28 |  // f28
-                                1 << 30;   // f30
-
-const int kNumCalleeSavedFPU = 6;
-
-const RegList kCallerSavedFPU = 1 << 0 |   // f0
-                                1 << 2 |   // f2
-                                1 << 4 |   // f4
-                                1 << 6 |   // f6
-                                1 << 8 |   // f8
-                                1 << 10 |  // f10
-                                1 << 12 |  // f12
-                                1 << 14 |  // f14
-                                1 << 16 |  // f16
-                                1 << 18;   // f18
-
 // Number of registers for which space is reserved in safepoints. Must be a
 // multiple of 8.
 const int kNumSafepointRegisters = 24;
diff --git a/src/codegen/mips64/reglist-mips64.h b/src/codegen/mips64/reglist-mips64.h
new file mode 100644
index 0000000000..3feeddead0
--- /dev/null
+++ b/src/codegen/mips64/reglist-mips64.h
@@ -0,0 +1,57 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_MIPS64_REGLIST_MIPS64_H_
+#define V8_CODEGEN_MIPS64_REGLIST_MIPS64_H_
+
+#include "src/codegen/mips64/constants-mips64.h"
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+const RegList kJSCallerSaved = {v0, v1, a0, a1, a2, a3, a4,
+                                a5, a6, a7, t0, t1, t2, t3};
+
+const int kNumJSCallerSaved = 14;
+
+// Callee-saved registers preserved when switching from C to JavaScript.
+const RegList kCalleeSaved = {s0,   // s0
+                              s1,   // s1
+                              s2,   // s2
+                              s3,   // s3
+                              s4,   // s4
+                              s5,   // s5
+                              s6,   // s6 (roots in Javascript code)
+                              s7,   // s7 (cp in Javascript code)
+                              fp};  // fp/s8
+
+const int kNumCalleeSaved = 9;
+
+const RegList kCalleeSavedFPU = {f20, f22, f24, f26, f28, f30};
+
+const int kNumCalleeSavedFPU = 6;
+
+const RegList kCallerSavedFPU = {f0, f2, f4, f6, f8, f10, f12, f14, f16, f18};
+
+// Number of registers for which space is reserved in safepoints. Must be a
+// multiple of 8.
+const int kNumSafepointRegisters = 24;
+
+// Define the list of registers actually saved at safepoints.
+// Note that the number of saved registers may be smaller than the reserved
+// space, i.e. kNumSafepointSavedRegisters <= kNumSafepointRegisters.
+const RegList kSafepointSavedRegisters = kJSCallerSaved | kCalleeSaved;
+const int kNumSafepointSavedRegisters = kNumJSCallerSaved + kNumCalleeSaved;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_MIPS64_REGLIST_MIPS64_H_
diff --git a/src/codegen/ppc/assembler-ppc.cc b/src/codegen/ppc/assembler-ppc.cc
index 1073679d79..3ef560289e 100644
--- a/src/codegen/ppc/assembler-ppc.cc
+++ b/src/codegen/ppc/assembler-ppc.cc
@@ -226,7 +226,7 @@ void Assembler::AllocateAndInstallRequestedHeapObjects(Isolate* isolate) {
 Assembler::Assembler(const AssemblerOptions& options,
                      std::unique_ptr<AssemblerBuffer> buffer)
     : AssemblerBase(options, std::move(buffer)),
-      scratch_register_list_(ip.bit()),
+      scratch_register_list_({ip}),
       constant_pool_builder_(kLoadPtrMaxReachBits, kLoadDoubleMaxReachBits) {
   reloc_info_writer.Reposition(buffer_start_ + buffer_->size(), pc_);
 
@@ -2109,11 +2109,7 @@ UseScratchRegisterScope::~UseScratchRegisterScope() {
 Register UseScratchRegisterScope::Acquire() {
   RegList* available = assembler_->GetScratchRegisterList();
   DCHECK_NOT_NULL(available);
-  DCHECK_NE(*available, 0);
-  int index = static_cast<int>(base::bits::CountTrailingZeros32(*available));
-  Register reg = Register::from_code(index);
-  *available &= ~reg.bit();
-  return reg;
+  return available->PopFront();
 }
 
 }  // namespace internal
diff --git a/src/codegen/ppc/interface-descriptors-ppc-inl.h b/src/codegen/ppc/interface-descriptors-ppc-inl.h
index b6c309f9a5..7afea5a4f2 100644
--- a/src/codegen/ppc/interface-descriptors-ppc-inl.h
+++ b/src/codegen/ppc/interface-descriptors-ppc-inl.h
@@ -24,14 +24,14 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | r3.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | r4.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | r5.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | r6.bit());
-  if (argc >= 5) DCHECK(allocatable_regs | r7.bit());
-  if (argc >= 6) DCHECK(allocatable_regs | r8.bit());
-  if (argc >= 7) DCHECK(allocatable_regs | r9.bit());
-  if (argc >= 8) DCHECK(allocatable_regs | r10.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(r3));
+  if (argc >= 2) DCHECK(allocatable_regs.has(r4));
+  if (argc >= 3) DCHECK(allocatable_regs.has(r5));
+  if (argc >= 4) DCHECK(allocatable_regs.has(r6));
+  if (argc >= 5) DCHECK(allocatable_regs.has(r7));
+  if (argc >= 6) DCHECK(allocatable_regs.has(r8));
+  if (argc >= 7) DCHECK(allocatable_regs.has(r9));
+  if (argc >= 8) DCHECK(allocatable_regs.has(r10));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/ppc/macro-assembler-ppc.cc b/src/codegen/ppc/macro-assembler-ppc.cc
index c7272cb8a5..cee9061b39 100644
--- a/src/codegen/ppc/macro-assembler-ppc.cc
+++ b/src/codegen/ppc/macro-assembler-ppc.cc
@@ -58,19 +58,10 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
                                                     Register exclusion2,
                                                     Register exclusion3) const {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
-  bytes += NumRegs(list) * kSystemPointerSize;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
+  bytes += list.Count() * kSystemPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     bytes += kStackSavedSavedFPSizeInBytes;
@@ -82,20 +73,11 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
 int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
                                     Register exclusion2, Register exclusion3) {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPush(list);
-  bytes += NumRegs(list) * kSystemPointerSize;
+  bytes += list.Count() * kSystemPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPushF64AndV128(kCallerSavedDoubles, kCallerSavedDoubles);
@@ -113,20 +95,10 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
     bytes += kStackSavedSavedFPSizeInBytes;
   }
 
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPop(list);
-  bytes += NumRegs(list) * kSystemPointerSize;
+  bytes += list.Count() * kSystemPointerSize;
 
   return bytes;
 }
@@ -507,14 +479,14 @@ void TurboAssembler::MultiPushF64AndV128(RegList dregs, RegList simd_regs,
     // We still need to allocate empty space on the stack even if we
     // are not pushing Simd registers (see kFixedFrameSizeFromFp).
     addi(sp, sp,
-         Operand(-static_cast<int8_t>(NumRegs(simd_regs)) * kSimd128Size));
+         Operand(-static_cast<int8_t>(simd_regs.Count()) * kSimd128Size));
     bind(&simd_pushed);
   } else {
     if (CpuFeatures::SupportsWasmSimd128()) {
       MultiPushV128(simd_regs);
     } else {
       addi(sp, sp,
-           Operand(-static_cast<int8_t>(NumRegs(simd_regs)) * kSimd128Size));
+           Operand(-static_cast<int8_t>(simd_regs.Count()) * kSimd128Size));
     }
   }
 #endif
@@ -535,14 +507,14 @@ void TurboAssembler::MultiPopF64AndV128(RegList dregs, RegList simd_regs,
     b(&simd_popped);
     bind(&pop_empty_simd);
     addi(sp, sp,
-         Operand(static_cast<int8_t>(NumRegs(simd_regs)) * kSimd128Size));
+         Operand(static_cast<int8_t>(simd_regs.Count()) * kSimd128Size));
     bind(&simd_popped);
   } else {
     if (CpuFeatures::SupportsWasmSimd128()) {
       MultiPopV128(simd_regs);
     } else {
       addi(sp, sp,
-           Operand(static_cast<int8_t>(NumRegs(simd_regs)) * kSimd128Size));
+           Operand(static_cast<int8_t>(simd_regs.Count()) * kSimd128Size));
     }
   }
 #endif
@@ -687,25 +659,13 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPush(regs);
+  if (registers.is_empty()) return;
+  MultiPush(registers);
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPop(regs);
+  if (registers.is_empty()) return;
+  MultiPop(registers);
 }
 
 void TurboAssembler::CallEphemeronKeyBarrier(Register object,
@@ -3405,19 +3365,13 @@ void TurboAssembler::StoreF32LE(DoubleRegister dst, const MemOperand& mem,
 Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
                                    Register reg4, Register reg5,
                                    Register reg6) {
-  RegList regs = 0;
-  if (reg1.is_valid()) regs |= reg1.bit();
-  if (reg2.is_valid()) regs |= reg2.bit();
-  if (reg3.is_valid()) regs |= reg3.bit();
-  if (reg4.is_valid()) regs |= reg4.bit();
-  if (reg5.is_valid()) regs |= reg5.bit();
-  if (reg6.is_valid()) regs |= reg6.bit();
+  RegList regs = {reg1, reg2, reg3, reg4, reg5, reg6};
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
   for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
     int code = config->GetAllocatableGeneralCode(i);
     Register candidate = Register::from_code(code);
-    if (regs & candidate.bit()) continue;
+    if (regs.has(candidate)) continue;
     return candidate;
   }
   UNREACHABLE();
diff --git a/src/codegen/ppc/register-ppc.h b/src/codegen/ppc/register-ppc.h
index fa1a265c9e..00eccc744e 100644
--- a/src/codegen/ppc/register-ppc.h
+++ b/src/codegen/ppc/register-ppc.h
@@ -6,8 +6,6 @@
 #define V8_CODEGEN_PPC_REGISTER_PPC_H_
 
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -62,84 +60,6 @@ namespace internal {
   V(cr8)  V(cr9)  V(cr10) V(cr11) V(cr12) V(cr15)
 // clang-format on
 
-// Register list in load/store instructions
-// Note that the bit values must match those used in actual instruction encoding
-
-// Caller-saved/arguments registers
-const RegList kJSCallerSaved = 1 << 3 |   // r3  a1
-                               1 << 4 |   // r4  a2
-                               1 << 5 |   // r5  a3
-                               1 << 6 |   // r6  a4
-                               1 << 7 |   // r7  a5
-                               1 << 8 |   // r8  a6
-                               1 << 9 |   // r9  a7
-                               1 << 10 |  // r10 a8
-                               1 << 11;
-
-const int kNumJSCallerSaved = 9;
-
-// Return the code of the n-th caller-saved register available to JavaScript
-// e.g. JSCallerSavedReg(0) returns r0.code() == 0
-int JSCallerSavedCode(int n);
-
-// Callee-saved registers preserved when switching from C to JavaScript
-const RegList kCalleeSaved = 1 << 14 |  // r14
-                             1 << 15 |  // r15
-                             1 << 16 |  // r16
-                             1 << 17 |  // r17
-                             1 << 18 |  // r18
-                             1 << 19 |  // r19
-                             1 << 20 |  // r20
-                             1 << 21 |  // r21
-                             1 << 22 |  // r22
-                             1 << 23 |  // r23
-                             1 << 24 |  // r24
-                             1 << 25 |  // r25
-                             1 << 26 |  // r26
-                             1 << 27 |  // r27
-                             1 << 28 |  // r28
-                             1 << 29 |  // r29
-                             1 << 30 |  // r20
-                             1 << 31;   // r31
-
-const int kNumCalleeSaved = 18;
-
-const RegList kCallerSavedDoubles = 1 << 0 |   // d0
-                                    1 << 1 |   // d1
-                                    1 << 2 |   // d2
-                                    1 << 3 |   // d3
-                                    1 << 4 |   // d4
-                                    1 << 5 |   // d5
-                                    1 << 6 |   // d6
-                                    1 << 7 |   // d7
-                                    1 << 8 |   // d8
-                                    1 << 9 |   // d9
-                                    1 << 10 |  // d10
-                                    1 << 11 |  // d11
-                                    1 << 12 |  // d12
-                                    1 << 13;   // d13
-
-const int kNumCallerSavedDoubles = 14;
-
-const RegList kCalleeSavedDoubles = 1 << 14 |  // d14
-                                    1 << 15 |  // d15
-                                    1 << 16 |  // d16
-                                    1 << 17 |  // d17
-                                    1 << 18 |  // d18
-                                    1 << 19 |  // d19
-                                    1 << 20 |  // d20
-                                    1 << 21 |  // d21
-                                    1 << 22 |  // d22
-                                    1 << 23 |  // d23
-                                    1 << 24 |  // d24
-                                    1 << 25 |  // d25
-                                    1 << 26 |  // d26
-                                    1 << 27 |  // d27
-                                    1 << 28 |  // d28
-                                    1 << 29 |  // d29
-                                    1 << 30 |  // d30
-                                    1 << 31;   // d31
-
 const int kNumCalleeSavedDoubles = 18;
 
 // The following constants describe the stack frame linkage area as
diff --git a/src/codegen/ppc/reglist-ppc.h b/src/codegen/ppc/reglist-ppc.h
new file mode 100644
index 0000000000..51af1ce608
--- /dev/null
+++ b/src/codegen/ppc/reglist-ppc.h
@@ -0,0 +1,59 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_PPC_REGLIST_PPC_H_
+#define V8_CODEGEN_PPC_REGLIST_PPC_H_
+
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+// Register list in load/store instructions
+// Note that the bit values must match those used in actual instruction encoding
+
+// Caller-saved/arguments registers
+const RegList kJSCallerSaved = {r3,   // a1
+                                r4,   // a2
+                                r5,   // a3
+                                r6,   // a4
+                                r7,   // a5
+                                r8,   // a6
+                                r9,   // a7
+                                r10,  // a8
+                                r11};
+
+const int kNumJSCallerSaved = 9;
+
+// Return the code of the n-th caller-saved register available to JavaScript
+// e.g. JSCallerSavedReg(0) returns r0.code() == 0
+int JSCallerSavedCode(int n);
+
+// Callee-saved registers preserved when switching from C to JavaScript
+const RegList kCalleeSaved = {r14, r15, r16, r17, r18, r19, r20, r21, r22,
+                              r23, r24, r25, r26, r27, r28, r29, r30, r31};
+
+const int kNumCalleeSaved = 18;
+
+const RegList kCallerSavedDoubles = {d0, d1, d2, d3,  d4,  d5,  d6,
+                                     d7, d8, d9, d10, d11, d12, d13};
+
+const int kNumCallerSavedDoubles = 14;
+
+const RegList kCalleeSavedDoubles = {d14, d15, d16, d17, d18, d19,
+                                     d20, d21, d22, d23, d24, d25,
+                                     d26, d27, d28, d29, d30, d31};
+
+const int kNumCalleeSavedDoubles = 18;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_PPC_REGLIST_PPC_H_
diff --git a/src/codegen/register-arch.h b/src/codegen/register-arch.h
new file mode 100644
index 0000000000..c9c3a98407
--- /dev/null
+++ b/src/codegen/register-arch.h
@@ -0,0 +1,34 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_REGISTER_ARCH_H_
+#define V8_CODEGEN_REGISTER_ARCH_H_
+
+#include "src/codegen/register-base.h"
+
+#if V8_TARGET_ARCH_IA32
+#include "src/codegen/ia32/register-ia32.h"
+#elif V8_TARGET_ARCH_X64
+#include "src/codegen/x64/register-x64.h"
+#elif V8_TARGET_ARCH_ARM64
+#include "src/codegen/arm64/register-arm64.h"
+#elif V8_TARGET_ARCH_ARM
+#include "src/codegen/arm/register-arm.h"
+#elif V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
+#include "src/codegen/ppc/register-ppc.h"
+#elif V8_TARGET_ARCH_MIPS
+#include "src/codegen/mips/register-mips.h"
+#elif V8_TARGET_ARCH_MIPS64
+#include "src/codegen/mips64/register-mips64.h"
+#elif V8_TARGET_ARCH_LOONG64
+#include "src/codegen/loong64/register-loong64.h"
+#elif V8_TARGET_ARCH_S390
+#include "src/codegen/s390/register-s390.h"
+#elif V8_TARGET_ARCH_RISCV64
+#include "src/codegen/riscv64/register-riscv64.h"
+#else
+#error Unknown architecture.
+#endif
+
+#endif  // V8_CODEGEN_REGISTER_ARCH_H_
diff --git a/src/codegen/register-base.h b/src/codegen/register-base.h
index 92812b14c6..b6cbc963e3 100644
--- a/src/codegen/register-base.h
+++ b/src/codegen/register-base.h
@@ -7,7 +7,6 @@
 
 #include "src/base/bits.h"
 #include "src/base/bounds.h"
-#include "src/codegen/reglist.h"
 #include "src/common/globals.h"
 
 namespace v8 {
@@ -39,11 +38,6 @@ class RegisterBase {
     return SubType{code};
   }
 
-  template <typename... Register>
-  static constexpr RegList ListOf(Register... regs) {
-    return CombineRegLists(regs.bit()...);
-  }
-
   constexpr bool is_valid() const { return reg_code_ != kCode_no_reg; }
 
   constexpr int8_t code() const {
@@ -51,34 +45,6 @@ class RegisterBase {
     return reg_code_;
   }
 
-  constexpr RegList bit() const {
-    return is_valid() ? RegList{1} << code() : RegList{};
-  }
-
-  static constexpr SubType FirstOf(RegList list) {
-    DCHECK_NE(kEmptyRegList, list);
-    return SubType::from_code(base::bits::CountTrailingZerosNonZero(list));
-  }
-
-  static constexpr SubType TakeFirst(RegList* list) {
-    RegList value = *list;
-    SubType result = FirstOf(value);
-    result.RemoveFrom(list);
-    return result;
-  }
-
-  constexpr bool IsIn(RegList list) const { return list & bit(); }
-
-  constexpr void InsertInto(RegList* list) const {
-    DCHECK(!IsIn(*list));
-    *list |= bit();
-  }
-
-  constexpr void RemoveFrom(RegList* list) const {
-    DCHECK(IsIn(*list));
-    *list ^= bit();
-  }
-
   inline constexpr bool operator==(SubType other) const {
     return reg_code_ == other.reg_code_;
   }
diff --git a/src/codegen/register-configuration.cc b/src/codegen/register-configuration.cc
index a78d3bfee3..91f06aec5b 100644
--- a/src/codegen/register-configuration.cc
+++ b/src/codegen/register-configuration.cc
@@ -190,13 +190,13 @@ const RegisterConfiguration* RegisterConfiguration::Default() {
 
 const RegisterConfiguration* RegisterConfiguration::RestrictGeneralRegisters(
     RegList registers) {
-  int num = NumRegs(registers);
+  int num = registers.Count();
   std::unique_ptr<int[]> codes{new int[num]};
   std::unique_ptr<char const* []> names { new char const*[num] };
   int counter = 0;
   for (int i = 0; i < Default()->num_allocatable_general_registers(); ++i) {
     auto reg = Register::from_code(Default()->GetAllocatableGeneralCode(i));
-    if (reg.bit() & registers) {
+    if (registers.has(reg)) {
       DCHECK(counter < num);
       codes[counter] = reg.code();
       names[counter] = RegisterName(Register::from_code(i));
diff --git a/src/codegen/register-configuration.h b/src/codegen/register-configuration.h
index 4f39ac9b26..537079cdd6 100644
--- a/src/codegen/register-configuration.h
+++ b/src/codegen/register-configuration.h
@@ -14,17 +14,6 @@
 namespace v8 {
 namespace internal {
 
-// An architecture independent representation of the sets of registers available
-// for instruction creation.
-enum class AliasingKind {
-  // Registers alias a single register of every other size (e.g. Intel).
-  kOverlap,
-  // Registers alias two registers of the next smaller size (e.g. ARM).
-  kCombine,
-  // SIMD128 Registers are independent of every other size (e.g Riscv)
-  kIndependent
-};
-
 class V8_EXPORT_PRIVATE RegisterConfiguration {
  public:
   // Architecture independent maxes.
diff --git a/src/codegen/register.h b/src/codegen/register.h
index ff25d1f206..28dc5981fe 100644
--- a/src/codegen/register.h
+++ b/src/codegen/register.h
@@ -5,41 +5,12 @@
 #ifndef V8_CODEGEN_REGISTER_H_
 #define V8_CODEGEN_REGISTER_H_
 
-#include "src/codegen/register-base.h"
+#include "src/codegen/register-arch.h"
 #include "src/codegen/reglist.h"
 
-#if V8_TARGET_ARCH_IA32
-#include "src/codegen/ia32/register-ia32.h"
-#elif V8_TARGET_ARCH_X64
-#include "src/codegen/x64/register-x64.h"
-#elif V8_TARGET_ARCH_ARM64
-#include "src/codegen/arm64/register-arm64.h"
-#elif V8_TARGET_ARCH_ARM
-#include "src/codegen/arm/register-arm.h"
-#elif V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
-#include "src/codegen/ppc/register-ppc.h"
-#elif V8_TARGET_ARCH_MIPS
-#include "src/codegen/mips/register-mips.h"
-#elif V8_TARGET_ARCH_MIPS64
-#include "src/codegen/mips64/register-mips64.h"
-#elif V8_TARGET_ARCH_LOONG64
-#include "src/codegen/loong64/register-loong64.h"
-#elif V8_TARGET_ARCH_S390
-#include "src/codegen/s390/register-s390.h"
-#elif V8_TARGET_ARCH_RISCV64
-#include "src/codegen/riscv64/register-riscv64.h"
-#else
-#error Unknown architecture.
-#endif
-
 namespace v8 {
 namespace internal {
 
-#define LIST_REG(V) V,
-static constexpr RegList kAllocatableGeneralRegisters = Register::ListOf(
-    ALLOCATABLE_GENERAL_REGISTERS(LIST_REG) Register::no_reg());
-#undef LIST_REG
-
 constexpr int AddArgumentPaddingSlots(int argument_count) {
   return argument_count + ArgumentPaddingSlots(argument_count);
 }
@@ -62,36 +33,13 @@ template <typename RegType, typename... RegTypes,
               base::is_same<Register, RegType, RegTypes...>::value ||
               base::is_same<DoubleRegister, RegType, RegTypes...>::value>::type>
 inline constexpr bool AreAliased(RegType first_reg, RegTypes... regs) {
-  int num_different_regs = NumRegs(RegType::ListOf(first_reg, regs...));
+  int num_different_regs = RegListBase<RegType>{first_reg, regs...}.Count();
   int num_given_regs =
       base::fold(CountIfValidRegisterFunctor{}, 0, first_reg, regs...);
   return num_different_regs < num_given_regs;
 }
 #endif
 
-class RegListIterator {
- public:
-  class Iterator {
-   public:
-    explicit Iterator(RegList list) : list_(list) {}
-    Register operator*() { return Register::FirstOf(list_); }
-    void operator++() { Register::FirstOf(list_).RemoveFrom(&list_); }
-    bool operator!=(const Iterator& other) const {
-      return list_ != other.list_;
-    }
-
-   private:
-    RegList list_;
-  };
-
-  explicit RegListIterator(RegList list) : list_(list) {}
-  Iterator begin() const { return Iterator(list_); }
-  Iterator end() const { return Iterator(kEmptyRegList); }
-
- private:
-  RegList list_;
-};
-
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/codegen/reglist-base.h b/src/codegen/reglist-base.h
new file mode 100644
index 0000000000..6fc67cd304
--- /dev/null
+++ b/src/codegen/reglist-base.h
@@ -0,0 +1,232 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_REGLIST_BASE_H_
+#define V8_CODEGEN_REGLIST_BASE_H_
+
+#include <cstdint>
+#include <initializer_list>
+
+#include "src/base/bits.h"
+#include "src/base/iterator.h"
+#include "src/base/template-utils.h"
+
+namespace v8 {
+namespace internal {
+
+class Register;
+
+template <typename RegisterT>
+class RegListBase {
+  using num_registers_sized_storage_t = typename std::conditional<
+      RegisterT::kNumRegisters <= 16, uint16_t,
+      typename std::conditional<RegisterT::kNumRegisters <= 32, uint32_t,
+                                uint64_t>::type>::type;
+  STATIC_ASSERT(RegisterT::kNumRegisters <= 64);
+
+ public:
+  class Iterator;
+  class ReverseIterator;
+
+#ifdef V8_TARGET_ARCH_ARM64
+  // On ARM64 the sp register has the special value 63 (kSPRegInternalCode)
+  using storage_t = typename std::conditional<
+      std::is_same<RegisterT, v8::internal::Register>::value, uint64_t,
+      num_registers_sized_storage_t>::type;
+#else
+  using storage_t = num_registers_sized_storage_t;
+#endif
+
+  constexpr RegListBase() = default;
+  constexpr RegListBase(std::initializer_list<RegisterT> regs) {
+    for (RegisterT reg : regs) {
+      set(reg);
+    }
+  }
+
+  constexpr void set(RegisterT reg) {
+    if (!reg.is_valid()) return;
+    regs_ |= storage_t{1} << reg.code();
+  }
+
+  constexpr void clear(RegisterT reg) {
+    if (!reg.is_valid()) return;
+    regs_ &= ~(storage_t{1} << reg.code());
+  }
+
+  constexpr bool has(RegisterT reg) const {
+    if (!reg.is_valid()) return false;
+    return (regs_ & (storage_t{1} << reg.code())) != 0;
+  }
+
+  constexpr void clear(RegListBase other) { regs_ &= ~other.regs_; }
+
+  constexpr bool is_empty() const { return regs_ == 0; }
+
+  constexpr unsigned Count() const {
+    return base::bits::CountPopulation(regs_);
+  }
+
+  constexpr RegListBase operator&(const RegListBase other) const {
+    return RegListBase(regs_ & other.regs_);
+  }
+
+  constexpr RegListBase operator|(const RegListBase other) const {
+    return RegListBase(regs_ | other.regs_);
+  }
+
+  constexpr RegListBase operator^(const RegListBase other) const {
+    return RegListBase(regs_ ^ other.regs_);
+  }
+
+  constexpr RegListBase operator-(const RegListBase other) const {
+    return RegListBase(regs_ & ~other.regs_);
+  }
+
+  constexpr RegListBase operator|(const RegisterT reg) const {
+    return *this | RegListBase{reg};
+  }
+
+  constexpr RegListBase operator-(const RegisterT reg) const {
+    return *this - RegListBase{reg};
+  }
+
+  constexpr RegListBase& operator&=(const RegListBase other) {
+    regs_ &= other.regs_;
+    return *this;
+  }
+
+  constexpr RegListBase& operator|=(const RegListBase other) {
+    regs_ |= other.regs_;
+    return *this;
+  }
+
+  constexpr bool operator==(const RegListBase other) const {
+    return regs_ == other.regs_;
+  }
+  constexpr bool operator!=(const RegListBase other) const {
+    return regs_ != other.regs_;
+  }
+
+  constexpr RegisterT first() const {
+    DCHECK(!is_empty());
+    int first_code = base::bits::CountTrailingZerosNonZero(regs_);
+    return RegisterT::from_code(first_code);
+  }
+
+  constexpr RegisterT last() const {
+    DCHECK(!is_empty());
+    int last_code =
+        8 * sizeof(regs_) - 1 - base::bits::CountLeadingZeros(regs_);
+    return RegisterT::from_code(last_code);
+  }
+
+  constexpr RegisterT PopFirst() {
+    RegisterT reg = first();
+    clear(reg);
+    return reg;
+  }
+
+  constexpr storage_t bits() const { return regs_; }
+
+  inline Iterator begin() const;
+  inline Iterator end() const;
+
+  inline ReverseIterator rbegin() const;
+  inline ReverseIterator rend() const;
+
+  static RegListBase FromBits(storage_t bits) { return RegListBase(bits); }
+
+  template <storage_t bits>
+  static constexpr RegListBase FromBits() {
+    return RegListBase{bits};
+  }
+
+ private:
+  // Unchecked constructor. Only use for valid bits.
+  explicit constexpr RegListBase(storage_t bits) : regs_(bits) {}
+
+  storage_t regs_ = 0;
+};
+
+template <typename RegisterT>
+class RegListBase<RegisterT>::Iterator
+    : public base::iterator<std::forward_iterator_tag, RegisterT> {
+ public:
+  RegisterT operator*() { return remaining_.first(); }
+  Iterator& operator++() {
+    remaining_.clear(remaining_.first());
+    return *this;
+  }
+  bool operator==(Iterator other) { return remaining_ == other.remaining_; }
+  bool operator!=(Iterator other) { return remaining_ != other.remaining_; }
+
+ private:
+  explicit Iterator(RegListBase<RegisterT> remaining) : remaining_(remaining) {}
+  friend class RegListBase;
+
+  RegListBase<RegisterT> remaining_;
+};
+
+template <typename RegisterT>
+class RegListBase<RegisterT>::ReverseIterator
+    : public base::iterator<std::forward_iterator_tag, RegisterT> {
+ public:
+  RegisterT operator*() { return remaining_.last(); }
+  ReverseIterator& operator++() {
+    remaining_.clear(remaining_.last());
+    return *this;
+  }
+  bool operator==(ReverseIterator other) {
+    return remaining_ == other.remaining_;
+  }
+  bool operator!=(ReverseIterator other) {
+    return remaining_ != other.remaining_;
+  }
+
+ private:
+  explicit ReverseIterator(RegListBase<RegisterT> remaining)
+      : remaining_(remaining) {}
+  friend class RegListBase;
+
+  RegListBase<RegisterT> remaining_;
+};
+
+template <typename RegisterT>
+typename RegListBase<RegisterT>::Iterator RegListBase<RegisterT>::begin()
+    const {
+  return Iterator{*this};
+}
+template <typename RegisterT>
+typename RegListBase<RegisterT>::Iterator RegListBase<RegisterT>::end() const {
+  return Iterator{RegListBase<RegisterT>{}};
+}
+
+template <typename RegisterT>
+typename RegListBase<RegisterT>::ReverseIterator
+RegListBase<RegisterT>::rbegin() const {
+  return ReverseIterator{*this};
+}
+template <typename RegisterT>
+typename RegListBase<RegisterT>::ReverseIterator RegListBase<RegisterT>::rend()
+    const {
+  return ReverseIterator{RegListBase<RegisterT>{}};
+}
+
+template <typename RegisterT>
+inline std::ostream& operator<<(std::ostream& os,
+                                RegListBase<RegisterT> reglist) {
+  os << "{";
+  for (bool first = true; !reglist.is_empty(); first = false) {
+    RegisterT reg = reglist.first();
+    reglist.clear(reg);
+    os << (first ? "" : ", ") << reg;
+  }
+  return os << "}";
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_REGLIST_BASE_H_
diff --git a/src/codegen/reglist.h b/src/codegen/reglist.h
index 99f6458dcf..eb9ff45163 100644
--- a/src/codegen/reglist.h
+++ b/src/codegen/reglist.h
@@ -5,41 +5,39 @@
 #ifndef V8_CODEGEN_REGLIST_H_
 #define V8_CODEGEN_REGLIST_H_
 
-#include <cstdint>
-
-#include "src/base/bits.h"
-#include "src/base/template-utils.h"
-
-namespace v8 {
-namespace internal {
-
-// Register configurations.
-#if V8_TARGET_ARCH_ARM64
-using RegList = uint64_t;
+#if V8_TARGET_ARCH_IA32
+#include "src/codegen/ia32/reglist-ia32.h"
+#elif V8_TARGET_ARCH_X64
+#include "src/codegen/x64/reglist-x64.h"
+#elif V8_TARGET_ARCH_ARM64
+#include "src/codegen/arm64/reglist-arm64.h"
+#elif V8_TARGET_ARCH_ARM
+#include "src/codegen/arm/reglist-arm.h"
+#elif V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
+#include "src/codegen/ppc/reglist-ppc.h"
+#elif V8_TARGET_ARCH_MIPS
+#include "src/codegen/mips/reglist-mips.h"
+#elif V8_TARGET_ARCH_MIPS64
+#include "src/codegen/mips64/reglist-mips64.h"
+#elif V8_TARGET_ARCH_LOONG64
+#include "src/codegen/loong64/reglist-loong64.h"
+#elif V8_TARGET_ARCH_S390
+#include "src/codegen/s390/reglist-s390.h"
+#elif V8_TARGET_ARCH_RISCV64
+#include "src/codegen/riscv64/reglist-riscv64.h"
 #else
-using RegList = uint32_t;
+#error Unknown architecture.
 #endif
 
-constexpr RegList kEmptyRegList = 0;
-
-// Get the number of registers in a given register list.
-constexpr int NumRegs(RegList list) {
-  return base::bits::CountPopulation(list);
-}
+namespace v8 {
+namespace internal {
 
-namespace detail {
-// Combine two RegLists by building the union of the contained registers.
-// TODO(clemensb): Replace by constexpr lambda once we have C++17.
-constexpr RegList CombineRegListsHelper(RegList list1, RegList list2) {
-  return list1 | list2;
-}
-}  // namespace detail
+static constexpr RegList kEmptyRegList = {};
 
-// Combine several RegLists by building the union of the contained registers.
-template <typename... RegLists>
-constexpr RegList CombineRegLists(RegLists... lists) {
-  return base::fold(detail::CombineRegListsHelper, 0, lists...);
-}
+#define LIST_REG(V) V,
+static constexpr RegList kAllocatableGeneralRegisters = {
+    ALLOCATABLE_GENERAL_REGISTERS(LIST_REG) Register::no_reg()};
+#undef LIST_REG
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/codegen/riscv64/assembler-riscv64.cc b/src/codegen/riscv64/assembler-riscv64.cc
index a6a3a6e48e..50a0518a14 100644
--- a/src/codegen/riscv64/assembler-riscv64.cc
+++ b/src/codegen/riscv64/assembler-riscv64.cc
@@ -214,7 +214,7 @@ Assembler::Assembler(const AssemblerOptions& options,
                      std::unique_ptr<AssemblerBuffer> buffer)
     : AssemblerBase(options, std::move(buffer)),
       VU(this),
-      scratch_register_list_(t3.bit() | t5.bit()),
+      scratch_register_list_({t3, t5}),
       constpool_(this) {
   reloc_info_writer.Reposition(buffer_start_ + buffer_->size(), pc_);
 
diff --git a/src/codegen/riscv64/assembler-riscv64.h b/src/codegen/riscv64/assembler-riscv64.h
index 522c967947..8d80065dd3 100644
--- a/src/codegen/riscv64/assembler-riscv64.h
+++ b/src/codegen/riscv64/assembler-riscv64.h
@@ -1796,11 +1796,11 @@ class V8_EXPORT_PRIVATE UseScratchRegisterScope {
   void Include(const RegList& list) { *available_ |= list; }
   void Exclude(const RegList& list) { *available_ &= ~list; }
   void Include(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Include(list);
   }
   void Exclude(const Register& reg1, const Register& reg2 = no_reg) {
-    RegList list(reg1.bit() | reg2.bit());
+    RegList list({reg1, reg2});
     Exclude(list);
   }
 
diff --git a/src/codegen/riscv64/interface-descriptors-riscv64-inl.h b/src/codegen/riscv64/interface-descriptors-riscv64-inl.h
index 64a6915f47..b5595d01d7 100644
--- a/src/codegen/riscv64/interface-descriptors-riscv64-inl.h
+++ b/src/codegen/riscv64/interface-descriptors-riscv64-inl.h
@@ -25,14 +25,14 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | a0.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | a1.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | a2.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | a3.bit());
-  if (argc >= 5) DCHECK(allocatable_regs | a4.bit());
-  if (argc >= 6) DCHECK(allocatable_regs | a5.bit());
-  if (argc >= 7) DCHECK(allocatable_regs | a6.bit());
-  if (argc >= 8) DCHECK(allocatable_regs | a7.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(a0));
+  if (argc >= 2) DCHECK(allocatable_regs.has(a1));
+  if (argc >= 3) DCHECK(allocatable_regs.has(a2));
+  if (argc >= 4) DCHECK(allocatable_regs.has(a3));
+  if (argc >= 5) DCHECK(allocatable_regs.has(a4));
+  if (argc >= 6) DCHECK(allocatable_regs.has(a5));
+  if (argc >= 7) DCHECK(allocatable_regs.has(a6));
+  if (argc >= 8) DCHECK(allocatable_regs.has(a7));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/riscv64/macro-assembler-riscv64.cc b/src/codegen/riscv64/macro-assembler-riscv64.cc
index ad7d446c73..d7d576558e 100644
--- a/src/codegen/riscv64/macro-assembler-riscv64.cc
+++ b/src/codegen/riscv64/macro-assembler-riscv64.cc
@@ -48,22 +48,13 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
                                                     Register exclusion2,
                                                     Register exclusion3) const {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
-  bytes += NumRegs(list) * kSystemPointerSize;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
+  bytes += list.Count() * kSystemPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -72,24 +63,15 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
 int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
                                     Register exclusion2, Register exclusion3) {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPush(list);
-  bytes += NumRegs(list) * kSystemPointerSize;
+  bytes += list.Count() * kSystemPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPushFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
   return bytes;
@@ -100,23 +82,13 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
   int bytes = 0;
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPopFPU(kCallerSavedFPU);
-    bytes += NumRegs(kCallerSavedFPU) * kDoubleSize;
-  }
-
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
+    bytes += kCallerSavedFPU.Count() * kDoubleSize;
   }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPop(list);
-  bytes += NumRegs(list) * kSystemPointerSize;
+  bytes += list.Count() * kSystemPointerSize;
 
   return bytes;
 }
@@ -205,25 +177,13 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPush(regs);
+  if (registers.is_empty()) return;
+  MultiPush(registers);
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPop(regs);
+  if (registers.is_empty()) return;
+  MultiPop(registers);
 }
 
 void TurboAssembler::CallEphemeronKeyBarrier(Register object,
@@ -1693,20 +1653,19 @@ void TurboAssembler::li(Register rd, Operand j, LiFlags mode) {
   }
 }
 
-static RegList t_regs = Register::ListOf(t0, t1, t2, t3, t4, t5, t6);
-static RegList a_regs = Register::ListOf(a0, a1, a2, a3, a4, a5, a6, a7);
-static RegList s_regs =
-    Register::ListOf(s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11);
+static RegList t_regs = {t0, t1, t2, t3, t4, t5, t6};
+static RegList a_regs = {a0, a1, a2, a3, a4, a5, a6, a7};
+static RegList s_regs = {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11};
 
 void TurboAssembler::MultiPush(RegList regs) {
   int16_t num_to_push = base::bits::CountPopulation(regs);
   int16_t stack_offset = num_to_push * kSystemPointerSize;
 
 #define TEST_AND_PUSH_REG(reg)             \
-  if ((regs & reg.bit()) != 0) {           \
+  if (regs.has(reg)) {                     \
     stack_offset -= kSystemPointerSize;    \
     Sd(reg, MemOperand(sp, stack_offset)); \
-    regs &= ~reg.bit();                    \
+    regs.clear(reg);                       \
   }
 
 #define T_REGS(V) V(t6) V(t5) V(t4) V(t3) V(t2) V(t1) V(t0)
@@ -1746,10 +1705,10 @@ void TurboAssembler::MultiPop(RegList regs) {
   int16_t stack_offset = 0;
 
 #define TEST_AND_POP_REG(reg)              \
-  if ((regs & reg.bit()) != 0) {           \
+  if (regs.has(reg)) {                     \
     Ld(reg, MemOperand(sp, stack_offset)); \
     stack_offset += kSystemPointerSize;    \
-    regs &= ~reg.bit();                    \
+    regs.clear(reg);                       \
   }
 
 #define T_REGS(V) V(t0) V(t1) V(t2) V(t3) V(t4) V(t5) V(t6)
@@ -4993,19 +4952,13 @@ void TurboAssembler::CheckPageFlag(Register object, Register scratch, int mask,
 Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
                                    Register reg4, Register reg5,
                                    Register reg6) {
-  RegList regs = 0;
-  if (reg1.is_valid()) regs |= reg1.bit();
-  if (reg2.is_valid()) regs |= reg2.bit();
-  if (reg3.is_valid()) regs |= reg3.bit();
-  if (reg4.is_valid()) regs |= reg4.bit();
-  if (reg5.is_valid()) regs |= reg5.bit();
-  if (reg6.is_valid()) regs |= reg6.bit();
+  RegList regs = {reg1, reg2, reg3, reg4, reg5, reg6};
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
   for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
     int code = config->GetAllocatableGeneralCode(i);
     Register candidate = Register::from_code(code);
-    if (regs & candidate.bit()) continue;
+    if (regs.has(candidate)) continue;
     return candidate;
   }
   UNREACHABLE();
diff --git a/src/codegen/riscv64/register-riscv64.h b/src/codegen/riscv64/register-riscv64.h
index 3b17e77a0e..7468938d36 100644
--- a/src/codegen/riscv64/register-riscv64.h
+++ b/src/codegen/riscv64/register-riscv64.h
@@ -6,8 +6,6 @@
 #define V8_CODEGEN_RISCV64_REGISTER_RISCV64_H_
 
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 #include "src/codegen/riscv64/constants-riscv64.h"
 
 namespace v8 {
@@ -123,7 +121,7 @@ const RegList kCalleeSavedFPU = 1 << 8 |   // fs0
                                 1 << 26 |  // fs10
                                 1 << 27;   // fs11
 
-const int kNumCalleeSavedFPU = NumRegs(kCalleeSavedFPU);
+const int kNumCalleeSavedFPU = kCalleeSavedFPU.Count();
 
 const RegList kCallerSavedFPU = 1 << 0 |   // ft0
                                 1 << 1 |   // ft1
@@ -146,7 +144,7 @@ const RegList kCallerSavedFPU = 1 << 0 |   // ft0
                                 1 << 30 |  // ft10
                                 1 << 31;   // ft11
 
-const int kNumCallerSavedFPU = NumRegs(kCallerSavedFPU);
+const int kNumCallerSavedFPU = kCallerSavedFPU.Count();
 
 // Number of registers for which space is reserved in safepoints. Must be a
 // multiple of 8.
diff --git a/src/codegen/riscv64/reglist-riscv64.h b/src/codegen/riscv64/reglist-riscv64.h
new file mode 100644
index 0000000000..d56363bce5
--- /dev/null
+++ b/src/codegen/riscv64/reglist-riscv64.h
@@ -0,0 +1,64 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_RISCV64_REGLIST_RISCV64_H_
+#define V8_CODEGEN_RISCV64_REGLIST_RISCV64_H_
+
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+#include "src/codegen/riscv64/constants-riscv64.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+const RegList kJSCallerSaved = {t0, t1, t2, a0, a1, a2, a3, a4, a5, a6, a7, t4};
+
+const int kNumJSCallerSaved = 12;
+
+// Callee-saved registers preserved when switching from C to JavaScript.
+const RegList kCalleeSaved = {fp,    // fp/s0
+                              s1,    // s1
+                              s2,    // s2
+                              s3,    // s3 scratch register
+                              s4,    // s4 scratch register 2
+                              s5,    // s5
+                              s6,    // s6 (roots in Javascript code)
+                              s7,    // s7 (cp in Javascript code)
+                              s8,    // s8
+                              s9,    // s9
+                              s10,   // s10
+                              s11};  // s11
+
+const int kNumCalleeSaved = 12;
+
+const RegList kCalleeSavedFPU = {fs0, fs1, fs2, fs3, fs4,  fs5,
+                                 fs6, fs7, fs8, fs9, fs10, fs11};
+
+const int kNumCalleeSavedFPU = kCalleeSavedFPU.Count();
+
+const RegList kCallerSavedFPU = {ft0, ft1, ft2, ft3, ft4,  ft5, ft6,
+                                 ft7, fa0, fa1, fa2, fa3,  fa4, fa5,
+                                 fa6, fa7, ft8, ft9, ft10, ft11};
+
+const int kNumCallerSavedFPU = kCallerSavedFPU.Count();
+
+// Number of registers for which space is reserved in safepoints. Must be a
+// multiple of 8.
+const int kNumSafepointRegisters = 32;
+
+// Define the list of registers actually saved at safepoints.
+// Note that the number of saved registers may be smaller than the reserved
+// space, i.e. kNumSafepointSavedRegisters <= kNumSafepointRegisters.
+const RegList kSafepointSavedRegisters = kJSCallerSaved | kCalleeSaved;
+const int kNumSafepointSavedRegisters = kNumJSCallerSaved + kNumCalleeSaved;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_RISCV64_REGLIST_RISCV64_H_
diff --git a/src/codegen/s390/assembler-s390.cc b/src/codegen/s390/assembler-s390.cc
index edb2acbcef..0c7350f9d1 100644
--- a/src/codegen/s390/assembler-s390.cc
+++ b/src/codegen/s390/assembler-s390.cc
@@ -375,8 +375,7 @@ void Assembler::AllocateAndInstallRequestedHeapObjects(Isolate* isolate) {
 
 Assembler::Assembler(const AssemblerOptions& options,
                      std::unique_ptr<AssemblerBuffer> buffer)
-    : AssemblerBase(options, std::move(buffer)),
-      scratch_register_list_(ip.bit()) {
+    : AssemblerBase(options, std::move(buffer)), scratch_register_list_({ip}) {
   reloc_info_writer.Reposition(buffer_start_ + buffer_->size(), pc_);
   last_bound_pos_ = 0;
   relocations_.reserve(128);
@@ -885,11 +884,7 @@ UseScratchRegisterScope::~UseScratchRegisterScope() {
 Register UseScratchRegisterScope::Acquire() {
   RegList* available = assembler_->GetScratchRegisterList();
   DCHECK_NOT_NULL(available);
-  DCHECK_NE(*available, 0);
-  int index = static_cast<int>(base::bits::CountTrailingZeros32(*available));
-  Register reg = Register::from_code(index);
-  *available &= ~reg.bit();
-  return reg;
+  return available->PopFront();
 }
 }  // namespace internal
 }  // namespace v8
diff --git a/src/codegen/s390/interface-descriptors-s390-inl.h b/src/codegen/s390/interface-descriptors-s390-inl.h
index b09db00dcd..d23c4fde34 100644
--- a/src/codegen/s390/interface-descriptors-s390-inl.h
+++ b/src/codegen/s390/interface-descriptors-s390-inl.h
@@ -24,14 +24,14 @@ template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data, int argc) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (argc >= 1) DCHECK(allocatable_regs | r2.bit());
-  if (argc >= 2) DCHECK(allocatable_regs | r3.bit());
-  if (argc >= 3) DCHECK(allocatable_regs | r4.bit());
-  if (argc >= 4) DCHECK(allocatable_regs | r5.bit());
-  if (argc >= 5) DCHECK(allocatable_regs | r6.bit());
-  if (argc >= 6) DCHECK(allocatable_regs | r7.bit());
-  if (argc >= 7) DCHECK(allocatable_regs | r8.bit());
-  if (argc >= 8) DCHECK(allocatable_regs | r9.bit());
+  if (argc >= 1) DCHECK(allocatable_regs.has(r2));
+  if (argc >= 2) DCHECK(allocatable_regs.has(r3));
+  if (argc >= 3) DCHECK(allocatable_regs.has(r4));
+  if (argc >= 4) DCHECK(allocatable_regs.has(r5));
+  if (argc >= 5) DCHECK(allocatable_regs.has(r6));
+  if (argc >= 6) DCHECK(allocatable_regs.has(r7));
+  if (argc >= 7) DCHECK(allocatable_regs.has(r8));
+  if (argc >= 8) DCHECK(allocatable_regs.has(r9));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/s390/macro-assembler-s390.cc b/src/codegen/s390/macro-assembler-s390.cc
index 9ecc20f8f2..56c9f60dfa 100644
--- a/src/codegen/s390/macro-assembler-s390.cc
+++ b/src/codegen/s390/macro-assembler-s390.cc
@@ -284,19 +284,10 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
                                                     Register exclusion2,
                                                     Register exclusion3) const {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
-  bytes += NumRegs(list) * kSystemPointerSize;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
+  bytes += list.Count() * kSystemPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     bytes += kStackSavedSavedFPSizeInBytes;
@@ -308,20 +299,11 @@ int TurboAssembler::RequiredStackSizeForCallerSaved(SaveFPRegsMode fp_mode,
 int TurboAssembler::PushCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
                                     Register exclusion2, Register exclusion3) {
   int bytes = 0;
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
 
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPush(list);
-  bytes += NumRegs(list) * kSystemPointerSize;
+  bytes += list.Count() * kSystemPointerSize;
 
   if (fp_mode == SaveFPRegsMode::kSave) {
     MultiPushF64OrV128(kCallerSavedDoubles);
@@ -339,20 +321,10 @@ int TurboAssembler::PopCallerSaved(SaveFPRegsMode fp_mode, Register exclusion1,
     bytes += kStackSavedSavedFPSizeInBytes;
   }
 
-  RegList exclusions = 0;
-  if (exclusion1 != no_reg) {
-    exclusions |= exclusion1.bit();
-    if (exclusion2 != no_reg) {
-      exclusions |= exclusion2.bit();
-      if (exclusion3 != no_reg) {
-        exclusions |= exclusion3.bit();
-      }
-    }
-  }
-
-  RegList list = kJSCallerSaved & ~exclusions;
+  RegList exclusions = {exclusion1, exclusion2, exclusion3};
+  RegList list = kJSCallerSaved - exclusions;
   MultiPop(list);
-  bytes += NumRegs(list) * kSystemPointerSize;
+  bytes += list.Count() * kSystemPointerSize;
 
   return bytes;
 }
@@ -753,14 +725,14 @@ void TurboAssembler::MultiPushF64OrV128(RegList dregs, Register location) {
     MultiPushDoubles(dregs);
     // We still need to allocate empty space on the stack as if
     // Simd rgeisters were saved (see kFixedFrameSizeFromFp).
-    lay(sp, MemOperand(sp, -(NumRegs(dregs) * kDoubleSize)));
+    lay(sp, MemOperand(sp, -(dregs.Count() * kDoubleSize)));
     bind(&simd_pushed);
   } else {
     if (CpuFeatures::SupportsWasmSimd128()) {
       MultiPushV128(dregs);
     } else {
       MultiPushDoubles(dregs);
-      lay(sp, MemOperand(sp, -(NumRegs(dregs) * kDoubleSize)));
+      lay(sp, MemOperand(sp, -(dregs.Count() * kDoubleSize)));
     }
   }
 #else
@@ -783,14 +755,14 @@ void TurboAssembler::MultiPopF64OrV128(RegList dregs, Register location) {
     b(&simd_popped);
     bind(&pop_doubles);
     // Simd not supported, only pop double registers.
-    lay(sp, MemOperand(sp, NumRegs(dregs) * kDoubleSize));
+    lay(sp, MemOperand(sp, dregs.Count() * kDoubleSize));
     MultiPopDoubles(dregs);
     bind(&simd_popped);
   } else {
     if (CpuFeatures::SupportsWasmSimd128()) {
       MultiPopV128(dregs);
     } else {
-      lay(sp, MemOperand(sp, NumRegs(dregs) * kDoubleSize));
+      lay(sp, MemOperand(sp, dregs.Count() * kDoubleSize));
       MultiPopDoubles(dregs);
     }
   }
@@ -947,25 +919,13 @@ void MacroAssembler::RecordWriteField(Register object, int offset,
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPush(regs);
+  if (registers.is_empty()) return;
+  MultiPush(registers);
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  RegList regs = 0;
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      regs |= Register::from_code(i).bit();
-    }
-  }
-  MultiPop(regs);
+  if (registers.is_empty()) return;
+  MultiPop(registers);
 }
 
 void TurboAssembler::CallEphemeronKeyBarrier(Register object,
@@ -2455,19 +2415,13 @@ void TurboAssembler::CheckPageFlag(
 Register GetRegisterThatIsNotOneOf(Register reg1, Register reg2, Register reg3,
                                    Register reg4, Register reg5,
                                    Register reg6) {
-  RegList regs = 0;
-  if (reg1.is_valid()) regs |= reg1.bit();
-  if (reg2.is_valid()) regs |= reg2.bit();
-  if (reg3.is_valid()) regs |= reg3.bit();
-  if (reg4.is_valid()) regs |= reg4.bit();
-  if (reg5.is_valid()) regs |= reg5.bit();
-  if (reg6.is_valid()) regs |= reg6.bit();
+  RegList regs = {reg1, reg2, reg3, reg4, reg5, reg6};
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
   for (int i = 0; i < config->num_allocatable_general_registers(); ++i) {
     int code = config->GetAllocatableGeneralCode(i);
     Register candidate = Register::from_code(code);
-    if (regs & candidate.bit()) continue;
+    if (regs.has(candidate)) continue;
     return candidate;
   }
   UNREACHABLE();
diff --git a/src/codegen/s390/register-s390.h b/src/codegen/s390/register-s390.h
index 4007afd59f..b3e5a49f2d 100644
--- a/src/codegen/s390/register-s390.h
+++ b/src/codegen/s390/register-s390.h
@@ -6,8 +6,6 @@
 #define V8_CODEGEN_S390_REGISTER_S390_H_
 
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -37,56 +35,6 @@ namespace internal {
   V(cr8)  V(cr9)  V(cr10) V(cr11) V(cr12) V(cr15)
 // clang-format on
 
-// Register list in load/store instructions
-// Note that the bit values must match those used in actual instruction encoding
-
-// Caller-saved/arguments registers
-const RegList kJSCallerSaved = 1 << 1 | 1 << 2 |  // r2  a1
-                               1 << 3 |           // r3  a2
-                               1 << 4 |           // r4  a3
-                               1 << 5;            // r5  a4
-
-const int kNumJSCallerSaved = 5;
-
-// Callee-saved registers preserved when switching from C to JavaScript
-const RegList kCalleeSaved =
-    1 << 6 |   // r6 (argument passing in CEntryStub)
-               //    (HandleScope logic in MacroAssembler)
-    1 << 7 |   // r7 (argument passing in CEntryStub)
-               //    (HandleScope logic in MacroAssembler)
-    1 << 8 |   // r8 (argument passing in CEntryStub)
-               //    (HandleScope logic in MacroAssembler)
-    1 << 9 |   // r9 (HandleScope logic in MacroAssembler)
-    1 << 10 |  // r10 (Roots register in Javascript)
-    1 << 11 |  // r11 (fp in Javascript)
-    1 << 12 |  // r12 (ip in Javascript)
-    1 << 13;   // r13 (cp in Javascript)
-// 1 << 15;   // r15 (sp in Javascript)
-
-const int kNumCalleeSaved = 8;
-
-const RegList kCallerSavedDoubles = 1 << 0 |  // d0
-                                    1 << 1 |  // d1
-                                    1 << 2 |  // d2
-                                    1 << 3 |  // d3
-                                    1 << 4 |  // d4
-                                    1 << 5 |  // d5
-                                    1 << 6 |  // d6
-                                    1 << 7;   // d7
-
-const int kNumCallerSavedDoubles = 8;
-
-const RegList kCalleeSavedDoubles = 1 << 8 |   // d8
-                                    1 << 9 |   // d9
-                                    1 << 10 |  // d10
-                                    1 << 11 |  // d11
-                                    1 << 12 |  // d12
-                                    1 << 13 |  // d12
-                                    1 << 14 |  // d12
-                                    1 << 15;   // d13
-
-const int kNumCalleeSavedDoubles = 8;
-
 // The following constants describe the stack frame linkage area as
 // defined by the ABI.
 
diff --git a/src/codegen/s390/reglist-s390.h b/src/codegen/s390/reglist-s390.h
new file mode 100644
index 0000000000..19fb017734
--- /dev/null
+++ b/src/codegen/s390/reglist-s390.h
@@ -0,0 +1,57 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_S390_REGLIST_S390_H_
+#define V8_CODEGEN_S390_REGLIST_S390_H_
+
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+// Register list in load/store instructions
+// Note that the bit values must match those used in actual instruction encoding
+
+// Caller-saved/arguments registers
+const RegList kJSCallerSaved = {r1, r2,  // r2  a1
+                                r3,      // r3  a2
+                                r4,      // r4  a3
+                                r5};     // r5  a4
+
+const int kNumJSCallerSaved = 5;
+
+// Callee-saved registers preserved when switching from C to JavaScript
+const RegList kCalleeSaved = {r6,    // r6 (argument passing in CEntryStub)
+                                     //    (HandleScope logic in MacroAssembler)
+                              r7,    // r7 (argument passing in CEntryStub)
+                                     //    (HandleScope logic in MacroAssembler)
+                              r8,    // r8 (argument passing in CEntryStub)
+                                     //    (HandleScope logic in MacroAssembler)
+                              r9,    // r9 (HandleScope logic in MacroAssembler)
+                              r10,   // r10 (Roots register in Javascript)
+                              r11,   // r11 (fp in Javascript)
+                              r12,   // r12 (ip in Javascript)
+                              r13};  // r13 (cp in Javascript)
+// r15;   // r15 (sp in Javascript)
+
+const int kNumCalleeSaved = 8;
+
+const RegList kCallerSavedDoubles = {d0, d1, d2, d3, d4, d5, d6, d7};
+
+const int kNumCallerSavedDoubles = 8;
+
+const RegList kCalleeSavedDoubles = {d8, d9, d10, d11, d12, d13, d14, d15};
+
+const int kNumCalleeSavedDoubles = 8;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_S390_REGLIST_S390_H_
diff --git a/src/codegen/x64/interface-descriptors-x64-inl.h b/src/codegen/x64/interface-descriptors-x64-inl.h
index 01dccc384b..af9b2e1cf2 100644
--- a/src/codegen/x64/interface-descriptors-x64-inl.h
+++ b/src/codegen/x64/interface-descriptors-x64-inl.h
@@ -24,10 +24,10 @@ void StaticCallInterfaceDescriptor<DerivedDescriptor>::
     VerifyArgumentRegisterCount(CallInterfaceDescriptorData* data,
                                 int nof_expected_args) {
   RegList allocatable_regs = data->allocatable_registers();
-  if (nof_expected_args >= 1) DCHECK(allocatable_regs | arg_reg_1.bit());
-  if (nof_expected_args >= 2) DCHECK(allocatable_regs | arg_reg_2.bit());
-  if (nof_expected_args >= 3) DCHECK(allocatable_regs | arg_reg_3.bit());
-  if (nof_expected_args >= 4) DCHECK(allocatable_regs | arg_reg_4.bit());
+  if (nof_expected_args >= 1) DCHECK(allocatable_regs.has(arg_reg_1));
+  if (nof_expected_args >= 2) DCHECK(allocatable_regs.has(arg_reg_2));
+  if (nof_expected_args >= 3) DCHECK(allocatable_regs.has(arg_reg_3));
+  if (nof_expected_args >= 4) DCHECK(allocatable_regs.has(arg_reg_4));
   // Additional arguments are passed on the stack.
 }
 #endif  // DEBUG
diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index 27f12cd8f8..631c118df2 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -442,22 +442,14 @@ void TurboAssembler::LoadExternalPointerField(
 }
 
 void TurboAssembler::MaybeSaveRegisters(RegList registers) {
-  if (registers == 0) return;
-  DCHECK_GT(NumRegs(registers), 0);
-  for (int i = 0; i < Register::kNumRegisters; ++i) {
-    if ((registers >> i) & 1u) {
-      pushq(Register::from_code(i));
-    }
+  for (Register reg : registers) {
+    pushq(reg);
   }
 }
 
 void TurboAssembler::MaybeRestoreRegisters(RegList registers) {
-  if (registers == 0) return;
-  DCHECK_GT(NumRegs(registers), 0);
-  for (int i = Register::kNumRegisters - 1; i >= 0; --i) {
-    if ((registers >> i) & 1u) {
-      popq(Register::from_code(i));
-    }
+  for (Register reg : base::Reversed(registers)) {
+    popq(reg);
   }
 }
 
diff --git a/src/codegen/x64/register-x64.h b/src/codegen/x64/register-x64.h
index 261be62dac..a9c563317e 100644
--- a/src/codegen/x64/register-x64.h
+++ b/src/codegen/x64/register-x64.h
@@ -6,8 +6,6 @@
 #define V8_CODEGEN_X64_REGISTER_X64_H_
 
 #include "src/codegen/register-base.h"
-#include "src/codegen/register-configuration.h"
-#include "src/codegen/reglist.h"
 
 namespace v8 {
 namespace internal {
@@ -87,20 +85,6 @@ constexpr Register no_reg = Register::no_reg();
 
 constexpr int kNumRegs = 16;
 
-constexpr RegList kJSCallerSaved =
-    Register::ListOf(rax, rcx, rdx,
-                     rbx,  // used as a caller-saved register in JavaScript code
-                     rdi);  // callee function
-
-constexpr RegList kCallerSaved =
-#ifdef V8_TARGET_OS_WIN
-    Register::ListOf(rax, rcx, rdx, r8, r9, r10, r11);
-#else
-    Register::ListOf(rax, rcx, rdx, rdi, rsi, r8, r9, r10, r11);
-#endif  // V8_TARGET_OS_WIN
-
-constexpr int kNumJSCallerSaved = 5;
-
 #ifdef V8_TARGET_OS_WIN
 // Windows calling convention
 constexpr Register arg_reg_1 = rcx;
diff --git a/src/codegen/x64/reglist-x64.h b/src/codegen/x64/reglist-x64.h
new file mode 100644
index 0000000000..6c7be82440
--- /dev/null
+++ b/src/codegen/x64/reglist-x64.h
@@ -0,0 +1,37 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_X64_REGLIST_X64_H_
+#define V8_CODEGEN_X64_REGLIST_X64_H_
+
+#include "src/base/macros.h"
+#include "src/codegen/register-arch.h"
+#include "src/codegen/reglist-base.h"
+
+namespace v8 {
+namespace internal {
+
+using RegList = RegListBase<Register>;
+using DoubleRegList = RegListBase<DoubleRegister>;
+ASSERT_TRIVIALLY_COPYABLE(RegList);
+ASSERT_TRIVIALLY_COPYABLE(DoubleRegList);
+
+constexpr RegList kJSCallerSaved = {
+    rax, rcx, rdx,
+    rbx,   // used as a caller-saved register in JavaScript code
+    rdi};  // callee function
+
+constexpr RegList kCallerSaved =
+#ifdef V8_TARGET_OS_WIN
+    {rax, rcx, rdx, r8, r9, r10, r11};
+#else
+    {rax, rcx, rdx, rdi, rsi, r8, r9, r10, r11};
+#endif  // V8_TARGET_OS_WIN
+
+constexpr int kNumJSCallerSaved = 5;
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_X64_REGLIST_X64_H_
diff --git a/src/common/globals.h b/src/common/globals.h
index 5f5a95a8c1..6c3e82a90e 100644
--- a/src/common/globals.h
+++ b/src/common/globals.h
@@ -1719,6 +1719,17 @@ inline std::ostream& operator<<(std::ostream& os, ConcurrencyMode mode) {
   return os << ToString(mode);
 }
 
+// An architecture independent representation of the sets of registers available
+// for instruction creation.
+enum class AliasingKind {
+  // Registers alias a single register of every other size (e.g. Intel).
+  kOverlap,
+  // Registers alias two registers of the next smaller size (e.g. ARM).
+  kCombine,
+  // SIMD128 Registers are independent of every other size (e.g Riscv)
+  kIndependent
+};
+
 #define FOR_EACH_ISOLATE_ADDRESS_NAME(C)                            \
   C(Handler, handler)                                               \
   C(CEntryFP, c_entry_fp)                                           \
diff --git a/src/compiler/backend/arm/code-generator-arm.cc b/src/compiler/backend/arm/code-generator-arm.cc
index 73fc2b9c26..ab929915e1 100644
--- a/src/compiler/backend/arm/code-generator-arm.cc
+++ b/src/compiler/backend/arm/code-generator-arm.cc
@@ -516,7 +516,7 @@ void CodeGenerator::AssembleDeconstructFrame() {
 
 void CodeGenerator::AssemblePrepareTailCall() {
   if (frame_access_state()->has_frame()) {
-    __ ldm(ia, fp, lr.bit() | fp.bit());
+    __ ldm(ia, fp, {lr, fp});
   }
   frame_access_state()->SetFrameAccessToSP();
 }
@@ -3659,24 +3659,24 @@ void CodeGenerator::AssembleArchSelect(Instruction* instr,
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
 
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
-  if (saves_fp != 0) {
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  if (!saves_fp.is_empty()) {
     frame->AlignSavedCalleeRegisterSlots();
   }
 
-  if (saves_fp != 0) {
+  if (!saves_fp.is_empty()) {
     // Save callee-saved FP registers.
     STATIC_ASSERT(DwVfpRegister::kNumRegisters == 32);
-    uint32_t last = base::bits::CountLeadingZeros32(saves_fp) - 1;
-    uint32_t first = base::bits::CountTrailingZeros32(saves_fp);
-    DCHECK_EQ((last - first + 1), base::bits::CountPopulation(saves_fp));
+    uint32_t last = base::bits::CountLeadingZeros32(saves_fp.bits()) - 1;
+    uint32_t first = base::bits::CountTrailingZeros32(saves_fp.bits());
+    DCHECK_EQ((last - first + 1), saves_fp.Count());
     frame->AllocateSavedCalleeRegisterSlots((last - first + 1) *
                                             (kDoubleSize / kSystemPointerSize));
   }
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     // Save callee-saved registers.
-    frame->AllocateSavedCalleeRegisterSlots(base::bits::CountPopulation(saves));
+    frame->AllocateSavedCalleeRegisterSlots(saves.Count());
   }
 }
 
@@ -3734,7 +3734,7 @@ void CodeGenerator::AssembleConstructFrame() {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
 
   if (required_slots > 0) {
     DCHECK(frame_access_state()->has_frame());
@@ -3773,25 +3773,21 @@ void CodeGenerator::AssembleConstructFrame() {
 #endif  // V8_ENABLE_WEBASSEMBLY
 
     // Skip callee-saved and return slots, which are pushed below.
-    required_slots -= base::bits::CountPopulation(saves);
+    required_slots -= saves.Count();
     required_slots -= frame()->GetReturnSlotCount();
-    required_slots -= 2 * base::bits::CountPopulation(saves_fp);
+    required_slots -= 2 * saves_fp.Count();
     if (required_slots > 0) {
       __ AllocateStackSpace(required_slots * kSystemPointerSize);
     }
   }
 
-  if (saves_fp != 0) {
+  if (!saves_fp.is_empty()) {
     // Save callee-saved FP registers.
     STATIC_ASSERT(DwVfpRegister::kNumRegisters == 32);
-    uint32_t last = base::bits::CountLeadingZeros32(saves_fp) - 1;
-    uint32_t first = base::bits::CountTrailingZeros32(saves_fp);
-    DCHECK_EQ((last - first + 1), base::bits::CountPopulation(saves_fp));
-    __ vstm(db_w, sp, DwVfpRegister::from_code(first),
-            DwVfpRegister::from_code(last));
+    __ vstm(db_w, sp, saves_fp.first(), saves_fp.last());
   }
 
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     // Save callee-saved registers.
     __ stm(db_w, sp, saves);
   }
@@ -3812,18 +3808,15 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // Restore registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ ldm(ia_w, sp, saves);
   }
 
   // Restore FP registers.
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
-  if (saves_fp != 0) {
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  if (!saves_fp.is_empty()) {
     STATIC_ASSERT(DwVfpRegister::kNumRegisters == 32);
-    uint32_t last = base::bits::CountLeadingZeros32(saves_fp) - 1;
-    uint32_t first = base::bits::CountTrailingZeros32(saves_fp);
-    __ vldm(ia_w, sp, DwVfpRegister::from_code(first),
-            DwVfpRegister::from_code(last));
+    __ vldm(ia_w, sp, saves_fp.first(), saves_fp.last());
   }
 
   unwinding_info_writer_.MarkBlockWillExit();
@@ -3868,7 +3861,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     if (drop_jsargs) {
       // Get the actual argument count.
       __ ldr(argc_reg, MemOperand(fp, StandardFrameConstants::kArgCOffset));
-      DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+      DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
     }
     AssembleDeconstructFrame();
   }
@@ -3878,7 +3871,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     // The number of arguments without the receiver is
     // max(argc_reg, parameter_slots-1), and the receiver is added in
     // DropArguments().
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
     if (parameter_slots > 1) {
       __ cmp(argc_reg, Operand(parameter_slots));
       __ mov(argc_reg, Operand(parameter_slots), LeaveCC, lt);
diff --git a/src/compiler/backend/arm64/code-generator-arm64.cc b/src/compiler/backend/arm64/code-generator-arm64.cc
index 5e0151463b..3f1842f64e 100644
--- a/src/compiler/backend/arm64/code-generator-arm64.cc
+++ b/src/compiler/backend/arm64/code-generator-arm64.cc
@@ -3005,17 +3005,17 @@ void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
 
   // Save FP registers.
-  CPURegList saves_fp = CPURegList(CPURegister::kVRegister, kDRegSizeInBits,
-                                   call_descriptor->CalleeSavedFPRegisters());
+  CPURegList saves_fp =
+      CPURegList(kDRegSizeInBits, call_descriptor->CalleeSavedFPRegisters());
   int saved_count = saves_fp.Count();
   if (saved_count != 0) {
-    DCHECK(saves_fp.list() == CPURegList::GetCalleeSavedV().list());
+    DCHECK(saves_fp.bits() == CPURegList::GetCalleeSavedV().bits());
     frame->AllocateSavedCalleeRegisterSlots(saved_count *
                                             (kDoubleSize / kSystemPointerSize));
   }
 
-  CPURegList saves = CPURegList(CPURegister::kRegister, kXRegSizeInBits,
-                                call_descriptor->CalleeSavedRegisters());
+  CPURegList saves =
+      CPURegList(kXRegSizeInBits, call_descriptor->CalleeSavedRegisters());
   saved_count = saves.Count();
   if (saved_count != 0) {
     frame->AllocateSavedCalleeRegisterSlots(saved_count);
@@ -3032,11 +3032,11 @@ void CodeGenerator::AssembleConstructFrame() {
   int required_slots =
       frame()->GetTotalFrameSlotCount() - frame()->GetFixedSlotCount();
 
-  CPURegList saves = CPURegList(CPURegister::kRegister, kXRegSizeInBits,
-                                call_descriptor->CalleeSavedRegisters());
+  CPURegList saves =
+      CPURegList(kXRegSizeInBits, call_descriptor->CalleeSavedRegisters());
   DCHECK_EQ(saves.Count() % 2, 0);
-  CPURegList saves_fp = CPURegList(CPURegister::kVRegister, kDRegSizeInBits,
-                                   call_descriptor->CalleeSavedFPRegisters());
+  CPURegList saves_fp =
+      CPURegList(kDRegSizeInBits, call_descriptor->CalleeSavedFPRegisters());
   DCHECK_EQ(saves_fp.Count() % 2, 0);
   // The number of return slots should be even after aligning the Frame.
   const int returns = frame()->GetReturnSlotCount();
@@ -3191,7 +3191,7 @@ void CodeGenerator::AssembleConstructFrame() {
 
   // Save FP registers.
   DCHECK_IMPLIES(saves_fp.Count() != 0,
-                 saves_fp.list() == CPURegList::GetCalleeSavedV().list());
+                 saves_fp.bits() == CPURegList::GetCalleeSavedV().bits());
   __ PushCPURegList(saves_fp);
 
   // Save registers.
@@ -3211,13 +3211,13 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
   }
 
   // Restore registers.
-  CPURegList saves = CPURegList(CPURegister::kRegister, kXRegSizeInBits,
-                                call_descriptor->CalleeSavedRegisters());
+  CPURegList saves =
+      CPURegList(kXRegSizeInBits, call_descriptor->CalleeSavedRegisters());
   __ PopCPURegList<TurboAssembler::kAuthLR>(saves);
 
   // Restore fp registers.
-  CPURegList saves_fp = CPURegList(CPURegister::kVRegister, kDRegSizeInBits,
-                                   call_descriptor->CalleeSavedFPRegisters());
+  CPURegList saves_fp =
+      CPURegList(kDRegSizeInBits, call_descriptor->CalleeSavedFPRegisters());
   __ PopCPURegList(saves_fp);
 
   unwinding_info_writer_.MarkBlockWillExit();
@@ -3261,7 +3261,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     }
     if (drop_jsargs) {
       // Get the actual argument count.
-      DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+      DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
       __ Ldr(argc_reg, MemOperand(fp, StandardFrameConstants::kArgCOffset));
     }
     AssembleDeconstructFrame();
@@ -3271,7 +3271,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     // We must pop all arguments from the stack (including the receiver). This
     // number of arguments is given by max(1 + argc_reg, parameter_slots).
     Label argc_reg_has_final_count;
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
     if (parameter_slots > 1) {
       __ Cmp(argc_reg, Operand(parameter_slots));
       __ B(&argc_reg_has_final_count, ge);
diff --git a/src/compiler/backend/ia32/code-generator-ia32.cc b/src/compiler/backend/ia32/code-generator-ia32.cc
index e1cc158fd3..2730728cdd 100644
--- a/src/compiler/backend/ia32/code-generator-ia32.cc
+++ b/src/compiler/backend/ia32/code-generator-ia32.cc
@@ -3999,14 +3999,9 @@ void CodeGenerator::AssembleArchSelect(Instruction* instr,
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {  // Save callee-saved registers.
+  if (!saves.is_empty()) {  // Save callee-saved registers.
     DCHECK(!info()->is_osr());
-    int pushed = 0;
-    for (int i = Register::kNumRegisters - 1; i >= 0; i--) {
-      if (!((1 << i) & saves)) continue;
-      ++pushed;
-    }
-    frame->AllocateSavedCalleeRegisterSlots(pushed);
+    frame->AllocateSavedCalleeRegisterSlots(saves.Count());
   }
 }
 
@@ -4096,17 +4091,17 @@ void CodeGenerator::AssembleConstructFrame() {
 #endif  // V8_ENABLE_WEBASSEMBLY
 
     // Skip callee-saved and return slots, which are created below.
-    required_slots -= base::bits::CountPopulation(saves);
+    required_slots -= saves.Count();
     required_slots -= frame()->GetReturnSlotCount();
     if (required_slots > 0) {
       __ AllocateStackSpace(required_slots * kSystemPointerSize);
     }
   }
 
-  if (saves != 0) {  // Save callee-saved registers.
+  if (!saves.is_empty()) {  // Save callee-saved registers.
     DCHECK(!info()->is_osr());
-    for (int i = Register::kNumRegisters - 1; i >= 0; i--) {
-      if (((1 << i) & saves)) __ push(Register::from_code(i));
+    for (Register reg : base::Reversed(saves)) {
+      __ push(reg);
     }
   }
 
@@ -4121,14 +4116,13 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
   // Restore registers.
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     const int returns = frame()->GetReturnSlotCount();
     if (returns != 0) {
       __ add(esp, Immediate(returns * kSystemPointerSize));
     }
-    for (int i = 0; i < Register::kNumRegisters; i++) {
-      if (!((1 << i) & saves)) continue;
-      __ pop(Register::from_code(i));
+    for (Register reg : saves) {
+      __ pop(reg);
     }
   }
 
@@ -4172,7 +4166,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     if (drop_jsargs) {
       // Get the actual argument count.
       __ mov(argc_reg, Operand(ebp, StandardFrameConstants::kArgCOffset));
-      DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+      DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
     }
     AssembleDeconstructFrame();
   }
@@ -4185,8 +4179,8 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     Label mismatch_return;
     Register scratch_reg = edx;
     DCHECK_NE(argc_reg, scratch_reg);
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & scratch_reg.bit());
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(scratch_reg));
     __ cmp(argc_reg, Immediate(parameter_slots));
     __ j(greater, &mismatch_return, Label::kNear);
     __ Ret(parameter_slots * kSystemPointerSize, scratch_reg);
@@ -4204,16 +4198,15 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
       __ ret(static_cast<int>(pop_size));
     } else {
       Register scratch_reg = ecx;
-      DCHECK_EQ(0u,
-                call_descriptor->CalleeSavedRegisters() & scratch_reg.bit());
+      DCHECK(!call_descriptor->CalleeSavedRegisters().has(scratch_reg));
       CHECK_LE(pop_size, static_cast<size_t>(std::numeric_limits<int>::max()));
       __ Ret(static_cast<int>(pop_size), scratch_reg);
     }
   } else {
     Register pop_reg = g.ToRegister(additional_pop_count);
     Register scratch_reg = pop_reg == ecx ? edx : ecx;
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & scratch_reg.bit());
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & pop_reg.bit());
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(scratch_reg));
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(pop_reg));
     int pop_size = static_cast<int>(parameter_slots * kSystemPointerSize);
     __ PopReturnAddressTo(scratch_reg);
     __ lea(esp, Operand(esp, pop_reg, times_system_pointer_size,
diff --git a/src/compiler/backend/loong64/code-generator-loong64.cc b/src/compiler/backend/loong64/code-generator-loong64.cc
index 33794e0d9b..df7a574450 100644
--- a/src/compiler/backend/loong64/code-generator-loong64.cc
+++ b/src/compiler/backend/loong64/code-generator-loong64.cc
@@ -2181,7 +2181,7 @@ void CodeGenerator::AssembleArchSelect(Instruction* instr,
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
 
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     int count = base::bits::CountPopulation(saves_fpu);
     DCHECK_EQ(kNumCalleeSavedFPU, count);
@@ -2190,8 +2190,8 @@ void CodeGenerator::FinishFrame(Frame* frame) {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
-    int count = base::bits::CountPopulation(saves);
+  if (!saves.is_empty()) {
+    int count = saves.Count();
     frame->AllocateSavedCalleeRegisterSlots(count);
   }
 }
@@ -2249,7 +2249,7 @@ void CodeGenerator::AssembleConstructFrame() {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
 
   if (required_slots > 0) {
     DCHECK(frame_access_state()->has_frame());
@@ -2293,7 +2293,7 @@ void CodeGenerator::AssembleConstructFrame() {
   const int returns = frame()->GetReturnSlotCount();
 
   // Skip callee-saved and return slots, which are pushed below.
-  required_slots -= base::bits::CountPopulation(saves);
+  required_slots -= saves.Count();
   required_slots -= base::bits::CountPopulation(saves_fpu);
   required_slots -= returns;
   if (required_slots > 0) {
@@ -2306,7 +2306,7 @@ void CodeGenerator::AssembleConstructFrame() {
     DCHECK_EQ(kNumCalleeSavedFPU, base::bits::CountPopulation(saves_fpu));
   }
 
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     // Save callee-saved registers.
     __ MultiPush(saves);
   }
@@ -2327,12 +2327,12 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // Restore GP registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ MultiPop(saves);
   }
 
   // Restore FPU registers.
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     __ MultiPopFPU(saves_fpu);
   }
diff --git a/src/compiler/backend/mips/code-generator-mips.cc b/src/compiler/backend/mips/code-generator-mips.cc
index 1436097661..7dcdbc83f2 100644
--- a/src/compiler/backend/mips/code-generator-mips.cc
+++ b/src/compiler/backend/mips/code-generator-mips.cc
@@ -3934,7 +3934,7 @@ void CodeGenerator::AssembleArchSelect(Instruction* instr,
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
 
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     frame->AlignSavedCalleeRegisterSlots();
   }
@@ -3947,8 +3947,8 @@ void CodeGenerator::FinishFrame(Frame* frame) {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
-    int count = base::bits::CountPopulation(saves);
+  if (!saves.is_empty()) {
+    int count = saves.Count();
     frame->AllocateSavedCalleeRegisterSlots(count);
   }
 }
@@ -4005,7 +4005,7 @@ void CodeGenerator::AssembleConstructFrame() {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
 
   if (required_slots > 0) {
     DCHECK(frame_access_state()->has_frame());
@@ -4046,7 +4046,7 @@ void CodeGenerator::AssembleConstructFrame() {
   const int returns = frame()->GetReturnSlotCount();
 
   // Skip callee-saved and return slots, which are pushed below.
-  required_slots -= base::bits::CountPopulation(saves);
+  required_slots -= saves.Count();
   required_slots -= 2 * base::bits::CountPopulation(saves_fpu);
   required_slots -= returns;
   if (required_slots > 0) {
@@ -4058,7 +4058,7 @@ void CodeGenerator::AssembleConstructFrame() {
     __ MultiPushFPU(saves_fpu);
   }
 
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     // Save callee-saved registers.
     __ MultiPush(saves);
   }
@@ -4079,12 +4079,12 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // Restore GP registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ MultiPop(saves);
   }
 
   // Restore FPU registers.
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     __ MultiPopFPU(saves_fpu);
   }
diff --git a/src/compiler/backend/mips64/code-generator-mips64.cc b/src/compiler/backend/mips64/code-generator-mips64.cc
index 862bfd96ed..848db97c64 100644
--- a/src/compiler/backend/mips64/code-generator-mips64.cc
+++ b/src/compiler/backend/mips64/code-generator-mips64.cc
@@ -4139,7 +4139,7 @@ void CodeGenerator::AssembleArchSelect(Instruction* instr,
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
 
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     int count = base::bits::CountPopulation(saves_fpu);
     DCHECK_EQ(kNumCalleeSavedFPU, count);
@@ -4148,8 +4148,8 @@ void CodeGenerator::FinishFrame(Frame* frame) {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
-    int count = base::bits::CountPopulation(saves);
+  if (!saves.is_empty()) {
+    int count = saves.Count();
     frame->AllocateSavedCalleeRegisterSlots(count);
   }
 }
@@ -4207,7 +4207,7 @@ void CodeGenerator::AssembleConstructFrame() {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
 
   if (required_slots > 0) {
     DCHECK(frame_access_state()->has_frame());
@@ -4248,7 +4248,7 @@ void CodeGenerator::AssembleConstructFrame() {
   const int returns = frame()->GetReturnSlotCount();
 
   // Skip callee-saved and return slots, which are pushed below.
-  required_slots -= base::bits::CountPopulation(saves);
+  required_slots -= saves.Count();
   required_slots -= base::bits::CountPopulation(saves_fpu);
   required_slots -= returns;
   if (required_slots > 0) {
@@ -4261,7 +4261,7 @@ void CodeGenerator::AssembleConstructFrame() {
     DCHECK_EQ(kNumCalleeSavedFPU, base::bits::CountPopulation(saves_fpu));
   }
 
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     // Save callee-saved registers.
     __ MultiPush(saves);
   }
@@ -4282,12 +4282,12 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // Restore GP registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ MultiPop(saves);
   }
 
   // Restore FPU registers.
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     __ MultiPopFPU(saves_fpu);
   }
diff --git a/src/compiler/backend/ppc/code-generator-ppc.cc b/src/compiler/backend/ppc/code-generator-ppc.cc
index 9ee86cbaec..c4232e31d2 100644
--- a/src/compiler/backend/ppc/code-generator-ppc.cc
+++ b/src/compiler/backend/ppc/code-generator-ppc.cc
@@ -3983,10 +3983,10 @@ void CodeGenerator::AssembleArchSelect(Instruction* instr,
 
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
-  const RegList double_saves = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList double_saves = call_descriptor->CalleeSavedFPRegisters();
 
   // Save callee-saved Double registers.
-  if (double_saves != 0) {
+  if (double_ !saves.is_empty()) {
     frame->AlignSavedCalleeRegisterSlots();
     DCHECK_EQ(kNumCalleeSavedDoubles,
               base::bits::CountPopulation(double_saves));
@@ -3994,11 +3994,11 @@ void CodeGenerator::FinishFrame(Frame* frame) {
                                             (kDoubleSize / kSystemPointerSize));
   }
   // Save callee-saved registers.
-  const RegList saves = FLAG_enable_embedded_constant_pool
-                            ? call_descriptor->CalleeSavedRegisters() &
-                                  ~kConstantPoolRegister.bit()
-                            : call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  const RegList saves =
+      FLAG_enable_embedded_constant_pool
+          ? call_descriptor->CalleeSavedRegisters() - kConstantPoolRegister
+          : call_descriptor->CalleeSavedRegisters();
+  if (!saves.is_empty()) {
     // register save area does not include the fp or constant pool pointer.
     const int num_saves =
         kNumCalleeSaved - 1 - (FLAG_enable_embedded_constant_pool ? 1 : 0);
@@ -4068,11 +4068,11 @@ void CodeGenerator::AssembleConstructFrame() {
     required_slots -= osr_helper()->UnoptimizedFrameSlots();
   }
 
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
-  const RegList saves = FLAG_enable_embedded_constant_pool
-                            ? call_descriptor->CalleeSavedRegisters() &
-                                  ~kConstantPoolRegister.bit()
-                            : call_descriptor->CalleeSavedRegisters();
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  const RegList saves =
+      FLAG_enable_embedded_constant_pool
+          ? call_descriptor->CalleeSavedRegisters() - kConstantPoolRegister
+          : call_descriptor->CalleeSavedRegisters();
 
   if (required_slots > 0) {
 #if V8_ENABLE_WEBASSEMBLY
@@ -4112,21 +4112,20 @@ void CodeGenerator::AssembleConstructFrame() {
 #endif  // V8_ENABLE_WEBASSEMBLY
 
     // Skip callee-saved and return slots, which are pushed below.
-    required_slots -= base::bits::CountPopulation(saves);
+    required_slots -= saves.Count();
     required_slots -= frame()->GetReturnSlotCount();
-    required_slots -= (kDoubleSize / kSystemPointerSize) *
-                      base::bits::CountPopulation(saves_fp);
+    required_slots -= (kDoubleSize / kSystemPointerSize) * saves_fp.Count();
     __ AddS64(sp, sp, Operand(-required_slots * kSystemPointerSize), r0);
   }
 
   // Save callee-saved Double registers.
-  if (saves_fp != 0) {
+  if (!saves_fp.is_empty()) {
     __ MultiPushDoubles(saves_fp);
-    DCHECK_EQ(kNumCalleeSavedDoubles, base::bits::CountPopulation(saves_fp));
+    DCHECK_EQ(kNumCalleeSavedDoubles, saves_fp.Count());
   }
 
   // Save callee-saved registers.
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ MultiPush(saves);
     // register save area does not include the fp or constant pool pointer.
   }
@@ -4146,24 +4145,24 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
   }
 
   // Restore registers.
-  const RegList saves = FLAG_enable_embedded_constant_pool
-                            ? call_descriptor->CalleeSavedRegisters() &
-                                  ~kConstantPoolRegister.bit()
-                            : call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  const RegList saves =
+      FLAG_enable_embedded_constant_pool
+          ? call_descriptor->CalleeSavedRegisters() - kConstantPoolRegister
+          : call_descriptor->CalleeSavedRegisters();
+  if (!saves.is_empty()) {
     __ MultiPop(saves);
   }
 
   // Restore double registers.
-  const RegList double_saves = call_descriptor->CalleeSavedFPRegisters();
-  if (double_saves != 0) {
+  const DoubleRegList double_saves = call_descriptor->CalleeSavedFPRegisters();
+  if (double_ !saves.is_empty()) {
     __ MultiPopDoubles(double_saves);
   }
 
   unwinding_info_writer_.MarkBlockWillExit();
 
   // We might need r6 for scratch.
-  DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & r6.bit());
+  DCHECK(!call_descriptor->CalleeSavedRegisters().has(r6));
   PPCOperandConverter g(this, nullptr);
   const int parameter_slots =
       static_cast<int>(call_descriptor->ParameterSlotCount());
@@ -4204,7 +4203,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     }
     if (drop_jsargs) {
       // Get the actual argument count.
-      DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+      DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
       __ LoadU64(argc_reg, MemOperand(fp, StandardFrameConstants::kArgCOffset));
     }
     AssembleDeconstructFrame();
diff --git a/src/compiler/backend/riscv64/code-generator-riscv64.cc b/src/compiler/backend/riscv64/code-generator-riscv64.cc
index c170035ac4..051aa9c77a 100644
--- a/src/compiler/backend/riscv64/code-generator-riscv64.cc
+++ b/src/compiler/backend/riscv64/code-generator-riscv64.cc
@@ -3850,7 +3850,7 @@ void CodeGenerator::AssembleArchTableSwitch(Instruction* instr) {
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
 
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     int count = base::bits::CountPopulation(saves_fpu);
     DCHECK_EQ(kNumCalleeSavedFPU, count);
@@ -3859,8 +3859,8 @@ void CodeGenerator::FinishFrame(Frame* frame) {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
-    int count = base::bits::CountPopulation(saves);
+  if (!saves.is_empty()) {
+    int count = saves.Count();
     frame->AllocateSavedCalleeRegisterSlots(count);
   }
 }
@@ -3911,7 +3911,7 @@ void CodeGenerator::AssembleConstructFrame() {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
 
   if (required_slots > 0) {
     DCHECK(frame_access_state()->has_frame());
@@ -3951,7 +3951,7 @@ void CodeGenerator::AssembleConstructFrame() {
   const int returns = frame()->GetReturnSlotCount();
 
   // Skip callee-saved and return slots, which are pushed below.
-  required_slots -= base::bits::CountPopulation(saves);
+  required_slots -= saves.Count();
   required_slots -= base::bits::CountPopulation(saves_fpu);
   required_slots -= returns;
   if (required_slots > 0) {
@@ -3964,7 +3964,7 @@ void CodeGenerator::AssembleConstructFrame() {
     DCHECK_EQ(kNumCalleeSavedFPU, base::bits::CountPopulation(saves_fpu));
   }
 
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     // Save callee-saved registers.
     __ MultiPush(saves);
   }
@@ -3985,12 +3985,12 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // Restore GP registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ MultiPop(saves);
   }
 
   // Restore FPU registers.
-  const RegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fpu = call_descriptor->CalleeSavedFPRegisters();
   if (saves_fpu != 0) {
     __ MultiPopFPU(saves_fpu);
   }
diff --git a/src/compiler/backend/s390/code-generator-s390.cc b/src/compiler/backend/s390/code-generator-s390.cc
index 078b3ece14..e84155334c 100644
--- a/src/compiler/backend/s390/code-generator-s390.cc
+++ b/src/compiler/backend/s390/code-generator-s390.cc
@@ -3359,10 +3359,10 @@ void CodeGenerator::AssembleArchSelect(Instruction* instr,
 
 void CodeGenerator::FinishFrame(Frame* frame) {
   auto call_descriptor = linkage()->GetIncomingDescriptor();
-  const RegList double_saves = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList double_saves = call_descriptor->CalleeSavedFPRegisters();
 
   // Save callee-saved Double registers.
-  if (double_saves != 0) {
+  if (double_ !saves.is_empty()) {
     frame->AlignSavedCalleeRegisterSlots();
     DCHECK_EQ(kNumCalleeSavedDoubles,
               base::bits::CountPopulation(double_saves));
@@ -3371,7 +3371,7 @@ void CodeGenerator::FinishFrame(Frame* frame) {
   }
   // Save callee-saved registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     // register save area does not include the fp or constant pool pointer.
     const int num_saves = kNumCalleeSaved - 1;
     frame->AllocateSavedCalleeRegisterSlots(num_saves);
@@ -3433,7 +3433,7 @@ void CodeGenerator::AssembleConstructFrame() {
     required_slots -= osr_helper()->UnoptimizedFrameSlots();
   }
 
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
   const RegList saves = call_descriptor->CalleeSavedRegisters();
 
   if (required_slots > 0) {
@@ -3473,21 +3473,20 @@ void CodeGenerator::AssembleConstructFrame() {
 #endif  // V8_ENABLE_WEBASSEMBLY
 
     // Skip callee-saved and return slots, which are pushed below.
-    required_slots -= base::bits::CountPopulation(saves);
+    required_slots -= saves.Count();
     required_slots -= frame()->GetReturnSlotCount();
-    required_slots -= (kDoubleSize / kSystemPointerSize) *
-                      base::bits::CountPopulation(saves_fp);
+    required_slots -= (kDoubleSize / kSystemPointerSize) * saves_fp.Count();
     __ lay(sp, MemOperand(sp, -required_slots * kSystemPointerSize));
   }
 
   // Save callee-saved Double registers.
-  if (saves_fp != 0) {
+  if (!saves_fp.is_empty()) {
     __ MultiPushDoubles(saves_fp);
-    DCHECK_EQ(kNumCalleeSavedDoubles, base::bits::CountPopulation(saves_fp));
+    DCHECK_EQ(kNumCalleeSavedDoubles, saves_fp.Count());
   }
 
   // Save callee-saved registers.
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ MultiPush(saves);
     // register save area does not include the fp or constant pool pointer.
   }
@@ -3508,20 +3507,20 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // Restore registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     __ MultiPop(saves);
   }
 
   // Restore double registers.
-  const RegList double_saves = call_descriptor->CalleeSavedFPRegisters();
-  if (double_saves != 0) {
+  const DoubleRegList double_saves = call_descriptor->CalleeSavedFPRegisters();
+  if (double_ !saves.is_empty()) {
     __ MultiPopDoubles(double_saves);
   }
 
   unwinding_info_writer_.MarkBlockWillExit();
 
   // We might need r3 for scratch.
-  DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & r5.bit());
+  DCHECK(!call_descriptor->CalleeSavedRegisters().has(r5));
   S390OperandConverter g(this, nullptr);
   const int parameter_slots =
       static_cast<int>(call_descriptor->ParameterSlotCount());
@@ -3562,7 +3561,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     }
     if (drop_jsargs) {
       // Get the actual argument count.
-      DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+      DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
       __ LoadU64(argc_reg, MemOperand(fp, StandardFrameConstants::kArgCOffset));
     }
     AssembleDeconstructFrame();
diff --git a/src/compiler/backend/x64/code-generator-x64.cc b/src/compiler/backend/x64/code-generator-x64.cc
index 29c5946343..949fc1ad43 100644
--- a/src/compiler/backend/x64/code-generator-x64.cc
+++ b/src/compiler/backend/x64/code-generator-x64.cc
@@ -1076,8 +1076,9 @@ void AdjustStackPointerForTailCall(Instruction* instr,
     // value before frame construction.
     // See also: AssembleConstructFrame.
     DCHECK(!info->is_osr());
-    DCHECK_EQ(linkage->GetIncomingDescriptor()->CalleeSavedRegisters(), 0);
-    DCHECK_EQ(linkage->GetIncomingDescriptor()->CalleeSavedFPRegisters(), 0);
+    DCHECK(linkage->GetIncomingDescriptor()->CalleeSavedRegisters().is_empty());
+    DCHECK(
+        linkage->GetIncomingDescriptor()->CalleeSavedFPRegisters().is_empty());
     DCHECK_EQ(state->frame()->GetReturnSlotCount(), 0);
     stack_slot_delta = (state->frame()->GetTotalFrameSlotCount() -
                         kReturnAddressStackSlotCount) *
@@ -4580,22 +4581,16 @@ static const int kQuadWordSize = 16;
 void CodeGenerator::FinishFrame(Frame* frame) {
   CallDescriptor* call_descriptor = linkage()->GetIncomingDescriptor();
 
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
-  if (saves_fp != 0) {  // Save callee-saved XMM registers.
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  if (!saves_fp.is_empty()) {  // Save callee-saved XMM registers.
     frame->AlignSavedCalleeRegisterSlots();
-    const uint32_t saves_fp_count = base::bits::CountPopulation(saves_fp);
+    const uint32_t saves_fp_count = saves_fp.Count();
     frame->AllocateSavedCalleeRegisterSlots(
         saves_fp_count * (kQuadWordSize / kSystemPointerSize));
   }
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {  // Save callee-saved registers.
-    int count = 0;
-    for (int i = Register::kNumRegisters - 1; i >= 0; i--) {
-      if (((1 << i) & saves)) {
-        ++count;
-      }
-    }
-    frame->AllocateSavedCalleeRegisterSlots(count);
+  if (!saves.is_empty()) {  // Save callee-saved registers.
+    frame->AllocateSavedCalleeRegisterSlots(saves.Count());
   }
 }
 
@@ -4654,7 +4649,7 @@ void CodeGenerator::AssembleConstructFrame() {
   }
 
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
 
   if (required_slots > 0) {
     DCHECK(frame_access_state()->has_frame());
@@ -4692,34 +4687,30 @@ void CodeGenerator::AssembleConstructFrame() {
 #endif  // V8_ENABLE_WEBASSEMBLY
 
     // Skip callee-saved and return slots, which are created below.
-    required_slots -= base::bits::CountPopulation(saves);
-    required_slots -= base::bits::CountPopulation(saves_fp) *
-                      (kQuadWordSize / kSystemPointerSize);
+    required_slots -= saves.Count();
+    required_slots -= saves_fp.Count() * (kQuadWordSize / kSystemPointerSize);
     required_slots -= frame()->GetReturnSlotCount();
     if (required_slots > 0) {
       __ AllocateStackSpace(required_slots * kSystemPointerSize);
     }
   }
 
-  if (saves_fp != 0) {  // Save callee-saved XMM registers.
-    const uint32_t saves_fp_count = base::bits::CountPopulation(saves_fp);
+  if (!saves_fp.is_empty()) {  // Save callee-saved XMM registers.
+    const uint32_t saves_fp_count = saves_fp.Count();
     const int stack_size = saves_fp_count * kQuadWordSize;
     // Adjust the stack pointer.
     __ AllocateStackSpace(stack_size);
     // Store the registers on the stack.
     int slot_idx = 0;
-    for (int i = 0; i < XMMRegister::kNumRegisters; i++) {
-      if (!((1 << i) & saves_fp)) continue;
-      __ Movdqu(Operand(rsp, kQuadWordSize * slot_idx),
-                XMMRegister::from_code(i));
+    for (XMMRegister reg : saves_fp) {
+      __ Movdqu(Operand(rsp, kQuadWordSize * slot_idx), reg);
       slot_idx++;
     }
   }
 
-  if (saves != 0) {  // Save callee-saved registers.
-    for (int i = Register::kNumRegisters - 1; i >= 0; i--) {
-      if (!((1 << i) & saves)) continue;
-      __ pushq(Register::from_code(i));
+  if (!saves.is_empty()) {  // Save callee-saved registers.
+    for (Register reg : base::Reversed(saves)) {
+      __ pushq(reg);
     }
   }
 
@@ -4734,26 +4725,23 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
 
   // Restore registers.
   const RegList saves = call_descriptor->CalleeSavedRegisters();
-  if (saves != 0) {
+  if (!saves.is_empty()) {
     const int returns = frame()->GetReturnSlotCount();
     if (returns != 0) {
       __ addq(rsp, Immediate(returns * kSystemPointerSize));
     }
-    for (int i = 0; i < Register::kNumRegisters; i++) {
-      if (!((1 << i) & saves)) continue;
-      __ popq(Register::from_code(i));
+    for (Register reg : saves) {
+      __ popq(reg);
     }
   }
-  const RegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
-  if (saves_fp != 0) {
-    const uint32_t saves_fp_count = base::bits::CountPopulation(saves_fp);
+  const DoubleRegList saves_fp = call_descriptor->CalleeSavedFPRegisters();
+  if (!saves_fp.is_empty()) {
+    const uint32_t saves_fp_count = saves_fp.Count();
     const int stack_size = saves_fp_count * kQuadWordSize;
     // Load the registers from the stack.
     int slot_idx = 0;
-    for (int i = 0; i < XMMRegister::kNumRegisters; i++) {
-      if (!((1 << i) & saves_fp)) continue;
-      __ Movdqu(XMMRegister::from_code(i),
-                Operand(rsp, kQuadWordSize * slot_idx));
+    for (XMMRegister reg : saves_fp) {
+      __ Movdqu(reg, Operand(rsp, kQuadWordSize * slot_idx));
       slot_idx++;
     }
     // Adjust the stack pointer.
@@ -4799,7 +4787,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     }
     if (drop_jsargs) {
       // Get the actual argument count.
-      DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+      DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
       __ movq(argc_reg, Operand(rbp, StandardFrameConstants::kArgCOffset));
     }
     AssembleDeconstructFrame();
@@ -4813,8 +4801,8 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     Label mismatch_return;
     Register scratch_reg = r10;
     DCHECK_NE(argc_reg, scratch_reg);
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & scratch_reg.bit());
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & argc_reg.bit());
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(scratch_reg));
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(argc_reg));
     __ cmpq(argc_reg, Immediate(parameter_slots));
     __ j(greater, &mismatch_return, Label::kNear);
     __ Ret(parameter_slots * kSystemPointerSize, scratch_reg);
@@ -4825,7 +4813,7 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
     __ Ret();
   } else if (additional_pop_count->IsImmediate()) {
     Register scratch_reg = r10;
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & scratch_reg.bit());
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(scratch_reg));
     int additional_count = g.ToConstant(additional_pop_count).ToInt32();
     size_t pop_size = (parameter_slots + additional_count) * kSystemPointerSize;
     CHECK_LE(pop_size, static_cast<size_t>(std::numeric_limits<int>::max()));
@@ -4833,8 +4821,8 @@ void CodeGenerator::AssembleReturn(InstructionOperand* additional_pop_count) {
   } else {
     Register pop_reg = g.ToRegister(additional_pop_count);
     Register scratch_reg = pop_reg == r10 ? rcx : r10;
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & scratch_reg.bit());
-    DCHECK_EQ(0u, call_descriptor->CalleeSavedRegisters() & pop_reg.bit());
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(scratch_reg));
+    DCHECK(!call_descriptor->CalleeSavedRegisters().has(pop_reg));
     int pop_size = static_cast<int>(parameter_slots * kSystemPointerSize);
     __ PopReturnAddressTo(scratch_reg);
     __ leaq(rsp, Operand(rsp, pop_reg, times_system_pointer_size,
diff --git a/src/compiler/c-linkage.cc b/src/compiler/c-linkage.cc
index 95a84ceeab..951550c4a5 100644
--- a/src/compiler/c-linkage.cc
+++ b/src/compiler/c-linkage.cc
@@ -19,7 +19,8 @@ namespace {
 // ===========================================================================
 // == ia32 ===================================================================
 // ===========================================================================
-#define CALLEE_SAVE_REGISTERS esi.bit() | edi.bit() | ebx.bit()
+#define CALLEE_SAVE_REGISTERS esi, edi, ebx
+#define CALLEE_SAVE_FP_REGISTERS
 
 #elif V8_TARGET_ARCH_X64
 // ===========================================================================
@@ -32,21 +33,17 @@ namespace {
 #define PARAM_REGISTERS rcx, rdx, r8, r9
 #define FP_PARAM_REGISTERS xmm0, xmm1, xmm2, xmm3
 #define FP_RETURN_REGISTER xmm0
-#define CALLEE_SAVE_REGISTERS                                             \
-  rbx.bit() | rdi.bit() | rsi.bit() | r12.bit() | r13.bit() | r14.bit() | \
-      r15.bit()
-#define CALLEE_SAVE_FP_REGISTERS                                        \
-  (1 << xmm6.code()) | (1 << xmm7.code()) | (1 << xmm8.code()) |        \
-      (1 << xmm9.code()) | (1 << xmm10.code()) | (1 << xmm11.code()) |  \
-      (1 << xmm12.code()) | (1 << xmm13.code()) | (1 << xmm14.code()) | \
-      (1 << xmm15.code())
+#define CALLEE_SAVE_REGISTERS rbx, rdi, rsi, r12, r13, r14, r15
+#define CALLEE_SAVE_FP_REGISTERS \
+  xmm6, xmm7, xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15
+
 #else  // V8_TARGET_OS_WIN
 // == x64 other ==============================================================
 #define PARAM_REGISTERS rdi, rsi, rdx, rcx, r8, r9
 #define FP_PARAM_REGISTERS xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7
 #define FP_RETURN_REGISTER xmm0
-#define CALLEE_SAVE_REGISTERS \
-  rbx.bit() | r12.bit() | r13.bit() | r14.bit() | r15.bit()
+#define CALLEE_SAVE_REGISTERS rbx, r12, r13, r14, r15
+#define CALLEE_SAVE_FP_REGISTERS
 #endif  // V8_TARGET_OS_WIN
 
 #elif V8_TARGET_ARCH_ARM
@@ -54,12 +51,8 @@ namespace {
 // == arm ====================================================================
 // ===========================================================================
 #define PARAM_REGISTERS r0, r1, r2, r3
-#define CALLEE_SAVE_REGISTERS \
-  r4.bit() | r5.bit() | r6.bit() | r7.bit() | r8.bit() | r9.bit() | r10.bit()
-#define CALLEE_SAVE_FP_REGISTERS                                  \
-  (1 << d8.code()) | (1 << d9.code()) | (1 << d10.code()) |       \
-      (1 << d11.code()) | (1 << d12.code()) | (1 << d13.code()) | \
-      (1 << d14.code()) | (1 << d15.code())
+#define CALLEE_SAVE_REGISTERS r4, r5, r6, r7, r8, r9, r10
+#define CALLEE_SAVE_FP_REGISTERS d8, d9, d10, d11, d12, d13, d14, d15
 
 #elif V8_TARGET_ARCH_ARM64
 // ===========================================================================
@@ -68,16 +61,9 @@ namespace {
 #define PARAM_REGISTERS x0, x1, x2, x3, x4, x5, x6, x7
 #define FP_PARAM_REGISTERS d0, d1, d2, d3, d4, d5, d6, d7
 #define FP_RETURN_REGISTER d0
-#define CALLEE_SAVE_REGISTERS                                     \
-  (1 << x19.code()) | (1 << x20.code()) | (1 << x21.code()) |     \
-      (1 << x22.code()) | (1 << x23.code()) | (1 << x24.code()) | \
-      (1 << x25.code()) | (1 << x26.code()) | (1 << x27.code()) | \
-      (1 << x28.code())
+#define CALLEE_SAVE_REGISTERS x19, x20, x21, x22, x23, x24, x25, x26, x27, x28
 
-#define CALLEE_SAVE_FP_REGISTERS                                  \
-  (1 << d8.code()) | (1 << d9.code()) | (1 << d10.code()) |       \
-      (1 << d11.code()) | (1 << d12.code()) | (1 << d13.code()) | \
-      (1 << d14.code()) | (1 << d15.code())
+#define CALLEE_SAVE_FP_REGISTERS d8, d9, d10, d11, d12, d13, d14, d15
 
 #elif V8_TARGET_ARCH_MIPS
 // ===========================================================================
@@ -85,34 +71,24 @@ namespace {
 // ===========================================================================
 #define STACK_SHADOW_WORDS 4
 #define PARAM_REGISTERS a0, a1, a2, a3
-#define CALLEE_SAVE_REGISTERS                                                  \
-  s0.bit() | s1.bit() | s2.bit() | s3.bit() | s4.bit() | s5.bit() | s6.bit() | \
-      s7.bit()
-#define CALLEE_SAVE_FP_REGISTERS \
-  f20.bit() | f22.bit() | f24.bit() | f26.bit() | f28.bit() | f30.bit()
+#define CALLEE_SAVE_REGISTERS s0, s1, s2, s3, s4, s5, s6, s7
+#define CALLEE_SAVE_FP_REGISTERS f20, f22, f24, f26, f28, f30
 
 #elif V8_TARGET_ARCH_MIPS64
 // ===========================================================================
 // == mips64 =================================================================
 // ===========================================================================
 #define PARAM_REGISTERS a0, a1, a2, a3, a4, a5, a6, a7
-#define CALLEE_SAVE_REGISTERS                                                  \
-  s0.bit() | s1.bit() | s2.bit() | s3.bit() | s4.bit() | s5.bit() | s6.bit() | \
-      s7.bit()
-#define CALLEE_SAVE_FP_REGISTERS \
-  f20.bit() | f22.bit() | f24.bit() | f26.bit() | f28.bit() | f30.bit()
+#define CALLEE_SAVE_REGISTERS s0, s1, s2, s3, s4, s5, s6, s7
+#define CALLEE_SAVE_FP_REGISTERS f20, f22, f24, f26, f28, f30
 
 #elif V8_TARGET_ARCH_LOONG64
 // ===========================================================================
 // == loong64 ================================================================
 // ===========================================================================
 #define PARAM_REGISTERS a0, a1, a2, a3, a4, a5, a6, a7
-#define CALLEE_SAVE_REGISTERS                                                  \
-  s0.bit() | s1.bit() | s2.bit() | s3.bit() | s4.bit() | s5.bit() | s6.bit() | \
-      s7.bit() | s8.bit() | fp.bit()
-#define CALLEE_SAVE_FP_REGISTERS                                          \
-  f24.bit() | f25.bit() | f26.bit() | f27.bit() | f28.bit() | f29.bit() | \
-      f30.bit() | f31.bit()
+#define CALLEE_SAVE_REGISTERS s0, s1, s2, s3, s4, s5, s6, s7, s8, fp
+#define CALLEE_SAVE_FP_REGISTERS f24, f25, f26, f27, f28, f29, f30, f31
 
 #elif V8_TARGET_ARCH_PPC64
 // ===========================================================================
@@ -124,14 +100,13 @@ namespace {
 #define STACK_SHADOW_WORDS 14
 #endif
 #define PARAM_REGISTERS r3, r4, r5, r6, r7, r8, r9, r10
-#define CALLEE_SAVE_REGISTERS                                                 \
-  r14.bit() | r15.bit() | r16.bit() | r17.bit() | r18.bit() | r19.bit() |     \
-      r20.bit() | r21.bit() | r22.bit() | r23.bit() | r24.bit() | r25.bit() | \
-      r26.bit() | r27.bit() | r28.bit() | r29.bit() | r30.bit()
-#define CALLEE_SAVE_FP_REGISTERS                                              \
-  d14.bit() | d15.bit() | d16.bit() | d17.bit() | d18.bit() | d19.bit() |     \
-      d20.bit() | d21.bit() | d22.bit() | d23.bit() | d24.bit() | d25.bit() | \
-      d26.bit() | d27.bit() | d28.bit() | d29.bit() | d30.bit() | d31.bit()
+#define CALLEE_SAVE_REGISTERS                                                \
+  r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, \
+      r29, r30
+
+#define CALLEE_SAVE_FP_REGISTERS                                             \
+  d14, d15, d16, d17, d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, \
+      d29, d30, d31
 
 #elif V8_TARGET_ARCH_S390X
 // ===========================================================================
@@ -139,11 +114,8 @@ namespace {
 // ===========================================================================
 #define STACK_SHADOW_WORDS 20
 #define PARAM_REGISTERS r2, r3, r4, r5, r6
-#define CALLEE_SAVE_REGISTERS \
-  r6.bit() | r7.bit() | r8.bit() | r9.bit() | r10.bit() | ip.bit() | r13.bit()
-#define CALLEE_SAVE_FP_REGISTERS                                        \
-  d8.bit() | d9.bit() | d10.bit() | d11.bit() | d12.bit() | d13.bit() | \
-      d14.bit() | d15.bit()
+#define CALLEE_SAVE_REGISTERS r6, r7, r8, r9, r10, ip, r13
+#define CALLEE_SAVE_FP_REGISTERS d8, d9, d10, d11, d12, d13, d14, d15
 
 #elif V8_TARGET_ARCH_RISCV64
 // ===========================================================================
@@ -152,12 +124,9 @@ namespace {
 #define PARAM_REGISTERS a0, a1, a2, a3, a4, a5, a6, a7
 // fp is not part of CALLEE_SAVE_REGISTERS (similar to how MIPS64 or PPC defines
 // it)
-#define CALLEE_SAVE_REGISTERS                                                  \
-  s1.bit() | s2.bit() | s3.bit() | s4.bit() | s5.bit() | s6.bit() | s7.bit() | \
-      s8.bit() | s9.bit() | s10.bit() | s11.bit()
-#define CALLEE_SAVE_FP_REGISTERS                                          \
-  fs0.bit() | fs1.bit() | fs2.bit() | fs3.bit() | fs4.bit() | fs5.bit() | \
-      fs6.bit() | fs7.bit() | fs8.bit() | fs9.bit() | fs10.bit() | fs11.bit()
+#define CALLEE_SAVE_REGISTERS s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11
+#define CALLEE_SAVE_FP_REGISTERS \
+  fs0, fs1, fs2, fs3, fs4, fs5, fs6, fs7, fs8, fs9, fs10, fs11
 #else
 // ===========================================================================
 // == unknown ================================================================
@@ -318,17 +287,8 @@ CallDescriptor* Linkage::GetSimplifiedCDescriptor(Zone* zone,
   BuildParameterLocations(msig, kFPParamRegisterCount, kParamRegisterCount,
                           kFPParamRegisters, kParamRegisters, &locations);
 
-#ifdef CALLEE_SAVE_REGISTERS
-  const RegList kCalleeSaveRegisters = CALLEE_SAVE_REGISTERS;
-#else
-  const RegList kCalleeSaveRegisters = 0;
-#endif
-
-#ifdef CALLEE_SAVE_FP_REGISTERS
-  const RegList kCalleeSaveFPRegisters = CALLEE_SAVE_FP_REGISTERS;
-#else
-  const RegList kCalleeSaveFPRegisters = 0;
-#endif
+  const RegList kCalleeSaveRegisters = {CALLEE_SAVE_REGISTERS};
+  const DoubleRegList kCalleeSaveFPRegisters = {CALLEE_SAVE_FP_REGISTERS};
 
   // The target for C calls is always an address (i.e. machine pointer).
   MachineType target_type = MachineType::Pointer();
diff --git a/src/compiler/linkage.cc b/src/compiler/linkage.cc
index bd62f24600..f5bf0cbb44 100644
--- a/src/compiler/linkage.cc
+++ b/src/compiler/linkage.cc
@@ -372,7 +372,7 @@ CallDescriptor* Linkage::GetCEntryStubCallDescriptor(
       js_parameter_count,               // stack_parameter_count
       properties,                       // properties
       kNoCalleeSaved,                   // callee-saved
-      kNoCalleeSaved,                   // callee-saved fp
+      kNoCalleeSavedFp,                 // callee-saved fp
       flags,                            // flags
       debug_name,                       // debug name
       stack_order);                     // stack order
@@ -426,7 +426,7 @@ CallDescriptor* Linkage::GetJSCallDescriptor(Zone* zone, bool is_osr,
       js_parameter_count,               // stack_parameter_count
       Operator::kNoProperties,          // properties
       kNoCalleeSaved,                   // callee-saved
-      kNoCalleeSaved,                   // callee-saved fp
+      kNoCalleeSavedFp,                 // callee-saved fp
       flags,                            // flags
       "js-call");                       // debug name
 }
@@ -522,7 +522,7 @@ CallDescriptor* Linkage::GetStubCallDescriptor(
   RegList callee_saved_registers = kNoCalleeSaved;
   if (descriptor.CalleeSaveRegisters()) {
     callee_saved_registers = allocatable_registers;
-    DCHECK(callee_saved_registers);
+    DCHECK(!callee_saved_registers.is_empty());
   }
   LinkageLocation target_loc = LinkageLocation::ForAnyRegister(target_type);
   return zone->New<CallDescriptor>(          // --
@@ -533,7 +533,7 @@ CallDescriptor* Linkage::GetStubCallDescriptor(
       stack_parameter_count,                 // stack_parameter_count
       properties,                            // properties
       callee_saved_registers,                // callee-saved registers
-      kNoCalleeSaved,                        // callee-saved fp
+      kNoCalleeSavedFp,                      // callee-saved fp
       CallDescriptor::kCanUseRoots | flags,  // flags
       descriptor.DebugName(),                // debug name
       descriptor.GetStackArgumentOrder(),    // stack order
@@ -583,7 +583,7 @@ CallDescriptor* Linkage::GetBytecodeDispatchCallDescriptor(
       stack_parameter_count,         // stack_parameter_count
       Operator::kNoProperties,       // properties
       kNoCalleeSaved,                // callee-saved registers
-      kNoCalleeSaved,                // callee-saved fp
+      kNoCalleeSavedFp,              // callee-saved fp
       kFlags,                        // flags
       descriptor.DebugName());
 }
diff --git a/src/compiler/linkage.h b/src/compiler/linkage.h
index 8c2238f850..0a96cc8b73 100644
--- a/src/compiler/linkage.h
+++ b/src/compiler/linkage.h
@@ -36,7 +36,8 @@ class OptimizedCompilationInfo;
 
 namespace compiler {
 
-const RegList kNoCalleeSaved = 0;
+constexpr RegList kNoCalleeSaved;
+constexpr DoubleRegList kNoCalleeSavedFp;
 
 class OsrHelper;
 
@@ -253,13 +254,13 @@ class V8_EXPORT_PRIVATE CallDescriptor final
                  LocationSignature* location_sig, size_t param_slot_count,
                  Operator::Properties properties,
                  RegList callee_saved_registers,
-                 RegList callee_saved_fp_registers, Flags flags,
+                 DoubleRegList callee_saved_fp_registers, Flags flags,
                  const char* debug_name = "",
                  StackArgumentOrder stack_order = StackArgumentOrder::kDefault,
 #if V8_ENABLE_WEBASSEMBLY
                  const wasm::FunctionSig* wasm_sig = nullptr,
 #endif
-                 const RegList allocatable_registers = 0,
+                 const RegList allocatable_registers = {},
                  size_t return_slot_count = 0)
       : kind_(kind),
         target_type_(target_type),
@@ -414,7 +415,9 @@ class V8_EXPORT_PRIVATE CallDescriptor final
   RegList CalleeSavedRegisters() const { return callee_saved_registers_; }
 
   // Get the callee-saved FP registers, if any, across this call.
-  RegList CalleeSavedFPRegisters() const { return callee_saved_fp_registers_; }
+  DoubleRegList CalleeSavedFPRegisters() const {
+    return callee_saved_fp_registers_;
+  }
 
   const char* debug_name() const { return debug_name_; }
 
@@ -443,7 +446,7 @@ class V8_EXPORT_PRIVATE CallDescriptor final
   RegList AllocatableRegisters() const { return allocatable_registers_; }
 
   bool HasRestrictedAllocatableRegisters() const {
-    return allocatable_registers_ != 0;
+    return !allocatable_registers_.is_empty();
   }
 
   EncodedCSignature ToEncodedCSignature() const;
@@ -461,7 +464,7 @@ class V8_EXPORT_PRIVATE CallDescriptor final
   const size_t return_slot_count_;
   const Operator::Properties properties_;
   const RegList callee_saved_registers_;
-  const RegList callee_saved_fp_registers_;
+  const DoubleRegList callee_saved_fp_registers_;
   // Non-zero value means restricting the set of allocatable registers for
   // register allocator to use.
   const RegList allocatable_registers_;
diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index 9f9991772d..346cf9db05 100644
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -503,7 +503,7 @@ class PipelineData {
     if (call_descriptor && call_descriptor->RequiresFrameAsIncoming()) {
       sequence_->instruction_blocks()[0]->mark_needs_frame();
     } else {
-      DCHECK_EQ(0u, call_descriptor->CalleeSavedFPRegisters());
+      DCHECK(call_descriptor->CalleeSavedFPRegisters().is_empty());
     }
   }
 
@@ -3474,7 +3474,7 @@ bool PipelineImpl::SelectInstructions(Linkage* linkage) {
 
   if (call_descriptor->HasRestrictedAllocatableRegisters()) {
     RegList registers = call_descriptor->AllocatableRegisters();
-    DCHECK_LT(0, NumRegs(registers));
+    DCHECK_LT(0, registers.Count());
     restricted_config.reset(
         RegisterConfiguration::RestrictGeneralRegisters(registers));
     config = restricted_config.get();
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index ea68c83adc..87e7a63429 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -8606,8 +8606,8 @@ CallDescriptor* GetWasmCallDescriptor(Zone* zone, const wasm::FunctionSig* fsig,
 
   int return_slots = rets.NumStackSlots();
 
-  const RegList kCalleeSaveRegisters = 0;
-  const RegList kCalleeSaveFPRegisters = 0;
+  const RegList kCalleeSaveRegisters;
+  const DoubleRegList kCalleeSaveFPRegisters;
 
   // The target for wasm calls is always a code object.
   MachineType target_type = MachineType::Pointer();
@@ -8639,7 +8639,7 @@ CallDescriptor* GetWasmCallDescriptor(Zone* zone, const wasm::FunctionSig* fsig,
       "wasm-call",                        // debug name
       StackArgumentOrder::kDefault,       // order of the arguments in the stack
       fsig,                               // signature
-      0,                                  // allocatable registers
+      RegList{},                          // allocatable registers
       return_slots);                      // return slot count
 }
 
diff --git a/src/execution/arm/frame-constants-arm.h b/src/execution/arm/frame-constants-arm.h
index 2e3b1ed665..46bff6230d 100644
--- a/src/execution/arm/frame-constants-arm.h
+++ b/src/execution/arm/frame-constants-arm.h
@@ -7,7 +7,7 @@
 
 #include "src/base/bits.h"
 #include "src/base/macros.h"
-#include "src/codegen/arm/register-arm.h"
+#include "src/codegen/register.h"
 #include "src/execution/frame-constants.h"
 
 namespace v8 {
@@ -77,17 +77,15 @@ class WasmCompileLazyFrameConstants : public TypedFrameConstants {
 class WasmDebugBreakFrameConstants : public TypedFrameConstants {
  public:
   // r10: root, r11: fp, r12: ip, r13: sp, r14: lr, r15: pc.
-  static constexpr RegList kPushedGpRegs =
-      Register::ListOf(r0, r1, r2, r3, r4, r5, r6, r7, r8, r9);
+  static constexpr RegList kPushedGpRegs = {r0, r1, r2, r3, r4,
+                                            r5, r6, r7, r8, r9};
 
   // d13: zero, d14-d15: scratch
-  static constexpr RegList kPushedFpRegs = LowDwVfpRegister::ListOf(
-      d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
+  static constexpr DoubleRegList kPushedFpRegs = {d0, d1, d2, d3,  d4,  d5, d6,
+                                                  d7, d8, d9, d10, d11, d12};
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -TypedFrameConstants::kFixedFrameSizeFromFp -
@@ -97,15 +95,17 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kDoubleSize;
   }
diff --git a/src/execution/arm64/frame-constants-arm64.h b/src/execution/arm64/frame-constants-arm64.h
index 8810586360..80bcda9de2 100644
--- a/src/execution/arm64/frame-constants-arm64.h
+++ b/src/execution/arm64/frame-constants-arm64.h
@@ -7,7 +7,6 @@
 
 #include "src/base/bits.h"
 #include "src/base/macros.h"
-#include "src/codegen/arm64/register-arm64.h"
 #include "src/codegen/register.h"
 #include "src/codegen/reglist.h"
 #include "src/common/globals.h"
@@ -98,23 +97,21 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
  public:
   // x16: ip0, x17: ip1, x18: platform register, x26: root, x28: base, x29: fp,
   // x30: lr, x31: xzr.
-  static constexpr RegList kPushedGpRegs = CPURegister::ListOf(
-      x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x19,
-      x20, x21, x22, x23, x24, x25, x27);
+  static constexpr RegList kPushedGpRegs = {
+      x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,  x8,  x9,  x10, x11,
+      x12, x13, x14, x15, x19, x20, x21, x22, x23, x24, x25, x27};
 
   // We push FpRegs as 128-bit SIMD registers, so 16-byte frame alignment
   // is guaranteed regardless of register count.
-  static constexpr RegList kPushedFpRegs = CPURegister::ListOf(
-      d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d16, d17,
-      d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, d29);
+  static constexpr DoubleRegList kPushedFpRegs = {
+      d0,  d1,  d2,  d3,  d4,  d5,  d6,  d7,  d8,  d9,  d10, d11, d12, d13, d14,
+      d16, d17, d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, d29};
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
   static_assert(kNumPushedGpRegisters % 2 == 0,
                 "stack frames need to be 16-byte aligned");
 
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       // Header is padded to 16 byte (see {MacroAssembler::EnterFrame}).
@@ -125,15 +122,17 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
diff --git a/src/execution/arm64/simulator-arm64.cc b/src/execution/arm64/simulator-arm64.cc
index d48789969e..6299cb2141 100644
--- a/src/execution/arm64/simulator-arm64.cc
+++ b/src/execution/arm64/simulator-arm64.cc
@@ -187,7 +187,7 @@ int PopLowestIndexAsCode(CPURegList* list) {
   if (list->IsEmpty()) {
     return -1;
   }
-  RegList reg_list = list->list();
+  uint64_t reg_list = list->bits();
   int index = base::bits::CountTrailingZeros(reg_list);
   DCHECK((1LL << index) & reg_list);
   list->Remove(index);
diff --git a/src/execution/ia32/frame-constants-ia32.h b/src/execution/ia32/frame-constants-ia32.h
index 45c7355979..0ad9f51e6e 100644
--- a/src/execution/ia32/frame-constants-ia32.h
+++ b/src/execution/ia32/frame-constants-ia32.h
@@ -7,7 +7,7 @@
 
 #include "src/base/bits.h"
 #include "src/base/macros.h"
-#include "src/codegen/ia32/register-ia32.h"
+#include "src/codegen/register.h"
 #include "src/execution/frame-constants.h"
 
 namespace v8 {
@@ -53,17 +53,14 @@ class WasmCompileLazyFrameConstants : public TypedFrameConstants {
 class WasmDebugBreakFrameConstants : public TypedFrameConstants {
  public:
   // Omit ebx, which is the root register.
-  static constexpr RegList kPushedGpRegs =
-      Register::ListOf(eax, ecx, edx, esi, edi);
+  static constexpr RegList kPushedGpRegs = {eax, ecx, edx, esi, edi};
 
   // Omit xmm7, which is the kScratchDoubleReg.
-  static constexpr RegList kPushedFpRegs =
-      DoubleRegister::ListOf(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6);
+  static constexpr DoubleRegList kPushedFpRegs = {xmm0, xmm1, xmm2, xmm3,
+                                                  xmm4, xmm5, xmm6};
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -kFixedFrameSizeFromFp - kNumPushedGpRegisters * kSystemPointerSize;
@@ -72,15 +69,17 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
diff --git a/src/execution/loong64/frame-constants-loong64.h b/src/execution/loong64/frame-constants-loong64.h
index 1395f47a7b..be347f7a1f 100644
--- a/src/execution/loong64/frame-constants-loong64.h
+++ b/src/execution/loong64/frame-constants-loong64.h
@@ -44,10 +44,8 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
   // {f0, f1, f2, ... f27, f28}
   static constexpr uint32_t kPushedFpRegs = 0x1fffffff;
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -kFixedFrameSizeFromFp - kNumPushedGpRegisters * kSystemPointerSize;
@@ -56,17 +54,19 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
-           base::bits::CountPopulation(lower_regs) * kDoubleSize;
+           base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
 };
 
diff --git a/src/execution/mips/frame-constants-mips.h b/src/execution/mips/frame-constants-mips.h
index 48704cf56a..23d74bb33f 100644
--- a/src/execution/mips/frame-constants-mips.h
+++ b/src/execution/mips/frame-constants-mips.h
@@ -49,10 +49,8 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
   // {f0, f2, f4, f6, f8, f10, f12, f14, f16, f18, f20, f22, f24}
   static constexpr uint32_t kPushedFpRegs = 0b1010101010101010101010101;
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -kFixedFrameSizeFromFp - kNumPushedGpRegisters * kSystemPointerSize;
@@ -61,17 +59,19 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
-           base::bits::CountPopulation(lower_regs) * kDoubleSize;
+           base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
 };
 
diff --git a/src/execution/mips64/frame-constants-mips64.h b/src/execution/mips64/frame-constants-mips64.h
index 40349ea8ec..7c519d72af 100644
--- a/src/execution/mips64/frame-constants-mips64.h
+++ b/src/execution/mips64/frame-constants-mips64.h
@@ -45,10 +45,8 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
   // {f0, f2, f4, f6, f8, f10, f12, f14, f16, f18, f20, f22, f24, f26}
   static constexpr uint32_t kPushedFpRegs = 0b101010101010101010101010101;
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -kFixedFrameSizeFromFp - kNumPushedGpRegisters * kSystemPointerSize;
@@ -57,17 +55,19 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
-           base::bits::CountPopulation(lower_regs) * kDoubleSize;
+           base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
 };
 
diff --git a/src/execution/ppc/frame-constants-ppc.h b/src/execution/ppc/frame-constants-ppc.h
index 7b0b4bc00c..e85bf4db8a 100644
--- a/src/execution/ppc/frame-constants-ppc.h
+++ b/src/execution/ppc/frame-constants-ppc.h
@@ -7,7 +7,7 @@
 
 #include "src/base/bits.h"
 #include "src/base/macros.h"
-#include "src/codegen/ppc/register-ppc.h"
+#include "src/codegen/register.h"
 #include "src/execution/frame-constants.h"
 
 namespace v8 {
@@ -43,16 +43,14 @@ class WasmCompileLazyFrameConstants : public TypedFrameConstants {
 // registers (see liftoff-assembler-defs.h).
 class WasmDebugBreakFrameConstants : public TypedFrameConstants {
  public:
-  static constexpr RegList kPushedGpRegs =
-      Register::ListOf(r3, r4, r5, r6, r7, r8, r9, r10, r11, cp);
+  static constexpr RegList kPushedGpRegs = {r3, r4, r5,  r6,  r7,
+                                            r8, r9, r10, r11, cp};
 
-  static constexpr RegList kPushedFpRegs = DoubleRegister::ListOf(
-      d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
+  static constexpr RegList kPushedFpRegs = {d0, d1, d2, d3,  d4,  d5, d6,
+                                            d7, d8, d9, d10, d11, d12};
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -TypedFrameConstants::kFixedFrameSizeFromFp -
@@ -62,17 +60,19 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
-           base::bits::CountPopulation(lower_regs) * kDoubleSize;
+           base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
 };
 
diff --git a/src/execution/riscv64/frame-constants-riscv64.h b/src/execution/riscv64/frame-constants-riscv64.h
index a92f3dd3d8..4c9286db62 100644
--- a/src/execution/riscv64/frame-constants-riscv64.h
+++ b/src/execution/riscv64/frame-constants-riscv64.h
@@ -46,18 +46,16 @@ class WasmCompileLazyFrameConstants : public TypedFrameConstants {
 class WasmDebugBreakFrameConstants : public TypedFrameConstants {
  public:
   // constexpr RegList kLiftoffAssemblerGpCacheRegs =
-  //    Register::ListOf(a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, s7);
+  //    {a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, s7};
   static constexpr uint32_t kPushedGpRegs = wasm::kLiftoffAssemblerGpCacheRegs;
 
-  //   constexpr RegList kLiftoffAssemblerFpCacheRegs = DoubleRegister::ListOf(
+  //   constexpr RegList kLiftoffAssemblerFpCacheRegs = {
   //       ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7, fa0, fa1, fa2, fa3, fa4, fa5,
-  //       fa6, fa7, ft8, ft9, ft10, ft11);
+  //       fa6, fa7, ft8, ft9, ft10, ft11};
   static constexpr uint32_t kPushedFpRegs = wasm::kLiftoffAssemblerFpCacheRegs;
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -kFixedFrameSizeFromFp - kNumPushedGpRegisters * kSystemPointerSize;
@@ -66,17 +64,19 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
-           base::bits::CountPopulation(lower_regs) * kDoubleSize;
+           base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
 };
 
diff --git a/src/execution/s390/frame-constants-s390.h b/src/execution/s390/frame-constants-s390.h
index 8a270046b0..f3011478e2 100644
--- a/src/execution/s390/frame-constants-s390.h
+++ b/src/execution/s390/frame-constants-s390.h
@@ -7,7 +7,7 @@
 
 #include "src/base/bits.h"
 #include "src/base/macros.h"
-#include "src/codegen/s390/register-s390.h"
+#include "src/codegen/register.h"
 #include "src/execution/frame-constants.h"
 
 namespace v8 {
@@ -46,16 +46,13 @@ class WasmCompileLazyFrameConstants : public TypedFrameConstants {
 // registers (see liftoff-assembler-defs.h).
 class WasmDebugBreakFrameConstants : public TypedFrameConstants {
  public:
-  static constexpr RegList kPushedGpRegs =
-      Register::ListOf(r2, r3, r4, r5, r6, r7, r8, cp);
+  static constexpr RegList kPushedGpRegs = {r2, r3, r4, r5, r6, r7, r8, cp};
 
-  static constexpr RegList kPushedFpRegs = DoubleRegister::ListOf(
-      d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
+  static constexpr RegList kPushedFpRegs = {d0, d1, d2, d3,  d4,  d5, d6,
+                                            d7, d8, d9, d10, d11, d12};
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -TypedFrameConstants::kFixedFrameSizeFromFp -
@@ -65,15 +62,17 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
diff --git a/src/execution/x64/frame-constants-x64.h b/src/execution/x64/frame-constants-x64.h
index 6e1522da25..329ba6289a 100644
--- a/src/execution/x64/frame-constants-x64.h
+++ b/src/execution/x64/frame-constants-x64.h
@@ -7,7 +7,7 @@
 
 #include "src/base/bits.h"
 #include "src/base/macros.h"
-#include "src/codegen/x64/register-x64.h"
+#include "src/codegen/register.h"
 #include "src/execution/frame-constants.h"
 
 namespace v8 {
@@ -61,16 +61,13 @@ class WasmCompileLazyFrameConstants : public TypedFrameConstants {
 // registers (see liftoff-assembler-defs.h).
 class WasmDebugBreakFrameConstants : public TypedFrameConstants {
  public:
-  static constexpr RegList kPushedGpRegs =
-      Register::ListOf(rax, rcx, rdx, rbx, rsi, rdi, r9);
+  static constexpr RegList kPushedGpRegs = {rax, rcx, rdx, rbx, rsi, rdi, r9};
 
-  static constexpr RegList kPushedFpRegs =
-      DoubleRegister::ListOf(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);
+  static constexpr DoubleRegList kPushedFpRegs = {xmm0, xmm1, xmm2, xmm3,
+                                                  xmm4, xmm5, xmm6, xmm7};
 
-  static constexpr int kNumPushedGpRegisters =
-      base::bits::CountPopulation(kPushedGpRegs);
-  static constexpr int kNumPushedFpRegisters =
-      base::bits::CountPopulation(kPushedFpRegs);
+  static constexpr int kNumPushedGpRegisters = kPushedGpRegs.Count();
+  static constexpr int kNumPushedFpRegisters = kPushedFpRegs.Count();
 
   static constexpr int kLastPushedGpRegisterOffset =
       -kFixedFrameSizeFromFp - kNumPushedGpRegisters * kSystemPointerSize;
@@ -79,15 +76,17 @@ class WasmDebugBreakFrameConstants : public TypedFrameConstants {
 
   // Offsets are fp-relative.
   static int GetPushedGpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedGpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedGpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedGpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedGpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedGpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSystemPointerSize;
   }
 
   static int GetPushedFpRegisterOffset(int reg_code) {
-    DCHECK_NE(0, kPushedFpRegs & (1 << reg_code));
-    uint32_t lower_regs = kPushedFpRegs & ((uint32_t{1} << reg_code) - 1);
+    DCHECK_NE(0, kPushedFpRegs.bits() & (1 << reg_code));
+    uint32_t lower_regs =
+        kPushedFpRegs.bits() & ((uint32_t{1} << reg_code) - 1);
     return kLastPushedFpRegisterOffset +
            base::bits::CountPopulation(lower_regs) * kSimd128Size;
   }
diff --git a/src/maglev/maglev-interpreter-frame-state.h b/src/maglev/maglev-interpreter-frame-state.h
index 14656ad667..79c9bde86d 100644
--- a/src/maglev/maglev-interpreter-frame-state.h
+++ b/src/maglev/maglev-interpreter-frame-state.h
@@ -76,7 +76,7 @@ class MergePointRegisterState {
       Register reg;
     };
     explicit Iterator(RegisterState* value_pointer,
-                      RegListIterator::Iterator reg_iterator)
+                      RegList::Iterator reg_iterator)
         : current_value_(value_pointer), reg_iterator_(reg_iterator) {}
     Entry operator*() { return {*current_value_, *reg_iterator_}; }
     void operator++() {
@@ -89,18 +89,17 @@ class MergePointRegisterState {
 
    private:
     RegisterState* current_value_;
-    RegListIterator::Iterator reg_iterator_;
+    RegList::Iterator reg_iterator_;
   };
 
   bool is_initialized() const { return values_[0].GetPayload().is_initialized; }
 
   Iterator begin() {
-    return Iterator(values_,
-                    RegListIterator::Iterator(kAllocatableGeneralRegisters));
+    return Iterator(values_, kAllocatableGeneralRegisters.begin());
   }
   Iterator end() {
     return Iterator(values_ + kAllocatableGeneralRegisterCount,
-                    RegListIterator::Iterator(kEmptyRegList));
+                    kAllocatableGeneralRegisters.end());
   }
 
  private:
diff --git a/src/maglev/maglev-ir.cc b/src/maglev/maglev-ir.cc
index 94849841d5..2f4cc3c161 100644
--- a/src/maglev/maglev-ir.cc
+++ b/src/maglev/maglev-ir.cc
@@ -507,7 +507,7 @@ void CheckMaps::GenerateCode(MaglevCodeGenState* code_gen_state,
                              const ProcessingState& state) {
   Register object = ToRegister(actual_map_input());
   RegList temps = temporaries();
-  Register map_tmp = Register::TakeFirst(&temps);
+  Register map_tmp = temps.PopFirst();
 
   __ LoadMap(map_tmp, object);
   __ Cmp(map_tmp, map().object());
diff --git a/src/maglev/maglev-ir.h b/src/maglev/maglev-ir.h
index 75dd014444..6612d993f3 100644
--- a/src/maglev/maglev-ir.h
+++ b/src/maglev/maglev-ir.h
@@ -370,7 +370,7 @@ class NodeBase : public ZoneObject {
 
   RegList temporaries() const {
     DCHECK_EQ(kTemporariesState, kHasTemporaries);
-    return num_temporaries_needed_;
+    return temporaries_;
   }
 
   void assign_temporaries(RegList list) {
@@ -567,8 +567,8 @@ class ValueNode : public Node {
   // A node is dead once it has no more upcoming uses.
   bool is_dead() const { return next_use_ == kInvalidNodeId; }
 
-  void AddRegister(Register reg) { reg.InsertInto(&registers_with_result_); }
-  void RemoveRegister(Register reg) { reg.RemoveFrom(&registers_with_result_); }
+  void AddRegister(Register reg) { registers_with_result_.set(reg); }
+  void RemoveRegister(Register reg) { registers_with_result_.clear(reg); }
   RegList ClearRegisters() {
     return std::exchange(registers_with_result_, kEmptyRegList);
   }
@@ -576,9 +576,9 @@ class ValueNode : public Node {
 
   compiler::AllocatedOperand allocation() const {
     if (has_register()) {
-      return compiler::AllocatedOperand(
-          compiler::LocationOperand::REGISTER, MachineRepresentation::kTagged,
-          Register::FirstOf(registers_with_result_).code());
+      return compiler::AllocatedOperand(compiler::LocationOperand::REGISTER,
+                                        MachineRepresentation::kTagged,
+                                        registers_with_result_.first().code());
     }
     DCHECK(is_spilled());
     return compiler::AllocatedOperand::cast(spill_or_hint_);
diff --git a/src/maglev/maglev-regalloc.cc b/src/maglev/maglev-regalloc.cc
index 5c56ac2558..5f6d9ae7d1 100644
--- a/src/maglev/maglev-regalloc.cc
+++ b/src/maglev/maglev-regalloc.cc
@@ -198,7 +198,7 @@ void StraightForwardRegisterAllocator::ComputePostDominatingHoles(
 
 void StraightForwardRegisterAllocator::PrintLiveRegs() const {
   bool first = true;
-  for (Register reg : RegListIterator(used_registers())) {
+  for (Register reg : used_registers()) {
     ValueNode* node = GetUsedRegister(reg);
     if (first) {
       first = false;
@@ -412,7 +412,7 @@ void StraightForwardRegisterAllocator::AllocateNodeResult(ValueNode* node) {
 
 void StraightForwardRegisterAllocator::DropRegisterValue(Register reg) {
   // The register should not already be free.
-  DCHECK(!reg.IsIn(free_registers_));
+  DCHECK(!free_registers_.has(reg));
 
   ValueNode* node = GetUsedRegister(reg);
 
@@ -424,7 +424,7 @@ void StraightForwardRegisterAllocator::DropRegisterValue(Register reg) {
 
   // Try to move the value to another register.
   if (free_registers_ != kEmptyRegList) {
-    Register target_reg = Register::TakeFirst(&free_registers_);
+    Register target_reg = free_registers_.PopFirst();
     SetRegister(target_reg, node);
     // Emit a gapmove.
     compiler::AllocatedOperand source(compiler::LocationOperand::REGISTER,
@@ -463,12 +463,12 @@ void StraightForwardRegisterAllocator::InitializeConditionalBranchRegisters(
   DCHECK_EQ(control_node->id() + 1, target->first_id());
   RegList registers = used_registers();
   while (registers != kEmptyRegList) {
-    Register reg = Register::TakeFirst(&registers);
+    Register reg = registers.PopFirst();
     ValueNode* node = GetUsedRegister(reg);
     if (!IsLiveAtTarget(node, control_node, target)) {
       FreeRegisters(node);
       // Update the registers we're visiting to avoid revisiting this node.
-      registers &= !free_registers_;
+      registers.clear(free_registers_);
     }
   }
 }
@@ -524,7 +524,7 @@ void StraightForwardRegisterAllocator::TryAllocateToInput(Phi* phi) {
   for (Input& input : *phi) {
     if (input.operand().IsRegister()) {
       Register reg = input.AssignedRegister();
-      if (reg.IsIn(free_registers_)) {
+      if (free_registers_.has(reg)) {
         phi->result().SetAllocated(ForceAllocate(reg, phi));
         if (FLAG_trace_maglev_regalloc) {
           printing_visitor_->Process(
@@ -611,7 +611,7 @@ void StraightForwardRegisterAllocator::AssignInput(Input& input) {
 }
 
 void StraightForwardRegisterAllocator::SpillRegisters() {
-  for (Register reg : RegListIterator(used_registers())) {
+  for (Register reg : used_registers()) {
     ValueNode* node = GetUsedRegister(reg);
     Spill(node);
   }
@@ -619,11 +619,11 @@ void StraightForwardRegisterAllocator::SpillRegisters() {
 
 void StraightForwardRegisterAllocator::SpillAndClearRegisters() {
   while (used_registers() != kEmptyRegList) {
-    Register reg = Register::FirstOf(used_registers());
+    Register reg = used_registers().first();
     ValueNode* node = GetUsedRegister(reg);
     Spill(node);
     FreeRegisters(node);
-    DCHECK(!reg.IsIn(used_registers()));
+    DCHECK(!used_registers().has(reg));
   }
 }
 
@@ -644,7 +644,7 @@ void StraightForwardRegisterAllocator::AllocateSpillSlot(ValueNode* node) {
 void StraightForwardRegisterAllocator::FreeSomeRegister() {
   int furthest_use = 0;
   Register best = Register::no_reg();
-  for (Register reg : RegListIterator(used_registers())) {
+  for (Register reg : used_registers()) {
     int use = GetUsedRegister(reg)->next_use();
     if (use > furthest_use) {
       furthest_use = use;
@@ -665,9 +665,9 @@ compiler::AllocatedOperand StraightForwardRegisterAllocator::AllocateRegister(
 
 compiler::AllocatedOperand StraightForwardRegisterAllocator::ForceAllocate(
     Register reg, ValueNode* node) {
-  if (reg.IsIn(free_registers_)) {
+  if (free_registers_.has(reg)) {
     // If it's already free, remove it from the free list.
-    reg.RemoveFrom(&free_registers_);
+    free_registers_.clear(reg);
   } else if (GetUsedRegister(reg) == node) {
     return compiler::AllocatedOperand(compiler::LocationOperand::REGISTER,
                                       MachineRepresentation::kTagged,
@@ -676,7 +676,7 @@ compiler::AllocatedOperand StraightForwardRegisterAllocator::ForceAllocate(
     DropRegisterValue(reg);
   }
 #ifdef DEBUG
-  DCHECK(!reg.IsIn(free_registers_));
+  DCHECK(!free_registers_.has(reg));
 #endif
   SetRegister(reg, node);
   return compiler::AllocatedOperand(compiler::LocationOperand::REGISTER,
@@ -685,7 +685,7 @@ compiler::AllocatedOperand StraightForwardRegisterAllocator::ForceAllocate(
 
 void StraightForwardRegisterAllocator::SetRegister(Register reg,
                                                    ValueNode* node) {
-  DCHECK(!reg.IsIn(free_registers_));
+  DCHECK(!free_registers_.has(reg));
   register_values_[reg.code()] = node;
   node->AddRegister(reg);
 }
@@ -693,7 +693,7 @@ void StraightForwardRegisterAllocator::SetRegister(Register reg,
 compiler::InstructionOperand
 StraightForwardRegisterAllocator::TryAllocateRegister(ValueNode* node) {
   if (free_registers_ == kEmptyRegList) return compiler::InstructionOperand();
-  Register reg = Register::TakeFirst(&free_registers_);
+  Register reg = free_registers_.PopFirst();
 
   // Allocation succeeded. This might have found an existing allocation.
   // Simply update the state anyway.
@@ -704,15 +704,14 @@ StraightForwardRegisterAllocator::TryAllocateRegister(ValueNode* node) {
 
 void StraightForwardRegisterAllocator::AssignTemporaries(NodeBase* node) {
   int num_temporaries_needed = node->num_temporaries_needed();
-  int num_free_registers = base::bits::CountPopulation(free_registers_);
+  int num_free_registers = free_registers_.Count();
 
   // Free extra registers if necessary.
   for (int i = num_free_registers; i < num_temporaries_needed; ++i) {
     FreeSomeRegister();
   }
 
-  DCHECK_GE(base::bits::CountPopulation(free_registers_),
-            num_temporaries_needed);
+  DCHECK_GE(free_registers_.Count(), num_temporaries_needed);
   node->assign_temporaries(free_registers_);
 }
 
@@ -720,10 +719,10 @@ void StraightForwardRegisterAllocator::InitializeRegisterValues(
     MergePointRegisterState& target_state) {
   // First clear the register state.
   while (used_registers() != kEmptyRegList) {
-    Register reg = Register::FirstOf(used_registers());
+    Register reg = used_registers().first();
     ValueNode* node = GetUsedRegister(reg);
     FreeRegisters(node);
-    DCHECK(!reg.IsIn(used_registers()));
+    DCHECK(!used_registers().has(reg));
   }
 
   // All registers should be free by now.
@@ -737,7 +736,7 @@ void StraightForwardRegisterAllocator::InitializeRegisterValues(
     RegisterMerge* merge;
     LoadMergeState(entry.state, &node, &merge);
     if (node != nullptr) {
-      reg.RemoveFrom(&free_registers_);
+      free_registers_.clear(reg);
       SetRegister(reg, node);
     } else {
       DCHECK(!entry.state.GetPayload().is_merge);
@@ -766,7 +765,7 @@ void StraightForwardRegisterAllocator::InitializeBranchTargetRegisterValues(
   for (auto entry : target_state) {
     Register reg = entry.reg;
     ValueNode* node = nullptr;
-    if (!reg.IsIn(free_registers_)) {
+    if (!free_registers_.has(reg)) {
       node = GetUsedRegister(reg);
       if (!IsLiveAtTarget(node, source, target)) node = nullptr;
     }
@@ -796,7 +795,7 @@ void StraightForwardRegisterAllocator::MergeRegisterValues(ControlNode* control,
         reg.code()};
 
     ValueNode* incoming = nullptr;
-    if (!reg.IsIn(free_registers_)) {
+    if (!free_registers_.has(reg)) {
       incoming = GetUsedRegister(reg);
       if (!IsLiveAtTarget(incoming, control, target)) {
         incoming = nullptr;
diff --git a/src/maglev/maglev-regalloc.h b/src/maglev/maglev-regalloc.h
index 2b71b63941..32252c5213 100644
--- a/src/maglev/maglev-regalloc.h
+++ b/src/maglev/maglev-regalloc.h
@@ -60,17 +60,17 @@ class StraightForwardRegisterAllocator {
     DCHECK_EQ(free_registers_ & list, kEmptyRegList);
     free_registers_ |= list;
   }
-  void FreeRegister(Register reg) { reg.InsertInto(&free_registers_); }
+  void FreeRegister(Register reg) { free_registers_.set(reg); }
 
   ValueNode* GetUsedRegister(Register reg) const {
-    DCHECK(!reg.IsIn(free_registers_));
+    DCHECK(!free_registers_.has(reg));
     ValueNode* node = register_values_[reg.code()];
     DCHECK_NOT_NULL(node);
     return node;
   }
 
   ValueNode* GetMaybeUsedRegister(Register reg) const {
-    if (!reg.IsIn(free_registers_)) return nullptr;
+    if (!free_registers_.has(reg)) return nullptr;
     return GetUsedRegister(reg);
   }
 
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index 72770779b9..78be35552e 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -702,10 +702,9 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
   // Start new stack frame.
   // Store link register in existing stack-cell.
   // Order here should correspond to order of offset constants in header file.
-  RegList registers_to_retain = r4.bit() | r5.bit() | r6.bit() |
-      r7.bit() | r8.bit() | r9.bit() | r10.bit() | fp.bit();
-  RegList argument_registers = r0.bit() | r1.bit() | r2.bit() | r3.bit();
-  __ stm(db_w, sp, argument_registers | registers_to_retain | lr.bit());
+  RegList registers_to_retain = {r4, r5, r6, r7, r8, r9, r10, fp};
+  RegList argument_registers = {r0, r1, r2, r3};
+  __ stm(db_w, sp, argument_registers | registers_to_retain | lr);
   // Set frame pointer in space for it if this is not a direct call
   // from generated code.
   __ add(frame_pointer(), sp, Operand(4 * kPointerSize));
@@ -922,7 +921,7 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
   // Skip sp past regexp registers and local variables..
   __ mov(sp, frame_pointer());
   // Restore registers r4..r11 and return (restoring lr to pc).
-  __ ldm(ia_w, sp, registers_to_retain | pc.bit());
+  __ ldm(ia_w, sp, registers_to_retain | pc);
 
   // Backtrack code (branch target for conditional backtracks).
   if (backtrack_label_.is_linked()) {
diff --git a/src/regexp/loong64/regexp-macro-assembler-loong64.cc b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
index 3db9a90c29..c60a714339 100644
--- a/src/regexp/loong64/regexp-macro-assembler-loong64.cc
+++ b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
@@ -667,13 +667,12 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
     // Order here should correspond to order of offset constants in header file.
     // TODO(plind): we save s0..s7, but ONLY use s3 here - use the regs
     // or dont save.
-    RegList registers_to_retain = s0.bit() | s1.bit() | s2.bit() | s3.bit() |
-                                  s4.bit() | s5.bit() | s6.bit() | s7.bit();
-    RegList argument_registers = a0.bit() | a1.bit() | a2.bit() | a3.bit();
+    RegList registers_to_retain = {s0, s1, s2, s3, s4, s5, s6, s7};
+    RegList argument_registers = {a0, a1, a2, a3};
 
-    argument_registers |= a4.bit() | a5.bit() | a6.bit() | a7.bit();
+    argument_registers |= {a4, a5, a6, a7};
 
-    __ MultiPush(ra.bit(), fp.bit(), argument_registers | registers_to_retain);
+    __ MultiPush({ra}, {fp}, argument_registers | registers_to_retain);
     // Set frame pointer in space for it if this is not a direct call
     // from generated code.
     // TODO(plind): this 8 is the # of argument regs, should have definition.
@@ -894,7 +893,7 @@ Handle<HeapObject> RegExpMacroAssemblerLOONG64::GetCode(Handle<String> source) {
     // Skip sp past regexp registers and local variables..
     __ mov(sp, frame_pointer());
     // Restore registers s0..s7 and return (restoring ra to pc).
-    __ MultiPop(ra.bit(), fp.bit(), registers_to_retain);
+    __ MultiPop({ra}, {fp}, registers_to_retain);
     __ Ret();
 
     // Backtrack code (branch target for conditional backtracks).
diff --git a/src/regexp/mips/regexp-macro-assembler-mips.cc b/src/regexp/mips/regexp-macro-assembler-mips.cc
index 74a42ef815..dafc657f81 100644
--- a/src/regexp/mips/regexp-macro-assembler-mips.cc
+++ b/src/regexp/mips/regexp-macro-assembler-mips.cc
@@ -681,10 +681,9 @@ Handle<HeapObject> RegExpMacroAssemblerMIPS::GetCode(Handle<String> source) {
     // Start new stack frame.
     // Store link register in existing stack-cell.
     // Order here should correspond to order of offset constants in header file.
-    RegList registers_to_retain = s0.bit() | s1.bit() | s2.bit() |
-        s3.bit() | s4.bit() | s5.bit() | s6.bit() | s7.bit() | fp.bit();
-    RegList argument_registers = a0.bit() | a1.bit() | a2.bit() | a3.bit();
-    __ MultiPush(argument_registers | registers_to_retain | ra.bit());
+    RegList registers_to_retain = {s0, s1, s2, s3, s4, s5, s6, s7, fp};
+    RegList argument_registers = {a0, a1, a2, a3};
+    __ MultiPush(argument_registers | registers_to_retain | ra);
     // Set frame pointer in space for it if this is not a direct call
     // from generated code.
     __ Addu(frame_pointer(), sp, Operand(4 * kPointerSize));
@@ -905,7 +904,7 @@ Handle<HeapObject> RegExpMacroAssemblerMIPS::GetCode(Handle<String> source) {
     // Skip sp past regexp registers and local variables..
     __ mov(sp, frame_pointer());
     // Restore registers s0..s7 and return (restoring ra to pc).
-    __ MultiPop(registers_to_retain | ra.bit());
+    __ MultiPop(registers_to_retain | ra);
     __ Ret();
 
     // Backtrack code (branch target for conditional backtracks).
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.cc b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
index bee0e57501..17546ed52d 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.cc
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
@@ -715,13 +715,12 @@ Handle<HeapObject> RegExpMacroAssemblerMIPS::GetCode(Handle<String> source) {
     // Order here should correspond to order of offset constants in header file.
     // TODO(plind): we save s0..s7, but ONLY use s3 here - use the regs
     // or dont save.
-    RegList registers_to_retain = s0.bit() | s1.bit() | s2.bit() |
-        s3.bit() | s4.bit() | s5.bit() | s6.bit() | s7.bit() | fp.bit();
-    RegList argument_registers = a0.bit() | a1.bit() | a2.bit() | a3.bit();
+    RegList registers_to_retain = {s0, s1, s2, s3, s4, s5, s6, s7, fp};
+    RegList argument_registers = {a0, a1, a2, a3};
 
-    argument_registers |= a4.bit() | a5.bit() | a6.bit() | a7.bit();
+    argument_registers |= {a4, a5, a6, a7};
 
-    __ MultiPush(argument_registers | registers_to_retain | ra.bit());
+    __ MultiPush(argument_registers | registers_to_retain | ra);
     // Set frame pointer in space for it if this is not a direct call
     // from generated code.
     // TODO(plind): this 8 is the # of argument regs, should have definition.
@@ -942,7 +941,7 @@ Handle<HeapObject> RegExpMacroAssemblerMIPS::GetCode(Handle<String> source) {
     // Skip sp past regexp registers and local variables..
     __ mov(sp, frame_pointer());
     // Restore registers s0..s7 and return (restoring ra to pc).
-    __ MultiPop(registers_to_retain | ra.bit());
+    __ MultiPop(registers_to_retain | ra);
     __ Ret();
 
     // Backtrack code (branch target for conditional backtracks).
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index fda0060e47..fb9425f008 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -737,13 +737,13 @@ Handle<HeapObject> RegExpMacroAssemblerPPC::GetCode(Handle<String> source) {
     FrameScope scope(masm_.get(), StackFrame::MANUAL);
 
     // Ensure register assigments are consistent with callee save mask
-    DCHECK(r25.bit() & kRegExpCalleeSaved);
-    DCHECK(code_pointer().bit() & kRegExpCalleeSaved);
-    DCHECK(current_input_offset().bit() & kRegExpCalleeSaved);
-    DCHECK(current_character().bit() & kRegExpCalleeSaved);
-    DCHECK(backtrack_stackpointer().bit() & kRegExpCalleeSaved);
-    DCHECK(end_of_input_address().bit() & kRegExpCalleeSaved);
-    DCHECK(frame_pointer().bit() & kRegExpCalleeSaved);
+    DCHECK(kRegExpCalleeSaved.has(r25));
+    DCHECK(kRegExpCalleeSaved.has(code_pointer()));
+    DCHECK(kRegExpCalleeSaved.has(current_input_offset()));
+    DCHECK(kRegExpCalleeSaved.has(current_character()));
+    DCHECK(kRegExpCalleeSaved.has(backtrack_stackpointer()));
+    DCHECK(kRegExpCalleeSaved.has(end_of_input_address()));
+    DCHECK(kRegExpCalleeSaved.has(frame_pointer()));
 
     // Actually emit code to start a new stack frame.
     // Push arguments
@@ -752,8 +752,7 @@ Handle<HeapObject> RegExpMacroAssemblerPPC::GetCode(Handle<String> source) {
     // Store link register in existing stack-cell.
     // Order here should correspond to order of offset constants in header file.
     RegList registers_to_retain = kRegExpCalleeSaved;
-    RegList argument_registers = r3.bit() | r4.bit() | r5.bit() | r6.bit() |
-                                 r7.bit() | r8.bit() | r9.bit() | r10.bit();
+    RegList argument_registers = {r3, r4, r5, r6, r7, r8, r9, r10};
     __ mflr(r0);
     __ push(r0);
     __ MultiPush(argument_registers | registers_to_retain);
diff --git a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
index 4fdc1985f3..1031fe7da5 100644
--- a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
+++ b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
@@ -221,16 +221,16 @@ void RegExpMacroAssemblerRISCV::CheckGreedyLoop(Label* on_equal) {
 
 // Push (pop) caller-saved registers used by irregexp.
 void RegExpMacroAssemblerRISCV::PushCallerSavedRegisters() {
-  RegList caller_saved_regexp =
-      current_input_offset().bit() | current_character().bit() |
-      end_of_input_address().bit() | backtrack_stackpointer().bit();
+  RegList caller_saved_regexp = {current_input_offset(), current_character(),
+                                 end_of_input_address(),
+                                 backtrack_stackpointer()};
   __ MultiPush(caller_saved_regexp);
 }
 
 void RegExpMacroAssemblerRISCV::PopCallerSavedRegisters() {
-  RegList caller_saved_regexp =
-      current_input_offset().bit() | current_character().bit() |
-      end_of_input_address().bit() | backtrack_stackpointer().bit();
+  RegList caller_saved_regexp = {current_input_offset(), current_character(),
+                                 end_of_input_address(),
+                                 backtrack_stackpointer()};
   __ MultiPop(caller_saved_regexp);
 }
 
@@ -696,10 +696,9 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
     // Order here should correspond to order of offset constants in header file.
     // TODO(plind): we save fp..s11, but ONLY use s3 here - use the regs
     // or dont save.
-    RegList registers_to_retain =
-        fp.bit() | s1.bit() | s2.bit() | s3.bit() | s4.bit() | s5.bit() |
-        s6.bit() | s7.bit() | s8.bit() /*| s9.bit() | s10.bit() | s11.bit()*/;
-    DCHECK(NumRegs(registers_to_retain) == kNumCalleeRegsToRetain);
+    RegList registers_to_retain = {fp, s1, s2, s3, s4,
+                                   s5, s6, s7, s8 /*, s9, s10, s11*/};
+    DCHECK(registers_to_retain.Count() == kNumCalleeRegsToRetain);
 
     // The remaining arguments are passed in registers, e.g.by calling the code
     // entry as cast to a function with the signature:
@@ -713,17 +712,16 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
     //             int call_origin,           // a6
     //             Isolate* isolate,          // a7
     //             Address regexp);           // on the stack
-    RegList argument_registers = a0.bit() | a1.bit() | a2.bit() | a3.bit() |
-                                 a4.bit() | a5.bit() | a6.bit() | a7.bit();
+    RegList argument_registers = {a0, a1, a2, a3, a4, a5, a6, a7};
 
     // According to MultiPush implementation, registers will be pushed in the
     // order of ra, fp, then s8, ..., s1, and finally a7,...a0
-    __ MultiPush(ra.bit() | registers_to_retain | argument_registers);
+    __ MultiPush({ra}, registers_to_retain | argument_registers);
 
     // Set frame pointer in space for it if this is not a direct call
     // from generated code.
     __ Add64(frame_pointer(), sp,
-             Operand(NumRegs(argument_registers) * kSystemPointerSize));
+             Operand(argument_registers.Count() * kSystemPointerSize));
 
     STATIC_ASSERT(kSuccessfulCaptures == kInputString - kSystemPointerSize);
     __ mv(a0, zero_reg);
@@ -844,8 +842,8 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
 
         DCHECK_EQ(0, num_saved_registers_ % 2);
         // Always an even number of capture registers. This allows us to
-        // unroll the loop once to add an operation between a load of a register
-        // and the following use of that register.
+        // unroll the loop once to add an operation between a load of a
+        // register and the following use of that register.
         for (int i = 0; i < num_saved_registers_; i += 2) {
           __ Ld(a2, register_location(i));
           __ Ld(a3, register_location(i + 1));
@@ -928,7 +926,7 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
     __ mv(sp, frame_pointer());
 
     // Restore registers fp..s11 and return (restoring ra to pc).
-    __ MultiPop(registers_to_retain | ra.bit());
+    __ MultiPop(registers_to_retain | ra);
 
     __ Ret();
 
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.cc b/src/regexp/s390/regexp-macro-assembler-s390.cc
index 3b80858f0e..bf22b69222 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.cc
+++ b/src/regexp/s390/regexp-macro-assembler-s390.cc
@@ -708,13 +708,13 @@ Handle<HeapObject> RegExpMacroAssemblerS390::GetCode(Handle<String> source) {
   FrameScope scope(masm_.get(), StackFrame::MANUAL);
 
   // Ensure register assigments are consistent with callee save mask
-  DCHECK(r6.bit() & kRegExpCalleeSaved);
-  DCHECK(code_pointer().bit() & kRegExpCalleeSaved);
-  DCHECK(current_input_offset().bit() & kRegExpCalleeSaved);
-  DCHECK(current_character().bit() & kRegExpCalleeSaved);
-  DCHECK(backtrack_stackpointer().bit() & kRegExpCalleeSaved);
-  DCHECK(end_of_input_address().bit() & kRegExpCalleeSaved);
-  DCHECK(frame_pointer().bit() & kRegExpCalleeSaved);
+  DCHECK(kRegExpCalleeSaved.has(r6));
+  DCHECK(kRegExpCalleeSaved.has(code_pointer()));
+  DCHECK(kRegExpCalleeSaved.has(current_input_offset()));
+  DCHECK(kRegExpCalleeSaved.has(current_character()));
+  DCHECK(kRegExpCalleeSaved.has(backtrack_stackpointer()));
+  DCHECK(kRegExpCalleeSaved.has(end_of_input_address()));
+  DCHECK(kRegExpCalleeSaved.has(frame_pointer()));
 
   // zLinux ABI
   //    Incoming parameters:
diff --git a/src/wasm/baseline/arm/liftoff-assembler-arm.h b/src/wasm/baseline/arm/liftoff-assembler-arm.h
index 0d275caf9f..e6654d9521 100644
--- a/src/wasm/baseline/arm/liftoff-assembler-arm.h
+++ b/src/wasm/baseline/arm/liftoff-assembler-arm.h
@@ -3452,8 +3452,13 @@ void LiftoffAssembler::emit_i8x16_shuffle(LiftoffRegister dst,
     // to q14 and q15, which will be unused since they are not allocatable in
     // Liftoff. If the operands are the same, then we build a smaller list
     // operand below.
-    static_assert(!(kLiftoffAssemblerFpCacheRegs &
-                    (d28.bit() | d29.bit() | d30.bit() | d31.bit())),
+    static_assert(!kLiftoffAssemblerFpCacheRegs.has(d28),
+                  "This only works if q14-q15 (d28-d31) are not used.");
+    static_assert(!kLiftoffAssemblerFpCacheRegs.has(d29),
+                  "This only works if q14-q15 (d28-d31) are not used.");
+    static_assert(!kLiftoffAssemblerFpCacheRegs.has(d30),
+                  "This only works if q14-q15 (d28-d31) are not used.");
+    static_assert(!kLiftoffAssemblerFpCacheRegs.has(d31),
                   "This only works if q14-q15 (d28-d31) are not used.");
     vmov(q14, src1);
     src1 = q14;
@@ -4065,7 +4070,7 @@ void LiftoffAssembler::AssertUnreachable(AbortReason reason) {
 
 void LiftoffAssembler::PushRegisters(LiftoffRegList regs) {
   RegList core_regs = regs.GetGpList();
-  if (core_regs != 0) {
+  if (!core_regs.is_empty()) {
     stm(db_w, sp, core_regs);
   }
   LiftoffRegList fp_regs = regs & kFpCacheRegList;
@@ -4104,7 +4109,7 @@ void LiftoffAssembler::PopRegisters(LiftoffRegList regs) {
     vldm(ia_w, sp, first, last);
   }
   RegList core_regs = regs.GetGpList();
-  if (core_regs != 0) {
+  if (!core_regs.is_empty()) {
     ldm(ia_w, sp, core_regs);
   }
 }
diff --git a/src/wasm/baseline/arm64/liftoff-assembler-arm64.h b/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
index 6b16dd035e..7671ef2816 100644
--- a/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
+++ b/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
@@ -98,13 +98,13 @@ inline CPURegister GetRegFromType(const LiftoffRegister& reg, ValueKind kind) {
 }
 
 inline CPURegList PadRegList(RegList list) {
-  if ((base::bits::CountPopulation(list) & 1) != 0) list |= padreg.bit();
-  return CPURegList(CPURegister::kRegister, kXRegSizeInBits, list);
+  if ((list.Count() & 1) != 0) list.set(padreg);
+  return CPURegList(kXRegSizeInBits, list);
 }
 
-inline CPURegList PadVRegList(RegList list) {
-  if ((base::bits::CountPopulation(list) & 1) != 0) list |= fp_scratch.bit();
-  return CPURegList(CPURegister::kVRegister, kQRegSizeInBits, list);
+inline CPURegList PadVRegList(DoubleRegList list) {
+  if ((list.Count() & 1) != 0) list.set(fp_scratch);
+  return CPURegList(kQRegSizeInBits, list);
 }
 
 inline CPURegister AcquireByType(UseScratchRegisterScope* temps,
@@ -3135,8 +3135,7 @@ void LiftoffAssembler::RecordSpillsInSafepoint(
     SafepointTableBuilder::Safepoint& safepoint, LiftoffRegList all_spills,
     LiftoffRegList ref_spills, int spill_offset) {
   int spill_space_size = 0;
-  bool needs_padding =
-      (base::bits::CountPopulation(all_spills.GetGpList()) & 1) != 0;
+  bool needs_padding = (all_spills.GetGpList().Count() & 1) != 0;
   if (needs_padding) {
     spill_space_size += kSystemPointerSize;
     ++spill_offset;
diff --git a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
index 1c334d8789..4ff56c5ec5 100644
--- a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
+++ b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
@@ -66,7 +66,7 @@ inline MemOperand GetHalfStackSlot(int offset, RegPairHalf half) {
 inline Operand GetInstanceOperand() { return GetStackSlot(kInstanceOffset); }
 
 static constexpr LiftoffRegList kByteRegs =
-    LiftoffRegList::FromBits<Register::ListOf(eax, ecx, edx)>();
+    LiftoffRegList::FromBits<RegList{eax, ecx, edx}.bits()>();
 
 inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, Register base,
                  int32_t offset, ValueKind kind) {
@@ -756,7 +756,7 @@ inline void AtomicBinop32(LiftoffAssembler* lasm, Binop op, Register dst_addr,
   if (is_byte_store) {
     // The scratch register has to be a byte register. As we are already tight
     // on registers, we just use the root register here.
-    static_assert((kLiftoffAssemblerGpCacheRegs & kRootRegister.bit()) == 0,
+    static_assert(!kLiftoffAssemblerGpCacheRegs.has(kRootRegister),
                   "root register is not Liftoff cache register");
     DCHECK(kRootRegister.is_byte_register());
     __ push(kRootRegister);
diff --git a/src/wasm/baseline/liftoff-assembler-defs.h b/src/wasm/baseline/liftoff-assembler-defs.h
index 5b43a2a41d..e4458b602b 100644
--- a/src/wasm/baseline/liftoff-assembler-defs.h
+++ b/src/wasm/baseline/liftoff-assembler-defs.h
@@ -15,105 +15,105 @@ namespace wasm {
 #if V8_TARGET_ARCH_IA32
 
 // Omit ebx, which is the root register.
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(eax, ecx, edx, esi, edi);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {eax, ecx, edx, esi, edi};
 
 // Omit xmm7, which is the kScratchDoubleReg.
-constexpr RegList kLiftoffAssemblerFpCacheRegs =
-    DoubleRegister::ListOf(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {xmm0, xmm1, xmm2, xmm3,
+                                                        xmm4, xmm5, xmm6};
 
 #elif V8_TARGET_ARCH_X64
 
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(rax, rcx, rdx, rbx, rsi, rdi, r9);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {rax, rcx, rdx, rbx,
+                                                  rsi, rdi, r9};
 
-constexpr RegList kLiftoffAssemblerFpCacheRegs =
-    DoubleRegister::ListOf(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {xmm0, xmm1, xmm2, xmm3,
+                                                        xmm4, xmm5, xmm6, xmm7};
 
 #elif V8_TARGET_ARCH_MIPS
 
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(a0, a1, a2, a3, t0, t1, t2, t3, t4, t5, t6, s7, v0, v1);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {a0, a1, a2, a3, t0, t1, t2,
+                                                  t3, t4, t5, t6, s7, v0, v1};
 
-constexpr RegList kLiftoffAssemblerFpCacheRegs = DoubleRegister::ListOf(
-    f0, f2, f4, f6, f8, f10, f12, f14, f16, f18, f20, f22, f24);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    f0, f2, f4, f6, f8, f10, f12, f14, f16, f18, f20, f22, f24};
 
 #elif V8_TARGET_ARCH_MIPS64
 
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, s7, v0, v1);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {a0, a1, a2, a3, a4, a5, a6,
+                                                  a7, t0, t1, t2, s7, v0, v1};
 
-constexpr RegList kLiftoffAssemblerFpCacheRegs = DoubleRegister::ListOf(
-    f0, f2, f4, f6, f8, f10, f12, f14, f16, f18, f20, f22, f24, f26);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    f0, f2, f4, f6, f8, f10, f12, f14, f16, f18, f20, f22, f24, f26};
 
 #elif V8_TARGET_ARCH_LOONG64
 
 // t6-t8 and s3-s4: scratch registers, s6: root
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, t3, t4, t5, s0,
-                     s1, s2, s5, s7, s8);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {a0, a1, a2, a3, a4, a5, a6,
+                                                  a7, t0, t1, t2, t3, t4, t5,
+                                                  s0, s1, s2, s5, s7, s8};
 
 // f29: zero, f30-f31: macro-assembler scratch float Registers.
-constexpr RegList kLiftoffAssemblerFpCacheRegs = DoubleRegister::ListOf(
-    f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16,
-    f17, f18, f19, f20, f21, f22, f23, f24, f25, f26, f27, f28);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    f0,  f1,  f2,  f3,  f4,  f5,  f6,  f7,  f8,  f9,  f10, f11, f12, f13, f14,
+    f15, f16, f17, f18, f19, f20, f21, f22, f23, f24, f25, f26, f27, f28};
 
 #elif V8_TARGET_ARCH_ARM
 
 // r10: root, r11: fp, r12: ip, r13: sp, r14: lr, r15: pc.
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(r0, r1, r2, r3, r4, r5, r6, r7, r8, r9);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {r0, r1, r2, r3, r4,
+                                                  r5, r6, r7, r8, r9};
 
 // d13: zero, d14-d15: scratch
-constexpr RegList kLiftoffAssemblerFpCacheRegs = LowDwVfpRegister::ListOf(
-    d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12};
 
 #elif V8_TARGET_ARCH_ARM64
 
 // x16: ip0, x17: ip1, x18: platform register, x26: root, x28: base, x29: fp,
 // x30: lr, x31: xzr.
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    CPURegister::ListOf(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12,
-                        x13, x14, x15, x19, x20, x21, x22, x23, x24, x25, x27);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {
+    x0,  x1,  x2,  x3,  x4,  x5,  x6,  x7,  x8,  x9,  x10, x11,
+    x12, x13, x14, x15, x19, x20, x21, x22, x23, x24, x25, x27};
 
 // d15: fp_zero, d30-d31: macro-assembler scratch V Registers.
-constexpr RegList kLiftoffAssemblerFpCacheRegs = CPURegister::ListOf(
-    d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14, d16, d17,
-    d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, d29);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    d0,  d1,  d2,  d3,  d4,  d5,  d6,  d7,  d8,  d9,  d10, d11, d12, d13, d14,
+    d16, d17, d18, d19, d20, d21, d22, d23, d24, d25, d26, d27, d28, d29};
 
 #elif V8_TARGET_ARCH_S390X
 
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(r2, r3, r4, r5, r6, r7, r8, cp);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {r2, r3, r4, r5,
+                                                  r6, r7, r8, cp};
 
-constexpr RegList kLiftoffAssemblerFpCacheRegs = DoubleRegister::ListOf(
-    d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12};
 
 #elif V8_TARGET_ARCH_PPC64
 
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(r3, r4, r5, r6, r7, r8, r9, r10, r11, cp);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {r3, r4, r5,  r6,  r7,
+                                                  r8, r9, r10, r11, cp};
 
-constexpr RegList kLiftoffAssemblerFpCacheRegs = DoubleRegister::ListOf(
-    d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    d0, d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12};
 
 #elif V8_TARGET_ARCH_RISCV64
 
 // Any change of kLiftoffAssemblerGpCacheRegs also need to update
 // kPushedGpRegs in frame-constants-riscv64.h
-constexpr RegList kLiftoffAssemblerGpCacheRegs =
-    Register::ListOf(a0, a1, a2, a3, a4, a5, a6, a7, t0, t1, t2, s7);
+constexpr RegList kLiftoffAssemblerGpCacheRegs = {a0, a1, a2, a3, a4, a5,
+                                                  a6, a7, t0, t1, t2, s7};
 
 // Any change of kLiftoffAssemblerGpCacheRegs also need to update
 // kPushedFpRegs in frame-constants-riscv64.h
-constexpr RegList kLiftoffAssemblerFpCacheRegs =
-    DoubleRegister::ListOf(ft1, ft2, ft3, ft4, ft5, ft6, ft7, fa0, fa1, fa2,
-                           fa3, fa4, fa5, fa6, fa7, ft8, ft9, ft10, ft11);
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs = {
+    ft1, ft2, ft3, ft4, ft5, ft6, ft7, fa0,  fa1, fa2,
+    fa3, fa4, fa5, fa6, fa7, ft8, ft9, ft10, ft11};
 #else
 
-constexpr RegList kLiftoffAssemblerGpCacheRegs = 0xff;
+constexpr RegList kLiftoffAssemblerGpCacheRegs = RegList::FromBits(0xff);
 
-constexpr RegList kLiftoffAssemblerFpCacheRegs = 0xff;
+constexpr DoubleRegList kLiftoffAssemblerFpCacheRegs =
+    DoubleRegList::FromBits(0xff);
 
 #endif
 }  // namespace wasm
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index 6d1ee50baf..a432ed100b 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -764,7 +764,7 @@ class LiftoffCompiler {
   bool SpillLocalsInitially(FullDecoder* decoder, uint32_t num_params) {
     int actual_locals = __ num_locals() - num_params;
     DCHECK_LE(0, actual_locals);
-    constexpr int kNumCacheRegisters = NumRegs(kLiftoffAssemblerGpCacheRegs);
+    constexpr int kNumCacheRegisters = kLiftoffAssemblerGpCacheRegs.Count();
     // If we have many locals, we put them on the stack initially. This avoids
     // having to spill them on merge points. Use of these initial values should
     // be rare anyway.
diff --git a/src/wasm/baseline/liftoff-register.h b/src/wasm/baseline/liftoff-register.h
index a31570a241..69a7350fc5 100644
--- a/src/wasm/baseline/liftoff-register.h
+++ b/src/wasm/baseline/liftoff-register.h
@@ -110,13 +110,9 @@ static inline constexpr RegClass reg_class_for(ValueKind kind) {
 // (not sharing index space with gp), so in this example, it is fp register 2.
 
 // Maximum code of a gp cache register.
-static constexpr int kMaxGpRegCode =
-    8 * sizeof(kLiftoffAssemblerGpCacheRegs) -
-    base::bits::CountLeadingZeros(kLiftoffAssemblerGpCacheRegs) - 1;
+static constexpr int kMaxGpRegCode = kLiftoffAssemblerGpCacheRegs.last().code();
 // Maximum code of an fp cache register.
-static constexpr int kMaxFpRegCode =
-    8 * sizeof(kLiftoffAssemblerFpCacheRegs) -
-    base::bits::CountLeadingZeros(kLiftoffAssemblerFpCacheRegs) - 1;
+static constexpr int kMaxFpRegCode = kLiftoffAssemblerFpCacheRegs.last().code();
 static constexpr int kAfterMaxLiftoffGpRegCode = kMaxGpRegCode + 1;
 static constexpr int kAfterMaxLiftoffFpRegCode =
     kAfterMaxLiftoffGpRegCode + kMaxFpRegCode + 1;
@@ -153,12 +149,12 @@ class LiftoffRegister {
  public:
   constexpr explicit LiftoffRegister(Register reg)
       : LiftoffRegister(reg.code()) {
-    DCHECK_NE(0, kLiftoffAssemblerGpCacheRegs & reg.bit());
+    DCHECK(kLiftoffAssemblerGpCacheRegs.has(reg));
     DCHECK_EQ(reg, gp());
   }
   constexpr explicit LiftoffRegister(DoubleRegister reg)
       : LiftoffRegister(kAfterMaxLiftoffGpRegCode + reg.code()) {
-    DCHECK_NE(0, kLiftoffAssemblerFpCacheRegs & reg.bit());
+    DCHECK(kLiftoffAssemblerFpCacheRegs.has(reg));
     DCHECK_EQ(reg, fp());
   }
 
@@ -340,9 +336,11 @@ class LiftoffRegList {
       use_u16, uint16_t,
       std::conditional<use_u32, uint32_t, uint64_t>::type>::type;
 
-  static constexpr storage_t kGpMask = storage_t{kLiftoffAssemblerGpCacheRegs};
-  static constexpr storage_t kFpMask = storage_t{kLiftoffAssemblerFpCacheRegs}
-                                       << kAfterMaxLiftoffGpRegCode;
+  static constexpr storage_t kGpMask =
+      storage_t{kLiftoffAssemblerGpCacheRegs.bits()};
+  static constexpr storage_t kFpMask =
+      storage_t{kLiftoffAssemblerFpCacheRegs.bits()}
+      << kAfterMaxLiftoffGpRegCode;
   // Sets all even numbered fp registers.
   static constexpr uint64_t kEvenFpSetMask = uint64_t{0x5555555555555555}
                                              << kAfterMaxLiftoffGpRegCode;
@@ -443,8 +441,11 @@ class LiftoffRegList {
     return FromBits(regs_ & ~mask.regs_);
   }
 
-  RegList GetGpList() { return regs_ & kGpMask; }
-  RegList GetFpList() { return (regs_ & kFpMask) >> kAfterMaxLiftoffGpRegCode; }
+  RegList GetGpList() { return RegList::FromBits(regs_ & kGpMask); }
+  DoubleRegList GetFpList() {
+    return DoubleRegList::FromBits((regs_ & kFpMask) >>
+                                   kAfterMaxLiftoffGpRegCode);
+  }
 
   inline Iterator begin() const;
   inline Iterator end() const;
diff --git a/src/wasm/baseline/x64/liftoff-assembler-x64.h b/src/wasm/baseline/x64/liftoff-assembler-x64.h
index d2aad069a2..c79527a100 100644
--- a/src/wasm/baseline/x64/liftoff-assembler-x64.h
+++ b/src/wasm/baseline/x64/liftoff-assembler-x64.h
@@ -53,14 +53,15 @@ inline constexpr Condition ToCondition(LiftoffCondition liftoff_cond) {
 constexpr Register kScratchRegister2 = r11;
 static_assert(kScratchRegister != kScratchRegister2, "collision");
 static_assert((kLiftoffAssemblerGpCacheRegs &
-               Register::ListOf(kScratchRegister, kScratchRegister2)) == 0,
+               RegList{kScratchRegister, kScratchRegister2})
+                  .is_empty(),
               "scratch registers must not be used as cache registers");
 
 constexpr DoubleRegister kScratchDoubleReg2 = xmm14;
 static_assert(kScratchDoubleReg != kScratchDoubleReg2, "collision");
 static_assert((kLiftoffAssemblerFpCacheRegs &
-               DoubleRegister::ListOf(kScratchDoubleReg, kScratchDoubleReg2)) ==
-                  0,
+               DoubleRegList{kScratchDoubleReg, kScratchDoubleReg2})
+                  .is_empty(),
               "scratch registers must not be used as cache registers");
 
 // rbp-8 holds the stack marker, rbp-16 is the instance parameter.
diff --git a/test/cctest/compiler/test-code-generator.cc b/test/cctest/compiler/test-code-generator.cc
index f1658abc45..9a8696c828 100644
--- a/test/cctest/compiler/test-code-generator.cc
+++ b/test/cctest/compiler/test-code-generator.cc
@@ -441,12 +441,13 @@ class TestEnvironment : public HandleAndZoneScope {
     DCHECK_LE(kGeneralRegisterCount,
               GetRegConfig()->num_allocatable_general_registers() - 2);
 
-    int32_t general_mask = GetRegConfig()->allocatable_general_codes_mask();
+    RegList general_mask =
+        RegList::FromBits(GetRegConfig()->allocatable_general_codes_mask());
     // kReturnRegister0 is used to hold the "teardown" code object, do not
     // generate moves using it.
+    general_mask.clear(kReturnRegister0);
     std::unique_ptr<const RegisterConfiguration> registers(
-        RegisterConfiguration::RestrictGeneralRegisters(
-            general_mask & ~kReturnRegister0.bit()));
+        RegisterConfiguration::RestrictGeneralRegisters(general_mask));
 
     for (int i = 0; i < kGeneralRegisterCount; i++) {
       int code = registers->GetAllocatableGeneralCode(i);
@@ -577,7 +578,7 @@ class TestEnvironment : public HandleAndZoneScope {
         kTotalStackParameterCount,      // stack_parameter_count
         Operator::kNoProperties,        // properties
         kNoCalleeSaved,                 // callee-saved registers
-        kNoCalleeSaved,                 // callee-saved fp
+        kNoCalleeSavedFp,               // callee-saved fp
         CallDescriptor::kNoFlags);      // flags
   }
 
diff --git a/test/cctest/compiler/test-run-native-calls.cc b/test/cctest/compiler/test-run-native-calls.cc
index 98b4e63fb6..5859051e36 100644
--- a/test/cctest/compiler/test-run-native-calls.cc
+++ b/test/cctest/compiler/test-run-native-calls.cc
@@ -182,8 +182,8 @@ class RegisterConfig {
       locations.AddParam(params.Next(msig->GetParam(i)));
     }
 
-    const RegList kCalleeSaveRegisters = 0;
-    const RegList kCalleeSaveFPRegisters = 0;
+    const RegList kCalleeSaveRegisters;
+    const DoubleRegList kCalleeSaveFPRegisters;
 
     MachineType target_type = MachineType::AnyTagged();
     LinkageLocation target_loc = LinkageLocation::ForAnyRegister();
diff --git a/test/cctest/compiler/test-run-tail-calls.cc b/test/cctest/compiler/test-run-tail-calls.cc
index 4e1023e36c..432a529a12 100644
--- a/test/cctest/compiler/test-run-tail-calls.cc
+++ b/test/cctest/compiler/test-run-tail-calls.cc
@@ -104,7 +104,7 @@ CallDescriptor* CreateDescriptorForStackArguments(Zone* zone, int param_slots) {
       param_slots,                    // stack parameter slots
       Operator::kNoProperties,        // properties
       kNoCalleeSaved,                 // callee-saved registers
-      kNoCalleeSaved,                 // callee-saved fp
+      kNoCalleeSavedFp,               // callee-saved fp
       CallDescriptor::kNoFlags);      // flags
 }
 
diff --git a/test/cctest/test-assembler-arm.cc b/test/cctest/test-assembler-arm.cc
index 4265f2b367..43c5e276e2 100644
--- a/test/cctest/test-assembler-arm.cc
+++ b/test/cctest/test-assembler-arm.cc
@@ -169,7 +169,7 @@ TEST(3) {
   Assembler assm(AssemblerOptions{});
 
   __ mov(ip, Operand(sp));
-  __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, fp, lr});
   __ sub(fp, ip, Operand(4));
   __ mov(r4, Operand(r0));
   __ ldr(r0, MemOperand(r4, offsetof(T, i)));
@@ -183,7 +183,7 @@ TEST(3) {
   __ add(r0, r2, Operand(r0));
   __ mov(r2, Operand(r2, ASR, 3));
   __ strh(r2, MemOperand(r4, offsetof(T, s)));
-  __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, fp, pc});
 
   CodeDesc desc;
   assm.GetCode(isolate, &desc);
@@ -240,7 +240,7 @@ TEST(4) {
     CpuFeatureScope scope(&assm, VFPv3);
 
     __ mov(ip, Operand(sp));
-    __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, fp, lr});
     __ sub(fp, ip, Operand(4));
 
     __ mov(r4, Operand(r0));
@@ -313,7 +313,7 @@ TEST(4) {
     __ vmov(s0, Float32(-16.0f));
     __ vstr(s0, r4, offsetof(T, p));
 
-    __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, fp, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -636,7 +636,7 @@ TEST(8) {
   Assembler assm(AssemblerOptions{});
 
   __ mov(ip, Operand(sp));
-  __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, fp, lr});
   __ sub(fp, ip, Operand(4));
 
   __ add(r4, r0, Operand(static_cast<int32_t>(offsetof(D, a))));
@@ -655,7 +655,7 @@ TEST(8) {
   __ vstm(ia_w, r4, s6, s7);
   __ vstm(ia_w, r4, s0, s5);
 
-  __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, fp, pc});
 
   CodeDesc desc;
   assm.GetCode(isolate, &desc);
@@ -741,7 +741,7 @@ TEST(9) {
   Assembler assm(AssemblerOptions{});
 
   __ mov(ip, Operand(sp));
-  __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, fp, lr});
   __ sub(fp, ip, Operand(4));
 
   __ add(r4, r0, Operand(static_cast<int32_t>(offsetof(D, a))));
@@ -764,7 +764,7 @@ TEST(9) {
   __ add(r4, r4, Operand(2 * 4));
   __ vstm(ia, r4, s0, s5);
 
-  __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, fp, pc});
 
   CodeDesc desc;
   assm.GetCode(isolate, &desc);
@@ -850,7 +850,7 @@ TEST(10) {
   Assembler assm(AssemblerOptions{});
 
   __ mov(ip, Operand(sp));
-  __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, fp, lr});
   __ sub(fp, ip, Operand(4));
 
   __ add(r4, r0, Operand(static_cast<int32_t>(offsetof(D, h)) + 8));
@@ -869,7 +869,7 @@ TEST(10) {
   __ vstm(db_w, r4, s0, s5);
   __ vstm(db_w, r4, s6, s7);
 
-  __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, fp, pc});
 
   CodeDesc desc;
   assm.GetCode(isolate, &desc);
@@ -1030,7 +1030,7 @@ TEST(13) {
   if (CpuFeatures::IsSupported(VFPv3)) {
     CpuFeatureScope scope(&assm, VFPv3);
 
-    __ stm(db_w, sp, r4.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, lr});
 
     // Load a, b, c into d16, d17, d18.
     __ mov(r4, Operand(r0));
@@ -1088,7 +1088,7 @@ TEST(13) {
     __ vmov(NeonS32, r4, d22, 1);
     __ str(r4, MemOperand(r0, offsetof(T, high)));
 
-    __ ldm(ia_w, sp, r4.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -1329,7 +1329,7 @@ TEST(15) {
   if (CpuFeatures::IsSupported(NEON)) {
     CpuFeatureScope scope(&assm, NEON);
 
-    __ stm(db_w, sp, r4.bit() | r5.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, r5, lr});
     // Move 32 bytes with neon.
     __ add(r4, r0, Operand(static_cast<int32_t>(offsetof(T, src0))));
     __ vld1(Neon8, NeonListOperand(d0, 4), NeonMemOperand(r4));
@@ -2164,7 +2164,7 @@ TEST(15) {
     __ vstr(d2, r0, offsetof(T, vtbx));
 
     // Restore and return.
-    __ ldm(ia_w, sp, r4.bit() | r5.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, r5, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -2446,7 +2446,7 @@ TEST(16) {
   // the doubles and floats.
   Assembler assm(AssemblerOptions{});
 
-  __ stm(db_w, sp, r4.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, lr});
 
   __ mov(r4, Operand(r0));
   __ ldr(r0, MemOperand(r4, offsetof(T, src0)));
@@ -2468,7 +2468,7 @@ TEST(16) {
   __ uxtab(r2, r0, r1, 8);
   __ str(r2, MemOperand(r4, offsetof(T, dst4)));
 
-  __ ldm(ia_w, sp, r4.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, pc});
 
   CodeDesc desc;
   assm.GetCode(isolate, &desc);
@@ -2937,7 +2937,7 @@ TEST(code_relative_offset) {
 
   Label start, target_away, target_faraway;
 
-  __ stm(db_w, sp, r4.bit() | r5.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, r5, lr});
 
   // r3 is used as the address zero, the test will crash when we load it.
   __ mov(r3, Operand::Zero());
@@ -2982,7 +2982,7 @@ TEST(code_relative_offset) {
   // r0 = r0 + 5 + 5 + 11
   __ add(r0, r0, Operand(11));
 
-  __ ldm(ia_w, sp, r4.bit() | r5.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, r5, pc});
 
   CodeDesc desc;
   assm.GetCode(isolate, &desc);
@@ -3090,7 +3090,7 @@ TEST(ARMv8_float32_vrintX) {
     CpuFeatureScope scope(&assm, ARMv8);
 
     __ mov(ip, Operand(sp));
-    __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, fp, lr});
 
     __ mov(r4, Operand(r0));
 
@@ -3119,7 +3119,7 @@ TEST(ARMv8_float32_vrintX) {
     __ vrintz(s5, s6);
     __ vstr(s5, r4, offsetof(T, zr));
 
-    __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, fp, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -3191,7 +3191,7 @@ TEST(ARMv8_vrintX) {
     CpuFeatureScope scope(&assm, ARMv8);
 
     __ mov(ip, Operand(sp));
-    __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, fp, lr});
 
     __ mov(r4, Operand(r0));
 
@@ -3220,7 +3220,7 @@ TEST(ARMv8_vrintX) {
     __ vrintz(d5, d6);
     __ vstr(d5, r4, offsetof(T, zr));
 
-    __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, fp, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -3930,7 +3930,7 @@ TEST(vswp) {
   };
   T t;
 
-  __ stm(db_w, sp, r4.bit() | r5.bit() | r6.bit() | r7.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, r5, r6, r7, lr});
 
   uint64_t one = bit_cast<uint64_t>(1.0);
   __ mov(r5, Operand(one >> 32));
@@ -3966,7 +3966,7 @@ TEST(vswp) {
   __ add(r6, r0, Operand(static_cast<int32_t>(offsetof(T, vswp_q5))));
   __ vst1(Neon8, NeonListOperand(q5), NeonMemOperand(r6));
 
-  __ ldm(ia_w, sp, r4.bit() | r5.bit() | r6.bit() | r7.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, r5, r6, r7, pc});
   __ bx(lr);
 
   CodeDesc desc;
@@ -4060,18 +4060,18 @@ TEST(use_scratch_register_scope) {
   Assembler assm(AssemblerOptions{});
 
   // The assembler should have ip as a scratch by default.
-  CHECK_EQ(*assm.GetScratchRegisterList(), ip.bit());
+  CHECK_EQ(*assm.GetScratchRegisterList(), RegList{ip});
 
   {
     UseScratchRegisterScope temps(&assm);
-    CHECK_EQ(*assm.GetScratchRegisterList(), ip.bit());
+    CHECK_EQ(*assm.GetScratchRegisterList(), RegList{ip});
 
     Register scratch = temps.Acquire();
     CHECK_EQ(scratch.code(), ip.code());
-    CHECK_EQ(*assm.GetScratchRegisterList(), 0);
+    CHECK_EQ(*assm.GetScratchRegisterList(), RegList{});
   }
 
-  CHECK_EQ(*assm.GetScratchRegisterList(), ip.bit());
+  CHECK_EQ(*assm.GetScratchRegisterList(), RegList{ip});
 }
 
 TEST(use_scratch_vfp_register_scope) {
@@ -4342,8 +4342,7 @@ TEST(move_pair) {
   HandleScope scope(isolate);
 
   auto f = AssembleCode<F_piiii>(isolate, [](MacroAssembler& assm) {
-    RegList used_callee_saved =
-        r4.bit() | r5.bit() | r6.bit() | r7.bit() | r8.bit();
+    RegList used_callee_saved = {r4, r5, r6, r7, r8};
     __ stm(db_w, sp, used_callee_saved);
 
     // Save output register bank pointer to r8.
diff --git a/test/cctest/test-assembler-arm64.cc b/test/cctest/test-assembler-arm64.cc
index 0c41602514..fea98df487 100644
--- a/test/cctest/test-assembler-arm64.cc
+++ b/test/cctest/test-assembler-arm64.cc
@@ -9571,7 +9571,7 @@ TEST(fcmp) {
     // test. A UseScratchRegisterScope will make sure that they are restored to
     // the default values once we're finished.
     UseScratchRegisterScope temps(&masm);
-    masm.FPTmpList()->set_list(0);
+    masm.FPTmpList()->set_bits(0);
 
     __ Fmov(s8, 0.0);
     __ Fmov(s9, 0.5);
@@ -9590,9 +9590,9 @@ TEST(fcmp) {
     __ Mrs(x4, NZCV);
     __ Fcmp(s8, 0.0);
     __ Mrs(x5, NZCV);
-    masm.FPTmpList()->set_list(d0.bit());
+    masm.FPTmpList()->set_bits(DoubleRegList{d0}.bits());
     __ Fcmp(s8, 255.0);
-    masm.FPTmpList()->set_list(0);
+    masm.FPTmpList()->set_bits(0);
     __ Mrs(x6, NZCV);
 
     __ Fmov(d19, 0.0);
@@ -9612,9 +9612,9 @@ TEST(fcmp) {
     __ Mrs(x14, NZCV);
     __ Fcmp(d19, 0.0);
     __ Mrs(x15, NZCV);
-    masm.FPTmpList()->set_list(d0.bit());
+    masm.FPTmpList()->set_bits(DoubleRegList{d0}.bits());
     __ Fcmp(d19, 12.3456);
-    masm.FPTmpList()->set_list(0);
+    masm.FPTmpList()->set_bits(0);
     __ Mrs(x16, NZCV);
   }
 
@@ -12026,27 +12026,27 @@ TEST(register_bit) {
   // teardown.
 
   // Simple tests.
-  CHECK_EQ(x0.bit(), 1ULL << 0);
-  CHECK_EQ(x1.bit(), 1ULL << 1);
-  CHECK_EQ(x10.bit(), 1ULL << 10);
+  CHECK_EQ(RegList{x0}.bits(), 1ULL << 0);
+  CHECK_EQ(RegList{x1}.bits(), 1ULL << 1);
+  CHECK_EQ(RegList{x10}.bits(), 1ULL << 10);
 
   // AAPCS64 definitions.
-  CHECK_EQ(fp.bit(), 1ULL << kFramePointerRegCode);
-  CHECK_EQ(lr.bit(), 1ULL << kLinkRegCode);
+  CHECK_EQ(RegList{fp}.bits(), 1ULL << kFramePointerRegCode);
+  CHECK_EQ(RegList{lr}.bits(), 1ULL << kLinkRegCode);
 
   // Fixed (hardware) definitions.
-  CHECK_EQ(xzr.bit(), 1ULL << kZeroRegCode);
+  CHECK_EQ(RegList{xzr}.bits(), 1ULL << kZeroRegCode);
 
   // Internal ABI definitions.
-  CHECK_EQ(sp.bit(), 1ULL << kSPRegInternalCode);
-  CHECK_NE(sp.bit(), xzr.bit());
+  CHECK_EQ(RegList{sp}.bits(), 1ULL << kSPRegInternalCode);
+  CHECK_NE(RegList{sp}.bits(), RegList{xzr}.bits());
 
-  // xn.bit() == wn.bit() at all times, for the same n.
-  CHECK_EQ(x0.bit(), w0.bit());
-  CHECK_EQ(x1.bit(), w1.bit());
-  CHECK_EQ(x10.bit(), w10.bit());
-  CHECK_EQ(xzr.bit(), wzr.bit());
-  CHECK_EQ(sp.bit(), wsp.bit());
+  // RegList{xn}.bits() == RegList{wn}.bits() at all times, for the same n.
+  CHECK_EQ(RegList{x0}.bits(), RegList{w0}.bits());
+  CHECK_EQ(RegList{x1}.bits(), RegList{w1}.bits());
+  CHECK_EQ(RegList{x10}.bits(), RegList{w10}.bits());
+  CHECK_EQ(RegList{xzr}.bits(), RegList{wzr}.bits());
+  CHECK_EQ(RegList{sp}.bits(), RegList{wsp}.bits());
 }
 
 TEST(peek_poke_simple) {
@@ -12054,9 +12054,8 @@ TEST(peek_poke_simple) {
   SETUP();
   START();
 
-  static const RegList x0_to_x3 = x0.bit() | x1.bit() | x2.bit() | x3.bit();
-  static const RegList x10_to_x13 =
-      x10.bit() | x11.bit() | x12.bit() | x13.bit();
+  static const RegList x0_to_x3 = {x0, x1, x2, x3};
+  static const RegList x10_to_x13 = {x10, x11, x12, x13};
 
   // The literal base is chosen to have two useful properties:
   //  * When multiplied by small values (such as a register index), this value
@@ -12141,35 +12140,35 @@ TEST(peek_poke_unaligned) {
   //    x0-x6 should be unchanged.
   //    w10-w12 should contain the lower words of x0-x2.
   __ Poke(x0, 1);
-  Clobber(&masm, x0.bit());
+  Clobber(&masm, {x0});
   __ Peek(x0, 1);
   __ Poke(x1, 2);
-  Clobber(&masm, x1.bit());
+  Clobber(&masm, {x1});
   __ Peek(x1, 2);
   __ Poke(x2, 3);
-  Clobber(&masm, x2.bit());
+  Clobber(&masm, {x2});
   __ Peek(x2, 3);
   __ Poke(x3, 4);
-  Clobber(&masm, x3.bit());
+  Clobber(&masm, {x3});
   __ Peek(x3, 4);
   __ Poke(x4, 5);
-  Clobber(&masm, x4.bit());
+  Clobber(&masm, {x4});
   __ Peek(x4, 5);
   __ Poke(x5, 6);
-  Clobber(&masm, x5.bit());
+  Clobber(&masm, {x5});
   __ Peek(x5, 6);
   __ Poke(x6, 7);
-  Clobber(&masm, x6.bit());
+  Clobber(&masm, {x6});
   __ Peek(x6, 7);
 
   __ Poke(w0, 1);
-  Clobber(&masm, w10.bit());
+  Clobber(&masm, {w10});
   __ Peek(w10, 1);
   __ Poke(w1, 2);
-  Clobber(&masm, w11.bit());
+  Clobber(&masm, {w11});
   __ Peek(w11, 2);
   __ Poke(w2, 3);
-  Clobber(&masm, w12.bit());
+  Clobber(&masm, {w12});
   __ Peek(w12, 3);
 
   __ Drop(4);
@@ -12332,9 +12331,11 @@ static void PushPopSimpleHelper(int reg_count, int reg_size,
   // For simplicity, exclude LR as well, as we would need to sign it when
   // pushing it. This also ensures that the list has an even number of elements,
   // which is needed for alignment.
-  RegList allowed = ~(masm.TmpList()->list() | x18.bit() | lr.bit());
+  static RegList const allowed =
+      RegList::FromBits(static_cast<uint32_t>(~masm.TmpList()->bits())) -
+      RegList{x18, lr};
   if (reg_count == kPushPopMaxRegCount) {
-    reg_count = CountSetBits(allowed, kNumberOfRegisters);
+    reg_count = CountSetBits(allowed.bits(), kNumberOfRegisters);
   }
   DCHECK_EQ(reg_count % 2, 0);
   // Work out which registers to use, based on reg_size.
@@ -12480,15 +12481,15 @@ static void PushPopFPSimpleHelper(int reg_count, int reg_size,
 
   // We can use any floating-point register. None of them are reserved for
   // debug code, for example.
-  static RegList const allowed = ~0;
+  static DoubleRegList const allowed = DoubleRegList::FromBits(~0);
   if (reg_count == kPushPopFPMaxRegCount) {
-    reg_count = CountSetBits(allowed, kNumberOfVRegisters);
+    reg_count = CountSetBits(allowed.bits(), kNumberOfVRegisters);
   }
   // Work out which registers to use, based on reg_size.
   auto v = CreateRegisterArray<VRegister, kNumberOfRegisters>();
   auto d = CreateRegisterArray<VRegister, kNumberOfRegisters>();
-  RegList list = PopulateVRegisterArray(nullptr, d.data(), v.data(), reg_size,
-                                        reg_count, allowed);
+  DoubleRegList list = PopulateVRegisterArray(nullptr, d.data(), v.data(),
+                                              reg_size, reg_count, allowed);
 
   // The literal base is chosen to have two useful properties:
   //  * When multiplied (using an integer) by small values (such as a register
@@ -12530,7 +12531,7 @@ static void PushPopFPSimpleHelper(int reg_count, int reg_size,
         }
         break;
       case PushPopRegList:
-        __ PushSizeRegList(list, reg_size, CPURegister::kVRegister);
+        __ PushSizeRegList(list, reg_size);
         break;
     }
 
@@ -12554,7 +12555,7 @@ static void PushPopFPSimpleHelper(int reg_count, int reg_size,
         }
         break;
       case PushPopRegList:
-        __ PopSizeRegList(list, reg_size, CPURegister::kVRegister);
+        __ PopSizeRegList(list, reg_size);
         break;
     }
   }
@@ -12627,24 +12628,25 @@ static void PushPopMixedMethodsHelper(int reg_size) {
 
   // Registers in the TmpList can be used by the macro assembler for debug code
   // (for example in 'Pop'), so we can't use them here.
-  static RegList const allowed = ~(masm.TmpList()->list());
+  static RegList const allowed =
+      RegList::FromBits(static_cast<uint32_t>(~masm.TmpList()->bits()));
   // Work out which registers to use, based on reg_size.
   auto r = CreateRegisterArray<Register, 10>();
   auto x = CreateRegisterArray<Register, 10>();
   PopulateRegisterArray(nullptr, x.data(), r.data(), reg_size, 10, allowed);
 
   // Calculate some handy register lists.
-  RegList r0_to_r3 = 0;
+  RegList r0_to_r3;
   for (int i = 0; i <= 3; i++) {
-    r0_to_r3 |= x[i].bit();
+    r0_to_r3.set(x[i]);
   }
-  RegList r4_to_r5 = 0;
+  RegList r4_to_r5;
   for (int i = 4; i <= 5; i++) {
-    r4_to_r5 |= x[i].bit();
+    r4_to_r5.set(x[i]);
   }
-  RegList r6_to_r9 = 0;
+  RegList r6_to_r9;
   for (int i = 6; i <= 9; i++) {
-    r6_to_r9 |= x[i].bit();
+    r6_to_r9.set(x[i]);
   }
 
   // The literal base is chosen to have two useful properties:
@@ -12706,17 +12708,17 @@ TEST(push_pop) {
   __ Mov(x1, 0x1111111111111111UL);
   __ Mov(x0, 0x0000000000000000UL);
   __ Claim(2);
-  __ PushXRegList(x0.bit() | x1.bit() | x2.bit() | x3.bit());
+  __ PushXRegList({x0, x1, x2, x3});
   __ Push(x3, x2);
-  __ PopXRegList(x0.bit() | x1.bit() | x2.bit() | x3.bit());
+  __ PopXRegList({x0, x1, x2, x3});
   __ Push(x2, x1, x3, x0);
   __ Pop(x4, x5);
   __ Pop(x6, x7, x8, x9);
 
   __ Claim(2);
-  __ PushWRegList(w0.bit() | w1.bit() | w2.bit() | w3.bit());
+  __ PushWRegList({w0, w1, w2, w3});
   __ Push(w3, w1, w2, w0);
-  __ PopWRegList(w10.bit() | w11.bit() | w12.bit() | w13.bit());
+  __ PopWRegList({w10, w11, w12, w13});
   __ Pop(w14, w15, w16, w17);
 
   __ Claim(2);
@@ -12726,18 +12728,18 @@ TEST(push_pop) {
   __ Pop(x22, x23);
 
   __ Claim(2);
-  __ PushXRegList(x1.bit() | x22.bit());
-  __ PopXRegList(x24.bit() | x26.bit());
+  __ PushXRegList({x1, x22});
+  __ PopXRegList({x24, x26});
 
   __ Claim(2);
-  __ PushWRegList(w1.bit() | w2.bit() | w4.bit() | w22.bit());
-  __ PopWRegList(w25.bit() | w27.bit() | w28.bit() | w29.bit());
+  __ PushWRegList({w1, w2, w4, w22});
+  __ PopWRegList({w25, w27, w28, w29});
 
   __ Claim(2);
-  __ PushXRegList(0);
-  __ PopXRegList(0);
+  __ PushXRegList({});
+  __ PopXRegList({});
   // Don't push/pop x18 (platform register) or lr
-  RegList all_regs = 0xFFFFFFFF & ~(x18.bit() | lr.bit());
+  RegList all_regs = RegList::FromBits(0xFFFFFFFF) - RegList{x18, lr};
   __ PushXRegList<TurboAssembler::kDontStoreLR>(all_regs);
   __ PopXRegList<TurboAssembler::kDontLoadLR>(all_regs);
   __ Drop(12);
@@ -13891,10 +13893,10 @@ TEST(cpureglist_utils_empty) {
   // Test an empty list.
   // Empty lists can have type and size properties. Check that we can create
   // them, and that they are empty.
-  CPURegList reg32(CPURegister::kRegister, kWRegSizeInBits, 0);
-  CPURegList reg64(CPURegister::kRegister, kXRegSizeInBits, 0);
-  CPURegList fpreg32(CPURegister::kVRegister, kSRegSizeInBits, 0);
-  CPURegList fpreg64(CPURegister::kVRegister, kDRegSizeInBits, 0);
+  CPURegList reg32(kWRegSizeInBits, RegList{});
+  CPURegList reg64(kXRegSizeInBits, RegList{});
+  CPURegList fpreg32(kSRegSizeInBits, DoubleRegList{});
+  CPURegList fpreg64(kDRegSizeInBits, DoubleRegList{});
 
   CHECK(reg32.IsEmpty());
   CHECK(reg64.IsEmpty());
diff --git a/test/cctest/test-assembler-ppc.cc b/test/cctest/test-assembler-ppc.cc
index d7bdd7e2cd..0ee531a8bc 100644
--- a/test/cctest/test-assembler-ppc.cc
+++ b/test/cctest/test-assembler-ppc.cc
@@ -263,7 +263,7 @@ TEST(4) {
     CpuFeatures::Scope scope(VFP3);
 
     __ mov(ip, Operand(sp));
-    __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, fp, lr});
     __ sub(fp, ip, Operand(4));
 
     __ mov(r4, Operand(r0));
@@ -321,7 +321,7 @@ TEST(4) {
     __ vneg(d0, d1);
     __ vstr(d0, r4, offsetof(T, n));
 
-    __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, fp, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -659,7 +659,7 @@ TEST(8) {
     CpuFeatures::Scope scope(VFP2);
 
     __ mov(ip, Operand(sp));
-    __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, fp, lr});
     __ sub(fp, ip, Operand(4));
 
     __ addi(r4, r0, Operand(offsetof(D, a)));
@@ -678,7 +678,7 @@ TEST(8) {
     __ vstm(ia_w, r4, s6, s7);
     __ vstm(ia_w, r4, s0, s5);
 
-    __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, fp, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -770,7 +770,7 @@ TEST(9) {
     CpuFeatures::Scope scope(VFP2);
 
     __ mov(ip, Operand(sp));
-    __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, fp, lr});
     __ sub(fp, ip, Operand(4));
 
     __ addi(r4, r0, Operand(offsetof(D, a)));
@@ -793,7 +793,7 @@ TEST(9) {
     __ addi(r4, r4, Operand(2 * 4));
     __ vstm(ia, r4, s0, s5);
 
-    __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, fp, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
@@ -885,7 +885,7 @@ TEST(10) {
     CpuFeatures::Scope scope(VFP2);
 
     __ mov(ip, Operand(sp));
-    __ stm(db_w, sp, r4.bit() | fp.bit() | lr.bit());
+    __ stm(db_w, sp, {r4, fp, lr});
     __ sub(fp, ip, Operand(4));
 
     __ addi(r4, r0, Operand(offsetof(D, h) + 8));
@@ -904,7 +904,7 @@ TEST(10) {
     __ vstm(db_w, r4, s0, s5);
     __ vstm(db_w, r4, s6, s7);
 
-    __ ldm(ia_w, sp, r4.bit() | fp.bit() | pc.bit());
+    __ ldm(ia_w, sp, {r4, fp, pc});
 
     CodeDesc desc;
     assm.GetCode(isolate, &desc);
diff --git a/test/cctest/test-macro-assembler-arm.cc b/test/cctest/test-macro-assembler-arm.cc
index 1190a4afb9..55a0441c52 100644
--- a/test/cctest/test-macro-assembler-arm.cc
+++ b/test/cctest/test-macro-assembler-arm.cc
@@ -73,7 +73,7 @@ TEST(ExtractLane) {
   };
   T t;
 
-  __ stm(db_w, sp, r4.bit() | r5.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, r5, lr});
 
   for (int i = 0; i < 4; i++) {
     __ mov(r4, Operand(i));
@@ -143,7 +143,7 @@ TEST(ExtractLane) {
     }
   }
 
-  __ ldm(ia_w, sp, r4.bit() | r5.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, r5, pc});
 
   CodeDesc desc;
   masm->GetCode(isolate, &desc);
@@ -210,7 +210,7 @@ TEST(ReplaceLane) {
   };
   T t;
 
-  __ stm(db_w, sp, r4.bit() | r5.bit() | r6.bit() | r7.bit() | lr.bit());
+  __ stm(db_w, sp, {r4, r5, r6, r7, lr});
 
   __ veor(q0, q0, q0);  // Zero
   __ veor(q1, q1, q1);  // Zero
@@ -274,7 +274,7 @@ TEST(ReplaceLane) {
     __ vst1(Neon8, NeonListOperand(q14), NeonMemOperand(r4));
   }
 
-  __ ldm(ia_w, sp, r4.bit() | r5.bit() | r6.bit() | r7.bit() | pc.bit());
+  __ ldm(ia_w, sp, {r4, r5, r6, r7, pc});
 
   CodeDesc desc;
   masm->GetCode(isolate, &desc);
diff --git a/test/cctest/test-utils-arm64.cc b/test/cctest/test-utils-arm64.cc
index 1fc0add43f..2b9cec9065 100644
--- a/test/cctest/test-utils-arm64.cc
+++ b/test/cctest/test-utils-arm64.cc
@@ -232,106 +232,100 @@ bool EqualV8Registers(const RegisterDump* a, const RegisterDump* b) {
 
 RegList PopulateRegisterArray(Register* w, Register* x, Register* r,
                               int reg_size, int reg_count, RegList allowed) {
-  RegList list = 0;
+  RegList list;
   int i = 0;
-  for (unsigned n = 0; (n < kNumberOfRegisters) && (i < reg_count); n++) {
-    if (((1ULL << n) & allowed) != 0) {
-      // Only assign allowed registers.
-      if (r) {
-        r[i] = Register::Create(n, reg_size);
-      }
-      if (x) {
-        x[i] = Register::Create(n, kXRegSizeInBits);
-      }
-      if (w) {
-        w[i] = Register::Create(n, kWRegSizeInBits);
-      }
-      list |= (1ULL << n);
-      i++;
+  // Only assign allowed registers.
+  for (Register reg : allowed) {
+    if (i == reg_count) break;
+    if (r) {
+      r[i] = Register::Create(reg.code(), reg_size);
     }
+    if (x) {
+      x[i] = reg.X();
+    }
+    if (w) {
+      w[i] = reg.W();
+    }
+    list.set(reg);
+    i++;
   }
   // Check that we got enough registers.
-  CHECK(CountSetBits(list, kNumberOfRegisters) == reg_count);
+  CHECK_EQ(list.Count(), reg_count);
 
   return list;
 }
 
-RegList PopulateVRegisterArray(VRegister* s, VRegister* d, VRegister* v,
-                               int reg_size, int reg_count, RegList allowed) {
-  RegList list = 0;
+DoubleRegList PopulateVRegisterArray(VRegister* s, VRegister* d, VRegister* v,
+                                     int reg_size, int reg_count,
+                                     DoubleRegList allowed) {
+  DoubleRegList list;
   int i = 0;
-  for (unsigned n = 0; (n < kNumberOfVRegisters) && (i < reg_count); n++) {
-    if (((1ULL << n) & allowed) != 0) {
-      // Only assigned allowed registers.
-      if (v) {
-        v[i] = VRegister::Create(n, reg_size);
-      }
-      if (d) {
-        d[i] = VRegister::Create(n, kDRegSizeInBits);
-      }
-      if (s) {
-        s[i] = VRegister::Create(n, kSRegSizeInBits);
-      }
-      list |= (1ULL << n);
-      i++;
+  // Only assigned allowed registers.
+  for (VRegister reg : allowed) {
+    if (i == reg_count) break;
+    if (v) {
+      v[i] = VRegister::Create(reg.code(), reg_size);
+    }
+    if (d) {
+      d[i] = reg.D();
     }
+    if (s) {
+      s[i] = reg.S();
+    }
+    list.set(reg);
+    i++;
   }
   // Check that we got enough registers.
-  CHECK(CountSetBits(list, kNumberOfVRegisters) == reg_count);
+  CHECK_EQ(list.Count(), reg_count);
 
   return list;
 }
 
-
 void Clobber(MacroAssembler* masm, RegList reg_list, uint64_t const value) {
   Register first = NoReg;
-  for (unsigned i = 0; i < kNumberOfRegisters; i++) {
-    if (reg_list & (1ULL << i)) {
-      Register xn = Register::Create(i, kXRegSizeInBits);
-      // We should never write into sp here.
-      CHECK_NE(xn, sp);
-      if (!xn.IsZero()) {
-        if (!first.is_valid()) {
-          // This is the first register we've hit, so construct the literal.
-          __ Mov(xn, value);
-          first = xn;
-        } else {
-          // We've already loaded the literal, so re-use the value already
-          // loaded into the first register we hit.
-          __ Mov(xn, first);
-        }
+  for (Register reg : reg_list) {
+    Register xn = reg.X();
+    // We should never write into sp here.
+    CHECK_NE(xn, sp);
+    if (!xn.IsZero()) {
+      if (!first.is_valid()) {
+        // This is the first register we've hit, so construct the literal.
+        __ Mov(xn, value);
+        first = xn;
+      } else {
+        // We've already loaded the literal, so re-use the value already
+        // loaded into the first register we hit.
+        __ Mov(xn, first);
       }
     }
   }
 }
 
-
-void ClobberFP(MacroAssembler* masm, RegList reg_list, double const value) {
+void ClobberFP(MacroAssembler* masm, DoubleRegList reg_list,
+               double const value) {
   VRegister first = NoVReg;
-  for (unsigned i = 0; i < kNumberOfVRegisters; i++) {
-    if (reg_list & (1ULL << i)) {
-      VRegister dn = VRegister::Create(i, kDRegSizeInBits);
-      if (!first.is_valid()) {
-        // This is the first register we've hit, so construct the literal.
-        __ Fmov(dn, value);
-        first = dn;
-      } else {
-        // We've already loaded the literal, so re-use the value already loaded
-        // into the first register we hit.
-        __ Fmov(dn, first);
-      }
+  for (VRegister reg : reg_list) {
+    VRegister dn = reg.D();
+    if (!first.is_valid()) {
+      // This is the first register we've hit, so construct the literal.
+      __ Fmov(dn, value);
+      first = dn;
+    } else {
+      // We've already loaded the literal, so re-use the value already loaded
+      // into the first register we hit.
+      __ Fmov(dn, first);
     }
   }
 }
 
-
 void Clobber(MacroAssembler* masm, CPURegList reg_list) {
   if (reg_list.type() == CPURegister::kRegister) {
     // This will always clobber X registers.
-    Clobber(masm, reg_list.list());
+    Clobber(masm, RegList::FromBits(static_cast<uint32_t>(reg_list.bits())));
   } else if (reg_list.type() == CPURegister::kVRegister) {
     // This will always clobber D registers.
-    ClobberFP(masm, reg_list.list());
+    ClobberFP(masm,
+              DoubleRegList::FromBits(static_cast<uint32_t>(reg_list.bits())));
   } else {
     UNREACHABLE();
   }
@@ -340,10 +334,10 @@ void Clobber(MacroAssembler* masm, CPURegList reg_list) {
 
 void RegisterDump::Dump(MacroAssembler* masm) {
   // Ensure that we don't unintentionally clobber any registers.
-  RegList old_tmp_list = masm->TmpList()->list();
-  RegList old_fptmp_list = masm->FPTmpList()->list();
-  masm->TmpList()->set_list(0);
-  masm->FPTmpList()->set_list(0);
+  uint64_t old_tmp_list = masm->TmpList()->bits();
+  uint64_t old_fptmp_list = masm->FPTmpList()->bits();
+  masm->TmpList()->set_bits(0);
+  masm->FPTmpList()->set_bits(0);
 
   // Preserve some temporary registers.
   Register dump_base = x0;
@@ -443,8 +437,8 @@ void RegisterDump::Dump(MacroAssembler* masm) {
   __ Ldr(dump2, MemOperand(dump2, dump2.code() * kXRegSize));
 
   // Restore the MacroAssembler's scratch registers.
-  masm->TmpList()->set_list(old_tmp_list);
-  masm->FPTmpList()->set_list(old_fptmp_list);
+  masm->TmpList()->set_bits(old_tmp_list);
+  masm->FPTmpList()->set_bits(old_fptmp_list);
 
   completed_ = true;
 }
diff --git a/test/cctest/test-utils-arm64.h b/test/cctest/test-utils-arm64.h
index 305f6bd938..5143dcf0d8 100644
--- a/test/cctest/test-utils-arm64.h
+++ b/test/cctest/test-utils-arm64.h
@@ -229,8 +229,9 @@ RegList PopulateRegisterArray(Register* w, Register* x, Register* r,
                               int reg_size, int reg_count, RegList allowed);
 
 // As PopulateRegisterArray, but for floating-point registers.
-RegList PopulateVRegisterArray(VRegister* s, VRegister* d, VRegister* v,
-                               int reg_size, int reg_count, RegList allowed);
+DoubleRegList PopulateVRegisterArray(VRegister* s, VRegister* d, VRegister* v,
+                                     int reg_size, int reg_count,
+                                     DoubleRegList allowed);
 
 // Ovewrite the contents of the specified registers. This enables tests to
 // check that register contents are written in cases where it's likely that the
@@ -244,7 +245,7 @@ void Clobber(MacroAssembler* masm, RegList reg_list,
              uint64_t const value = 0xFEDCBA9876543210UL);
 
 // As Clobber, but for FP registers.
-void ClobberFP(MacroAssembler* masm, RegList reg_list,
+void ClobberFP(MacroAssembler* masm, DoubleRegList reg_list,
                double const value = kFP64SignallingNaN);
 
 // As Clobber, but for a CPURegList with either FP or integer registers. When
diff --git a/test/unittests/compiler/backend/instruction-selector-unittest.h b/test/unittests/compiler/backend/instruction-selector-unittest.h
index 3af4f7b587..5013377530 100644
--- a/test/unittests/compiler/backend/instruction-selector-unittest.h
+++ b/test/unittests/compiler/backend/instruction-selector-unittest.h
@@ -115,8 +115,8 @@ class InstructionSelectorTest : public TestWithNativeContextAndZone {
                             kSystemPointerSize);
       }
 
-      const RegList kCalleeSaveRegisters = 0;
-      const RegList kCalleeSaveFPRegisters = 0;
+      const RegList kCalleeSaveRegisters;
+      const DoubleRegList kCalleeSaveFPRegisters;
 
       MachineType target_type = MachineType::Pointer();
       LinkageLocation target_loc = LinkageLocation::ForAnyRegister();
diff --git a/test/unittests/compiler/linkage-tail-call-unittest.cc b/test/unittests/compiler/linkage-tail-call-unittest.cc
index 3c76ac0701..cd9236adc4 100644
--- a/test/unittests/compiler/linkage-tail-call-unittest.cc
+++ b/test/unittests/compiler/linkage-tail-call-unittest.cc
@@ -43,14 +43,14 @@ class LinkageTailCall : public TestWithZone {
         locations,  // location_sig
         stack_arguments,
         Operator::kNoProperties,   // properties
-        0,                         // callee-saved
-        0,                         // callee-saved fp
+        kNoCalleeSaved,            // callee-saved
+        kNoCalleeSavedFp,          // callee-saved fp
         CallDescriptor::kNoFlags,  // flags,
         "", StackArgumentOrder::kDefault,
 #if V8_ENABLE_WEBASSEMBLY
         nullptr,  // wasm function sig
 #endif
-        0,  // allocatable_registers
+        RegList{},  // allocatable_registers
         stack_returns);
   }
 
-- 
2.35.1


From f28435517481ae4c40bc631078c999830ba3ff0c Mon Sep 17 00:00:00 2001
From: JiQiu <qiuji@iscas.ac.cn>
Date: Wed, 16 Aug 2023 08:53:33 +0800
Subject: [PATCH] [riscv][codegen] Fix RiscvCvtSD and CvtDS codegen

1. Add code generation for riscv32
2. When the convert source operand is NaN, keep the sign bit
3. Reopen sign-bit related test case
4. Cleanup macro definitions in simulator

Bug: v8:14269

Change-Id: Id7bdef062a62b69b6d36568cb8b0e64ceab03ce4
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4781027
Auto-Submit: Ji Qiu <qiuji@iscas.ac.cn>
Reviewed-by: Yahan Lu <yahan@iscas.ac.cn>
Commit-Queue: Ji Qiu <qiuji@iscas.ac.cn>
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Reviewed-by: Thibaud Michaud <thibaudm@chromium.org>
Cr-Commit-Position: refs/heads/main@{#89590}
---
 .../backend/riscv/code-generator-riscv.cc     | 42 +++++++++
 src/execution/riscv/simulator-riscv.cc        | 90 ++++++++++---------
 test/cctest/cctest.status                     |  8 +-
 3 files changed, 94 insertions(+), 46 deletions(-)

diff --git a/src/compiler/backend/riscv/code-generator-riscv.cc b/src/compiler/backend/riscv/code-generator-riscv.cc
index 54b75ed3cc4..c129bb4efae 100644
--- a/src/compiler/backend/riscv/code-generator-riscv.cc
+++ b/src/compiler/backend/riscv/code-generator-riscv.cc
@@ -1540,11 +1540,53 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       __ FPUCanonicalizeNaN(i.OutputDoubleRegister(), i.InputDoubleRegister(0));
       break;
     case kRiscvCvtSD: {
+      Label done;
+      __ feq_d(kScratchReg, i.InputDoubleRegister(0), i.InputDoubleRegister(0));
+#if V8_TARGET_ARCH_RISCV64
+      __ fmv_x_d(kScratchReg2, i.InputDoubleRegister(0));
+#elif V8_TARGET_ARCH_RISCV32
+      __ StoreDouble(i.InputDoubleRegister(0),
+                     MemOperand(sp, -kDoubleSize));  // store whole 64 bit
+#endif
       __ fcvt_s_d(i.OutputDoubleRegister(), i.InputDoubleRegister(0));
+      __ Branch(&done, ne, kScratchReg, Operand(zero_reg));
+#if V8_TARGET_ARCH_RISCV64
+      __ And(kScratchReg2, kScratchReg2, Operand(0x8000000000000000));
+      __ srai(kScratchReg2, kScratchReg2, 32);
+      __ fmv_d_x(kScratchDoubleReg, kScratchReg2);
+#elif V8_TARGET_ARCH_RISCV32
+      __ Lw(kScratchReg2,
+            MemOperand(sp,
+                       -kDoubleSize /
+                           2));  // only load the high half to get the sign bit
+      __ fmv_w_x(kScratchDoubleReg, kScratchReg2);
+#endif
+      __ fsgnj_s(i.OutputDoubleRegister(), i.OutputDoubleRegister(),
+                 kScratchDoubleReg);
+      __ bind(&done);
       break;
     }
     case kRiscvCvtDS: {
+      Label done;
+      __ feq_s(kScratchReg, i.InputDoubleRegister(0), i.InputDoubleRegister(0));
+#if V8_TARGET_ARCH_RISCV64
+      __ fmv_x_d(kScratchReg2, i.InputDoubleRegister(0));
+#elif V8_TARGET_ARCH_RISCV32
+      __ StoreFloat(i.InputDoubleRegister(0), MemOperand(sp, -kFloatSize));
+#endif
       __ fcvt_d_s(i.OutputDoubleRegister(), i.InputSingleRegister(0));
+      __ Branch(&done, ne, kScratchReg, Operand(zero_reg));
+#if V8_TARGET_ARCH_RISCV64
+      __ And(kScratchReg2, kScratchReg2, Operand(0x80000000));
+      __ slli(kScratchReg2, kScratchReg2, 32);
+      __ fmv_d_x(kScratchDoubleReg, kScratchReg2);
+#elif V8_TARGET_ARCH_RISCV32
+      __ Lw(kScratchReg2, MemOperand(sp, -kFloatSize));
+      __ fcvt_d_w(kScratchDoubleReg, kScratchReg2);
+#endif
+      __ fsgnj_d(i.OutputDoubleRegister(), i.OutputDoubleRegister(),
+                 kScratchDoubleReg);
+      __ bind(&done);
       break;
     }
     case kRiscvCvtDW: {
diff --git a/src/execution/riscv/simulator-riscv.cc b/src/execution/riscv/simulator-riscv.cc
index 886d5ceebfa..63cdb7e2eeb 100644
--- a/src/execution/riscv/simulator-riscv.cc
+++ b/src/execution/riscv/simulator-riscv.cc
@@ -2758,7 +2758,7 @@ void Simulator::TraceRegWr(int64_t value, TraceType t) {
   }
 }
 
-#elif V8_TARGET_ARCH_32_BIT
+#elif V8_TARGET_ARCH_RISCV32
 template <typename T>
 void Simulator::TraceRegWr(T value, TraceType t) {
   if (v8_flags.trace_sim) {
@@ -2904,8 +2904,9 @@ void Simulator::TraceMemWr(sreg_t addr, T value) {
         } else {
           SNPrintF(trace_buf_,
                    "                    (%" PRIu64
-                   ")    flt:%e --> [addr: %" REGIx_FORMAT "]",
-                   icount_, static_cast<float>(value), addr);
+                   ")    flt:%e bit:%x --> [addr: %" REGIx_FORMAT "]",
+                   icount_, static_cast<float>(value),
+                   base::bit_cast<int32_t, float>(value), addr);
         }
         break;
       case 8:
@@ -2918,8 +2919,13 @@ void Simulator::TraceMemWr(sreg_t addr, T value) {
         } else {
           SNPrintF(trace_buf_,
                    "                    (%" PRIu64
-                   ")    dbl:%e --> [addr: %" REGIx_FORMAT "]",
-                   icount_, static_cast<double>(value), addr);
+#if V8_TARGET_ARCH_RISCV64
+                   ")    dbl:%e bit:%lx --> [addr: %" REGIx_FORMAT "]",
+#elif V8_TARGET_ARCH_RISCV32
+                   ")    dbl:%e bit:%llx --> [addr: %" REGIx_FORMAT "]",
+#endif
+                   icount_, static_cast<double>(value),
+                   base::bit_cast<int64_t, double>(value), addr);
         }
         break;
       default:
@@ -2932,8 +2938,12 @@ void Simulator::TraceMemWrDouble(sreg_t addr, double value) {
   if (v8_flags.trace_sim) {
     SNPrintF(trace_buf_,
              "                    (%" PRIu64
-             ")    dbl:%e --> [addr: %" REGIx_FORMAT "]",
-             icount_, value, addr);
+#if V8_TARGET_ARCH_RISCV64
+             ")    dbl:%e bit:%lx--> [addr: %" REGIx_FORMAT "]",
+#elif V8_TARGET_ARCH_RISCV32
+             ")    dbl:%e bit:%llx--> [addr: %" REGIx_FORMAT "]",
+#endif
+             icount_, value, base::bit_cast<int64_t, double>(value), addr);
   }
 }
 // RISCV Memory Read/Write functions
@@ -3500,7 +3510,7 @@ void Simulator::DecodeRVRType() {
       set_rd(rs1() & rs2());
       break;
     }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
     case RO_ADDW: {
       set_rd(sext32(rs1() + rs2()));
       break;
@@ -3521,7 +3531,7 @@ void Simulator::DecodeRVRType() {
       set_rd(sext32(int32_t(rs1()) >> (rs2() & 0x1F)));
       break;
     }
-#endif /* V8_TARGET_ARCH_64_BIT */
+#endif /* V8_TARGET_ARCH_RISCV64 */
       // TODO(riscv): Add RISCV M extension macro
     case RO_MUL: {
       set_rd(rs1() * rs2());
@@ -3583,7 +3593,7 @@ void Simulator::DecodeRVRType() {
       }
       break;
     }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
     case RO_MULW: {
       set_rd(sext32(sext32(rs1()) * sext32(rs2())));
       break;
@@ -3632,7 +3642,7 @@ void Simulator::DecodeRVRType() {
       }
       break;
     }
-#endif /*V8_TARGET_ARCH_64_BIT*/
+#endif /*V8_TARGET_ARCH_RISCV64*/
       // TODO(riscv): End Add RISCV M extension macro
     default: {
       switch (instr_.BaseOpcode()) {
@@ -4009,7 +4019,7 @@ void Simulator::DecodeRVRAType() {
           instr_.instr(), WORD)));
       break;
     }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
     case RO_LR_D: {
       base::MutexGuard lock_guard(&GlobalMonitor::Get()->mutex);
       int64_t addr = rs1();
@@ -4089,7 +4099,7 @@ void Simulator::DecodeRVRAType() {
           instr_.instr(), DWORD));
       break;
     }
-#endif /*V8_TARGET_ARCH_64_BIT*/
+#endif /*V8_TARGET_ARCH_RISCV64*/
     // TODO(riscv): End Add macro for RISCV A extension
     default: {
       UNSUPPORTED();
@@ -4226,7 +4236,7 @@ void Simulator::DecodeRVRFPType() {
               RoundF2IHelper<uint32_t>(original_val, instr_.RoundMode())));
           break;
         }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
         case 0b00010: {  // RO_FCVT_L_S
           set_rd(RoundF2IHelper<int64_t>(original_val, instr_.RoundMode()));
           break;
@@ -4235,7 +4245,7 @@ void Simulator::DecodeRVRFPType() {
           set_rd(RoundF2IHelper<uint64_t>(original_val, instr_.RoundMode()));
           break;
         }
-#endif /* V8_TARGET_ARCH_64_BIT */
+#endif /* V8_TARGET_ARCH_RISCV64 */
         default: {
           UNSUPPORTED();
         }
@@ -4293,7 +4303,7 @@ void Simulator::DecodeRVRFPType() {
           set_frd(static_cast<float>((uint32_t)rs1()));
           break;
         }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
         case 0b00010: {  // RO_FCVT_S_L
           set_frd(static_cast<float>((int64_t)rs1()));
           break;
@@ -4302,7 +4312,7 @@ void Simulator::DecodeRVRFPType() {
           set_frd(static_cast<float>((uint64_t)rs1()));
           break;
         }
-#endif /* V8_TARGET_ARCH_64_BIT */
+#endif /* V8_TARGET_ARCH_RISCV64 */
         default: {
           UNSUPPORTED();
         }
@@ -4477,12 +4487,12 @@ void Simulator::DecodeRVRFPType() {
           set_rd(FclassHelper(drs1()));
           break;
         }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
         case 0b000: {  // RO_FMV_X_D
           set_rd(base::bit_cast<int64_t>(drs1()));
           break;
         }
-#endif /* V8_TARGET_ARCH_64_BIT */
+#endif /* V8_TARGET_ARCH_RISCV64 */
         default: {
           UNSUPPORTED();
         }
@@ -4501,7 +4511,7 @@ void Simulator::DecodeRVRFPType() {
               RoundF2IHelper<uint32_t>(original_val, instr_.RoundMode())));
           break;
         }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
         case 0b00010: {  // RO_FCVT_L_D
           set_rd(RoundF2IHelper<int64_t>(original_val, instr_.RoundMode()));
           break;
@@ -4510,7 +4520,7 @@ void Simulator::DecodeRVRFPType() {
           set_rd(RoundF2IHelper<uint64_t>(original_val, instr_.RoundMode()));
           break;
         }
-#endif /* V8_TARGET_ARCH_64_BIT */
+#endif /* V8_TARGET_ARCH_RISCV64 */
         default: {
           UNSUPPORTED();
         }
@@ -4527,7 +4537,7 @@ void Simulator::DecodeRVRFPType() {
           set_drd((uint32_t)rs1());
           break;
         }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
         case 0b00010: {  // RO_FCVT_D_L
           set_drd((int64_t)rs1());
           break;
@@ -4536,14 +4546,14 @@ void Simulator::DecodeRVRFPType() {
           set_drd((uint64_t)rs1());
           break;
         }
-#endif /* V8_TARGET_ARCH_64_BIT */
+#endif /* V8_TARGET_ARCH_RISCV64 */
         default: {
           UNSUPPORTED();
         }
       }
       break;
     }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
     case RO_FMV_D_X: {
       if (instr_.Funct3Value() == 0b000 && instr_.Rs2Value() == 0b00000) {
         // Since FMV preserves source bit-pattern, no need to canonize
@@ -4553,7 +4563,7 @@ void Simulator::DecodeRVRFPType() {
       }
       break;
     }
-#endif /* V8_TARGET_ARCH_64_BIT */
+#endif /* V8_TARGET_ARCH_RISCV64 */
     default: {
       UNSUPPORTED();
     }
@@ -4888,7 +4898,7 @@ void Simulator::DecodeRVIType() {
       TraceMemRd(addr, val, get_register(rd_reg()));
       break;
     }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
     case RO_LWU: {
       int64_t addr = rs1() + imm12();
       uint32_t val = ReadMem<uint32_t>(addr, instr_.instr());
@@ -4903,7 +4913,7 @@ void Simulator::DecodeRVIType() {
       TraceMemRd(addr, val, get_register(rd_reg()));
       break;
     }
-#endif /*V8_TARGET_ARCH_64_BIT*/
+#endif /*V8_TARGET_ARCH_RISCV64*/
     case RO_ADDI: {
       set_rd(sext_xlen(rs1() + imm12()));
       break;
@@ -4943,7 +4953,7 @@ void Simulator::DecodeRVIType() {
       }
       break;
     }
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
     case RO_ADDIW: {
       set_rd(sext32(rs1() + imm12()));
       break;
@@ -4960,7 +4970,7 @@ void Simulator::DecodeRVIType() {
       }
       break;
     }
-#endif /*V8_TARGET_ARCH_64_BIT*/
+#endif /*V8_TARGET_ARCH_RISCV64*/
     case RO_FENCE: {
       // DO nothing in sumulator
       break;
@@ -5065,11 +5075,11 @@ void Simulator::DecodeRVSType() {
     case RO_SW:
       WriteMem<uint32_t>(rs1() + s_imm12(), (uint32_t)rs2(), instr_.instr());
       break;
-#ifdef V8_TARGET_ARCH_64_BIT
+#ifdef V8_TARGET_ARCH_RISCV64
     case RO_SD:
       WriteMem<uint64_t>(rs1() + s_imm12(), (uint64_t)rs2(), instr_.instr());
       break;
-#endif /*V8_TARGET_ARCH_64_BIT*/
+#endif /*V8_TARGET_ARCH_RISCV64*/
     // TODO(riscv): use F Extension macro block
     case RO_FSW: {
       WriteMem<Float32>(rs1() + s_imm12(), get_fpu_register_Float32(rs2_reg()),
@@ -5207,7 +5217,7 @@ void Simulator::DecodeCAType() {
     case RO_C_AND:
       set_rvc_rs1s(rvc_rs1s() & rvc_rs2s());
       break;
-#if V8_TARGET_ARCH_64_BIT
+#if V8_TARGET_ARCH_RISCV64
     case RO_C_SUBW:
       set_rvc_rs1s(sext32(rvc_rs1s() - rvc_rs2s()));
       break;
@@ -5228,7 +5238,7 @@ void Simulator::DecodeCIType() {
       else  // c.addi
         set_rvc_rd(sext_xlen(rvc_rs1() + rvc_imm6()));
       break;
-#if V8_TARGET_ARCH_64_BIT
+#if V8_TARGET_ARCH_RISCV64
     case RO_C_ADDIW:
       set_rvc_rd(sext32(rvc_rs1() + rvc_imm6()));
       break;
@@ -5259,7 +5269,7 @@ void Simulator::DecodeCIType() {
                        get_fpu_register(rvc_frd_reg()));
       break;
     }
-#if V8_TARGET_ARCH_64_BIT
+#if V8_TARGET_ARCH_RISCV64
     case RO_C_LWSP: {
       sreg_t addr = get_register(sp) + rvc_imm6_lwsp();
       int64_t val = ReadMem<int32_t>(addr, instr_.instr());
@@ -5274,7 +5284,7 @@ void Simulator::DecodeCIType() {
       TraceMemRd(addr, val, get_register(rvc_rd_reg()));
       break;
     }
-#elif V8_TARGET_ARCH_32_BIT
+#elif V8_TARGET_ARCH_RISCV32
     case RO_C_FLWSP: {
       sreg_t addr = get_register(sp) + rvc_imm6_ldsp();
       uint32_t val = ReadMem<uint32_t>(addr, instr_.instr());
@@ -5315,7 +5325,7 @@ void Simulator::DecodeCSSType() {
                         instr_.instr());
       break;
     }
-#if V8_TARGET_ARCH_32_BIT
+#if V8_TARGET_ARCH_RISCV32
     case RO_C_FSWSP: {
       sreg_t addr = get_register(sp) + rvc_imm6_sdsp();
       WriteMem<Float32>(addr, get_fpu_register_Float32(rvc_rs2_reg()),
@@ -5328,7 +5338,7 @@ void Simulator::DecodeCSSType() {
       WriteMem<int32_t>(addr, (int32_t)rvc_rs2(), instr_.instr());
       break;
     }
-#if V8_TARGET_ARCH_64_BIT
+#if V8_TARGET_ARCH_RISCV64
     case RO_C_SDSP: {
       sreg_t addr = get_register(sp) + rvc_imm6_sdsp();
       WriteMem<int64_t>(addr, (int64_t)rvc_rs2(), instr_.instr());
@@ -5355,7 +5365,7 @@ void Simulator::DecodeCLType() {
       set_rvc_drs2s(Float64::FromBits(val), false);
       break;
     }
-#if V8_TARGET_ARCH_64_BIT
+#if V8_TARGET_ARCH_RISCV64
     case RO_C_LD: {
       sreg_t addr = rvc_rs1s() + rvc_imm5_d();
       int64_t val = ReadMem<int64_t>(addr, instr_.instr());
@@ -5363,7 +5373,7 @@ void Simulator::DecodeCLType() {
       TraceMemRd(addr, val, get_register(rvc_rs2s_reg()));
       break;
     }
-#elif V8_TARGET_ARCH_32_BIT
+#elif V8_TARGET_ARCH_RISCV32
     case RO_C_FLW: {
       sreg_t addr = rvc_rs1s() + rvc_imm5_d();
       uint32_t val = ReadMem<uint32_t>(addr, instr_.instr());
@@ -5383,7 +5393,7 @@ void Simulator::DecodeCSType() {
       WriteMem<int32_t>(addr, (int32_t)rvc_rs2s(), instr_.instr());
       break;
     }
-#if V8_TARGET_ARCH_64_BIT
+#if V8_TARGET_ARCH_RISCV64
     case RO_C_SD: {
       sreg_t addr = rvc_rs1s() + rvc_imm5_d();
       WriteMem<int64_t>(addr, (int64_t)rvc_rs2s(), instr_.instr());
diff --git a/test/cctest/cctest.status b/test/cctest/cctest.status
index d8e478e1a55..259f5ad602c 100644
--- a/test/cctest/cctest.status
+++ b/test/cctest/cctest.status
@@ -383,14 +383,10 @@
   'test-run-load-store/RunUnalignedLoadStoreZeroExtend64': [SKIP],
   'test-run-load-store/RunLoadStoreZeroExtend64': [SKIP],
 
-  # On riscv, if the result of a floating-point operation is NaN, it is the canonical
-  # NaN. So skip thes cases.
-  'test-run-wasm/RunWasmLiftoff_F32CopySign': [SKIP],
-  'test-run-wasm/RunWasmLiftoff_Float32Neg': [SKIP],
+  # According to riscv's NaN generation and propagation scheme, the payload
+  # is not guaranteed. So the test fails when src bits has payload.
   'test-run-wasm/RunWasmLiftoff_F32ReinterpretI32': [SKIP],
-  'test-run-wasm/RunWasmTurbofan_F32CopySign': [SKIP],
   'test-run-wasm/RunWasmTurbofan_F32ReinterpretI32': [SKIP],
-  'test-run-wasm/RunWasmTurbofan_Float32Neg': [SKIP],
 }],  # 'arch == riscv64'
 
 ##############################################################################
-- 
2.35.1


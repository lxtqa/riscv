From aec48e519ceff3e448ebea9350e06db668276547 Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Wed, 10 May 2023 19:44:48 +0200
Subject: [PATCH] [regexp] Use uint8_t instead of byte

Byte is an alias for the standard uint8_t type (defined in
src/common/globals.h).
For readability, avoid the alias and use the uint8_t directly.

R=jgruber@chromium.org

Change-Id: I1c1ad57813e1287dc480e14639542754091314ad
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4519269
Reviewed-by: Jakob Linke <jgruber@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#87580}
---
 src/regexp/arm/regexp-macro-assembler-arm.cc  |  4 +-
 .../arm64/regexp-macro-assembler-arm64.cc     |  3 +-
 .../arm64/regexp-macro-assembler-arm64.h      |  4 +-
 .../ia32/regexp-macro-assembler-ia32.cc       |  4 +-
 .../loong64/regexp-macro-assembler-loong64.cc |  4 +-
 .../mips64/regexp-macro-assembler-mips64.cc   |  4 +-
 src/regexp/ppc/regexp-macro-assembler-ppc.cc  |  6 +-
 src/regexp/regexp-bytecode-generator.cc       |  2 +-
 src/regexp/regexp-bytecode-generator.h        |  4 +-
 src/regexp/regexp-bytecode-peephole.cc        | 56 ++++++++++---------
 src/regexp/regexp-bytecode-peephole.h         |  5 +-
 src/regexp/regexp-bytecodes.cc                |  7 ++-
 src/regexp/regexp-bytecodes.h                 |  5 +-
 src/regexp/regexp-interpreter.cc              | 28 +++++-----
 src/regexp/regexp-macro-assembler.cc          | 20 +++----
 src/regexp/regexp-macro-assembler.h           | 14 ++---
 src/regexp/regexp-stack.cc                    |  2 +-
 src/regexp/regexp-stack.h                     |  8 +--
 .../riscv/regexp-macro-assembler-riscv.cc     |  8 +--
 .../s390/regexp-macro-assembler-s390.cc       |  6 +-
 src/regexp/x64/regexp-macro-assembler-x64.cc  |  4 +-
 21 files changed, 102 insertions(+), 96 deletions(-)

diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index 4cf2fcf8d54..3a671a3f249 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -1218,8 +1218,8 @@ int RegExpMacroAssemblerARM::CheckStackGuardState(Address* return_address,
           frame_entry<int>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.cc b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
index fe1b0f6e041..ea315c36f32 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.cc
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
@@ -1432,7 +1432,7 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 
 int RegExpMacroAssemblerARM64::CheckStackGuardState(
     Address* return_address, Address raw_code, Address re_frame,
-    int start_index, const byte** input_start, const byte** input_end) {
+    int start_index, const uint8_t** input_start, const uint8_t** input_end) {
   InstructionStream re_code = InstructionStream::cast(Object(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset), start_index,
@@ -1443,7 +1443,6 @@ int RegExpMacroAssemblerARM64::CheckStackGuardState(
       input_end);
 }
 
-
 void RegExpMacroAssemblerARM64::CheckPosition(int cp_offset,
                                               Label* on_outside_input) {
   if (cp_offset >= 0) {
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.h b/src/regexp/arm64/regexp-macro-assembler-arm64.h
index a5164472b71..86f4a6e20ca 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.h
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.h
@@ -94,8 +94,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM64
   // {raw_code} is an Address because this is called via ExternalReference.
   static int CheckStackGuardState(Address* return_address, Address raw_code,
                                   Address re_frame, int start_offset,
-                                  const byte** input_start,
-                                  const byte** input_end);
+                                  const uint8_t** input_start,
+                                  const uint8_t** input_end);
 
  private:
   static constexpr int kFramePointerOffset = 0;
diff --git a/src/regexp/ia32/regexp-macro-assembler-ia32.cc b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
index 70037dc169c..2f2075d5590 100644
--- a/src/regexp/ia32/regexp-macro-assembler-ia32.cc
+++ b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
@@ -1255,8 +1255,8 @@ int RegExpMacroAssemblerIA32::CheckStackGuardState(Address* return_address,
           frame_entry<int>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 
diff --git a/src/regexp/loong64/regexp-macro-assembler-loong64.cc b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
index 232c868ee0a..bc7657c051c 100644
--- a/src/regexp/loong64/regexp-macro-assembler-loong64.cc
+++ b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
@@ -1212,8 +1212,8 @@ int64_t RegExpMacroAssemblerLOONG64::CheckStackGuardState(
           frame_entry<int64_t>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 MemOperand RegExpMacroAssemblerLOONG64::register_location(int register_index) {
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.cc b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
index eac2c7c1011..7e8a2646df5 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.cc
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
@@ -1263,8 +1263,8 @@ int64_t RegExpMacroAssemblerMIPS::CheckStackGuardState(Address* return_address,
           frame_entry<int64_t>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 MemOperand RegExpMacroAssemblerMIPS::register_location(int register_index) {
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index f67fd569353..4bb0a48529d 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -85,7 +85,7 @@ namespace internal {
  *              Address end,
  *              int* capture_output_array,
  *              int num_capture_registers,
- *              byte* stack_area_base,
+ *              uint8_t* stack_area_base,
  *              bool direct_call = false,
  *              Isolate* isolate,
  *              Address regexp);
@@ -1292,8 +1292,8 @@ int RegExpMacroAssemblerPPC::CheckStackGuardState(Address* return_address,
           frame_entry<intptr_t>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 
diff --git a/src/regexp/regexp-bytecode-generator.cc b/src/regexp/regexp-bytecode-generator.cc
index 61225642e23..c3813219dda 100644
--- a/src/regexp/regexp-bytecode-generator.cc
+++ b/src/regexp/regexp-bytecode-generator.cc
@@ -393,7 +393,7 @@ Handle<HeapObject> RegExpBytecodeGenerator::GetCode(Handle<String> source) {
 
 int RegExpBytecodeGenerator::length() { return pc_; }
 
-void RegExpBytecodeGenerator::Copy(byte* a) {
+void RegExpBytecodeGenerator::Copy(uint8_t* a) {
   MemCopy(a, buffer_.data(), length());
 }
 
diff --git a/src/regexp/regexp-bytecode-generator.h b/src/regexp/regexp-bytecode-generator.h
index d3ed62b8850..2ac09991c4b 100644
--- a/src/regexp/regexp-bytecode-generator.h
+++ b/src/regexp/regexp-bytecode-generator.h
@@ -109,11 +109,11 @@ class V8_EXPORT_PRIVATE RegExpBytecodeGenerator : public RegExpMacroAssembler {
   inline void Emit(uint32_t bc, int32_t arg);
   // Bytecode buffer.
   int length();
-  void Copy(byte* a);
+  void Copy(uint8_t* a);
 
   // The buffer into which code and relocation info are generated.
   static constexpr int kInitialBufferSize = 1024;
-  ZoneVector<byte> buffer_;
+  ZoneVector<uint8_t> buffer_;
 
   // The program counter.
   int pc_;
diff --git a/src/regexp/regexp-bytecode-peephole.cc b/src/regexp/regexp-bytecode-peephole.cc
index e29e7ee0aff..add0dba7384 100644
--- a/src/regexp/regexp-bytecode-peephole.cc
+++ b/src/regexp/regexp-bytecode-peephole.cc
@@ -115,7 +115,7 @@ class BytecodeSequenceNode {
   // Checks if the current node is valid for the sequence. I.e. all conditions
   // set by IfArgumentEqualsOffset and IfArgumentEquals are fulfilled by this
   // node for the actual bytecode sequence.
-  bool CheckArguments(const byte* bytecode, int pc);
+  bool CheckArguments(const uint8_t* bytecode, int pc);
   // Returns whether this node marks the end of a valid sequence (i.e. can be
   // replaced with an optimized bytecode).
   bool IsSequence() const;
@@ -176,10 +176,10 @@ class RegExpBytecodePeephole {
   // Parses bytecode and fills the internal buffer with the potentially
   // optimized bytecode. Returns true when optimizations were performed, false
   // otherwise.
-  bool OptimizeBytecode(const byte* bytecode, int length);
+  bool OptimizeBytecode(const uint8_t* bytecode, int length);
   // Copies the internal bytecode buffer to another buffer. The caller is
   // responsible for allocating/freeing the memory.
-  void CopyOptimizedBytecode(byte* to_address) const;
+  void CopyOptimizedBytecode(uint8_t* to_address) const;
   int Length() const;
 
  private:
@@ -189,12 +189,12 @@ class RegExpBytecodePeephole {
   BytecodeSequenceNode& CreateSequence(int bytecode);
   // Checks for optimization candidates at pc and emits optimized bytecode to
   // the internal buffer. Returns the length of replaced bytecodes in bytes.
-  int TryOptimizeSequence(const byte* bytecode, int bytecode_length,
+  int TryOptimizeSequence(const uint8_t* bytecode, int bytecode_length,
                           int start_pc);
   // Emits optimized bytecode to the internal buffer. start_pc points to the
   // start of the sequence in bytecode and last_node is the last
   // BytecodeSequenceNode of the matching sequence found.
-  void EmitOptimization(int start_pc, const byte* bytecode,
+  void EmitOptimization(int start_pc, const uint8_t* bytecode,
                         const BytecodeSequenceNode& last_node);
   // Adds a relative jump source fixup at pos.
   // Jump source fixups are used to find offsets in the new bytecode that
@@ -217,14 +217,14 @@ class RegExpBytecodePeephole {
   void EmitValue(T value);
   template <typename T>
   void OverwriteValue(int offset, T value);
-  void CopyRangeToOutput(const byte* orig_bytecode, int start, int length);
-  void SetRange(byte value, int count);
-  void EmitArgument(int start_pc, const byte* bytecode,
+  void CopyRangeToOutput(const uint8_t* orig_bytecode, int start, int length);
+  void SetRange(uint8_t value, int count);
+  void EmitArgument(int start_pc, const uint8_t* bytecode,
                     BytecodeArgumentMapping arg);
   int pc() const;
   Zone* zone() const;
 
-  ZoneVector<byte> optimized_bytecode_buffer_;
+  ZoneVector<uint8_t> optimized_bytecode_buffer_;
   BytecodeSequenceNode* sequences_;
   // Jumps used in old bytecode.
   // Key: Jump source (offset where destination is stored in old bytecode)
@@ -255,15 +255,15 @@ class RegExpBytecodePeephole {
 };
 
 template <typename T>
-T GetValue(const byte* buffer, int pos) {
+T GetValue(const uint8_t* buffer, int pos) {
   DCHECK(IsAligned(reinterpret_cast<Address>(buffer + pos), alignof(T)));
   return *reinterpret_cast<const T*>(buffer + pos);
 }
 
-int32_t GetArgumentValue(const byte* bytecode, int offset, int length) {
+int32_t GetArgumentValue(const uint8_t* bytecode, int offset, int length) {
   switch (length) {
     case 1:
-      return GetValue<byte>(bytecode, offset);
+      return GetValue<uint8_t>(bytecode, offset);
     case 2:
       return GetValue<int16_t>(bytecode, offset);
     case 4:
@@ -386,7 +386,7 @@ BytecodeSequenceNode& BytecodeSequenceNode::IgnoreArgument(
   return *this;
 }
 
-bool BytecodeSequenceNode::CheckArguments(const byte* bytecode, int pc) {
+bool BytecodeSequenceNode::CheckArguments(const uint8_t* bytecode, int pc) {
   bool is_valid = true;
   for (auto check_iter = argument_check_->begin();
        check_iter != argument_check_->end() && is_valid; check_iter++) {
@@ -616,7 +616,7 @@ void RegExpBytecodePeephole::DefineStandardSequences() {
       .IgnoreArgument(4, 4, 4);  // loop jump
 }
 
-bool RegExpBytecodePeephole::OptimizeBytecode(const byte* bytecode,
+bool RegExpBytecodePeephole::OptimizeBytecode(const uint8_t* bytecode,
                                               int length) {
   int old_pc = 0;
   bool did_optimize = false;
@@ -641,7 +641,7 @@ bool RegExpBytecodePeephole::OptimizeBytecode(const byte* bytecode,
   return did_optimize;
 }
 
-void RegExpBytecodePeephole::CopyOptimizedBytecode(byte* to_address) const {
+void RegExpBytecodePeephole::CopyOptimizedBytecode(uint8_t* to_address) const {
   MemCopy(to_address, &(*optimized_bytecode_buffer_.begin()), Length());
 }
 
@@ -654,7 +654,7 @@ BytecodeSequenceNode& RegExpBytecodePeephole::CreateSequence(int bytecode) {
   return sequences_->FollowedBy(bytecode);
 }
 
-int RegExpBytecodePeephole::TryOptimizeSequence(const byte* bytecode,
+int RegExpBytecodePeephole::TryOptimizeSequence(const uint8_t* bytecode,
                                                 int bytecode_length,
                                                 int start_pc) {
   BytecodeSequenceNode* seq_node = sequences_;
@@ -682,7 +682,8 @@ int RegExpBytecodePeephole::TryOptimizeSequence(const byte* bytecode,
 }
 
 void RegExpBytecodePeephole::EmitOptimization(
-    int start_pc, const byte* bytecode, const BytecodeSequenceNode& last_node) {
+    int start_pc, const uint8_t* bytecode,
+    const BytecodeSequenceNode& last_node) {
 #ifdef DEBUG
   int optimized_start_pc = pc();
 #endif
@@ -882,7 +883,7 @@ void RegExpBytecodePeephole::FixJump(int jump_source, int jump_destination) {
 #ifdef DEBUG
   // TODO(pthier): This check could be better if we track the bytecodes
   // actually used and check if we jump to one of them.
-  byte jump_bc = optimized_bytecode_buffer_[fixed_jump_destination];
+  uint8_t jump_bc = optimized_bytecode_buffer_[fixed_jump_destination];
   DCHECK_GT(jump_bc, 0);
   DCHECK_LT(jump_bc, kRegExpBytecodeCount);
 #endif
@@ -901,7 +902,7 @@ template <typename T>
 void RegExpBytecodePeephole::EmitValue(T value) {
   DCHECK(optimized_bytecode_buffer_.begin() + pc() ==
          optimized_bytecode_buffer_.end());
-  byte* value_byte_iter = reinterpret_cast<byte*>(&value);
+  uint8_t* value_byte_iter = reinterpret_cast<uint8_t*>(&value);
   optimized_bytecode_buffer_.insert(optimized_bytecode_buffer_.end(),
                                     value_byte_iter,
                                     value_byte_iter + sizeof(T));
@@ -909,14 +910,14 @@ void RegExpBytecodePeephole::EmitValue(T value) {
 
 template <typename T>
 void RegExpBytecodePeephole::OverwriteValue(int offset, T value) {
-  byte* value_byte_iter = reinterpret_cast<byte*>(&value);
-  byte* value_byte_iter_end = value_byte_iter + sizeof(T);
+  uint8_t* value_byte_iter = reinterpret_cast<uint8_t*>(&value);
+  uint8_t* value_byte_iter_end = value_byte_iter + sizeof(T);
   while (value_byte_iter < value_byte_iter_end) {
     optimized_bytecode_buffer_[offset++] = *value_byte_iter++;
   }
 }
 
-void RegExpBytecodePeephole::CopyRangeToOutput(const byte* orig_bytecode,
+void RegExpBytecodePeephole::CopyRangeToOutput(const uint8_t* orig_bytecode,
                                                int start, int length) {
   DCHECK(optimized_bytecode_buffer_.begin() + pc() ==
          optimized_bytecode_buffer_.end());
@@ -925,20 +926,20 @@ void RegExpBytecodePeephole::CopyRangeToOutput(const byte* orig_bytecode,
                                     orig_bytecode + start + length);
 }
 
-void RegExpBytecodePeephole::SetRange(byte value, int count) {
+void RegExpBytecodePeephole::SetRange(uint8_t value, int count) {
   DCHECK(optimized_bytecode_buffer_.begin() + pc() ==
          optimized_bytecode_buffer_.end());
   optimized_bytecode_buffer_.insert(optimized_bytecode_buffer_.end(), count,
                                     value);
 }
 
-void RegExpBytecodePeephole::EmitArgument(int start_pc, const byte* bytecode,
+void RegExpBytecodePeephole::EmitArgument(int start_pc, const uint8_t* bytecode,
                                           BytecodeArgumentMapping arg) {
   int arg_pos = start_pc + arg.offset;
   switch (arg.length) {
     case 1:
       DCHECK_EQ(arg.new_length, arg.length);
-      EmitValue(GetValue<byte>(bytecode, arg_pos));
+      EmitValue(GetValue<uint8_t>(bytecode, arg_pos));
       break;
     case 2:
       DCHECK_EQ(arg.new_length, arg.length);
@@ -1011,8 +1012,9 @@ Zone* RegExpBytecodePeephole::zone() const { return zone_; }
 
 // static
 Handle<ByteArray> RegExpBytecodePeepholeOptimization::OptimizeBytecode(
-    Isolate* isolate, Zone* zone, Handle<String> source, const byte* bytecode,
-    int length, const ZoneUnorderedMap<int, int>& jump_edges) {
+    Isolate* isolate, Zone* zone, Handle<String> source,
+    const uint8_t* bytecode, int length,
+    const ZoneUnorderedMap<int, int>& jump_edges) {
   RegExpBytecodePeephole peephole(zone, length, jump_edges);
   bool did_optimize = peephole.OptimizeBytecode(bytecode, length);
   Handle<ByteArray> array = isolate->factory()->NewByteArray(peephole.Length());
diff --git a/src/regexp/regexp-bytecode-peephole.h b/src/regexp/regexp-bytecode-peephole.h
index f116e1ac418..d73068c2143 100644
--- a/src/regexp/regexp-bytecode-peephole.h
+++ b/src/regexp/regexp-bytecode-peephole.h
@@ -21,8 +21,9 @@ class RegExpBytecodePeepholeOptimization : public AllStatic {
   // Performs peephole optimization on the given bytecode and returns the
   // optimized bytecode.
   static Handle<ByteArray> OptimizeBytecode(
-      Isolate* isolate, Zone* zone, Handle<String> source, const byte* bytecode,
-      int length, const ZoneUnorderedMap<int, int>& jump_edges);
+      Isolate* isolate, Zone* zone, Handle<String> source,
+      const uint8_t* bytecode, int length,
+      const ZoneUnorderedMap<int, int>& jump_edges);
 };
 
 }  // namespace internal
diff --git a/src/regexp/regexp-bytecodes.cc b/src/regexp/regexp-bytecodes.cc
index 3eeceb2b141..6f90d5d620f 100644
--- a/src/regexp/regexp-bytecodes.cc
+++ b/src/regexp/regexp-bytecodes.cc
@@ -11,7 +11,8 @@
 namespace v8 {
 namespace internal {
 
-void RegExpBytecodeDisassembleSingle(const byte* code_base, const byte* pc) {
+void RegExpBytecodeDisassembleSingle(const uint8_t* code_base,
+                                     const uint8_t* pc) {
   int bytecode = *reinterpret_cast<const int32_t*>(pc) & BYTECODE_MASK;
   PrintF("%s", RegExpBytecodeName(bytecode));
 
@@ -29,14 +30,14 @@ void RegExpBytecodeDisassembleSingle(const byte* code_base, const byte* pc) {
   PrintF("\n");
 }
 
-void RegExpBytecodeDisassemble(const byte* code_base, int length,
+void RegExpBytecodeDisassemble(const uint8_t* code_base, int length,
                                const char* pattern) {
   PrintF("[generated bytecode for regexp pattern: '%s']\n", pattern);
 
   ptrdiff_t offset = 0;
 
   while (offset < length) {
-    const byte* const pc = code_base + offset;
+    const uint8_t* const pc = code_base + offset;
     PrintF("%p  %4" V8PRIxPTRDIFF "  ", pc, offset);
     RegExpBytecodeDisassembleSingle(code_base, pc);
     offset += RegExpBytecodeLength(*pc);
diff --git a/src/regexp/regexp-bytecodes.h b/src/regexp/regexp-bytecodes.h
index 8479b30bd87..3d51f116f27 100644
--- a/src/regexp/regexp-bytecodes.h
+++ b/src/regexp/regexp-bytecodes.h
@@ -250,8 +250,9 @@ inline constexpr const char* RegExpBytecodeName(int bytecode) {
   return kRegExpBytecodeNames[bytecode];
 }
 
-void RegExpBytecodeDisassembleSingle(const byte* code_base, const byte* pc);
-void RegExpBytecodeDisassemble(const byte* code_base, int length,
+void RegExpBytecodeDisassembleSingle(const uint8_t* code_base,
+                                     const uint8_t* pc);
+void RegExpBytecodeDisassemble(const uint8_t* code_base, int length,
                                const char* pattern);
 
 }  // namespace internal
diff --git a/src/regexp/regexp-interpreter.cc b/src/regexp/regexp-interpreter.cc
index 57eff39e7da..6858fbfb4c9 100644
--- a/src/regexp/regexp-interpreter.cc
+++ b/src/regexp/regexp-interpreter.cc
@@ -74,7 +74,7 @@ bool BackRefMatchesNoCase(Isolate* isolate, int from, int current, int len,
 }
 
 #ifdef DEBUG
-void MaybeTraceInterpreter(const byte* code_base, const byte* pc,
+void MaybeTraceInterpreter(const uint8_t* code_base, const uint8_t* pc,
                            int stack_depth, int current_position,
                            uint32_t current_char, int bytecode_length,
                            const char* bytecode_name) {
@@ -92,18 +92,18 @@ void MaybeTraceInterpreter(const byte* code_base, const byte* pc,
 }
 #endif  // DEBUG
 
-int32_t Load32Aligned(const byte* pc) {
+int32_t Load32Aligned(const uint8_t* pc) {
   DCHECK_EQ(0, reinterpret_cast<intptr_t>(pc) & 3);
   return *reinterpret_cast<const int32_t*>(pc);
 }
 
 // TODO(jgruber): Rename to Load16AlignedUnsigned.
-uint32_t Load16Aligned(const byte* pc) {
+uint32_t Load16Aligned(const uint8_t* pc) {
   DCHECK_EQ(0, reinterpret_cast<intptr_t>(pc) & 1);
   return *reinterpret_cast<const uint16_t*>(pc);
 }
 
-int32_t Load16AlignedSigned(const byte* pc) {
+int32_t Load16AlignedSigned(const uint8_t* pc) {
   DCHECK_EQ(0, reinterpret_cast<intptr_t>(pc) & 1);
   return *reinterpret_cast<const int16_t*>(pc);
 }
@@ -231,7 +231,8 @@ template <typename Char>
 void UpdateCodeAndSubjectReferences(
     Isolate* isolate, Handle<ByteArray> code_array,
     Handle<String> subject_string, ByteArray* code_array_out,
-    const byte** code_base_out, const byte** pc_out, String* subject_string_out,
+    const uint8_t** code_base_out, const uint8_t** pc_out,
+    String* subject_string_out,
     base::Vector<const Char>* subject_string_vector_out) {
   DisallowGarbageCollection no_gc;
 
@@ -253,8 +254,9 @@ void UpdateCodeAndSubjectReferences(
 template <typename Char>
 IrregexpInterpreter::Result HandleInterrupts(
     Isolate* isolate, RegExp::CallOrigin call_origin, ByteArray* code_array_out,
-    String* subject_string_out, const byte** code_base_out,
-    base::Vector<const Char>* subject_string_vector_out, const byte** pc_out) {
+    String* subject_string_out, const uint8_t** code_base_out,
+    base::Vector<const Char>* subject_string_vector_out,
+    const uint8_t** pc_out) {
   DisallowGarbageCollection no_gc;
 
   StackLimitCheck check(isolate);
@@ -309,7 +311,7 @@ IrregexpInterpreter::Result HandleInterrupts(
   return IrregexpInterpreter::SUCCESS;
 }
 
-bool CheckBitInTable(const uint32_t current_char, const byte* const table) {
+bool CheckBitInTable(const uint32_t current_char, const uint8_t* const table) {
   int mask = RegExpMacroAssembler::kTableMask;
   int b = table[(current_char & mask) >> kBitsPerByteLog2];
   int bit = (current_char & (kBitsPerByte - 1));
@@ -437,8 +439,8 @@ IrregexpInterpreter::Result RawMatch(
 
 #endif  // V8_USE_COMPUTED_GOTO
 
-  const byte* pc = code_array.GetDataStartAddress();
-  const byte* code_base = pc;
+  const uint8_t* pc = code_array.GetDataStartAddress();
+  const uint8_t* code_base = pc;
 
   InterpreterRegisters registers(total_register_count, output_registers,
                                  output_register_count);
@@ -453,7 +455,7 @@ IrregexpInterpreter::Result RawMatch(
 #endif
 
   while (true) {
-    const byte* next_pc = pc;
+    const uint8_t* next_pc = pc;
     int32_t insn;
     int32_t next_insn;
 #if V8_USE_COMPUTED_GOTO
@@ -971,7 +973,7 @@ IrregexpInterpreter::Result RawMatch(
     BYTECODE(SKIP_UNTIL_BIT_IN_TABLE) {
       int32_t load_offset = LoadPacked24Signed(insn);
       int32_t advance = Load16AlignedSigned(pc + 4);
-      const byte* table = pc + 8;
+      const uint8_t* table = pc + 8;
       while (IndexIsInBounds(current + load_offset, subject.length())) {
         current_char = subject[current + load_offset];
         if (CheckBitInTable(current_char, table)) {
@@ -987,7 +989,7 @@ IrregexpInterpreter::Result RawMatch(
       int32_t load_offset = LoadPacked24Signed(insn);
       int32_t advance = Load16AlignedSigned(pc + 4);
       uint16_t limit = Load16Aligned(pc + 6);
-      const byte* table = pc + 8;
+      const uint8_t* table = pc + 8;
       while (IndexIsInBounds(current + load_offset, subject.length())) {
         current_char = subject[current + load_offset];
         if (current_char > limit) {
diff --git a/src/regexp/regexp-macro-assembler.cc b/src/regexp/regexp-macro-assembler.cc
index 8a248aaed58..cab5574b2cf 100644
--- a/src/regexp/regexp-macro-assembler.cc
+++ b/src/regexp/regexp-macro-assembler.cc
@@ -284,7 +284,7 @@ bool NativeRegExpMacroAssembler::CanReadUnaligned() const {
 int NativeRegExpMacroAssembler::CheckStackGuardState(
     Isolate* isolate, int start_index, RegExp::CallOrigin call_origin,
     Address* return_address, InstructionStream re_code, Address* subject,
-    const byte** input_start, const byte** input_end) {
+    const uint8_t** input_start, const uint8_t** input_end) {
   DisallowGarbageCollection no_gc;
   Address old_pc = PointerAuthentication::AuthenticatePC(return_address, 0);
   DCHECK_LE(re_code.instruction_start(), old_pc);
@@ -403,18 +403,18 @@ int NativeRegExpMacroAssembler::Match(Handle<JSRegExp> regexp,
   int char_size_shift = is_one_byte ? 0 : 1;
 
   DisallowGarbageCollection no_gc;
-  const byte* input_start =
+  const uint8_t* input_start =
       subject_ptr.AddressOfCharacterAt(start_offset + slice_offset, no_gc);
   int byte_length = char_length << char_size_shift;
-  const byte* input_end = input_start + byte_length;
+  const uint8_t* input_end = input_start + byte_length;
   return Execute(*subject, start_offset, input_start, input_end, offsets_vector,
                  offsets_vector_length, isolate, *regexp);
 }
 
 // static
 int NativeRegExpMacroAssembler::ExecuteForTesting(
-    String input, int start_offset, const byte* input_start,
-    const byte* input_end, int* output, int output_size, Isolate* isolate,
+    String input, int start_offset, const uint8_t* input_start,
+    const uint8_t* input_end, int* output, int output_size, Isolate* isolate,
     JSRegExp regexp) {
   return Execute(input, start_offset, input_start, input_end, output,
                  output_size, isolate, regexp);
@@ -426,7 +426,7 @@ int NativeRegExpMacroAssembler::ExecuteForTesting(
 // internal methods.
 int NativeRegExpMacroAssembler::Execute(
     String input,  // This needs to be the unpacked (sliced, cons) string.
-    int start_offset, const byte* input_start, const byte* input_end,
+    int start_offset, const uint8_t* input_start, const uint8_t* input_end,
     int* output, int output_size, Isolate* isolate, JSRegExp regexp) {
   RegExpStackScope stack_scope(isolate);
 
@@ -436,9 +436,9 @@ int NativeRegExpMacroAssembler::Execute(
 
   using RegexpMatcherSig =
       // NOLINTNEXTLINE(readability/casting)
-      int(Address input_string, int start_offset, const byte* input_start,
-          const byte* input_end, int* output, int output_size, int call_origin,
-          Isolate* isolate, Address regexp);
+      int(Address input_string, int start_offset, const uint8_t* input_start,
+          const uint8_t* input_end, int* output, int output_size,
+          int call_origin, Isolate* isolate, Address regexp);
 
   auto fn = GeneratedCode<RegexpMatcherSig>::FromCode(isolate, code);
   int result = fn.Call(input.ptr(), start_offset, input_start, input_end,
@@ -459,7 +459,7 @@ int NativeRegExpMacroAssembler::Execute(
 #endif  // !COMPILING_IRREGEXP_FOR_EXTERNAL_EMBEDDER
 
 // clang-format off
-const byte NativeRegExpMacroAssembler::word_character_map[] = {
+const uint8_t NativeRegExpMacroAssembler::word_character_map[] = {
     0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u,
     0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u,
     0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u, 0x00u,
diff --git a/src/regexp/regexp-macro-assembler.h b/src/regexp/regexp-macro-assembler.h
index 2ba9e2d28d0..4d69a776bac 100644
--- a/src/regexp/regexp-macro-assembler.h
+++ b/src/regexp/regexp-macro-assembler.h
@@ -304,8 +304,8 @@ class NativeRegExpMacroAssembler: public RegExpMacroAssembler {
                    int previous_index, Isolate* isolate);
 
   V8_EXPORT_PRIVATE static int ExecuteForTesting(String input, int start_offset,
-                                                 const byte* input_start,
-                                                 const byte* input_end,
+                                                 const uint8_t* input_start,
+                                                 const uint8_t* input_end,
                                                  int* output, int output_size,
                                                  Isolate* isolate,
                                                  JSRegExp regexp);
@@ -333,8 +333,8 @@ class NativeRegExpMacroAssembler: public RegExpMacroAssembler {
                                   RegExp::CallOrigin call_origin,
                                   Address* return_address,
                                   InstructionStream re_code, Address* subject,
-                                  const byte** input_start,
-                                  const byte** input_end);
+                                  const uint8_t** input_start,
+                                  const uint8_t** input_end);
 
   static Address word_character_map_address() {
     return reinterpret_cast<Address>(&word_character_map[0]);
@@ -344,14 +344,14 @@ class NativeRegExpMacroAssembler: public RegExpMacroAssembler {
   // Byte map of one byte characters with a 0xff if the character is a word
   // character (digit, letter or underscore) and 0x00 otherwise.
   // Used by generated RegExp code.
-  static const byte word_character_map[256];
+  static const uint8_t word_character_map[256];
 
   Handle<ByteArray> GetOrAddRangeArray(const ZoneList<CharacterRange>* ranges);
 
  private:
   // Returns a {Result} sentinel, or the number of successful matches.
-  static int Execute(String input, int start_offset, const byte* input_start,
-                     const byte* input_end, int* output, int output_size,
+  static int Execute(String input, int start_offset, const uint8_t* input_start,
+                     const uint8_t* input_end, int* output, int output_size,
                      Isolate* isolate, JSRegExp regexp);
 
   ZoneUnorderedMap<uint32_t, Handle<FixedUInt16Array>> range_array_cache_;
diff --git a/src/regexp/regexp-stack.cc b/src/regexp/regexp-stack.cc
index 9c403eed089..bf1edfae294 100644
--- a/src/regexp/regexp-stack.cc
+++ b/src/regexp/regexp-stack.cc
@@ -74,7 +74,7 @@ Address RegExpStack::EnsureCapacity(size_t size) {
   if (size > kMaximumStackSize) return kNullAddress;
   if (thread_local_.memory_size_ < size) {
     if (size < kMinimumDynamicStackSize) size = kMinimumDynamicStackSize;
-    byte* new_memory = NewArray<byte>(size);
+    uint8_t* new_memory = NewArray<uint8_t>(size);
     if (thread_local_.memory_size_ > 0) {
       // Copy original memory into top of new memory.
       MemCopy(new_memory + size - thread_local_.memory_size_,
diff --git a/src/regexp/regexp-stack.h b/src/regexp/regexp-stack.h
index 5711f7736db..dadd0105e0b 100644
--- a/src/regexp/regexp-stack.h
+++ b/src/regexp/regexp-stack.h
@@ -95,7 +95,7 @@ class RegExpStack final {
   // before NativeRegExpMacroAssembler::GrowStack must be called.
   static constexpr size_t kStaticStackSize =
       2 * kStackLimitSlack * kSystemPointerSize;
-  byte static_stack_[kStaticStackSize] = {0};
+  uint8_t static_stack_[kStaticStackSize] = {0};
 
   static_assert(kStaticStackSize <= kMaximumStackSize);
 
@@ -110,10 +110,10 @@ class RegExpStack final {
     //  - memory_, memory_top_, stack_pointer_ must be non-nullptr
     //  - memory_top_ = memory_ + memory_size_
     //  - memory_ <= stack_pointer_ <= memory_top_
-    byte* memory_ = nullptr;
-    byte* memory_top_ = nullptr;
+    uint8_t* memory_ = nullptr;
+    uint8_t* memory_top_ = nullptr;
     size_t memory_size_ = 0;
-    byte* stack_pointer_ = nullptr;
+    uint8_t* stack_pointer_ = nullptr;
     Address limit_ = kNullAddress;
     bool owns_memory_ = false;  // Whether memory_ is owned and must be freed.
 
diff --git a/src/regexp/riscv/regexp-macro-assembler-riscv.cc b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
index 95d004aa9a4..37f24df9eb3 100644
--- a/src/regexp/riscv/regexp-macro-assembler-riscv.cc
+++ b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
@@ -681,8 +681,8 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
     //
     // *int(*match)(String input_string,      // a0
     //             int start_offset,          // a1
-    //             byte* input_start,         // a2
-    //             byte* input_end,           // a3
+    //             uint8_t* input_start,      // a2
+    //             uint8_t* input_end,        // a3
     //             int* output,               // a4
     //             int output_size,           // a5
     //             int call_origin,           // a6
@@ -1223,8 +1223,8 @@ int64_t RegExpMacroAssemblerRISCV::CheckStackGuardState(Address* return_address,
           frame_entry<int64_t>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 MemOperand RegExpMacroAssemblerRISCV::register_location(int register_index) {
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.cc b/src/regexp/s390/regexp-macro-assembler-s390.cc
index 5c207f3b017..f082b958403 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.cc
+++ b/src/regexp/s390/regexp-macro-assembler-s390.cc
@@ -87,7 +87,7 @@ namespace internal {
  *              Address end,
  *              int* capture_output_array,
  *              int num_capture_registers,
- *              byte* stack_area_base,
+ *              uint8_t* stack_area_base,
  *              bool direct_call = false,
  *              Isolate* isolate,
  *              Address regexp);
@@ -1261,8 +1261,8 @@ int RegExpMacroAssemblerS390::CheckStackGuardState(Address* return_address,
           frame_entry<intptr_t>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 MemOperand RegExpMacroAssemblerS390::register_location(int register_index) {
diff --git a/src/regexp/x64/regexp-macro-assembler-x64.cc b/src/regexp/x64/regexp-macro-assembler-x64.cc
index 53b2f5ab52c..de474716f02 100644
--- a/src/regexp/x64/regexp-macro-assembler-x64.cc
+++ b/src/regexp/x64/regexp-macro-assembler-x64.cc
@@ -1318,8 +1318,8 @@ int RegExpMacroAssemblerX64::CheckStackGuardState(Address* return_address,
           frame_entry<int>(re_frame, kDirectCallOffset)),
       return_address, re_code,
       frame_entry_address<Address>(re_frame, kInputStringOffset),
-      frame_entry_address<const byte*>(re_frame, kInputStartOffset),
-      frame_entry_address<const byte*>(re_frame, kInputEndOffset));
+      frame_entry_address<const uint8_t*>(re_frame, kInputStartOffset),
+      frame_entry_address<const uint8_t*>(re_frame, kInputEndOffset));
 }
 
 
-- 
2.35.1


From 08e1c0feb6dfb022ee220d347205cc2fccd36457 Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Tue, 10 Oct 2023 09:32:06 +0000
Subject: [PATCH] Revert "Reland "[liftoff] Add support for direct C calls""

This reverts commit abb12d27903a827d3be0959dc800725e9cb6b533.

Reason for revert: UBSan errors: https://ci.chromium.org/ui/p/v8/builders/ci/V8%20Linux64%20UBSan/28643/overview

Original change's description:
> Reland "[liftoff] Add support for direct C calls"
>
> This is a reland of commit 5fb5de9cfc6c54cf8710db01f395299d5acb435b.
>
> Release builds of ia32 are fixed by adding a `USE` statement.
>
> Original change's description:
> > [liftoff] Add support for direct C calls
> >
> > This adds support for calling C functions and passing parameters
> > according to the C calling conventions. So far we could only call C
> > functions that expect their input in a pointer-referenced
> > stack-allocated buffer.
> >
> > For now, the four bit-rotating C functions are moved over. The same
> > infrastructure will be used for atomic notify in a follow-up, and we can
> > decide to move more functions over to generate smaller code and increase
> > performance.
> >
> > R=dlehmann@chromium.org
> >
> > Bug: v8:14101
> > Change-Id: Ifb85f57afa41f6a77d612fbd20076e37ce10bf99
> > Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4905288
> > Commit-Queue: Clemens Backes <clemensb@chromium.org>
> > Reviewed-by: Daniel Lehmann <dlehmann@chromium.org>
> > Cr-Commit-Position: refs/heads/main@{#90308}
>
> Bug: v8:14101
> Cq-Include-Trybots: luci.v8.try:v8_linux_compile_rel
> Change-Id: I7084f18589893a4ae07ed2a806b234a877279ecc
> Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4922912
> Reviewed-by: Daniel Lehmann <dlehmann@chromium.org>
> Commit-Queue: Clemens Backes <clemensb@chromium.org>
> Cr-Commit-Position: refs/heads/main@{#90325}

Bug: v8:14101
Change-Id: Ieee8cbef8d18d0f33608996178a2d036530b53c2
Cq-Include-Trybots: luci.v8.try:v8_linux_compile_rel
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4925193
Commit-Queue: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Auto-Submit: Clemens Backes <clemensb@chromium.org>
Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Cr-Commit-Position: refs/heads/main@{#90328}
---
 .../baseline/arm/liftoff-assembler-arm-inl.h  |  34 +----
 .../arm64/liftoff-assembler-arm64-inl.h       |  27 +---
 .../ia32/liftoff-assembler-ia32-inl.h         |  68 +--------
 src/wasm/baseline/liftoff-assembler.h         |  10 +-
 src/wasm/baseline/liftoff-compiler.cc         | 131 ++++++++----------
 .../loong64/liftoff-assembler-loong64-inl.h   |   8 +-
 .../mips64/liftoff-assembler-mips64-inl.h     |   8 +-
 .../baseline/ppc/liftoff-assembler-ppc-inl.h  |   8 +-
 .../riscv/liftoff-assembler-riscv32-inl.h     |   8 +-
 .../riscv/liftoff-assembler-riscv64-inl.h     |   8 +-
 .../s390/liftoff-assembler-s390-inl.h         |   8 +-
 .../baseline/x64/liftoff-assembler-x64-inl.h  |  27 +---
 src/wasm/wasm-external-refs.cc                |  22 ++-
 src/wasm/wasm-external-refs.h                 |   8 +-
 14 files changed, 118 insertions(+), 257 deletions(-)

diff --git a/src/wasm/baseline/arm/liftoff-assembler-arm-inl.h b/src/wasm/baseline/arm/liftoff-assembler-arm-inl.h
index c8f7facee85..f2de4b748a3 100644
--- a/src/wasm/baseline/arm/liftoff-assembler-arm-inl.h
+++ b/src/wasm/baseline/arm/liftoff-assembler-arm-inl.h
@@ -12,7 +12,6 @@
 #include "src/heap/memory-chunk.h"
 #include "src/wasm/baseline/liftoff-assembler.h"
 #include "src/wasm/baseline/liftoff-register.h"
-#include "src/wasm/baseline/parallel-move-inl.h"
 #include "src/wasm/object-access.h"
 #include "src/wasm/wasm-objects.h"
 
@@ -4410,10 +4409,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   Ret();
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   // Arguments are passed by pushing them all to the stack and then passing
   // a pointer to them.
   DCHECK(IsAligned(stack_bytes, kSystemPointerSize));
@@ -4473,31 +4472,6 @@ void LiftoffAssembler::CallCWithStackBuffer(
   add(sp, sp, Operand(stack_bytes));
 }
 
-void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
-                             ExternalReference ext_ref) {
-  constexpr Register kArgRegs[] = {arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4};
-  const Register* next_arg_reg = kArgRegs;
-  ParallelMove parallel_move{this};
-  for (const VarState& arg : args) {
-    DCHECK_GT(std::end(kArgRegs), next_arg_reg);
-    Register dst_lo = *next_arg_reg++;
-    if (arg.kind() == kI64) {
-      DCHECK_GT(std::end(kArgRegs), next_arg_reg);
-      Register dst_hi = *next_arg_reg++;
-      parallel_move.LoadIntoRegister(LiftoffRegister::ForPair(dst_lo, dst_hi),
-                                     arg);
-    } else {
-      parallel_move.LoadIntoRegister(LiftoffRegister{dst_lo}, arg);
-    }
-  }
-  parallel_move.Execute();
-
-  // Now call the C function.
-  int num_args = static_cast<int>(args.size());
-  PrepareCallCFunction(num_args);
-  CallCFunction(ext_ref, num_args);
-}
-
 void LiftoffAssembler::CallNativeWasmCode(Address addr) {
   Call(addr, RelocInfo::WASM_CALL);
 }
diff --git a/src/wasm/baseline/arm64/liftoff-assembler-arm64-inl.h b/src/wasm/baseline/arm64/liftoff-assembler-arm64-inl.h
index 3b3d8b27582..34fa43b6176 100644
--- a/src/wasm/baseline/arm64/liftoff-assembler-arm64-inl.h
+++ b/src/wasm/baseline/arm64/liftoff-assembler-arm64-inl.h
@@ -9,7 +9,7 @@
 #include "src/codegen/arm64/macro-assembler-arm64-inl.h"
 #include "src/heap/memory-chunk.h"
 #include "src/wasm/baseline/liftoff-assembler.h"
-#include "src/wasm/baseline/parallel-move-inl.h"
+#include "src/wasm/baseline/parallel-move.h"
 #include "src/wasm/object-access.h"
 #include "src/wasm/wasm-objects.h"
 
@@ -3477,10 +3477,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   Ret();
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   // The stack pointer is required to be quadword aligned.
   int total_size = RoundUp(stack_bytes, kQuadWordSizeInBytes);
   // Reserve space in the stack.
@@ -3542,23 +3542,6 @@ void LiftoffAssembler::CallCWithStackBuffer(
   Drop(total_size, 1);
 }
 
-void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
-                             ExternalReference ext_ref) {
-  constexpr Register kArgRegs[] = {arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4};
-  DCHECK_LE(args.size(), arraysize(kArgRegs));
-  const Register* next_arg_reg = kArgRegs;
-  ParallelMove parallel_move{this};
-  for (const VarState& arg : args) {
-    parallel_move.LoadIntoRegister(LiftoffRegister{*next_arg_reg}, arg);
-    ++next_arg_reg;
-  }
-  parallel_move.Execute();
-
-  // Now call the C function.
-  int num_args = static_cast<int>(args.size());
-  CallCFunction(ext_ref, num_args);
-}
-
 void LiftoffAssembler::CallNativeWasmCode(Address addr) {
   Call(addr, RelocInfo::WASM_CALL);
 }
diff --git a/src/wasm/baseline/ia32/liftoff-assembler-ia32-inl.h b/src/wasm/baseline/ia32/liftoff-assembler-ia32-inl.h
index 64ef4bb8efc..b2f75a3aab7 100644
--- a/src/wasm/baseline/ia32/liftoff-assembler-ia32-inl.h
+++ b/src/wasm/baseline/ia32/liftoff-assembler-ia32-inl.h
@@ -4726,10 +4726,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   ret(static_cast<int>(num_stack_slots * kSystemPointerSize));
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   AllocateStackSpace(stack_bytes);
 
   int arg_offset = 0;
@@ -4787,66 +4787,6 @@ void LiftoffAssembler::CallCWithStackBuffer(
   add(esp, Immediate(stack_bytes));
 }
 
-void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
-                             ExternalReference ext_ref) {
-  LiftoffRegList arg_regs;
-  for (const VarState arg : args) {
-    if (arg.is_reg()) arg_regs.set(arg.reg());
-  }
-
-  RegList usable_regs = kLiftoffAssemblerGpCacheRegs - arg_regs.GetGpList();
-  Register scratch = usable_regs.first();
-  int num_args = 0;
-  // i64 values take two stack slots.
-  for (const VarState& arg : args) {
-    num_args += arg.kind() == kI64 ? 2 : 1;
-  }
-  PrepareCallCFunction(num_args, scratch);
-
-  // Ia32 passes all arguments via the stack. Store them now in the stack space
-  // allocated by {PrepareCallCFunction}.
-
-  // GetNextOperand returns the operand for the next stack slot on each
-  // invocation.
-  auto GetNextOperand = [arg_offset = 0, num_args]() mutable {
-    // Check that we don't exceed the pre-computed {num_args}.
-    DCHECK_GE(num_args * kSystemPointerSize, arg_offset);
-    USE(num_args);
-    Operand dst{esp, arg_offset};
-    arg_offset += kSystemPointerSize;
-    return dst;
-  };
-  for (const VarState& arg : args) {
-    Operand dst = GetNextOperand();
-    if (arg.is_reg()) {
-      LiftoffRegister reg = arg.reg();
-      if (arg.kind() == kI64) {
-        mov(dst, reg.low_gp());
-        mov(GetNextOperand(), reg.high_gp());
-      } else {
-        mov(dst, reg.gp());
-      }
-    } else if (arg.is_const()) {
-      DCHECK_EQ(kI32, arg.kind());
-      mov(dst, Immediate(arg.i32_const()));
-    } else {
-      DCHECK(arg.is_stack());
-      if (arg.kind() == kI64) {
-        mov(scratch, liftoff::GetStackSlot(arg.offset()));
-        mov(dst, scratch);
-        mov(scratch, liftoff::GetStackSlot(arg.offset() + kSystemPointerSize));
-        mov(GetNextOperand(), scratch);
-      } else {
-        mov(scratch, liftoff::GetStackSlot(arg.offset()));
-        mov(dst, scratch);
-      }
-    }
-  }
-
-  // Now call the C function.
-  CallCFunction(ext_ref, num_args);
-}
-
 void LiftoffAssembler::CallNativeWasmCode(Address addr) {
   wasm_call(addr, RelocInfo::WASM_CALL);
 }
diff --git a/src/wasm/baseline/liftoff-assembler.h b/src/wasm/baseline/liftoff-assembler.h
index c4059cfcfc6..595fd95a4f1 100644
--- a/src/wasm/baseline/liftoff-assembler.h
+++ b/src/wasm/baseline/liftoff-assembler.h
@@ -1506,15 +1506,9 @@ class LiftoffAssembler : public MacroAssembler {
   // this is the return value of the C function, stored in {rets[0]}. Further
   // outputs (specified in {sig->returns()}) are read from the buffer and stored
   // in the remaining {rets} registers.
-  inline void CallCWithStackBuffer(const std::initializer_list<VarState> args,
-                                   const LiftoffRegister* rets,
-                                   ValueKind return_kind,
-                                   ValueKind out_argument_kind, int stack_bytes,
-                                   ExternalReference ext_ref);
-
-  // Execute a C call with arguments passed according to the C calling
-  // conventions.
   inline void CallC(const std::initializer_list<VarState> args,
+                    const LiftoffRegister* rets, ValueKind return_kind,
+                    ValueKind out_argument_kind, int stack_bytes,
                     ExternalReference ext_ref);
 
   inline void CallNativeWasmCode(Address addr);
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index e0195616adb..8f75bf975b1 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -1648,24 +1648,10 @@ class LiftoffCompiler {
     if (!c->label.get()->is_bound()) __ bind(c->label.get());
   }
 
-  // Call a C function (with default C calling conventions). Returns the
-  // register holding the result if any.
-  LiftoffRegister GenerateCCall(ValueKind return_kind,
-                                const std::initializer_list<VarState> args,
-                                ExternalReference ext_ref) {
-    __ SpillAllRegisters();
-    __ CallC(args, ext_ref);
-    if (needs_gp_reg_pair(return_kind)) {
-      return LiftoffRegister::ForPair(kReturnRegister0, kReturnRegister1);
-    }
-    return LiftoffRegister{kReturnRegister0};
-  }
-
-  void GenerateCCallWithStackBuffer(const LiftoffRegister* result_regs,
-                                    ValueKind return_kind,
-                                    ValueKind out_argument_kind,
-                                    const std::initializer_list<VarState> args,
-                                    ExternalReference ext_ref) {
+  void GenerateCCall(const LiftoffRegister* result_regs, ValueKind return_kind,
+                     ValueKind out_argument_kind,
+                     const std::initializer_list<VarState> args,
+                     ExternalReference ext_ref) {
     // Before making a call, spill all cache registers.
     __ SpillAllRegisters();
 
@@ -1677,8 +1663,8 @@ class LiftoffCompiler {
     int out_arg_bytes =
         out_argument_kind == kVoid ? 0 : value_kind_size(out_argument_kind);
     int stack_bytes = std::max(param_bytes, out_arg_bytes);
-    __ CallCWithStackBuffer(args, result_regs, return_kind, out_argument_kind,
-                            stack_bytes, ext_ref);
+    __ CallC(args, result_regs, return_kind, out_argument_kind, stack_bytes,
+             ext_ref);
   }
 
   template <typename EmitFn, typename... Args>
@@ -1757,8 +1743,7 @@ class LiftoffCompiler {
                                     LiftoffRegister dst, LiftoffRegister src) {
       if ((asm_.*emit_fn)(dst.fp(), src.fp())) return;
       ExternalReference ext_ref = fallback_fn();
-      GenerateCCallWithStackBuffer(&dst, kVoid, kind, {VarState{kind, src, 0}},
-                                   ext_ref);
+      GenerateCCall(&dst, kVoid, kind, {VarState{kind, src, 0}}, ext_ref);
     };
     EmitUnOp<kind, kind>(emit_with_c_fallback);
   }
@@ -1786,14 +1771,14 @@ class LiftoffCompiler {
         LiftoffRegister ret_reg =
             __ GetUnusedRegister(kGpReg, LiftoffRegList{dst});
         LiftoffRegister dst_regs[] = {ret_reg, dst};
-        GenerateCCallWithStackBuffer(dst_regs, kI32, dst_kind,
-                                     {VarState{src_kind, src, 0}}, ext_ref);
+        GenerateCCall(dst_regs, kI32, dst_kind, {VarState{src_kind, src, 0}},
+                      ext_ref);
         // It's okay that this is short-lived: we're trapping anyway.
         FREEZE_STATE(trapping);
         __ emit_cond_jump(kEqual, trap, kI32, ret_reg.gp(), no_reg, trapping);
       } else {
-        GenerateCCallWithStackBuffer(&dst, kVoid, dst_kind,
-                                     {VarState{src_kind, src, 0}}, ext_ref);
+        GenerateCCall(&dst, kVoid, dst_kind, {VarState{src_kind, src, 0}},
+                      ext_ref);
       }
     }
     __ PushRegister(dst_kind, dst);
@@ -1927,9 +1912,8 @@ class LiftoffCompiler {
         return EmitUnOp<kI32, kI32>(
             [this](LiftoffRegister dst, LiftoffRegister src) {
               if (__ emit_i32_popcnt(dst.gp(), src.gp())) return;
-              GenerateCCallWithStackBuffer(
-                  &dst, kI32, kVoid, {VarState{kI32, src, 0}},
-                  ExternalReference::wasm_word32_popcnt());
+              GenerateCCall(&dst, kI32, kVoid, {VarState{kI32, src, 0}},
+                            ExternalReference::wasm_word32_popcnt());
             });
       case kExprI64Popcnt:
         return EmitUnOp<kI64, kI64>(
@@ -1937,9 +1921,8 @@ class LiftoffCompiler {
               if (__ emit_i64_popcnt(dst, src)) return;
               // The c function returns i32. We will zero-extend later.
               LiftoffRegister c_call_dst = kNeedI64RegPair ? dst.low() : dst;
-              GenerateCCallWithStackBuffer(
-                  &c_call_dst, kI32, kVoid, {VarState{kI64, src, 0}},
-                  ExternalReference::wasm_word64_popcnt());
+              GenerateCCall(&c_call_dst, kI32, kVoid, {VarState{kI64, src, 0}},
+                            ExternalReference::wasm_word64_popcnt());
               // Now zero-extend the result to i64.
               __ emit_type_conversion(kExprI64UConvertI32, dst, c_call_dst,
                                       nullptr);
@@ -2048,8 +2031,8 @@ class LiftoffCompiler {
     // Cannot emit native instructions, build C call.
     LiftoffRegister ret = __ GetUnusedRegister(kGpReg, LiftoffRegList{dst});
     LiftoffRegister result_regs[] = {ret, dst};
-    GenerateCCallWithStackBuffer(result_regs, kI32, kI64,
-                                 {{kI64, lhs, 0}, {kI64, rhs, 0}}, ext_ref);
+    GenerateCCall(result_regs, kI32, kI64, {{kI64, lhs, 0}, {kI64, rhs, 0}},
+                  ext_ref);
     FREEZE_STATE(trapping);
     __ emit_i32_cond_jumpi(kEqual, trap_by_zero, ret.gp(), 0, trapping);
     if (trap_unrepresentable) {
@@ -2072,15 +2055,15 @@ class LiftoffCompiler {
   }
 
   template <ValueKind kind, ExternalReference(ExtRefFn)()>
-  void EmitBitRotationCCall() {
-    EmitBinOp<kind, kind>([this](LiftoffRegister dst, LiftoffRegister input,
-                                 LiftoffRegister shift) {
-      // The shift is always passed as 32-bit value.
-      if (needs_gp_reg_pair(kind)) shift = shift.low();
-      LiftoffRegister result =
-          GenerateCCall(kind, {{kind, input, 0}, {kI32, shift, 0}}, ExtRefFn());
-      if (dst != result) __ Move(dst, result, kind);
-    });
+  void EmitCCallBinOp() {
+    EmitBinOp<kind, kind>(
+        [this](LiftoffRegister dst, LiftoffRegister lhs, LiftoffRegister rhs) {
+          const bool out_via_stack = kind == kI64;
+          ValueKind out_arg_kind = out_via_stack ? kI64 : kVoid;
+          ValueKind return_kind = out_via_stack ? kVoid : kind;
+          GenerateCCall(&dst, return_kind, out_arg_kind,
+                        {{kind, lhs, 0}, {kind, rhs, 0}}, ExtRefFn());
+        });
   }
 
   template <typename EmitFn, typename EmitFnImm>
@@ -2225,9 +2208,9 @@ class LiftoffCompiler {
         return EmitBinOpImm<kI32, kI32>(&LiftoffAssembler::emit_i32_shr,
                                         &LiftoffAssembler::emit_i32_shri);
       case kExprI32Rol:
-        return EmitBitRotationCCall<kI32, ExternalReference::wasm_word32_rol>();
+        return EmitCCallBinOp<kI32, ExternalReference::wasm_word32_rol>();
       case kExprI32Ror:
-        return EmitBitRotationCCall<kI32, ExternalReference::wasm_word32_ror>();
+        return EmitCCallBinOp<kI32, ExternalReference::wasm_word32_ror>();
       case kExprI64Shl:
         return EmitI64Shift(&LiftoffAssembler::emit_i64_shl,
                             &LiftoffAssembler::emit_i64_shli);
@@ -2238,9 +2221,9 @@ class LiftoffCompiler {
         return EmitI64Shift(&LiftoffAssembler::emit_i64_shr,
                             &LiftoffAssembler::emit_i64_shri);
       case kExprI64Rol:
-        return EmitBitRotationCCall<kI64, ExternalReference::wasm_word64_rol>();
+        return EmitCCallBinOp<kI64, ExternalReference::wasm_word64_rol>();
       case kExprI64Ror:
-        return EmitBitRotationCCall<kI64, ExternalReference::wasm_word64_ror>();
+        return EmitCCallBinOp<kI64, ExternalReference::wasm_word64_ror>();
       case kExprF32Add:
         return EmitBinOp<kF32, kF32>(&LiftoffAssembler::emit_f32_add);
       case kExprF32Sub:
@@ -3872,8 +3855,7 @@ class LiftoffCompiler {
     LiftoffRegister dst = __ GetUnusedRegister(rc, {src}, {});
     if (!(asm_.*emit_fn)(dst, src)) {
       // Return v128 via stack for ARM.
-      GenerateCCallWithStackBuffer(&dst, kVoid, kS128,
-                                   {VarState{kS128, src, 0}}, ext_ref());
+      GenerateCCall(&dst, kVoid, kS128, {VarState{kS128, src, 0}}, ext_ref());
     }
     if (V8_UNLIKELY(nondeterminism_)) {
       LiftoffRegList pinned{dst};
@@ -5446,15 +5428,14 @@ class LiftoffCompiler {
     // We don't need the instance anymore after the call. We can use the
     // register for the result.
     LiftoffRegister result{instance};
-    GenerateCCallWithStackBuffer(
-        &result, kI32, kVoid,
-        {{kIntPtrKind, LiftoffRegister{instance}, 0},
-         {kI32, static_cast<int32_t>(imm.memory.index), 0},
-         dst,
-         src,
-         {kI32, static_cast<int32_t>(imm.data_segment.index), 0},
-         size},
-        ExternalReference::wasm_memory_init());
+    GenerateCCall(&result, kI32, kVoid,
+                  {{kIntPtrKind, LiftoffRegister{instance}, 0},
+                   {kI32, static_cast<int32_t>(imm.memory.index), 0},
+                   dst,
+                   src,
+                   {kI32, static_cast<int32_t>(imm.data_segment.index), 0},
+                   size},
+                  ExternalReference::wasm_memory_init());
     FREEZE_STATE(trapping);
     __ emit_cond_jump(kEqual, trap_label, kI32, result.gp(), no_reg, trapping);
   }
@@ -5515,15 +5496,14 @@ class LiftoffCompiler {
     // We don't need the instance anymore after the call. We can use the
     // register for the result.
     LiftoffRegister result(instance);
-    GenerateCCallWithStackBuffer(
-        &result, kI32, kVoid,
-        {{kIntPtrKind, LiftoffRegister{instance}, 0},
-         {kI32, static_cast<int32_t>(imm.memory_dst.index), 0},
-         {kI32, static_cast<int32_t>(imm.memory_src.index), 0},
-         dst,
-         src,
-         size},
-        ExternalReference::wasm_memory_copy());
+    GenerateCCall(&result, kI32, kVoid,
+                  {{kIntPtrKind, LiftoffRegister{instance}, 0},
+                   {kI32, static_cast<int32_t>(imm.memory_dst.index), 0},
+                   {kI32, static_cast<int32_t>(imm.memory_src.index), 0},
+                   dst,
+                   src,
+                   size},
+                  ExternalReference::wasm_memory_copy());
     FREEZE_STATE(trapping);
     __ emit_cond_jump(kEqual, trap_label, kI32, result.gp(), no_reg, trapping);
   }
@@ -5560,13 +5540,13 @@ class LiftoffCompiler {
     // We don't need the instance anymore after the call. We can use the
     // register for the result.
     LiftoffRegister result(instance);
-    GenerateCCallWithStackBuffer(&result, kI32, kVoid,
-                                 {{kIntPtrKind, LiftoffRegister{instance}, 0},
-                                  {kI32, static_cast<int32_t>(imm.index), 0},
-                                  dst,
-                                  value,
-                                  size},
-                                 ExternalReference::wasm_memory_fill());
+    GenerateCCall(&result, kI32, kVoid,
+                  {{kIntPtrKind, LiftoffRegister{instance}, 0},
+                   {kI32, static_cast<int32_t>(imm.index), 0},
+                   dst,
+                   value,
+                   size},
+                  ExternalReference::wasm_memory_fill());
     FREEZE_STATE(trapping);
     __ emit_cond_jump(kEqual, trap_label, kI32, result.gp(), no_reg, trapping);
   }
@@ -5960,8 +5940,7 @@ class LiftoffCompiler {
                  const Value& src, const Value& src_index,
                  const ArrayIndexImmediate& src_imm, const Value& length) {
     // TODO(14034): Unify implementation with TF: Implement this with
-    // GenerateCCallWithStackBuffer. Remove runtime function and builtin in
-    // wasm.tq.
+    // GenerateCCall. Remove runtime function and builtin in wasm.tq.
     CallBuiltin(v8_flags.experimental_wasm_skip_bounds_checks
                     ? Builtin::kWasmArrayCopy
                     : Builtin::kWasmArrayCopyWithChecks,
diff --git a/src/wasm/baseline/loong64/liftoff-assembler-loong64-inl.h b/src/wasm/baseline/loong64/liftoff-assembler-loong64-inl.h
index 19736789d52..e4b4a407131 100644
--- a/src/wasm/baseline/loong64/liftoff-assembler-loong64-inl.h
+++ b/src/wasm/baseline/loong64/liftoff-assembler-loong64-inl.h
@@ -3123,10 +3123,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   Ret();
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   addi_d(sp, sp, -stack_bytes);
 
   int arg_offset = 0;
diff --git a/src/wasm/baseline/mips64/liftoff-assembler-mips64-inl.h b/src/wasm/baseline/mips64/liftoff-assembler-mips64-inl.h
index 2742e880054..9df43c84b67 100644
--- a/src/wasm/baseline/mips64/liftoff-assembler-mips64-inl.h
+++ b/src/wasm/baseline/mips64/liftoff-assembler-mips64-inl.h
@@ -3651,10 +3651,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   MacroAssembler::DropAndRet(static_cast<int>(num_stack_slots));
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   Daddu(sp, sp, -stack_bytes);
 
   int arg_offset = 0;
diff --git a/src/wasm/baseline/ppc/liftoff-assembler-ppc-inl.h b/src/wasm/baseline/ppc/liftoff-assembler-ppc-inl.h
index 069ad71571f..113cb99443f 100644
--- a/src/wasm/baseline/ppc/liftoff-assembler-ppc-inl.h
+++ b/src/wasm/baseline/ppc/liftoff-assembler-ppc-inl.h
@@ -2552,10 +2552,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   Ret();
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   int total_size = RoundUp(stack_bytes, kSystemPointerSize);
 
   int size = total_size;
diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h
index 895d2c82a1f..113ab39370a 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h
@@ -2074,10 +2074,10 @@ void LiftoffAssembler::emit_i16x8_extadd_pairwise_i8x16_u(LiftoffRegister dst,
   vwaddu_vv(dst.fp().toV(), kSimd128ScratchReg, kSimd128ScratchReg2);
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   AddWord(sp, sp, Operand(-stack_bytes));
 
   int arg_offset = 0;
diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv64-inl.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv64-inl.h
index ff3d59c433b..235f6b59be2 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv64-inl.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv64-inl.h
@@ -1637,10 +1637,10 @@ void LiftoffAssembler::emit_i16x8_extadd_pairwise_i8x16_u(LiftoffRegister dst,
   vwaddu_vv(dst.fp().toV(), kSimd128ScratchReg, kSimd128ScratchReg2);
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   AddWord(sp, sp, Operand(-stack_bytes));
 
   int arg_offset = 0;
diff --git a/src/wasm/baseline/s390/liftoff-assembler-s390-inl.h b/src/wasm/baseline/s390/liftoff-assembler-s390-inl.h
index 7125b34f715..74bed1536b5 100644
--- a/src/wasm/baseline/s390/liftoff-assembler-s390-inl.h
+++ b/src/wasm/baseline/s390/liftoff-assembler-s390-inl.h
@@ -2978,10 +2978,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   Ret();
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   int total_size = RoundUp(stack_bytes, 8);
 
   int size = total_size;
diff --git a/src/wasm/baseline/x64/liftoff-assembler-x64-inl.h b/src/wasm/baseline/x64/liftoff-assembler-x64-inl.h
index c78597f9909..a86449ca8ce 100644
--- a/src/wasm/baseline/x64/liftoff-assembler-x64-inl.h
+++ b/src/wasm/baseline/x64/liftoff-assembler-x64-inl.h
@@ -14,7 +14,6 @@
 #include "src/flags/flags.h"
 #include "src/heap/memory-chunk.h"
 #include "src/wasm/baseline/liftoff-assembler.h"
-#include "src/wasm/baseline/parallel-move-inl.h"
 #include "src/wasm/baseline/parallel-move.h"
 #include "src/wasm/object-access.h"
 #include "src/wasm/simd-shuffle.h"
@@ -4245,10 +4244,10 @@ void LiftoffAssembler::DropStackSlotsAndRet(uint32_t num_stack_slots) {
   ret(static_cast<int>(num_stack_slots * kSystemPointerSize));
 }
 
-void LiftoffAssembler::CallCWithStackBuffer(
-    const std::initializer_list<VarState> args, const LiftoffRegister* rets,
-    ValueKind return_kind, ValueKind out_argument_kind, int stack_bytes,
-    ExternalReference ext_ref) {
+void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
+                             const LiftoffRegister* rets, ValueKind return_kind,
+                             ValueKind out_argument_kind, int stack_bytes,
+                             ExternalReference ext_ref) {
   AllocateStackSpace(stack_bytes);
 
   int arg_offset = 0;
@@ -4302,24 +4301,6 @@ void LiftoffAssembler::CallCWithStackBuffer(
   addq(rsp, Immediate(stack_bytes));
 }
 
-void LiftoffAssembler::CallC(const std::initializer_list<VarState> args,
-                             ExternalReference ext_ref) {
-  constexpr Register kArgRegs[] = {arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4};
-  DCHECK_LE(args.size(), arraysize(kArgRegs));
-  const Register* next_arg_reg = kArgRegs;
-  ParallelMove parallel_move{this};
-  for (const VarState& arg : args) {
-    parallel_move.LoadIntoRegister(LiftoffRegister{*next_arg_reg}, arg);
-    ++next_arg_reg;
-  }
-  parallel_move.Execute();
-
-  // Now call the C function.
-  int num_args = static_cast<int>(args.size());
-  PrepareCallCFunction(num_args);
-  CallCFunction(ext_ref, num_args);
-}
-
 void LiftoffAssembler::CallNativeWasmCode(Address addr) {
   near_call(addr, RelocInfo::WASM_CALL);
 }
diff --git a/src/wasm/wasm-external-refs.cc b/src/wasm/wasm-external-refs.cc
index f2bbe23e48d..5b6f2178076 100644
--- a/src/wasm/wasm-external-refs.cc
+++ b/src/wasm/wasm-external-refs.cc
@@ -344,20 +344,30 @@ uint32_t word64_popcnt_wrapper(Address data) {
   return base::bits::CountPopulation(ReadUnalignedValue<uint64_t>(data));
 }
 
-uint32_t word32_rol_wrapper(uint32_t input, uint32_t shift) {
+uint32_t word32_rol_wrapper(Address data) {
+  uint32_t input = ReadUnalignedValue<uint32_t>(data);
+  uint32_t shift = ReadUnalignedValue<uint32_t>(data + sizeof(input)) & 31;
   return (input << shift) | (input >> ((32 - shift) & 31));
 }
 
-uint32_t word32_ror_wrapper(uint32_t input, uint32_t shift) {
+uint32_t word32_ror_wrapper(Address data) {
+  uint32_t input = ReadUnalignedValue<uint32_t>(data);
+  uint32_t shift = ReadUnalignedValue<uint32_t>(data + sizeof(input)) & 31;
   return (input >> shift) | (input << ((32 - shift) & 31));
 }
 
-uint64_t word64_rol_wrapper(uint64_t input, uint32_t shift) {
-  return (input << shift) | (input >> ((64 - shift) & 63));
+void word64_rol_wrapper(Address data) {
+  uint64_t input = ReadUnalignedValue<uint64_t>(data);
+  uint64_t shift = ReadUnalignedValue<uint64_t>(data + sizeof(input)) & 63;
+  uint64_t result = (input << shift) | (input >> ((64 - shift) & 63));
+  WriteUnalignedValue<uint64_t>(data, result);
 }
 
-uint64_t word64_ror_wrapper(uint64_t input, uint32_t shift) {
-  return (input >> shift) | (input << ((64 - shift) & 63));
+void word64_ror_wrapper(Address data) {
+  uint64_t input = ReadUnalignedValue<uint64_t>(data);
+  uint64_t shift = ReadUnalignedValue<uint64_t>(data + sizeof(input)) & 63;
+  uint64_t result = (input >> shift) | (input << ((64 - shift) & 63));
+  WriteUnalignedValue<uint64_t>(data, result);
 }
 
 void float64_pow_wrapper(Address data) {
diff --git a/src/wasm/wasm-external-refs.h b/src/wasm/wasm-external-refs.h
index e6deae144fc..724abd421f1 100644
--- a/src/wasm/wasm-external-refs.h
+++ b/src/wasm/wasm-external-refs.h
@@ -78,13 +78,13 @@ V8_EXPORT_PRIVATE uint32_t word32_popcnt_wrapper(Address data);
 
 V8_EXPORT_PRIVATE uint32_t word64_popcnt_wrapper(Address data);
 
-V8_EXPORT_PRIVATE uint32_t word32_rol_wrapper(uint32_t input, uint32_t shift);
+V8_EXPORT_PRIVATE uint32_t word32_rol_wrapper(Address data);
 
-V8_EXPORT_PRIVATE uint32_t word32_ror_wrapper(uint32_t input, uint32_t shift);
+V8_EXPORT_PRIVATE uint32_t word32_ror_wrapper(Address data);
 
-V8_EXPORT_PRIVATE uint64_t word64_rol_wrapper(uint64_t input, uint32_t shift);
+V8_EXPORT_PRIVATE void word64_rol_wrapper(Address data);
 
-V8_EXPORT_PRIVATE uint64_t word64_ror_wrapper(uint64_t input, uint32_t shift);
+V8_EXPORT_PRIVATE void word64_ror_wrapper(Address data);
 
 V8_EXPORT_PRIVATE void float64_pow_wrapper(Address data);
 
-- 
2.35.1


From 2c3dcfeb018ade1ab82c606044f3f2d22fa1e6cb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=A8=E6=96=87=E6=98=8E?= <yangwenming@bytedance.com>
Date: Thu, 20 Jul 2023 21:58:28 +0800
Subject: [PATCH] [atomic,riscv32] fix i64.atomic.rmw32.xxx_u on riscv32.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Liftoff on riscv32 do not clear high reg when handling
i64.atomic.rmw32.xxx_u and thus get wrong result. This
CL add instructions to set high reg of a pair, which
hold an i64 on riscv32, to zero so that unexpected
value in the high bits is cleared.
Besides, riscv64 does not pass the regress test yet, so
it will skip the added test. Further CL will be
committed to solve the underlying bug on riscv64.

Bug: v8:14113
Change-Id: I9d4f40495eebd950dd59d6f3731adf8a042f0fd2
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4705503
Auto-Submit: 杨文明 <yangwenming@bytedance.com>
Commit-Queue: Thibaud Michaud <thibaudm@chromium.org>
Reviewed-by: Thibaud Michaud <thibaudm@chromium.org>
Cr-Commit-Position: refs/heads/main@{#89172}
---
 .../riscv/liftoff-assembler-riscv32.h         |  8 +-
 test/mjsunit/mjsunit.status                   |  4 +
 test/mjsunit/regress/wasm/regress-14113.js    | 74 +++++++++++++++++++
 3 files changed, 84 insertions(+), 2 deletions(-)
 create mode 100644 test/mjsunit/regress/wasm/regress-14113.js

diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
index 0893709d8fe..98607d39ad0 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
@@ -480,14 +480,12 @@ inline void AtomicBinop(LiftoffAssembler* lasm, Register dst_addr,
   switch (type.value()) {
     case StoreType::kI64Store8:
     case StoreType::kI64Store16:
-    case StoreType::kI64Store32:
       __ LoadConstant(result.high(), WasmValue(0));
       result_reg = result.low_gp();
       value_reg = value.low_gp();
       break;
     case StoreType::kI32Store8:
     case StoreType::kI32Store16:
-    case StoreType::kI32Store:
       result_reg = result.gp();
       value_reg = value.gp();
       break;
@@ -711,6 +709,7 @@ void LiftoffAssembler::AtomicAdd(Register dst_addr, Register offset_reg,
     Register actual_addr = liftoff::CalculateActualAddress(
         this, dst_addr, offset_reg, offset_imm, temps.Acquire());
     if (type.value() == StoreType::kI64Store32) {
+      mv(result.high_gp(), zero_reg);  // High word of result is always 0.
       result = result.low();
       value = value.low();
     }
@@ -737,6 +736,7 @@ void LiftoffAssembler::AtomicSub(Register dst_addr, Register offset_reg,
     Register actual_addr = liftoff::CalculateActualAddress(
         this, dst_addr, offset_reg, offset_imm, temps.Acquire());
     if (type.value() == StoreType::kI64Store32) {
+      mv(result.high_gp(), zero_reg);
       result = result.low();
       value = value.low();
     }
@@ -763,6 +763,7 @@ void LiftoffAssembler::AtomicAnd(Register dst_addr, Register offset_reg,
     Register actual_addr = liftoff::CalculateActualAddress(
         this, dst_addr, offset_reg, offset_imm, temps.Acquire());
     if (type.value() == StoreType::kI64Store32) {
+      mv(result.high_gp(), zero_reg);
       result = result.low();
       value = value.low();
     }
@@ -788,6 +789,7 @@ void LiftoffAssembler::AtomicOr(Register dst_addr, Register offset_reg,
     Register actual_addr = liftoff::CalculateActualAddress(
         this, dst_addr, offset_reg, offset_imm, temps.Acquire());
     if (type.value() == StoreType::kI64Store32) {
+      mv(result.high_gp(), zero_reg);
       result = result.low();
       value = value.low();
     }
@@ -813,6 +815,7 @@ void LiftoffAssembler::AtomicXor(Register dst_addr, Register offset_reg,
     Register actual_addr = liftoff::CalculateActualAddress(
         this, dst_addr, offset_reg, offset_imm, temps.Acquire());
     if (type.value() == StoreType::kI64Store32) {
+      mv(result.high_gp(), zero_reg);
       result = result.low();
       value = value.low();
     }
@@ -839,6 +842,7 @@ void LiftoffAssembler::AtomicExchange(Register dst_addr, Register offset_reg,
     Register actual_addr = liftoff::CalculateActualAddress(
         this, dst_addr, offset_reg, offset_imm, temps.Acquire());
     if (type.value() == StoreType::kI64Store32) {
+      mv(result.high_gp(), zero_reg);
       result = result.low();
       value = value.low();
     }
diff --git a/test/mjsunit/mjsunit.status b/test/mjsunit/mjsunit.status
index 8b1472538ca..8e5fe0adaf2 100644
--- a/test/mjsunit/mjsunit.status
+++ b/test/mjsunit/mjsunit.status
@@ -977,6 +977,10 @@
 'regress/wasm/regress-14171':[SKIP],
 }], # 'arch == riscv32'
 
+[ 'arch == riscv64' , {
+'regress/wasm/regress-14113':[SKIP],
+}], # 'arch == riscv64'
+
 ##############################################################################
 ['system == macos', {
   # TODO(machenbach): These tests are x25 slower on 4-core Mac Minis. They can
diff --git a/test/mjsunit/regress/wasm/regress-14113.js b/test/mjsunit/regress/wasm/regress-14113.js
new file mode 100644
index 00000000000..4c3cfebb9e2
--- /dev/null
+++ b/test/mjsunit/regress/wasm/regress-14113.js
@@ -0,0 +1,74 @@
+// Copyright 2023 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Flags: --liftoff --no-wasm-tier-up
+
+d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');
+
+const I64AtomicOps = [
+  kExprI64AtomicAdd32U,
+  kExprI64AtomicSub32U,
+  kExprI64AtomicAnd32U,
+  kExprI64AtomicOr32U,
+  kExprI64AtomicXor32U,
+  kExprI64AtomicExchange32U,
+];
+
+const Inputs = [
+  [0x0ffffffffn, 1n, 0n],
+  [0x200000000n, 1n, 0x2ffffffffn],
+  [0x1ffffffffn, 1n, 0x100000001n],
+  [0x1ffffffffn, 1n, 0x1ffffffffn],
+  [0x1ffffffffn, 0xffffffffn, 0x100000000n],
+  [0x1ffffffffn, 0xfffffffen, 0x1fffffffen],
+];
+
+// Test that bits beyond position 31 of the second
+// operand do not affect result at all.
+const Inputs2 = [
+  [0x0ffffffffn, 0xbee00000001n, 0n],
+  [0x200000000n, 0xbee00000001n, 0x2ffffffffn],
+  [0x1ffffffffn, 0xbee00000001n, 0x100000001n],
+  [0x1ffffffffn, 0xbee00000001n, 0x1ffffffffn],
+  [0x1ffffffffn, 0xbeeffffffffn, 0x100000000n],
+  [0x1ffffffffn, 0xbeefffffffen, 0x1fffffffen],
+];
+
+function TestBinOp64(index, memory, inputs) {
+  const Op = I64AtomicOps[index];
+  const sample = inputs[index];
+
+  const builder = new WasmModuleBuilder();
+  builder.addImportedMemory("imports", "mem", 1);
+  builder.addType(makeSig([kWasmI32, kWasmI64], [kWasmI64]));
+  // Generate function 1 (out of 1).
+  builder.addFunction(undefined, 0 /* sig */).addBodyWithEnd([
+    kExprLocalGet, 0,
+    kExprLocalGet, 1,
+    kAtomicPrefix, Op, 0x02, 0x00,
+    kExprEnd
+  ]);
+  builder.addExport('run', 0);
+  const instance = builder.instantiate({ imports: { mem: memory } });
+
+  let dv = new DataView(memory.buffer);
+  dv.setBigUint64(index * 8, sample[0], true);
+  assertEquals(sample[0] & 0xffffffffn, instance.exports.run(index * 8, sample[1]));
+  assertEquals(sample[2], dv.getBigUint64(index * 8, true));
+}
+
+function runTestWithInputs(inputs) {
+  var mem = new WebAssembly.Memory({ initial: 1 });
+  TestBinOp64(0, mem, inputs, "i64.atomic.rmw32.add");
+  TestBinOp64(1, mem, inputs, "i64.atomic.rmw32.sub");
+  TestBinOp64(2, mem, inputs, "i64.atomic.rmw32.and");
+  TestBinOp64(3, mem, inputs, "i64.atomic.rmw32.or");
+  TestBinOp64(4, mem, inputs, "i64.atomic.rmw32.xor");
+  TestBinOp64(5, mem, inputs, "i64.atomic.rmw32.xchg");
+}
+
+(function () {
+  runTestWithInputs(Inputs);
+  runTestWithInputs(Inputs2);
+})();
-- 
2.35.1


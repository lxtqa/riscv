From c38b8ebb43806819847e570a1110e615f2f48e3d Mon Sep 17 00:00:00 2001
From: Jakob Linke <jgruber@chromium.org>
Date: Thu, 23 Mar 2023 12:39:46 +0100
Subject: [PATCH] [code] Remove most embedded metadata for builtins

.. which is no longer needed now that we've fully split up the Code
and InstructionStream heap objects.

- Metadata (e.g. the handler table offset) now lives in the Code
  object.
- All builtins have a Code object.
- We're no longer forced to store it in .rodata for builtins.

The embedded metadata is pruned to contain only:

- instruction_offset
- instruction_length
- metadata_offset

for each builtin. `instruction_length` isn't strictly needed, but
remains there for ease of use.

This reduces the embedded metadata part of our embedded blob from
112KiB to 68KiB, and removes a bunch of unnecessary dispatches in
Code accessors.

Bug: v8:13789
Change-Id: If2ff04b5a39be2267cc216496f873247851da50c
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4360031
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Commit-Queue: Jakob Linke <jgruber@chromium.org>
Reviewed-by: Igor Sheludko <ishell@chromium.org>
Auto-Submit: Jakob Linke <jgruber@chromium.org>
Cr-Commit-Position: refs/heads/main@{#86659}
---
 src/builtins/builtins.cc                      |  34 ++--
 src/builtins/builtins.h                       |   4 +-
 src/codegen/handler-table.cc                  |   2 +-
 src/codegen/macro-assembler-base.cc           |   6 +-
 src/codegen/maglev-safepoint-table.cc         |   4 +-
 src/codegen/reloc-info.cc                     |   2 +-
 src/codegen/safepoint-table.cc                |   4 +-
 src/deoptimizer/deoptimizer-cfi-builtins.cc   |   2 +-
 src/execution/isolate.cc                      |   2 +-
 src/heap/factory.cc                           |   2 -
 src/objects/code-inl.h                        |  69 ++++----
 src/objects/code.cc                           | 152 ------------------
 src/objects/code.h                            |  67 ++------
 src/regexp/arm/regexp-macro-assembler-arm.cc  |   2 +-
 .../loong64/regexp-macro-assembler-loong64.cc |   2 +-
 .../mips64/regexp-macro-assembler-mips64.cc   |   2 +-
 src/regexp/ppc/regexp-macro-assembler-ppc.cc  |   2 +-
 .../riscv/regexp-macro-assembler-riscv.cc     |   2 +-
 src/snapshot/deserializer.cc                  |   7 +-
 src/snapshot/embedded/embedded-data-inl.h     | 141 ++--------------
 src/snapshot/embedded/embedded-data.cc        |  45 ++----
 src/snapshot/embedded/embedded-data.h         | 146 ++++++-----------
 src/snapshot/embedded/embedded-file-writer.cc |   8 +-
 .../platform-embedded-file-writer-win.cc      |   8 +-
 src/snapshot/read-only-deserializer.cc        |   6 +-
 src/utils/memcopy.cc                          |   6 +-
 src/wasm/wasm-code-manager.cc                 |   2 +-
 27 files changed, 164 insertions(+), 565 deletions(-)

diff --git a/src/builtins/builtins.cc b/src/builtins/builtins.cc
index 2c84a811bc2..ea41f048ef7 100644
--- a/src/builtins/builtins.cc
+++ b/src/builtins/builtins.cc
@@ -315,7 +315,7 @@ void Builtins::InitializeIsolateDataTables(Isolate* isolate) {
     DCHECK(Builtins::IsBuiltinId(isolate->builtins()->code(i).builtin_id()));
     DCHECK(!isolate->builtins()->code(i).has_instruction_stream());
     isolate_data->builtin_entry_table()[ToInt(i)] =
-        embedded_data.InstructionStartOfBuiltin(i);
+        embedded_data.InstructionStartOf(i);
   }
 
   // T0 tables.
@@ -365,28 +365,27 @@ Handle<Code> Builtins::CreateInterpreterEntryTrampolineForProfiling(
   DCHECK_NOT_NULL(isolate->embedded_blob_code());
   DCHECK_NE(0, isolate->embedded_blob_code_size());
 
-  EmbeddedData d = EmbeddedData::FromBlob(isolate);
-  const Builtin builtin = Builtin::kInterpreterEntryTrampolineForProfiling;
+  Code code = isolate->builtins()->code(
+      Builtin::kInterpreterEntryTrampolineForProfiling);
 
   CodeDesc desc;
-  desc.buffer = reinterpret_cast<byte*>(d.InstructionStartOfBuiltin(builtin));
+  desc.buffer = reinterpret_cast<byte*>(code.InstructionStart());
 
-  int instruction_size = d.InstructionSizeOfBuiltin(builtin);
+  int instruction_size = code.instruction_size();
   desc.buffer_size = instruction_size;
   desc.instr_size = instruction_size;
 
   // Ensure the code doesn't require creation of metadata, otherwise respective
   // fields of CodeDesc should be initialized.
-  DCHECK_EQ(d.SafepointTableSizeOf(builtin), 0);
-  DCHECK_EQ(d.HandlerTableSizeOf(builtin), 0);
-  DCHECK_EQ(d.ConstantPoolSizeOf(builtin), 0);
-  // TODO(v8:11036): currently the CodeDesc can't represent the state when the
-  // code metadata is stored separately from the instruction stream, therefore
-  // it cannot recreate code comments in the trampoline copy.
-  // The following DCHECK currently fails if the mksnapshot is run with enabled
-  // code comments.
-  DCHECK_EQ(d.CodeCommentsSizeOf(builtin), 0);
-  DCHECK_EQ(d.UnwindingInfoSizeOf(builtin), 0);
+  DCHECK_EQ(code.safepoint_table_size(), 0);
+  DCHECK_EQ(code.handler_table_size(), 0);
+  DCHECK_EQ(code.constant_pool_size(), 0);
+  // TODO(v8:11036): The following DCHECK currently fails if the mksnapshot is
+  // run with enabled code comments, i.e. --interpreted_frames_native_stack is
+  // incompatible with --code-comments at mksnapshot-time. If ever needed,
+  // implement support.
+  DCHECK_EQ(code.code_comments_size(), 0);
+  DCHECK_EQ(code.unwinding_info_size(), 0);
 
   desc.safepoint_table_offset = instruction_size;
   desc.handler_table_offset = instruction_size;
@@ -395,11 +394,8 @@ Handle<Code> Builtins::CreateInterpreterEntryTrampolineForProfiling(
 
   CodeDesc::Verify(&desc);
 
-  const int kind_specific_flags =
-      isolate->builtins()->code(builtin).kind_specific_flags(kRelaxedLoad);
-
   return Factory::CodeBuilder(isolate, desc, CodeKind::BUILTIN)
-      .set_kind_specific_flags(kind_specific_flags)
+      .set_kind_specific_flags(code.kind_specific_flags(kRelaxedLoad))
       // Mimic the InterpreterEntryTrampoline.
       .set_builtin(Builtin::kInterpreterEntryTrampoline)
       .Build();
diff --git a/src/builtins/builtins.h b/src/builtins/builtins.h
index 91811adb8bb..7fc3cc28f2e 100644
--- a/src/builtins/builtins.h
+++ b/src/builtins/builtins.h
@@ -90,7 +90,9 @@ class Builtins {
       kFirstWideBytecodeHandler + kNumberOfWideBytecodeHandlers;
   static constexpr int kLastBytecodeHandlerPlusOne =
       kFirstExtraWideBytecodeHandler + kNumberOfWideBytecodeHandlers;
-  static_assert(kLastBytecodeHandlerPlusOne == kBuiltinCount);
+  static constexpr bool kBytecodeHandlersAreSortedLast =
+      kLastBytecodeHandlerPlusOne == kBuiltinCount;
+  static_assert(kBytecodeHandlersAreSortedLast);
 
   static constexpr bool IsBuiltinId(Builtin builtin) {
     return builtin != Builtin::kNoBuiltinId;
diff --git a/src/codegen/handler-table.cc b/src/codegen/handler-table.cc
index a00f9113ffb..833e94432bf 100644
--- a/src/codegen/handler-table.cc
+++ b/src/codegen/handler-table.cc
@@ -20,7 +20,7 @@ namespace v8 {
 namespace internal {
 
 HandlerTable::HandlerTable(Code code)
-    : HandlerTable(code.HandlerTableAddress(), code.handler_table_size(),
+    : HandlerTable(code.handler_table_address(), code.handler_table_size(),
                    kReturnAddressBasedEncoding) {}
 
 #if V8_ENABLE_WEBASSEMBLY
diff --git a/src/codegen/macro-assembler-base.cc b/src/codegen/macro-assembler-base.cc
index 899f67830f4..18ffcdac54b 100644
--- a/src/codegen/macro-assembler-base.cc
+++ b/src/codegen/macro-assembler-base.cc
@@ -30,12 +30,12 @@ Address MacroAssemblerBase::BuiltinEntry(Builtin builtin) {
   DCHECK(Builtins::IsBuiltinId(builtin));
   if (isolate_ != nullptr) {
     Address entry = isolate_->builtin_entry_table()[Builtins::ToInt(builtin)];
-    DCHECK_EQ(entry, EmbeddedData::FromBlob(isolate_).InstructionStartOfBuiltin(
-                         builtin));
+    DCHECK_EQ(entry,
+              EmbeddedData::FromBlob(isolate_).InstructionStartOf(builtin));
     return entry;
   }
   EmbeddedData d = EmbeddedData::FromBlob();
-  return d.InstructionStartOfBuiltin(builtin);
+  return d.InstructionStartOf(builtin);
 }
 
 void MacroAssemblerBase::IndirectLoadConstant(Register destination,
diff --git a/src/codegen/maglev-safepoint-table.cc b/src/codegen/maglev-safepoint-table.cc
index 50adb61efd9..9f6b692466c 100644
--- a/src/codegen/maglev-safepoint-table.cc
+++ b/src/codegen/maglev-safepoint-table.cc
@@ -15,14 +15,14 @@ namespace internal {
 MaglevSafepointTable::MaglevSafepointTable(Isolate* isolate, Address pc,
                                            Code code)
     : MaglevSafepointTable(code.InstructionStart(isolate, pc),
-                           code.SafepointTableAddress()) {
+                           code.safepoint_table_address()) {
   DCHECK(code.is_maglevved());
 }
 
 MaglevSafepointTable::MaglevSafepointTable(Isolate* isolate, Address pc,
                                            GcSafeCode code)
     : MaglevSafepointTable(code.InstructionStart(isolate, pc),
-                           code.SafepointTableAddress()) {
+                           code.safepoint_table_address()) {
   DCHECK(code.is_maglevved());
 }
 
diff --git a/src/codegen/reloc-info.cc b/src/codegen/reloc-info.cc
index a7c4be40c4c..c9483ae20bd 100644
--- a/src/codegen/reloc-info.cc
+++ b/src/codegen/reloc-info.cc
@@ -283,7 +283,7 @@ RelocIterator::RelocIterator(const CodeReference code_reference, int mode_mask)
 RelocIterator::RelocIterator(EmbeddedData* embedded_data, Code code,
                              int mode_mask)
     : RelocIterator(code, code.instruction_stream(),
-                    embedded_data->InstructionStartOfBuiltin(code.builtin_id()),
+                    embedded_data->InstructionStartOf(code.builtin_id()),
                     code.constant_pool(),
                     code.relocation_start() + code.relocation_size(),
                     code.relocation_start(), mode_mask) {}
diff --git a/src/codegen/safepoint-table.cc b/src/codegen/safepoint-table.cc
index b1ae0d8a7eb..580c20c31c1 100644
--- a/src/codegen/safepoint-table.cc
+++ b/src/codegen/safepoint-table.cc
@@ -22,11 +22,11 @@ namespace internal {
 
 SafepointTable::SafepointTable(Isolate* isolate, Address pc, Code code)
     : SafepointTable(code.InstructionStart(isolate, pc),
-                     code.SafepointTableAddress()) {}
+                     code.safepoint_table_address()) {}
 
 SafepointTable::SafepointTable(Isolate* isolate, Address pc, GcSafeCode code)
     : SafepointTable(code.InstructionStart(isolate, pc),
-                     code.SafepointTableAddress()) {}
+                     code.safepoint_table_address()) {}
 
 #if V8_ENABLE_WEBASSEMBLY
 SafepointTable::SafepointTable(const wasm::WasmCode* code)
diff --git a/src/deoptimizer/deoptimizer-cfi-builtins.cc b/src/deoptimizer/deoptimizer-cfi-builtins.cc
index 58b1c35d5c2..16be7da1ff9 100644
--- a/src/deoptimizer/deoptimizer-cfi-builtins.cc
+++ b/src/deoptimizer/deoptimizer-cfi-builtins.cc
@@ -43,7 +43,7 @@ constexpr function_ptr builtins[] = {
 };
 
 bool Deoptimizer::IsValidReturnAddress(Address address, Isolate* isolate) {
-  EmbeddedData d = EmbeddedData::GetEmbeddedDataForPC(isolate, address);
+  EmbeddedData d = EmbeddedData::FromBlobForPc(isolate, address);
   Address code_start = reinterpret_cast<Address>(d.code());
   Address offset = address - code_start;
   if (offset >= v8_Default_embedded_blob_code_size_) return false;
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index 06c707da96c..3ffbd33f03f 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -3839,7 +3839,7 @@ void CreateOffHeapTrampolines(Isolate* isolate) {
   static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);
   for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
        ++builtin) {
-    Address instruction_start = d.InstructionStartOfBuiltin(builtin);
+    Address instruction_start = d.InstructionStartOf(builtin);
     Handle<Code> trampoline = isolate->factory()->NewOffHeapTrampolineFor(
         builtins->code_handle(builtin), instruction_start);
 
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index c952862340d..b2be3fcd5a0 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -2545,8 +2545,6 @@ Handle<Code> Factory::NewOffHeapTrampolineFor(Handle<Code> code,
   off_heap_trampoline->set_code_entry_point(isolate(),
                                             code->code_entry_point());
 
-  DCHECK_EQ(code->instruction_size(), code->OffHeapInstructionSize());
-  DCHECK_EQ(code->metadata_size(), code->OffHeapMetadataSize());
   DCHECK_EQ(code->inlined_bytecode_size(), 0);
   DCHECK_EQ(code->osr_offset(), BytecodeOffset::None());
 
diff --git a/src/objects/code-inl.h b/src/objects/code-inl.h
index e864d57ce03..79d4743c115 100644
--- a/src/objects/code-inl.h
+++ b/src/objects/code-inl.h
@@ -21,6 +21,7 @@
 #include "src/objects/oddball.h"
 #include "src/objects/shared-function-info-inl.h"
 #include "src/objects/smi-inl.h"
+#include "src/snapshot/embedded/embedded-data-inl.h"
 #include "src/utils/utils.h"
 
 // Has to be the last include (doesn't have include guards):
@@ -68,7 +69,7 @@ GCSAFE_CODE_FWD_ACCESSOR(bool, marked_for_deoptimization)
 GCSAFE_CODE_FWD_ACCESSOR(Object, raw_instruction_stream)
 GCSAFE_CODE_FWD_ACCESSOR(int, stack_slots)
 GCSAFE_CODE_FWD_ACCESSOR(Address, constant_pool)
-GCSAFE_CODE_FWD_ACCESSOR(Address, SafepointTableAddress)
+GCSAFE_CODE_FWD_ACCESSOR(Address, safepoint_table_address)
 #undef GCSAFE_CODE_FWD_ACCESSOR
 
 int GcSafeCode::GetOffsetFromInstructionStart(Isolate* isolate,
@@ -405,24 +406,33 @@ Address Code::InstructionEnd() const {
 }
 
 Address Code::metadata_start() const {
-  return InstructionStart() + instruction_size();
+  if (has_instruction_stream()) {
+    static_assert(InstructionStream::kOnHeapBodyIsContiguous);
+    return InstructionStart() + instruction_size();
+  }
+  // An embedded builtin. Remapping is irrelevant wrt the metadata section so
+  // we can simply use the global blob.
+  // TODO(jgruber): Consider adding this as a physical Code field to avoid the
+  // lookup. Alternatively, rename this (and callers) to camel-case to clarify
+  // it's more than a simple accessor.
+  static_assert(!InstructionStream::kOffHeapBodyIsContiguous);
+  return EmbeddedData::FromBlob().MetadataStartOf(builtin_id());
 }
 
 Address Code::InstructionStart(Isolate* isolate, Address pc) const {
-  return V8_LIKELY(has_instruction_stream())
-             ? code_entry_point()
-             : OffHeapInstructionStart(isolate, pc);
+  if (V8_LIKELY(has_instruction_stream())) return code_entry_point();
+  // Note we intentionally don't bounds-check that `pc` is within the returned
+  // instruction area.
+  return EmbeddedData::FromBlobForPc(isolate, pc)
+      .InstructionStartOf(builtin_id());
 }
 
 Address Code::InstructionEnd(Isolate* isolate, Address pc) const {
-  return V8_LIKELY(has_instruction_stream())
-             ? InstructionEnd()
-             : OffHeapInstructionEnd(isolate, pc);
+  return InstructionStart(isolate, pc) + InstructionSize();
 }
 
 int Code::GetOffsetFromInstructionStart(Isolate* isolate, Address pc) const {
-  Address instruction_start = InstructionStart(isolate, pc);
-  Address offset = pc - instruction_start;
+  const Address offset = pc - InstructionStart(isolate, pc);
   DCHECK_LE(offset, InstructionSize());
   return static_cast<int>(offset);
 }
@@ -444,11 +454,6 @@ Address Code::safepoint_table_address() const {
   return metadata_start() + safepoint_table_offset();
 }
 
-Address Code::SafepointTableAddress() const {
-  return V8_LIKELY(has_instruction_stream()) ? safepoint_table_address()
-                                             : OffHeapSafepointTableAddress();
-}
-
 int Code::safepoint_table_size() const {
   return handler_table_offset() - safepoint_table_offset();
 }
@@ -459,11 +464,6 @@ Address Code::handler_table_address() const {
   return metadata_start() + handler_table_offset();
 }
 
-Address Code::HandlerTableAddress() const {
-  return V8_LIKELY(has_instruction_stream()) ? handler_table_address()
-                                             : OffHeapHandlerTableAddress();
-}
-
 int Code::handler_table_size() const {
   return constant_pool_offset() - handler_table_offset();
 }
@@ -471,8 +471,6 @@ int Code::handler_table_size() const {
 bool Code::has_handler_table() const { return handler_table_size() > 0; }
 
 int Code::constant_pool_size() const {
-  if V8_UNLIKELY (!has_instruction_stream()) return OffHeapConstantPoolSize();
-
   const int size = code_comments_offset() - constant_pool_offset();
   if (!V8_EMBEDDED_CONSTANT_POOL_BOOL) {
     DCHECK_EQ(size, 0);
@@ -519,15 +517,10 @@ int Code::relocation_size() const {
 
 Address InstructionStream::entry() const { return instruction_start(); }
 
-bool InstructionStream::contains(Isolate* isolate, Address inner_pointer) {
-  return (address() <= inner_pointer) &&
-         (inner_pointer < address() + CodeSize());
-}
-
-bool Code::contains(Isolate* isolate, Address inner_pointer) {
-  return has_instruction_stream()
-             ? instruction_stream().contains(isolate, inner_pointer)
-             : OffHeapBuiltinContains(isolate, inner_pointer);
+bool Code::contains(Isolate* isolate, Address inner_pointer) const {
+  const Address start = InstructionStart(isolate, inner_pointer);
+  if (inner_pointer < start) return false;
+  return inner_pointer < start + InstructionSize();
 }
 
 // static
@@ -762,15 +755,11 @@ void Code::set_constant_pool_offset(int value) {
 
 Address Code::constant_pool() const {
   if (!has_constant_pool()) return kNullAddress;
-  return V8_LIKELY(has_instruction_stream())
-             ? metadata_start() + constant_pool_offset()
-             : OffHeapConstantPoolAddress();
+  return metadata_start() + constant_pool_offset();
 }
 
 Address Code::code_comments() const {
-  return V8_LIKELY(has_instruction_stream())
-             ? metadata_start() + code_comments_offset()
-             : OffHeapCodeCommentsAddress();
+  return metadata_start() + code_comments_offset();
 }
 
 int Code::code_comments_size() const {
@@ -977,9 +966,9 @@ void Code::SetCodeEntryPointForSerialization(Isolate* isolate, Address entry) {
 }
 
 void Code::UpdateCodeEntryPoint(Isolate* isolate_for_sandbox,
-                                InstructionStream code) {
-  DCHECK_EQ(raw_instruction_stream(), code);
-  set_code_entry_point(isolate_for_sandbox, code.instruction_start());
+                                InstructionStream istream) {
+  DCHECK_EQ(raw_instruction_stream(), istream);
+  set_code_entry_point(isolate_for_sandbox, istream.instruction_start());
 }
 
 Address Code::InstructionStart() const { return code_entry_point(); }
diff --git a/src/objects/code.cc b/src/objects/code.cc
index 1ca28beb309..5cf3206f8fb 100644
--- a/src/objects/code.cc
+++ b/src/objects/code.cc
@@ -38,140 +38,6 @@
 namespace v8 {
 namespace internal {
 
-namespace {
-
-// Helper function for getting an EmbeddedData that can handle un-embedded
-// builtins when short builtin calls are enabled.
-inline EmbeddedData EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(
-    HeapObject code) {
-#if defined(V8_COMPRESS_POINTERS_IN_ISOLATE_CAGE)
-  // GetIsolateFromWritableObject(*this) works for both read-only and writable
-  // objects when pointer compression is enabled with a per-Isolate cage.
-  return EmbeddedData::FromBlob(GetIsolateFromWritableObject(code));
-#elif defined(V8_COMPRESS_POINTERS_IN_SHARED_CAGE)
-  // When pointer compression is enabled with a shared cage, there is also a
-  // shared CodeRange. When short builtin calls are enabled, there is a single
-  // copy of the re-embedded builtins in the shared CodeRange, so use that if
-  // it's present.
-  if (v8_flags.jitless) return EmbeddedData::FromBlob();
-  CodeRange* code_range = CodeRange::GetProcessWideCodeRange();
-  return (code_range && code_range->embedded_blob_code_copy() != nullptr)
-             ? EmbeddedData::FromBlob(code_range)
-             : EmbeddedData::FromBlob();
-#else
-  // Otherwise there is a single copy of the blob across all Isolates, use the
-  // global atomic variables.
-  return EmbeddedData::FromBlob();
-#endif
-}
-
-}  // namespace
-
-Address Code::OffHeapInstructionStart() const {
-  // TODO(11527): Here and below: pass Isolate as an argument for getting
-  // the EmbeddedData.
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.InstructionStartOfBuiltin(builtin);
-}
-
-Address Code::OffHeapInstructionEnd() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.InstructionStartOfBuiltin(builtin) +
-         d.InstructionSizeOfBuiltin(builtin);
-}
-
-int Code::OffHeapInstructionSize() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.InstructionSizeOfBuiltin(builtin);
-}
-
-Address Code::OffHeapMetadataStart() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.MetadataStartOfBuiltin(builtin);
-}
-
-Address Code::OffHeapMetadataEnd() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.MetadataStartOfBuiltin(builtin) + d.MetadataSizeOfBuiltin(builtin);
-}
-
-int Code::OffHeapMetadataSize() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.MetadataSizeOfBuiltin(builtin);
-}
-
-Address Code::OffHeapSafepointTableAddress() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.SafepointTableStartOf(builtin);
-}
-
-int Code::OffHeapSafepointTableSize() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.SafepointTableSizeOf(builtin);
-}
-
-Address Code::OffHeapHandlerTableAddress() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.HandlerTableStartOf(builtin);
-}
-
-int Code::OffHeapHandlerTableSize() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.HandlerTableSizeOf(builtin);
-}
-
-Address Code::OffHeapConstantPoolAddress() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.ConstantPoolStartOf(builtin);
-}
-
-int Code::OffHeapConstantPoolSize() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.ConstantPoolSizeOf(builtin);
-}
-
-Address Code::OffHeapCodeCommentsAddress() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.CodeCommentsStartOf(builtin);
-}
-
-int Code::OffHeapCodeCommentsSize() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.CodeCommentsSizeOf(builtin);
-}
-
-Address Code::OffHeapUnwindingInfoAddress() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.UnwindingInfoStartOf(builtin);
-}
-
-int Code::OffHeapUnwindingInfoSize() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.UnwindingInfoSizeOf(builtin);
-}
-
-int Code::OffHeapStackSlots() const {
-  Builtin builtin = builtin_id();
-  EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.StackSlotsOf(builtin);
-}
-
 void Code::ClearEmbeddedObjects(Heap* heap) {
   HeapObject undefined = ReadOnlyRoots(heap).undefined_value();
   int mode_mask = RelocInfo::EmbeddedObjectModeMask();
@@ -278,24 +144,6 @@ MaglevSafepointEntry Code::GetMaglevSafepointEntry(Isolate* isolate,
   return table.FindEntry(pc);
 }
 
-Address Code::OffHeapInstructionStart(Isolate* isolate, Address pc) const {
-  DCHECK(!has_instruction_stream());
-  EmbeddedData d = EmbeddedData::GetEmbeddedDataForPC(isolate, pc);
-  return d.InstructionStartOfBuiltin(builtin_id());
-}
-
-Address Code::OffHeapInstructionEnd(Isolate* isolate, Address pc) const {
-  DCHECK(!has_instruction_stream());
-  EmbeddedData d = EmbeddedData::GetEmbeddedDataForPC(isolate, pc);
-  return d.InstructionEndOf(builtin_id());
-}
-
-bool Code::OffHeapBuiltinContains(Isolate* isolate, Address pc) const {
-  DCHECK(!has_instruction_stream());
-  EmbeddedData d = EmbeddedData::GetEmbeddedDataForPC(isolate, pc);
-  return d.BuiltinContains(builtin_id(), pc);
-}
-
 // TODO(cbruni): Move to BytecodeArray
 int AbstractCode::SourcePosition(PtrComprCageBase cage_base, int offset) {
   CHECK_NE(kind(cage_base), CodeKind::BASELINE);
diff --git a/src/objects/code.h b/src/objects/code.h
index e4cba409486..4f11ade1820 100644
--- a/src/objects/code.h
+++ b/src/objects/code.h
@@ -101,11 +101,14 @@ class Code : public HeapObject {
   inline bool has_instruction_stream() const;
   inline bool has_instruction_stream(RelaxedLoadTag) const;
 
-  // Cached value of instruction_stream().InstructionStart().
+  // The cached value of instruction_stream().InstructionStart(), *or* a
+  // pointer to the off-heap entry point for embedded builtins.
   DECL_GETTER(code_entry_point, Address)
 
   // Aliases for code_entry_point for API compatibility with InstructionStream.
   inline Address InstructionStart() const;
+  inline Address InstructionEnd() const;
+  inline int InstructionSize() const;
 
   inline void SetInstructionStreamAndEntryPoint(
       Isolate* isolate_for_sandbox, InstructionStream code,
@@ -114,10 +117,10 @@ class Code : public HeapObject {
                                              Address entry);
   inline void SetCodeEntryPointForSerialization(Isolate* isolate,
                                                 Address entry);
-  // Updates the value of the code entry point. The code must be equal to
-  // the code() value.
+  // Updates the value of the code entry point. `istream` must be equal to
+  // the instruction_stream() value.
   inline void UpdateCodeEntryPoint(Isolate* isolate_for_sandbox,
-                                   InstructionStream code);
+                                   InstructionStream istream);
 
   DECL_RELAXED_UINT16_ACCESSORS(kind_specific_flags)
 
@@ -217,14 +220,11 @@ class Code : public HeapObject {
   inline ByteArray SourcePositionTable(Isolate* isolate,
                                        SharedFunctionInfo sfi) const;
 
-  // Returns true if pc is inside this object's instructions.
-  inline bool contains(Isolate* isolate, Address pc);
-
-  inline Address SafepointTableAddress() const;
+  inline Address safepoint_table_address() const;
   inline int safepoint_table_size() const;
   inline bool has_safepoint_table() const;
 
-  inline Address HandlerTableAddress() const;
+  inline Address handler_table_address() const;
   inline int handler_table_size() const;
   inline bool has_handler_table() const;
 
@@ -255,13 +255,11 @@ class Code : public HeapObject {
   inline Address metadata_start() const;
   inline Address metadata_end() const;
 
-  inline Address handler_table_address() const;
-
-  inline Address safepoint_table_address() const;
-
   inline int CodeSize() const;
   inline int SizeIncludingMetadata() const;
 
+  // The following functions include support for short builtin calls:
+  //
   // When builtins un-embedding is enabled for the Isolate
   // (see Isolate::is_short_builtin_calls_enabled()) then both embedded and
   // un-embedded builtins might be exeuted and thus two kinds of |pc|s might
@@ -274,32 +272,19 @@ class Code : public HeapObject {
   // instruction_start/end() values.
   // TODO(11527): remove these versions once the full solution is ready.
   inline Address InstructionStart(Isolate* isolate, Address pc) const;
-  V8_EXPORT_PRIVATE Address OffHeapInstructionStart() const;
-  V8_EXPORT_PRIVATE Address OffHeapInstructionStart(Isolate* isolate,
-                                                    Address pc) const;
   inline Address InstructionEnd(Isolate* isolate, Address pc) const;
-  V8_EXPORT_PRIVATE Address OffHeapInstructionEnd(Isolate* isolate,
-                                                  Address pc) const;
-
-  V8_EXPORT_PRIVATE bool OffHeapBuiltinContains(Isolate* isolate,
-                                                Address pc) const;
-
-  inline Address InstructionEnd() const;
-  inline int InstructionSize() const;
+  inline bool contains(Isolate* isolate, Address pc) const;
+  inline int GetOffsetFromInstructionStart(Isolate* isolate, Address pc) const;
+  // Support for short builtin calls END.
 
   SafepointEntry GetSafepointEntry(Isolate* isolate, Address pc);
   MaglevSafepointEntry GetMaglevSafepointEntry(Isolate* isolate, Address pc);
 
-  inline int GetOffsetFromInstructionStart(Isolate* isolate, Address pc) const;
-
   void SetMarkedForDeoptimization(Isolate* isolate, const char* reason);
 
   inline bool CanContainWeakObjects();
-
   inline bool IsWeakObject(HeapObject object);
-
   static inline bool IsWeakObjectInOptimizedCode(HeapObject object);
-
   static inline bool IsWeakObjectInDeoptimizationLiteralArray(Object object);
 
   // This function should be called only from GC.
@@ -447,23 +432,6 @@ class Code : public HeapObject {
   // InstructionStream object.
   DECL_RELAXED_UINT16_ACCESSORS(flags)
 
-  V8_EXPORT_PRIVATE Address OffHeapInstructionEnd() const;
-  V8_EXPORT_PRIVATE int OffHeapInstructionSize() const;
-  V8_EXPORT_PRIVATE Address OffHeapMetadataStart() const;
-  V8_EXPORT_PRIVATE Address OffHeapMetadataEnd() const;
-  V8_EXPORT_PRIVATE int OffHeapMetadataSize() const;
-  V8_EXPORT_PRIVATE Address OffHeapSafepointTableAddress() const;
-  V8_EXPORT_PRIVATE int OffHeapSafepointTableSize() const;
-  V8_EXPORT_PRIVATE Address OffHeapHandlerTableAddress() const;
-  V8_EXPORT_PRIVATE int OffHeapHandlerTableSize() const;
-  V8_EXPORT_PRIVATE Address OffHeapConstantPoolAddress() const;
-  V8_EXPORT_PRIVATE int OffHeapConstantPoolSize() const;
-  V8_EXPORT_PRIVATE Address OffHeapCodeCommentsAddress() const;
-  V8_EXPORT_PRIVATE int OffHeapCodeCommentsSize() const;
-  V8_EXPORT_PRIVATE Address OffHeapUnwindingInfoAddress() const;
-  V8_EXPORT_PRIVATE int OffHeapUnwindingInfoSize() const;
-  V8_EXPORT_PRIVATE int OffHeapStackSlots() const;
-
   enum BytecodeToPCPosition {
     kPcAtStartOfBytecode,
     // End of bytecode equals the start of the next bytecode.
@@ -529,6 +497,7 @@ class GcSafeCode : public HeapObject {
   inline bool marked_for_deoptimization() const;
   inline Object raw_instruction_stream() const;
   inline Address constant_pool() const;
+  inline Address safepoint_table_address() const;
   inline int stack_slots() const;
 
   inline int GetOffsetFromInstructionStart(Isolate* isolate, Address pc) const;
@@ -537,9 +506,6 @@ class GcSafeCode : public HeapObject {
   inline bool CanDeoptAt(Isolate* isolate, Address pc) const;
   inline Object raw_instruction_stream(PtrComprCageBase code_cage_base) const;
 
-  // Accessors that had to be modified to be used in GC settings.
-  inline Address SafepointTableAddress() const;
-
  private:
   OBJECT_CONSTRUCTORS(GcSafeCode, HeapObject);
 };
@@ -622,9 +588,6 @@ class InstructionStream : public HeapObject {
   // InstructionStream entry point.
   inline Address entry() const;
 
-  // Returns true if pc is inside this object's instructions.
-  inline bool contains(Isolate* isolate, Address pc);
-
   // Relocate the code by delta bytes. Called to signal that this code
   // object has been moved by delta bytes.
   void Relocate(intptr_t delta);
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index 89d3ea62529..6f1180eb4e5 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -1177,7 +1177,7 @@ void RegExpMacroAssemblerARM::CallCheckStackGuardState() {
   __ mov(ip, Operand(stack_guard_check));
 
   EmbeddedData d = EmbeddedData::FromBlob();
-  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
+  Address entry = d.InstructionStartOf(Builtin::kDirectCEntry);
   __ mov(lr, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(lr);
 
diff --git a/src/regexp/loong64/regexp-macro-assembler-loong64.cc b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
index 472d513b97a..66a6d9f25e2 100644
--- a/src/regexp/loong64/regexp-macro-assembler-loong64.cc
+++ b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
@@ -1167,7 +1167,7 @@ void RegExpMacroAssemblerLOONG64::CallCheckStackGuardState(Register scratch) {
 
   EmbeddedData d = EmbeddedData::FromBlob();
   CHECK(Builtins::IsIsolateIndependent(Builtin::kDirectCEntry));
-  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
+  Address entry = d.InstructionStartOf(Builtin::kDirectCEntry);
   __ li(kScratchReg, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(kScratchReg);
 
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.cc b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
index 46f009480b2..4818a437a67 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.cc
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
@@ -1217,7 +1217,7 @@ void RegExpMacroAssemblerMIPS::CallCheckStackGuardState(Register scratch) {
 
   EmbeddedData d = EmbeddedData::FromBlob();
   CHECK(Builtins::IsIsolateIndependent(Builtin::kDirectCEntry));
-  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
+  Address entry = d.InstructionStartOf(Builtin::kDirectCEntry);
   __ li(kScratchReg, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(kScratchReg);
 
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index 3576f318fed..63ebfc07223 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -1249,7 +1249,7 @@ void RegExpMacroAssemblerPPC::CallCheckStackGuardState(Register scratch) {
   __ mov(ip, Operand(stack_guard_check));
 
   EmbeddedData d = EmbeddedData::FromBlob();
-  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
+  Address entry = d.InstructionStartOf(Builtin::kDirectCEntry);
   __ mov(r0, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(r0);
 
diff --git a/src/regexp/riscv/regexp-macro-assembler-riscv.cc b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
index 9eb1807de84..b1f262dcc95 100644
--- a/src/regexp/riscv/regexp-macro-assembler-riscv.cc
+++ b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
@@ -1177,7 +1177,7 @@ void RegExpMacroAssemblerRISCV::CallCheckStackGuardState(Register scratch) {
 
   EmbeddedData d = EmbeddedData::FromBlob();
   CHECK(Builtins::IsIsolateIndependent(Builtin::kDirectCEntry));
-  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
+  Address entry = d.InstructionStartOf(Builtin::kDirectCEntry);
   __ li(kScratchReg, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(kScratchReg);
 
diff --git a/src/snapshot/deserializer.cc b/src/snapshot/deserializer.cc
index e71af5266dc..3ec6548e54c 100644
--- a/src/snapshot/deserializer.cc
+++ b/src/snapshot/deserializer.cc
@@ -496,8 +496,9 @@ void Deserializer<IsolateT>::PostProcessNewObject(Handle<Map> map,
     Code code = Code::cast(raw_obj);
     code.init_code_entry_point(main_thread_isolate(), kNullAddress);
     if (!code.has_instruction_stream()) {
-      code.SetEntryPointForOffHeapBuiltin(main_thread_isolate(),
-                                          code.OffHeapInstructionStart());
+      code.SetEntryPointForOffHeapBuiltin(
+          main_thread_isolate(), EmbeddedData::FromBlob(main_thread_isolate())
+                                     .InstructionStartOf(code.builtin_id()));
     } else {
       code.UpdateCodeEntryPoint(main_thread_isolate(),
                                 code.instruction_stream());
@@ -797,7 +798,7 @@ void DeserializerRelocInfoVisitor::VisitOffHeapTarget(RelocInfo* rinfo) {
 
   CHECK_NOT_NULL(isolate()->embedded_blob_code());
   EmbeddedData d = EmbeddedData::FromBlob(isolate());
-  Address address = d.InstructionStartOfBuiltin(builtin);
+  Address address = d.InstructionStartOf(builtin);
   CHECK_NE(kNullAddress, address);
 
   // TODO(ishell): implement RelocInfo::set_target_off_heap_target()
diff --git a/src/snapshot/embedded/embedded-data-inl.h b/src/snapshot/embedded/embedded-data-inl.h
index 028bdd07134..3d0588e0e5c 100644
--- a/src/snapshot/embedded/embedded-data-inl.h
+++ b/src/snapshot/embedded/embedded-data-inl.h
@@ -10,18 +10,7 @@
 namespace v8 {
 namespace internal {
 
-bool EmbeddedData::BuiltinContains(Builtin builtin, Address pc) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  Address start =
-      reinterpret_cast<Address>(RawCode() + desc.instruction_offset);
-  DCHECK_LT(start, reinterpret_cast<Address>(code_ + code_size_));
-  if (pc < start) return false;
-  Address end = start + desc.instruction_length;
-  return pc < end;
-}
-
-Address EmbeddedData::InstructionStartOfBuiltin(Builtin builtin) const {
+Address EmbeddedData::InstructionStartOf(Builtin builtin) const {
   DCHECK(Builtins::IsBuiltinId(builtin));
   const struct LayoutDescription& desc = LayoutDescription(builtin);
   const uint8_t* result = RawCode() + desc.instruction_offset;
@@ -38,13 +27,13 @@ Address EmbeddedData::InstructionEndOf(Builtin builtin) const {
   return reinterpret_cast<Address>(result);
 }
 
-uint32_t EmbeddedData::InstructionSizeOfBuiltin(Builtin builtin) const {
+uint32_t EmbeddedData::InstructionSizeOf(Builtin builtin) const {
   DCHECK(Builtins::IsBuiltinId(builtin));
   const struct LayoutDescription& desc = LayoutDescription(builtin);
   return desc.instruction_length;
 }
 
-Address EmbeddedData::MetadataStartOfBuiltin(Builtin builtin) const {
+Address EmbeddedData::MetadataStartOf(Builtin builtin) const {
   DCHECK(Builtins::IsBuiltinId(builtin));
   const struct LayoutDescription& desc = LayoutDescription(builtin);
   const uint8_t* result = RawMetadata() + desc.metadata_offset;
@@ -52,130 +41,18 @@ Address EmbeddedData::MetadataStartOfBuiltin(Builtin builtin) const {
   return reinterpret_cast<Address>(result);
 }
 
-uint32_t EmbeddedData::MetadataSizeOfBuiltin(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  return desc.metadata_length;
-}
-
-Address EmbeddedData::SafepointTableStartOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  const uint8_t* result = RawMetadata() + desc.metadata_offset;
-  DCHECK_LE(desc.handler_table_offset, data_size_);
-  return reinterpret_cast<Address>(result);
-}
-
-uint32_t EmbeddedData::SafepointTableSizeOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-#if V8_EMBEDDED_CONSTANT_POOL_BOOL
-  DCHECK_LE(desc.handler_table_offset, desc.constant_pool_offset);
-#else
-  DCHECK_LE(desc.handler_table_offset, desc.code_comments_offset_offset);
-#endif
-  return desc.handler_table_offset - desc.metadata_offset;
-}
-
-Address EmbeddedData::HandlerTableStartOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  const uint8_t* result = RawMetadata() + desc.handler_table_offset;
-  DCHECK_LE(desc.handler_table_offset, data_size_);
-  return reinterpret_cast<Address>(result);
-}
-
-uint32_t EmbeddedData::HandlerTableSizeOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-#if V8_EMBEDDED_CONSTANT_POOL_BOOL
-  DCHECK_LE(desc.handler_table_offset, desc.constant_pool_offset);
-  return desc.constant_pool_offset - desc.handler_table_offset;
-#else
-  DCHECK_LE(desc.handler_table_offset, desc.code_comments_offset_offset);
-  return desc.code_comments_offset_offset - desc.handler_table_offset;
-#endif
-}
-
-Address EmbeddedData::ConstantPoolStartOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-#if V8_EMBEDDED_CONSTANT_POOL_BOOL
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  const uint8_t* result = RawMetadata() + desc.constant_pool_offset;
-  DCHECK_LE(desc.constant_pool_offset, data_size_);
-  return reinterpret_cast<Address>(result);
-#else
-  return kNullAddress;
-#endif
-}
-
-uint32_t EmbeddedData::ConstantPoolSizeOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-#if V8_EMBEDDED_CONSTANT_POOL_BOOL
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  DCHECK_LE(desc.constant_pool_offset, desc.code_comments_offset_offset);
-  return desc.code_comments_offset_offset - desc.constant_pool_offset;
-#else
-  return 0;
-#endif
-}
-
-Address EmbeddedData::CodeCommentsStartOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  const uint8_t* result = RawMetadata() + desc.code_comments_offset_offset;
-  DCHECK_LE(desc.code_comments_offset_offset, data_size_);
-  return reinterpret_cast<Address>(result);
-}
-
-uint32_t EmbeddedData::CodeCommentsSizeOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  DCHECK_LE(desc.code_comments_offset_offset,
-            desc.unwinding_info_offset_offset);
-  return desc.unwinding_info_offset_offset - desc.code_comments_offset_offset;
-}
-
-Address EmbeddedData::UnwindingInfoStartOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  const uint8_t* result = RawMetadata() + desc.unwinding_info_offset_offset;
-  DCHECK_LE(desc.unwinding_info_offset_offset, data_size_);
-  return reinterpret_cast<Address>(result);
-}
-
-uint32_t EmbeddedData::UnwindingInfoSizeOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  uint32_t metadata_end_offset = desc.metadata_offset + desc.metadata_length;
-  DCHECK_LE(desc.unwinding_info_offset_offset, metadata_end_offset);
-  return metadata_end_offset - desc.unwinding_info_offset_offset;
-}
-
-uint32_t EmbeddedData::StackSlotsOf(Builtin builtin) const {
-  DCHECK(Builtins::IsBuiltinId(builtin));
-  const struct LayoutDescription& desc = LayoutDescription(builtin);
-  return desc.stack_slots;
-}
-
 Address EmbeddedData::InstructionStartOfBytecodeHandlers() const {
-  return InstructionStartOfBuiltin(Builtin::kFirstBytecodeHandler);
+  return InstructionStartOf(Builtin::kFirstBytecodeHandler);
 }
 
 Address EmbeddedData::InstructionEndOfBytecodeHandlers() const {
-  static_assert(static_cast<int>(Builtin::kFirstBytecodeHandler) +
-                    kNumberOfBytecodeHandlers +
-                    2 * kNumberOfWideBytecodeHandlers ==
-                Builtins::kBuiltinCount);
-  Builtin lastBytecodeHandler = Builtins::FromInt(Builtins::kBuiltinCount - 1);
-  return InstructionStartOfBuiltin(lastBytecodeHandler) +
-         InstructionSizeOfBuiltin(lastBytecodeHandler);
+  static_assert(Builtins::kBytecodeHandlersAreSortedLast);
+  // Note this also includes trailing padding, but that's fine for our purposes.
+  return reinterpret_cast<Address>(code_ + code_size_);
 }
 
-// Padded with kCodeAlignment.
-// TODO(v8:11045): Consider removing code alignment.
-uint32_t EmbeddedData::PaddedInstructionSizeOfBuiltin(Builtin builtin) const {
-  uint32_t size = InstructionSizeOfBuiltin(builtin);
+uint32_t EmbeddedData::PaddedInstructionSizeOf(Builtin builtin) const {
+  uint32_t size = InstructionSizeOf(builtin);
   CHECK_NE(size, 0);
   return PadAndAlignCode(size);
 }
diff --git a/src/snapshot/embedded/embedded-data.cc b/src/snapshot/embedded/embedded-data.cc
index d7193d02d23..b9b3eb1e09f 100644
--- a/src/snapshot/embedded/embedded-data.cc
+++ b/src/snapshot/embedded/embedded-data.cc
@@ -17,7 +17,7 @@ namespace {
 Builtin TryLookupCode(const EmbeddedData& d, Address address) {
   if (!d.IsInCodeRange(address)) return Builtin::kNoBuiltinId;
 
-  if (address < d.InstructionStartOfBuiltin(static_cast<Builtin>(0))) {
+  if (address < d.InstructionStartOf(static_cast<Builtin>(0))) {
     return Builtin::kNoBuiltinId;
   }
 
@@ -29,8 +29,8 @@ Builtin TryLookupCode(const EmbeddedData& d, Address address) {
   while (l < r) {
     const int mid = (l + r) / 2;
     const Builtin builtin = Builtins::FromInt(mid);
-    Address start = d.InstructionStartOfBuiltin(builtin);
-    Address end = start + d.PaddedInstructionSizeOfBuiltin(builtin);
+    Address start = d.InstructionStartOf(builtin);
+    Address end = start + d.PaddedInstructionSizeOf(builtin);
 
     if (address < start) {
       r = mid;
@@ -115,7 +115,7 @@ void OffHeapInstructionStream::CreateOffHeapOffHeapInstructionStream(
     Isolate* isolate, uint8_t** code, uint32_t* code_size, uint8_t** data,
     uint32_t* data_size) {
   // Create the embedded blob from scratch using the current Isolate's heap.
-  EmbeddedData d = EmbeddedData::FromIsolate(isolate);
+  EmbeddedData d = EmbeddedData::NewFromIsolate(isolate);
 
   // Allocate the backing store that will contain the embedded blob in this
   // Isolate. The backing store is on the native heap, *not* on V8's garbage-
@@ -209,7 +209,7 @@ void FinalizeEmbeddedCodeTargets(Isolate* isolate, EmbeddedData* blob) {
 
       // Do not emit write-barrier for off-heap writes.
       off_heap_it.rinfo()->set_off_heap_target_address(
-          blob->InstructionStartOfBuiltin(target_code.builtin_id()));
+          blob->InstructionStartOf(target_code.builtin_id()));
 
       on_heap_it.next();
       off_heap_it.next();
@@ -241,7 +241,7 @@ void EnsureRelocatable(Code code) {
 }  // namespace
 
 // static
-EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
+EmbeddedData EmbeddedData::NewFromIsolate(Isolate* isolate) {
   Builtins* builtins = isolate->builtins();
 
   // Store instruction stream lengths and offsets.
@@ -263,8 +263,6 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
     }
 
     uint32_t instruction_size = static_cast<uint32_t>(code.instruction_size());
-    uint32_t metadata_size = static_cast<uint32_t>(code.metadata_size());
-
     DCHECK_EQ(0, raw_code_size % kCodeAlignment);
     {
       const int builtin_index = static_cast<int>(builtin);
@@ -273,25 +271,10 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
       layout_desc.instruction_offset = raw_code_size;
       layout_desc.instruction_length = instruction_size;
       layout_desc.metadata_offset = raw_data_size;
-      layout_desc.metadata_length = metadata_size;
-
-      layout_desc.handler_table_offset =
-          raw_data_size + static_cast<uint32_t>(code.handler_table_offset());
-#if V8_EMBEDDED_CONSTANT_POOL_BOOL
-      layout_desc.constant_pool_offset =
-          raw_data_size + static_cast<uint32_t>(code.constant_pool_offset());
-#endif
-      layout_desc.code_comments_offset_offset =
-          raw_data_size + static_cast<uint32_t>(code.code_comments_offset());
-      layout_desc.unwinding_info_offset_offset =
-          raw_data_size + static_cast<uint32_t>(code.unwinding_info_offset());
-      layout_desc.stack_slots = static_cast<uint32_t>(code.stack_slots());
-
-      CHECK_EQ(code.deoptimization_data().length(), 0);
     }
     // Align the start of each section.
     raw_code_size += PadAndAlignCode(instruction_size);
-    raw_data_size += PadAndAlignData(metadata_size);
+    raw_data_size += PadAndAlignData(code.metadata_size());
   }
   CHECK_WITH_MSG(
       !saw_unsafe_builtin,
@@ -387,18 +370,10 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
     for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
          ++builtin) {
       Code code = builtins->code(builtin);
-
-      CHECK_EQ(d.InstructionSizeOfBuiltin(builtin), code.instruction_size());
-      CHECK_EQ(d.MetadataSizeOfBuiltin(builtin), code.metadata_size());
-
-      CHECK_EQ(d.SafepointTableSizeOf(builtin), code.safepoint_table_size());
-      CHECK_EQ(d.HandlerTableSizeOf(builtin), code.handler_table_size());
-      CHECK_EQ(d.ConstantPoolSizeOf(builtin), code.constant_pool_size());
-      CHECK_EQ(d.CodeCommentsSizeOf(builtin), code.code_comments_size());
-      CHECK_EQ(d.UnwindingInfoSizeOf(builtin), code.unwinding_info_size());
-      CHECK_EQ(d.StackSlotsOf(builtin), code.stack_slots());
+      CHECK_EQ(d.InstructionSizeOf(builtin), code.instruction_size());
     }
   }
+
   // Ensure that InterpreterEntryTrampolineForProfiling is relocatable.
   // See v8_flags.interpreted_frames_native_stack for details.
   EnsureRelocatable(
@@ -435,7 +410,7 @@ void EmbeddedData::PrintStatistics() const {
   int sizes[kCount];
   static_assert(Builtins::kAllBuiltinsAreIsolateIndependent);
   for (int i = 0; i < kCount; i++) {
-    sizes[i] = InstructionSizeOfBuiltin(Builtins::FromInt(i));
+    sizes[i] = InstructionSizeOf(Builtins::FromInt(i));
   }
 
   // Sort for percentiles.
diff --git a/src/snapshot/embedded/embedded-data.h b/src/snapshot/embedded/embedded-data.h
index ee752634e74..d4889d8c35a 100644
--- a/src/snapshot/embedded/embedded-data.h
+++ b/src/snapshot/embedded/embedded-data.h
@@ -51,8 +51,11 @@ class OffHeapInstructionStream final : public AllStatic {
 
 class EmbeddedData final {
  public:
-  static EmbeddedData FromIsolate(Isolate* isolate);
+  // Create the embedded blob from the given Isolate's heap state.
+  static EmbeddedData NewFromIsolate(Isolate* isolate);
 
+  // Returns the global embedded blob (usually physically located in .text and
+  // .rodata).
   static EmbeddedData FromBlob() {
     return EmbeddedData(Isolate::CurrentEmbeddedBlobCode(),
                         Isolate::CurrentEmbeddedBlobCodeSize(),
@@ -60,12 +63,16 @@ class EmbeddedData final {
                         Isolate::CurrentEmbeddedBlobDataSize());
   }
 
+  // Returns a potentially remapped embedded blob (see also
+  // MaybeRemapEmbeddedBuiltinsIntoCodeRange).
   static EmbeddedData FromBlob(Isolate* isolate) {
     return EmbeddedData(
         isolate->embedded_blob_code(), isolate->embedded_blob_code_size(),
         isolate->embedded_blob_data(), isolate->embedded_blob_data_size());
   }
 
+  // Returns a potentially remapped embedded blob (see also
+  // MaybeRemapEmbeddedBuiltinsIntoCodeRange).
   static EmbeddedData FromBlob(CodeRange* code_range) {
     return EmbeddedData(code_range->embedded_blob_code_copy(),
                         Isolate::CurrentEmbeddedBlobCodeSize(),
@@ -73,53 +80,53 @@ class EmbeddedData final {
                         Isolate::CurrentEmbeddedBlobDataSize());
   }
 
-  const uint8_t* code() const { return code_; }
-  uint32_t code_size() const { return code_size_; }
-  const uint8_t* data() const { return data_; }
-  uint32_t data_size() const { return data_size_; }
-
-  bool IsInCodeRange(Address pc) const {
-    Address start = reinterpret_cast<Address>(code_);
-    return (start <= pc) && (pc < start + code_size_);
-  }
-
   // When short builtin calls optimization is enabled for the Isolate, there
   // will be two builtins instruction streams executed: the embedded one and
   // the one un-embedded into the per-Isolate code range. In most of the cases,
   // the per-Isolate instructions will be used but in some cases (like builtin
-  // calls from Wasm) the embedded instruction stream could be used.
-  // If the requested PC belongs to the embedded code blob - it'll be returned,
-  // and the per-Isolate blob otherwise.
+  // calls from Wasm) the embedded instruction stream could be used.  If the
+  // requested PC belongs to the embedded code blob - it'll be returned, and
+  // the per-Isolate blob otherwise.
   // See http://crbug.com/v8/11527 for details.
-  inline static EmbeddedData GetEmbeddedDataForPC(Isolate* isolate,
-                                                  Address maybe_builtin_pc) {
+  static EmbeddedData FromBlobForPc(Isolate* isolate,
+                                    Address maybe_builtin_pc) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate);
-    if (isolate->is_short_builtin_calls_enabled() &&
-        !d.IsInCodeRange(maybe_builtin_pc)) {
+    if (d.IsInCodeRange(maybe_builtin_pc)) return d;
+    if (isolate->is_short_builtin_calls_enabled()) {
       EmbeddedData global_d = EmbeddedData::FromBlob();
       // If the pc does not belong to the embedded code blob we should be using
       // the un-embedded one.
       if (global_d.IsInCodeRange(maybe_builtin_pc)) return global_d;
     }
-#ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE
-    if (V8_SHORT_BUILTIN_CALLS_BOOL && !d.IsInCodeRange(maybe_builtin_pc)) {
-      // When shared pointer compression cage is enabled and it has the embedded
-      // code blob copy then it could have been used regardless of whether the
-      // isolate uses it or knows about it or not (see
-      // InstructionStream::OffHeapInstructionStart()).
-      // So, this blob has to be checked too.
-      CodeRange* code_range = CodeRange::GetProcessWideCodeRange();
-      if (code_range && code_range->embedded_blob_code_copy() != nullptr) {
-        EmbeddedData remapped_d = EmbeddedData::FromBlob(code_range);
-        // If the pc does not belong to the embedded code blob we should be
-        // using the un-embedded one.
-        if (remapped_d.IsInCodeRange(maybe_builtin_pc)) return remapped_d;
-      }
+#if defined(V8_COMPRESS_POINTERS_IN_SHARED_CAGE) && \
+    defined(V8_SHORT_BUILTIN_CALLS)
+    // When shared pointer compression cage is enabled and it has the embedded
+    // code blob copy then it could have been used regardless of whether the
+    // isolate uses it or knows about it or not (see
+    // InstructionStream::OffHeapInstructionStart()).
+    // So, this blob has to be checked too.
+    CodeRange* code_range = CodeRange::GetProcessWideCodeRange();
+    if (code_range && code_range->embedded_blob_code_copy() != nullptr) {
+      EmbeddedData remapped_d = EmbeddedData::FromBlob(code_range);
+      // If the pc does not belong to the embedded code blob we should be
+      // using the un-embedded one.
+      if (remapped_d.IsInCodeRange(maybe_builtin_pc)) return remapped_d;
     }
-#endif
+#endif  // defined(V8_COMPRESS_POINTERS_IN_SHARED_CAGE) &&
+        // defined(V8_SHORT_BUILTIN_CALLS)
     return d;
   }
 
+  const uint8_t* code() const { return code_; }
+  uint32_t code_size() const { return code_size_; }
+  const uint8_t* data() const { return data_; }
+  uint32_t data_size() const { return data_size_; }
+
+  bool IsInCodeRange(Address pc) const {
+    Address start = reinterpret_cast<Address>(code_);
+    return (start <= pc) && (pc < start + code_size_);
+  }
+
   void Dispose() {
     delete[] code_;
     code_ = nullptr;
@@ -127,35 +134,12 @@ class EmbeddedData final {
     data_ = nullptr;
   }
 
-  inline bool BuiltinContains(Builtin builtin, Address pc) const;
-
-  // TODO(ishell): rename XyzOfBuiltin() to XyzOf().
-  inline Address InstructionStartOfBuiltin(Builtin builtin) const;
+  inline Address InstructionStartOf(Builtin builtin) const;
   inline Address InstructionEndOf(Builtin builtin) const;
-  inline uint32_t InstructionSizeOfBuiltin(Builtin builtin) const;
-
+  inline uint32_t InstructionSizeOf(Builtin builtin) const;
   inline Address InstructionStartOfBytecodeHandlers() const;
   inline Address InstructionEndOfBytecodeHandlers() const;
-
-  inline Address MetadataStartOfBuiltin(Builtin builtin) const;
-  inline uint32_t MetadataSizeOfBuiltin(Builtin builtin) const;
-
-  inline Address SafepointTableStartOf(Builtin builtin) const;
-  inline uint32_t SafepointTableSizeOf(Builtin builtin) const;
-
-  inline Address HandlerTableStartOf(Builtin builtin) const;
-  inline uint32_t HandlerTableSizeOf(Builtin builtin) const;
-
-  inline Address ConstantPoolStartOf(Builtin builtin) const;
-  inline uint32_t ConstantPoolSizeOf(Builtin builtin) const;
-
-  inline Address CodeCommentsStartOf(Builtin builtin) const;
-  inline uint32_t CodeCommentsSizeOf(Builtin builtin) const;
-
-  inline Address UnwindingInfoStartOf(Builtin builtin) const;
-  inline uint32_t UnwindingInfoSizeOf(Builtin builtin) const;
-
-  inline uint32_t StackSlotsOf(Builtin builtin) const;
+  inline Address MetadataStartOf(Builtin builtin) const;
 
   uint32_t AddressForHashing(Address addr) {
     DCHECK(IsInCodeRange(addr));
@@ -164,8 +148,7 @@ class EmbeddedData final {
   }
 
   // Padded with kCodeAlignment.
-  // TODO(v8:11045): Consider removing code alignment.
-  inline uint32_t PaddedInstructionSizeOfBuiltin(Builtin builtin) const;
+  inline uint32_t PaddedInstructionSizeOf(Builtin builtin) const;
 
   size_t CreateEmbeddedBlobDataHash() const;
   size_t CreateEmbeddedBlobCodeHash() const;
@@ -182,29 +165,15 @@ class EmbeddedData final {
     return *reinterpret_cast<const size_t*>(data_ + IsolateHashOffset());
   }
 
-  // Blob layout information for a single instruction stream. Corresponds
-  // roughly to InstructionStream object layout (see the instruction and
-  // metadata area).
+  // Blob layout information for a single instruction stream.
   struct LayoutDescription {
     // The offset and (unpadded) length of this builtin's instruction area
     // from the start of the embedded code section.
     uint32_t instruction_offset;
     uint32_t instruction_length;
-    // The offset and (unpadded) length of this builtin's metadata area
-    // from the start of the embedded data section.
+    // The offset of this builtin's metadata area from the start of the
+    // embedded data section.
     uint32_t metadata_offset;
-    uint32_t metadata_length;
-
-    // The offsets describing inline metadata tables, relative to the start
-    // of the embedded data section.
-    uint32_t handler_table_offset;
-#if V8_EMBEDDED_CONSTANT_POOL_BOOL
-    uint32_t constant_pool_offset;
-#endif
-    uint32_t code_comments_offset_offset;
-    uint32_t unwinding_info_offset_offset;
-
-    uint32_t stack_slots;
   };
   static_assert(offsetof(LayoutDescription, instruction_offset) ==
                 0 * kUInt32Size);
@@ -212,27 +181,6 @@ class EmbeddedData final {
                 1 * kUInt32Size);
   static_assert(offsetof(LayoutDescription, metadata_offset) ==
                 2 * kUInt32Size);
-  static_assert(offsetof(LayoutDescription, metadata_length) ==
-                3 * kUInt32Size);
-  static_assert(offsetof(LayoutDescription, handler_table_offset) ==
-                4 * kUInt32Size);
-#if V8_EMBEDDED_CONSTANT_POOL_BOOL
-  static_assert(offsetof(LayoutDescription, constant_pool_offset) ==
-                5 * kUInt32Size);
-  static_assert(offsetof(LayoutDescription, code_comments_offset_offset) ==
-                6 * kUInt32Size);
-  static_assert(offsetof(LayoutDescription, unwinding_info_offset_offset) ==
-                7 * kUInt32Size);
-  static_assert(offsetof(LayoutDescription, stack_slots) == 8 * kUInt32Size);
-  static_assert(sizeof(LayoutDescription) == 9 * kUInt32Size);
-#else
-  static_assert(offsetof(LayoutDescription, code_comments_offset_offset) ==
-                5 * kUInt32Size);
-  static_assert(offsetof(LayoutDescription, unwinding_info_offset_offset) ==
-                6 * kUInt32Size);
-  static_assert(offsetof(LayoutDescription, stack_slots) == 7 * kUInt32Size);
-  static_assert(sizeof(LayoutDescription) == 8 * kUInt32Size);
-#endif
 
   // The layout of the blob is as follows:
   //
diff --git a/src/snapshot/embedded/embedded-file-writer.cc b/src/snapshot/embedded/embedded-file-writer.cc
index 9ce32f64e89..7de603d6b0b 100644
--- a/src/snapshot/embedded/embedded-file-writer.cc
+++ b/src/snapshot/embedded/embedded-file-writer.cc
@@ -67,7 +67,7 @@ void EmbeddedFileWriter::WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
   // that labels do not insert bytes into the middle of the blob byte
   // stream.
   w->DeclareFunctionBegin(builtin_symbol.begin(),
-                          blob->InstructionSizeOfBuiltin(builtin));
+                          blob->InstructionSizeOf(builtin));
   const int builtin_id = static_cast<int>(builtin);
   const std::vector<byte>& current_positions = source_positions_[builtin_id];
   // The code below interleaves bytes of assembly code for the builtin
@@ -87,9 +87,9 @@ void EmbeddedFileWriter::WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
   const std::vector<LabelInfo>& current_labels = label_info_[builtin_id];
   auto label = current_labels.begin();
 
-  const uint8_t* data = reinterpret_cast<const uint8_t*>(
-      blob->InstructionStartOfBuiltin(builtin));
-  uint32_t size = blob->PaddedInstructionSizeOfBuiltin(builtin);
+  const uint8_t* data =
+      reinterpret_cast<const uint8_t*>(blob->InstructionStartOf(builtin));
+  uint32_t size = blob->PaddedInstructionSizeOf(builtin);
   uint32_t i = 0;
   uint32_t next_source_pos_offset =
       static_cast<uint32_t>(positions.done() ? size : positions.code_offset());
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-win.cc b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
index d36ef9946f1..39a99354a8a 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-win.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
@@ -123,9 +123,9 @@ void EmitUnwindData(PlatformEmbeddedFileWriterWin* w,
       // entry because the return address can be retrieved from [rsp].
       if (unwind_infos[builtin_index].is_leaf_function()) continue;
 
-      uint64_t builtin_start_offset = blob->InstructionStartOfBuiltin(builtin) -
+      uint64_t builtin_start_offset = blob->InstructionStartOf(builtin) -
                                       reinterpret_cast<Address>(blob->code());
-      uint32_t builtin_size = blob->InstructionSizeOfBuiltin(builtin);
+      uint32_t builtin_size = blob->InstructionSizeOf(builtin);
 
       const std::vector<int>& xdata_desc =
           unwind_infos[builtin_index].fp_offsets();
@@ -206,9 +206,9 @@ void EmitUnwindData(PlatformEmbeddedFileWriterWin* w,
     const int builtin_index = static_cast<int>(builtin);
     if (unwind_infos[builtin_index].is_leaf_function()) continue;
 
-    uint64_t builtin_start_offset = blob->InstructionStartOfBuiltin(builtin) -
+    uint64_t builtin_start_offset = blob->InstructionStartOf(builtin) -
                                     reinterpret_cast<Address>(blob->code());
-    uint32_t builtin_size = blob->InstructionSizeOfBuiltin(builtin);
+    uint32_t builtin_size = blob->InstructionSizeOf(builtin);
 
     const std::vector<int>& xdata_desc =
         unwind_infos[builtin_index].fp_offsets();
diff --git a/src/snapshot/read-only-deserializer.cc b/src/snapshot/read-only-deserializer.cc
index ea86170a843..96618c07b52 100644
--- a/src/snapshot/read-only-deserializer.cc
+++ b/src/snapshot/read-only-deserializer.cc
@@ -12,6 +12,7 @@
 #include "src/logging/counters-scopes.h"
 #include "src/objects/slots.h"
 #include "src/roots/static-roots.h"
+#include "src/snapshot/embedded/embedded-data-inl.h"
 #include "src/snapshot/snapshot-data.h"
 
 namespace v8 {
@@ -110,8 +111,9 @@ void ReadOnlyDeserializer::PostProcessNewObjectsIfStaticRootsEnabled() {
       // attached InstructionStream.
       DCHECK(code.is_builtin());
       DCHECK(!code.has_instruction_stream());
-      code.SetEntryPointForOffHeapBuiltin(main_thread_isolate(),
-                                          code.OffHeapInstructionStart());
+      code.SetEntryPointForOffHeapBuiltin(
+          main_thread_isolate(), EmbeddedData::FromBlob(main_thread_isolate())
+                                     .InstructionStartOf(code.builtin_id()));
     }
   }
 }
diff --git a/src/utils/memcopy.cc b/src/utils/memcopy.cc
index 6bf529e7f9f..591a6a514df 100644
--- a/src/utils/memcopy.cc
+++ b/src/utils/memcopy.cc
@@ -38,19 +38,19 @@ void init_memcopy_functions() {
   if (Isolate::CurrentEmbeddedBlobIsBinaryEmbedded()) {
     EmbeddedData d = EmbeddedData::FromBlob();
     memmove_function = reinterpret_cast<MemMoveFunction>(
-        d.InstructionStartOfBuiltin(Builtin::kMemMove));
+        d.InstructionStartOf(Builtin::kMemMove));
   }
 #elif(V8_OS_POSIX || V8_OS_STARBOARD) && V8_HOST_ARCH_ARM
   if (Isolate::CurrentEmbeddedBlobIsBinaryEmbedded()) {
     EmbeddedData d = EmbeddedData::FromBlob();
     memcopy_uint8_function = reinterpret_cast<MemCopyUint8Function>(
-        d.InstructionStartOfBuiltin(Builtin::kMemCopyUint8Uint8));
+        d.InstructionStartOf(Builtin::kMemCopyUint8Uint8));
   }
 #elif V8_OS_POSIX && V8_HOST_ARCH_MIPS
   if (Isolate::CurrentEmbeddedBlobIsBinaryEmbedded()) {
     EmbeddedData d = EmbeddedData::FromBlob();
     memcopy_uint8_function = reinterpret_cast<MemCopyUint8Function>(
-        d.InstructionStartOfBuiltin(Builtin::kMemCopyUint8Uint8));
+        d.InstructionStartOf(Builtin::kMemCopyUint8Uint8));
   }
 #endif
 }
diff --git a/src/wasm/wasm-code-manager.cc b/src/wasm/wasm-code-manager.cc
index 5d4f0f5d622..5cf46956d3a 100644
--- a/src/wasm/wasm-code-manager.cc
+++ b/src/wasm/wasm-code-manager.cc
@@ -1537,7 +1537,7 @@ void NativeModule::AddCodeSpaceLocked(base::AddressRegion region) {
     Address builtin_addresses[WasmCode::kRuntimeStubCount];
     for (int i = 0; i < WasmCode::kRuntimeStubCount; ++i) {
       Builtin builtin = stub_names[i];
-      builtin_addresses[i] = embedded_data.InstructionStartOfBuiltin(builtin);
+      builtin_addresses[i] = embedded_data.InstructionStartOf(builtin);
     }
     JumpTableAssembler::GenerateFarJumpTable(
         far_jump_table->instruction_start(), builtin_addresses,
-- 
2.35.1


From c3f4c5323d5585bc37159cb6e062c3bf57579567 Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Tue, 6 Sep 2022 18:03:57 +0200
Subject: [PATCH] [execution] Use v8_flags for accessing flag values

Avoid the deprecated FLAG_* syntax, access flag values via the
{v8_flags} struct instead.

R=ishell@chromium.org

Bug: v8:12887
Change-Id: Ic54ad0c1135f6d3ff9f261df40f2138bf511d5be
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3876383
Reviewed-by: Igor Sheludko <ishell@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#83013}
---
 src/execution/arm/simulator-arm.cc         |  35 +++--
 src/execution/arm64/pointer-auth-arm64.cc  |   2 +-
 src/execution/arm64/simulator-arm64.cc     |  45 +++---
 src/execution/arm64/simulator-arm64.h      |   2 +-
 src/execution/execution.cc                 |   5 +-
 src/execution/frame-constants.h            |   4 +-
 src/execution/frames.cc                    |  33 ++---
 src/execution/isolate.cc                   | 155 +++++++++++----------
 src/execution/isolate.h                    |  10 +-
 src/execution/local-isolate.cc             |   2 +-
 src/execution/loong64/simulator-loong64.cc |  42 +++---
 src/execution/messages.cc                  |   8 +-
 src/execution/mips/simulator-mips.cc       |  54 +++----
 src/execution/mips64/simulator-mips64.cc   |  48 +++----
 src/execution/ppc/frame-constants-ppc.cc   |   2 +-
 src/execution/ppc/frame-constants-ppc.h    |   4 +-
 src/execution/ppc/simulator-ppc.cc         |  45 +++---
 src/execution/protectors.cc                |   6 +-
 src/execution/riscv/simulator-riscv.cc     |  62 ++++-----
 src/execution/riscv/simulator-riscv.h      |  12 +-
 src/execution/s390/simulator-s390.cc       |  53 ++++---
 src/execution/stack-guard.cc               |   4 +-
 src/execution/tiering-manager.cc           |  51 +++----
 23 files changed, 346 insertions(+), 338 deletions(-)

diff --git a/src/execution/arm/simulator-arm.cc b/src/execution/arm/simulator-arm.cc
index ee331f606a6..5879fd0cdb1 100644
--- a/src/execution/arm/simulator-arm.cc
+++ b/src/execution/arm/simulator-arm.cc
@@ -516,9 +516,9 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
       PrintF("Wrong usage. Use help command for more information.\n");
     }
   } else if ((strcmp(cmd, "t") == 0) || strcmp(cmd, "trace") == 0) {
-    ::v8::internal::FLAG_trace_sim = !::v8::internal::FLAG_trace_sim;
+    v8_flags.trace_sim = !v8_flags.trace_sim;
     PrintF("Trace of executed instructions is %s\n",
-           ::v8::internal::FLAG_trace_sim ? "on" : "off");
+           v8_flags.trace_sim ? "on" : "off");
   } else if ((strcmp(cmd, "h") == 0) || (strcmp(cmd, "help") == 0)) {
     PrintF("cont\n");
     PrintF("  continue execution (alias 'c')\n");
@@ -1659,8 +1659,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       // Check if stack is aligned. Error if not aligned is reported below to
       // include information on the function called.
       bool stack_aligned =
-          (get_register(sp) & (::v8::internal::FLAG_sim_stack_alignment - 1)) ==
-          0;
+          (get_register(sp) & (v8_flags.sim_stack_alignment - 1)) == 0;
       Redirection* redirection = Redirection::FromInstruction(instr);
       int32_t arg0 = get_register(r0);
       int32_t arg1 = get_register(r1);
@@ -1701,7 +1700,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         int64_t iresult = 0;  // integer return value
         double dresult = 0;   // double return value
         GetFpArgs(&dval0, &dval1, &ival);
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           SimulatorRuntimeCall generic_target =
               reinterpret_cast<SimulatorRuntimeCall>(external);
           switch (redirection->type()) {
@@ -1775,7 +1774,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
           default:
             UNREACHABLE();
         }
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           switch (redirection->type()) {
             case ExternalReference::BUILTIN_COMPARE_CALL:
               PrintF("Returned %08x\n", static_cast<int32_t>(iresult));
@@ -1790,7 +1789,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
           }
         }
       } else if (redirection->type() == ExternalReference::DIRECT_API_CALL) {
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08x",
                  reinterpret_cast<void*>(external), arg0);
           if (!stack_aligned) {
@@ -1804,7 +1803,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         TrashCallerSaveRegisters();
 #endif
       } else if (redirection->type() == ExternalReference::PROFILING_API_CALL) {
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08x %08x",
                  reinterpret_cast<void*>(external), arg0, arg1);
           if (!stack_aligned) {
@@ -1818,7 +1817,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         TrashCallerSaveRegisters();
 #endif
       } else if (redirection->type() == ExternalReference::DIRECT_GETTER_CALL) {
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08x %08x",
                  reinterpret_cast<void*>(external), arg0, arg1);
           if (!stack_aligned) {
@@ -1833,7 +1832,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
 #endif
       } else if (redirection->type() ==
                  ExternalReference::PROFILING_GETTER_CALL) {
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08x %08x %08x",
                  reinterpret_cast<void*>(external), arg0, arg1, arg2);
           if (!stack_aligned) {
@@ -1863,7 +1862,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         DCHECK(redirection->type() == ExternalReference::BUILTIN_CALL ||
                redirection->type() == ExternalReference::BUILTIN_CALL_PAIR ||
                redirection->type() == ExternalReference::FAST_C_CALL);
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF(
               "Call to host function at %p "
               "args %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x, "
@@ -1887,7 +1886,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
 #endif
         int32_t lo_res = static_cast<int32_t>(result);
         int32_t hi_res = static_cast<int32_t>(result >> 32);
-        if (::v8::internal::FLAG_trace_sim) {
+        if (v8_flags.trace_sim) {
           PrintF("Returned %08x\n", lo_res);
         }
         set_register(r0, lo_res);
@@ -6122,11 +6121,11 @@ void Simulator::DecodeSpecialCondition(Instruction* instr) {
 
 // Executes the current instruction.
 void Simulator::InstructionDecode(Instruction* instr) {
-  if (v8::internal::FLAG_check_icache) {
+  if (v8_flags.check_icache) {
     CheckICache(i_cache(), instr);
   }
   pc_modified_ = false;
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // use a reasonably large buffer
@@ -6183,7 +6182,7 @@ void Simulator::Execute() {
   // raw PC value and not the one used as input to arithmetic instructions.
   int program_counter = get_pc();
 
-  if (::v8::internal::FLAG_stop_sim_at == 0) {
+  if (v8_flags.stop_sim_at == 0) {
     // Fast version of the dispatch loop without checking whether the simulator
     // should be stopping at a particular executed instruction.
     while (program_counter != end_sim_pc) {
@@ -6193,12 +6192,12 @@ void Simulator::Execute() {
       program_counter = get_pc();
     }
   } else {
-    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
-    // we reach the particular instruction count.
+    // v8_flags.stop_sim_at is at the non-default value. Stop in the debugger
+    // when we reach the particular instruction count.
     while (program_counter != end_sim_pc) {
       Instruction* instr = reinterpret_cast<Instruction*>(program_counter);
       icount_ = base::AddWithWraparound(icount_, 1);
-      if (icount_ == ::v8::internal::FLAG_stop_sim_at) {
+      if (icount_ == v8_flags.stop_sim_at) {
         ArmDebugger dbg(this);
         dbg.Debug();
       } else {
diff --git a/src/execution/arm64/pointer-auth-arm64.cc b/src/execution/arm64/pointer-auth-arm64.cc
index 7f4eeeb0ac9..1bb0a377a9e 100644
--- a/src/execution/arm64/pointer-auth-arm64.cc
+++ b/src/execution/arm64/pointer-auth-arm64.cc
@@ -232,7 +232,7 @@ uint64_t Simulator::AuthPAC(uint64_t ptr, uint64_t context, PACKey key,
   } else {
     int error_lsb = GetTopPACBit(ptr, type) - 2;
     uint64_t error_mask = UINT64_C(0x3) << error_lsb;
-    if (FLAG_sim_abort_on_bad_auth) {
+    if (v8_flags.sim_abort_on_bad_auth) {
       FATAL("Pointer authentication failure.");
     }
     return (original_ptr & ~error_mask) | (error_code << error_lsb);
diff --git a/src/execution/arm64/simulator-arm64.cc b/src/execution/arm64/simulator-arm64.cc
index 9d2896ddd08..de3c992ac92 100644
--- a/src/execution/arm64/simulator-arm64.cc
+++ b/src/execution/arm64/simulator-arm64.cc
@@ -57,17 +57,17 @@ namespace internal {
 #define WHITE "37"
 
 using TEXT_COLOUR = char const* const;
-TEXT_COLOUR clr_normal = FLAG_log_colour ? COLOUR(NORMAL) : "";
-TEXT_COLOUR clr_flag_name = FLAG_log_colour ? COLOUR_BOLD(WHITE) : "";
-TEXT_COLOUR clr_flag_value = FLAG_log_colour ? COLOUR(NORMAL) : "";
-TEXT_COLOUR clr_reg_name = FLAG_log_colour ? COLOUR_BOLD(CYAN) : "";
-TEXT_COLOUR clr_reg_value = FLAG_log_colour ? COLOUR(CYAN) : "";
-TEXT_COLOUR clr_vreg_name = FLAG_log_colour ? COLOUR_BOLD(MAGENTA) : "";
-TEXT_COLOUR clr_vreg_value = FLAG_log_colour ? COLOUR(MAGENTA) : "";
-TEXT_COLOUR clr_memory_address = FLAG_log_colour ? COLOUR_BOLD(BLUE) : "";
-TEXT_COLOUR clr_debug_number = FLAG_log_colour ? COLOUR_BOLD(YELLOW) : "";
-TEXT_COLOUR clr_debug_message = FLAG_log_colour ? COLOUR(YELLOW) : "";
-TEXT_COLOUR clr_printf = FLAG_log_colour ? COLOUR(GREEN) : "";
+TEXT_COLOUR clr_normal = v8_flags.log_colour ? COLOUR(NORMAL) : "";
+TEXT_COLOUR clr_flag_name = v8_flags.log_colour ? COLOUR_BOLD(WHITE) : "";
+TEXT_COLOUR clr_flag_value = v8_flags.log_colour ? COLOUR(NORMAL) : "";
+TEXT_COLOUR clr_reg_name = v8_flags.log_colour ? COLOUR_BOLD(CYAN) : "";
+TEXT_COLOUR clr_reg_value = v8_flags.log_colour ? COLOUR(CYAN) : "";
+TEXT_COLOUR clr_vreg_name = v8_flags.log_colour ? COLOUR_BOLD(MAGENTA) : "";
+TEXT_COLOUR clr_vreg_value = v8_flags.log_colour ? COLOUR(MAGENTA) : "";
+TEXT_COLOUR clr_memory_address = v8_flags.log_colour ? COLOUR_BOLD(BLUE) : "";
+TEXT_COLOUR clr_debug_number = v8_flags.log_colour ? COLOUR_BOLD(YELLOW) : "";
+TEXT_COLOUR clr_debug_message = v8_flags.log_colour ? COLOUR(YELLOW) : "";
+TEXT_COLOUR clr_printf = v8_flags.log_colour ? COLOUR(GREEN) : "";
 
 DEFINE_LAZY_LEAKY_OBJECT_GETTER(Simulator::GlobalMonitor,
                                 Simulator::GlobalMonitor::Get)
@@ -86,9 +86,9 @@ bool Simulator::ProbeMemory(uintptr_t address, uintptr_t access_size) {
 #endif
 }
 
-// This is basically the same as PrintF, with a guard for FLAG_trace_sim.
+// This is basically the same as PrintF, with a guard for v8_flags.trace_sim.
 void Simulator::TraceSim(const char* format, ...) {
-  if (FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     va_list arguments;
     va_start(arguments, format);
     base::OS::VFPrint(stream_, format, arguments);
@@ -128,7 +128,7 @@ Simulator* Simulator::current(Isolate* isolate) {
 
   Simulator* sim = isolate_data->simulator();
   if (sim == nullptr) {
-    if (FLAG_trace_sim || FLAG_debug_sim) {
+    if (v8_flags.trace_sim || v8_flags.debug_sim) {
       sim = new Simulator(new Decoder<DispatchingDecoderVisitor>(), isolate);
     } else {
       sim = new Decoder<Simulator>();
@@ -336,7 +336,7 @@ Simulator::Simulator(Decoder<DispatchingDecoderVisitor>* decoder,
 
   Init(stream);
 
-  if (FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     decoder_->InsertVisitorBefore(print_disasm_, this);
     log_parameters_ = LOG_ALL;
   }
@@ -349,14 +349,14 @@ Simulator::Simulator()
       log_parameters_(NO_PARAM),
       isolate_(nullptr) {
   Init(stdout);
-  CHECK(!FLAG_trace_sim);
+  CHECK(!v8_flags.trace_sim);
 }
 
 void Simulator::Init(FILE* stream) {
   ResetState();
 
   // Allocate and setup the simulator stack.
-  stack_size_ = (FLAG_sim_stack_size * KB) + (2 * stack_protection_size_);
+  stack_size_ = (v8_flags.sim_stack_size * KB) + (2 * stack_protection_size_);
   stack_ = reinterpret_cast<uintptr_t>(new byte[stack_size_]);
   stack_limit_ = stack_ + stack_protection_size_;
   uintptr_t tos = stack_ + stack_size_ - stack_protection_size_;
@@ -411,19 +411,19 @@ void Simulator::Run() {
 
   pc_modified_ = false;
 
-  if (::v8::internal::FLAG_stop_sim_at == 0) {
+  if (v8_flags.stop_sim_at == 0) {
     // Fast version of the dispatch loop without checking whether the simulator
     // should be stopping at a particular executed instruction.
     while (pc_ != kEndOfSimAddress) {
       ExecuteInstruction();
     }
   } else {
-    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
-    // we reach the particular instruction count.
+    // v8_flags.stop_sim_at is at the non-default value. Stop in the debugger
+    // when we reach the particular instruction count.
     while (pc_ != kEndOfSimAddress) {
       icount_for_stop_sim_at_ =
           base::AddWithWraparound(icount_for_stop_sim_at_, 1);
-      if (icount_for_stop_sim_at_ == ::v8::internal::FLAG_stop_sim_at) {
+      if (icount_for_stop_sim_at_ == v8_flags.stop_sim_at) {
         Debug();
       }
       ExecuteInstruction();
@@ -3834,7 +3834,8 @@ void Simulator::VisitException(Instruction* instr) {
         // Always print something when we hit a debug point that breaks.
         // We are going to break, so printing something is not an issue in
         // terms of speed.
-        if (FLAG_trace_sim_messages || FLAG_trace_sim || (parameters & BREAK)) {
+        if (v8_flags.trace_sim_messages || v8_flags.trace_sim ||
+            (parameters & BREAK)) {
           if (message != nullptr) {
             PrintF(stream_, "# %sDebugger hit %d: %s%s%s\n", clr_debug_number,
                    code, clr_debug_message, message, clr_normal);
diff --git a/src/execution/arm64/simulator-arm64.h b/src/execution/arm64/simulator-arm64.h
index 0094619a48b..4a7b81f8a3e 100644
--- a/src/execution/arm64/simulator-arm64.h
+++ b/src/execution/arm64/simulator-arm64.h
@@ -2513,7 +2513,7 @@ class Simulator : public DecoderVisitor, public SimulatorBase {
   }
 
   int log_parameters_;
-  // Instruction counter only valid if FLAG_stop_sim_at isn't 0.
+  // Instruction counter only valid if v8_flags.stop_sim_at isn't 0.
   int icount_for_stop_sim_at_;
   Isolate* isolate_;
 };
diff --git a/src/execution/execution.cc b/src/execution/execution.cc
index bf956e1703b..b76a601b8fe 100644
--- a/src/execution/execution.cc
+++ b/src/execution/execution.cc
@@ -405,7 +405,8 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> Invoke(Isolate* isolate,
     SaveContext save(isolate);
     SealHandleScope shs(isolate);
 
-    if (FLAG_clear_exceptions_on_js_entry) isolate->clear_pending_exception();
+    if (v8_flags.clear_exceptions_on_js_entry)
+      isolate->clear_pending_exception();
 
     if (params.execution_target == Execution::Target::kCallable) {
       // clang-format off
@@ -445,7 +446,7 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> Invoke(Isolate* isolate,
   }
 
 #ifdef VERIFY_HEAP
-  if (FLAG_verify_heap) {
+  if (v8_flags.verify_heap) {
     value.ObjectVerify(isolate);
   }
 #endif
diff --git a/src/execution/frame-constants.h b/src/execution/frame-constants.h
index 1fcc9df8d22..0f9eaa6f7c6 100644
--- a/src/execution/frame-constants.h
+++ b/src/execution/frame-constants.h
@@ -55,14 +55,14 @@ class CommonFrameConstants : public AllStatic {
   static constexpr int kCallerSPOffset = kCallerPCOffset + 1 * kPCOnStackSize;
 
   // Fixed part of the frame consists of return address, caller fp,
-  // constant pool (if FLAG_enable_embedded_constant_pool), context, and
+  // constant pool (if v8_flags.enable_embedded_constant_pool), context, and
   // function. CommonFrame::IterateExpressions assumes that kLastObjectOffset
   // is the last object pointer.
   static constexpr int kFixedFrameSizeAboveFp = kPCOnStackSize + kFPOnStackSize;
   static constexpr int kFixedSlotCountAboveFp =
       kFixedFrameSizeAboveFp / kSystemPointerSize;
   static constexpr int kCPSlotSize =
-      FLAG_enable_embedded_constant_pool.value() ? kSystemPointerSize : 0;
+      v8_flags.enable_embedded_constant_pool.value() ? kSystemPointerSize : 0;
   static constexpr int kCPSlotCount = kCPSlotSize / kSystemPointerSize;
   static constexpr int kConstantPoolOffset =
       kCPSlotSize ? -1 * kSystemPointerSize : 0;
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 6baaf4bd576..86c09a80d85 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -71,7 +71,7 @@ class StackHandlerIterator {
     // Make sure the handler has already been unwound to this frame. With stack
     // switching this is not equivalent to the inequality below, because the
     // frame and the handler could be in different stacks.
-    DCHECK_IMPLIES(!FLAG_experimental_wasm_stack_switching,
+    DCHECK_IMPLIES(!v8_flags.experimental_wasm_stack_switching,
                    frame->sp() <= AddressOf(handler));
     // For CWasmEntry frames, the handler was registered by the last C++
     // frame (Execution::CallWasm), so even though its address is already
@@ -143,7 +143,7 @@ void StackFrameIterator::Advance() {
   // chain must have been completely unwound. Except for wasm stack-switching:
   // we stop at the end of the current segment.
 #if V8_ENABLE_WEBASSEMBLY
-  DCHECK_IMPLIES(done() && !FLAG_experimental_wasm_stack_switching,
+  DCHECK_IMPLIES(done() && !v8_flags.experimental_wasm_stack_switching,
                  handler_ == nullptr);
 #else
   DCHECK_IMPLIES(done(), handler_ == nullptr);
@@ -295,7 +295,7 @@ bool IsInterpreterFramePc(Isolate* isolate, Address pc,
        builtin == Builtin::kBaselineOrInterpreterEnterAtBytecode ||
        builtin == Builtin::kBaselineOrInterpreterEnterAtNextBytecode)) {
     return true;
-  } else if (FLAG_interpreted_frames_native_stack) {
+  } else if (v8_flags.interpreted_frames_native_stack) {
     intptr_t marker = Memory<intptr_t>(
         state->fp + CommonFrameConstants::kContextOrFrameTypeOffset);
     MSAN_MEMORY_IS_INITIALIZED(
@@ -609,7 +609,7 @@ void StackFrame::IteratePc(RootVisitor* v, Address* pc_address,
   Address pc = holder.InstructionStart(isolate_, old_pc) + pc_offset;
   // TODO(v8:10026): avoid replacing a signed pointer.
   PointerAuthentication::ReplacePC(pc_address, pc, kSystemPointerSize);
-  if (FLAG_enable_embedded_constant_pool && constant_pool_address) {
+  if (v8_flags.enable_embedded_constant_pool && constant_pool_address) {
     *constant_pool_address = holder.constant_pool();
   }
 }
@@ -649,7 +649,7 @@ StackFrame::Type StackFrame::ComputeType(const StackFrameIteratorBase* iterator,
                                          State* state) {
 #if V8_ENABLE_WEBASSEMBLY
   if (state->fp == kNullAddress) {
-    DCHECK(FLAG_experimental_wasm_stack_switching);
+    DCHECK(v8_flags.experimental_wasm_stack_switching);
     return NO_FRAME_TYPE;
   }
 #endif
@@ -844,7 +844,7 @@ void ExitFrame::ComputeCallerState(State* state) const {
   state->pc_address = ResolveReturnAddressLocation(
       reinterpret_cast<Address*>(fp() + ExitFrameConstants::kCallerPCOffset));
   state->callee_pc_address = nullptr;
-  if (FLAG_enable_embedded_constant_pool) {
+  if (v8_flags.enable_embedded_constant_pool) {
     state->constant_pool_address = reinterpret_cast<Address*>(
         fp() + ExitFrameConstants::kConstantPoolOffset);
   }
@@ -961,7 +961,7 @@ int BuiltinExitFrame::ComputeParametersCount() const {
 }
 
 Handle<FixedArray> BuiltinExitFrame::GetParameters() const {
-  if (V8_LIKELY(!FLAG_detailed_error_stack_trace)) {
+  if (V8_LIKELY(!v8_flags.detailed_error_stack_trace)) {
     return isolate()->factory()->empty_fixed_array();
   }
   int param_count = ComputeParametersCount();
@@ -1060,7 +1060,7 @@ void CommonFrame::ComputeCallerState(State* state) const {
   if (state->fp == kNullAddress) {
     // An empty FP signals the first frame of a stack segment. The caller is
     // on a different stack, or is unbound (suspended stack).
-    DCHECK(FLAG_experimental_wasm_stack_switching);
+    DCHECK(v8_flags.experimental_wasm_stack_switching);
     return;
   }
 #endif
@@ -1262,7 +1262,7 @@ void WasmFrame::Iterate(RootVisitor* v) const {
                 "WasmExitFrame has one slot more than WasmFrame");
 
   int frame_header_size = WasmFrameConstants::kFixedFrameSizeFromFp;
-  if (wasm_code->is_liftoff() && FLAG_wasm_speculative_inlining) {
+  if (wasm_code->is_liftoff() && v8_flags.wasm_speculative_inlining) {
     // Frame has Wasm feedback slot.
     frame_header_size += kSystemPointerSize;
   }
@@ -1884,7 +1884,7 @@ int JavaScriptFrame::GetActualArgumentCount() const {
 }
 
 Handle<FixedArray> CommonFrameWithJSLinkage::GetParameters() const {
-  if (V8_LIKELY(!FLAG_detailed_error_stack_trace)) {
+  if (V8_LIKELY(!v8_flags.detailed_error_stack_trace)) {
     return isolate()->factory()->empty_fixed_array();
   }
   int param_count = ComputeParametersCount();
@@ -1970,10 +1970,11 @@ void FrameSummary::JavaScriptFrameSummary::EnsureSourcePositionsAvailable() {
 }
 
 bool FrameSummary::JavaScriptFrameSummary::AreSourcePositionsAvailable() const {
-  return !FLAG_enable_lazy_source_positions || function()
-                                                   ->shared()
-                                                   .GetBytecodeArray(isolate())
-                                                   .HasSourcePositionTable();
+  return !v8_flags.enable_lazy_source_positions ||
+         function()
+             ->shared()
+             .GetBytecodeArray(isolate())
+             .HasSourcePositionTable();
 }
 
 bool FrameSummary::JavaScriptFrameSummary::is_subject_to_debugging() const {
@@ -2776,10 +2777,10 @@ void WasmCompileLazyFrame::Iterate(RootVisitor* v) const {
 namespace {
 
 void PrintFunctionSource(StringStream* accumulator, SharedFunctionInfo shared) {
-  if (FLAG_max_stack_trace_source_length != 0) {
+  if (v8_flags.max_stack_trace_source_length != 0) {
     std::ostringstream os;
     os << "--------- s o u r c e   c o d e ---------\n"
-       << SourceCodeOf(shared, FLAG_max_stack_trace_source_length)
+       << SourceCodeOf(shared, v8_flags.max_stack_trace_source_length)
        << "\n-----------------------------------------\n";
     accumulator->Add(os.str().c_str());
   }
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index fa3b6972ea4..e910dcd9fca 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -155,7 +155,7 @@ namespace internal {
 #ifdef DEBUG
 #define TRACE_ISOLATE(tag)                                                  \
   do {                                                                      \
-    if (FLAG_trace_isolates) {                                              \
+    if (v8_flags.trace_isolates) {                                          \
       PrintF("Isolate %p (id %d)" #tag "\n", reinterpret_cast<void*>(this), \
              id());                                                         \
     }                                                                       \
@@ -315,7 +315,7 @@ void Isolate::SetEmbeddedBlob(const uint8_t* code, uint32_t code_size,
         "indicates that the embedded blob has been modified since compilation "
         "time.");
   }
-  if (FLAG_text_is_readable) {
+  if (v8_flags.text_is_readable) {
     if (d.EmbeddedBlobCodeHash() != d.CreateEmbeddedBlobCodeHash()) {
       FATAL(
           "Embedded blob code section checksum verification failed. This "
@@ -521,7 +521,7 @@ Isolate::FindOrAllocatePerThreadDataForThisThread() {
     base::MutexGuard lock_guard(&thread_data_table_mutex_);
     per_thread = thread_data_table_.Lookup(thread_id);
     if (per_thread == nullptr) {
-      if (FLAG_adjust_os_scheduling_parameters) {
+      if (v8_flags.adjust_os_scheduling_parameters) {
         base::OS::AdjustSchedulingParams();
       }
       per_thread = new PerIsolateThreadData(this, thread_id);
@@ -619,7 +619,7 @@ void Isolate::Iterate(RootVisitor* v, ThreadLocalTop* thread) {
   // Iterate over pointers on native execution stack.
 #if V8_ENABLE_WEBASSEMBLY
   wasm::WasmCodeRefScope wasm_code_ref_scope;
-  if (FLAG_experimental_wasm_stack_switching) {
+  if (v8_flags.experimental_wasm_stack_switching) {
     wasm::StackMemory* current = wasm_stacks_;
     DCHECK_NOT_NULL(current);
     do {
@@ -785,7 +785,7 @@ class CallSiteBuilder {
                  (BytecodeArray::kHeaderSize - kHeapObjectTag);
 
     Handle<FixedArray> parameters = isolate_->factory()->empty_fixed_array();
-    if (V8_UNLIKELY(FLAG_detailed_error_stack_trace)) {
+    if (V8_UNLIKELY(v8_flags.detailed_error_stack_trace)) {
       parameters = isolate_->factory()->CopyFixedArrayUpTo(
           handle(generator_object->parameters_and_registers(), isolate_),
           function->shared()
@@ -901,7 +901,7 @@ class CallSiteBuilder {
   bool IsNotHidden(Handle<JSFunction> function) {
     // TODO(szuend): Remove this check once the flag is enabled
     //               by default.
-    if (!FLAG_experimental_stack_trace_frames &&
+    if (!v8_flags.experimental_stack_trace_frames &&
         function->shared().IsApiFunction()) {
       return false;
     }
@@ -909,7 +909,7 @@ class CallSiteBuilder {
     // exposed, in which case the native flag is set.
     // The --builtins-in-stack-traces command line flag allows including
     // internal call sites in the stack trace for debugging purposes.
-    if (!FLAG_builtins_in_stack_traces &&
+    if (!v8_flags.builtins_in_stack_traces &&
         !function->shared().IsUserJavaScript()) {
       return function->shared().native() || function->shared().IsApiFunction();
     }
@@ -940,7 +940,7 @@ class CallSiteBuilder {
 };
 
 bool GetStackTraceLimit(Isolate* isolate, int* result) {
-  if (FLAG_correctness_fuzzer_suppressions) return false;
+  if (v8_flags.correctness_fuzzer_suppressions) return false;
   Handle<JSObject> error = isolate->error_function();
 
   Handle<String> key = isolate->factory()->stackTraceLimit_string();
@@ -951,7 +951,7 @@ bool GetStackTraceLimit(Isolate* isolate, int* result) {
   // Ensure that limit is not negative.
   *result = std::max(FastD2IChecked(stack_trace_limit->Number()), 0);
 
-  if (*result != FLAG_stack_trace_limit) {
+  if (*result != v8_flags.stack_trace_limit) {
     isolate->CountUsage(v8::Isolate::kErrorStackTraceLimit);
   }
 
@@ -1211,7 +1211,7 @@ Handle<FixedArray> CaptureSimpleStackTrace(Isolate* isolate, int limit,
   // If --async-stack-traces are enabled and the "current microtask" is a
   // PromiseReactionJobTask, we try to enrich the stack trace with async
   // frames.
-  if (FLAG_async_stack_traces) {
+  if (v8_flags.async_stack_traces) {
     CaptureAsyncStackTrace(isolate, &builder);
   }
 
@@ -1592,7 +1592,7 @@ Object Isolate::StackOverflow() {
   DCHECK_GE(GetCurrentStackPosition(), stack_guard()->real_climit() - 8 * KB);
 #endif
 
-  if (FLAG_correctness_fuzzer_suppressions) {
+  if (v8_flags.correctness_fuzzer_suppressions) {
     FATAL("Aborting on stack overflow");
   }
 
@@ -1615,7 +1615,7 @@ Object Isolate::StackOverflow() {
   Throw(*exception);
 
 #ifdef VERIFY_HEAP
-  if (FLAG_verify_heap && FLAG_stress_compaction) {
+  if (v8_flags.verify_heap && v8_flags.stress_compaction) {
     heap()->CollectAllGarbage(Heap::kNoGCFlags,
                               GarbageCollectionReason::kTesting);
   }
@@ -1756,14 +1756,14 @@ Handle<JSMessageObject> Isolate::CreateMessageOrAbort(
   // embedder didn't specify a custom uncaught exception callback,
   // or if the custom callback determined that V8 should abort, then
   // abort.
-  if (FLAG_abort_on_uncaught_exception) {
+  if (v8_flags.abort_on_uncaught_exception) {
     CatchType prediction = PredictExceptionCatcher();
     if ((prediction == NOT_CAUGHT || prediction == CAUGHT_BY_EXTERNAL) &&
         (!abort_on_uncaught_exception_callback_ ||
          abort_on_uncaught_exception_callback_(
              reinterpret_cast<v8::Isolate*>(this)))) {
       // Prevent endless recursion.
-      FLAG_abort_on_uncaught_exception = false;
+      v8_flags.abort_on_uncaught_exception = false;
       // This flag is intended for use by JavaScript developers, so
       // print a user-friendly stack trace (not an internal one).
       PrintF(stderr, "%s\n\nFROM\n",
@@ -1786,7 +1786,7 @@ Object Isolate::ThrowInternal(Object raw_exception, MessageLocation* location) {
   HandleScope scope(this);
   Handle<Object> exception(raw_exception, this);
 
-  if (FLAG_print_all_exceptions) {
+  if (v8_flags.print_all_exceptions) {
     PrintF("=========================================================\n");
     PrintF("Exception thrown:\n");
     if (location) {
@@ -1953,7 +1953,7 @@ Object Isolate::UnwindAndFindHandler() {
 #if V8_ENABLE_WEBASSEMBLY
   // Iterate the chain of stack segments for wasm stack switching.
   WasmContinuationObject current_stack;
-  if (FLAG_experimental_wasm_stack_switching) {
+  if (v8_flags.experimental_wasm_stack_switching) {
     current_stack =
         WasmContinuationObject::cast(root(RootIndex::kActiveContinuation));
   }
@@ -1963,7 +1963,7 @@ Object Isolate::UnwindAndFindHandler() {
   // over the stack and dispatching according to the frame type.
   for (StackFrameIterator iter(this);; iter.Advance(), visited_frames++) {
 #if V8_ENABLE_WEBASSEMBLY
-    if (FLAG_experimental_wasm_stack_switching && iter.done()) {
+    if (v8_flags.experimental_wasm_stack_switching && iter.done()) {
       // We reached the end of the current stack segment. Follow the linked-list
       // of stacks to find the next frame, and perform the implicit stack
       // switch.
@@ -1991,7 +1991,7 @@ Object Isolate::UnwindAndFindHandler() {
         DCHECK_EQ(current_stack, parent_suspender.continuation());
       }
       roots_table().slot(RootIndex::kActiveSuspender).store(suspender.parent());
-      if (FLAG_trace_wasm_stack_switching) {
+      if (v8_flags.trace_wasm_stack_switching) {
         PrintF("Switch to stack #%d (unwind)\n", parent_stack->id());
       }
       uintptr_t limit =
@@ -2114,7 +2114,7 @@ Object Isolate::UnwindAndFindHandler() {
       case StackFrame::WASM_COMPILE_LAZY: {
         // Can only fail directly on invocation. This happens if an invalid
         // function was validated lazily.
-        DCHECK(FLAG_wasm_lazy_validation);
+        DCHECK(v8_flags.wasm_lazy_validation);
         break;
       }
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -2401,7 +2401,7 @@ Isolate::CatchType Isolate::PredictExceptionCatcher() {
 }
 
 Object Isolate::ThrowIllegalOperation() {
-  if (FLAG_stack_trace_on_illegal) PrintStack(stdout);
+  if (v8_flags.stack_trace_on_illegal) PrintStack(stdout);
   return Throw(ReadOnlyRoots(heap()).illegal_access_string());
 }
 
@@ -2942,9 +2942,9 @@ void Isolate::InstallConditionalFeatures(Handle<Context> context) {
 }
 
 bool Isolate::IsSharedArrayBufferConstructorEnabled(Handle<Context> context) {
-  if (!FLAG_harmony_sharedarraybuffer) return false;
+  if (!v8_flags.harmony_sharedarraybuffer) return false;
 
-  if (!FLAG_enable_sharedarraybuffer_per_context) return true;
+  if (!v8_flags.enable_sharedarraybuffer_per_context) return true;
 
   if (sharedarraybuffer_constructor_enabled_callback()) {
     v8::Local<v8::Context> api_context = v8::Utils::ToLocal(context);
@@ -2959,7 +2959,7 @@ bool Isolate::IsWasmSimdEnabled(Handle<Context> context) {
     v8::Local<v8::Context> api_context = v8::Utils::ToLocal(context);
     return wasm_simd_enabled_callback()(api_context);
   }
-  return FLAG_experimental_wasm_simd;
+  return v8_flags.experimental_wasm_simd;
 #else
   return false;
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -2971,7 +2971,7 @@ bool Isolate::AreWasmExceptionsEnabled(Handle<Context> context) {
     v8::Local<v8::Context> api_context = v8::Utils::ToLocal(context);
     return wasm_exceptions_enabled_callback()(api_context);
   }
-  return FLAG_experimental_wasm_eh;
+  return v8_flags.experimental_wasm_eh;
 #else
   return false;
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -3130,7 +3130,7 @@ class TracingAccountingAllocator : public AccountingAllocator {
   void TraceZoneDestructionImpl(const Zone* zone) override {
     base::MutexGuard lock(&mutex_);
 #ifdef V8_ENABLE_PRECISE_ZONE_STATS
-    if (FLAG_trace_zone_type_stats) {
+    if (v8_flags.trace_zone_type_stats) {
       type_stats_.MergeWith(zone->type_stats());
     }
 #endif
@@ -3139,7 +3139,7 @@ class TracingAccountingAllocator : public AccountingAllocator {
     nesting_depth_--;
 
 #ifdef V8_ENABLE_PRECISE_ZONE_STATS
-    if (FLAG_trace_zone_type_stats && active_zones_.empty()) {
+    if (v8_flags.trace_zone_type_stats && active_zones_.empty()) {
       type_stats_.Dump();
     }
 #endif
@@ -3147,16 +3147,17 @@ class TracingAccountingAllocator : public AccountingAllocator {
 
  private:
   void UpdateMemoryTrafficAndReportMemoryUsage(size_t memory_traffic_delta) {
-    if (!FLAG_trace_zone_stats &&
+    if (!v8_flags.trace_zone_stats &&
         !(TracingFlags::zone_stats.load(std::memory_order_relaxed) &
           v8::tracing::TracingCategoryObserver::ENABLED_BY_TRACING)) {
       // Don't print anything if the zone tracing was enabled only because of
-      // FLAG_trace_zone_type_stats.
+      // v8_flags.trace_zone_type_stats.
       return;
     }
 
     memory_traffic_since_last_report_ += memory_traffic_delta;
-    if (memory_traffic_since_last_report_ < FLAG_zone_stats_tolerance) return;
+    if (memory_traffic_since_last_report_ < v8_flags.zone_stats_tolerance)
+      return;
     memory_traffic_since_last_report_ = 0;
 
     Dump(buffer_, true);
@@ -3164,7 +3165,7 @@ class TracingAccountingAllocator : public AccountingAllocator {
     {
       std::string trace_str = buffer_.str();
 
-      if (FLAG_trace_zone_stats) {
+      if (v8_flags.trace_zone_stats) {
         PrintF(
             "{"
             "\"type\": \"v8-zone-trace\", "
@@ -3251,7 +3252,7 @@ std::atomic<size_t> Isolate::non_disposed_isolates_;
 
 namespace {
 bool HasFlagThatRequiresSharedHeap() {
-  return i::FLAG_shared_string_table || i::FLAG_harmony_struct;
+  return v8_flags.shared_string_table || v8_flags.harmony_struct;
 }
 }  // namespace
 
@@ -3277,9 +3278,9 @@ Isolate* Isolate::GetProcessWideSharedIsolate(bool* created_shared_isolate) {
     // configurable and tailored for the shared heap.
     v8::Isolate::CreateParams params;
     size_t initial_shared_heap_size =
-        static_cast<size_t>(FLAG_initial_shared_heap_size) * MB;
+        static_cast<size_t>(v8_flags.initial_shared_heap_size) * MB;
     size_t max_shared_heap_size =
-        static_cast<size_t>(FLAG_max_shared_heap_size) * MB;
+        static_cast<size_t>(v8_flags.max_shared_heap_size) * MB;
     if (initial_shared_heap_size != 0 && max_shared_heap_size != 0) {
       params.constraints.ConfigureDefaultsFromHeapSize(initial_shared_heap_size,
                                                        max_shared_heap_size);
@@ -3421,9 +3422,9 @@ Isolate::Isolate(std::unique_ptr<i::IsolateAllocator> isolate_allocator,
 #endif
       rail_mode_(PERFORMANCE_ANIMATION),
       logger_(new Logger()),
-      detailed_source_positions_for_profiling_(FLAG_detailed_line_info),
+      detailed_source_positions_for_profiling_(v8_flags.detailed_line_info),
       persistent_handles_list_(new PersistentHandlesList()),
-      jitless_(FLAG_jitless),
+      jitless_(v8_flags.jitless),
 #if V8_SFI_HAS_UNIQUE_ID
       next_unique_sfi_id_(0),
 #endif
@@ -3528,7 +3529,7 @@ void Isolate::ClearSerializerData() {
 // When profiling status changes, call this function to update the single bool
 // cache.
 void Isolate::UpdateLogObjectRelocation() {
-  log_object_relocation_ = FLAG_verify_predictable ||
+  log_object_relocation_ = v8_flags.verify_predictable ||
                            v8_file_logger()->is_logging() || is_profiling() ||
                            v8_file_logger()->is_listening_to_code_events() ||
                            (heap_profiler() != nullptr &&
@@ -3541,7 +3542,7 @@ void Isolate::Deinit() {
   DisallowHeapAllocation no_allocation;
 
   tracing_cpu_profiler_.reset();
-  if (FLAG_stress_sampling_allocation_profiler > 0) {
+  if (v8_flags.stress_sampling_allocation_profiler > 0) {
     heap_profiler()->StopSamplingHeapProfiler();
   }
 
@@ -3577,7 +3578,7 @@ void Isolate::Deinit() {
   // All client isolates should already be detached.
   if (is_shared()) global_safepoint()->AssertNoClientsOnTearDown();
 
-  if (FLAG_print_deopt_stress) {
+  if (v8_flags.print_deopt_stress) {
     PrintF(stdout, "=== Stress deopt counter: %u\n", stress_deopt_count_);
   }
 
@@ -3663,7 +3664,7 @@ void Isolate::Deinit() {
   if (logfile != nullptr) base::Fclose(logfile);
 
 #if defined(V8_OS_WIN) && defined(V8_ENABLE_ETW_STACK_WALKING)
-  if (i::FLAG_enable_etw_stack_walking) {
+  if (v8_flags.enable_etw_stack_walking) {
     ETWJITInterface::RemoveIsolate(this);
   }
 #endif  // defined(V8_OS_WIN)
@@ -4121,12 +4122,12 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
   // Code space setup requires the permissions to be set to default state.
   RwxMemoryWriteScope::SetDefaultPermissionsForNewThread();
   base::ElapsedTimer timer;
-  if (create_heap_objects && FLAG_profile_deserialization) timer.Start();
+  if (create_heap_objects && v8_flags.profile_deserialization) timer.Start();
 
   time_millis_at_init_ = heap_.MonotonicallyIncreasingTimeInMs();
 
-  stress_deopt_count_ = FLAG_deopt_every_n_times;
-  force_slow_path_ = FLAG_force_slow_path;
+  stress_deopt_count_ = v8_flags.deopt_every_n_times;
+  force_slow_path_ = v8_flags.force_slow_path;
 
   has_fatal_error_ = false;
 
@@ -4158,9 +4159,9 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
   interpreter_ = new interpreter::Interpreter(this);
   bigint_processor_ = bigint::Processor::New(new BigIntPlatform(this));
 
-  if (FLAG_lazy_compile_dispatcher) {
+  if (v8_flags.lazy_compile_dispatcher) {
     lazy_compile_dispatcher_ = std::make_unique<LazyCompileDispatcher>(
-        this, V8::GetCurrentPlatform(), FLAG_stack_size);
+        this, V8::GetCurrentPlatform(), v8_flags.stack_size);
   }
   baseline_batch_compiler_ = new baseline::BaselineBatchCompiler(this);
 #ifdef V8_ENABLE_MAGLEV
@@ -4225,7 +4226,7 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
     string_forwarding_table_ = shared_isolate()->string_forwarding_table_;
   }
 
-  if (V8_SHORT_BUILTIN_CALLS_BOOL && FLAG_short_builtin_calls) {
+  if (V8_SHORT_BUILTIN_CALLS_BOOL && v8_flags.short_builtin_calls) {
 #if defined(V8_OS_ANDROID)
     // On Android, the check is not operative to detect memory, and re-embedded
     // builtins don't have a memory cost.
@@ -4280,7 +4281,7 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
 #endif  // V8_ENABLE_WEBASSEMBLY
 
 #if defined(V8_OS_WIN) && defined(V8_ENABLE_ETW_STACK_WALKING)
-  if (i::FLAG_enable_etw_stack_walking) {
+  if (v8_flags.enable_etw_stack_walking) {
     ETWJITInterface::AddIsolate(this);
   }
 #endif  // defined(V8_OS_WIN)
@@ -4289,7 +4290,7 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
     setup_delegate_ = new SetupIsolateDelegate(create_heap_objects);
   }
 
-  if (!FLAG_inline_new) heap_.DisableInlineAllocation();
+  if (!v8_flags.inline_new) heap_.DisableInlineAllocation();
 
   if (!setup_delegate_->SetupHeap(&heap_)) {
     V8::FatalProcessOutOfMemory(this, "heap object creation");
@@ -4328,11 +4329,12 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
   // embedded blob setup).
   init_memcopy_functions();
 
-  if (FLAG_log_internal_timer_events) {
+  if (v8_flags.log_internal_timer_events) {
     set_event_logger(V8FileLogger::DefaultEventLoggerSentinel);
   }
 
-  if (FLAG_trace_turbo || FLAG_trace_turbo_graph || FLAG_turbo_profiling) {
+  if (v8_flags.trace_turbo || v8_flags.trace_turbo_graph ||
+      v8_flags.turbo_profiling) {
     PrintF("Concurrent recompilation has been disabled for tracing.\n");
   } else if (OptimizingCompileDispatcher::Enabled()) {
     optimizing_compile_dispatcher_ = new OptimizingCompileDispatcher(this);
@@ -4364,7 +4366,7 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
   }
 
 #ifdef VERIFY_HEAP
-  if (FLAG_verify_heap) {
+  if (v8_flags.verify_heap) {
     HeapVerifier::VerifyReadOnlyHeap(&heap_);
   }
 #endif
@@ -4391,8 +4393,8 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
   }
 #endif  // DEBUG
 
-  if (FLAG_print_builtin_code) builtins()->PrintBuiltinCode();
-  if (FLAG_print_builtin_size) builtins()->PrintBuiltinSize();
+  if (v8_flags.print_builtin_code) builtins()->PrintBuiltinCode();
+  if (v8_flags.print_builtin_size) builtins()->PrintBuiltinSize();
 
   // Finish initialization of ThreadLocal after deserialization is done.
   clear_pending_exception();
@@ -4403,7 +4405,7 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
   if (!create_heap_objects)
     Assembler::QuietNaN(ReadOnlyRoots(this).nan_value());
 
-  if (FLAG_trace_turbo) {
+  if (v8_flags.trace_turbo) {
     // Create an empty file.
     std::ofstream(GetTurboCfgFileName(this).c_str(), std::ios_base::trunc);
   }
@@ -4415,8 +4417,8 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
 
   initialized_from_snapshot_ = !create_heap_objects;
 
-  if (FLAG_stress_sampling_allocation_profiler > 0) {
-    uint64_t sample_interval = FLAG_stress_sampling_allocation_profiler;
+  if (v8_flags.stress_sampling_allocation_profiler > 0) {
+    uint64_t sample_interval = v8_flags.stress_sampling_allocation_profiler;
     int stack_depth = 128;
     v8::HeapProfiler::SamplingFlags sampling_flags =
         v8::HeapProfiler::SamplingFlags::kSamplingForceGC;
@@ -4434,17 +4436,17 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
   }
 #endif  // V8_OS_WIN64
 
-  if (create_heap_objects && FLAG_profile_deserialization) {
+  if (create_heap_objects && v8_flags.profile_deserialization) {
     double ms = timer.Elapsed().InMillisecondsF();
     PrintF("[Initializing isolate from scratch took %0.3f ms]\n", ms);
   }
 
 #ifdef V8_ENABLE_WEBASSEMBLY
-  if (FLAG_experimental_wasm_stack_switching) {
+  if (v8_flags.experimental_wasm_stack_switching) {
     std::unique_ptr<wasm::StackMemory> stack(
         wasm::StackMemory::GetCurrentStackView(this));
     this->wasm_stacks() = stack.get();
-    if (FLAG_trace_wasm_stack_switching) {
+    if (v8_flags.trace_wasm_stack_switching) {
       PrintF("Set up native stack object (limit: %p, base: %p)\n",
              stack->jslimit(), reinterpret_cast<void*>(stack->base()));
     }
@@ -4533,7 +4535,7 @@ std::unique_ptr<PersistentHandles> Isolate::NewPersistentHandles() {
 }
 
 void Isolate::DumpAndResetStats() {
-  if (FLAG_trace_turbo_stack_accesses) {
+  if (v8_flags.trace_turbo_stack_accesses) {
     StdoutStream os;
     uint64_t total_loads = 0;
     uint64_t total_stores = 0;
@@ -4559,13 +4561,13 @@ void Isolate::DumpAndResetStats() {
     }
   }
   if (turbo_statistics_ != nullptr) {
-    DCHECK(FLAG_turbo_stats || FLAG_turbo_stats_nvp);
+    DCHECK(v8_flags.turbo_stats || v8_flags.turbo_stats_nvp);
     StdoutStream os;
-    if (FLAG_turbo_stats) {
+    if (v8_flags.turbo_stats) {
       AsPrintableStatistics ps = {*turbo_statistics_, false};
       os << ps << std::endl;
     }
-    if (FLAG_turbo_stats_nvp) {
+    if (v8_flags.turbo_stats_nvp) {
       AsPrintableStatistics ps = {*turbo_statistics_, true};
       os << ps << std::endl;
     }
@@ -4574,7 +4576,7 @@ void Isolate::DumpAndResetStats() {
 #if V8_ENABLE_WEBASSEMBLY
   // TODO(7424): There is no public API for the {WasmEngine} yet. So for now we
   // just dump and reset the engines statistics together with the Isolate.
-  if (FLAG_turbo_stats_wasm) {
+  if (v8_flags.turbo_stats_wasm) {
     wasm::GetWasmEngine()->DumpAndResetTurboStatistics();
   }
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -4588,8 +4590,8 @@ void Isolate::DumpAndResetStats() {
   }
 #endif  // V8_RUNTIME_CALL_STATS
   if (BasicBlockProfiler::Get()->HasData(this)) {
-    if (FLAG_turbo_profiling_output) {
-      auto f = std::fopen(FLAG_turbo_profiling_output, "a");
+    if (v8_flags.turbo_profiling_output) {
+      auto f = std::fopen(v8_flags.turbo_profiling_output, "a");
       OFStream pgo_stream(f);
       BasicBlockProfiler::Get()->Log(this, pgo_stream);
     } else {
@@ -4600,7 +4602,7 @@ void Isolate::DumpAndResetStats() {
   } else {
     // Only log builtins PGO data if v8 was built with
     // v8_enable_builtins_profiling=true
-    CHECK_NULL(FLAG_turbo_profiling_output);
+    CHECK_NULL(v8_flags.turbo_profiling_output);
   }
 }
 
@@ -4625,7 +4627,7 @@ CodeTracer* Isolate::GetCodeTracer() {
 
 bool Isolate::use_optimizer() {
   // TODO(v8:7700): Update this predicate for a world with multiple tiers.
-  return (FLAG_turbofan || FLAG_maglev) && !serializer_enabled_ &&
+  return (v8_flags.turbofan || v8_flags.maglev) && !serializer_enabled_ &&
          CpuFeatures::SupportsOptimizer() && !is_precise_count_code_coverage();
 }
 
@@ -4643,8 +4645,9 @@ bool Isolate::NeedsDetailedOptimizedCodeLineInfo() const {
 bool Isolate::NeedsSourcePositionsForProfiling() const {
   return
       // Static conditions.
-      FLAG_trace_deopt || FLAG_trace_turbo || FLAG_trace_turbo_graph ||
-      FLAG_turbo_profiling || FLAG_perf_prof || FLAG_log_maps || FLAG_log_ic ||
+      v8_flags.trace_deopt || v8_flags.trace_turbo ||
+      v8_flags.trace_turbo_graph || v8_flags.turbo_profiling ||
+      v8_flags.perf_prof || v8_flags.log_maps || v8_flags.log_ic ||
       // Dynamic conditions; changing any of these conditions triggers source
       // position collection for the entire heap
       // (CollectSourcePositionsForAllBytecodeArrays).
@@ -4765,12 +4768,12 @@ static base::RandomNumberGenerator* ensure_rng_exists(
 base::RandomNumberGenerator* Isolate::random_number_generator() {
   // TODO(bmeurer) Initialized lazily because it depends on flags; can
   // be fixed once the default isolate cleanup is done.
-  return ensure_rng_exists(&random_number_generator_, FLAG_random_seed);
+  return ensure_rng_exists(&random_number_generator_, v8_flags.random_seed);
 }
 
 base::RandomNumberGenerator* Isolate::fuzzer_rng() {
   if (fuzzer_rng_ == nullptr) {
-    int64_t seed = FLAG_fuzzer_random_seed;
+    int64_t seed = v8_flags.fuzzer_random_seed;
     if (seed == 0) {
       seed = random_number_generator()->initial_seed();
     }
@@ -5001,7 +5004,7 @@ MaybeHandle<FixedArray> Isolate::GetImportAssertionsFromArgument(
 
   // The parser shouldn't have allowed the second argument to import() if
   // the flag wasn't enabled.
-  DCHECK(FLAG_harmony_import_assertions);
+  DCHECK(v8_flags.harmony_import_assertions);
 
   if (!import_assertions_argument->IsJSReceiver()) {
     this->Throw(
@@ -5433,7 +5436,7 @@ int Isolate::GetNextScriptId() { return heap()->NextScriptId(); }
 
 // static
 std::string Isolate::GetTurboCfgFileName(Isolate* isolate) {
-  if (const char* filename = FLAG_trace_turbo_cfg_file) return filename;
+  if (const char* filename = v8_flags.trace_turbo_cfg_file) return filename;
   std::ostringstream os;
   os << "turbo-" << base::OS::GetCurrentProcessId() << "-";
   if (isolate != nullptr) {
@@ -5479,7 +5482,7 @@ void Isolate::CheckDetachedContextsAfterGC() {
     ++new_length;
   }
 
-  if (FLAG_trace_detached_contexts) {
+  if (v8_flags.trace_detached_contexts) {
     PrintF("%d detached contexts are collected out of %d\n",
            length - new_length, length);
     for (int i = 0; i < new_length; i += 2) {
@@ -5506,7 +5509,7 @@ void Isolate::DetachGlobal(Handle<Context> env) {
   JSObject::ForceSetPrototype(this, global_proxy, factory()->null_value());
   global_proxy->map().set_constructor_or_back_pointer(roots.null_value(),
                                                       kRelaxedStore);
-  if (FLAG_track_detached_contexts) AddDetachedContext(env);
+  if (v8_flags.track_detached_contexts) AddDetachedContext(env);
   DCHECK(global_proxy->IsDetached());
 
   env->native_context().set_microtask_queue(this, nullptr);
@@ -5532,7 +5535,7 @@ void Isolate::SetRAILMode(RAILMode rail_mode) {
   if (old_rail_mode == PERFORMANCE_LOAD && rail_mode != PERFORMANCE_LOAD) {
     heap()->incremental_marking()->incremental_marking_job()->ScheduleTask();
   }
-  if (FLAG_trace_rail) {
+  if (v8_flags.trace_rail) {
     PrintIsolate(this, "RAIL mode: %s\n", RAILModeName(rail_mode));
   }
 }
diff --git a/src/execution/isolate.h b/src/execution/isolate.h
index 47a4c838c3d..9300970de15 100644
--- a/src/execution/isolate.h
+++ b/src/execution/isolate.h
@@ -1528,7 +1528,7 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
   bool concurrent_recompilation_enabled() {
     // Thread is only available with flag enabled.
     DCHECK(optimizing_compile_dispatcher_ == nullptr ||
-           FLAG_concurrent_recompilation);
+           v8_flags.concurrent_recompilation);
     return optimizing_compile_dispatcher_ != nullptr;
   }
 
@@ -2012,7 +2012,9 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
 
   // TODO(pthier): Unify with owns_shareable_data() once the flag
   // --shared-string-table is removed.
-  bool OwnsStringTables() { return !FLAG_shared_string_table || is_shared(); }
+  bool OwnsStringTables() {
+    return !v8_flags.shared_string_table || is_shared();
+  }
 
 #if USE_SIMULATOR
   SimulatorData* simulator_data() { return simulator_data_; }
@@ -2392,8 +2394,8 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
 
   std::vector<Object> startup_object_cache_;
 
-  // When sharing data among Isolates (e.g. FLAG_shared_string_table), only the
-  // shared Isolate populates this and client Isolates reference that copy.
+  // When sharing data among Isolates (e.g. v8_flags.shared_string_table), only
+  // the shared Isolate populates this and client Isolates reference that copy.
   //
   // Otherwise this is populated for all Isolates.
   std::vector<Object> shared_heap_object_cache_;
diff --git a/src/execution/local-isolate.cc b/src/execution/local-isolate.cc
index e4bd4dfe046..aa30289ae6a 100644
--- a/src/execution/local-isolate.cc
+++ b/src/execution/local-isolate.cc
@@ -22,7 +22,7 @@ LocalIsolate::LocalIsolate(Isolate* isolate, ThreadKind kind)
       thread_id_(ThreadId::Current()),
       stack_limit_(kind == ThreadKind::kMain
                        ? isolate->stack_guard()->real_climit()
-                       : GetCurrentStackPosition() - FLAG_stack_size * KB)
+                       : GetCurrentStackPosition() - v8_flags.stack_size * KB)
 #ifdef V8_INTL_SUPPORT
       ,
       default_locale_(isolate->DefaultLocale())
diff --git a/src/execution/loong64/simulator-loong64.cc b/src/execution/loong64/simulator-loong64.cc
index 1e8702d5833..f15015fcb68 100644
--- a/src/execution/loong64/simulator-loong64.cc
+++ b/src/execution/loong64/simulator-loong64.cc
@@ -830,7 +830,7 @@ void Simulator::CheckICache(base::CustomMatcherHashMap* i_cache,
 Simulator::Simulator(Isolate* isolate) : isolate_(isolate) {
   // Set up simulator support first. Some of this information is needed to
   // setup the architecture state.
-  stack_size_ = FLAG_sim_stack_size * KB;
+  stack_size_ = v8_flags.sim_stack_size * KB;
   stack_ = reinterpret_cast<char*>(base::Malloc(stack_size_));
   pc_modified_ = false;
   icount_ = 0;
@@ -1490,7 +1490,7 @@ void Simulator::DieOrDebug() {
 }
 
 void Simulator::TraceRegWr(int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int64_t fmt_int64;
       int32_t fmt_int32[2];
@@ -1540,7 +1540,7 @@ void Simulator::TraceRegWr(int64_t value, TraceType t) {
 
 // TODO(plind): consider making icount_ printing a flag option.
 void Simulator::TraceMemRd(int64_t addr, int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int64_t fmt_int64;
       int32_t fmt_int32[2];
@@ -1589,7 +1589,7 @@ void Simulator::TraceMemRd(int64_t addr, int64_t value, TraceType t) {
 }
 
 void Simulator::TraceMemWr(int64_t addr, int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (t) {
       case BYTE:
         base::SNPrintF(trace_buf_,
@@ -1622,7 +1622,7 @@ void Simulator::TraceMemWr(int64_t addr, int64_t value, TraceType t) {
 
 template <typename T>
 void Simulator::TraceMemRd(int64_t addr, T value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (sizeof(T)) {
       case 1:
         base::SNPrintF(trace_buf_,
@@ -1663,7 +1663,7 @@ void Simulator::TraceMemRd(int64_t addr, T value) {
 
 template <typename T>
 void Simulator::TraceMemWr(int64_t addr, T value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (sizeof(T)) {
       case 1:
         base::SNPrintF(trace_buf_,
@@ -2290,7 +2290,7 @@ void Simulator::SoftwareInterrupt() {
       GetFpArgs(&dval0, &dval1, &ival);
       SimulatorRuntimeCall generic_target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_FP_FP_CALL:
           case ExternalReference::BUILTIN_COMPARE_CALL:
@@ -2345,7 +2345,7 @@ void Simulator::SoftwareInterrupt() {
         default:
           UNREACHABLE();
       }
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_COMPARE_CALL:
             PrintF("Returned %08x\n", static_cast<int32_t>(iresult));
@@ -2360,7 +2360,7 @@ void Simulator::SoftwareInterrupt() {
         }
       }
     } else if (redirection->type() == ExternalReference::DIRECT_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 " \n",
                reinterpret_cast<void*>(external), arg0);
       }
@@ -2368,7 +2368,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeDirectApiCall>(external);
       target(arg0);
     } else if (redirection->type() == ExternalReference::PROFILING_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 "  %08" PRIx64
                " \n",
                reinterpret_cast<void*>(external), arg0, arg1);
@@ -2377,7 +2377,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeProfilingApiCall>(external);
       target(arg0, Redirection::UnwrapRedirection(arg1));
     } else if (redirection->type() == ExternalReference::DIRECT_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 "  %08" PRIx64
                " \n",
                reinterpret_cast<void*>(external), arg0, arg1);
@@ -2387,7 +2387,7 @@ void Simulator::SoftwareInterrupt() {
       target(arg0, arg1);
     } else if (redirection->type() ==
                ExternalReference::PROFILING_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 "  %08" PRIx64
                "  %08" PRIx64 " \n",
                reinterpret_cast<void*>(external), arg0, arg1, arg2);
@@ -2400,7 +2400,7 @@ void Simulator::SoftwareInterrupt() {
              redirection->type() == ExternalReference::BUILTIN_CALL_PAIR);
       SimulatorRuntimeCall target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF(
             "Call to host function at %p "
             "args %08" PRIx64 " , %08" PRIx64 " , %08" PRIx64 " , %08" PRIx64
@@ -2419,7 +2419,7 @@ void Simulator::SoftwareInterrupt() {
       set_register(v0, (int64_t)(result.x));
       set_register(v1, (int64_t)(result.y));
     }
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("Returned %08" PRIx64 "  : %08" PRIx64 " \n", get_register(v1),
              get_register(v0));
     }
@@ -5318,14 +5318,14 @@ void Simulator::DecodeTypeOp22() {
 
 // Executes the current instruction.
 void Simulator::InstructionDecode(Instruction* instr) {
-  if (v8::internal::FLAG_check_icache) {
+  if (v8_flags.check_icache) {
     CheckICache(i_cache(), instr);
   }
   pc_modified_ = false;
 
   v8::base::EmbeddedVector<char, 256> buffer;
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     base::SNPrintF(trace_buf_, " ");
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
@@ -5369,7 +5369,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     }
   }
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     PrintF("  0x%08" PRIxPTR "   %-44s   %s\n",
            reinterpret_cast<intptr_t>(instr), buffer.begin(),
            trace_buf_.begin());
@@ -5384,7 +5384,7 @@ void Simulator::Execute() {
   // Get the PC to simulate. Cannot use the accessor here as we need the
   // raw PC value and not the one used as input to arithmetic instructions.
   int64_t program_counter = get_pc();
-  if (::v8::internal::FLAG_stop_sim_at == 0) {
+  if (v8_flags.stop_sim_at == 0) {
     // Fast version of the dispatch loop without checking whether the simulator
     // should be stopping at a particular executed instruction.
     while (program_counter != end_sim_pc) {
@@ -5394,12 +5394,12 @@ void Simulator::Execute() {
       program_counter = get_pc();
     }
   } else {
-    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
-    // we reach the particular instruction count.
+    // v8_flags.stop_sim_at is at the non-default value. Stop in the debugger
+    // when we reach the particular instruction count.
     while (program_counter != end_sim_pc) {
       Instruction* instr = reinterpret_cast<Instruction*>(program_counter);
       icount_++;
-      if (icount_ == static_cast<int64_t>(::v8::internal::FLAG_stop_sim_at)) {
+      if (icount_ == static_cast<int64_t>(v8_flags.stop_sim_at)) {
         Loong64Debugger dbg(this);
         dbg.Debug();
       } else {
diff --git a/src/execution/messages.cc b/src/execution/messages.cc
index 82b1cc9c2a0..c8ab777730b 100644
--- a/src/execution/messages.cc
+++ b/src/execution/messages.cc
@@ -83,7 +83,7 @@ Handle<JSMessageObject> MessageHandler::MakeMessageObject(
   int bytecode_offset = -1;
   Handle<Script> script_handle = isolate->factory()->empty_script();
   Handle<SharedFunctionInfo> shared_info;
-  if (location != nullptr && !FLAG_correctness_fuzzer_suppressions) {
+  if (location != nullptr && !v8_flags.correctness_fuzzer_suppressions) {
     start = location->start_pos();
     end = location->end_pos();
     script_handle = location->script();
@@ -296,7 +296,7 @@ class V8_NODISCARD PrepareStackTraceScope {
 MaybeHandle<Object> ErrorUtils::FormatStackTrace(Isolate* isolate,
                                                  Handle<JSObject> error,
                                                  Handle<Object> raw_stack) {
-  if (FLAG_correctness_fuzzer_suppressions) {
+  if (v8_flags.correctness_fuzzer_suppressions) {
     return isolate->factory()->empty_string();
   }
   DCHECK(raw_stack->IsFixedArray());
@@ -507,7 +507,7 @@ MaybeHandle<JSObject> ErrorUtils::Construct(
     Isolate* isolate, Handle<JSFunction> target, Handle<Object> new_target,
     Handle<Object> message, Handle<Object> options, FrameSkipMode mode,
     Handle<Object> caller, StackTraceCollection stack_trace_collection) {
-  if (FLAG_correctness_fuzzer_suppressions) {
+  if (v8_flags.correctness_fuzzer_suppressions) {
     // Abort range errors in correctness fuzzing, as their causes differ
     // accross correctness-fuzzing scenarios.
     if (target.is_identical_to(isolate->range_error_function())) {
@@ -693,7 +693,7 @@ Handle<JSObject> ErrorUtils::MakeGenericError(
     Isolate* isolate, Handle<JSFunction> constructor, MessageTemplate index,
     Handle<Object> arg0, Handle<Object> arg1, Handle<Object> arg2,
     FrameSkipMode mode) {
-  if (FLAG_clear_exceptions_on_js_entry) {
+  if (v8_flags.clear_exceptions_on_js_entry) {
     // This function used to be implemented in JavaScript, and JSEntry
     // clears any pending exceptions - so whenever we'd call this from C++,
     // pending exceptions would be cleared. Preserve this behavior.
diff --git a/src/execution/mips/simulator-mips.cc b/src/execution/mips/simulator-mips.cc
index bcf2bb8f880..22551ef2c7c 100644
--- a/src/execution/mips/simulator-mips.cc
+++ b/src/execution/mips/simulator-mips.cc
@@ -856,7 +856,7 @@ void Simulator::CheckICache(base::CustomMatcherHashMap* i_cache,
 Simulator::Simulator(Isolate* isolate) : isolate_(isolate) {
   // Set up simulator support first. Some of this information is needed to
   // setup the architecture state.
-  stack_size_ = FLAG_sim_stack_size * KB;
+  stack_size_ = v8_flags.sim_stack_size * KB;
   stack_ = reinterpret_cast<char*>(base::Malloc(stack_size_));
   pc_modified_ = false;
   icount_ = 0;
@@ -1627,7 +1627,7 @@ int32_t Simulator::get_pc() const { return registers_[pc]; }
 // get the correct MIPS-like behaviour on unaligned accesses.
 
 void Simulator::TraceRegWr(int32_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int32_t fmt_int32;
       float fmt_float;
@@ -1652,7 +1652,7 @@ void Simulator::TraceRegWr(int32_t value, TraceType t) {
 }
 
 void Simulator::TraceRegWr(int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int64_t fmt_int64;
       double fmt_double;
@@ -1678,7 +1678,7 @@ void Simulator::TraceRegWr(int64_t value, TraceType t) {
 
 template <typename T>
 void Simulator::TraceMSARegWr(T* value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       uint8_t b[16];
       uint16_t h[8];
@@ -1731,7 +1731,7 @@ void Simulator::TraceMSARegWr(T* value, TraceType t) {
 
 template <typename T>
 void Simulator::TraceMSARegWr(T* value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       uint8_t b[kMSALanesByte];
       uint16_t h[kMSALanesHalf];
@@ -1768,7 +1768,7 @@ void Simulator::TraceMSARegWr(T* value) {
 
 // TODO(plind): consider making icount_ printing a flag option.
 void Simulator::TraceMemRd(int32_t addr, int32_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int32_t fmt_int32;
       float fmt_float;
@@ -1794,7 +1794,7 @@ void Simulator::TraceMemRd(int32_t addr, int32_t value, TraceType t) {
 }
 
 void Simulator::TraceMemWr(int32_t addr, int32_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (t) {
       case BYTE:
         SNPrintF(trace_buf_,
@@ -1819,7 +1819,7 @@ void Simulator::TraceMemWr(int32_t addr, int32_t value, TraceType t) {
 
 template <typename T>
 void Simulator::TraceMemRd(int32_t addr, T value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (sizeof(T)) {
       case 1:
         SNPrintF(trace_buf_,
@@ -1857,7 +1857,7 @@ void Simulator::TraceMemRd(int32_t addr, T value) {
 
 template <typename T>
 void Simulator::TraceMemWr(int32_t addr, T value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (sizeof(T)) {
       case 1:
         SNPrintF(trace_buf_,
@@ -1886,7 +1886,7 @@ void Simulator::TraceMemWr(int32_t addr, T value) {
 }
 
 void Simulator::TraceMemRd(int32_t addr, int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int64_t fmt_int64;
       int32_t fmt_int32[2];
@@ -1921,7 +1921,7 @@ void Simulator::TraceMemRd(int32_t addr, int64_t value, TraceType t) {
 }
 
 void Simulator::TraceMemWr(int32_t addr, int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (t) {
       case DWORD:
         SNPrintF(trace_buf_,
@@ -2316,7 +2316,7 @@ void Simulator::SoftwareInterrupt() {
       GetFpArgs(&dval0, &dval1, &ival);
       SimulatorRuntimeCall generic_target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_FP_FP_CALL:
           case ExternalReference::BUILTIN_COMPARE_CALL:
@@ -2371,7 +2371,7 @@ void Simulator::SoftwareInterrupt() {
         default:
           UNREACHABLE();
       }
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_COMPARE_CALL:
             PrintF("Returned %08x\n", static_cast<int32_t>(iresult));
@@ -2386,7 +2386,7 @@ void Simulator::SoftwareInterrupt() {
         }
       }
     } else if (redirection->type() == ExternalReference::DIRECT_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08x\n",
                reinterpret_cast<void*>(external), arg0);
       }
@@ -2394,7 +2394,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeDirectApiCall>(external);
       target(arg0);
     } else if (redirection->type() == ExternalReference::PROFILING_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08x %08x\n",
                reinterpret_cast<void*>(external), arg0, arg1);
       }
@@ -2402,7 +2402,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeProfilingApiCall>(external);
       target(arg0, Redirection::UnwrapRedirection(arg1));
     } else if (redirection->type() == ExternalReference::DIRECT_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08x %08x\n",
                reinterpret_cast<void*>(external), arg0, arg1);
       }
@@ -2411,7 +2411,7 @@ void Simulator::SoftwareInterrupt() {
       target(arg0, arg1);
     } else if (redirection->type() ==
                ExternalReference::PROFILING_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08x %08x %08x\n",
                reinterpret_cast<void*>(external), arg0, arg1, arg2);
       }
@@ -2423,7 +2423,7 @@ void Simulator::SoftwareInterrupt() {
              redirection->type() == ExternalReference::BUILTIN_CALL_PAIR);
       SimulatorRuntimeCall target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF(
             "Call to host function at %p "
             "args %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08x, %08xi, "
@@ -2439,7 +2439,7 @@ void Simulator::SoftwareInterrupt() {
       set_register(v0, static_cast<int32_t>(result));
       set_register(v1, static_cast<int32_t>(result >> 32));
     }
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("Returned %08x : %08x\n", get_register(v1), get_register(v0));
     }
     set_register(ra, saved_ra);
@@ -6338,7 +6338,7 @@ void Simulator::DecodeTypeImmediate() {
     int32_t current_pc = get_pc();
     const int32_t bitsIn16Int = sizeof(int16_t) * kBitsPerByte;
     if (do_branch) {
-      if (FLAG_debug_code) {
+      if (v8_flags.debug_code) {
         int16_t bits = imm16 & 0xFC;
         if (imm16 >= 0) {
           CHECK_EQ(bits, 0);
@@ -6918,12 +6918,12 @@ void Simulator::DecodeTypeJump() {
 
 // Executes the current instruction.
 void Simulator::InstructionDecode(Instruction* instr) {
-  if (v8::internal::FLAG_check_icache) {
+  if (v8_flags.check_icache) {
     CheckICache(i_cache(), instr);
   }
   pc_modified_ = false;
   v8::base::EmbeddedVector<char, 256> buffer;
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     SNPrintF(trace_buf_, "%s", "");
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
@@ -6944,7 +6944,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     default:
       UNSUPPORTED();
   }
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     PrintF("  0x%08" PRIxPTR "  %-44s   %s\n",
            reinterpret_cast<intptr_t>(instr), buffer.begin(),
            trace_buf_.begin());
@@ -6958,7 +6958,7 @@ void Simulator::Execute() {
   // Get the PC to simulate. Cannot use the accessor here as we need the
   // raw PC value and not the one used as input to arithmetic instructions.
   int program_counter = get_pc();
-  if (::v8::internal::FLAG_stop_sim_at == 0) {
+  if (v8_flags.stop_sim_at == 0) {
     // Fast version of the dispatch loop without checking whether the simulator
     // should be stopping at a particular executed instruction.
     while (program_counter != end_sim_pc) {
@@ -6968,12 +6968,12 @@ void Simulator::Execute() {
       program_counter = get_pc();
     }
   } else {
-    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
-    // we reach the particular instruction count.
+    // v8_flags.stop_sim_at is at the non-default value. Stop in the debugger
+    // when we reach the particular instruction count.
     while (program_counter != end_sim_pc) {
       Instruction* instr = reinterpret_cast<Instruction*>(program_counter);
       icount_++;
-      if (icount_ == static_cast<uint64_t>(::v8::internal::FLAG_stop_sim_at)) {
+      if (icount_ == static_cast<uint64_t>(v8_flags.stop_sim_at)) {
         MipsDebugger dbg(this);
         dbg.Debug();
       } else {
diff --git a/src/execution/mips64/simulator-mips64.cc b/src/execution/mips64/simulator-mips64.cc
index a0e8d22156b..b3149083ac8 100644
--- a/src/execution/mips64/simulator-mips64.cc
+++ b/src/execution/mips64/simulator-mips64.cc
@@ -799,7 +799,7 @@ void Simulator::CheckICache(base::CustomMatcherHashMap* i_cache,
 Simulator::Simulator(Isolate* isolate) : isolate_(isolate) {
   // Set up simulator support first. Some of this information is needed to
   // setup the architecture state.
-  stack_size_ = FLAG_sim_stack_size * KB;
+  stack_size_ = v8_flags.sim_stack_size * KB;
   stack_ = reinterpret_cast<char*>(base::Malloc(stack_size_));
   pc_modified_ = false;
   icount_ = 0;
@@ -1568,7 +1568,7 @@ void Simulator::DieOrDebug() {
 }
 
 void Simulator::TraceRegWr(int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int64_t fmt_int64;
       int32_t fmt_int32[2];
@@ -1618,7 +1618,7 @@ void Simulator::TraceRegWr(int64_t value, TraceType t) {
 
 template <typename T>
 void Simulator::TraceMSARegWr(T* value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       uint8_t b[16];
       uint16_t h[8];
@@ -1674,7 +1674,7 @@ void Simulator::TraceMSARegWr(T* value, TraceType t) {
 
 template <typename T>
 void Simulator::TraceMSARegWr(T* value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       uint8_t b[kMSALanesByte];
       uint16_t h[kMSALanesHalf];
@@ -1711,7 +1711,7 @@ void Simulator::TraceMSARegWr(T* value) {
 
 // TODO(plind): consider making icount_ printing a flag option.
 void Simulator::TraceMemRd(int64_t addr, int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int64_t fmt_int64;
       int32_t fmt_int32[2];
@@ -1760,7 +1760,7 @@ void Simulator::TraceMemRd(int64_t addr, int64_t value, TraceType t) {
 }
 
 void Simulator::TraceMemWr(int64_t addr, int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (t) {
       case BYTE:
         base::SNPrintF(trace_buf_,
@@ -1793,7 +1793,7 @@ void Simulator::TraceMemWr(int64_t addr, int64_t value, TraceType t) {
 
 template <typename T>
 void Simulator::TraceMemRd(int64_t addr, T value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (sizeof(T)) {
       case 1:
         base::SNPrintF(trace_buf_,
@@ -1834,7 +1834,7 @@ void Simulator::TraceMemRd(int64_t addr, T value) {
 
 template <typename T>
 void Simulator::TraceMemWr(int64_t addr, T value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (sizeof(T)) {
       case 1:
         base::SNPrintF(trace_buf_,
@@ -2455,7 +2455,7 @@ void Simulator::SoftwareInterrupt() {
       GetFpArgs(&dval0, &dval1, &ival);
       SimulatorRuntimeCall generic_target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_FP_FP_CALL:
           case ExternalReference::BUILTIN_COMPARE_CALL:
@@ -2510,7 +2510,7 @@ void Simulator::SoftwareInterrupt() {
         default:
           UNREACHABLE();
       }
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_COMPARE_CALL:
             PrintF("Returned %08x\n", static_cast<int32_t>(iresult));
@@ -2525,7 +2525,7 @@ void Simulator::SoftwareInterrupt() {
         }
       }
     } else if (redirection->type() == ExternalReference::DIRECT_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 " \n",
                reinterpret_cast<void*>(external), arg0);
       }
@@ -2533,7 +2533,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeDirectApiCall>(external);
       target(arg0);
     } else if (redirection->type() == ExternalReference::PROFILING_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 "  %08" PRIx64
                " \n",
                reinterpret_cast<void*>(external), arg0, arg1);
@@ -2542,7 +2542,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeProfilingApiCall>(external);
       target(arg0, Redirection::UnwrapRedirection(arg1));
     } else if (redirection->type() == ExternalReference::DIRECT_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 "  %08" PRIx64
                " \n",
                reinterpret_cast<void*>(external), arg0, arg1);
@@ -2552,7 +2552,7 @@ void Simulator::SoftwareInterrupt() {
       target(arg0, arg1);
     } else if (redirection->type() ==
                ExternalReference::PROFILING_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function at %p args %08" PRIx64 "  %08" PRIx64
                "  %08" PRIx64 " \n",
                reinterpret_cast<void*>(external), arg0, arg1, arg2);
@@ -2565,7 +2565,7 @@ void Simulator::SoftwareInterrupt() {
              redirection->type() == ExternalReference::BUILTIN_CALL_PAIR);
       SimulatorRuntimeCall target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF(
             "Call to host function at %p "
             "args %08" PRIx64 " , %08" PRIx64 " , %08" PRIx64 " , %08" PRIx64
@@ -2584,7 +2584,7 @@ void Simulator::SoftwareInterrupt() {
       set_register(v0, (int64_t)(result.x));
       set_register(v1, (int64_t)(result.y));
     }
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("Returned %08" PRIx64 "  : %08" PRIx64 " \n", get_register(v1),
              get_register(v0));
     }
@@ -6777,7 +6777,7 @@ void Simulator::DecodeTypeImmediate() {
     int64_t current_pc = get_pc();
     const int32_t bitsIn16Int = sizeof(int16_t) * kBitsPerByte;
     if (do_branch) {
-      if (FLAG_debug_code) {
+      if (v8_flags.debug_code) {
         int16_t bits = imm16 & 0xFC;
         if (imm16 >= 0) {
           CHECK_EQ(bits, 0);
@@ -7473,14 +7473,14 @@ void Simulator::DecodeTypeJump() {
 
 // Executes the current instruction.
 void Simulator::InstructionDecode(Instruction* instr) {
-  if (v8::internal::FLAG_check_icache) {
+  if (v8_flags.check_icache) {
     CheckICache(i_cache(), instr);
   }
   pc_modified_ = false;
 
   v8::base::EmbeddedVector<char, 256> buffer;
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     base::SNPrintF(trace_buf_, " ");
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
@@ -7503,7 +7503,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
       UNSUPPORTED();
   }
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     PrintF("  0x%08" PRIxPTR "   %-44s   %s\n",
            reinterpret_cast<intptr_t>(instr), buffer.begin(),
            trace_buf_.begin());
@@ -7518,7 +7518,7 @@ void Simulator::Execute() {
   // Get the PC to simulate. Cannot use the accessor here as we need the
   // raw PC value and not the one used as input to arithmetic instructions.
   int64_t program_counter = get_pc();
-  if (::v8::internal::FLAG_stop_sim_at == 0) {
+  if (v8_flags.stop_sim_at == 0) {
     // Fast version of the dispatch loop without checking whether the simulator
     // should be stopping at a particular executed instruction.
     while (program_counter != end_sim_pc) {
@@ -7528,12 +7528,12 @@ void Simulator::Execute() {
       program_counter = get_pc();
     }
   } else {
-    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
-    // we reach the particular instruction count.
+    // v8_flags.stop_sim_at is at the non-default value. Stop in the debugger
+    // when we reach the particular instruction count.
     while (program_counter != end_sim_pc) {
       Instruction* instr = reinterpret_cast<Instruction*>(program_counter);
       icount_++;
-      if (icount_ == static_cast<int64_t>(::v8::internal::FLAG_stop_sim_at)) {
+      if (icount_ == static_cast<int64_t>(v8_flags.stop_sim_at)) {
         MipsDebugger dbg(this);
         dbg.Debug();
       } else {
diff --git a/src/execution/ppc/frame-constants-ppc.cc b/src/execution/ppc/frame-constants-ppc.cc
index 7ef3ea12bf3..757d20249e6 100644
--- a/src/execution/ppc/frame-constants-ppc.cc
+++ b/src/execution/ppc/frame-constants-ppc.cc
@@ -16,7 +16,7 @@ namespace internal {
 Register JavaScriptFrame::fp_register() { return v8::internal::fp; }
 Register JavaScriptFrame::context_register() { return cp; }
 Register JavaScriptFrame::constant_pool_pointer_register() {
-  DCHECK(FLAG_enable_embedded_constant_pool);
+  DCHECK(v8_flags.enable_embedded_constant_pool);
   return kConstantPoolRegister;
 }
 
diff --git a/src/execution/ppc/frame-constants-ppc.h b/src/execution/ppc/frame-constants-ppc.h
index c7c378f37a5..6c82a864fe5 100644
--- a/src/execution/ppc/frame-constants-ppc.h
+++ b/src/execution/ppc/frame-constants-ppc.h
@@ -17,8 +17,8 @@ class EntryFrameConstants : public AllStatic {
  public:
   // Need to take constant pool into account.
   static constexpr int kCallerFPOffset =
-      FLAG_enable_embedded_constant_pool.value() ? -4 * kSystemPointerSize
-                                                 : -3 * kSystemPointerSize;
+      v8_flags.enable_embedded_constant_pool.value() ? -4 * kSystemPointerSize
+                                                     : -3 * kSystemPointerSize;
 };
 
 class WasmCompileLazyFrameConstants : public TypedFrameConstants {
diff --git a/src/execution/ppc/simulator-ppc.cc b/src/execution/ppc/simulator-ppc.cc
index d3d260b1c14..0177f2b784d 100644
--- a/src/execution/ppc/simulator-ppc.cc
+++ b/src/execution/ppc/simulator-ppc.cc
@@ -178,8 +178,8 @@ void PPCDebugger::Debug() {
   // to all commands.
   UndoBreakpoint();
   // Disable tracing while simulating
-  bool trace = ::v8::internal::FLAG_trace_sim;
-  ::v8::internal::FLAG_trace_sim = false;
+  bool trace = v8_flags.trace_sim;
+  v8_flags.trace_sim = false;
 
   while (!done && !sim_->has_bad_pc()) {
     if (last_pc != sim_->get_pc()) {
@@ -534,9 +534,9 @@ void PPCDebugger::Debug() {
           PrintF("Wrong usage. Use help command for more information.\n");
         }
       } else if ((strcmp(cmd, "t") == 0) || strcmp(cmd, "trace") == 0) {
-        ::v8::internal::FLAG_trace_sim = !::v8::internal::FLAG_trace_sim;
+        v8_flags.trace_sim = !v8_flags.trace_sim;
         PrintF("Trace of executed instructions is %s\n",
-               ::v8::internal::FLAG_trace_sim ? "on" : "off");
+               v8_flags.trace_sim ? "on" : "off");
       } else if ((strcmp(cmd, "h") == 0) || (strcmp(cmd, "help") == 0)) {
         PrintF("cont\n");
         PrintF("  continue execution (alias 'c')\n");
@@ -617,7 +617,7 @@ void PPCDebugger::Debug() {
   // hit.
   RedoBreakpoint();
   // Restore tracing
-  ::v8::internal::FLAG_trace_sim = trace;
+  v8_flags.trace_sim = trace;
 
 #undef COMMAND_SIZE
 #undef ARG_SIZE
@@ -733,7 +733,7 @@ Simulator::Simulator(Isolate* isolate) : isolate_(isolate) {
 // Set up simulator support first. Some of this information is needed to
 // setup the architecture state.
 #if V8_TARGET_ARCH_PPC64
-  size_t stack_size = FLAG_sim_stack_size * KB;
+  size_t stack_size = v8_flags.sim_stack_size * KB;
 #else
   size_t stack_size = MB;  // allocate 1MB for stack
 #endif
@@ -977,8 +977,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       // Check if stack is aligned. Error if not aligned is reported below to
       // include information on the function called.
       bool stack_aligned =
-          (get_register(sp) & (::v8::internal::FLAG_sim_stack_alignment - 1)) ==
-          0;
+          (get_register(sp) & (v8_flags.sim_stack_alignment - 1)) == 0;
       Redirection* redirection = Redirection::FromInstruction(instr);
       const int kArgCount = 20;
       const int kRegisterArgCount = 8;
@@ -1019,7 +1018,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         int iresult = 0;      // integer return value
         double dresult = 0;   // double return value
         GetFpArgs(&dval0, &dval1, &ival);
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           SimulatorRuntimeCall generic_target =
               reinterpret_cast<SimulatorRuntimeCall>(external);
           switch (redirection->type()) {
@@ -1081,7 +1080,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
           default:
             UNREACHABLE();
         }
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           switch (redirection->type()) {
             case ExternalReference::BUILTIN_COMPARE_CALL:
               PrintF("Returned %08x\n", iresult);
@@ -1098,7 +1097,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       } else if (redirection->type() == ExternalReference::DIRECT_API_CALL) {
         // See callers of MacroAssembler::CallApiFunctionAndReturn for
         // explanation of register usage.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0]);
           if (!stack_aligned) {
@@ -1114,7 +1113,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       } else if (redirection->type() == ExternalReference::PROFILING_API_CALL) {
         // See callers of MacroAssembler::CallApiFunctionAndReturn for
         // explanation of register usage.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR
                  " %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0], arg[1]);
@@ -1131,7 +1130,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       } else if (redirection->type() == ExternalReference::DIRECT_GETTER_CALL) {
         // See callers of MacroAssembler::CallApiFunctionAndReturn for
         // explanation of register usage.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR
                  " %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0], arg[1]);
@@ -1150,7 +1149,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         target(arg[0], arg[1]);
       } else if (redirection->type() ==
                  ExternalReference::PROFILING_GETTER_CALL) {
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR
                  " %08" V8PRIxPTR " %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0], arg[1], arg[2]);
@@ -1169,7 +1168,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         target(arg[0], arg[1], Redirection::UnwrapRedirection(arg[2]));
       } else {
         // builtin call.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           SimulatorRuntimeCall target =
               reinterpret_cast<SimulatorRuntimeCall>(external);
           PrintF(
@@ -1202,7 +1201,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
           intptr_t x;
           intptr_t y;
           decodeObjectPair(&result, &x, &y);
-          if (::v8::internal::FLAG_trace_sim) {
+          if (v8_flags.trace_sim) {
             PrintF("Returned {%08" V8PRIxPTR ", %08" V8PRIxPTR "}\n", x, y);
           }
           if (ABI_RETURNS_OBJECT_PAIRS_IN_REGS) {
@@ -1232,7 +1231,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
               target(arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6],
                      arg[7], arg[8], arg[9], arg[10], arg[11], arg[12], arg[13],
                      arg[14], arg[15], arg[16], arg[17], arg[18], arg[19]);
-          if (::v8::internal::FLAG_trace_sim) {
+          if (v8_flags.trace_sim) {
             PrintF("Returned %08" V8PRIxPTR "\n", result);
           }
           set_register(r3, result);
@@ -5385,11 +5384,11 @@ void Simulator::Trace(Instruction* instr) {
 
 // Executes the current instruction.
 void Simulator::ExecuteInstruction(Instruction* instr) {
-  if (v8::internal::FLAG_check_icache) {
+  if (v8_flags.check_icache) {
     CheckICache(i_cache(), instr);
   }
   pc_modified_ = false;
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     Trace(instr);
   }
   uint32_t opcode = instr->OpcodeField();
@@ -5408,7 +5407,7 @@ void Simulator::Execute() {
   // raw PC value and not the one used as input to arithmetic instructions.
   intptr_t program_counter = get_pc();
 
-  if (::v8::internal::FLAG_stop_sim_at == 0) {
+  if (v8_flags.stop_sim_at == 0) {
     // Fast version of the dispatch loop without checking whether the simulator
     // should be stopping at a particular executed instruction.
     while (program_counter != end_sim_pc) {
@@ -5418,12 +5417,12 @@ void Simulator::Execute() {
       program_counter = get_pc();
     }
   } else {
-    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
-    // we reach the particular instruction count.
+    // v8_flags.stop_sim_at is at the non-default value. Stop in the debugger
+    // when we reach the particular instruction count.
     while (program_counter != end_sim_pc) {
       Instruction* instr = reinterpret_cast<Instruction*>(program_counter);
       icount_++;
-      if (icount_ == ::v8::internal::FLAG_stop_sim_at) {
+      if (icount_ == v8_flags.stop_sim_at) {
         PPCDebugger dbg(this);
         dbg.Debug();
       } else {
diff --git a/src/execution/protectors.cc b/src/execution/protectors.cc
index 71d9fa9735b..2889b76a6f2 100644
--- a/src/execution/protectors.cc
+++ b/src/execution/protectors.cc
@@ -19,12 +19,12 @@ namespace internal {
 namespace {
 
 void TraceProtectorInvalidation(const char* protector_name) {
-  DCHECK(FLAG_trace_protector_invalidation);
+  DCHECK(v8_flags.trace_protector_invalidation);
   static constexpr char kInvalidateProtectorTracingCategory[] =
       "V8.InvalidateProtector";
   static constexpr char kInvalidateProtectorTracingArg[] = "protector-name";
 
-  DCHECK(FLAG_trace_protector_invalidation);
+  DCHECK(v8_flags.trace_protector_invalidation);
 
   // TODO(jgruber): Remove the PrintF once tracing can output to stdout.
   i::PrintF("Invalidating protector cell %s\n", protector_name);
@@ -49,7 +49,7 @@ DECLARED_PROTECTORS_ON_ISOLATE(V)
   void Protectors::Invalidate##name(Isolate* isolate) {                      \
     DCHECK(isolate->factory()->cell()->value().IsSmi());                     \
     DCHECK(Is##name##Intact(isolate));                                       \
-    if (FLAG_trace_protector_invalidation) {                                 \
+    if (v8_flags.trace_protector_invalidation) {                             \
       TraceProtectorInvalidation(#name);                                     \
     }                                                                        \
     isolate->CountUsage(v8::Isolate::kInvalidated##name##Protector);         \
diff --git a/src/execution/riscv/simulator-riscv.cc b/src/execution/riscv/simulator-riscv.cc
index 275356a0e6f..c97f77cc52c 100644
--- a/src/execution/riscv/simulator-riscv.cc
+++ b/src/execution/riscv/simulator-riscv.cc
@@ -1182,7 +1182,7 @@ struct type_sew_t<128> {
     }                                                                          \
   }                                                                            \
   set_rvv_vstart(0);                                                           \
-  if (::v8::internal::FLAG_trace_sim) {                                        \
+  if (v8_flags.trace_sim) {                                                    \
     __int128_t value = Vregister_[rvv_vd_reg()];                               \
     SNPrintF(trace_buf_,                                                       \
              "%016" REGIx_FORMAT "%016" REGIx_FORMAT                           \
@@ -1208,7 +1208,7 @@ struct type_sew_t<128> {
     }                                                                          \
   }                                                                            \
   set_rvv_vstart(0);                                                           \
-  if (::v8::internal::FLAG_trace_sim) {                                        \
+  if (v8_flags.trace_sim) {                                                    \
     __int128_t value = Vregister_[rvv_vd_reg()];                               \
     SNPrintF(trace_buf_,                                                       \
              "%016" REGIx_FORMAT "%016" REGIx_FORMAT                           \
@@ -1943,7 +1943,7 @@ void RiscvDebugger::Debug() {
         PrintF("regaining control from gdb\n");
       } else if (strcmp(cmd, "trace") == 0) {
         PrintF("enable trace sim\n");
-        FLAG_trace_sim = true;
+        v8_flags.trace_sim = true;
       } else if (strcmp(cmd, "break") == 0 || strcmp(cmd, "b") == 0 ||
                  strcmp(cmd, "tbreak") == 0) {
         bool is_tbreak = strcmp(cmd, "tbreak") == 0;
@@ -2267,7 +2267,7 @@ void Simulator::CheckICache(base::CustomMatcherHashMap* i_cache,
 Simulator::Simulator(Isolate* isolate) : isolate_(isolate), builtins_(isolate) {
   // Set up simulator support first. Some of this information is needed to
   // setup the architecture state.
-  stack_size_ = FLAG_sim_stack_size * KB;
+  stack_size_ = v8_flags.sim_stack_size * KB;
   stack_ = reinterpret_cast<char*>(malloc(stack_size_));
   pc_modified_ = false;
   icount_ = 0;
@@ -2605,7 +2605,7 @@ sreg_t Simulator::get_pc() const { return registers_[pc]; }
 
 // TODO(plind): refactor this messy debug code when we do unaligned access.
 void Simulator::DieOrDebug() {
-  if (FLAG_riscv_trap_to_simulator_debugger) {
+  if (v8_flags.riscv_trap_to_simulator_debugger) {
     RiscvDebugger dbg(this);
     dbg.Debug();
   } else {
@@ -2615,7 +2615,7 @@ void Simulator::DieOrDebug() {
 
 #if V8_TARGET_ARCH_RISCV64
 void Simulator::TraceRegWr(int64_t value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int64_t fmt_int64;
       int32_t fmt_int32[2];
@@ -2654,7 +2654,7 @@ void Simulator::TraceRegWr(int64_t value, TraceType t) {
 #elif V8_TARGET_ARCH_32_BIT
 template <typename T>
 void Simulator::TraceRegWr(T value, TraceType t) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     union {
       int32_t fmt_int32;
       float fmt_float;
@@ -2691,7 +2691,7 @@ void Simulator::TraceRegWr(T value, TraceType t) {
 // TODO(plind): consider making icount_ printing a flag option.
 template <typename T>
 void Simulator::TraceMemRd(sreg_t addr, T value, sreg_t reg_value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     if (std::is_integral<T>::value) {
       switch (sizeof(T)) {
         case 1:
@@ -2742,7 +2742,7 @@ void Simulator::TraceMemRd(sreg_t addr, T value, sreg_t reg_value) {
 }
 
 void Simulator::TraceMemRdFloat(sreg_t addr, Float32 value, int64_t reg_value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     SNPrintF(trace_buf_,
              "%016" PRIx64 "    (%" PRId64
              ")    flt:%e <-- [addr: %" REGIx_FORMAT "]",
@@ -2751,7 +2751,7 @@ void Simulator::TraceMemRdFloat(sreg_t addr, Float32 value, int64_t reg_value) {
 }
 
 void Simulator::TraceMemRdDouble(sreg_t addr, double value, int64_t reg_value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     SNPrintF(trace_buf_,
              "%016" PRIx64 "    (%" PRId64
              ")    dbl:%e <-- [addr: %" REGIx_FORMAT "]",
@@ -2761,7 +2761,7 @@ void Simulator::TraceMemRdDouble(sreg_t addr, double value, int64_t reg_value) {
 
 void Simulator::TraceMemRdDouble(sreg_t addr, Float64 value,
                                  int64_t reg_value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     SNPrintF(trace_buf_,
              "%016" PRIx64 "    (%" PRId64
              ")    dbl:%e <-- [addr: %" REGIx_FORMAT "]",
@@ -2771,7 +2771,7 @@ void Simulator::TraceMemRdDouble(sreg_t addr, Float64 value,
 
 template <typename T>
 void Simulator::TraceMemWr(sreg_t addr, T value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     switch (sizeof(T)) {
       case 1:
         SNPrintF(trace_buf_,
@@ -2822,7 +2822,7 @@ void Simulator::TraceMemWr(sreg_t addr, T value) {
 }
 
 void Simulator::TraceMemWrDouble(sreg_t addr, double value) {
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     SNPrintF(trace_buf_,
              "                    (%" PRIu64
              ")    dbl:%e --> [addr: %" REGIx_FORMAT "]",
@@ -2845,7 +2845,7 @@ T Simulator::ReadMem(sreg_t addr, Instruction* instr) {
   }
 #if !defined(V8_COMPRESS_POINTERS) && defined(RISCV_HAS_NO_UNALIGNED)
   // check for natural alignment
-  if (!FLAG_riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
+  if (!v8_flags.riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
     PrintF("Unaligned read at 0x%08" REGIx_FORMAT " , pc=0x%08" V8PRIxPTR "\n",
            addr, reinterpret_cast<intptr_t>(instr));
     DieOrDebug();
@@ -2867,7 +2867,7 @@ void Simulator::WriteMem(sreg_t addr, T value, Instruction* instr) {
   }
 #if !defined(V8_COMPRESS_POINTERS) && defined(RISCV_HAS_NO_UNALIGNED)
   // check for natural alignment
-  if (!FLAG_riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
+  if (!v8_flags.riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
     PrintF("Unaligned write at 0x%08" REGIx_FORMAT " , pc=0x%08" V8PRIxPTR "\n",
            addr, reinterpret_cast<intptr_t>(instr));
     DieOrDebug();
@@ -2893,7 +2893,7 @@ void Simulator::WriteMem(sreg_t addr, Float32 value, Instruction* instr) {
   }
 #if !defined(V8_COMPRESS_POINTERS) && defined(RISCV_HAS_NO_UNALIGNED)
   // check for natural alignment
-  if (!FLAG_riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
+  if (!v8_flags.riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
     PrintF("Unaligned write at 0x%08" REGIx_FORMAT " , pc=0x%08" V8PRIxPTR "\n",
            addr, reinterpret_cast<intptr_t>(instr));
     DieOrDebug();
@@ -2915,7 +2915,7 @@ void Simulator::WriteMem(sreg_t addr, Float64 value, Instruction* instr) {
   }
 #if !defined(V8_COMPRESS_POINTERS) && defined(RISCV_HAS_NO_UNALIGNED)
   // check for natural alignment
-  if (!FLAG_riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
+  if (!v8_flags.riscv_c_extension && ((addr & (sizeof(T) - 1)) != 0)) {
     PrintF("Unaligned write at 0x%08" REGIx_FORMAT " , pc=0x%08" V8PRIxPTR "\n",
            addr, reinterpret_cast<intptr_t>(instr));
     DieOrDebug();
@@ -3036,7 +3036,7 @@ void Simulator::SoftwareInterrupt() {
       GetFpArgs(&dval0, &dval1, &ival);
       SimulatorRuntimeCall generic_target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_FP_FP_CALL:
           case ExternalReference::BUILTIN_COMPARE_CALL:
@@ -3094,7 +3094,7 @@ void Simulator::SoftwareInterrupt() {
         default:
           UNREACHABLE();
       }
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         switch (redirection->type()) {
           case ExternalReference::BUILTIN_COMPARE_CALL:
             PrintF("Returned %08x\n", static_cast<int32_t>(iresult));
@@ -3109,7 +3109,7 @@ void Simulator::SoftwareInterrupt() {
         }
       }
     } else if (redirection->type() == ExternalReference::DIRECT_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function %s at %p args %08" REGIx_FORMAT " \n",
                ExternalReferenceTable::NameOfIsolateIndependentAddress(pc),
                reinterpret_cast<void*>(external), arg0);
@@ -3118,7 +3118,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeDirectApiCall>(external);
       target(arg0);
     } else if (redirection->type() == ExternalReference::PROFILING_API_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function %s at %p args %08" REGIx_FORMAT
                "  %08" REGIx_FORMAT " \n",
                ExternalReferenceTable::NameOfIsolateIndependentAddress(pc),
@@ -3128,7 +3128,7 @@ void Simulator::SoftwareInterrupt() {
           reinterpret_cast<SimulatorRuntimeProfilingApiCall>(external);
       target(arg0, Redirection::UnwrapRedirection(arg1));
     } else if (redirection->type() == ExternalReference::DIRECT_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function %s at %p args %08" REGIx_FORMAT
                "  %08" REGIx_FORMAT " \n",
                ExternalReferenceTable::NameOfIsolateIndependentAddress(pc),
@@ -3139,7 +3139,7 @@ void Simulator::SoftwareInterrupt() {
       target(arg0, arg1);
     } else if (redirection->type() ==
                ExternalReference::PROFILING_GETTER_CALL) {
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF("Call to host function %s at %p args %08" REGIx_FORMAT
                "  %08" REGIx_FORMAT "  %08" REGIx_FORMAT " \n",
                ExternalReferenceTable::NameOfIsolateIndependentAddress(pc),
@@ -3165,7 +3165,7 @@ void Simulator::SoftwareInterrupt() {
           redirection->type() == ExternalReference::FAST_C_CALL);
       SimulatorRuntimeCall target =
           reinterpret_cast<SimulatorRuntimeCall>(external);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         PrintF(
             "Call to host function %s at %p "
             "args %08" REGIx_FORMAT " , %08" REGIx_FORMAT " , %08" REGIx_FORMAT
@@ -3195,7 +3195,7 @@ void Simulator::SoftwareInterrupt() {
       set_register(a1, (sreg_t)(result >> 32));
 #endif
     }
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("Returned %08" REGIx_FORMAT "  : %08" REGIx_FORMAT " \n",
              get_register(a1), get_register(a0));
     }
@@ -4675,7 +4675,7 @@ void Simulator::DecodeRVIType() {
       // Note: No need to shift 2 for JALR's imm12, but set lowest bit to 0.
       sreg_t next_pc = (rs1() + imm12()) & ~sreg_t(1);
       set_pc(next_pc);
-      if (::v8::internal::FLAG_trace_sim) {
+      if (v8_flags.trace_sim) {
         Builtin builtin = LookUp((Address)get_pc());
         if (builtin != Builtin::kNoBuiltinId) {
           auto code = builtins_.code(builtin);
@@ -7178,14 +7178,14 @@ void Simulator::DecodeVType() {
 
 // Executes the current instruction.
 void Simulator::InstructionDecode(Instruction* instr) {
-  if (v8::internal::FLAG_check_icache) {
+  if (v8_flags.check_icache) {
     CheckICache(i_cache(), instr);
   }
   pc_modified_ = false;
 
   v8::base::EmbeddedVector<char, 256> buffer;
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     SNPrintF(trace_buf_, " ");
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
@@ -7260,7 +7260,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
       UNSUPPORTED();
   }
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     PrintF("  0x%012" PRIxPTR "      %-44s\t%s\n",
            reinterpret_cast<intptr_t>(instr), buffer.begin(),
            trace_buf_.begin());
@@ -7303,7 +7303,7 @@ void Simulator::Execute() {
   while (program_counter != end_sim_pc) {
     Instruction* instr = reinterpret_cast<Instruction*>(program_counter);
     icount_++;
-    if (icount_ == static_cast<sreg_t>(::v8::internal::FLAG_stop_sim_at)) {
+    if (icount_ == static_cast<sreg_t>(v8_flags.stop_sim_at)) {
       RiscvDebugger dbg(this);
       dbg.Debug();
     } else {
@@ -7410,7 +7410,7 @@ intptr_t Simulator::CallImpl(Address entry, int argument_count,
   if (reg_arg_count > 6) set_register(a6, arguments[6]);
   if (reg_arg_count > 7) set_register(a7, arguments[7]);
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     std::cout << "CallImpl: reg_arg_count = " << reg_arg_count << std::hex
               << " entry-pc (JSEntry) = 0x" << entry
               << " a0 (Isolate-root) = 0x" << get_register(a0)
diff --git a/src/execution/riscv/simulator-riscv.h b/src/execution/riscv/simulator-riscv.h
index 8119340f6bd..f3b022b36f7 100644
--- a/src/execution/riscv/simulator-riscv.h
+++ b/src/execution/riscv/simulator-riscv.h
@@ -794,7 +794,7 @@ class Simulator : public SimulatorBase {
 
 #ifdef CAN_USE_RVV_INSTRUCTIONS
   inline void rvv_trace_vd() {
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       __int128_t value = Vregister_[rvv_vd_reg()];
       SNPrintF(trace_buf_, "%016" PRIx64 "%016" PRIx64 " (%" PRId64 ")",
                *(reinterpret_cast<int64_t*>(&value) + 1),
@@ -803,7 +803,7 @@ class Simulator : public SimulatorBase {
   }
 
   inline void rvv_trace_vs1() {
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("\t%s:0x%016" PRIx64 "%016" PRIx64 "\n",
              v8::internal::VRegisters::Name(static_cast<int>(rvv_vs1_reg())),
              (uint64_t)(get_vregister(static_cast<int>(rvv_vs1_reg())) >> 64),
@@ -812,7 +812,7 @@ class Simulator : public SimulatorBase {
   }
 
   inline void rvv_trace_vs2() {
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("\t%s:0x%016" PRIx64 "%016" PRIx64 "\n",
              v8::internal::VRegisters::Name(static_cast<int>(rvv_vs2_reg())),
              (uint64_t)(get_vregister(static_cast<int>(rvv_vs2_reg())) >> 64),
@@ -820,7 +820,7 @@ class Simulator : public SimulatorBase {
     }
   }
   inline void rvv_trace_v0() {
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("\t%s:0x%016" PRIx64 "%016" PRIx64 "\n",
              v8::internal::VRegisters::Name(v0),
              (uint64_t)(get_vregister(v0) >> 64), (uint64_t)get_vregister(v0));
@@ -828,7 +828,7 @@ class Simulator : public SimulatorBase {
   }
 
   inline void rvv_trace_rs1() {
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       PrintF("\t%s:0x%016" PRIx64 "\n",
              v8::internal::Registers::Name(static_cast<int>(rs1_reg())),
              (uint64_t)(get_register(rs1_reg())));
@@ -836,7 +836,7 @@ class Simulator : public SimulatorBase {
   }
 
   inline void rvv_trace_status() {
-    if (::v8::internal::FLAG_trace_sim) {
+    if (v8_flags.trace_sim) {
       int i = 0;
       for (; i < trace_buf_.length(); i++) {
         if (trace_buf_[i] == '\0') break;
diff --git a/src/execution/s390/simulator-s390.cc b/src/execution/s390/simulator-s390.cc
index 71d63b1b922..66fe039cb3e 100644
--- a/src/execution/s390/simulator-s390.cc
+++ b/src/execution/s390/simulator-s390.cc
@@ -188,8 +188,8 @@ void S390Debugger::Debug() {
   // to all commands.
   UndoBreakpoint();
   // Disable tracing while simulating
-  bool trace = ::v8::internal::FLAG_trace_sim;
-  ::v8::internal::FLAG_trace_sim = false;
+  bool trace = v8_flags.trace_sim;
+  v8_flags.trace_sim = false;
 
   while (!done && !sim_->has_bad_pc()) {
     if (last_pc != sim_->get_pc()) {
@@ -558,9 +558,9 @@ void S390Debugger::Debug() {
       } else if (strcmp(cmd, "icount") == 0) {
         PrintF("%05" PRId64 "\n", sim_->icount_);
       } else if ((strcmp(cmd, "t") == 0) || strcmp(cmd, "trace") == 0) {
-        ::v8::internal::FLAG_trace_sim = !::v8::internal::FLAG_trace_sim;
+        v8_flags.trace_sim = !v8_flags.trace_sim;
         PrintF("Trace of executed instructions is %s\n",
-               ::v8::internal::FLAG_trace_sim ? "on" : "off");
+               v8_flags.trace_sim ? "on" : "off");
       } else if ((strcmp(cmd, "h") == 0) || (strcmp(cmd, "help") == 0)) {
         PrintF("cont\n");
         PrintF("  continue execution (alias 'c')\n");
@@ -633,7 +633,7 @@ void S390Debugger::Debug() {
   // hit.
   RedoBreakpoint();
   // Restore tracing
-  ::v8::internal::FLAG_trace_sim = trace;
+  v8_flags.trace_sim = trace;
 
 #undef COMMAND_SIZE
 #undef ARG_SIZE
@@ -1573,7 +1573,7 @@ Simulator::Simulator(Isolate* isolate) : isolate_(isolate) {
 // Set up simulator support first. Some of this information is needed to
 // setup the architecture state.
 #if V8_TARGET_ARCH_S390X
-  size_t stack_size = FLAG_sim_stack_size * KB;
+  size_t stack_size = v8_flags.sim_stack_size * KB;
 #else
   size_t stack_size = MB;  // allocate 1MB for stack
 #endif
@@ -1974,8 +1974,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       // Check if stack is aligned. Error if not aligned is reported below to
       // include information on the function called.
       bool stack_aligned =
-          (get_register(sp) & (::v8::internal::FLAG_sim_stack_alignment - 1)) ==
-          0;
+          (get_register(sp) & (v8_flags.sim_stack_alignment - 1)) == 0;
       Redirection* redirection = Redirection::FromInstruction(instr);
       const int kArgCount = 20;
       const int kRegisterArgCount = 5;
@@ -2021,7 +2020,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         int iresult = 0;      // integer return value
         double dresult = 0;   // double return value
         GetFpArgs(&dval0, &dval1, &ival);
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           SimulatorRuntimeCall generic_target =
               reinterpret_cast<SimulatorRuntimeCall>(external);
           switch (redirection->type()) {
@@ -2083,7 +2082,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
           default:
             UNREACHABLE();
         }
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           switch (redirection->type()) {
             case ExternalReference::BUILTIN_COMPARE_CALL:
               PrintF("Returned %08x\n", iresult);
@@ -2100,7 +2099,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       } else if (redirection->type() == ExternalReference::DIRECT_API_CALL) {
         // See callers of MacroAssembler::CallApiFunctionAndReturn for
         // explanation of register usage.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0]);
           if (!stack_aligned) {
@@ -2116,7 +2115,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       } else if (redirection->type() == ExternalReference::PROFILING_API_CALL) {
         // See callers of MacroAssembler::CallApiFunctionAndReturn for
         // explanation of register usage.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR
                  " %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0], arg[1]);
@@ -2133,7 +2132,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
       } else if (redirection->type() == ExternalReference::DIRECT_GETTER_CALL) {
         // See callers of MacroAssembler::CallApiFunctionAndReturn for
         // explanation of register usage.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR
                  " %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0], arg[1]);
@@ -2152,7 +2151,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         target(arg[0], arg[1]);
       } else if (redirection->type() ==
                  ExternalReference::PROFILING_GETTER_CALL) {
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           PrintF("Call to host function at %p args %08" V8PRIxPTR
                  " %08" V8PRIxPTR " %08" V8PRIxPTR,
                  reinterpret_cast<void*>(external), arg[0], arg[1], arg[2]);
@@ -2171,7 +2170,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         target(arg[0], arg[1], Redirection::UnwrapRedirection(arg[2]));
       } else {
         // builtin call.
-        if (::v8::internal::FLAG_trace_sim || !stack_aligned) {
+        if (v8_flags.trace_sim || !stack_aligned) {
           SimulatorRuntimeCall target =
               reinterpret_cast<SimulatorRuntimeCall>(external);
           PrintF(
@@ -2204,7 +2203,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
           intptr_t x;
           intptr_t y;
           decodeObjectPair(&result, &x, &y);
-          if (::v8::internal::FLAG_trace_sim) {
+          if (v8_flags.trace_sim) {
             PrintF("Returned {%08" V8PRIxPTR ", %08" V8PRIxPTR "}\n", x, y);
           }
           if (ABI_RETURNS_OBJECTPAIR_IN_REGS) {
@@ -2234,7 +2233,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
               target(arg[0], arg[1], arg[2], arg[3], arg[4], arg[5], arg[6],
                      arg[7], arg[8], arg[9], arg[10], arg[11], arg[12], arg[13],
                      arg[14], arg[15], arg[16], arg[17], arg[18], arg[19]);
-          if (::v8::internal::FLAG_trace_sim) {
+          if (v8_flags.trace_sim) {
             PrintF("Returned %08" V8PRIxPTR "\n", result);
           }
           set_register(r2, result);
@@ -2250,13 +2249,13 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         //         int32_t lo_res = static_cast<int32_t>(result);
         //         int32_t hi_res = static_cast<int32_t>(result >> 32);
         // #if !V8_TARGET_LITTLE_ENDIAN
-        //         if (::v8::internal::FLAG_trace_sim) {
+        //         if (v8_flags.trace_sim) {
         //           PrintF("Returned %08x\n", hi_res);
         //         }
         //         set_register(r2, hi_res);
         //         set_register(r3, lo_res);
         // #else
-        //         if (::v8::internal::FLAG_trace_sim) {
+        //         if (v8_flags.trace_sim) {
         //           PrintF("Returned %08x\n", lo_res);
         //         }
         //         set_register(r2, lo_res);
@@ -2269,7 +2268,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         //           intptr_t result = target(arg[0], arg[1], arg[2], arg[3],
         //           arg[4],
         //               arg[5]);
-        //           if (::v8::internal::FLAG_trace_sim) {
+        //           if (v8_flags.trace_sim) {
         //             PrintF("Returned %08" V8PRIxPTR "\n", result);
         //           }
         //           set_register(r2, result);
@@ -2280,7 +2279,7 @@ void Simulator::SoftwareInterrupt(Instruction* instr) {
         //             reinterpret_cast<SimulatorRuntimePairCall>(external);
         //           ObjectPair result = target(arg[0], arg[1], arg[2], arg[3],
         //               arg[4], arg[5]);
-        //           if (::v8::internal::FLAG_trace_sim) {
+        //           if (v8_flags.trace_sim) {
         //             PrintF("Returned %08" V8PRIxPTR ", %08" V8PRIxPTR "\n",
         //                 result.x, result.y);
         //           }
@@ -2440,13 +2439,13 @@ int Simulator::DecodeInstruction(Instruction* instr) {
 void Simulator::ExecuteInstruction(Instruction* instr, bool auto_incr_pc) {
   icount_++;
 
-  if (v8::internal::FLAG_check_icache) {
+  if (v8_flags.check_icache) {
     CheckICache(i_cache(), instr);
   }
 
   pc_modified_ = false;
 
-  if (::v8::internal::FLAG_trace_sim) {
+  if (v8_flags.trace_sim) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // use a reasonably large buffer
@@ -2480,7 +2479,7 @@ void Simulator::Execute() {
   // raw PC value and not the one used as input to arithmetic instructions.
   intptr_t program_counter = get_pc();
 
-  if (::v8::internal::FLAG_stop_sim_at == 0) {
+  if (v8_flags.stop_sim_at == 0) {
     // Fast version of the dispatch loop without checking whether the simulator
     // should be stopping at a particular executed instruction.
     while (program_counter != end_sim_pc) {
@@ -2489,11 +2488,11 @@ void Simulator::Execute() {
       program_counter = get_pc();
     }
   } else {
-    // FLAG_stop_sim_at is at the non-default value. Stop in the debugger when
-    // we reach the particular instruction count.
+    // v8_flags.stop_sim_at is at the non-default value. Stop in the debugger
+    // when we reach the particular instruction count.
     while (program_counter != end_sim_pc) {
       Instruction* instr = reinterpret_cast<Instruction*>(program_counter);
-      if (icount_ == ::v8::internal::FLAG_stop_sim_at) {
+      if (icount_ == v8_flags.stop_sim_at) {
         S390Debugger dbg(this);
         dbg.Debug();
       } else {
diff --git a/src/execution/stack-guard.cc b/src/execution/stack-guard.cc
index 31d9b52c82b..2b4af70bc0a 100644
--- a/src/execution/stack-guard.cc
+++ b/src/execution/stack-guard.cc
@@ -217,7 +217,7 @@ void StackGuard::FreeThreadResources() {
 
 void StackGuard::ThreadLocal::Initialize(Isolate* isolate,
                                          const ExecutionAccess& lock) {
-  const uintptr_t kLimitSize = FLAG_stack_size * KB;
+  const uintptr_t kLimitSize = v8_flags.stack_size * KB;
   DCHECK_GT(GetCurrentStackPosition(), kLimitSize);
   uintptr_t limit = GetCurrentStackPosition() - kLimitSize;
   real_jslimit_ = SimulatorStack::JsLimitFromCLimit(isolate, limit);
@@ -271,7 +271,7 @@ Object StackGuard::HandleInterrupts() {
   isolate_->heap()->VerifyNewSpaceTop();
 #endif
 
-  if (FLAG_verify_predictable) {
+  if (v8_flags.verify_predictable) {
     // Advance synthetic time by making a time request.
     isolate_->heap()->MonotonicallyIncreasingTimeInMs();
   }
diff --git a/src/execution/tiering-manager.cc b/src/execution/tiering-manager.cc
index 0dc112c0289..7ca72b7b2be 100644
--- a/src/execution/tiering-manager.cc
+++ b/src/execution/tiering-manager.cc
@@ -95,14 +95,14 @@ static_assert(sizeof(OptimizationDecision) <= kInt32Size);
 namespace {
 
 void TraceInOptimizationQueue(JSFunction function) {
-  if (FLAG_trace_opt_verbose) {
+  if (v8_flags.trace_opt_verbose) {
     PrintF("[not marking function %s for optimization: already queued]\n",
            function.DebugNameCStr().get());
   }
 }
 
 void TraceHeuristicOptimizationDisallowed(JSFunction function) {
-  if (FLAG_trace_opt_verbose) {
+  if (v8_flags.trace_opt_verbose) {
     PrintF(
         "[not marking function %s for optimization: marked with "
         "%%PrepareFunctionForOptimization for manual optimization]\n",
@@ -112,7 +112,7 @@ void TraceHeuristicOptimizationDisallowed(JSFunction function) {
 
 void TraceRecompile(Isolate* isolate, JSFunction function,
                     OptimizationDecision d) {
-  if (FLAG_trace_opt) {
+  if (v8_flags.trace_opt) {
     CodeTracer::Scope scope(isolate->GetCodeTracer());
     PrintF(scope.file(), "[marking ");
     function.ShortPrint(scope.file());
@@ -127,7 +127,7 @@ void TraceRecompile(Isolate* isolate, JSFunction function,
 
 void TraceManualRecompile(JSFunction function, CodeKind code_kind,
                           ConcurrencyMode concurrency_mode) {
-  if (FLAG_trace_opt) {
+  if (v8_flags.trace_opt) {
     PrintF("[manually marking ");
     function.ShortPrint();
     PrintF(" for optimization to %s, %s]\n", CodeKindToString(code_kind),
@@ -145,7 +145,8 @@ namespace {
 
 bool TiersUpToMaglev(CodeKind code_kind) {
   // TODO(v8:7700): Flip the UNLIKELY when appropriate.
-  return V8_UNLIKELY(FLAG_maglev) && CodeKindIsUnoptimizedJSFunction(code_kind);
+  return V8_UNLIKELY(v8_flags.maglev) &&
+         CodeKindIsUnoptimizedJSFunction(code_kind);
 }
 
 bool TiersUpToMaglev(base::Optional<CodeKind> code_kind) {
@@ -153,8 +154,8 @@ bool TiersUpToMaglev(base::Optional<CodeKind> code_kind) {
 }
 
 int InterruptBudgetFor(base::Optional<CodeKind> code_kind) {
-  return TiersUpToMaglev(code_kind) ? FLAG_interrupt_budget_for_maglev
-                                    : FLAG_interrupt_budget;
+  return TiersUpToMaglev(code_kind) ? v8_flags.interrupt_budget_for_maglev
+                                    : v8_flags.interrupt_budget;
 }
 
 }  // namespace
@@ -168,14 +169,14 @@ int TieringManager::InterruptBudgetFor(Isolate* isolate, JSFunction function) {
   DCHECK(!function.has_feedback_vector());
   DCHECK(function.shared().is_compiled());
   return function.shared().GetBytecodeArray(isolate).length() *
-         FLAG_interrupt_budget_factor_for_feedback_allocation;
+         v8_flags.interrupt_budget_factor_for_feedback_allocation;
 }
 
 // static
 int TieringManager::InitialInterruptBudget() {
-  return V8_LIKELY(FLAG_lazy_feedback_allocation)
-             ? FLAG_interrupt_budget_for_feedback_allocation
-             : FLAG_interrupt_budget;
+  return V8_LIKELY(v8_flags.lazy_feedback_allocation)
+             ? v8_flags.interrupt_budget_for_feedback_allocation
+             : v8_flags.interrupt_budget;
 }
 
 namespace {
@@ -201,7 +202,7 @@ bool SmallEnoughForOSR(Isolate* isolate, JSFunction function,
   static const int kOSRBytecodeSizeAllowancePerTick = 44;
   const double scale_factor_for_active_tier =
       InterruptBudgetFor(code_kind) /
-      static_cast<double>(FLAG_interrupt_budget);
+      static_cast<double>(v8_flags.interrupt_budget);
 
   const double raw_limit = kOSRBytecodeSizeAllowanceBase +
                            scale_factor_for_active_tier *
@@ -219,13 +220,13 @@ void TrySetOsrUrgency(Isolate* isolate, JSFunction function, int osr_urgency) {
   // Guaranteed since we've got a feedback vector.
   DCHECK(shared.IsUserJavaScript());
 
-  if (V8_UNLIKELY(!FLAG_use_osr)) return;
+  if (V8_UNLIKELY(!v8_flags.use_osr)) return;
   if (V8_UNLIKELY(shared.optimization_disabled())) return;
 
   // We've passed all checks - bump the OSR urgency.
 
   FeedbackVector fv = function.feedback_vector();
-  if (V8_UNLIKELY(FLAG_trace_osr)) {
+  if (V8_UNLIKELY(v8_flags.trace_osr)) {
     CodeTracer::Scope scope(isolate->GetCodeTracer());
     PrintF(scope.file(),
            "[OSR - setting osr urgency. function: %s, old urgency: %d, new "
@@ -249,7 +250,7 @@ void TryRequestOsrAtNextOpportunity(Isolate* isolate, JSFunction function) {
 
 bool ShouldOptimizeAsSmallFunction(int bytecode_size, bool any_ic_changed) {
   return !any_ic_changed &&
-         bytecode_size < FLAG_max_bytecode_size_for_early_opt;
+         bytecode_size < v8_flags.max_bytecode_size_for_early_opt;
 }
 
 }  // namespace
@@ -272,7 +273,7 @@ void TieringManager::MaybeOptimizeFrame(JSFunction function,
     return;
   }
 
-  if (V8_UNLIKELY(FLAG_testing_d8_test_runner) &&
+  if (V8_UNLIKELY(v8_flags.testing_d8_test_runner) &&
       !PendingOptimizationTable::IsHeuristicOptimizationAllowed(isolate_,
                                                                 function)) {
     TraceHeuristicOptimizationDisallowed(function);
@@ -282,7 +283,7 @@ void TieringManager::MaybeOptimizeFrame(JSFunction function,
   // TODO(v8:7700): Consider splitting this up for Maglev/Turbofan.
   if (V8_UNLIKELY(function.shared().optimization_disabled())) return;
 
-  if (V8_UNLIKELY(FLAG_always_osr)) {
+  if (V8_UNLIKELY(v8_flags.always_osr)) {
     TryRequestOsrAtNextOpportunity(isolate_, function);
     // Continue below and do a normal optimized compile as well.
   }
@@ -325,7 +326,7 @@ OptimizationDecision TieringManager::ShouldOptimize(JSFunction function,
   DCHECK_EQ(code_kind, function.GetActiveTier().value());
 
   if (TiersUpToMaglev(code_kind) &&
-      function.shared().PassesFilter(FLAG_maglev_filter) &&
+      function.shared().PassesFilter(v8_flags.maglev_filter) &&
       !function.shared(isolate_).maglev_compilation_failed()) {
     return OptimizationDecision::Maglev();
   } else if (code_kind == CodeKind::TURBOFAN) {
@@ -333,15 +334,16 @@ OptimizationDecision TieringManager::ShouldOptimize(JSFunction function,
     return OptimizationDecision::DoNotOptimize();
   }
 
-  if (!FLAG_turbofan || !function.shared().PassesFilter(FLAG_turbo_filter)) {
+  if (!v8_flags.turbofan ||
+      !function.shared().PassesFilter(v8_flags.turbo_filter)) {
     return OptimizationDecision::DoNotOptimize();
   }
 
   BytecodeArray bytecode = function.shared().GetBytecodeArray(isolate_);
   const int ticks = function.feedback_vector().profiler_ticks();
   const int ticks_for_optimization =
-      FLAG_ticks_before_optimization +
-      (bytecode.length() / FLAG_bytecode_size_allowance_per_tick);
+      v8_flags.ticks_before_optimization +
+      (bytecode.length() / v8_flags.bytecode_size_allowance_per_tick);
   if (ticks >= ticks_for_optimization) {
     return OptimizationDecision::TurbofanHotAndStable();
   } else if (ShouldOptimizeAsSmallFunction(bytecode.length(),
@@ -349,14 +351,15 @@ OptimizationDecision TieringManager::ShouldOptimize(JSFunction function,
     // If no IC was patched since the last tick and this function is very
     // small, optimistically optimize it now.
     return OptimizationDecision::TurbofanSmallFunction();
-  } else if (FLAG_trace_opt_verbose) {
+  } else if (v8_flags.trace_opt_verbose) {
     PrintF("[not yet optimizing %s, not enough ticks: %d/%d and ",
            function.DebugNameCStr().get(), ticks, ticks_for_optimization);
     if (any_ic_changed_) {
       PrintF("ICs changed]\n");
     } else {
       PrintF(" too large for small function optimization: %d/%d]\n",
-             bytecode.length(), FLAG_max_bytecode_size_for_early_opt.value());
+             bytecode.length(),
+             v8_flags.max_bytecode_size_for_early_opt.value());
     }
   }
 
@@ -412,7 +415,7 @@ void TieringManager::OnInterruptTick(Handle<JSFunction> function) {
   // tiering.
   if (CanCompileWithBaseline(isolate_, function->shared()) &&
       function->ActiveTierIsIgnition()) {
-    if (FLAG_baseline_batch_compilation) {
+    if (v8_flags.baseline_batch_compilation) {
       isolate_->baseline_batch_compiler()->EnqueueFunction(function);
     } else {
       IsCompiledScope is_compiled_scope(
-- 
2.35.1


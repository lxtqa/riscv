From 77d515484864984f721d6726610f314982ac44d2 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Mon, 21 Feb 2022 09:19:21 +0800
Subject: [PATCH] [riscv64] Move explicit specialization into .cc file

Building with Gcc-10 causes error "explicit specialization in non-namespace scope".
This change fixes it.

Bug: v8:12649

Change-Id: I36b2b042b336c2dfd32ba5541fdbbdb8dc8b4fd7
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3473997
Reviewed-by: ji qiu <qiuji@iscas.ac.cn>
Commit-Queue: ji qiu <qiuji@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#79185}
---
 src/execution/riscv64/simulator-riscv64.cc | 158 +++++++++++++++++++++
 src/execution/riscv64/simulator-riscv64.h  | 158 ---------------------
 2 files changed, 158 insertions(+), 158 deletions(-)

diff --git a/src/execution/riscv64/simulator-riscv64.cc b/src/execution/riscv64/simulator-riscv64.cc
index d5c8c30d87..50d7250f13 100644
--- a/src/execution/riscv64/simulator-riscv64.cc
+++ b/src/execution/riscv64/simulator-riscv64.cc
@@ -128,6 +128,164 @@ static inline bool is_overlapped_widen(const int astart, int asize,
 #define require_align(val, pos) CHECK_EQ(is_aligned(val, pos), true)
 #endif
 
+// RVV
+// The following code about RVV was based from:
+//   https://github.com/riscv/riscv-isa-sim
+// Copyright (c) 2010-2017, The Regents of the University of California
+// (Regents).  All Rights Reserved.
+
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. Neither the name of the Regents nor the
+//    names of its contributors may be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+
+// IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
+// SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
+// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
+// REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
+// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+// PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
+// HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
+// MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+template <uint64_t N>
+struct type_usew_t;
+template <>
+struct type_usew_t<8> {
+  using type = uint8_t;
+};
+
+template <>
+struct type_usew_t<16> {
+  using type = uint16_t;
+};
+
+template <>
+struct type_usew_t<32> {
+  using type = uint32_t;
+};
+
+template <>
+struct type_usew_t<64> {
+  using type = uint64_t;
+};
+
+template <>
+struct type_usew_t<128> {
+  using type = __uint128_t;
+};
+template <uint64_t N>
+struct type_sew_t;
+
+template <>
+struct type_sew_t<8> {
+  using type = int8_t;
+};
+
+template <>
+struct type_sew_t<16> {
+  using type = int16_t;
+};
+
+template <>
+struct type_sew_t<32> {
+  using type = int32_t;
+};
+
+template <>
+struct type_sew_t<64> {
+  using type = int64_t;
+};
+
+template <>
+struct type_sew_t<128> {
+  using type = __int128_t;
+};
+
+#define VV_PARAMS(x)                                                       \
+  type_sew_t<x>::type& vd =                                                \
+      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);                  \
+  type_sew_t<x>::type vs1 = Rvvelt<type_sew_t<x>::type>(rvv_vs1_reg(), i); \
+  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VV_UPARAMS(x)                                                        \
+  type_usew_t<x>::type& vd =                                                 \
+      Rvvelt<type_usew_t<x>::type>(rvv_vd_reg(), i, true);                   \
+  type_usew_t<x>::type vs1 = Rvvelt<type_usew_t<x>::type>(rvv_vs1_reg(), i); \
+  type_usew_t<x>::type vs2 = Rvvelt<type_usew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VX_PARAMS(x)                                                        \
+  type_sew_t<x>::type& vd =                                                 \
+      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);                   \
+  type_sew_t<x>::type rs1 = (type_sew_t<x>::type)(get_register(rs1_reg())); \
+  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VX_UPARAMS(x)                                                         \
+  type_usew_t<x>::type& vd =                                                  \
+      Rvvelt<type_usew_t<x>::type>(rvv_vd_reg(), i, true);                    \
+  type_usew_t<x>::type rs1 = (type_usew_t<x>::type)(get_register(rs1_reg())); \
+  type_usew_t<x>::type vs2 = Rvvelt<type_usew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VI_PARAMS(x)                                                    \
+  type_sew_t<x>::type& vd =                                             \
+      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);               \
+  type_sew_t<x>::type simm5 = (type_sew_t<x>::type)(instr_.RvvSimm5()); \
+  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VI_UPARAMS(x)                                                     \
+  type_usew_t<x>::type& vd =                                              \
+      Rvvelt<type_usew_t<x>::type>(rvv_vd_reg(), i, true);                \
+  type_usew_t<x>::type uimm5 = (type_usew_t<x>::type)(instr_.RvvUimm5()); \
+  type_usew_t<x>::type vs2 = Rvvelt<type_usew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VN_PARAMS(x)                                                    \
+  constexpr int half_x = x >> 1;                                        \
+  type_sew_t<half_x>::type& vd =                                        \
+      Rvvelt<type_sew_t<half_x>::type>(rvv_vd_reg(), i, true);          \
+  type_sew_t<x>::type uimm5 = (type_sew_t<x>::type)(instr_.RvvUimm5()); \
+  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VN_UPARAMS(x)                                                     \
+  constexpr int half_x = x >> 1;                                          \
+  type_usew_t<half_x>::type& vd =                                         \
+      Rvvelt<type_usew_t<half_x>::type>(rvv_vd_reg(), i, true);           \
+  type_usew_t<x>::type uimm5 = (type_usew_t<x>::type)(instr_.RvvUimm5()); \
+  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
+
+#define VXI_PARAMS(x)                                                       \
+  type_sew_t<x>::type& vd =                                                 \
+      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);                   \
+  type_sew_t<x>::type vs1 = Rvvelt<type_sew_t<x>::type>(rvv_vs1_reg(), i);  \
+  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);  \
+  type_sew_t<x>::type rs1 = (type_sew_t<x>::type)(get_register(rs1_reg())); \
+  type_sew_t<x>::type simm5 = (type_sew_t<x>::type)(instr_.RvvSimm5());
+
+#define VI_XI_SLIDEDOWN_PARAMS(x, off)                           \
+  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
+  auto vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i + off);
+
+#define VI_XI_SLIDEUP_PARAMS(x, offset)                          \
+  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
+  auto vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i - offset);
+
+/* Vector Integer Extension */
+#define VI_VIE_PARAMS(x, scale)                                  \
+  if ((x / scale) < 8) UNREACHABLE();                            \
+  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
+  auto vs2 = Rvvelt<type_sew_t<x / scale>::type>(rvv_vs2_reg(), i);
+
+#define VI_VIE_UPARAMS(x, scale)                                 \
+  if ((x / scale) < 8) UNREACHABLE();                            \
+  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
+  auto vs2 = Rvvelt<type_usew_t<x / scale>::type>(rvv_vs2_reg(), i);
+
 #define require_noover(astart, asize, bstart, bsize) \
   CHECK_EQ(!is_overlapped(astart, asize, bstart, bsize), true)
 #define require_noover_widen(astart, asize, bstart, bsize) \
diff --git a/src/execution/riscv64/simulator-riscv64.h b/src/execution/riscv64/simulator-riscv64.h
index 4d2cd460c4..bf1dda48e9 100644
--- a/src/execution/riscv64/simulator-riscv64.h
+++ b/src/execution/riscv64/simulator-riscv64.h
@@ -652,164 +652,6 @@ class Simulator : public SimulatorBase {
     }
   }
 
-  // RVV
-  // The following code about RVV was based from:
-  //   https://github.com/riscv/riscv-isa-sim
-  // Copyright (c) 2010-2017, The Regents of the University of California
-  // (Regents).  All Rights Reserved.
-
-  // Redistribution and use in source and binary forms, with or without
-  // modification, are permitted provided that the following conditions are met:
-  // 1. Redistributions of source code must retain the above copyright
-  //    notice, this list of conditions and the following disclaimer.
-  // 2. Redistributions in binary form must reproduce the above copyright
-  //    notice, this list of conditions and the following disclaimer in the
-  //    documentation and/or other materials provided with the distribution.
-  // 3. Neither the name of the Regents nor the
-  //    names of its contributors may be used to endorse or promote products
-  //    derived from this software without specific prior written permission.
-
-  // IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
-  // SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS,
-  // ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
-  // REGENTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-  // REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
-  // TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-  // PURPOSE. THE SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED
-  // HEREUNDER IS PROVIDED "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE
-  // MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
-  template <uint64_t N>
-  struct type_usew_t;
-  template <>
-  struct type_usew_t<8> {
-    using type = uint8_t;
-  };
-
-  template <>
-  struct type_usew_t<16> {
-    using type = uint16_t;
-  };
-
-  template <>
-  struct type_usew_t<32> {
-    using type = uint32_t;
-  };
-
-  template <>
-  struct type_usew_t<64> {
-    using type = uint64_t;
-  };
-
-  template <>
-  struct type_usew_t<128> {
-    using type = __uint128_t;
-  };
-  template <uint64_t N>
-  struct type_sew_t;
-
-  template <>
-  struct type_sew_t<8> {
-    using type = int8_t;
-  };
-
-  template <>
-  struct type_sew_t<16> {
-    using type = int16_t;
-  };
-
-  template <>
-  struct type_sew_t<32> {
-    using type = int32_t;
-  };
-
-  template <>
-  struct type_sew_t<64> {
-    using type = int64_t;
-  };
-
-  template <>
-  struct type_sew_t<128> {
-    using type = __int128_t;
-  };
-
-#define VV_PARAMS(x)                                                       \
-  type_sew_t<x>::type& vd =                                                \
-      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);                  \
-  type_sew_t<x>::type vs1 = Rvvelt<type_sew_t<x>::type>(rvv_vs1_reg(), i); \
-  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VV_UPARAMS(x)                                                        \
-  type_usew_t<x>::type& vd =                                                 \
-      Rvvelt<type_usew_t<x>::type>(rvv_vd_reg(), i, true);                   \
-  type_usew_t<x>::type vs1 = Rvvelt<type_usew_t<x>::type>(rvv_vs1_reg(), i); \
-  type_usew_t<x>::type vs2 = Rvvelt<type_usew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VX_PARAMS(x)                                                        \
-  type_sew_t<x>::type& vd =                                                 \
-      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);                   \
-  type_sew_t<x>::type rs1 = (type_sew_t<x>::type)(get_register(rs1_reg())); \
-  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VX_UPARAMS(x)                                                         \
-  type_usew_t<x>::type& vd =                                                  \
-      Rvvelt<type_usew_t<x>::type>(rvv_vd_reg(), i, true);                    \
-  type_usew_t<x>::type rs1 = (type_usew_t<x>::type)(get_register(rs1_reg())); \
-  type_usew_t<x>::type vs2 = Rvvelt<type_usew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VI_PARAMS(x)                                                    \
-  type_sew_t<x>::type& vd =                                             \
-      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);               \
-  type_sew_t<x>::type simm5 = (type_sew_t<x>::type)(instr_.RvvSimm5()); \
-  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VI_UPARAMS(x)                                                     \
-  type_usew_t<x>::type& vd =                                              \
-      Rvvelt<type_usew_t<x>::type>(rvv_vd_reg(), i, true);                \
-  type_usew_t<x>::type uimm5 = (type_usew_t<x>::type)(instr_.RvvUimm5()); \
-  type_usew_t<x>::type vs2 = Rvvelt<type_usew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VN_PARAMS(x)                                                    \
-  constexpr int half_x = x >> 1;                                        \
-  type_sew_t<half_x>::type& vd =                                        \
-      Rvvelt<type_sew_t<half_x>::type>(rvv_vd_reg(), i, true);          \
-  type_sew_t<x>::type uimm5 = (type_sew_t<x>::type)(instr_.RvvUimm5()); \
-  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VN_UPARAMS(x)                                                     \
-  constexpr int half_x = x >> 1;                                          \
-  type_usew_t<half_x>::type& vd =                                         \
-      Rvvelt<type_usew_t<half_x>::type>(rvv_vd_reg(), i, true);           \
-  type_usew_t<x>::type uimm5 = (type_usew_t<x>::type)(instr_.RvvUimm5()); \
-  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);
-
-#define VXI_PARAMS(x)                                                       \
-  type_sew_t<x>::type& vd =                                                 \
-      Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true);                   \
-  type_sew_t<x>::type vs1 = Rvvelt<type_sew_t<x>::type>(rvv_vs1_reg(), i);  \
-  type_sew_t<x>::type vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i);  \
-  type_sew_t<x>::type rs1 = (type_sew_t<x>::type)(get_register(rs1_reg())); \
-  type_sew_t<x>::type simm5 = (type_sew_t<x>::type)(instr_.RvvSimm5());
-
-#define VI_XI_SLIDEDOWN_PARAMS(x, off)                           \
-  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
-  auto vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i + off);
-
-#define VI_XI_SLIDEUP_PARAMS(x, offset)                          \
-  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
-  auto vs2 = Rvvelt<type_sew_t<x>::type>(rvv_vs2_reg(), i - offset);
-
-/* Vector Integer Extension */
-#define VI_VIE_PARAMS(x, scale)                                  \
-  if ((x / scale) < 8) UNREACHABLE();                            \
-  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
-  auto vs2 = Rvvelt<type_sew_t<x / scale>::type>(rvv_vs2_reg(), i);
-
-#define VI_VIE_UPARAMS(x, scale)                                 \
-  if ((x / scale) < 8) UNREACHABLE();                            \
-  auto& vd = Rvvelt<type_sew_t<x>::type>(rvv_vd_reg(), i, true); \
-  auto vs2 = Rvvelt<type_usew_t<x / scale>::type>(rvv_vs2_reg(), i);
-
   inline void rvv_trace_vd() {
     if (::v8::internal::FLAG_trace_sim) {
       __int128_t value = Vregister_[rvv_vd_reg()];
-- 
2.35.1


From d0ccddd0324aa9391e76b611481bdc47f0f073de Mon Sep 17 00:00:00 2001
From: neis <neis@chromium.org>
Date: Mon, 18 Apr 2016 07:13:04 -0700
Subject: [PATCH] First version of the new generators implementation.

Behind --ignition-generators. Does not yet support Turbofan.

TBR=bmeurer@chromium.org
BUG=v8:4907
LOG=n

Review URL: https://codereview.chromium.org/1884183002

Cr-Commit-Position: refs/heads/master@{#35584}
---
 src/arm/builtins-arm.cc                       |  94 ++-
 src/arm64/builtins-arm64.cc                   |  99 +--
 src/builtins.cc                               |   9 +-
 src/compiler.cc                               |  10 +-
 src/debug/mirrors.js                          |   4 +-
 src/flag-definitions.h                        |   2 +
 src/frames.cc                                 |  11 +-
 src/frames.h                                  |   3 +-
 src/ia32/builtins-ia32.cc                     |  92 ++-
 src/interpreter/bytecode-array-builder.cc     |   5 +
 src/interpreter/bytecode-array-builder.h      |   2 +
 src/interpreter/bytecode-generator.cc         | 118 +++-
 src/interpreter/bytecode-generator.h          |   4 +
 src/interpreter/bytecode-register-allocator.h |   2 +-
 src/isolate.cc                                |   2 +-
 src/mips/builtins-mips.cc                     |  94 ++-
 src/mips64/builtins-mips64.cc                 |  96 ++-
 src/objects-inl.h                             |   6 +-
 src/objects.h                                 |   4 +-
 src/runtime/runtime-generator.cc              |  66 ++
 src/runtime/runtime.h                         |   5 +-
 src/x64/builtins-x64.cc                       |  98 +--
 .../bytecode_expectations/Generators.golden   | 629 ++++++++++++++++++
 .../generate-bytecode-expectations.cc         |  10 +
 .../interpreter/test-bytecode-generator.cc    |  23 +
 test/cctest/interpreter/test-interpreter.cc   |  31 +
 test/mjsunit/harmony/generators.js            | 305 +++++++++
 27 files changed, 1590 insertions(+), 234 deletions(-)
 create mode 100644 test/cctest/interpreter/bytecode_expectations/Generators.golden

diff --git a/src/arm/builtins-arm.cc b/src/arm/builtins-arm.cc
index 1799090aa10..c6e9f445049 100644
--- a/src/arm/builtins-arm.cc
+++ b/src/arm/builtins-arm.cc
@@ -773,44 +773,70 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {
     __ bind(&done_loop);
   }
 
-  // Enter a new JavaScript frame, and initialize its slots as they were when
-  // the generator was suspended.
-  DCHECK(!FLAG_enable_embedded_constant_pool);
-  FrameScope scope(masm, StackFrame::MANUAL);
-  __ Push(lr, fp);
-  __ Move(fp, sp);
-  __ Push(cp, r4);
-
-  // Restore the operand stack.
-  __ ldr(r0, FieldMemOperand(r1, JSGeneratorObject::kOperandStackOffset));
-  __ ldr(r3, FieldMemOperand(r0, FixedArray::kLengthOffset));
-  __ add(r0, r0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
-  __ add(r3, r0, Operand(r3, LSL, kPointerSizeLog2 - 1));
+  // Dispatch on the kind of generator object.
+  Label old_generator;
+  __ ldr(r3, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));
+  __ ldr(r3, FieldMemOperand(r3, SharedFunctionInfo::kFunctionDataOffset));
+  __ CompareObjectType(r3, r3, r3, BYTECODE_ARRAY_TYPE);
+  __ b(ne, &old_generator);
+
+  // New-style (ignition/turbofan) generator object
   {
-    Label done_loop, loop;
-    __ bind(&loop);
-    __ cmp(r0, r3);
-    __ b(eq, &done_loop);
-    __ ldr(ip, MemOperand(r0, kPointerSize, PostIndex));
-    __ Push(ip);
-    __ b(&loop);
-    __ bind(&done_loop);
+    __ ldr(r0, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));
+    __ ldr(r0,
+         FieldMemOperand(r0, SharedFunctionInfo::kFormalParameterCountOffset));
+    __ SmiUntag(r0);
+    // We abuse new.target both to indicate that this is a resume call and to
+    // pass in the generator object.  In ordinary calls, new.target is always
+    // undefined because generator functions are non-constructable.
+    __ Move(r3, r1);
+    __ Move(r1, r4);
+    __ ldr(r5, FieldMemOperand(r1, JSFunction::kCodeEntryOffset));
+    __ Jump(r5);
   }
 
-  // Reset operand stack so we don't leak.
-  __ LoadRoot(ip, Heap::kEmptyFixedArrayRootIndex);
-  __ str(ip, FieldMemOperand(r1, JSGeneratorObject::kOperandStackOffset));
+  // Old-style (full-codegen) generator object
+  __ bind(&old_generator);
+  {
+    // Enter a new JavaScript frame, and initialize its slots as they were when
+    // the generator was suspended.
+    DCHECK(!FLAG_enable_embedded_constant_pool);
+    FrameScope scope(masm, StackFrame::MANUAL);
+    __ Push(lr, fp);
+    __ Move(fp, sp);
+    __ Push(cp, r4);
+
+    // Restore the operand stack.
+    __ ldr(r0, FieldMemOperand(r1, JSGeneratorObject::kOperandStackOffset));
+    __ ldr(r3, FieldMemOperand(r0, FixedArray::kLengthOffset));
+    __ add(r0, r0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
+    __ add(r3, r0, Operand(r3, LSL, kPointerSizeLog2 - 1));
+    {
+      Label done_loop, loop;
+      __ bind(&loop);
+      __ cmp(r0, r3);
+      __ b(eq, &done_loop);
+      __ ldr(ip, MemOperand(r0, kPointerSize, PostIndex));
+      __ Push(ip);
+      __ b(&loop);
+      __ bind(&done_loop);
+    }
 
-  // Resume the generator function at the continuation.
-  __ ldr(r3, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));
-  __ ldr(r3, FieldMemOperand(r3, SharedFunctionInfo::kCodeOffset));
-  __ add(r3, r3, Operand(Code::kHeaderSize - kHeapObjectTag));
-  __ ldr(r2, FieldMemOperand(r1, JSGeneratorObject::kContinuationOffset));
-  __ add(r3, r3, Operand(r2, ASR, 1));
-  __ mov(r2, Operand(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
-  __ str(r2, FieldMemOperand(r1, JSGeneratorObject::kContinuationOffset));
-  __ Move(r0, r1);  // Continuation expects generator object in r0.
-  __ Jump(r3);
+    // Reset operand stack so we don't leak.
+    __ LoadRoot(ip, Heap::kEmptyFixedArrayRootIndex);
+    __ str(ip, FieldMemOperand(r1, JSGeneratorObject::kOperandStackOffset));
+
+    // Resume the generator function at the continuation.
+    __ ldr(r3, FieldMemOperand(r4, JSFunction::kSharedFunctionInfoOffset));
+    __ ldr(r3, FieldMemOperand(r3, SharedFunctionInfo::kCodeOffset));
+    __ add(r3, r3, Operand(Code::kHeaderSize - kHeapObjectTag));
+    __ ldr(r2, FieldMemOperand(r1, JSGeneratorObject::kContinuationOffset));
+    __ add(r3, r3, Operand(r2, ASR, 1));
+    __ mov(r2, Operand(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
+    __ str(r2, FieldMemOperand(r1, JSGeneratorObject::kContinuationOffset));
+    __ Move(r0, r1);  // Continuation expects generator object in r0.
+    __ Jump(r3);
+  }
 }
 
 void Builtins::Generate_ConstructedNonConstructable(MacroAssembler* masm) {
diff --git a/src/arm64/builtins-arm64.cc b/src/arm64/builtins-arm64.cc
index b5a7f8a6b50..a242129fbb7 100644
--- a/src/arm64/builtins-arm64.cc
+++ b/src/arm64/builtins-arm64.cc
@@ -767,54 +767,75 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {
   // values have already been copied into the context and these dummy values
   // will never be used.
   __ Ldr(x10, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));
-
-  // Push holes for arguments to generator function. Since the parser forced
-  // context allocation for any variables in generators, the actual argument
-  // values have already been copied into the context and these dummy values
-  // will never be used.
   __ Ldr(w10,
          FieldMemOperand(x10, SharedFunctionInfo::kFormalParameterCountOffset));
   __ LoadRoot(x11, Heap::kTheHoleValueRootIndex);
   __ PushMultipleTimes(x11, w10);
 
-  // Enter a new JavaScript frame, and initialize its slots as they were when
-  // the generator was suspended.
-  FrameScope scope(masm, StackFrame::MANUAL);
-  __ Push(lr, fp);
-  __ Move(fp, jssp);
-  __ Push(cp, x4);
-
-  // Restore the operand stack.
-  __ Ldr(x0, FieldMemOperand(x1, JSGeneratorObject::kOperandStackOffset));
-  __ Ldr(w3, UntagSmiFieldMemOperand(x0, FixedArray::kLengthOffset));
-  __ Add(x0, x0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
-  __ Add(x3, x0, Operand(x3, LSL, kPointerSizeLog2));
+  // Dispatch on the kind of generator object.
+  Label old_generator;
+  __ Ldr(x3, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));
+  __ Ldr(x3, FieldMemOperand(x3, SharedFunctionInfo::kFunctionDataOffset));
+  __ CompareObjectType(x3, x3, x3, BYTECODE_ARRAY_TYPE);
+  __ B(ne, &old_generator);
+
+  // New-style (ignition/turbofan) generator object
   {
-    Label done_loop, loop;
-    __ Bind(&loop);
-    __ Cmp(x0, x3);
-    __ B(eq, &done_loop);
-    __ Ldr(x10, MemOperand(x0, kPointerSize, PostIndex));
-    __ Push(x10);
-    __ B(&loop);
-    __ Bind(&done_loop);
+    __ Ldr(x0, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));
+    __ Ldr(x0,
+         FieldMemOperand(x0, SharedFunctionInfo::kFormalParameterCountOffset));
+    __ SmiUntag(x0);
+    // We abuse new.target both to indicate that this is a resume call and to
+    // pass in the generator object.  In ordinary calls, new.target is always
+    // undefined because generator functions are non-constructable.
+    __ Move(x3, x1);
+    __ Move(x1, x4);
+    __ Ldr(x5, FieldMemOperand(x1, JSFunction::kCodeEntryOffset));
+    __ Jump(x5);
   }
 
-  // Reset operand stack so we don't leak.
-  __ LoadRoot(x10, Heap::kEmptyFixedArrayRootIndex);
-  __ Str(x10, FieldMemOperand(x1, JSGeneratorObject::kOperandStackOffset));
+  // Old-style (full-codegen) generator object
+  __ bind(&old_generator);
+  {
+    // Enter a new JavaScript frame, and initialize its slots as they were when
+    // the generator was suspended.
+    FrameScope scope(masm, StackFrame::MANUAL);
+    __ Push(lr, fp);
+    __ Move(fp, jssp);
+    __ Push(cp, x4);
+
+    // Restore the operand stack.
+    __ Ldr(x0, FieldMemOperand(x1, JSGeneratorObject::kOperandStackOffset));
+    __ Ldr(w3, UntagSmiFieldMemOperand(x0, FixedArray::kLengthOffset));
+    __ Add(x0, x0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
+    __ Add(x3, x0, Operand(x3, LSL, kPointerSizeLog2));
+    {
+      Label done_loop, loop;
+      __ Bind(&loop);
+      __ Cmp(x0, x3);
+      __ B(eq, &done_loop);
+      __ Ldr(x10, MemOperand(x0, kPointerSize, PostIndex));
+      __ Push(x10);
+      __ B(&loop);
+      __ Bind(&done_loop);
+    }
 
-  // Resume the generator function at the continuation.
-  __ Ldr(x10, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));
-  __ Ldr(x10, FieldMemOperand(x10, SharedFunctionInfo::kCodeOffset));
-  __ Add(x10, x10, Code::kHeaderSize - kHeapObjectTag);
-  __ Ldrsw(x11,
-           UntagSmiFieldMemOperand(x1, JSGeneratorObject::kContinuationOffset));
-  __ Add(x10, x10, x11);
-  __ Mov(x12, Smi::FromInt(JSGeneratorObject::kGeneratorExecuting));
-  __ Str(x12, FieldMemOperand(x1, JSGeneratorObject::kContinuationOffset));
-  __ Move(x0, x1);  // Continuation expects generator object in x0.
-  __ Br(x10);
+    // Reset operand stack so we don't leak.
+    __ LoadRoot(x10, Heap::kEmptyFixedArrayRootIndex);
+    __ Str(x10, FieldMemOperand(x1, JSGeneratorObject::kOperandStackOffset));
+
+    // Resume the generator function at the continuation.
+    __ Ldr(x10, FieldMemOperand(x4, JSFunction::kSharedFunctionInfoOffset));
+    __ Ldr(x10, FieldMemOperand(x10, SharedFunctionInfo::kCodeOffset));
+    __ Add(x10, x10, Code::kHeaderSize - kHeapObjectTag);
+    __ Ldrsw(x11,
+        UntagSmiFieldMemOperand(x1, JSGeneratorObject::kContinuationOffset));
+    __ Add(x10, x10, x11);
+    __ Mov(x12, Smi::FromInt(JSGeneratorObject::kGeneratorExecuting));
+    __ Str(x12, FieldMemOperand(x1, JSGeneratorObject::kContinuationOffset));
+    __ Move(x0, x1);  // Continuation expects generator object in x0.
+    __ Br(x10);
+  }
 }
 
 enum IsTagged { kArgcIsSmiTagged, kArgcIsUntaggedInt };
diff --git a/src/builtins.cc b/src/builtins.cc
index a7d5aea37c3..8013f1078f4 100644
--- a/src/builtins.cc
+++ b/src/builtins.cc
@@ -2340,7 +2340,8 @@ void Generate_GeneratorPrototypeResume(
   Node* receiver = assembler->Parameter(0);
   Node* value = assembler->Parameter(1);
   Node* context = assembler->Parameter(4);
-  Node* zero = assembler->SmiConstant(Smi::FromInt(0));
+  Node* closed = assembler->SmiConstant(
+      Smi::FromInt(JSGeneratorObject::kGeneratorClosed));
 
   // Check if the {receiver} is actually a JSGeneratorObject.
   Label if_receiverisincompatible(assembler, Label::kDeferred);
@@ -2356,9 +2357,11 @@ void Generate_GeneratorPrototypeResume(
       receiver, JSGeneratorObject::kContinuationOffset);
   Label if_receiverisclosed(assembler, Label::kDeferred),
       if_receiverisrunning(assembler, Label::kDeferred);
-  assembler->GotoIf(assembler->SmiEqual(receiver_continuation, zero),
+  assembler->GotoIf(assembler->SmiEqual(receiver_continuation, closed),
                     &if_receiverisclosed);
-  assembler->GotoIf(assembler->SmiLessThan(receiver_continuation, zero),
+  DCHECK_LT(JSGeneratorObject::kGeneratorExecuting,
+            JSGeneratorObject::kGeneratorClosed);
+  assembler->GotoIf(assembler->SmiLessThan(receiver_continuation, closed),
                     &if_receiverisrunning);
 
   // Resume the {receiver} using our trampoline.
diff --git a/src/compiler.cc b/src/compiler.cc
index a257a09677d..9de36ed7f06 100644
--- a/src/compiler.cc
+++ b/src/compiler.cc
@@ -506,8 +506,7 @@ bool UseIgnition(CompilationInfo* info) {
     return false;
   }
 
-  // TODO(4681): Generator functions are not yet supported.
-  if (info->shared_info()->is_generator()) {
+  if (info->shared_info()->is_generator() && !FLAG_ignition_generators) {
     return false;
   }
 
@@ -840,6 +839,13 @@ MaybeHandle<Code> GetOptimizedCode(Handle<JSFunction> function,
     return MaybeHandle<Code>();
   }
 
+  // Do not use Crankshaft/TurboFan on a generator function.
+  // TODO(neis): Eventually enable for Turbofan.
+  if (IsGeneratorFunction(info->shared_info()->kind())) {
+    info->AbortOptimization(kGenerator);
+    return MaybeHandle<Code>();
+  }
+
   // Limit the number of times we try to optimize functions.
   const int kMaxOptCount =
       FLAG_deopt_every_n_times == 0 ? FLAG_max_opt_count : 1000;
diff --git a/src/debug/mirrors.js b/src/debug/mirrors.js
index 881f303f29d..d0b76fda202 100644
--- a/src/debug/mirrors.js
+++ b/src/debug/mirrors.js
@@ -1408,8 +1408,8 @@ inherits(GeneratorMirror, ObjectMirror);
 
 function GeneratorGetStatus_(value) {
   var continuation = %GeneratorGetContinuation(value);
-  if (continuation < 0) return "running";
-  if (continuation == 0) return "closed";
+  if (continuation < -1) return "running";
+  if (continuation == -1) return "closed";
   return "suspended";
 }
 
diff --git a/src/flag-definitions.h b/src/flag-definitions.h
index 79be6414ca5..ade3c72d394 100644
--- a/src/flag-definitions.h
+++ b/src/flag-definitions.h
@@ -284,6 +284,8 @@ DEFINE_BOOL(string_slices, true, "use string slices")
 // Flags for Ignition.
 DEFINE_BOOL(ignition, false, "use ignition interpreter")
 DEFINE_BOOL(ignition_eager, true, "eagerly compile and parse with ignition")
+DEFINE_BOOL(ignition_generators, false,
+            "enable experimental ignition support for generators")
 DEFINE_STRING(ignition_filter, "*", "filter for ignition interpreter")
 DEFINE_BOOL(print_bytecode, false,
             "print bytecode generated by ignition interpreter")
diff --git a/src/frames.cc b/src/frames.cc
index 78859344e04..6f5176261b3 100644
--- a/src/frames.cc
+++ b/src/frames.cc
@@ -1250,7 +1250,7 @@ void InterpretedFrame::PatchBytecodeArray(BytecodeArray* bytecode_array) {
   SetExpression(index, bytecode_array);
 }
 
-Object* InterpretedFrame::GetInterpreterRegister(int register_index) const {
+Object* InterpretedFrame::ReadInterpreterRegister(int register_index) const {
   const int index = InterpreterFrameConstants::kRegisterFileExpressionIndex;
   DCHECK_EQ(
       InterpreterFrameConstants::kRegisterFilePointerFromFp,
@@ -1258,6 +1258,15 @@ Object* InterpretedFrame::GetInterpreterRegister(int register_index) const {
   return GetExpression(index + register_index);
 }
 
+void InterpretedFrame::WriteInterpreterRegister(int register_index,
+                                                Object* value) {
+  const int index = InterpreterFrameConstants::kRegisterFileExpressionIndex;
+  DCHECK_EQ(
+      InterpreterFrameConstants::kRegisterFilePointerFromFp,
+      InterpreterFrameConstants::kExpressionsOffset - index * kPointerSize);
+  return SetExpression(index + register_index, value);
+}
+
 void InterpretedFrame::Summarize(List<FrameSummary>* functions) const {
   DCHECK(functions->length() == 0);
   AbstractCode* abstract_code =
diff --git a/src/frames.h b/src/frames.h
index 6b51fb868cd..953b6066aa1 100644
--- a/src/frames.h
+++ b/src/frames.h
@@ -907,7 +907,8 @@ class InterpretedFrame : public JavaScriptFrame {
   void PatchBytecodeArray(BytecodeArray* bytecode_array);
 
   // Access to the interpreter register file for this frame.
-  Object* GetInterpreterRegister(int register_index) const;
+  Object* ReadInterpreterRegister(int register_index) const;
+  void WriteInterpreterRegister(int register_index, Object* value);
 
   // Build a list with summaries for this frame including all inlined frames.
   void Summarize(List<FrameSummary>* frames) const override;
diff --git a/src/ia32/builtins-ia32.cc b/src/ia32/builtins-ia32.cc
index 6b4e5479186..ec8a7977ef0 100644
--- a/src/ia32/builtins-ia32.cc
+++ b/src/ia32/builtins-ia32.cc
@@ -463,44 +463,68 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {
     __ bind(&done_loop);
   }
 
-  // Enter a new JavaScript frame, and initialize its slots as they were when
-  // the generator was suspended.
-  FrameScope scope(masm, StackFrame::MANUAL);
-  __ PushReturnAddressFrom(eax);  // Return address.
-  __ Push(ebp);                   // Caller's frame pointer.
-  __ Move(ebp, esp);
-  __ Push(esi);  // Callee's context.
-  __ Push(edi);  // Callee's JS Function.
-
-  // Restore the operand stack.
-  __ mov(eax, FieldOperand(ebx, JSGeneratorObject::kOperandStackOffset));
+  // Dispatch on the kind of generator object.
+  Label old_generator;
+  __ mov(ecx, FieldOperand(edi, JSFunction::kSharedFunctionInfoOffset));
+  __ mov(ecx, FieldOperand(ecx, SharedFunctionInfo::kFunctionDataOffset));
+  __ CmpObjectType(ecx, BYTECODE_ARRAY_TYPE, ecx);
+  __ j(not_equal, &old_generator);
+
+  // New-style (ignition/turbofan) generator object
   {
-    Label done_loop, loop;
-    __ Move(ecx, Smi::FromInt(0));
-    __ bind(&loop);
-    __ cmp(ecx, FieldOperand(eax, FixedArray::kLengthOffset));
-    __ j(equal, &done_loop, Label::kNear);
-    __ Push(FieldOperand(eax, ecx, times_half_pointer_size,
-                         FixedArray::kHeaderSize));
-    __ add(ecx, Immediate(Smi::FromInt(1)));
-    __ jmp(&loop);
-    __ bind(&done_loop);
+    __ PushReturnAddressFrom(eax);
+    __ mov(eax, FieldOperand(edi, JSFunction::kSharedFunctionInfoOffset));
+    __ mov(eax,
+         FieldOperand(ecx, SharedFunctionInfo::kFormalParameterCountOffset));
+    // We abuse new.target both to indicate that this is a resume call and to
+    // pass in the generator object.  In ordinary calls, new.target is always
+    // undefined because generator functions are non-constructable.
+    __ mov(edx, ebx);
+    __ jmp(FieldOperand(edi, JSFunction::kCodeEntryOffset));
   }
 
-  // Reset operand stack so we don't leak.
-  __ mov(FieldOperand(ebx, JSGeneratorObject::kOperandStackOffset),
-         Immediate(masm->isolate()->factory()->empty_fixed_array()));
+  // Old-style (full-codegen) generator object
+  __ bind(&old_generator);
+  {
+    // Enter a new JavaScript frame, and initialize its slots as they were when
+    // the generator was suspended.
+    FrameScope scope(masm, StackFrame::MANUAL);
+    __ PushReturnAddressFrom(eax);  // Return address.
+    __ Push(ebp);                   // Caller's frame pointer.
+    __ Move(ebp, esp);
+    __ Push(esi);  // Callee's context.
+    __ Push(edi);  // Callee's JS Function.
+
+    // Restore the operand stack.
+    __ mov(eax, FieldOperand(ebx, JSGeneratorObject::kOperandStackOffset));
+    {
+      Label done_loop, loop;
+      __ Move(ecx, Smi::FromInt(0));
+      __ bind(&loop);
+      __ cmp(ecx, FieldOperand(eax, FixedArray::kLengthOffset));
+      __ j(equal, &done_loop, Label::kNear);
+      __ Push(FieldOperand(eax, ecx, times_half_pointer_size,
+                           FixedArray::kHeaderSize));
+      __ add(ecx, Immediate(Smi::FromInt(1)));
+      __ jmp(&loop);
+      __ bind(&done_loop);
+    }
 
-  // Resume the generator function at the continuation.
-  __ mov(edx, FieldOperand(edi, JSFunction::kSharedFunctionInfoOffset));
-  __ mov(edx, FieldOperand(edx, SharedFunctionInfo::kCodeOffset));
-  __ mov(ecx, FieldOperand(ebx, JSGeneratorObject::kContinuationOffset));
-  __ SmiUntag(ecx);
-  __ lea(edx, FieldOperand(edx, ecx, times_1, Code::kHeaderSize));
-  __ mov(FieldOperand(ebx, JSGeneratorObject::kContinuationOffset),
-         Immediate(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
-  __ mov(eax, ebx);  // Continuation expects generator object in eax.
-  __ jmp(edx);
+    // Reset operand stack so we don't leak.
+    __ mov(FieldOperand(ebx, JSGeneratorObject::kOperandStackOffset),
+           Immediate(masm->isolate()->factory()->empty_fixed_array()));
+
+    // Resume the generator function at the continuation.
+    __ mov(edx, FieldOperand(edi, JSFunction::kSharedFunctionInfoOffset));
+    __ mov(edx, FieldOperand(edx, SharedFunctionInfo::kCodeOffset));
+    __ mov(ecx, FieldOperand(ebx, JSGeneratorObject::kContinuationOffset));
+    __ SmiUntag(ecx);
+    __ lea(edx, FieldOperand(edx, ecx, times_1, Code::kHeaderSize));
+    __ mov(FieldOperand(ebx, JSGeneratorObject::kContinuationOffset),
+           Immediate(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
+    __ mov(eax, ebx);  // Continuation expects generator object in eax.
+    __ jmp(edx);
+  }
 }
 
 // Generate code for entering a JS function with the interpreter.
diff --git a/src/interpreter/bytecode-array-builder.cc b/src/interpreter/bytecode-array-builder.cc
index 109b01eab32..f664349dd44 100644
--- a/src/interpreter/bytecode-array-builder.cc
+++ b/src/interpreter/bytecode-array-builder.cc
@@ -896,6 +896,11 @@ BytecodeArrayBuilder& BytecodeArrayBuilder::Return() {
   return *this;
 }
 
+BytecodeArrayBuilder& BytecodeArrayBuilder::Illegal() {
+  Output(Bytecode::kIllegal);
+  return *this;
+}
+
 BytecodeArrayBuilder& BytecodeArrayBuilder::Debugger() {
   Output(Bytecode::kDebugger);
   return *this;
diff --git a/src/interpreter/bytecode-array-builder.h b/src/interpreter/bytecode-array-builder.h
index 4446a635968..4ad9ff995a1 100644
--- a/src/interpreter/bytecode-array-builder.h
+++ b/src/interpreter/bytecode-array-builder.h
@@ -230,6 +230,8 @@ class BytecodeArrayBuilder final : public ZoneObject {
   BytecodeArrayBuilder& ReThrow();
   BytecodeArrayBuilder& Return();
 
+  BytecodeArrayBuilder& Illegal();
+
   // Debugger.
   BytecodeArrayBuilder& Debugger();
 
diff --git a/src/interpreter/bytecode-generator.cc b/src/interpreter/bytecode-generator.cc
index 7a4c10dd8f8..9148b2d294c 100644
--- a/src/interpreter/bytecode-generator.cc
+++ b/src/interpreter/bytecode-generator.cc
@@ -565,8 +565,10 @@ BytecodeGenerator::BytecodeGenerator(Isolate* isolate, Zone* zone)
       execution_context_(nullptr),
       execution_result_(nullptr),
       register_allocator_(nullptr),
+      generator_resume_points_(0, zone),
       try_catch_nesting_level_(0),
-      try_finally_nesting_level_(0) {
+      try_finally_nesting_level_(0),
+      generator_yields_seen_(0) {
   InitializeAstVisitor(isolate);
 }
 
@@ -586,6 +588,10 @@ Handle<BytecodeArray> BytecodeGenerator::MakeBytecode(CompilationInfo* info) {
   // Initialize control scope.
   ControlScopeForTopLevel control(this);
 
+  if (IsGeneratorFunction(info->literal()->kind())) {
+    VisitGeneratorPrologue();
+  }
+
   // Build function context only if there are context allocated variables.
   if (scope()->NeedsContext()) {
     // Push a new inner context scope for the function.
@@ -634,6 +640,40 @@ void BytecodeGenerator::MakeBytecodeBody() {
   VisitStatements(info()->literal()->body());
 }
 
+void BytecodeGenerator::VisitGeneratorPrologue() {
+  generator_resume_points_.clear();
+  generator_resume_points_.resize(info()->literal()->yield_count());
+
+  BytecodeLabel regular_call;
+  builder()
+      ->LoadAccumulatorWithRegister(Register::new_target())
+      .JumpIfUndefined(&regular_call);
+
+  // This is a resume call. Restore registers and perform state dispatch.
+  // (The current context has already been restored by the trampoline.)
+  {
+    RegisterAllocationScope register_scope(this);
+    Register state = register_allocator()->NewRegister();
+    builder()
+        ->CallRuntime(Runtime::kResumeIgnitionGenerator, Register::new_target(),
+                      1)
+        .StoreAccumulatorInRegister(state);
+
+    // TODO(neis): Optimize this by using a proper jump table.
+    for (size_t i = 0; i < generator_resume_points_.size(); ++i) {
+      builder()
+          ->LoadLiteral(Smi::FromInt(static_cast<int>(i)))
+          .CompareOperation(Token::Value::EQ_STRICT, state)
+          .JumpIfTrue(&(generator_resume_points_[i]));
+    }
+    builder()->Illegal();  // Should never get here.
+  }
+
+  builder()->Bind(&regular_call);
+  // This is a regular call. Fall through to the ordinary function prologue,
+  // after which we will run into the generator object creation and the initial
+  // yield (both inserted by the parser).
+}
 
 void BytecodeGenerator::VisitBlock(Block* stmt) {
   // Visit declarations and statements.
@@ -2229,16 +2269,86 @@ void BytecodeGenerator::VisitAssignment(Assignment* expr) {
   execution_result()->SetResultInAccumulator();
 }
 
+void BytecodeGenerator::VisitYield(Yield* expr) {
+  int id = generator_yields_seen_++;
+
+  builder()->SetExpressionPosition(expr);
+  Register value = VisitForRegisterValue(expr->expression());
+
+  register_allocator()->PrepareForConsecutiveAllocations(2);
+  Register generator = register_allocator()->NextConsecutiveRegister();
+  Register state = register_allocator()->NextConsecutiveRegister();
+
+  // Save context, registers, and state. Then return.
+  VisitForRegisterValue(expr->generator_object(), generator);
+  builder()
+      ->LoadLiteral(Smi::FromInt(id))
+      .StoreAccumulatorInRegister(state)
+      .CallRuntime(Runtime::kSuspendIgnitionGenerator, generator, 2)
+      .LoadAccumulatorWithRegister(value)
+      .Return();  // Hard return (ignore any finally blocks).
+
+  builder()->Bind(&(generator_resume_points_[id]));
+  // Upon resume, we continue here.
+
+  {
+    RegisterAllocationScope register_scope(this);
+
+    Register input = register_allocator()->NewRegister();
+    builder()
+        ->CallRuntime(Runtime::kGeneratorGetInput, generator, 1)
+        .StoreAccumulatorInRegister(input);
+
+    Register resume_mode = register_allocator()->NewRegister();
+    builder()
+        ->CallRuntime(Runtime::kGeneratorGetResumeMode, generator, 1)
+        .StoreAccumulatorInRegister(resume_mode);
+
+    // Now dispatch on resume mode.
+
+    BytecodeLabel resume_with_next;
+    BytecodeLabel resume_with_return;
+    BytecodeLabel resume_with_throw;
 
-void BytecodeGenerator::VisitYield(Yield* expr) { UNIMPLEMENTED(); }
+    builder()
+        ->LoadLiteral(Smi::FromInt(JSGeneratorObject::kNext))
+        .CompareOperation(Token::EQ_STRICT, resume_mode)
+        .JumpIfTrue(&resume_with_next)
+        .LoadLiteral(Smi::FromInt(JSGeneratorObject::kThrow))
+        .CompareOperation(Token::EQ_STRICT, resume_mode)
+        .JumpIfTrue(&resume_with_throw)
+        .Jump(&resume_with_return);
+
+    builder()->Bind(&resume_with_return);
+    {
+      register_allocator()->PrepareForConsecutiveAllocations(2);
+      Register value = register_allocator()->NextConsecutiveRegister();
+      Register done = register_allocator()->NextConsecutiveRegister();
+      builder()
+          ->MoveRegister(input, value)
+          .LoadTrue()
+          .StoreAccumulatorInRegister(done)
+          .CallRuntime(Runtime::kCreateIterResultObject, value, 2);
+      execution_control()->ReturnAccumulator();
+    }
 
+    builder()->Bind(&resume_with_throw);
+    builder()
+        ->LoadAccumulatorWithRegister(input)
+        .Throw();
+
+    builder()->Bind(&resume_with_next);
+    builder()->LoadAccumulatorWithRegister(input);
+  }
+  execution_result()->SetResultInAccumulator();
+}
 
 void BytecodeGenerator::VisitThrow(Throw* expr) {
   VisitForAccumulatorValue(expr->exception());
   builder()->SetExpressionPosition(expr);
   builder()->Throw();
-  // Throw statments are modeled as expression instead of statments. These are
-  // converted from assignment statements in Rewriter::ReWrite pass. An
+  // Throw statements are modeled as expressions instead of statements. These
+  // are converted from assignment statements in Rewriter::ReWrite pass. An
   // assignment statement expects a value in the accumulator. This is a hack to
   // avoid DCHECK fails assert accumulator has been set.
   execution_result()->SetResultInAccumulator();
diff --git a/src/interpreter/bytecode-generator.h b/src/interpreter/bytecode-generator.h
index 4ef173890c0..c3c8e441d29 100644
--- a/src/interpreter/bytecode-generator.h
+++ b/src/interpreter/bytecode-generator.h
@@ -109,6 +109,8 @@ class BytecodeGenerator final : public AstVisitor {
   void BuildHoleCheckForVariableLoad(VariableMode mode, Handle<String> name);
   void BuildHoleCheckForVariableAssignment(Variable* variable, Token::Value op);
 
+  void VisitGeneratorPrologue();
+
   void VisitArgumentsObject(Variable* variable);
   void VisitRestArgumentsArray(Variable* rest);
   void VisitCallSuper(Call* call);
@@ -204,8 +206,10 @@ class BytecodeGenerator final : public AstVisitor {
   ContextScope* execution_context_;
   ExpressionResultScope* execution_result_;
   RegisterAllocationScope* register_allocator_;
+  ZoneVector<BytecodeLabel> generator_resume_points_;
   int try_catch_nesting_level_;
   int try_finally_nesting_level_;
+  int generator_yields_seen_;
 };
 
 }  // namespace interpreter
diff --git a/src/interpreter/bytecode-register-allocator.h b/src/interpreter/bytecode-register-allocator.h
index 696a3b174a8..a4f68459cbc 100644
--- a/src/interpreter/bytecode-register-allocator.h
+++ b/src/interpreter/bytecode-register-allocator.h
@@ -65,7 +65,7 @@ class TemporaryRegisterAllocator final {
   DISALLOW_COPY_AND_ASSIGN(TemporaryRegisterAllocator);
 };
 
-// A class than allows the instantiator to allocate temporary registers that are
+// A class that allows the instantiator to allocate temporary registers that are
 // cleaned up when scope is closed.
 class BytecodeRegisterAllocator final {
  public:
diff --git a/src/isolate.cc b/src/isolate.cc
index 63f670facd0..559f0a0292b 100644
--- a/src/isolate.cc
+++ b/src/isolate.cc
@@ -1162,7 +1162,7 @@ Object* Isolate::UnwindAndFindHandler() {
         // position of the exception handler. The special builtin below will
         // take care of continuing to dispatch at that position. Also restore
         // the correct context for the handler from the interpreter register.
-        context = Context::cast(js_frame->GetInterpreterRegister(context_reg));
+        context = Context::cast(js_frame->ReadInterpreterRegister(context_reg));
         js_frame->PatchBytecodeOffset(static_cast<int>(offset));
         offset = 0;
 
diff --git a/src/mips/builtins-mips.cc b/src/mips/builtins-mips.cc
index b02d070e686..693b29d2955 100644
--- a/src/mips/builtins-mips.cc
+++ b/src/mips/builtins-mips.cc
@@ -893,44 +893,70 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {
     __ bind(&done_loop);
   }
 
-  // Enter a new JavaScript frame, and initialize its slots as they were when
-  // the generator was suspended.
-  FrameScope scope(masm, StackFrame::MANUAL);
-  __ Push(ra, fp);
-  __ Move(fp, sp);
-  __ Push(cp, t0);
-
-  // Restore the operand stack.
-  __ lw(a0, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
-  __ lw(a3, FieldMemOperand(a0, FixedArray::kLengthOffset));
-  __ Addu(a0, a0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
-  __ Lsa(a3, a0, a3, kPointerSizeLog2 - 1);
+  // Dispatch on the kind of generator object.
+  Label old_generator;
+  __ lw(a3, FieldMemOperand(t0, JSFunction::kSharedFunctionInfoOffset));
+  __ lw(a3, FieldMemOperand(a3, SharedFunctionInfo::kFunctionDataOffset));
+  __ GetObjectType(a3, a3, a3);
+  __ Branch(&old_generator, ne, a3, Operand(BYTECODE_ARRAY_TYPE));
+
+  // New-style (ignition/turbofan) generator object.
   {
-    Label done_loop, loop;
-    __ bind(&loop);
-    __ Branch(&done_loop, eq, a0, Operand(a3));
-    __ lw(t1, MemOperand(a0));
-    __ Push(t1);
-    __ Branch(USE_DELAY_SLOT, &loop);
-    __ addiu(a0, a0, kPointerSize);  // In delay slot.
-    __ bind(&done_loop);
+    __ lw(a0, FieldMemOperand(t0, JSFunction::kSharedFunctionInfoOffset));
+    __ lw(a0,
+         FieldMemOperand(a0, SharedFunctionInfo::kFormalParameterCountOffset));
+    __ SmiUntag(a0);
+    // We abuse new.target both to indicate that this is a resume call and to
+    // pass in the generator object.  In ordinary calls, new.target is always
+    // undefined because generator functions are non-constructable.
+    __ Move(a3, a1);
+    __ Move(a1, t0);
+    __ lw(a2, FieldMemOperand(a1, JSFunction::kCodeEntryOffset));
+    __ Jump(a2);
   }
 
-  // Reset operand stack so we don't leak.
-  __ LoadRoot(t1, Heap::kEmptyFixedArrayRootIndex);
-  __ sw(t1, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
+  // Old-style (full-codegen) generator object
+  __ bind(&old_generator);
+  {
+    // Enter a new JavaScript frame, and initialize its slots as they were when
+    // the generator was suspended.
+    FrameScope scope(masm, StackFrame::MANUAL);
+    __ Push(ra, fp);
+    __ Move(fp, sp);
+    __ Push(cp, t0);
+
+    // Restore the operand stack.
+    __ lw(a0, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
+    __ lw(a3, FieldMemOperand(a0, FixedArray::kLengthOffset));
+    __ Addu(a0, a0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
+    __ Lsa(a3, a0, a3, kPointerSizeLog2 - 1);
+    {
+      Label done_loop, loop;
+      __ bind(&loop);
+      __ Branch(&done_loop, eq, a0, Operand(a3));
+      __ lw(t1, MemOperand(a0));
+      __ Push(t1);
+      __ Branch(USE_DELAY_SLOT, &loop);
+      __ addiu(a0, a0, kPointerSize);  // In delay slot.
+      __ bind(&done_loop);
+    }
 
-  // Resume the generator function at the continuation.
-  __ lw(a3, FieldMemOperand(t0, JSFunction::kSharedFunctionInfoOffset));
-  __ lw(a3, FieldMemOperand(a3, SharedFunctionInfo::kCodeOffset));
-  __ Addu(a3, a3, Operand(Code::kHeaderSize - kHeapObjectTag));
-  __ lw(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
-  __ SmiUntag(a2);
-  __ Addu(a3, a3, Operand(a2));
-  __ li(a2, Operand(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
-  __ sw(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
-  __ Move(v0, a1);  // Continuation expects generator object in v0.
-  __ Jump(a3);
+    // Reset operand stack so we don't leak.
+    __ LoadRoot(t1, Heap::kEmptyFixedArrayRootIndex);
+    __ sw(t1, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
+
+    // Resume the generator function at the continuation.
+    __ lw(a3, FieldMemOperand(t0, JSFunction::kSharedFunctionInfoOffset));
+    __ lw(a3, FieldMemOperand(a3, SharedFunctionInfo::kCodeOffset));
+    __ Addu(a3, a3, Operand(Code::kHeaderSize - kHeapObjectTag));
+    __ lw(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
+    __ SmiUntag(a2);
+    __ Addu(a3, a3, Operand(a2));
+    __ li(a2, Operand(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
+    __ sw(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
+    __ Move(v0, a1);  // Continuation expects generator object in v0.
+    __ Jump(a3);
+  }
 }
 
 // Generate code for entering a JS function with the interpreter.
diff --git a/src/mips64/builtins-mips64.cc b/src/mips64/builtins-mips64.cc
index 190a5bc8033..43b4df3baf3 100644
--- a/src/mips64/builtins-mips64.cc
+++ b/src/mips64/builtins-mips64.cc
@@ -758,45 +758,71 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {
     __ bind(&done_loop);
   }
 
-  // Enter a new JavaScript frame, and initialize its slots as they were when
-  // the generator was suspended.
-  FrameScope scope(masm, StackFrame::MANUAL);
-  __ Push(ra, fp);
-  __ Move(fp, sp);
-  __ Push(cp, a4);
-
-  // Restore the operand stack.
-  __ ld(a0, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
-  __ ld(a3, FieldMemOperand(a0, FixedArray::kLengthOffset));
-  __ SmiUntag(a3);
-  __ Daddu(a0, a0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
-  __ Dlsa(a3, a0, a3, kPointerSizeLog2);
+  // Dispatch on the kind of generator object.
+  Label old_generator;
+  __ ld(a3, FieldMemOperand(a4, JSFunction::kSharedFunctionInfoOffset));
+  __ ld(a3, FieldMemOperand(a3, SharedFunctionInfo::kFunctionDataOffset));
+  __ GetObjectType(a3, a3, a3);
+  __ Branch(&old_generator, ne, a3, Operand(BYTECODE_ARRAY_TYPE));
+
+  // New-style (ignition/turbofan) generator object.
   {
-    Label done_loop, loop;
-    __ bind(&loop);
-    __ Branch(&done_loop, eq, a0, Operand(a3));
-    __ ld(a5, MemOperand(a0));
-    __ Push(a5);
-    __ Branch(USE_DELAY_SLOT, &loop);
-    __ daddiu(a0, a0, kPointerSize);  // In delay slot.
-    __ bind(&done_loop);
+    __ ld(a0, FieldMemOperand(a4, JSFunction::kSharedFunctionInfoOffset));
+    __ lw(a0,
+         FieldMemOperand(a0, SharedFunctionInfo::kFormalParameterCountOffset));
+    __ SmiUntag(a0);
+    // We abuse new.target both to indicate that this is a resume call and to
+    // pass in the generator object.  In ordinary calls, new.target is always
+    // undefined because generator functions are non-constructable.
+    __ Move(a3, a1);
+    __ Move(a1, a4);
+    __ ld(a2, FieldMemOperand(a1, JSFunction::kCodeEntryOffset));
+    __ Jump(a2);
   }
 
-  // Reset operand stack so we don't leak.
-  __ LoadRoot(a5, Heap::kEmptyFixedArrayRootIndex);
-  __ sd(a5, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
+  // Old-style (full-codegen) generator object
+  __ bind(&old_generator);
+  {
+    // Enter a new JavaScript frame, and initialize its slots as they were when
+    // the generator was suspended.
+    FrameScope scope(masm, StackFrame::MANUAL);
+    __ Push(ra, fp);
+    __ Move(fp, sp);
+    __ Push(cp, a4);
+
+    // Restore the operand stack.
+    __ ld(a0, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
+    __ ld(a3, FieldMemOperand(a0, FixedArray::kLengthOffset));
+    __ SmiUntag(a3);
+    __ Daddu(a0, a0, Operand(FixedArray::kHeaderSize - kHeapObjectTag));
+    __ Dlsa(a3, a0, a3, kPointerSizeLog2);
+    {
+      Label done_loop, loop;
+      __ bind(&loop);
+      __ Branch(&done_loop, eq, a0, Operand(a3));
+      __ ld(a5, MemOperand(a0));
+      __ Push(a5);
+      __ Branch(USE_DELAY_SLOT, &loop);
+      __ daddiu(a0, a0, kPointerSize);  // In delay slot.
+      __ bind(&done_loop);
+    }
 
-  // Resume the generator function at the continuation.
-  __ ld(a3, FieldMemOperand(a4, JSFunction::kSharedFunctionInfoOffset));
-  __ ld(a3, FieldMemOperand(a3, SharedFunctionInfo::kCodeOffset));
-  __ Daddu(a3, a3, Operand(Code::kHeaderSize - kHeapObjectTag));
-  __ ld(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
-  __ SmiUntag(a2);
-  __ Daddu(a3, a3, Operand(a2));
-  __ li(a2, Operand(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
-  __ sd(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
-  __ Move(v0, a1);  // Continuation expects generator object in v0.
-  __ Jump(a3);
+    // Reset operand stack so we don't leak.
+    __ LoadRoot(a5, Heap::kEmptyFixedArrayRootIndex);
+    __ sd(a5, FieldMemOperand(a1, JSGeneratorObject::kOperandStackOffset));
+
+    // Resume the generator function at the continuation.
+    __ ld(a3, FieldMemOperand(a4, JSFunction::kSharedFunctionInfoOffset));
+    __ ld(a3, FieldMemOperand(a3, SharedFunctionInfo::kCodeOffset));
+    __ Daddu(a3, a3, Operand(Code::kHeaderSize - kHeapObjectTag));
+    __ ld(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
+    __ SmiUntag(a2);
+    __ Daddu(a3, a3, Operand(a2));
+    __ li(a2, Operand(Smi::FromInt(JSGeneratorObject::kGeneratorExecuting)));
+    __ sd(a2, FieldMemOperand(a1, JSGeneratorObject::kContinuationOffset));
+    __ Move(v0, a1);  // Continuation expects generator object in v0.
+    __ Jump(a3);
+  }
 }
 
 void Builtins::Generate_ConstructedNonConstructable(MacroAssembler* masm) {
diff --git a/src/objects-inl.h b/src/objects-inl.h
index 046d950fba7..b1a1c95cee1 100644
--- a/src/objects-inl.h
+++ b/src/objects-inl.h
@@ -6279,9 +6279,9 @@ SMI_ACCESSORS(JSGeneratorObject, continuation, kContinuationOffset)
 ACCESSORS(JSGeneratorObject, operand_stack, FixedArray, kOperandStackOffset)
 
 bool JSGeneratorObject::is_suspended() {
-  DCHECK_LT(kGeneratorExecuting, kGeneratorClosed);
-  DCHECK_EQ(kGeneratorClosed, 0);
-  return continuation() > 0;
+  DCHECK_LT(kGeneratorExecuting, 0);
+  DCHECK_LT(kGeneratorClosed, 0);
+  return continuation() >= 0;
 }
 
 bool JSGeneratorObject::is_closed() {
diff --git a/src/objects.h b/src/objects.h
index 08cd44dcf36..0d61bc9a522 100644
--- a/src/objects.h
+++ b/src/objects.h
@@ -7356,8 +7356,8 @@ class JSGeneratorObject: public JSObject {
   DECLARE_VERIFIER(JSGeneratorObject)
 
   // Magic sentinel values for the continuation.
-  static const int kGeneratorExecuting = -1;
-  static const int kGeneratorClosed = 0;
+  static const int kGeneratorExecuting = -2;
+  static const int kGeneratorClosed = -1;
 
   // Layout description.
   static const int kFunctionOffset = JSObject::kHeaderSize;
diff --git a/src/runtime/runtime-generator.cc b/src/runtime/runtime-generator.cc
index eeac3ad6b64..9c875300c6b 100644
--- a/src/runtime/runtime-generator.cc
+++ b/src/runtime/runtime-generator.cc
@@ -68,6 +68,7 @@ RUNTIME_FUNCTION(Runtime_SuspendJSGeneratorObject) {
   return isolate->heap()->undefined_value();
 }
 
+
 RUNTIME_FUNCTION(Runtime_GeneratorClose) {
   HandleScope scope(isolate);
   DCHECK(args.length() == 1);
@@ -109,6 +110,16 @@ RUNTIME_FUNCTION(Runtime_GeneratorGetInput) {
 }
 
 
+// Returns resume mode of generator activation.
+RUNTIME_FUNCTION(Runtime_GeneratorGetResumeMode) {
+  HandleScope scope(isolate);
+  DCHECK(args.length() == 1);
+  CONVERT_ARG_HANDLE_CHECKED(JSGeneratorObject, generator, 0);
+
+  return Smi::FromInt(generator->resume_mode());
+}
+
+
 // Returns generator continuation as a PC offset, or the magic -1 or 0 values.
 RUNTIME_FUNCTION(Runtime_GeneratorGetContinuation) {
   HandleScope scope(isolate);
@@ -134,5 +145,60 @@ RUNTIME_FUNCTION(Runtime_GeneratorGetSourcePosition) {
   return isolate->heap()->undefined_value();
 }
 
+
+RUNTIME_FUNCTION(Runtime_SuspendIgnitionGenerator) {
+  HandleScope scope(isolate);
+  DCHECK(args.length() == 2);
+  CONVERT_ARG_HANDLE_CHECKED(JSGeneratorObject, generator, 0);
+  CONVERT_ARG_HANDLE_CHECKED(Smi, state, 1);
+
+  JavaScriptFrameIterator it(isolate);
+  JavaScriptFrame* frame = it.frame();
+  Handle<JSFunction> function(frame->function());
+  CHECK(function->shared()->is_generator());
+  CHECK_EQ(frame->type(), StackFrame::INTERPRETED);
+
+  // Save register file.
+  int size = function->shared()->bytecode_array()->register_count();
+  Handle<FixedArray> register_file = isolate->factory()->NewFixedArray(size);
+  for (int i = 0; i < size; ++i) {
+    Object* value =
+        static_cast<InterpretedFrame*>(frame)->ReadInterpreterRegister(i);
+    register_file->set(i, value);
+  }
+
+  generator->set_operand_stack(*register_file);
+  generator->set_context(Context::cast(frame->context()));
+  generator->set_continuation(state->value());
+
+  return isolate->heap()->undefined_value();
+}
+
+
+RUNTIME_FUNCTION(Runtime_ResumeIgnitionGenerator) {
+  HandleScope scope(isolate);
+  DCHECK(args.length() == 1);
+  CONVERT_ARG_HANDLE_CHECKED(JSGeneratorObject, generator, 0);
+
+  JavaScriptFrameIterator it(isolate);
+  JavaScriptFrame* frame = it.frame();
+  Handle<JSFunction> function(frame->function());
+  CHECK(function->shared()->is_generator());
+  CHECK_EQ(frame->type(), StackFrame::INTERPRETED);
+
+  // Restore register file.
+  int size = function->shared()->bytecode_array()->register_count();
+  DCHECK_EQ(size, generator->operand_stack()->length());
+  for (int i = 0; i < size; ++i) {
+    Object* value = generator->operand_stack()->get(i);
+    static_cast<InterpretedFrame*>(frame)->WriteInterpreterRegister(i, value);
+  }
+  generator->set_operand_stack(isolate->heap()->empty_fixed_array());
+
+  int state = generator->continuation();
+  generator->set_continuation(JSGeneratorObject::kGeneratorExecuting);
+  return Smi::FromInt(state);
+}
+
 }  // namespace internal
 }  // namespace v8
diff --git a/src/runtime/runtime.h b/src/runtime/runtime.h
index 1635f420af4..e0500ffdcd6 100644
--- a/src/runtime/runtime.h
+++ b/src/runtime/runtime.h
@@ -237,7 +237,10 @@ namespace internal {
   F(GeneratorGetReceiver, 1, 1)         \
   F(GeneratorGetInput, 1, 1)            \
   F(GeneratorGetContinuation, 1, 1)     \
-  F(GeneratorGetSourcePosition, 1, 1)
+  F(GeneratorGetSourcePosition, 1, 1)   \
+  F(GeneratorGetResumeMode, 1, 1)       \
+  F(SuspendIgnitionGenerator, 2, 1)     \
+  F(ResumeIgnitionGenerator, 1, 1)
 
 #ifdef V8_I18N_SUPPORT
 #define FOR_EACH_INTRINSIC_I18N(F)           \
diff --git a/src/x64/builtins-x64.cc b/src/x64/builtins-x64.cc
index 60841e65a3f..86f29983912 100644
--- a/src/x64/builtins-x64.cc
+++ b/src/x64/builtins-x64.cc
@@ -537,48 +537,72 @@ void Builtins::Generate_ResumeGeneratorTrampoline(MacroAssembler* masm) {
     __ bind(&done_loop);
   }
 
-  // Enter a new JavaScript frame, and initialize its slots as they were when
-  // the generator was suspended.
-  FrameScope scope(masm, StackFrame::MANUAL);
-  __ PushReturnAddressFrom(rax);  // Return address.
-  __ Push(rbp);                   // Caller's frame pointer.
-  __ Move(rbp, rsp);
-  __ Push(rsi);  // Callee's context.
-  __ Push(rdi);  // Callee's JS Function.
+  // Dispatch on the kind of generator object.
+  Label old_generator;
+  __ movp(rcx, FieldOperand(rdi, JSFunction::kSharedFunctionInfoOffset));
+  __ movp(rcx, FieldOperand(rcx, SharedFunctionInfo::kFunctionDataOffset));
+  __ CmpObjectType(rcx, BYTECODE_ARRAY_TYPE, rcx);
+  __ j(not_equal, &old_generator);
 
-  // Restore the operand stack.
-  __ movp(rsi, FieldOperand(rbx, JSGeneratorObject::kOperandStackOffset));
-  __ SmiToInteger32(rax, FieldOperand(rsi, FixedArray::kLengthOffset));
+  // New-style (ignition/turbofan) generator object.
   {
-    Label done_loop, loop;
-    __ Set(rcx, 0);
-    __ bind(&loop);
-    __ cmpl(rcx, rax);
-    __ j(equal, &done_loop, Label::kNear);
-    __ Push(
-        FieldOperand(rsi, rcx, times_pointer_size, FixedArray::kHeaderSize));
-    __ addl(rcx, Immediate(1));
-    __ jmp(&loop);
-    __ bind(&done_loop);
-  }
+    __ PushReturnAddressFrom(rax);
+    __ movp(rax, FieldOperand(rdi, JSFunction::kSharedFunctionInfoOffset));
+    __ LoadSharedFunctionInfoSpecialField(
+        rax, rax, SharedFunctionInfo::kFormalParameterCountOffset);
+    // We abuse new.target both to indicate that this is a resume call and to
+    // pass in the generator object.  In ordinary calls, new.target is always
+    // undefined because generator functions are non-constructable.
+    __ movp(rdx, rbx);
+    __ jmp(FieldOperand(rdi, JSFunction::kCodeEntryOffset));
+  }
+
+  // Old-style (full-codegen) generator object.
+  __ bind(&old_generator);
+  {
+    // Enter a new JavaScript frame, and initialize its slots as they were when
+    // the generator was suspended.
+    FrameScope scope(masm, StackFrame::MANUAL);
+    __ PushReturnAddressFrom(rax);  // Return address.
+    __ Push(rbp);                   // Caller's frame pointer.
+    __ Move(rbp, rsp);
+    __ Push(rsi);  // Callee's context.
+    __ Push(rdi);  // Callee's JS Function.
+
+    // Restore the operand stack.
+    __ movp(rsi, FieldOperand(rbx, JSGeneratorObject::kOperandStackOffset));
+    __ SmiToInteger32(rax, FieldOperand(rsi, FixedArray::kLengthOffset));
+    {
+      Label done_loop, loop;
+      __ Set(rcx, 0);
+      __ bind(&loop);
+      __ cmpl(rcx, rax);
+      __ j(equal, &done_loop, Label::kNear);
+      __ Push(
+          FieldOperand(rsi, rcx, times_pointer_size, FixedArray::kHeaderSize));
+      __ addl(rcx, Immediate(1));
+      __ jmp(&loop);
+      __ bind(&done_loop);
+    }
 
-  // Reset operand stack so we don't leak.
-  __ LoadRoot(FieldOperand(rbx, JSGeneratorObject::kOperandStackOffset),
-              Heap::kEmptyFixedArrayRootIndex);
+    // Reset operand stack so we don't leak.
+    __ LoadRoot(FieldOperand(rbx, JSGeneratorObject::kOperandStackOffset),
+                Heap::kEmptyFixedArrayRootIndex);
 
-  // Restore context.
-  __ movp(rsi, FieldOperand(rbx, JSGeneratorObject::kContextOffset));
+    // Restore context.
+    __ movp(rsi, FieldOperand(rbx, JSGeneratorObject::kContextOffset));
 
-  // Resume the generator function at the continuation.
-  __ movp(rdx, FieldOperand(rdi, JSFunction::kSharedFunctionInfoOffset));
-  __ movp(rdx, FieldOperand(rdx, SharedFunctionInfo::kCodeOffset));
-  __ SmiToInteger64(rcx,
-                    FieldOperand(rbx, JSGeneratorObject::kContinuationOffset));
-  __ leap(rdx, FieldOperand(rdx, rcx, times_1, Code::kHeaderSize));
-  __ Move(FieldOperand(rbx, JSGeneratorObject::kContinuationOffset),
-          Smi::FromInt(JSGeneratorObject::kGeneratorExecuting));
-  __ movp(rax, rbx);  // Continuation expects generator object in rax.
-  __ jmp(rdx);
+    // Resume the generator function at the continuation.
+    __ movp(rdx, FieldOperand(rdi, JSFunction::kSharedFunctionInfoOffset));
+    __ movp(rdx, FieldOperand(rdx, SharedFunctionInfo::kCodeOffset));
+    __ SmiToInteger64(
+        rcx, FieldOperand(rbx, JSGeneratorObject::kContinuationOffset));
+    __ leap(rdx, FieldOperand(rdx, rcx, times_1, Code::kHeaderSize));
+    __ Move(FieldOperand(rbx, JSGeneratorObject::kContinuationOffset),
+            Smi::FromInt(JSGeneratorObject::kGeneratorExecuting));
+    __ movp(rax, rbx);  // Continuation expects generator object in rax.
+    __ jmp(rdx);
+  }
 }
 
 // Generate code for entering a JS function with the interpreter.
diff --git a/test/cctest/interpreter/bytecode_expectations/Generators.golden b/test/cctest/interpreter/bytecode_expectations/Generators.golden
new file mode 100644
index 00000000000..580cc98b725
--- /dev/null
+++ b/test/cctest/interpreter/bytecode_expectations/Generators.golden
@@ -0,0 +1,629 @@
+#
+# Autogenerated by generate-bytecode-expectations.
+#
+
+---
+pool type: mixed
+execute: yes
+wrap: no
+test function name: f
+ignition generators: yes
+
+---
+snippet: "
+  function* f() { }
+"
+frame size: 11
+parameter count: 1
+bytecode array length: 201
+bytecodes: [
+  B(Ldar), R(new_target),
+  B(JumpIfUndefined), U8(15),
+  B(CallRuntime), U16(Runtime::kResumeIgnitionGenerator), R(new_target), U8(1),
+  B(Star), R(1),
+  B(LdaZero),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(54),
+  B(Illegal),
+  B(CallRuntime), U16(Runtime::kNewFunctionContext), R(closure), U8(1),
+  B(PushContext), R(0),
+  B(Ldar), R(this),
+  B(StaContextSlot), R(context), U8(4),
+  B(StackCheck),
+  B(Mov), R(context), R(3),
+  B(Ldar), R(closure),
+  B(Star), R(4),
+  B(LdaContextSlot), R(context), U8(4),
+  B(Star), R(5),
+  B(CallRuntime), U16(Runtime::kCreateJSGeneratorObject), R(4), U8(2),
+  B(StaContextSlot), R(context), U8(5),
+  B(Star), R(4),
+  B(LdaContextSlot), R(context), U8(5),
+  B(Star), R(5),
+  B(LdaZero),
+  B(Star), R(6),
+  B(CallRuntime), U16(Runtime::kSuspendIgnitionGenerator), R(5), U8(2),
+  B(Ldar), R(4),
+  B(Return),
+  B(CallRuntime), U16(Runtime::kGeneratorGetInput), R(5), U8(1),
+  B(Star), R(7),
+  B(CallRuntime), U16(Runtime::kGeneratorGetResumeMode), R(5), U8(1),
+  B(Star), R(8),
+  B(LdaZero),
+  B(TestEqualStrict), R(8),
+  B(JumpIfTrue), U8(31),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(8),
+  B(JumpIfTrue), U8(22),
+  B(Jump), U8(2),
+  B(Mov), R(7), R(9),
+  B(LdaTrue),
+  B(Star), R(10),
+  B(CallRuntime), U16(Runtime::kCreateIterResultObject), R(9), U8(2),
+  B(Star), R(2),
+  B(LdaZero),
+  B(Star), R(1),
+  B(Jump), U8(38),
+  B(Ldar), R(7),
+  B(Throw),
+  B(Ldar), R(7),
+  B(LdaUndefined),
+  B(Star), R(4),
+  B(LdaTrue),
+  B(Star), R(5),
+  B(CallRuntime), U16(Runtime::k_CreateIterResultObject), R(4), U8(2),
+  B(Star), R(2),
+  B(LdaSmi), U8(1),
+  B(Star), R(1),
+  B(Jump), U8(14),
+  B(LdaSmi), U8(-1),
+  B(Star), R(1),
+  B(Jump), U8(8),
+  B(Star), R(2),
+  B(LdaSmi), U8(2),
+  B(Star), R(1),
+  B(CallRuntime), U16(Runtime::kInterpreterClearPendingMessage), R(0), U8(0),
+  B(Star), R(3),
+  B(LdaContextSlot), R(context), U8(5),
+  B(Star), R(4),
+  B(CallRuntime), U16(Runtime::kGeneratorClose), R(4), U8(1),
+  B(CallRuntime), U16(Runtime::kInterpreterSetPendingMessage), R(3), U8(1),
+  B(LdaZero),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(16),
+  B(LdaSmi), U8(1),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(13),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(10),
+  B(Jump), U8(11),
+  B(Ldar), R(2),
+  B(Return),
+  B(Ldar), R(2),
+  B(Return),
+  B(Ldar), R(2),
+  B(ReThrow),
+  B(LdaUndefined),
+  B(Return),
+]
+constant pool: [
+]
+handlers: [
+  [33, 137, 143],
+]
+
+---
+snippet: "
+  function* f() { yield 42 }
+"
+frame size: 11
+parameter count: 1
+bytecode array length: 298
+bytecodes: [
+  B(Ldar), R(new_target),
+  B(JumpIfUndefined), U8(21),
+  B(CallRuntime), U16(Runtime::kResumeIgnitionGenerator), R(new_target), U8(1),
+  B(Star), R(1),
+  B(LdaZero),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(60),
+  B(LdaSmi), U8(1),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrueConstant), U8(0),
+  B(Illegal),
+  B(CallRuntime), U16(Runtime::kNewFunctionContext), R(closure), U8(1),
+  B(PushContext), R(0),
+  B(Ldar), R(this),
+  B(StaContextSlot), R(context), U8(4),
+  B(StackCheck),
+  B(Mov), R(context), R(3),
+  B(Ldar), R(closure),
+  B(Star), R(4),
+  B(LdaContextSlot), R(context), U8(4),
+  B(Star), R(5),
+  B(CallRuntime), U16(Runtime::kCreateJSGeneratorObject), R(4), U8(2),
+  B(StaContextSlot), R(context), U8(5),
+  B(Star), R(4),
+  B(LdaContextSlot), R(context), U8(5),
+  B(Star), R(5),
+  B(LdaZero),
+  B(Star), R(6),
+  B(CallRuntime), U16(Runtime::kSuspendIgnitionGenerator), R(5), U8(2),
+  B(Ldar), R(4),
+  B(Return),
+  B(CallRuntime), U16(Runtime::kGeneratorGetInput), R(5), U8(1),
+  B(Star), R(7),
+  B(CallRuntime), U16(Runtime::kGeneratorGetResumeMode), R(5), U8(1),
+  B(Star), R(8),
+  B(LdaZero),
+  B(TestEqualStrict), R(8),
+  B(JumpIfTrue), U8(31),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(8),
+  B(JumpIfTrue), U8(22),
+  B(Jump), U8(2),
+  B(Mov), R(7), R(9),
+  B(LdaTrue),
+  B(Star), R(10),
+  B(CallRuntime), U16(Runtime::kCreateIterResultObject), R(9), U8(2),
+  B(Star), R(2),
+  B(LdaZero),
+  B(Star), R(1),
+  B(Jump), U8(120),
+  B(Ldar), R(7),
+  B(Throw),
+  B(Ldar), R(7),
+  B(LdaSmi), U8(42),
+  B(Star), R(4),
+  B(LdaFalse),
+  B(Star), R(5),
+  B(CallRuntime), U16(Runtime::k_CreateIterResultObject), R(4), U8(2),
+  B(Star), R(6),
+  B(LdaContextSlot), R(context), U8(5),
+  B(Star), R(4),
+  B(LdaSmi), U8(1),
+  B(Star), R(5),
+  B(CallRuntime), U16(Runtime::kSuspendIgnitionGenerator), R(4), U8(2),
+  B(Ldar), R(6),
+  B(Return),
+  B(CallRuntime), U16(Runtime::kGeneratorGetInput), R(4), U8(1),
+  B(Star), R(7),
+  B(CallRuntime), U16(Runtime::kGeneratorGetResumeMode), R(4), U8(1),
+  B(Star), R(8),
+  B(LdaZero),
+  B(TestEqualStrict), R(8),
+  B(JumpIfTrue), U8(32),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(8),
+  B(JumpIfTrue), U8(23),
+  B(Jump), U8(2),
+  B(Mov), R(7), R(9),
+  B(LdaTrue),
+  B(Star), R(10),
+  B(CallRuntime), U16(Runtime::kCreateIterResultObject), R(9), U8(2),
+  B(Star), R(2),
+  B(LdaSmi), U8(1),
+  B(Star), R(1),
+  B(Jump), U8(38),
+  B(Ldar), R(7),
+  B(Throw),
+  B(Ldar), R(7),
+  B(LdaUndefined),
+  B(Star), R(4),
+  B(LdaTrue),
+  B(Star), R(5),
+  B(CallRuntime), U16(Runtime::k_CreateIterResultObject), R(4), U8(2),
+  B(Star), R(2),
+  B(LdaSmi), U8(2),
+  B(Star), R(1),
+  B(Jump), U8(14),
+  B(LdaSmi), U8(-1),
+  B(Star), R(1),
+  B(Jump), U8(8),
+  B(Star), R(2),
+  B(LdaSmi), U8(3),
+  B(Star), R(1),
+  B(CallRuntime), U16(Runtime::kInterpreterClearPendingMessage), R(0), U8(0),
+  B(Star), R(3),
+  B(LdaContextSlot), R(context), U8(5),
+  B(Star), R(4),
+  B(CallRuntime), U16(Runtime::kGeneratorClose), R(4), U8(1),
+  B(CallRuntime), U16(Runtime::kInterpreterSetPendingMessage), R(3), U8(1),
+  B(LdaZero),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(22),
+  B(LdaSmi), U8(1),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(19),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(16),
+  B(LdaSmi), U8(3),
+  B(TestEqualStrict), R(1),
+  B(JumpIfTrue), U8(13),
+  B(Jump), U8(14),
+  B(Ldar), R(2),
+  B(Return),
+  B(Ldar), R(2),
+  B(Return),
+  B(Ldar), R(2),
+  B(Return),
+  B(Ldar), R(2),
+  B(ReThrow),
+  B(LdaUndefined),
+  B(Return),
+]
+constant pool: [
+  kInstanceTypeDontCare,
+]
+handlers: [
+  [39, 225, 231],
+]
+
+---
+snippet: "
+  function* f() { for (let x of [42]) yield x }
+"
+frame size: 17
+parameter count: 1
+bytecode array length: 786
+bytecodes: [
+  B(Ldar), R(new_target),
+  B(JumpIfUndefined), U8(21),
+  B(CallRuntime), U16(Runtime::kResumeIgnitionGenerator), R(new_target), U8(1),
+  B(Star), R(3),
+  B(LdaZero),
+  B(TestEqualStrict), R(3),
+  B(JumpIfTrue), U8(60),
+  B(LdaSmi), U8(1),
+  B(TestEqualStrict), R(3),
+  B(JumpIfTrueConstant), U8(8),
+  B(Illegal),
+  B(CallRuntime), U16(Runtime::kNewFunctionContext), R(closure), U8(1),
+  B(PushContext), R(0),
+  B(Ldar), R(this),
+  B(StaContextSlot), R(context), U8(4),
+  B(StackCheck),
+  B(Mov), R(context), R(5),
+  B(Ldar), R(closure),
+  B(Star), R(6),
+  B(LdaContextSlot), R(context), U8(4),
+  B(Star), R(7),
+  B(CallRuntime), U16(Runtime::kCreateJSGeneratorObject), R(6), U8(2),
+  B(StaContextSlot), R(context), U8(5),
+  B(Star), R(6),
+  B(LdaContextSlot), R(context), U8(5),
+  B(Star), R(7),
+  B(LdaZero),
+  B(Star), R(8),
+  B(CallRuntime), U16(Runtime::kSuspendIgnitionGenerator), R(7), U8(2),
+  B(Ldar), R(6),
+  B(Return),
+  B(CallRuntime), U16(Runtime::kGeneratorGetInput), R(7), U8(1),
+  B(Star), R(9),
+  B(CallRuntime), U16(Runtime::kGeneratorGetResumeMode), R(7), U8(1),
+  B(Star), R(10),
+  B(LdaZero),
+  B(TestEqualStrict), R(10),
+  B(JumpIfTrue), U8(31),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(10),
+  B(JumpIfTrue), U8(22),
+  B(Jump), U8(2),
+  B(Mov), R(9), R(11),
+  B(LdaTrue),
+  B(Star), R(12),
+  B(CallRuntime), U16(Runtime::kCreateIterResultObject), R(11), U8(2),
+  B(Star), R(4),
+  B(LdaZero),
+  B(Star), R(3),
+  B(JumpConstant), U8(16),
+  B(Ldar), R(9),
+  B(Throw),
+  B(Ldar), R(9),
+  B(LdaConstant), U8(0),
+  B(Star), R(6),
+  B(Ldar), R(closure),
+  B(Star), R(7),
+  B(CallRuntime), U16(Runtime::kPushBlockContext), R(6), U8(2),
+  B(PushContext), R(1),
+  B(LdaTheHole),
+  B(StaContextSlot), R(context), U8(4),
+  B(LdaUndefined),
+  B(StaContextSlot), R(1), U8(10),
+  B(LdaZero),
+  B(StaContextSlot), R(1), U8(9),
+  B(Mov), R(context), R(8),
+  B(Mov), R(context), R(9),
+  B(CreateArrayLiteral), U8(1), U8(0), U8(3),
+  B(Star), R(11),
+  B(LdaConstant), U8(2),
+  B(KeyedLoadIC), R(11), U8(3),
+  B(Star), R(10),
+  B(Call), R(10), R(11), U8(1), U8(1),
+  B(StaContextSlot), R(1), U8(7),
+  B(LdaContextSlot), R(1), U8(7),
+  B(Star), R(12),
+  B(LoadIC), R(12), U8(3), U8(7),
+  B(Star), R(11),
+  B(Call), R(11), R(12), U8(1), U8(5),
+  B(StaContextSlot), R(1), U8(8),
+  B(Star), R(10),
+  B(InvokeIntrinsic), U16(Runtime::k_IsJSReceiver), R(10), U8(1),
+  B(LogicalNot),
+  B(JumpIfFalse), U8(12),
+  B(LdaContextSlot), R(1), U8(8),
+  B(Star), R(10),
+  B(CallRuntime), U16(Runtime::kThrowIteratorResultNotAnObject), R(10), U8(1),
+  B(LdaContextSlot), R(1), U8(8),
+  B(Star), R(10),
+  B(LoadIC), R(10), U8(4), U8(9),
+  B(JumpIfToBooleanTrueConstant), U8(9),
+  B(LdaSmi), U8(2),
+  B(StaContextSlot), R(1), U8(9),
+  B(LdaContextSlot), R(1), U8(8),
+  B(Star), R(10),
+  B(LoadIC), R(10), U8(5), U8(11),
+  B(StaContextSlot), R(1), U8(6),
+  B(LdaContextSlot), R(1), U8(10),
+  B(StackCheck),
+  B(LdaConstant), U8(6),
+  B(Star), R(10),
+  B(Ldar), R(closure),
+  B(Star), R(11),
+  B(CallRuntime), U16(Runtime::kPushBlockContext), R(10), U8(2),
+  B(PushContext), R(2),
+  B(LdaTheHole),
+  B(StaContextSlot), R(context), U8(4),
+  B(LdaContextSlot), R(1), U8(6),
+  B(StaContextSlot), R(context), U8(4),
+  B(LdaContextSlot), R(context), U8(4),
+  B(JumpIfNotHole), U8(11),
+  B(LdaConstant), U8(7),
+  B(Star), R(11),
+  B(CallRuntime), U16(Runtime::kThrowReferenceError), R(11), U8(1),
+  B(Star), R(10),
+  B(LdaFalse),
+  B(Star), R(11),
+  B(CallRuntime), U16(Runtime::k_CreateIterResultObject), R(10), U8(2),
+  B(Star), R(12),
+  B(LdaContextSlot), R(1), U8(5),
+  B(Star), R(10),
+  B(LdaSmi), U8(1),
+  B(Star), R(11),
+  B(CallRuntime), U16(Runtime::kSuspendIgnitionGenerator), R(10), U8(2),
+  B(Ldar), R(12),
+  B(Return),
+  B(CallRuntime), U16(Runtime::kGeneratorGetInput), R(10), U8(1),
+  B(Star), R(13),
+  B(CallRuntime), U16(Runtime::kGeneratorGetResumeMode), R(10), U8(1),
+  B(Star), R(14),
+  B(LdaZero),
+  B(TestEqualStrict), R(14),
+  B(JumpIfTrue), U8(45),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(14),
+  B(JumpIfTrue), U8(36),
+  B(Jump), U8(2),
+  B(Mov), R(13), R(15),
+  B(LdaTrue),
+  B(Star), R(16),
+  B(CallRuntime), U16(Runtime::kCreateIterResultObject), R(15), U8(2),
+  B(PopContext), R(2),
+  B(PopContext), R(2),
+  B(PopContext), R(2),
+  B(PopContext), R(2),
+  B(PopContext), R(2),
+  B(PopContext), R(2),
+  B(PopContext), R(2),
+  B(Star), R(7),
+  B(LdaZero),
+  B(Star), R(6),
+  B(Jump), U8(78),
+  B(Ldar), R(13),
+  B(Throw),
+  B(Ldar), R(13),
+  B(PopContext), R(2),
+  B(LdaZero),
+  B(StaContextSlot), R(1), U8(9),
+  B(Wide), B(Jump), U16(-210),
+  B(Jump), U8(49),
+  B(Star), R(11),
+  B(LdaConstant), U8(10),
+  B(Star), R(10),
+  B(Ldar), R(closure),
+  B(Star), R(12),
+  B(CallRuntime), U16(Runtime::kPushCatchContext), R(10), U8(3),
+  B(Star), R(9),
+  B(PushContext), R(2),
+  B(LdaContextSlot), R(1), U8(9),
+  B(Star), R(10),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(10),
+  B(JumpIfFalse), U8(7),
+  B(LdaSmi), U8(1),
+  B(StaContextSlot), R(1), U8(9),
+  B(LdaContextSlot), R(context), U8(4),
+  B(Star), R(10),
+  B(CallRuntime), U16(Runtime::kReThrow), R(10), U8(1),
+  B(PopContext), R(2),
+  B(LdaSmi), U8(-1),
+  B(Star), R(6),
+  B(Jump), U8(8),
+  B(Star), R(7),
+  B(LdaSmi), U8(1),
+  B(Star), R(6),
+  B(CallRuntime), U16(Runtime::kInterpreterClearPendingMessage), R(0), U8(0),
+  B(Star), R(8),
+  B(LdaContextSlot), R(1), U8(9),
+  B(Star), R(9),
+  B(LdaZero),
+  B(TestEqualStrict), R(9),
+  B(JumpIfTrue), U8(10),
+  B(LdaContextSlot), R(1), U8(7),
+  B(Star), R(9),
+  B(LdaUndefined),
+  B(TestEqualStrict), R(9),
+  B(LogicalNot),
+  B(JumpIfFalseConstant), U8(15),
+  B(LdaContextSlot), R(1), U8(7),
+  B(Star), R(9),
+  B(LoadIC), R(9), U8(11), U8(13),
+  B(StaContextSlot), R(1), U8(11),
+  B(LdaContextSlot), R(1), U8(11),
+  B(Star), R(9),
+  B(LdaNull),
+  B(TestEqual), R(9),
+  B(JumpIfFalse), U8(4),
+  B(JumpConstant), U8(14),
+  B(LdaContextSlot), R(1), U8(9),
+  B(Star), R(9),
+  B(LdaSmi), U8(1),
+  B(TestEqualStrict), R(9),
+  B(JumpIfFalse), U8(82),
+  B(LdaContextSlot), R(1), U8(11),
+  B(TypeOf),
+  B(Star), R(9),
+  B(LdaConstant), U8(12),
+  B(TestEqualStrict), R(9),
+  B(JumpIfFalse), U8(4),
+  B(Jump), U8(18),
+  B(Wide), B(LdaSmi), U16(139),
+  B(Star), R(9),
+  B(LdaConstant), U8(13),
+  B(Star), R(10),
+  B(CallRuntime), U16(Runtime::kNewTypeError), R(9), U8(2),
+  B(Throw),
+  B(Mov), R(context), R(9),
+  B(LdaContextSlot), R(1), U8(11),
+  B(Star), R(10),
+  B(LdaContextSlot), R(1), U8(7),
+  B(Star), R(11),
+  B(CallRuntime), U16(Runtime::k_Call), R(10), U8(2),
+  B(Jump), U8(30),
+  B(Star), R(11),
+  B(LdaConstant), U8(10),
+  B(Star), R(10),
+  B(Ldar), R(closure),
+  B(Star), R(12),
+  B(CallRuntime), U16(Runtime::kPushCatchContext), R(10), U8(3),
+  B(Star), R(9),
+  B(CallRuntime), U16(Runtime::kInterpreterClearPendingMessage), R(0), U8(0),
+  B(Ldar), R(9),
+  B(PushContext), R(2),
+  B(PopContext), R(2),
+  B(Jump), U8(44),
+  B(LdaContextSlot), R(1), U8(11),
+  B(Star), R(9),
+  B(LdaContextSlot), R(1), U8(7),
+  B(Star), R(10),
+  B(CallRuntime), U16(Runtime::k_Call), R(9), U8(2),
+  B(StaContextSlot), R(1), U8(12),
+  B(LdaContextSlot), R(1), U8(12),
+  B(Star), R(9),
+  B(InvokeIntrinsic), U16(Runtime::k_IsJSReceiver), R(9), U8(1),
+  B(JumpIfToBooleanFalse), U8(4),
+  B(Jump), U8(12),
+  B(LdaContextSlot), R(1), U8(12),
+  B(Star), R(9),
+  B(CallRuntime), U16(Runtime::kThrowIteratorResultNotAnObject), R(9), U8(1),
+  B(CallRuntime), U16(Runtime::kInterpreterSetPendingMessage), R(8), U8(1),
+  B(LdaZero),
+  B(TestEqualStrict), R(6),
+  B(JumpIfTrue), U8(10),
+  B(LdaSmi), U8(1),
+  B(TestEqualStrict), R(6),
+  B(JumpIfTrue), U8(18),
+  B(Jump), U8(30),
+  B(Ldar), R(7),
+  B(PopContext), R(1),
+  B(PopContext), R(1),
+  B(Star), R(4),
+  B(LdaSmi), U8(1),
+  B(Star), R(3),
+  B(Jump), U8(49),
+  B(Ldar), R(7),
+  B(PopContext), R(1),
+  B(PopContext), R(1),
+  B(Star), R(4),
+  B(LdaSmi), U8(2),
+  B(Star), R(3),
+  B(Jump), U8(35),
+  B(PopContext), R(1),
+  B(LdaUndefined),
+  B(Star), R(6),
+  B(LdaTrue),
+  B(Star), R(7),
+  B(CallRuntime), U16(Runtime::k_CreateIterResultObject), R(6), U8(2),
+  B(Star), R(4),
+  B(LdaSmi), U8(3),
+  B(Star), R(3),
+  B(Jump), U8(14),
+  B(LdaSmi), U8(-1),
+  B(Star), R(3),
+  B(Jump), U8(8),
+  B(Star), R(4),
+  B(LdaSmi), U8(4),
+  B(Star), R(3),
+  B(CallRuntime), U16(Runtime::kInterpreterClearPendingMessage), R(0), U8(0),
+  B(Star), R(5),
+  B(LdaContextSlot), R(context), U8(5),
+  B(Star), R(6),
+  B(CallRuntime), U16(Runtime::kGeneratorClose), R(6), U8(1),
+  B(CallRuntime), U16(Runtime::kInterpreterSetPendingMessage), R(5), U8(1),
+  B(LdaZero),
+  B(TestEqualStrict), R(3),
+  B(JumpIfTrue), U8(28),
+  B(LdaSmi), U8(1),
+  B(TestEqualStrict), R(3),
+  B(JumpIfTrue), U8(25),
+  B(LdaSmi), U8(2),
+  B(TestEqualStrict), R(3),
+  B(JumpIfTrue), U8(22),
+  B(LdaSmi), U8(3),
+  B(TestEqualStrict), R(3),
+  B(JumpIfTrue), U8(19),
+  B(LdaSmi), U8(4),
+  B(TestEqualStrict), R(3),
+  B(JumpIfTrue), U8(16),
+  B(Jump), U8(17),
+  B(Ldar), R(4),
+  B(Return),
+  B(Ldar), R(4),
+  B(Return),
+  B(Ldar), R(4),
+  B(ReThrow),
+  B(Ldar), R(4),
+  B(Return),
+  B(Ldar), R(4),
+  B(ReThrow),
+  B(LdaUndefined),
+  B(Return),
+]
+constant pool: [
+  InstanceType::FIXED_ARRAY_TYPE,
+  InstanceType::FIXED_ARRAY_TYPE,
+  InstanceType::SYMBOL_TYPE,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  InstanceType::FIXED_ARRAY_TYPE,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  kInstanceTypeDontCare,
+  kInstanceTypeDontCare,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  InstanceType::ONE_BYTE_INTERNALIZED_STRING_TYPE,
+  kInstanceTypeDontCare,
+  kInstanceTypeDontCare,
+  kInstanceTypeDontCare,
+]
+handlers: [
+  [39, 704, 710],
+  [154, 440, 446],
+  [157, 391, 393],
+  [548, 563, 565],
+]
+
diff --git a/test/cctest/interpreter/generate-bytecode-expectations.cc b/test/cctest/interpreter/generate-bytecode-expectations.cc
index 92ba9ba0bd4..bba382340a2 100644
--- a/test/cctest/interpreter/generate-bytecode-expectations.cc
+++ b/test/cctest/interpreter/generate-bytecode-expectations.cc
@@ -44,6 +44,7 @@ class ProgramOptions final {
         execute_(true),
         top_level_(false),
         do_expressions_(false),
+        ignition_generators_(false),
         verbose_(false),
         const_pool_type_(
             BytecodeExpectationsPrinter::ConstantPoolType::kMixed) {}
@@ -64,6 +65,7 @@ class ProgramOptions final {
   bool execute() const { return execute_; }
   bool top_level() const { return top_level_; }
   bool do_expressions() const { return do_expressions_; }
+  bool ignition_generators() const { return ignition_generators_; }
   bool verbose() const { return verbose_; }
   bool suppress_runtime_errors() const { return rebaseline_ && !verbose_; }
   BytecodeExpectationsPrinter::ConstantPoolType const_pool_type() const {
@@ -83,6 +85,7 @@ class ProgramOptions final {
   bool execute_;
   bool top_level_;
   bool do_expressions_;
+  bool ignition_generators_;
   bool verbose_;
   BytecodeExpectationsPrinter::ConstantPoolType const_pool_type_;
   std::vector<std::string> input_filenames_;
@@ -212,6 +215,8 @@ ProgramOptions ProgramOptions::FromCommandLine(int argc, char** argv) {
       options.top_level_ = true;
     } else if (strcmp(argv[i], "--do-expressions") == 0) {
       options.do_expressions_ = true;
+    } else if (strcmp(argv[i], "--ignition-generators") == 0) {
+      options.ignition_generators_ = true;
     } else if (strcmp(argv[i], "--verbose") == 0) {
       options.verbose_ = true;
     } else if (strncmp(argv[i], "--output=", 9) == 0) {
@@ -316,6 +321,8 @@ void ProgramOptions::UpdateFromHeader(std::istream& stream) {
       top_level_ = ParseBoolean(line.c_str() + 11);
     } else if (line.compare(0, 16, "do expressions: ") == 0) {
       do_expressions_ = ParseBoolean(line.c_str() + 16);
+    } else if (line.compare(0, 21, "ignition generators: ") == 0) {
+      do_expressions_ = ParseBoolean(line.c_str() + 21);
     } else if (line == "---") {
       break;
     } else if (line.empty()) {
@@ -340,6 +347,7 @@ void ProgramOptions::PrintHeader(std::ostream& stream) const {  // NOLINT
 
   if (top_level_) stream << "\ntop level: yes";
   if (do_expressions_) stream << "\ndo expressions: yes";
+  if (ignition_generators_) stream << "\nignition generators: yes";
 
   stream << "\n\n";
 }
@@ -445,6 +453,7 @@ void GenerateExpectationsFile(std::ostream& stream,  // NOLINT
   }
 
   if (options.do_expressions()) i::FLAG_harmony_do_expressions = true;
+  if (options.ignition_generators()) i::FLAG_ignition_generators = true;
 
   stream << "#\n# Autogenerated by generate-bytecode-expectations.\n#\n\n";
   options.PrintHeader(stream);
@@ -497,6 +506,7 @@ void PrintUsage(const char* exec_path) {
          "Specify the name of the test function.\n"
          "  --top-level   Process top level code, not the top-level function.\n"
          "  --do-expressions  Enable harmony_do_expressions flag.\n"
+         "  --ignition-generators  Enable ignition_generators flag.\n"
          "  --output=file.name\n"
          "      Specify the output file. If not specified, output goes to "
          "stdout.\n"
diff --git a/test/cctest/interpreter/test-bytecode-generator.cc b/test/cctest/interpreter/test-bytecode-generator.cc
index 74518a7f4ed..b51ebca0241 100644
--- a/test/cctest/interpreter/test-bytecode-generator.cc
+++ b/test/cctest/interpreter/test-bytecode-generator.cc
@@ -2149,6 +2149,29 @@ TEST(ClassAndSuperClass) {
            LoadGolden("ClassAndSuperClass.golden"));
 }
 
+TEST(Generators) {
+  bool old_flag = FLAG_ignition_generators;
+  FLAG_ignition_generators = true;
+
+  InitializedIgnitionHandleScope scope;
+  BytecodeExpectationsPrinter printer(CcTest::isolate(),
+                                      ConstantPoolType::kMixed);
+  printer.set_wrap(false);
+  printer.set_test_function_name("f");
+
+  const char* snippets[] = {
+      "function* f() { }",
+
+      "function* f() { yield 42 }",
+
+      "function* f() { for (let x of [42]) yield x }",
+  };
+
+  CHECK_EQ(BuildActual(printer, snippets), LoadGolden("Generators.golden"));
+
+  FLAG_ignition_generators = old_flag;
+}
+
 }  // namespace interpreter
 }  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/interpreter/test-interpreter.cc b/test/cctest/interpreter/test-interpreter.cc
index c8dc7760109..49089664089 100644
--- a/test/cctest/interpreter/test-interpreter.cc
+++ b/test/cctest/interpreter/test-interpreter.cc
@@ -4139,6 +4139,37 @@ TEST(InterpreterIllegalConstDeclaration) {
   }
 }
 
+TEST(InterpreterGenerators) {
+  bool old_flag = FLAG_ignition_generators;
+  FLAG_ignition_generators = true;
+
+  HandleAndZoneScope handles;
+  i::Isolate* isolate = handles.main_isolate();
+  i::Factory* factory = isolate->factory();
+
+  std::pair<const char*, Handle<Object>> tests[] = {
+      {"function* f() { }; return f().next().value",
+       factory->undefined_value()},
+      {"function* f() { yield 42 }; return f().next().value",
+       factory->NewNumberFromInt(42)},
+      {"function* f() { for (let x of [42]) yield x}; return f().next().value",
+       factory->NewNumberFromInt(42)},
+  };
+
+  for (size_t i = 0; i < arraysize(tests); i++) {
+    std::string source(
+        InterpreterTester::SourceForBody(tests[i].first));
+    InterpreterTester tester(handles.main_isolate(), source.c_str());
+    auto callable = tester.GetCallable<>();
+
+    Handle<i::Object> return_value = callable().ToHandleChecked();
+    CHECK(return_value->SameValue(*tests[i].second));
+  }
+
+  FLAG_ignition_generators = old_flag;
+}
+
+
 }  // namespace interpreter
 }  // namespace internal
 }  // namespace v8
diff --git a/test/mjsunit/harmony/generators.js b/test/mjsunit/harmony/generators.js
index df6cec89253..74bd4876066 100644
--- a/test/mjsunit/harmony/generators.js
+++ b/test/mjsunit/harmony/generators.js
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+// Flags: --ignition-generators --harmony-do-expressions
+
 
 { // yield in try-catch
 
@@ -270,3 +272,306 @@
     assertEquals({value: 42, done: true}, x.return(42));
   }
 }
+
+
+// More or less random tests from here on.
+
+
+{
+  function* foo() { }
+  let g = foo();
+  assertEquals({value: undefined, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() { return new.target }
+  let g = foo();
+  assertEquals({value: undefined, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() { throw 666; return 42}
+  let g = foo();
+  assertThrowsEquals(() => g.next(), 666);
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo(a) { return a; }
+  let g = foo(42);
+  assertEquals({value: 42, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo(a) { a.iwashere = true; return a; }
+  let x = {};
+  let g = foo(x);
+  assertEquals({value: {iwashere: true}, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  let a = 42;
+  function* foo() { return a; }
+  let g = foo();
+  assertEquals({value: 42, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  let a = 40;
+  function* foo(b) { return a + b; }
+  let g = foo(2);
+  assertEquals({value: 42, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  let a = 40;
+  function* foo(b) { a--; b++; return a + b; }
+  let g = foo(2);
+  assertEquals({value: 42, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  let g;
+  function* foo() { g.next() }
+  g = foo();
+  assertThrows(() => g.next(), TypeError);
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() { yield 2; yield 3; yield 4 }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 4, done: false}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() { yield 2; if (true) { yield 3 }; yield 4 }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 4, done: false}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() { yield 2; if (true) { yield 3; yield 4 } }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 4, done: false}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() { yield 2; if (false) { yield 3 }; yield 4 }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 4, done: false}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() { yield 2; while (true) { yield 3 }; yield 4 }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+}
+
+{
+  function* foo() { yield 2; (yield 3) + 42; yield 4 }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 4, done: false}, g.next());
+}
+
+{
+  function* foo() { yield 2; (do {yield 3}) + 42; yield 4 }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 4, done: false}, g.next());
+}
+
+{
+  function* foo() { yield 2; return (yield 3) + 42; yield 4 }
+  g = foo();
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 42, done: true}, g.next(0));
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  let x = 42;
+  function* foo() {
+    yield x;
+    for (let x in {a: 1, b: 2}) {
+      let i = 2;
+      yield x;
+      yield i;
+      do {
+        yield i;
+      } while (i-- > 0);
+    }
+    yield x;
+    return 5;
+  }
+  g = foo();
+  assertEquals({value: 42, done: false}, g.next());
+  assertEquals({value: 'a', done: false}, g.next());
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 1, done: false}, g.next());
+  assertEquals({value: 0, done: false}, g.next());
+  assertEquals({value: 'b', done: false}, g.next());
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 1, done: false}, g.next());
+  assertEquals({value: 0, done: false}, g.next());
+  assertEquals({value: 42, done: false}, g.next());
+  assertEquals({value: 5, done: true}, g.next());
+}
+
+{
+  let a = 3;
+  function* foo() {
+    let b = 4;
+    yield 1;
+    { let c = 5; yield 2; yield a; yield b; yield c; }
+  }
+  g = foo();
+  assertEquals({value: 1, done: false}, g.next());
+  assertEquals({value: 2, done: false}, g.next());
+  assertEquals({value: 3, done: false}, g.next());
+  assertEquals({value: 4, done: false}, g.next());
+  assertEquals({value: 5, done: false}, g.next());
+  assertEquals({value: undefined, done: true}, g.next());
+}
+
+{
+  function* foo() {
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+    yield 42;
+  }
+  g = foo();
+  for (let i = 0; i < 100; ++i) {
+    assertEquals({value: 42, done: false}, g.next());
+  }
+  assertEquals({value: undefined, done: true}, g.next());
+}
-- 
2.35.1


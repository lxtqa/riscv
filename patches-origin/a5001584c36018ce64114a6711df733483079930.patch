From a5001584c36018ce64114a6711df733483079930 Mon Sep 17 00:00:00 2001
From: Leszek Swirski <leszeks@chromium.org>
Date: Tue, 5 Sep 2023 17:17:36 +0200
Subject: [PATCH] [tagged-ptr] Remove Smi & Object constructors

Remove the last remaining way of creating raw Smi and Object, instead of
using Tagged<Smi>/Tagged<Object>.

This reverts the default constructor of Tagged<Object> to initialise
with kNullAddress instead of kZapValue, since there were too many places
relying on this initialisation for subsequent checks.

Bug: v8:12710
Change-Id: I6a591d0bf95bc4659552dbcbcfd561664afb14f7
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4839257
Reviewed-by: Michael Lippautz <mlippautz@chromium.org>
Auto-Submit: Leszek Swirski <leszeks@chromium.org>
Commit-Queue: Leszek Swirski <leszeks@chromium.org>
Cr-Commit-Position: refs/heads/main@{#89804}
---
 include/v8-value.h                            |   2 +-
 src/api/api-arguments-inl.h                   |   2 +-
 src/api/api-arguments.cc                      |   6 +-
 src/api/api-inl.h                             |   6 +-
 src/api/api-natives.cc                        |   2 +-
 src/api/api.cc                                |  40 +++---
 src/builtins/builtins-microtask-queue-gen.cc  |   2 +-
 src/builtins/builtins-typed-array-gen.cc      |   4 +-
 src/builtins/builtins-utils.h                 |   4 +-
 src/builtins/builtins.cc                      |   2 +-
 src/builtins/convert.tq                       |   6 -
 src/codegen/arm/assembler-arm-inl.h           |   2 +-
 src/codegen/arm64/assembler-arm64-inl.h       |   2 +-
 src/codegen/external-reference.cc             |  49 ++++----
 src/codegen/ia32/assembler-ia32-inl.h         |   2 +-
 src/codegen/loong64/assembler-loong64-inl.h   |   2 +-
 src/codegen/mips64/assembler-mips64-inl.h     |   2 +-
 src/codegen/ppc/assembler-ppc-inl.h           |   9 +-
 src/codegen/riscv/assembler-riscv-inl.h       |   2 +-
 src/codegen/s390/assembler-s390-inl.h         |   9 +-
 src/codegen/x64/assembler-x64-inl.h           |   2 +-
 src/compiler/code-assembler.cc                |   2 +-
 src/compiler/graph-visualizer.cc              |   2 +-
 src/compiler/js-call-reducer.cc               |   3 +-
 src/compiler/js-heap-broker.h                 |   2 +-
 src/compiler/pipeline.cc                      |   2 +-
 .../turboshaft/fast-api-call-reducer.h        |   4 +-
 src/compiler/wasm-gc-lowering.cc              |  18 +--
 src/debug/debug.cc                            |   6 +-
 src/deoptimizer/deoptimizer.cc                |  19 +--
 src/deoptimizer/translated-state.cc           |  10 +-
 src/diagnostics/objects-printer.cc            |   4 +-
 src/execution/arguments-inl.h                 |   2 +-
 src/execution/arguments.h                     |   2 +-
 src/execution/execution.cc                    |  12 +-
 src/execution/frames-inl.h                    |  12 +-
 src/execution/frames.cc                       |  29 ++---
 src/execution/isolate.cc                      |   2 +-
 src/execution/isolate.h                       |   2 +-
 src/execution/microtask-queue.cc              |   2 +-
 src/execution/simulator-base.h                |   2 +-
 src/execution/thread-local-top.cc             |   2 +-
 src/handles/global-handles.cc                 |  10 +-
 src/handles/handles-inl.h                     |   6 +-
 src/heap/factory-base.h                       |   2 +-
 src/heap/heap-write-barrier.cc                |   8 +-
 src/heap/heap.cc                              |   9 +-
 src/heap/mark-compact.cc                      |   3 +-
 src/heap/objects-visiting.cc                  |   2 +-
 src/heap/read-only-promotion.cc               |   2 +-
 src/heap/remembered-set-inl.h                 |   6 +-
 src/heap/setup-heap-internal.cc               |  14 +--
 src/heap/zapping.cc                           |   3 +-
 src/ic/ic.cc                                  |   4 +-
 src/numbers/math-random.cc                    |   3 +-
 src/objects/bigint.cc                         | 114 ++++++++++--------
 src/objects/compressed-slots-inl.h            |  21 ++--
 src/objects/descriptor-array.h                |   3 +-
 src/objects/dictionary.h                      |   8 +-
 src/objects/elements.cc                       |  14 +--
 src/objects/embedder-data-slot-inl.h          |   5 +-
 src/objects/fixed-array-inl.h                 |   3 +-
 src/objects/free-space-inl.h                  |   2 +-
 src/objects/js-array-buffer.cc                |   5 +-
 src/objects/js-objects-inl.h                  |   2 +-
 src/objects/js-objects.cc                     |   2 +-
 src/objects/keys.cc                           |   2 +-
 src/objects/lookup.cc                         |   2 +-
 src/objects/map.h                             |   2 +-
 src/objects/object-macros.h                   |   2 -
 src/objects/object-type.cc                    |   4 +-
 src/objects/objects-inl.h                     |  10 +-
 src/objects/objects.cc                        |  13 +-
 src/objects/objects.h                         |   7 +-
 src/objects/simd.cc                           |  19 +--
 src/objects/slots-inl.h                       |  22 ++--
 src/objects/smi.h                             |  23 +---
 src/objects/string-table.cc                   |   2 +-
 src/objects/tagged-field-inl.h                |  24 ++--
 src/objects/tagged-impl-inl.h                 |  23 ++--
 src/objects/tagged-impl.cc                    |   4 +-
 src/objects/tagged-index.h                    |  21 +---
 src/objects/tagged-value-inl.h                |   5 +-
 src/objects/tagged.h                          |  38 ++----
 src/objects/transitions.h                     |   2 +-
 src/profiler/heap-snapshot-generator.cc       |   7 +-
 src/regexp/arm/regexp-macro-assembler-arm.cc  |   3 +-
 .../arm64/regexp-macro-assembler-arm64.cc     |   3 +-
 src/regexp/experimental/experimental.cc       |   4 +-
 .../ia32/regexp-macro-assembler-ia32.cc       |   3 +-
 .../loong64/regexp-macro-assembler-loong64.cc |   3 +-
 .../mips64/regexp-macro-assembler-mips64.cc   |   3 +-
 src/regexp/ppc/regexp-macro-assembler-ppc.cc  |   3 +-
 src/regexp/regexp-interpreter.cc              |   4 +-
 src/regexp/regexp-macro-assembler.cc          |   3 +-
 .../riscv/regexp-macro-assembler-riscv.cc     |   3 +-
 .../s390/regexp-macro-assembler-s390.cc       |   3 +-
 src/regexp/x64/regexp-macro-assembler-x64.cc  |   3 +-
 src/runtime/runtime-scopes.cc                 |   4 +-
 src/runtime/runtime-test.cc                   |   2 +-
 src/runtime/runtime-wasm.cc                   |   2 +-
 src/sandbox/indirect-pointer-inl.h            |   3 +-
 src/snapshot/read-only-serializer.cc          |   3 +-
 src/snapshot/snapshot.cc                      |   4 +-
 src/strings/string-stream.cc                  |   2 +-
 src/torque/implementation-visitor.cc          |  10 +-
 src/utils/address-map.cc                      |   2 +-
 src/wasm/c-api.cc                             |   7 +-
 src/wasm/constant-expression-interface.cc     |   4 +-
 src/wasm/wasm-debug.cc                        |   8 +-
 src/wasm/wasm-external-refs.cc                |  22 ++--
 src/wasm/wasm-objects.cc                      |   4 +-
 test/cctest/compiler/test-code-generator.cc   |   7 +-
 test/cctest/heap/test-heap.cc                 |   2 +-
 test/cctest/test-assembler-loong64.cc         |   3 +-
 test/cctest/test-assembler-mips64.cc          |   3 +-
 test/cctest/test-assembler-riscv32.cc         |   3 +-
 test/cctest/test-assembler-riscv64.cc         |   3 +-
 test/cctest/test-js-weak-refs.cc              |  12 +-
 test/cctest/test-mementos.cc                  |   2 +-
 test/cctest/test-shared-strings.cc            |   2 +-
 test/cctest/test-smi-lexicographic-compare.cc |   2 +-
 test/cctest/trace-extension.cc                |   6 +-
 test/cctest/wasm/test-gc.cc                   |   4 +-
 .../assembler/macro-assembler-x64-unittest.cc |   2 +-
 test/unittests/compiler/codegen-unittest.cc   |   2 +-
 test/unittests/heap/spaces-unittest.cc        |   6 +-
 .../objects/concurrent-js-array-unittest.cc   |   2 +-
 tools/grokdump.py                             |   2 +-
 129 files changed, 493 insertions(+), 464 deletions(-)

diff --git a/include/v8-value.h b/include/v8-value.h
index 19ecf71d16a..e24a45e359f 100644
--- a/include/v8-value.h
+++ b/include/v8-value.h
@@ -391,7 +391,7 @@ class V8_EXPORT Value : public Data {
   V8_WARN_UNUSED_RESULT MaybeLocal<String> ToDetailString(
       Local<Context> context) const;
   /**
-   * Perform the equivalent of `Object(value)` in JS.
+   * Perform the equivalent of `Tagged<Object>(value)` in JS.
    */
   V8_WARN_UNUSED_RESULT MaybeLocal<Object> ToObject(
       Local<Context> context) const;
diff --git a/src/api/api-arguments-inl.h b/src/api/api-arguments-inl.h
index b5aba465de7..563884b90ef 100644
--- a/src/api/api-arguments-inl.h
+++ b/src/api/api-arguments-inl.h
@@ -32,7 +32,7 @@ CustomArgumentsBase::CustomArgumentsBase(Isolate* isolate)
 
 template <typename T>
 CustomArguments<T>::~CustomArguments() {
-  slot_at(kReturnValueIndex).store(Object(kHandleZapValue));
+  slot_at(kReturnValueIndex).store(Tagged<Object>(kHandleZapValue));
 }
 
 template <typename T>
diff --git a/src/api/api-arguments.cc b/src/api/api-arguments.cc
index 08511a0ac4a..289cd9f28b3 100644
--- a/src/api/api-arguments.cc
+++ b/src/api/api-arguments.cc
@@ -21,7 +21,8 @@ PropertyCallbackArguments::PropertyCallbackArguments(
   slot_at(T::kThisIndex).store(self);
   slot_at(T::kHolderIndex).store(holder);
   slot_at(T::kDataIndex).store(data);
-  slot_at(T::kIsolateIndex).store(Object(reinterpret_cast<Address>(isolate)));
+  slot_at(T::kIsolateIndex)
+      .store(Tagged<Object>(reinterpret_cast<Address>(isolate)));
   int value = Internals::kInferShouldThrowMode;
   if (should_throw.IsJust()) {
     value = should_throw.FromJust();
@@ -45,7 +46,8 @@ FunctionCallbackArguments::FunctionCallbackArguments(
   slot_at(T::kDataIndex).store(data);
   slot_at(T::kHolderIndex).store(holder);
   slot_at(T::kNewTargetIndex).store(new_target);
-  slot_at(T::kIsolateIndex).store(Object(reinterpret_cast<Address>(isolate)));
+  slot_at(T::kIsolateIndex)
+      .store(Tagged<Object>(reinterpret_cast<Address>(isolate)));
   // Here the hole is set as default value. It's converted to and not
   // directly exposed to js.
   // TODO(cbruni): Remove and/or use custom sentinel value.
diff --git a/src/api/api-inl.h b/src/api/api-inl.h
index 154ac355a1a..2b4bbf7feea 100644
--- a/src/api/api-inl.h
+++ b/src/api/api-inl.h
@@ -117,7 +117,7 @@ TYPED_ARRAYS(MAKE_TO_LOCAL_TYPED_ARRAY)
       const v8::From* that, bool allow_empty_handle) {                       \
     DCHECK(allow_empty_handle || !v8::internal::ValueHelper::IsEmpty(that)); \
     DCHECK(v8::internal::ValueHelper::IsEmpty(that) ||                       \
-           Is##To(v8::internal::Object(                                      \
+           Is##To(v8::internal::Tagged<v8::internal::Object>(                \
                v8::internal::ValueHelper::ValueAsAddress(that))));           \
     if (v8::internal::ValueHelper::IsEmpty(that)) {                          \
       return v8::internal::Handle<v8::internal::To>::null();                 \
@@ -131,7 +131,7 @@ TYPED_ARRAYS(MAKE_TO_LOCAL_TYPED_ARRAY)
       const v8::From* that, bool allow_empty_handle) {                       \
     DCHECK(allow_empty_handle || !v8::internal::ValueHelper::IsEmpty(that)); \
     DCHECK(v8::internal::ValueHelper::IsEmpty(that) ||                       \
-           Is##To(v8::internal::Object(                                      \
+           Is##To(v8::internal::Tagged<v8::internal::Object>(                \
                v8::internal::ValueHelper::ValueAsAddress(that))));           \
     return v8::internal::DirectHandle<v8::internal::To>(                     \
         v8::internal::ValueHelper::ValueAsAddress(that));                    \
@@ -149,7 +149,7 @@ TYPED_ARRAYS(MAKE_TO_LOCAL_TYPED_ARRAY)
       const v8::From* that, bool allow_empty_handle) {                       \
     DCHECK(allow_empty_handle || !v8::internal::ValueHelper::IsEmpty(that)); \
     DCHECK(v8::internal::ValueHelper::IsEmpty(that) ||                       \
-           Is##To(v8::internal::Object(                                      \
+           Is##To(v8::internal::Tagged<v8::internal::Object>(                \
                v8::internal::ValueHelper::ValueAsAddress(that))));           \
     return v8::internal::Handle<v8::internal::To>(                           \
         reinterpret_cast<v8::internal::Address*>(                            \
diff --git a/src/api/api-natives.cc b/src/api/api-natives.cc
index 16710ee00f6..183e99a3a98 100644
--- a/src/api/api-natives.cc
+++ b/src/api/api-natives.cc
@@ -182,7 +182,7 @@ Tagged<Object> GetIntrinsic(Isolate* isolate, v8::Intrinsic intrinsic) {
     V8_INTRINSICS_LIST(GET_INTRINSIC_VALUE)
 #undef GET_INTRINSIC_VALUE
   }
-  return Object();
+  return Tagged<Object>();
 }
 
 template <typename TemplateInfoT>
diff --git a/src/api/api.cc b/src/api/api.cc
index 31ed7601eb7..b7606b29d7c 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -731,7 +731,7 @@ i::Address* GlobalizeTracedReference(i::Isolate* i_isolate, i::Address value,
   auto result = i_isolate->traced_handles()->Create(value, slot, store_mode);
 #ifdef VERIFY_HEAP
   if (i::v8_flags.verify_heap) {
-    Object::ObjectVerify(i::Object(value), i_isolate);
+    Object::ObjectVerify(i::Tagged<i::Object>(value), i_isolate);
   }
 #endif  // VERIFY_HEAP
   return result.location();
@@ -800,7 +800,7 @@ i::Address* GlobalizeReference(i::Isolate* i_isolate, i::Address value) {
   i::Handle<i::Object> result = i_isolate->global_handles()->Create(value);
 #ifdef VERIFY_HEAP
   if (i::v8_flags.verify_heap) {
-    i::Object::ObjectVerify(i::Object(value), i_isolate);
+    i::Object::ObjectVerify(i::Tagged<i::Object>(value), i_isolate);
   }
 #endif  // VERIFY_HEAP
   return result.location();
@@ -920,8 +920,9 @@ EscapableHandleScope::EscapableHandleScope(Isolate* v8_isolate) {
 
 i::Address* EscapableHandleScope::Escape(i::Address* escape_value) {
   i::Heap* heap = reinterpret_cast<i::Isolate*>(GetIsolate())->heap();
-  Utils::ApiCheck(i::IsTheHole(i::Object(*escape_slot_), heap->isolate()),
-                  "EscapableHandleScope::Escape", "Escape value set twice");
+  Utils::ApiCheck(
+      i::IsTheHole(i::Tagged<i::Object>(*escape_slot_), heap->isolate()),
+      "EscapableHandleScope::Escape", "Escape value set twice");
   if (escape_value == nullptr) {
     *escape_slot_ = i::ReadOnlyRoots(heap).undefined_value().ptr();
     return nullptr;
@@ -1805,8 +1806,8 @@ void ObjectTemplate::SetAccessCheckCallback(AccessCheckCallback callback,
       i::Handle<i::AccessCheckInfo>::cast(struct_info);
 
   SET_FIELD_WRAPPED(i_isolate, info, set_callback, callback);
-  info->set_named_interceptor(i::Object());
-  info->set_indexed_interceptor(i::Object());
+  info->set_named_interceptor(i::Tagged<i::Object>());
+  info->set_indexed_interceptor(i::Tagged<i::Object>());
 
   if (data.IsEmpty()) {
     data = v8::Undefined(reinterpret_cast<v8::Isolate*>(i_isolate));
@@ -2981,8 +2982,9 @@ void v8::TryCatch::operator delete(void*, size_t) { base::OS::Abort(); }
 void v8::TryCatch::operator delete[](void*, size_t) { base::OS::Abort(); }
 
 bool v8::TryCatch::HasCaught() const {
-  return !IsTheHole(i::Object(reinterpret_cast<i::Address>(exception_)),
-                    i_isolate_);
+  return !IsTheHole(
+      i::Tagged<i::Object>(reinterpret_cast<i::Address>(exception_)),
+      i_isolate_);
 }
 
 bool v8::TryCatch::CanContinue() const { return can_continue_; }
@@ -3970,7 +3972,8 @@ MaybeLocal<Uint32> Value::ToUint32(Local<Context> context) const {
 }
 
 i::Isolate* i::IsolateFromNeverReadOnlySpaceObject(i::Address obj) {
-  return i::GetIsolateFromWritableObject(i::HeapObject::cast(i::Object(obj)));
+  return i::GetIsolateFromWritableObject(
+      i::HeapObject::cast(i::Tagged<i::Object>(obj)));
 }
 
 bool i::ShouldThrowOnError(i::Isolate* i_isolate) {
@@ -6716,9 +6719,10 @@ MaybeLocal<Object> v8::Context::NewRemoteContext(
   i::Handle<i::AccessCheckInfo> access_check_info = i::handle(
       i::AccessCheckInfo::cast(global_constructor->GetAccessCheckInfo()),
       i_isolate);
-  Utils::ApiCheck(access_check_info->named_interceptor() != i::Object(),
-                  "v8::Context::NewRemoteContext",
-                  "Global template needs to have access check handlers");
+  Utils::ApiCheck(
+      access_check_info->named_interceptor() != i::Tagged<i::Object>(),
+      "v8::Context::NewRemoteContext",
+      "Global template needs to have access check handlers");
   i::Handle<i::JSObject> global_proxy = CreateEnvironment<i::JSGlobalProxy>(
       i_isolate, nullptr, global_template, global_object, 0,
       DeserializeInternalFieldsCallback(), nullptr);
@@ -7320,9 +7324,10 @@ MaybeLocal<v8::Object> FunctionTemplate::NewRemoteInstance() {
                   "InstanceTemplate needs to have access checks enabled");
   i::Handle<i::AccessCheckInfo> access_check_info = i::handle(
       i::AccessCheckInfo::cast(constructor->GetAccessCheckInfo()), i_isolate);
-  Utils::ApiCheck(access_check_info->named_interceptor() != i::Object(),
-                  "v8::FunctionTemplate::NewRemoteInstance",
-                  "InstanceTemplate needs to have access check handlers");
+  Utils::ApiCheck(
+      access_check_info->named_interceptor() != i::Tagged<i::Object>(),
+      "v8::FunctionTemplate::NewRemoteInstance",
+      "InstanceTemplate needs to have access check handlers");
   i::Handle<i::JSObject> object;
   if (!i::ApiNatives::InstantiateRemoteObject(
            Utils::OpenHandle(*InstanceTemplate()))
@@ -11259,8 +11264,9 @@ void InvokeAccessorGetterCallback(
   {
     Address arg = i_isolate->isolate_data()->api_callback_thunk_argument();
     // Currently we don't call InterceptorInfo callbacks via CallApiGetter.
-    DCHECK(IsAccessorInfo(Object(arg)));
-    Tagged<AccessorInfo> accessor_info = AccessorInfo::cast(Object(arg));
+    DCHECK(IsAccessorInfo(Tagged<Object>(arg)));
+    Tagged<AccessorInfo> accessor_info =
+        AccessorInfo::cast(Tagged<Object>(arg));
     getter = reinterpret_cast<v8::AccessorNameGetterCallback>(
         accessor_info->getter(i_isolate));
 
diff --git a/src/builtins/builtins-microtask-queue-gen.cc b/src/builtins/builtins-microtask-queue-gen.cc
index f58636fee55..96fdaaba202 100644
--- a/src/builtins/builtins-microtask-queue-gen.cc
+++ b/src/builtins/builtins-microtask-queue-gen.cc
@@ -356,7 +356,7 @@ void MicrotaskQueueBuiltinsAssembler::IncrementFinishedMicrotaskCount(
 TNode<Context> MicrotaskQueueBuiltinsAssembler::GetCurrentContext() {
   auto ref = ExternalReference::Create(kContextAddress, isolate());
   // TODO(delphick): Add a checked cast. For now this is not possible as context
-  // can actually be Smi(0).
+  // can actually be Tagged<Smi>(0).
   return TNode<Context>::UncheckedCast(LoadFullTagged(ExternalConstant(ref)));
 }
 
diff --git a/src/builtins/builtins-typed-array-gen.cc b/src/builtins/builtins-typed-array-gen.cc
index 452012c0965..42e594a0ce9 100644
--- a/src/builtins/builtins-typed-array-gen.cc
+++ b/src/builtins/builtins-typed-array-gen.cc
@@ -51,9 +51,9 @@ TNode<JSArrayBuffer> TypedArrayBuiltinsAssembler::AllocateEmptyOnHeapBuffer(
   //  - Set BitField to 0.
   //  - Set IsExternal and IsDetachable bits of BitFieldSlot.
   //  - Set the byte_length field to zero.
-  //  - Set backing_store to null/Smi(0).
+  //  - Set backing_store to null/Tagged<Smi>(0).
   //  - Set extension to null.
-  //  - Set all embedder fields to Smi(0).
+  //  - Set all embedder fields to Tagged<Smi>(0).
   if (FIELD_SIZE(JSArrayBuffer::kOptionalPaddingOffset) != 0) {
     DCHECK_EQ(4, FIELD_SIZE(JSArrayBuffer::kOptionalPaddingOffset));
     StoreObjectFieldNoWriteBarrier(
diff --git a/src/builtins/builtins-utils.h b/src/builtins/builtins-utils.h
index 116a190f67a..877ac184997 100644
--- a/src/builtins/builtins-utils.h
+++ b/src/builtins/builtins-utils.h
@@ -23,12 +23,12 @@ class BuiltinArguments : public JavaScriptArguments {
       : Arguments(length, arguments) {
     // Check we have at least the receiver.
     DCHECK_LE(1, this->length());
-    DCHECK(Object((*at(0)).ptr()).IsObject());
+    DCHECK(Tagged<Object>((*at(0)).ptr()).IsObject());
   }
 
   Tagged<Object> operator[](int index) const {
     DCHECK_LT(index, length());
-    return Object(*address_of_arg_at(index + kArgsOffset));
+    return Tagged<Object>(*address_of_arg_at(index + kArgsOffset));
   }
 
   template <class S = Object>
diff --git a/src/builtins/builtins.cc b/src/builtins/builtins.cc
index 1085f16075f..44a794158fa 100644
--- a/src/builtins/builtins.cc
+++ b/src/builtins/builtins.cc
@@ -188,7 +188,7 @@ void Builtins::set_code(Builtin builtin, Tagged<Code> code) {
 
 Tagged<Code> Builtins::code(Builtin builtin) {
   Address ptr = isolate_->builtin_table()[Builtins::ToInt(builtin)];
-  return Code::cast(Object(ptr));
+  return Code::cast(Tagged<Object>(ptr));
 }
 
 Handle<Code> Builtins::code_handle(Builtin builtin) {
diff --git a/src/builtins/convert.tq b/src/builtins/convert.tq
index 36eda98f16f..a79e6816e6f 100644
--- a/src/builtins/convert.tq
+++ b/src/builtins/convert.tq
@@ -117,12 +117,6 @@ FromConstexpr<int8, constexpr int31>(i: constexpr int31): int8 {
 FromConstexpr<char8, constexpr int31>(i: constexpr int31): char8 {
   return %RawDownCast<char8>(FromConstexpr<uint8>(i));
 }
-FromConstexpr<Number, constexpr Smi>(s: constexpr Smi): Number {
-  return SmiConstant(s);
-}
-FromConstexpr<Smi, constexpr Smi>(s: constexpr Smi): Smi {
-  return SmiConstant(s);
-}
 FromConstexpr<uint32, constexpr int31>(i: constexpr int31): uint32 {
   return Unsigned(Int32Constant(i));
 }
diff --git a/src/codegen/arm/assembler-arm-inl.h b/src/codegen/arm/assembler-arm-inl.h
index 2021142b910..ebfe2d5eb75 100644
--- a/src/codegen/arm/assembler-arm-inl.h
+++ b/src/codegen/arm/assembler-arm-inl.h
@@ -94,7 +94,7 @@ int RelocInfo::target_address_size() { return kPointerSize; }
 Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
   DCHECK(IsCodeTarget(rmode_) || IsFullEmbeddedObject(rmode_));
   return HeapObject::cast(
-      Object(Assembler::target_address_at(pc_, constant_pool_)));
+      Tagged<Object>(Assembler::target_address_at(pc_, constant_pool_)));
 }
 
 Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {
diff --git a/src/codegen/arm64/assembler-arm64-inl.h b/src/codegen/arm64/assembler-arm64-inl.h
index 4fcf4782570..1ca26a2316e 100644
--- a/src/codegen/arm64/assembler-arm64-inl.h
+++ b/src/codegen/arm64/assembler-arm64-inl.h
@@ -675,7 +675,7 @@ Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
     return HeapObject::cast(obj);
   } else {
     return HeapObject::cast(
-        Object(Assembler::target_address_at(pc_, constant_pool_)));
+        Tagged<Object>(Assembler::target_address_at(pc_, constant_pool_)));
   }
 }
 
diff --git a/src/codegen/external-reference.cc b/src/codegen/external-reference.cc
index c6fedbcfe05..04977061916 100644
--- a/src/codegen/external-reference.cc
+++ b/src/codegen/external-reference.cc
@@ -367,13 +367,15 @@ namespace {
 
 intptr_t DebugBreakAtEntry(Isolate* isolate, Address raw_sfi) {
   DisallowGarbageCollection no_gc;
-  Tagged<SharedFunctionInfo> sfi = SharedFunctionInfo::cast(Object(raw_sfi));
+  Tagged<SharedFunctionInfo> sfi =
+      SharedFunctionInfo::cast(Tagged<Object>(raw_sfi));
   return isolate->debug()->BreakAtEntry(sfi) ? 1 : 0;
 }
 
 Address DebugGetCoverageInfo(Isolate* isolate, Address raw_sfi) {
   DisallowGarbageCollection no_gc;
-  Tagged<SharedFunctionInfo> sfi = SharedFunctionInfo::cast(Object(raw_sfi));
+  Tagged<SharedFunctionInfo> sfi =
+      SharedFunctionInfo::cast(Tagged<Object>(raw_sfi));
   base::Optional<Tagged<DebugInfo>> debug_info =
       isolate->debug()->TryGetDebugInfo(sfi);
   if (debug_info.has_value() && debug_info.value()->HasCoverageInfo()) {
@@ -797,9 +799,9 @@ namespace {
 static uintptr_t BaselinePCForBytecodeOffset(Address raw_code_obj,
                                              int bytecode_offset,
                                              Address raw_bytecode_array) {
-  Tagged<Code> code_obj = Code::cast(Object(raw_code_obj));
+  Tagged<Code> code_obj = Code::cast(Tagged<Object>(raw_code_obj));
   Tagged<BytecodeArray> bytecode_array =
-      BytecodeArray::cast(Object(raw_bytecode_array));
+      BytecodeArray::cast(Tagged<Object>(raw_bytecode_array));
   return code_obj->GetBaselineStartPCForBytecodeOffset(bytecode_offset,
                                                        bytecode_array);
 }
@@ -807,9 +809,9 @@ static uintptr_t BaselinePCForBytecodeOffset(Address raw_code_obj,
 static uintptr_t BaselinePCForNextExecutedBytecode(Address raw_code_obj,
                                                    int bytecode_offset,
                                                    Address raw_bytecode_array) {
-  Tagged<Code> code_obj = Code::cast(Object(raw_code_obj));
+  Tagged<Code> code_obj = Code::cast(Tagged<Object>(raw_code_obj));
   Tagged<BytecodeArray> bytecode_array =
-      BytecodeArray::cast(Object(raw_bytecode_array));
+      BytecodeArray::cast(Tagged<Object>(raw_bytecode_array));
   return code_obj->GetBaselinePCForNextExecutedBytecode(bytecode_offset,
                                                         bytecode_array);
 }
@@ -1088,14 +1090,14 @@ namespace {
 
 void StringWriteToFlatOneByte(Address source, uint8_t* sink, int32_t start,
                               int32_t length) {
-  return String::WriteToFlat<uint8_t>(String::cast(Object(source)), sink, start,
-                                      length);
+  return String::WriteToFlat<uint8_t>(String::cast(Tagged<Object>(source)),
+                                      sink, start, length);
 }
 
 void StringWriteToFlatTwoByte(Address source, uint16_t* sink, int32_t start,
                               int32_t length) {
-  return String::WriteToFlat<uint16_t>(String::cast(Object(source)), sink,
-                                       start, length);
+  return String::WriteToFlat<uint16_t>(String::cast(Tagged<Object>(source)),
+                                       sink, start, length);
 }
 
 const uint8_t* ExternalOneByteStringGetChars(Address string) {
@@ -1105,8 +1107,9 @@ const uint8_t* ExternalOneByteStringGetChars(Address string) {
   // merged by the linker, resulting in one of the input type's vtable address
   // failing the address range check.
   // TODO(chromium:1160961): Consider removing the CHECK when CFI is fixed.
-  CHECK(IsExternalOneByteString(Object(string), cage_base));
-  return ExternalOneByteString::cast(Object(string))->GetChars(cage_base);
+  CHECK(IsExternalOneByteString(Tagged<Object>(string), cage_base));
+  return ExternalOneByteString::cast(Tagged<Object>(string))
+      ->GetChars(cage_base);
 }
 const uint16_t* ExternalTwoByteStringGetChars(Address string) {
   PtrComprCageBase cage_base = GetPtrComprCageBaseFromOnHeapAddress(string);
@@ -1115,8 +1118,9 @@ const uint16_t* ExternalTwoByteStringGetChars(Address string) {
   // merged by the linker, resulting in one of the input type's vtable address
   // failing the address range check.
   // TODO(chromium:1160961): Consider removing the CHECK when CFI is fixed.
-  CHECK(IsExternalTwoByteString(Object(string), cage_base));
-  return ExternalTwoByteString::cast(Object(string))->GetChars(cage_base);
+  CHECK(IsExternalTwoByteString(Tagged<Object>(string), cage_base));
+  return ExternalTwoByteString::cast(Tagged<Object>(string))
+      ->GetChars(cage_base);
 }
 
 }  // namespace
@@ -1149,13 +1153,13 @@ FUNCTION_REFERENCE(orderedhashmap_gethash_raw, OrderedHashMap::GetHash)
 
 Address GetOrCreateHash(Isolate* isolate, Address raw_key) {
   DisallowGarbageCollection no_gc;
-  return Object::GetOrCreateHash(Object(raw_key), isolate).ptr();
+  return Object::GetOrCreateHash(Tagged<Object>(raw_key), isolate).ptr();
 }
 
 FUNCTION_REFERENCE(get_or_create_hash_raw, GetOrCreateHash)
 
 static Address JSReceiverCreateIdentityHash(Isolate* isolate, Address raw_key) {
-  Tagged<JSReceiver> key = JSReceiver::cast(Object(raw_key));
+  Tagged<JSReceiver> key = JSReceiver::cast(Tagged<Object>(raw_key));
   return JSReceiver::CreateIdentityHash(isolate, key).ptr();
 }
 
@@ -1179,11 +1183,11 @@ static size_t NameDictionaryLookupForwardedString(Isolate* isolate,
   DisallowGarbageCollection no_gc;
   HandleScope handle_scope(isolate);
 
-  Handle<String> key(String::cast(Object(raw_key)), isolate);
+  Handle<String> key(String::cast(Tagged<Object>(raw_key)), isolate);
   // This function should only be used as the slow path for forwarded strings.
   DCHECK(Name::IsForwardingIndex(key->raw_hash_field()));
 
-  Tagged<Dictionary> dict = Dictionary::cast(Object(raw_dict));
+  Tagged<Dictionary> dict = Dictionary::cast(Tagged<Object>(raw_dict));
   ReadOnlyRoots roots(isolate);
   uint32_t hash = key->hash();
   InternalIndex entry = mode == kFindExisting
@@ -1315,8 +1319,8 @@ FUNCTION_REFERENCE(check_object_type, CheckObjectType)
 #ifdef V8_INTL_SUPPORT
 
 static Address ConvertOneByteToLower(Address raw_src, Address raw_dst) {
-  Tagged<String> src = String::cast(Object(raw_src));
-  Tagged<String> dst = String::cast(Object(raw_dst));
+  Tagged<String> src = String::cast(Tagged<Object>(raw_src));
+  Tagged<String> dst = String::cast(Tagged<Object>(raw_dst));
   return Intl::ConvertOneByteToLower(src, dst).ptr();
 }
 FUNCTION_REFERENCE(intl_convert_one_byte_to_lower, ConvertOneByteToLower)
@@ -1387,7 +1391,7 @@ ExternalReference ExternalReference::runtime_function_table_address(
 }
 
 static Address InvalidatePrototypeChainsWrapper(Address raw_map) {
-  Tagged<Map> map = Map::cast(Object(raw_map));
+  Tagged<Map> map = Map::cast(Tagged<Object>(raw_map));
   return JSObject::InvalidatePrototypeChains(map).ptr();
 }
 
@@ -1676,7 +1680,8 @@ IF_TSAN(FUNCTION_REFERENCE, tsan_relaxed_load_function_64_bits,
 
 static int EnterMicrotaskContextWrapper(HandleScopeImplementer* hsi,
                                         Address raw_context) {
-  Tagged<NativeContext> context = NativeContext::cast(Object(raw_context));
+  Tagged<NativeContext> context =
+      NativeContext::cast(Tagged<Object>(raw_context));
   hsi->EnterMicrotaskContext(context);
   return 0;
 }
diff --git a/src/codegen/ia32/assembler-ia32-inl.h b/src/codegen/ia32/assembler-ia32-inl.h
index 359489e858a..e123bbf5aa2 100644
--- a/src/codegen/ia32/assembler-ia32-inl.h
+++ b/src/codegen/ia32/assembler-ia32-inl.h
@@ -82,7 +82,7 @@ int RelocInfo::target_address_size() { return Assembler::kSpecialTargetSize; }
 
 Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
   DCHECK(IsCodeTarget(rmode_) || IsFullEmbeddedObject(rmode_));
-  return HeapObject::cast(Object(ReadUnalignedValue<Address>(pc_)));
+  return HeapObject::cast(Tagged<Object>(ReadUnalignedValue<Address>(pc_)));
 }
 
 Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {
diff --git a/src/codegen/loong64/assembler-loong64-inl.h b/src/codegen/loong64/assembler-loong64-inl.h
index f074991e4d8..3a4abe3a8d2 100644
--- a/src/codegen/loong64/assembler-loong64-inl.h
+++ b/src/codegen/loong64/assembler-loong64-inl.h
@@ -121,7 +121,7 @@ Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
     return HeapObject::cast(obj);
   } else {
     return HeapObject::cast(
-        Object(Assembler::target_address_at(pc_, constant_pool_)));
+        Tagged<Object>(Assembler::target_address_at(pc_, constant_pool_)));
   }
 }
 
diff --git a/src/codegen/mips64/assembler-mips64-inl.h b/src/codegen/mips64/assembler-mips64-inl.h
index 92d5d7d8c48..d439a4bb2a3 100644
--- a/src/codegen/mips64/assembler-mips64-inl.h
+++ b/src/codegen/mips64/assembler-mips64-inl.h
@@ -138,7 +138,7 @@ void Assembler::deserialization_set_target_internal_reference_at(
 Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
   DCHECK(IsCodeTarget(rmode_) || IsFullEmbeddedObject(rmode_));
   return HeapObject::cast(
-      Object(Assembler::target_address_at(pc_, constant_pool_)));
+      Tagged<Object>(Assembler::target_address_at(pc_, constant_pool_)));
 }
 
 Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {
diff --git a/src/codegen/ppc/assembler-ppc-inl.h b/src/codegen/ppc/assembler-ppc-inl.h
index 0680f6db937..343ff8b973b 100644
--- a/src/codegen/ppc/assembler-ppc-inl.h
+++ b/src/codegen/ppc/assembler-ppc-inl.h
@@ -148,12 +148,13 @@ Handle<Object> Assembler::code_target_object_handle_at(Address pc,
 Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
   DCHECK(IsCodeTarget(rmode_) || IsEmbeddedObjectMode(rmode_));
   if (IsCompressedEmbeddedObject(rmode_)) {
-    return HeapObject::cast(Object(V8HeapCompressionScheme::DecompressTagged(
-        cage_base,
-        Assembler::target_compressed_address_at(pc_, constant_pool_))));
+    return HeapObject::cast(
+        Tagged<Object>(V8HeapCompressionScheme::DecompressTagged(
+            cage_base,
+            Assembler::target_compressed_address_at(pc_, constant_pool_))));
   } else {
     return HeapObject::cast(
-        Object(Assembler::target_address_at(pc_, constant_pool_)));
+        Tagged<Object>(Assembler::target_address_at(pc_, constant_pool_)));
   }
 }
 
diff --git a/src/codegen/riscv/assembler-riscv-inl.h b/src/codegen/riscv/assembler-riscv-inl.h
index 8abf4b3239f..9bfbdedc788 100644
--- a/src/codegen/riscv/assembler-riscv-inl.h
+++ b/src/codegen/riscv/assembler-riscv-inl.h
@@ -168,7 +168,7 @@ Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
             Assembler::target_compressed_address_at(pc_, constant_pool_))));
   } else {
     return HeapObject::cast(
-        Object(Assembler::target_address_at(pc_, constant_pool_)));
+        Tagged<Object>(Assembler::target_address_at(pc_, constant_pool_)));
   }
 }
 
diff --git a/src/codegen/s390/assembler-s390-inl.h b/src/codegen/s390/assembler-s390-inl.h
index 0a753f49d4a..163106a6d6d 100644
--- a/src/codegen/s390/assembler-s390-inl.h
+++ b/src/codegen/s390/assembler-s390-inl.h
@@ -142,12 +142,13 @@ Handle<Object> Assembler::code_target_object_handle_at(Address pc) {
 Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
   DCHECK(IsCodeTarget(rmode_) || IsEmbeddedObjectMode(rmode_));
   if (IsCompressedEmbeddedObject(rmode_)) {
-    return HeapObject::cast(Object(V8HeapCompressionScheme::DecompressTagged(
-        cage_base,
-        Assembler::target_compressed_address_at(pc_, constant_pool_))));
+    return HeapObject::cast(
+        Tagged<Object>(V8HeapCompressionScheme::DecompressTagged(
+            cage_base,
+            Assembler::target_compressed_address_at(pc_, constant_pool_))));
   } else {
     return HeapObject::cast(
-        Object(Assembler::target_address_at(pc_, constant_pool_)));
+        Tagged<Object>(Assembler::target_address_at(pc_, constant_pool_)));
   }
 }
 
diff --git a/src/codegen/x64/assembler-x64-inl.h b/src/codegen/x64/assembler-x64-inl.h
index 5d196ac4152..a8fdfc19155 100644
--- a/src/codegen/x64/assembler-x64-inl.h
+++ b/src/codegen/x64/assembler-x64-inl.h
@@ -295,7 +295,7 @@ Tagged<HeapObject> RelocInfo::target_object(PtrComprCageBase cage_base) {
     return HeapObject::cast(obj);
   }
   DCHECK(IsFullEmbeddedObject(rmode_));
-  return HeapObject::cast(Object(ReadUnalignedValue<Address>(pc_)));
+  return HeapObject::cast(Tagged<Object>(ReadUnalignedValue<Address>(pc_)));
 }
 
 Handle<HeapObject> RelocInfo::target_object_handle(Assembler* origin) {
diff --git a/src/compiler/code-assembler.cc b/src/compiler/code-assembler.cc
index ead1ec634df..d5fa92d8222 100644
--- a/src/compiler/code-assembler.cc
+++ b/src/compiler/code-assembler.cc
@@ -362,7 +362,7 @@ bool CodeAssembler::TryToSmiConstant(TNode<IntegralT> node,
     intptr_t value = m.ResolvedValue();
     // Make sure that the value is actually a smi
     CHECK_EQ(0, value & ((static_cast<intptr_t>(1) << kSmiShiftSize) - 1));
-    *out_value = Smi(static_cast<Address>(value));
+    *out_value = Tagged<Smi>(static_cast<Address>(value));
     return true;
   }
   return false;
diff --git a/src/compiler/graph-visualizer.cc b/src/compiler/graph-visualizer.cc
index 3d5b33657d3..dfe935e8b67 100644
--- a/src/compiler/graph-visualizer.cc
+++ b/src/compiler/graph-visualizer.cc
@@ -219,7 +219,7 @@ void JsonPrintAllSourceWithPositions(std::ostream& os,
   os << "\"sources\" : {";
   Handle<Script> script =
       (info->shared_info().is_null() ||
-       info->shared_info()->script() == Object())
+       info->shared_info()->script() == Tagged<Object>())
           ? Handle<Script>()
           : handle(Script::cast(info->shared_info()->script()), isolate);
   JsonPrintFunctionSource(os, -1,
diff --git a/src/compiler/js-call-reducer.cc b/src/compiler/js-call-reducer.cc
index 65fd9b61753..09b994b1256 100644
--- a/src/compiler/js-call-reducer.cc
+++ b/src/compiler/js-call-reducer.cc
@@ -2712,7 +2712,8 @@ Reduction JSCallReducer::ReduceObjectConstructor(Node* node) {
   Node* value = n.Argument(0);
   Effect effect = n.effect();
 
-  // We can fold away the Object(x) call if |x| is definitely not a primitive.
+  // We can fold away the Tagged<Object>(x) call if |x| is definitely not a
+  // primitive.
   if (NodeProperties::CanBePrimitive(broker(), value, effect)) {
     if (!NodeProperties::CanBeNullOrUndefined(broker(), value, effect)) {
       // Turn the {node} into a {JSToObject} call if we know that
diff --git a/src/compiler/js-heap-broker.h b/src/compiler/js-heap-broker.h
index 0a09e9378ee..9a7a75196be 100644
--- a/src/compiler/js-heap-broker.h
+++ b/src/compiler/js-heap-broker.h
@@ -330,7 +330,7 @@ class V8_EXPORT_PRIVATE JSHeapBroker {
         return true;
       }
     }
-    return canonical_handles_->Find(Object(address)) != nullptr;
+    return canonical_handles_->Find(Tagged<Object>(address)) != nullptr;
   }
 
   std::string Trace() const;
diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index d7f22bd8df4..44bf1d1f261 100644
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -3205,7 +3205,7 @@ int HashGraphForPGO(Graph* graph) {
       }
     }
   }
-  return Smi(IntToSmi(static_cast<int>(hash))).value();
+  return Tagged<Smi>(IntToSmi(static_cast<int>(hash))).value();
 }
 
 }  // namespace
diff --git a/src/compiler/turboshaft/fast-api-call-reducer.h b/src/compiler/turboshaft/fast-api-call-reducer.h
index 5ab3736e1a6..96dc3d6c2c7 100644
--- a/src/compiler/turboshaft/fast-api-call-reducer.h
+++ b/src/compiler/turboshaft/fast-api-call-reducer.h
@@ -124,8 +124,8 @@ class FastApiCallReducer : public Next {
     GOTO(done, FastApiCallOp::kSuccessValue, fast_call_result);
 
     if (BIND(handle_error)) {
-      // We pass Smi(0) as the value here, although this should never be visible
-      // when calling code reacts to `kFailureValue` properly.
+      // We pass Tagged<Smi>(0) as the value here, although this should never be
+      // visible when calling code reacts to `kFailureValue` properly.
       GOTO(done, FastApiCallOp::kFailureValue, __ TagSmi(0));
     }
 
diff --git a/src/compiler/wasm-gc-lowering.cc b/src/compiler/wasm-gc-lowering.cc
index de836d93869..8aed5a66bbd 100644
--- a/src/compiler/wasm-gc-lowering.cc
+++ b/src/compiler/wasm-gc-lowering.cc
@@ -878,15 +878,15 @@ Reduction WasmGCLowering::ReduceStringPrepareForGetCodeunit(Node* node) {
                       MachineRepresentation::kWord32);        // Offset.
 
   // These values will be used to replace the original node's projections.
-  // The first, "string", is either a SeqString or Smi(0) (in case of external
-  // string). Notably this makes it GC-safe: if that string moves, this pointer
-  // will be updated accordingly.
-  // The second, "offset", has full register width so that it can be used to
-  // store external pointers: for external strings, we add up the character
-  // backing store's base address and any slice offset.
-  // The third, "character width", is a shift width, i.e. it is 0 for one-byte
-  // strings, 1 for two-byte strings, kCharWidthBailoutSentinel for uncached
-  // external strings (for which "string"/"offset" are invalid and unusable).
+  // The first, "string", is either a SeqString or Tagged<Smi>(0) (in case of
+  // external string). Notably this makes it GC-safe: if that string moves, this
+  // pointer will be updated accordingly. The second, "offset", has full
+  // register width so that it can be used to store external pointers: for
+  // external strings, we add up the character backing store's base address and
+  // any slice offset. The third, "character width", is a shift width, i.e. it
+  // is 0 for one-byte strings, 1 for two-byte strings,
+  // kCharWidthBailoutSentinel for uncached external strings (for which
+  // "string"/"offset" are invalid and unusable).
   auto done =
       gasm_.MakeLabel(MachineRepresentation::kTagged,        // String.
                       MachineType::PointerRepresentation(),  // Offset.
diff --git a/src/debug/debug.cc b/src/debug/debug.cc
index 600f6fc8167..5ac08b23331 100644
--- a/src/debug/debug.cc
+++ b/src/debug/debug.cc
@@ -478,7 +478,7 @@ void DebugInfoCollection::Insert(Tagged<SharedFunctionInfo> sfi,
 bool DebugInfoCollection::Contains(Tagged<SharedFunctionInfo> sfi) const {
   auto it = map_.find(sfi->unique_id());
   if (it == map_.end()) return false;
-  DCHECK_EQ(DebugInfo::cast(Object(*it->second))->shared(), sfi);
+  DCHECK_EQ(DebugInfo::cast(Tagged<Object>(*it->second))->shared(), sfi);
   return true;
 }
 
@@ -486,7 +486,7 @@ base::Optional<Tagged<DebugInfo>> DebugInfoCollection::Find(
     Tagged<SharedFunctionInfo> sfi) const {
   auto it = map_.find(sfi->unique_id());
   if (it == map_.end()) return {};
-  Tagged<DebugInfo> di = DebugInfo::cast(Object(*it->second));
+  Tagged<DebugInfo> di = DebugInfo::cast(Tagged<Object>(*it->second));
   DCHECK_EQ(di->shared(), sfi);
   return di;
 }
@@ -504,7 +504,7 @@ void DebugInfoCollection::DeleteSlow(Tagged<SharedFunctionInfo> sfi) {
 
 Tagged<DebugInfo> DebugInfoCollection::EntryAsDebugInfo(size_t index) const {
   DCHECK_LT(index, list_.size());
-  return DebugInfo::cast(Object(*list_[index]));
+  return DebugInfo::cast(Tagged<Object>(*list_[index]));
 }
 
 void DebugInfoCollection::DeleteIndex(size_t index) {
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index 0698a43bf76..eb23ef32f5a 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -248,7 +248,7 @@ class FrameWriter {
 Deoptimizer* Deoptimizer::New(Address raw_function, DeoptimizeKind kind,
                               Address from, int fp_to_sp_delta,
                               Isolate* isolate) {
-  Tagged<JSFunction> function = JSFunction::cast(Object(raw_function));
+  Tagged<JSFunction> function = JSFunction::cast(Tagged<Object>(raw_function));
   Deoptimizer* deoptimizer =
       new Deoptimizer(isolate, function, kind, from, fp_to_sp_delta);
   isolate->set_current_deoptimizer(deoptimizer);
@@ -1230,7 +1230,8 @@ void Deoptimizer::DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
       // the exception (which lives in the result register).
       intptr_t accumulator_value =
           input_->GetRegister(kInterpreterAccumulatorRegister.code());
-      frame_writer.PushRawObject(Object(accumulator_value), "accumulator\n");
+      frame_writer.PushRawObject(Tagged<Object>(accumulator_value),
+                                 "accumulator\n");
     } else {
       // If we are lazily deoptimizing make sure we store the deopt
       // return value into the appropriate slot.
@@ -1279,7 +1280,8 @@ void Deoptimizer::DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
 
   // Clear the context register. The context might be a de-materialized object
   // and will be materialized by {Runtime_NotifyDeoptimized}. For additional
-  // safety we use Smi(0) instead of the potential {arguments_marker} here.
+  // safety we use Tagged<Smi>(0) instead of the potential {arguments_marker}
+  // here.
   if (is_topmost) {
     intptr_t context_value = static_cast<intptr_t>(Smi::zero().ptr());
     Register context_reg = JavaScriptFrame::context_register();
@@ -1492,7 +1494,8 @@ void Deoptimizer::DoComputeConstructCreateStubFrame(
 
   // Clear the context register. The context might be a de-materialized object
   // and will be materialized by {Runtime_NotifyDeoptimized}. For additional
-  // safety we use Smi(0) instead of the potential {arguments_marker} here.
+  // safety we use Tagged<Smi>(0) instead of the potential {arguments_marker}
+  // here.
   if (is_topmost) {
     intptr_t context_value = static_cast<intptr_t>(Smi::zero().ptr());
     Register context_reg = JavaScriptFrame::context_register();
@@ -1622,7 +1625,8 @@ void Deoptimizer::DoComputeConstructInvokeStubFrame(
 
   // Clear the context register. The context might be a de-materialized object
   // and will be materialized by {Runtime_NotifyDeoptimized}. For additional
-  // safety we use Smi(0) instead of the potential {arguments_marker} here.
+  // safety we use Tagged<Smi>(0) instead of the potential {arguments_marker}
+  // here.
   if (is_topmost) {
     intptr_t context_value = static_cast<intptr_t>(Smi::zero().ptr());
     Register context_reg = JavaScriptFrame::context_register();
@@ -1908,7 +1912,7 @@ void Deoptimizer::DoComputeBuiltinContinuation(
       case BuiltinContinuationMode::JAVASCRIPT_HANDLE_EXCEPTION: {
         intptr_t accumulator_value =
             input_->GetRegister(kInterpreterAccumulatorRegister.code());
-        frame_writer.PushRawObject(Object(accumulator_value),
+        frame_writer.PushRawObject(Tagged<Object>(accumulator_value),
                                    "exception (from accumulator)\n");
       } break;
     }
@@ -2041,7 +2045,8 @@ void Deoptimizer::DoComputeBuiltinContinuation(
 
   // Clear the context register. The context might be a de-materialized object
   // and will be materialized by {Runtime_NotifyDeoptimized}. For additional
-  // safety we use Smi(0) instead of the potential {arguments_marker} here.
+  // safety we use Tagged<Smi>(0) instead of the potential {arguments_marker}
+  // here.
   if (is_topmost) {
     intptr_t context_value = static_cast<intptr_t>(Smi::zero().ptr());
     Register context_reg = JavaScriptFrame::context_register();
diff --git a/src/deoptimizer/translated-state.cc b/src/deoptimizer/translated-state.cc
index a89d5eeac5e..7d5e4545ab7 100644
--- a/src/deoptimizer/translated-state.cc
+++ b/src/deoptimizer/translated-state.cc
@@ -765,7 +765,7 @@ void TranslatedValue::Handlify() {
   if (kind() == kTagged && IsHeapObject(raw_literal())) {
     set_initialized_storage(
         Handle<HeapObject>(HeapObject::cast(raw_literal()), isolate()));
-    raw_literal_ = Object();
+    raw_literal_ = Tagged<Object>();
   }
 }
 
@@ -1249,10 +1249,10 @@ int TranslatedState::CreateNextTranslatedValue(
       if (trace_file != nullptr) {
         PrintF(trace_file, V8PRIxPTR_FMT " ; %s ", uncompressed_value,
                converter.NameOfCPURegister(input_reg));
-        ShortPrint(Object(uncompressed_value), trace_file);
+        ShortPrint(Tagged<Object>(uncompressed_value), trace_file);
       }
       TranslatedValue translated_value =
-          TranslatedValue::NewTagged(this, Object(uncompressed_value));
+          TranslatedValue::NewTagged(this, Tagged<Object>(uncompressed_value));
       frame.Add(translated_value);
       return translated_value.GetChildrenCount();
     }
@@ -1432,10 +1432,10 @@ int TranslatedState::CreateNextTranslatedValue(
         PrintF(trace_file, V8PRIxPTR_FMT " ;  [fp %c %3d]  ",
                uncompressed_value, slot_offset < 0 ? '-' : '+',
                std::abs(slot_offset));
-        ShortPrint(Object(uncompressed_value), trace_file);
+        ShortPrint(Tagged<Object>(uncompressed_value), trace_file);
       }
       TranslatedValue translated_value =
-          TranslatedValue::NewTagged(this, Object(uncompressed_value));
+          TranslatedValue::NewTagged(this, Tagged<Object>(uncompressed_value));
       frame.Add(translated_value);
       return translated_value.GetChildrenCount();
     }
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index 24e00e450ea..807b52dcab8 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -2108,7 +2108,7 @@ void WasmStruct::WasmStructPrint(std::ostream& os) {
 #else
         Address obj = raw;
 #endif
-        os << Brief(Object(obj));
+        os << Brief(Tagged<Object>(obj));
         break;
       }
       case wasm::kS128:
@@ -3483,7 +3483,7 @@ inline i::Tagged<i::Object> GetObjectFromRaw(void* object) {
         isolate, static_cast<i::Tagged_t>(object_ptr));
   }
 #endif
-  return i::Object(object_ptr);
+  return i::Tagged<i::Object>(object_ptr);
 }
 
 }  // namespace
diff --git a/src/execution/arguments-inl.h b/src/execution/arguments-inl.h
index 4caeb93bf65..33a94f79453 100644
--- a/src/execution/arguments-inl.h
+++ b/src/execution/arguments-inl.h
@@ -19,7 +19,7 @@ Arguments<T>::ChangeValueScope::ChangeValueScope(Isolate* isolate,
                                                  Arguments* args, int index,
                                                  Tagged<Object> value)
     : location_(args->address_of_arg_at(index)) {
-  old_value_ = handle(Object(*location_), isolate);
+  old_value_ = handle(Tagged<Object>(*location_), isolate);
   *location_ = value.ptr();
 }
 
diff --git a/src/execution/arguments.h b/src/execution/arguments.h
index 7676b974049..f81c1f6e1fd 100644
--- a/src/execution/arguments.h
+++ b/src/execution/arguments.h
@@ -52,7 +52,7 @@ class Arguments {
   }
 
   V8_INLINE Tagged<Object> operator[](int index) const {
-    return Object(*address_of_arg_at(index));
+    return Tagged<Object>(*address_of_arg_at(index));
   }
 
   template <class S = Object>
diff --git a/src/execution/execution.cc b/src/execution/execution.cc
index 93077c26d66..63f2eea526b 100644
--- a/src/execution/execution.cc
+++ b/src/execution/execution.cc
@@ -424,9 +424,9 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> Invoke(Isolate* isolate,
       Address recv = (*params.receiver).ptr();
       Address** argv = reinterpret_cast<Address**>(params.argv);
       RCS_SCOPE(isolate, RuntimeCallCounterId::kJS_Execution);
-      value = Object(stub_entry.Call(isolate->isolate_data()->isolate_root(),
-                                     orig_func, func, recv,
-                                     JSParameterCount(params.argc), argv));
+      value = Tagged<Object>(
+          stub_entry.Call(isolate->isolate_data()->isolate_root(), orig_func,
+                          func, recv, JSParameterCount(params.argc), argv));
     } else {
       DCHECK_EQ(Execution::Target::kRunMicrotasks, params.execution_target);
 
@@ -440,8 +440,8 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> Invoke(Isolate* isolate,
           JSEntryFunction::FromAddress(isolate, code->instruction_start());
 
       RCS_SCOPE(isolate, RuntimeCallCounterId::kJS_Execution);
-      value = Object(stub_entry.Call(isolate->isolate_data()->isolate_root(),
-                                     params.microtask_queue));
+      value = Tagged<Object>(stub_entry.Call(
+          isolate->isolate_data()->isolate_root(), params.microtask_queue));
     }
   }
 
@@ -651,7 +651,7 @@ void Execution::CallWasm(Isolate* isolate, Handle<Code> wrapper_code,
     Address result = stub_entry.Call(wasm_call_target, (*object_ref).ptr(),
                                      packed_args, saved_c_entry_fp);
     if (result != kNullAddress) {
-      isolate->set_pending_exception(Object(result));
+      isolate->set_pending_exception(Tagged<Object>(result));
     }
   }
 
diff --git a/src/execution/frames-inl.h b/src/execution/frames-inl.h
index 794c065dafc..b4c9c8f521d 100644
--- a/src/execution/frames-inl.h
+++ b/src/execution/frames-inl.h
@@ -138,21 +138,21 @@ inline Tagged<Object> BuiltinExitFrame::receiver_slot_object() const {
   // ------- JS stack arguments ------
   // fp[6]: receiver
   const int receiverOffset = BuiltinExitFrameConstants::kFirstArgumentOffset;
-  return Object(base::Memory<Address>(fp() + receiverOffset));
+  return Tagged<Object>(base::Memory<Address>(fp() + receiverOffset));
 }
 
 inline Tagged<Object> BuiltinExitFrame::argc_slot_object() const {
-  return Object(
+  return Tagged<Object>(
       base::Memory<Address>(fp() + BuiltinExitFrameConstants::kArgcOffset));
 }
 
 inline Tagged<Object> BuiltinExitFrame::target_slot_object() const {
-  return Object(
+  return Tagged<Object>(
       base::Memory<Address>(fp() + BuiltinExitFrameConstants::kTargetOffset));
 }
 
 inline Tagged<Object> BuiltinExitFrame::new_target_slot_object() const {
-  return Object(base::Memory<Address>(
+  return Tagged<Object>(base::Memory<Address>(
       fp() + BuiltinExitFrameConstants::kNewTargetOffset));
 }
 
@@ -186,7 +186,7 @@ inline CommonFrame::CommonFrame(StackFrameIteratorBase* iterator)
     : StackFrame(iterator) {}
 
 inline Tagged<Object> CommonFrame::GetExpression(int index) const {
-  return Object(base::Memory<Address>(GetExpressionAddress(index)));
+  return Tagged<Object>(base::Memory<Address>(GetExpressionAddress(index)));
 }
 
 inline void CommonFrame::SetExpression(int index, Tagged<Object> value) {
@@ -230,7 +230,7 @@ inline void JavaScriptFrame::set_receiver(Tagged<Object> value) {
 
 inline Tagged<Object> JavaScriptFrame::function_slot_object() const {
   const int offset = StandardFrameConstants::kFunctionOffset;
-  return Object(base::Memory<Address>(fp() + offset));
+  return Tagged<Object>(base::Memory<Address>(fp() + offset));
 }
 
 inline TurbofanStubWithContextFrame::TurbofanStubWithContextFrame(
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 8459fb06c42..b9c770263b4 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -300,7 +300,7 @@ base::Optional<bool> IsInterpreterFramePc(Isolate* isolate, Address pc,
     MSAN_MEMORY_IS_INITIALIZED(
         state->fp + StandardFrameConstants::kFunctionOffset,
         kSystemPointerSize);
-    Tagged<Object> maybe_function = Object(
+    Tagged<Object> maybe_function = Tagged<Object>(
         Memory<Address>(state->fp + StandardFrameConstants::kFunctionOffset));
     // There's no need to run a full ContainsSlow if we know the frame can't be
     // an InterpretedFrame,  so we do these fast checks first
@@ -864,7 +864,7 @@ StackFrame::Type StackFrameIteratorForProfiler::ComputeStackFrameType(
 
   MSAN_MEMORY_IS_INITIALIZED(
       state->fp + StandardFrameConstants::kFunctionOffset, kSystemPointerSize);
-  Tagged<Object> maybe_function = Object(
+  Tagged<Object> maybe_function = Tagged<Object>(
       Memory<Address>(state->fp + StandardFrameConstants::kFunctionOffset));
   if (IsSmi(maybe_function)) {
     return StackFrame::NATIVE;
@@ -1043,7 +1043,7 @@ Tagged<Object> BuiltinExitFrame::GetParameter(int i) const {
   DCHECK(i >= 0 && i < ComputeParametersCount());
   int offset =
       BuiltinExitFrameConstants::kFirstArgumentOffset + i * kSystemPointerSize;
-  return Object(Memory<Address>(fp() + offset));
+  return Tagged<Object>(Memory<Address>(fp() + offset));
 }
 
 int BuiltinExitFrame::ComputeParametersCount() const {
@@ -1122,7 +1122,7 @@ Tagged<Object> ApiCallbackExitFrame::GetParameter(int i) const {
   DCHECK(i >= 0 && i < ComputeParametersCount());
   int offset = ApiCallbackExitFrameConstants::kFirstArgumentOffset +
                i * kSystemPointerSize;
-  return Object(Memory<Address>(fp() + offset));
+  return Tagged<Object>(Memory<Address>(fp() + offset));
 }
 
 int ApiCallbackExitFrame::ComputeParametersCount() const {
@@ -1325,7 +1325,7 @@ void VisitSpillSlot(Isolate* isolate, RootVisitor* v,
       if (DEBUG_BOOL) {
         // Ensure that the spill slot contains correct heap object.
         Tagged<HeapObject> raw =
-            HeapObject::cast(Object(*spill_slot.location()));
+            HeapObject::cast(Tagged<Object>(*spill_slot.location()));
         MapWord map_word = raw->map_word(cage_base, kRelaxedLoad);
         Tagged<HeapObject> forwarded = map_word.IsForwardingAddress()
                                            ? map_word.ToForwardingAddress(raw)
@@ -1525,7 +1525,7 @@ void WasmFrame::Iterate(RootVisitor* v) const {
 }
 
 void TypedFrame::IterateParamsOfWasmToJSWrapper(RootVisitor* v) const {
-  Tagged<Object> maybe_signature = Object(
+  Tagged<Object> maybe_signature = Tagged<Object>(
       Memory<Address>(fp() + WasmToJSWrapperConstants::kSignatureOffset));
   // The signature slot contains a marker and not a signature, so there is
   // nothing we have to iterate here.
@@ -2215,7 +2215,7 @@ void JavaScriptFrame::CollectFunctionAndOffsetForICStats(
 }
 
 Tagged<Object> CommonFrameWithJSLinkage::GetParameter(int index) const {
-  return Object(Memory<Address>(GetParameterSlot(index)));
+  return Tagged<Object>(Memory<Address>(GetParameterSlot(index)));
 }
 
 int CommonFrameWithJSLinkage::ComputeParametersCount() const {
@@ -2248,7 +2248,7 @@ Handle<FixedArray> CommonFrameWithJSLinkage::GetParameters() const {
 
 Tagged<JSFunction> JavaScriptBuiltinContinuationFrame::function() const {
   const int offset = BuiltinContinuationFrameConstants::kFunctionOffset;
-  return JSFunction::cast(Object(base::Memory<Address>(fp() + offset)));
+  return JSFunction::cast(Tagged<Object>(base::Memory<Address>(fp() + offset)));
 }
 
 int JavaScriptBuiltinContinuationFrame::ComputeParametersCount() const {
@@ -2264,12 +2264,12 @@ int JavaScriptBuiltinContinuationFrame::ComputeParametersCount() const {
 intptr_t JavaScriptBuiltinContinuationFrame::GetSPToFPDelta() const {
   Address height_slot =
       fp() + BuiltinContinuationFrameConstants::kFrameSPtoFPDeltaAtDeoptimize;
-  intptr_t height = Smi::ToInt(Smi(Memory<Address>(height_slot)));
+  intptr_t height = Smi::ToInt(Tagged<Smi>(Memory<Address>(height_slot)));
   return height;
 }
 
 Tagged<Object> JavaScriptBuiltinContinuationFrame::context() const {
-  return Object(Memory<Address>(
+  return Tagged<Object>(Memory<Address>(
       fp() + BuiltinContinuationFrameConstants::kBuiltinContextOffset));
 }
 
@@ -2282,7 +2282,7 @@ void JavaScriptBuiltinContinuationWithCatchFrame::SetException(
 
   // Only allow setting exception if previous value was the hole.
   CHECK_EQ(ReadOnlyRoots(isolate()).the_hole_value(),
-           Object(Memory<Address>(exception_argument_slot)));
+           Tagged<Object>(Memory<Address>(exception_argument_slot)));
   Memory<Address>(exception_argument_slot) = exception.ptr();
 }
 
@@ -2846,7 +2846,8 @@ int InterpretedFrame::GetBytecodeOffset(Address fp) {
             InterpreterFrameConstants::kExpressionsOffset -
                 index * kSystemPointerSize);
   Address expression_offset = fp + offset - index * kSystemPointerSize;
-  int raw_offset = Smi::ToInt(Object(Memory<Address>(expression_offset)));
+  int raw_offset =
+      Smi::ToInt(Tagged<Object>(Memory<Address>(expression_offset)));
   return raw_offset - BytecodeArray::kHeaderSize + kHeapObjectTag;
 }
 
@@ -2886,12 +2887,12 @@ void BaselineFrame::PatchContext(Tagged<Context> value) {
 
 Tagged<JSFunction> BuiltinFrame::function() const {
   const int offset = BuiltinFrameConstants::kFunctionOffset;
-  return JSFunction::cast(Object(base::Memory<Address>(fp() + offset)));
+  return JSFunction::cast(Tagged<Object>(base::Memory<Address>(fp() + offset)));
 }
 
 int BuiltinFrame::ComputeParametersCount() const {
   const int offset = BuiltinFrameConstants::kLengthOffset;
-  return Smi::ToInt(Object(base::Memory<Address>(fp() + offset))) -
+  return Smi::ToInt(Tagged<Object>(base::Memory<Address>(fp() + offset))) -
          kJSArgcReceiverSlots;
 }
 
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index c8dace0268b..4391be212f3 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -2376,7 +2376,7 @@ Isolate::CatchType ToCatchType(HandlerTable::CatchPrediction prediction) {
 
 Isolate::CatchType Isolate::PredictExceptionCatcher() {
   Address external_handler = thread_local_top()->try_catch_handler_address();
-  if (TopExceptionHandlerType(Object()) ==
+  if (TopExceptionHandlerType(Tagged<Object>()) ==
       ExceptionHandlerType::kExternalTryCatch) {
     return CAUGHT_BY_EXTERNAL;
   }
diff --git a/src/execution/isolate.h b/src/execution/isolate.h
index 8412dcb2eb8..a84b7237cd3 100644
--- a/src/execution/isolate.h
+++ b/src/execution/isolate.h
@@ -1232,7 +1232,7 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
   }
 
   Tagged<Object> root(RootIndex index) const {
-    return Object(roots_table()[index]);
+    return Tagged<Object>(roots_table()[index]);
   }
 
   Handle<Object> root_handle(RootIndex index) {
diff --git a/src/execution/microtask-queue.cc b/src/execution/microtask-queue.cc
index 290780fa181..f7ad6e9ab07 100644
--- a/src/execution/microtask-queue.cc
+++ b/src/execution/microtask-queue.cc
@@ -71,7 +71,7 @@ MicrotaskQueue::~MicrotaskQueue() {
 Address MicrotaskQueue::CallEnqueueMicrotask(Isolate* isolate,
                                              intptr_t microtask_queue_pointer,
                                              Address raw_microtask) {
-  Tagged<Microtask> microtask = Microtask::cast(Object(raw_microtask));
+  Tagged<Microtask> microtask = Microtask::cast(Tagged<Object>(raw_microtask));
   reinterpret_cast<MicrotaskQueue*>(microtask_queue_pointer)
       ->EnqueueMicrotask(microtask);
   return Smi::zero().ptr();
diff --git a/src/execution/simulator-base.h b/src/execution/simulator-base.h
index e974d5151be..efbf34cbd13 100644
--- a/src/execution/simulator-base.h
+++ b/src/execution/simulator-base.h
@@ -73,7 +73,7 @@ class SimulatorBase {
   template <typename T>
   static typename std::enable_if<std::is_base_of<Object, T>::value, T>::type
   ConvertReturn(intptr_t ret) {
-    return Object(ret);
+    return Tagged<Object>(ret);
   }
 
 #if V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_LOONG64
diff --git a/src/execution/thread-local-top.cc b/src/execution/thread-local-top.cc
index eb3ea9b36f1..d383fccd169 100644
--- a/src/execution/thread-local-top.cc
+++ b/src/execution/thread-local-top.cc
@@ -25,7 +25,7 @@ void ThreadLocalTop::Clear() {
   pending_handler_sp_ = kNullAddress;
   num_frames_above_pending_handler_ = 0;
   last_api_entry_ = kNullAddress;
-  pending_message_ = Object();
+  pending_message_ = Tagged<Object>();
   rethrowing_message_ = false;
   external_caught_exception_ = false;
   c_entry_fp_ = kNullAddress;
diff --git a/src/handles/global-handles.cc b/src/handles/global-handles.cc
index 7bf9188e72b..89a3b6d6ac1 100644
--- a/src/handles/global-handles.cc
+++ b/src/handles/global-handles.cc
@@ -335,7 +335,7 @@ class NodeBase {
     DCHECK(!AsChild()->IsInUse());
   }
 
-  Tagged<Object> object() const { return Object(object_); }
+  Tagged<Object> object() const { return Tagged<Object>(object_); }
   FullObjectSlot location() { return FullObjectSlot(&object_); }
   Handle<Object> handle() { return Handle<Object>(&object_); }
   Address raw_object() const { return object_; }
@@ -548,7 +548,7 @@ class GlobalHandles::Node final : public NodeBase<GlobalHandles::Node> {
     }
 
     // Zap with something dangerous.
-    location().store(Object(0xCA11));
+    location().store(Tagged<Object>(0xCA11));
 
     pending_phantom_callbacks->push_back(std::make_pair(
         this,
@@ -640,7 +640,7 @@ Handle<Object> GlobalHandles::CopyGlobal(Address* location) {
       Node::FromLocation(location)->global_handles();
 #ifdef VERIFY_HEAP
   if (v8_flags.verify_heap) {
-    Object::ObjectVerify(Object(*location), global_handles->isolate());
+    Object::ObjectVerify(Tagged<Object>(*location), global_handles->isolate());
   }
 #endif  // VERIFY_HEAP
   return global_handles->Create(*location);
@@ -1031,7 +1031,7 @@ void EternalHandles::IterateYoungRoots(RootVisitor* visitor) {
 void EternalHandles::PostGarbageCollectionProcessing() {
   size_t last = 0;
   for (int index : young_node_indices_) {
-    if (ObjectInYoungGeneration(Object(*GetLocation(index)))) {
+    if (ObjectInYoungGeneration(Tagged<Object>(*GetLocation(index)))) {
       young_node_indices_[last++] = index;
     }
   }
@@ -1042,7 +1042,7 @@ void EternalHandles::PostGarbageCollectionProcessing() {
 void EternalHandles::Create(Isolate* isolate, Tagged<Object> object,
                             int* index) {
   DCHECK_EQ(kInvalidIndex, *index);
-  if (object == Object()) return;
+  if (object == Tagged<Object>()) return;
   Tagged<Object> the_hole = ReadOnlyRoots(isolate).the_hole_value();
   DCHECK_NE(the_hole, object);
   int block = size_ >> kShift;
diff --git a/src/handles/handles-inl.h b/src/handles/handles-inl.h
index fb86c0d7d78..561e56d855f 100644
--- a/src/handles/handles-inl.h
+++ b/src/handles/handles-inl.h
@@ -35,7 +35,7 @@ bool HandleBase::is_identical_to(const HandleBase& that) const {
               (that.location_ == nullptr || that.IsDereferenceAllowed()));
   if (this->location_ == that.location_) return true;
   if (this->location_ == nullptr || that.location_ == nullptr) return false;
-  return Object(*this->location_) == Object(*that.location_);
+  return Tagged<Object>(*this->location_) == Tagged<Object>(*that.location_);
 }
 
 // Allocate a new handle for the object, do not canonicalize.
@@ -110,7 +110,7 @@ V8_INLINE DirectHandle<T>::DirectHandle(Tagged<T> object)
 template <typename T>
 template <typename S>
 V8_INLINE const DirectHandle<T> DirectHandle<T>::cast(DirectHandle<S> that) {
-  T::cast(Object(that.address()));
+  T::cast(Tagged<Object>(that.address()));
   return DirectHandle<T>(that.address());
 }
 
@@ -299,7 +299,7 @@ bool DirectHandleBase::is_identical_to(const DirectHandleBase& that) const {
   if (this->address() == kTaggedNullAddress ||
       that.address() == kTaggedNullAddress)
     return false;
-  return Object(this->address()) == Object(that.address());
+  return Tagged<Object>(this->address()) == Tagged<Object>(that.address());
 }
 #endif  // V8_ENABLE_DIRECT_HANDLE
 
diff --git a/src/heap/factory-base.h b/src/heap/factory-base.h
index 23d6ebb0131..b480a8a496f 100644
--- a/src/heap/factory-base.h
+++ b/src/heap/factory-base.h
@@ -146,7 +146,7 @@ class FactoryBase : public TorqueGeneratedFactory<Impl> {
   Handle<FixedArray> NewFixedArrayWithHoles(
       int length, AllocationType allocation = AllocationType::kYoung);
 
-  // Allocate a new fixed array with Smi(0) entries.
+  // Allocate a new fixed array with Tagged<Smi>(0) entries.
   Handle<FixedArray> NewFixedArrayWithZeroes(
       int length, AllocationType allocation = AllocationType::kYoung);
 
diff --git a/src/heap/heap-write-barrier.cc b/src/heap/heap-write-barrier.cc
index e7239e957f8..2c313443017 100644
--- a/src/heap/heap-write-barrier.cc
+++ b/src/heap/heap-write-barrier.cc
@@ -99,7 +99,7 @@ void WriteBarrier::MarkingSlow(Tagged<HeapObject> host,
 }
 
 int WriteBarrier::MarkingFromCode(Address raw_host, Address raw_slot) {
-  Tagged<HeapObject> host = HeapObject::cast(Object(raw_host));
+  Tagged<HeapObject> host = HeapObject::cast(Tagged<Object>(raw_host));
   MaybeObjectSlot slot(raw_slot);
   Address value = (*slot).ptr();
 
@@ -132,7 +132,7 @@ int WriteBarrier::MarkingFromCode(Address raw_host, Address raw_slot) {
 
 int WriteBarrier::IndirectPointerMarkingFromCode(Address raw_host,
                                                  Address raw_slot) {
-  Tagged<HeapObject> host = HeapObject::cast(Object(raw_host));
+  Tagged<HeapObject> host = HeapObject::cast(Tagged<Object>(raw_host));
   IndirectPointerSlot slot(raw_slot);
 
 #if DEBUG
@@ -154,7 +154,7 @@ int WriteBarrier::IndirectPointerMarkingFromCode(Address raw_host,
 }
 
 int WriteBarrier::SharedMarkingFromCode(Address raw_host, Address raw_slot) {
-  Tagged<HeapObject> host = HeapObject::cast(Object(raw_host));
+  Tagged<HeapObject> host = HeapObject::cast(Tagged<Object>(raw_host));
   MaybeObjectSlot slot(raw_slot);
   Address raw_value = (*slot).ptr();
   MaybeObject value(raw_value);
@@ -181,7 +181,7 @@ int WriteBarrier::SharedMarkingFromCode(Address raw_host, Address raw_slot) {
 }
 
 int WriteBarrier::SharedFromCode(Address raw_host, Address raw_slot) {
-  Tagged<HeapObject> host = HeapObject::cast(Object(raw_host));
+  Tagged<HeapObject> host = HeapObject::cast(Tagged<Object>(raw_host));
 
   if (!host.InWritableSharedSpace()) {
     Heap::SharedHeapBarrierSlow(host, raw_slot);
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index 9198b2b3c23..82a30e6215c 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -3271,7 +3271,8 @@ void CreateFillerObjectAtImpl(Heap* heap, Address addr, int size,
                                      SKIP_WRITE_BARRIER);
     FreeSpace::cast(filler)->set_size(size, kRelaxedStore);
     if (clear_memory_mode == ClearFreedMemoryMode::kClearFreedMemory) {
-      MemsetTagged(ObjectSlot(addr) + 2, Object(kClearedFreeMemoryValue),
+      MemsetTagged(ObjectSlot(addr) + 2,
+                   Tagged<Object>(kClearedFreeMemoryValue),
                    (size / kTaggedSize) - 2);
     }
 
@@ -3503,7 +3504,7 @@ Tagged<FixedArrayBase> Heap::LeftTrimFixedArray(Tagged<FixedArrayBase> object,
   // performed on pages which are not concurrently swept creating a filler
   // object does not require synchronization.
   RELAXED_WRITE_FIELD(object, bytes_to_trim,
-                      Object(MapWord::FromMap(map).ptr()));
+                      Tagged<Object>(MapWord::FromMap(map).ptr()));
   RELAXED_WRITE_FIELD(object, bytes_to_trim + kTaggedSize,
                       Smi::FromInt(len - elements_to_trim));
 
@@ -3613,7 +3614,7 @@ void Heap::CreateFillerForArray(Tagged<T> object, int elements_to_trim,
   } else if (clear_slots) {
     // Large objects are not swept, so it is not necessary to clear the
     // recorded slot.
-    MemsetTagged(ObjectSlot(new_end), Object(kClearedFreeMemoryValue),
+    MemsetTagged(ObjectSlot(new_end), Tagged<Object>(kClearedFreeMemoryValue),
                  (old_end - new_end) / kTaggedSize);
   }
 
@@ -4626,7 +4627,7 @@ class ClearStaleLeftTrimmedHandlesVisitor : public RootVisitor {
         } else {
           next += current->Size();
         }
-        current = HeapObject::cast(Object(next));
+        current = HeapObject::cast(Tagged<Object>(next));
       }
       DCHECK(
           current->map_word(cage_base(), kRelaxedLoad).IsForwardingAddress() ||
diff --git a/src/heap/mark-compact.cc b/src/heap/mark-compact.cc
index df64ae88fc1..c9f4c4d7805 100644
--- a/src/heap/mark-compact.cc
+++ b/src/heap/mark-compact.cc
@@ -3274,7 +3274,8 @@ void MarkCompactCollector::RightTrimDescriptorArray(
     }
     if (heap::ShouldZapGarbage()) {
       Address zap_end = std::min(aligned_start, end);
-      MemsetTagged(ObjectSlot(start), Object(static_cast<Address>(kZapValue)),
+      MemsetTagged(ObjectSlot(start),
+                   Tagged<Object>(static_cast<Address>(kZapValue)),
                    (zap_end - start) >> kTaggedSizeLog2);
     }
   } else {
diff --git a/src/heap/objects-visiting.cc b/src/heap/objects-visiting.cc
index b283d1310a6..c1b182b5de7 100644
--- a/src/heap/objects-visiting.cc
+++ b/src/heap/objects-visiting.cc
@@ -41,7 +41,7 @@ Tagged<Object> VisitWeakList(Heap* heap, Tagged<Object> list,
     // Move to the next element before the WeakNext is cleared.
     list = WeakListVisitor<T>::WeakNext(candidate);
 
-    if (retained != Object()) {
+    if (retained != Tagged<Object>()) {
       if (head == undefined) {
         // First element in the list.
         head = retained;
diff --git a/src/heap/read-only-promotion.cc b/src/heap/read-only-promotion.cc
index da5d20cf96e..c8a8b1ab19e 100644
--- a/src/heap/read-only-promotion.cc
+++ b/src/heap/read-only-promotion.cc
@@ -410,7 +410,7 @@ class ReadOnlyPromotionImpl final : public AllStatic {
 
       IndirectPointerHandle handle = slot.Relaxed_LoadHandle();
       CodePointerTable* cpt = GetProcessWideCodePointerTable();
-      CHECK_EQ(dead_code, Object(cpt->GetCodeObject(handle)));
+      CHECK_EQ(dead_code, Tagged<Object>(cpt->GetCodeObject(handle)));
 
       // The old Code object (in mutable space) is dead. To preserve the 1:1
       // relation between Code objects and CPT entries, overwrite it immediately
diff --git a/src/heap/remembered-set-inl.h b/src/heap/remembered-set-inl.h
index 09f7608c758..370da71e454 100644
--- a/src/heap/remembered-set-inl.h
+++ b/src/heap/remembered-set-inl.h
@@ -35,8 +35,8 @@ SlotCallbackResult UpdateTypedSlotHelper::UpdateTypedSlot(Heap* heap,
       return UpdateEmbeddedPointer(heap, &rinfo, callback);
     }
     case SlotType::kConstPoolEmbeddedObjectCompressed: {
-      Tagged<HeapObject> old_target =
-          HeapObject::cast(Object(V8HeapCompressionScheme::DecompressTagged(
+      Tagged<HeapObject> old_target = HeapObject::cast(
+          Tagged<Object>(V8HeapCompressionScheme::DecompressTagged(
               heap->isolate(), base::Memory<Tagged_t>(addr))));
       Tagged<HeapObject> new_target = old_target;
       SlotCallbackResult result = callback(FullMaybeObjectSlot(&new_target));
@@ -78,7 +78,7 @@ Tagged<HeapObject> UpdateTypedSlotHelper::GetTargetObject(Heap* heap,
     case SlotType::kConstPoolEmbeddedObjectCompressed: {
       Address full = V8HeapCompressionScheme::DecompressTagged(
           heap->isolate(), base::Memory<Tagged_t>(addr));
-      return HeapObject::cast(Object(full));
+      return HeapObject::cast(Tagged<Object>(full));
     }
     case SlotType::kConstPoolEmbeddedObjectFull: {
       FullHeapObjectSlot slot(addr);
diff --git a/src/heap/setup-heap-internal.cc b/src/heap/setup-heap-internal.cc
index fc7570907bc..7950efb783f 100644
--- a/src/heap/setup-heap-internal.cc
+++ b/src/heap/setup-heap-internal.cc
@@ -1475,13 +1475,13 @@ void Heap::CreateInternalAccessorInfoObjects() {
   ACCESSOR_INFO_LIST_GENERATOR(INIT_ACCESSOR_INFO, /* not used */)
 #undef INIT_ACCESSOR_INFO
 
-#define INIT_SIDE_EFFECT_FLAG(_, accessor_name, AccessorName, GetterType, \
-                              SetterType)                                 \
-  AccessorInfo::cast(                                                     \
-      Object(roots_table()[RootIndex::k##AccessorName##Accessor]))        \
-      ->set_getter_side_effect_type(SideEffectType::GetterType);          \
-  AccessorInfo::cast(                                                     \
-      Object(roots_table()[RootIndex::k##AccessorName##Accessor]))        \
+#define INIT_SIDE_EFFECT_FLAG(_, accessor_name, AccessorName, GetterType,  \
+                              SetterType)                                  \
+  AccessorInfo::cast(                                                      \
+      Tagged<Object>(roots_table()[RootIndex::k##AccessorName##Accessor])) \
+      ->set_getter_side_effect_type(SideEffectType::GetterType);           \
+  AccessorInfo::cast(                                                      \
+      Tagged<Object>(roots_table()[RootIndex::k##AccessorName##Accessor])) \
       ->set_setter_side_effect_type(SideEffectType::SetterType);
   ACCESSOR_INFO_LIST_GENERATOR(INIT_SIDE_EFFECT_FLAG, /* not used */)
 #undef INIT_SIDE_EFFECT_FLAG
diff --git a/src/heap/zapping.cc b/src/heap/zapping.cc
index 574a58e7102..bc6d8e3ff74 100644
--- a/src/heap/zapping.cc
+++ b/src/heap/zapping.cc
@@ -26,7 +26,8 @@ void ZapBlock(Address start, size_t size, uintptr_t zap_value) {
   DCHECK(ShouldZapGarbage());
   DCHECK(IsAligned(start, kTaggedSize));
   DCHECK(IsAligned(size, kTaggedSize));
-  MemsetTagged(ObjectSlot(start), Object(static_cast<Address>(zap_value)),
+  MemsetTagged(ObjectSlot(start),
+               Tagged<Object>(static_cast<Address>(zap_value)),
                size >> kTaggedSizeLog2);
 }
 
diff --git a/src/ic/ic.cc b/src/ic/ic.cc
index 8348f60a970..4c7c7922854 100644
--- a/src/ic/ic.cc
+++ b/src/ic/ic.cc
@@ -3317,8 +3317,8 @@ RUNTIME_FUNCTION(Runtime_CloneObjectIC_Miss) {
             return *source_map;
           }
           case FastCloneObjectMode::kEmptyObject: {
-            nexus.ConfigureCloneObject(source_map,
-                                       MaybeObjectHandle(Smi(0), isolate));
+            nexus.ConfigureCloneObject(
+                source_map, MaybeObjectHandle(Tagged<Smi>(0), isolate));
             RETURN_RESULT_OR_FAILURE(
                 isolate, CloneObjectSlowPath(isolate, source, flags));
           }
diff --git a/src/numbers/math-random.cc b/src/numbers/math-random.cc
index 53fb393416c..fb738644b7e 100644
--- a/src/numbers/math-random.cc
+++ b/src/numbers/math-random.cc
@@ -33,7 +33,8 @@ void MathRandom::ResetContext(Tagged<Context> native_context) {
 }
 
 Address MathRandom::RefillCache(Isolate* isolate, Address raw_native_context) {
-  Tagged<Context> native_context = Context::cast(Object(raw_native_context));
+  Tagged<Context> native_context =
+      Context::cast(Tagged<Object>(raw_native_context));
   DisallowGarbageCollection no_gc;
   Tagged<PodArray<State>> pod =
       PodArray<State>::cast(native_context->math_random_state());
diff --git a/src/objects/bigint.cc b/src/objects/bigint.cc
index 52693852162..aca8e97a40f 100644
--- a/src/objects/bigint.cc
+++ b/src/objects/bigint.cc
@@ -1643,26 +1643,28 @@ void BigIntBase::BigIntBasePrint(std::ostream& os) {
 
 void MutableBigInt_AbsoluteAddAndCanonicalize(Address result_addr,
                                               Address x_addr, Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::Add(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
 }
 
 int32_t MutableBigInt_AbsoluteCompare(Address x_addr, Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
 
   return bigint::Compare(GetDigits(x), GetDigits(y));
 }
 
 void MutableBigInt_AbsoluteSubAndCanonicalize(Address result_addr,
                                               Address x_addr, Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::Subtract(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1673,9 +1675,10 @@ void MutableBigInt_AbsoluteSubAndCanonicalize(Address result_addr,
 int32_t MutableBigInt_AbsoluteMulAndCanonicalize(Address result_addr,
                                                  Address x_addr,
                                                  Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   Isolate* isolate;
   if (!GetIsolateFromHeapObject(x, &isolate)) {
@@ -1696,9 +1699,10 @@ int32_t MutableBigInt_AbsoluteMulAndCanonicalize(Address result_addr,
 int32_t MutableBigInt_AbsoluteDivAndCanonicalize(Address result_addr,
                                                  Address x_addr,
                                                  Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
   DCHECK_GE(result->length(),
             bigint::DivideResultLength(GetDigits(x), GetDigits(y)));
 
@@ -1721,9 +1725,10 @@ int32_t MutableBigInt_AbsoluteDivAndCanonicalize(Address result_addr,
 int32_t MutableBigInt_AbsoluteModAndCanonicalize(Address result_addr,
                                                  Address x_addr,
                                                  Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   Isolate* isolate;
   if (!GetIsolateFromHeapObject(x, &isolate)) {
@@ -1744,9 +1749,10 @@ int32_t MutableBigInt_AbsoluteModAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseAndPosPosAndCanonicalize(Address result_addr,
                                                    Address x_addr,
                                                    Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseAnd_PosPos(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1755,9 +1761,10 @@ void MutableBigInt_BitwiseAndPosPosAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseAndNegNegAndCanonicalize(Address result_addr,
                                                    Address x_addr,
                                                    Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseAnd_NegNeg(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1766,9 +1773,10 @@ void MutableBigInt_BitwiseAndNegNegAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseAndPosNegAndCanonicalize(Address result_addr,
                                                    Address x_addr,
                                                    Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseAnd_PosNeg(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1777,9 +1785,10 @@ void MutableBigInt_BitwiseAndPosNegAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseOrPosPosAndCanonicalize(Address result_addr,
                                                   Address x_addr,
                                                   Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseOr_PosPos(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1788,9 +1797,10 @@ void MutableBigInt_BitwiseOrPosPosAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseOrNegNegAndCanonicalize(Address result_addr,
                                                   Address x_addr,
                                                   Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseOr_NegNeg(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1799,9 +1809,10 @@ void MutableBigInt_BitwiseOrNegNegAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseOrPosNegAndCanonicalize(Address result_addr,
                                                   Address x_addr,
                                                   Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseOr_PosNeg(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1810,9 +1821,10 @@ void MutableBigInt_BitwiseOrPosNegAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseXorPosPosAndCanonicalize(Address result_addr,
                                                    Address x_addr,
                                                    Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseXor_PosPos(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1821,9 +1833,10 @@ void MutableBigInt_BitwiseXorPosPosAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseXorNegNegAndCanonicalize(Address result_addr,
                                                    Address x_addr,
                                                    Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseXor_NegNeg(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1832,9 +1845,10 @@ void MutableBigInt_BitwiseXorNegNegAndCanonicalize(Address result_addr,
 void MutableBigInt_BitwiseXorPosNegAndCanonicalize(Address result_addr,
                                                    Address x_addr,
                                                    Address y_addr) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<BigInt> y = BigInt::cast(Object(y_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<BigInt> y = BigInt::cast(Tagged<Object>(y_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::BitwiseXor_PosNeg(GetRWDigits(result), GetDigits(x), GetDigits(y));
   MutableBigInt::Canonicalize(result);
@@ -1842,8 +1856,9 @@ void MutableBigInt_BitwiseXorPosNegAndCanonicalize(Address result_addr,
 
 void MutableBigInt_LeftShiftAndCanonicalize(Address result_addr, Address x_addr,
                                             intptr_t shift) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
 
   bigint::LeftShift(GetRWDigits(result), GetDigits(x), shift);
   MutableBigInt::Canonicalize(result);
@@ -1851,7 +1866,7 @@ void MutableBigInt_LeftShiftAndCanonicalize(Address result_addr, Address x_addr,
 
 uint32_t RightShiftResultLength(Address x_addr, uint32_t x_sign,
                                 intptr_t shift) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
   bigint::RightShiftState state;
   int length =
       bigint::RightShift_ResultLength(GetDigits(x), x_sign, shift, &state);
@@ -1865,8 +1880,9 @@ uint32_t RightShiftResultLength(Address x_addr, uint32_t x_sign,
 void MutableBigInt_RightShiftAndCanonicalize(Address result_addr,
                                              Address x_addr, intptr_t shift,
                                              uint32_t must_round_down) {
-  Tagged<BigInt> x = BigInt::cast(Object(x_addr));
-  Tagged<MutableBigInt> result = MutableBigInt::cast(Object(result_addr));
+  Tagged<BigInt> x = BigInt::cast(Tagged<Object>(x_addr));
+  Tagged<MutableBigInt> result =
+      MutableBigInt::cast(Tagged<Object>(result_addr));
   bigint::RightShiftState state{must_round_down == 1};
   bigint::RightShift(GetRWDigits(result), GetDigits(x), shift, state);
   MutableBigInt::Canonicalize(result);
diff --git a/src/objects/compressed-slots-inl.h b/src/objects/compressed-slots-inl.h
index aefe15d05e3..edd3b9b9da9 100644
--- a/src/objects/compressed-slots-inl.h
+++ b/src/objects/compressed-slots-inl.h
@@ -36,12 +36,12 @@ bool CompressedObjectSlot::Relaxed_ContainsMapValue(Address raw_value) const {
 
 Tagged<Object> CompressedObjectSlot::operator*() const {
   Tagged_t value = *location();
-  return Object(TCompressionScheme::DecompressTagged(address(), value));
+  return Tagged<Object>(TCompressionScheme::DecompressTagged(address(), value));
 }
 
 Tagged<Object> CompressedObjectSlot::load(PtrComprCageBase cage_base) const {
   Tagged_t value = *location();
-  return Object(TCompressionScheme::DecompressTagged(cage_base, value));
+  return Tagged<Object>(TCompressionScheme::DecompressTagged(cage_base, value));
 }
 
 void CompressedObjectSlot::store(Tagged<Object> value) const {
@@ -64,18 +64,18 @@ Tagged<Map> CompressedObjectSlot::load_map() const {
 
 Tagged<Object> CompressedObjectSlot::Acquire_Load() const {
   AtomicTagged_t value = AsAtomicTagged::Acquire_Load(location());
-  return Object(TCompressionScheme::DecompressTagged(address(), value));
+  return Tagged<Object>(TCompressionScheme::DecompressTagged(address(), value));
 }
 
 Tagged<Object> CompressedObjectSlot::Relaxed_Load() const {
   AtomicTagged_t value = AsAtomicTagged::Relaxed_Load(location());
-  return Object(TCompressionScheme::DecompressTagged(address(), value));
+  return Tagged<Object>(TCompressionScheme::DecompressTagged(address(), value));
 }
 
 Tagged<Object> CompressedObjectSlot::Relaxed_Load(
     PtrComprCageBase cage_base) const {
   AtomicTagged_t value = AsAtomicTagged::Relaxed_Load(location());
-  return Object(TCompressionScheme::DecompressTagged(cage_base, value));
+  return Tagged<Object>(TCompressionScheme::DecompressTagged(cage_base, value));
 }
 
 void CompressedObjectSlot::Relaxed_Store(Tagged<Object> value) const {
@@ -94,7 +94,8 @@ Tagged<Object> CompressedObjectSlot::Release_CompareAndSwap(
   Tagged_t target_ptr = TCompressionScheme::CompressObject(target.ptr());
   Tagged_t result =
       AsAtomicTagged::Release_CompareAndSwap(location(), old_ptr, target_ptr);
-  return Object(TCompressionScheme::DecompressTagged(address(), result));
+  return Tagged<Object>(
+      TCompressionScheme::DecompressTagged(address(), result));
 }
 
 //
@@ -163,7 +164,7 @@ Tagged<HeapObject> CompressedHeapObjectSlot::ToHeapObject() const {
   Tagged_t value = *location();
   DCHECK(HAS_STRONG_HEAP_OBJECT_TAG(value));
   return HeapObject::cast(
-      Object(TCompressionScheme::DecompressTagged(address(), value)));
+      Tagged<Object>(TCompressionScheme::DecompressTagged(address(), value)));
 }
 
 void CompressedHeapObjectSlot::StoreHeapObject(Tagged<HeapObject> value) const {
@@ -178,7 +179,7 @@ template <typename CompressionScheme>
 Tagged<Object> OffHeapCompressedObjectSlot<CompressionScheme>::load(
     PtrComprCageBase cage_base) const {
   Tagged_t value = *TSlotBase::location();
-  return Object(CompressionScheme::DecompressTagged(cage_base, value));
+  return Tagged<Object>(CompressionScheme::DecompressTagged(cage_base, value));
 }
 
 template <typename CompressionScheme>
@@ -191,14 +192,14 @@ template <typename CompressionScheme>
 Tagged<Object> OffHeapCompressedObjectSlot<CompressionScheme>::Relaxed_Load(
     PtrComprCageBase cage_base) const {
   AtomicTagged_t value = AsAtomicTagged::Relaxed_Load(TSlotBase::location());
-  return Object(CompressionScheme::DecompressTagged(cage_base, value));
+  return Tagged<Object>(CompressionScheme::DecompressTagged(cage_base, value));
 }
 
 template <typename CompressionScheme>
 Tagged<Object> OffHeapCompressedObjectSlot<CompressionScheme>::Acquire_Load(
     PtrComprCageBase cage_base) const {
   AtomicTagged_t value = AsAtomicTagged::Acquire_Load(TSlotBase::location());
-  return Object(CompressionScheme::DecompressTagged(cage_base, value));
+  return Tagged<Object>(CompressionScheme::DecompressTagged(cage_base, value));
 }
 
 template <typename CompressionScheme>
diff --git a/src/objects/descriptor-array.h b/src/objects/descriptor-array.h
index 4b00ecadd44..76254e4a4fa 100644
--- a/src/objects/descriptor-array.h
+++ b/src/objects/descriptor-array.h
@@ -44,7 +44,8 @@ class EnumCache : public TorqueGeneratedEnumCache<EnumCache, Struct> {
 //   Elements:
 //     [kHeaderSize + 0]: first key (and internalized String)
 //     [kHeaderSize + 1]: first descriptor details (see PropertyDetails)
-//     [kHeaderSize + 2]: first value for constants / Smi(1) when not used
+//     [kHeaderSize + 2]: first value for constants / Tagged<Smi>(1) when not
+//     used
 //   Slack:
 //     [kHeaderSize + number of descriptors * 3]: start of slack
 // The "value" fields store either values or field types. A field type is either
diff --git a/src/objects/dictionary.h b/src/objects/dictionary.h
index 887c2157b0c..9cfef9e0b14 100644
--- a/src/objects/dictionary.h
+++ b/src/objects/dictionary.h
@@ -447,10 +447,10 @@ template <typename Dictionary>
 struct EnumIndexComparator {
   explicit EnumIndexComparator(Tagged<Dictionary> dict) : dict(dict) {}
   bool operator()(Tagged_t a, Tagged_t b) {
-    PropertyDetails da(
-        dict->DetailsAt(InternalIndex(Smi(static_cast<Address>(a)).value())));
-    PropertyDetails db(
-        dict->DetailsAt(InternalIndex(Smi(static_cast<Address>(b)).value())));
+    PropertyDetails da(dict->DetailsAt(
+        InternalIndex(Tagged<Smi>(static_cast<Address>(a)).value())));
+    PropertyDetails db(dict->DetailsAt(
+        InternalIndex(Tagged<Smi>(static_cast<Address>(b)).value())));
     return da.dictionary_index() < db.dictionary_index();
   }
   Tagged<Dictionary> dict;
diff --git a/src/objects/elements.cc b/src/objects/elements.cc
index 11c067decbf..6734427f62e 100644
--- a/src/objects/elements.cc
+++ b/src/objects/elements.cc
@@ -5441,10 +5441,10 @@ void CopyFastNumberJSArrayElementsToTypedArray(Address raw_context,
                                                Address raw_destination,
                                                uintptr_t length,
                                                uintptr_t offset) {
-  Tagged<Context> context = Context::cast(Object(raw_context));
-  Tagged<JSArray> source = JSArray::cast(Object(raw_source));
+  Tagged<Context> context = Context::cast(Tagged<Object>(raw_context));
+  Tagged<JSArray> source = JSArray::cast(Tagged<Object>(raw_source));
   Tagged<JSTypedArray> destination =
-      JSTypedArray::cast(Object(raw_destination));
+      JSTypedArray::cast(Tagged<Object>(raw_destination));
 
   switch (destination->GetElementsKind()) {
 #define TYPED_ARRAYS_CASE(Type, type, TYPE, ctype)           \
@@ -5463,9 +5463,9 @@ void CopyFastNumberJSArrayElementsToTypedArray(Address raw_context,
 void CopyTypedArrayElementsToTypedArray(Address raw_source,
                                         Address raw_destination,
                                         uintptr_t length, uintptr_t offset) {
-  Tagged<JSTypedArray> source = JSTypedArray::cast(Object(raw_source));
+  Tagged<JSTypedArray> source = JSTypedArray::cast(Tagged<Object>(raw_source));
   Tagged<JSTypedArray> destination =
-      JSTypedArray::cast(Object(raw_destination));
+      JSTypedArray::cast(Tagged<Object>(raw_destination));
 
   switch (destination->GetElementsKind()) {
 #define TYPED_ARRAYS_CASE(Type, type, TYPE, ctype)                          \
@@ -5483,9 +5483,9 @@ void CopyTypedArrayElementsToTypedArray(Address raw_source,
 
 void CopyTypedArrayElementsSlice(Address raw_source, Address raw_destination,
                                  uintptr_t start, uintptr_t end) {
-  Tagged<JSTypedArray> source = JSTypedArray::cast(Object(raw_source));
+  Tagged<JSTypedArray> source = JSTypedArray::cast(Tagged<Object>(raw_source));
   Tagged<JSTypedArray> destination =
-      JSTypedArray::cast(Object(raw_destination));
+      JSTypedArray::cast(Tagged<Object>(raw_destination));
 
   destination->GetElementsAccessor()->CopyTypedArrayElementsSlice(
       source, destination, start, end);
diff --git a/src/objects/embedder-data-slot-inl.h b/src/objects/embedder-data-slot-inl.h
index d4e5a9b932b..ab79c85bd21 100644
--- a/src/objects/embedder-data-slot-inl.h
+++ b/src/objects/embedder-data-slot-inl.h
@@ -180,13 +180,14 @@ void EmbedderDataSlot::gc_safe_store(Isolate* isolate, Address value) {
   // TODO(ishell, v8:8875): revisit this once the allocation alignment
   // inconsistency is fixed.
   Address lo = static_cast<intptr_t>(static_cast<int32_t>(value));
-  ObjectSlot(address() + kTaggedPayloadOffset).Relaxed_Store(Smi(lo));
+  ObjectSlot(address() + kTaggedPayloadOffset).Relaxed_Store(Tagged<Smi>(lo));
   Address hi = value >> 32;
   // Here we use MaybeObjectSlot because ObjectSlot expects a valid `Object`.
   // This allows us to store a non-smi, that is not a valid `HeapObject`.
   MaybeObjectSlot(address() + kRawPayloadOffset).Relaxed_Store(MaybeObject(hi));
 #else
-  ObjectSlot(address() + kTaggedPayloadOffset).Relaxed_Store(Smi(value));
+  ObjectSlot(address() + kTaggedPayloadOffset)
+      .Relaxed_Store(Tagged<Smi>(value));
 #endif
 }
 
diff --git a/src/objects/fixed-array-inl.h b/src/objects/fixed-array-inl.h
index fdc775eeb65..aad2e96dade 100644
--- a/src/objects/fixed-array-inl.h
+++ b/src/objects/fixed-array-inl.h
@@ -690,7 +690,8 @@ void ByteArray::clear_padding() {
 
 Tagged<ByteArray> ByteArray::FromDataStartAddress(Address address) {
   DCHECK_TAG_ALIGNED(address);
-  return ByteArray::cast(Object(address - kHeaderSize + kHeapObjectTag));
+  return ByteArray::cast(
+      Tagged<Object>(address - kHeaderSize + kHeapObjectTag));
 }
 
 int ByteArray::DataSize() const { return RoundUp(length(), kTaggedSize); }
diff --git a/src/objects/free-space-inl.h b/src/objects/free-space-inl.h
index d250ffb7717..54ae43cb979 100644
--- a/src/objects/free-space-inl.h
+++ b/src/objects/free-space-inl.h
@@ -34,7 +34,7 @@ Tagged<FreeSpace> FreeSpace::next() const {
     return FreeSpace();
   }
   Address next_ptr = ptr() + diff_to_next * kObjectAlignment;
-  return FreeSpace::unchecked_cast(Object(next_ptr));
+  return FreeSpace::unchecked_cast(Tagged<Object>(next_ptr));
 #else
   return FreeSpace::unchecked_cast(
       TaggedField<Object, kNextOffset>::load(*this));
diff --git a/src/objects/js-array-buffer.cc b/src/objects/js-array-buffer.cc
index 8644f3a28db..95dbe900828 100644
--- a/src/objects/js-array-buffer.cc
+++ b/src/objects/js-array-buffer.cc
@@ -177,7 +177,8 @@ size_t JSArrayBuffer::GsabByteLength(Isolate* isolate,
   DCHECK(v8_flags.harmony_rab_gsab);
   DisallowGarbageCollection no_gc;
   DisallowJavascriptExecution no_js(isolate);
-  Tagged<JSArrayBuffer> buffer = JSArrayBuffer::cast(Object(raw_array_buffer));
+  Tagged<JSArrayBuffer> buffer =
+      JSArrayBuffer::cast(Tagged<Object>(raw_array_buffer));
   CHECK(buffer->is_resizable_by_js());
   CHECK(buffer->is_shared());
   return buffer->GetBackingStore()->byte_length(std::memory_order_seq_cst);
@@ -404,7 +405,7 @@ size_t JSTypedArray::LengthTrackingGsabBackedTypedArrayLength(
   DCHECK(v8_flags.harmony_rab_gsab);
   DisallowGarbageCollection no_gc;
   DisallowJavascriptExecution no_js(isolate);
-  Tagged<JSTypedArray> array = JSTypedArray::cast(Object(raw_array));
+  Tagged<JSTypedArray> array = JSTypedArray::cast(Tagged<Object>(raw_array));
   CHECK(array->is_length_tracking());
   Tagged<JSArrayBuffer> buffer = array->buffer();
   CHECK(buffer->is_resizable_by_js());
diff --git a/src/objects/js-objects-inl.h b/src/objects/js-objects-inl.h
index 4a8c6484803..0f38fbc053f 100644
--- a/src/objects/js-objects-inl.h
+++ b/src/objects/js-objects-inl.h
@@ -594,7 +594,7 @@ void JSObject::InitializeBody(Tagged<Map> map, int start_offset,
     }
     // fill the remainder with one word filler objects (ie just a map word)
     while (offset < size) {
-      Tagged<Object> fm = Object(filler_map.ptr());
+      Tagged<Object> fm = Tagged<Object>(filler_map.ptr());
       WRITE_FIELD(*this, offset, fm);
       offset += kTaggedSize;
     }
diff --git a/src/objects/js-objects.cc b/src/objects/js-objects.cc
index 692aa0b0252..c392b841434 100644
--- a/src/objects/js-objects.cc
+++ b/src/objects/js-objects.cc
@@ -5141,7 +5141,7 @@ void InvalidateOnePrototypeValidityCellInternal(Tagged<Map> map) {
   }
   Tagged<PrototypeInfo> prototype_info;
   if (map->TryGetPrototypeInfo(&prototype_info)) {
-    prototype_info->set_prototype_chain_enum_cache(Object());
+    prototype_info->set_prototype_chain_enum_cache(Tagged<Object>());
   }
 
   // We may inline accesses to constants stored in dictionary mode prototypes in
diff --git a/src/objects/keys.cc b/src/objects/keys.cc
index c35ff86f991..b93033cfb0b 100644
--- a/src/objects/keys.cc
+++ b/src/objects/keys.cc
@@ -1161,7 +1161,7 @@ Maybe<bool> KeyAccumulator::CollectOwnKeys(Handle<JSReceiver> receiver,
     }
     // We always have both kinds of interceptors or none.
     if (!access_check_info.is_null() &&
-        access_check_info->named_interceptor() != Object()) {
+        access_check_info->named_interceptor() != Tagged<Object>()) {
       MAYBE_RETURN(CollectAccessCheckInterceptorKeys(access_check_info,
                                                      receiver, object),
                    Nothing<bool>());
diff --git a/src/objects/lookup.cc b/src/objects/lookup.cc
index abf82b6dda4..2233c2adf01 100644
--- a/src/objects/lookup.cc
+++ b/src/objects/lookup.cc
@@ -1367,7 +1367,7 @@ Handle<InterceptorInfo> LookupIterator::GetInterceptorForFailedAccessCheck()
     Tagged<Object> interceptor = is_js_array_element(IsElement())
                                      ? access_check_info->indexed_interceptor()
                                      : access_check_info->named_interceptor();
-    if (interceptor != Object()) {
+    if (interceptor != Tagged<Object>()) {
       return handle(InterceptorInfo::cast(interceptor), isolate_);
     }
   }
diff --git a/src/objects/map.h b/src/objects/map.h
index 88956b22848..53f75a3b3df 100644
--- a/src/objects/map.h
+++ b/src/objects/map.h
@@ -648,7 +648,7 @@ class Map : public TorqueGeneratedMap<Map, HeapObject> {
   DECL_ACCESSORS(dependent_code, Tagged<DependentCode>)
 
   // [prototype_validity_cell]: Cell containing the validity bit for prototype
-  // chains or Smi(0) if uninitialized.
+  // chains or Tagged<Smi>(0) if uninitialized.
   // The meaning of this validity cell is different for prototype maps and
   // non-prototype maps.
   // For prototype maps the validity bit "guards" modifications of prototype
diff --git a/src/objects/object-macros.h b/src/objects/object-macros.h
index 1f1962f1bb1..e80c54995c9 100644
--- a/src/objects/object-macros.h
+++ b/src/objects/object-macros.h
@@ -28,8 +28,6 @@
   const Type* operator->() const { return this; }                              \
                                                                                \
  protected:                                                                    \
-  template <typename TFieldType, int kFieldOffset, typename CompressionScheme> \
-  friend class TaggedField;                                                    \
   friend class Tagged<Type>;                                                   \
                                                                                \
   /* Special constructor for constexpr construction which allows skipping type \
diff --git a/src/objects/object-type.cc b/src/objects/object-type.cc
index 2424f4aa107..3bb1d61ecee 100644
--- a/src/objects/object-type.cc
+++ b/src/objects/object-type.cc
@@ -14,8 +14,8 @@ namespace internal {
 Address CheckObjectType(Address raw_value, Address raw_type,
                         Address raw_location) {
 #ifdef DEBUG
-  ObjectType type = static_cast<ObjectType>(Smi(raw_type).value());
-  Tagged<String> location = String::cast(Object(raw_location));
+  ObjectType type = static_cast<ObjectType>(Tagged<Smi>(raw_type).value());
+  Tagged<String> location = String::cast(Tagged<Object>(raw_location));
   const char* expected;
 
   if (HAS_WEAK_HEAP_OBJECT_TAG(raw_value)) {
diff --git a/src/objects/objects-inl.h b/src/objects/objects-inl.h
index 0fa883e3340..2bf9381582b 100644
--- a/src/objects/objects-inl.h
+++ b/src/objects/objects-inl.h
@@ -73,7 +73,8 @@ int PropertyDetails::field_width_in_words() const {
 }
 
 bool IsTaggedIndex(Tagged<Object> obj) {
-  return IsSmi(obj) && TaggedIndex::IsValid(TaggedIndex(obj.ptr()).value());
+  return IsSmi(obj) &&
+         TaggedIndex::IsValid(Tagged<TaggedIndex>(obj.ptr()).value());
 }
 
 DEF_HEAP_OBJECT_PREDICATE(HeapObject, IsClassBoilerplate) {
@@ -861,9 +862,9 @@ MapWord MapWord::FromMap(const Tagged<Map> map) {
 
 Tagged<Map> MapWord::ToMap() const {
 #ifdef V8_MAP_PACKING
-  return Map::unchecked_cast(Object(Unpack(value_)));
+  return Map::unchecked_cast(Tagged<Object>(Unpack(value_)));
 #else
-  return Map::unchecked_cast(Object(value_));
+  return Map::unchecked_cast(Tagged<Object>(value_));
 #endif
 }
 
@@ -901,7 +902,8 @@ Tagged<HeapObject> MapWord::ToForwardingAddress(
   // When external code space is enabled forwarding pointers are encoded as
   // Smi representing a diff from the source object address in kObjectAlignment
   // chunks.
-  intptr_t diff = static_cast<intptr_t>(Smi(value_).value()) * kObjectAlignment;
+  intptr_t diff =
+      static_cast<intptr_t>(Tagged<Smi>(value_).value()) * kObjectAlignment;
   Address address = map_word_host.address() + diff;
   return HeapObject::FromAddress(address);
 #else
diff --git a/src/objects/objects.cc b/src/objects/objects.cc
index 84e1892ac8f..dd70ccea742 100644
--- a/src/objects/objects.cc
+++ b/src/objects/objects.cc
@@ -4119,9 +4119,10 @@ Address JSArray::ArrayJoinConcatToSequentialString(Isolate* isolate,
                                                    Address raw_dest) {
   DisallowGarbageCollection no_gc;
   DisallowJavascriptExecution no_js(isolate);
-  Tagged<FixedArray> fixed_array = FixedArray::cast(Object(raw_fixed_array));
-  Tagged<String> separator = String::cast(Object(raw_separator));
-  Tagged<String> dest = String::cast(Object(raw_dest));
+  Tagged<FixedArray> fixed_array =
+      FixedArray::cast(Tagged<Object>(raw_fixed_array));
+  Tagged<String> separator = String::cast(Tagged<Object>(raw_separator));
+  Tagged<String> dest = String::cast(Tagged<Object>(raw_dest));
   DCHECK(IsFixedArray(fixed_array));
   DCHECK(StringShape(dest).IsSequentialOneByte() ||
          StringShape(dest).IsSequentialTwoByte());
@@ -4517,7 +4518,7 @@ Script::Iterator::Iterator(Isolate* isolate)
 
 Tagged<Script> Script::Iterator::Next() {
   Tagged<Object> o = iterator_.Next();
-  if (o != Object()) {
+  if (o != Tagged<Object>()) {
     return Script::cast(o);
   }
   return Script();
@@ -6369,8 +6370,8 @@ void JSFinalizationRegistry::RemoveCellFromUnregisterTokenMap(
     Address raw_weak_cell) {
   DisallowGarbageCollection no_gc;
   Tagged<JSFinalizationRegistry> finalization_registry =
-      JSFinalizationRegistry::cast(Object(raw_finalization_registry));
-  Tagged<WeakCell> weak_cell = WeakCell::cast(Object(raw_weak_cell));
+      JSFinalizationRegistry::cast(Tagged<Object>(raw_finalization_registry));
+  Tagged<WeakCell> weak_cell = WeakCell::cast(Tagged<Object>(raw_weak_cell));
   DCHECK(!IsUndefined(weak_cell->unregister_token(), isolate));
   Tagged<HeapObject> undefined = ReadOnlyRoots(isolate).undefined_value();
 
diff --git a/src/objects/objects.h b/src/objects/objects.h
index 33d29946ef2..beb59841215 100644
--- a/src/objects/objects.h
+++ b/src/objects/objects.h
@@ -305,9 +305,6 @@ ShouldThrow GetShouldThrow(Isolate* isolate, Maybe<ShouldThrow> should_throw);
 // For a design overview, see https://goo.gl/Ph4CGz.
 class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
  public:
-  constexpr Object() : TaggedImpl(kNullAddress) {}
-  explicit constexpr Object(Address ptr) : TaggedImpl(ptr) {}
-
   // Whether the object is in the RO heap and the RO heap is shared, or in the
   // writable shared heap.
   static V8_INLINE bool InSharedHeap(Tagged<Object> obj);
@@ -685,6 +682,8 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
 
  protected:
   struct SkipTypeCheckTag {};
+  constexpr Object() : TaggedImpl(kNullAddress) {}
+  explicit constexpr Object(Address ptr) : TaggedImpl(ptr) {}
   explicit constexpr Object(Address ptr, SkipTypeCheckTag) : Object(ptr) {}
 
   // Static overwrites of TaggedImpl's IsSmi/IsHeapObject, to avoid conflicts
@@ -747,8 +746,6 @@ constexpr Tagged<Object>::Tagged(Object raw) : TaggedBase(raw.ptr()) {
   static_assert(kTaggedCanConvertToRawObjects);
 }
 
-constexpr Object Tagged<Object>::ToRawPtr() const { return Object(ptr()); }
-
 V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream& os,
                                            Tagged<Object> obj);
 
diff --git a/src/objects/simd.cc b/src/objects/simd.cc
index 9c2244558bc..d25b71e55a4 100644
--- a/src/objects/simd.cc
+++ b/src/objects/simd.cc
@@ -360,17 +360,17 @@ Address ArrayIndexOfIncludes(Address array_start, uintptr_t array_len,
 
   if constexpr (kind == ArrayIndexOfIncludesKind::DOUBLE) {
     Tagged<FixedDoubleArray> fixed_array =
-        FixedDoubleArray::cast(Object(array_start));
+        FixedDoubleArray::cast(Tagged<Object>(array_start));
     double* array = static_cast<double*>(
         fixed_array->RawField(FixedDoubleArray::OffsetOfElementAt(0))
             .ToVoidPtr());
 
     double search_num;
-    if (IsSmi(Object(search_element))) {
-      search_num = Object(search_element).ToSmi().value();
+    if (IsSmi(Tagged<Object>(search_element))) {
+      search_num = Tagged<Object>(search_element).ToSmi().value();
     } else {
-      DCHECK(IsHeapNumber(Object(search_element)));
-      search_num = HeapNumber::cast(Object(search_element))->value();
+      DCHECK(IsHeapNumber(Tagged<Object>(search_element)));
+      search_num = HeapNumber::cast(Tagged<Object>(search_element))->value();
     }
 
     DCHECK(!std::isnan(search_num));
@@ -395,13 +395,14 @@ Address ArrayIndexOfIncludes(Address array_start, uintptr_t array_len,
   }
 
   if constexpr (kind == ArrayIndexOfIncludesKind::OBJECTORSMI) {
-    Tagged<FixedArray> fixed_array = FixedArray::cast(Object(array_start));
+    Tagged<FixedArray> fixed_array =
+        FixedArray::cast(Tagged<Object>(array_start));
     Tagged_t* array =
         static_cast<Tagged_t*>(fixed_array->data_start().ToVoidPtr());
 
-    DCHECK(!IsHeapNumber(Object(search_element)));
-    DCHECK(!IsBigInt(Object(search_element)));
-    DCHECK(!IsString(Object(search_element)));
+    DCHECK(!IsHeapNumber(Tagged<Object>(search_element)));
+    DCHECK(!IsBigInt(Tagged<Object>(search_element)));
+    DCHECK(!IsString(Tagged<Object>(search_element)));
 
     return search<Tagged_t>(array, array_len, from_index,
                             static_cast<Tagged_t>(search_element));
diff --git a/src/objects/slots-inl.h b/src/objects/slots-inl.h
index fee88062b35..9e76e1a6070 100644
--- a/src/objects/slots-inl.h
+++ b/src/objects/slots-inl.h
@@ -37,7 +37,9 @@ bool FullObjectSlot::Relaxed_ContainsMapValue(Address raw_value) const {
   return base::AsAtomicPointer::Relaxed_Load(location()) == raw_value;
 }
 
-Tagged<Object> FullObjectSlot::operator*() const { return Object(*location()); }
+Tagged<Object> FullObjectSlot::operator*() const {
+  return Tagged<Object>(*location());
+}
 
 Tagged<Object> FullObjectSlot::load(PtrComprCageBase cage_base) const {
   return **this;
@@ -57,14 +59,14 @@ void FullObjectSlot::store_map(Tagged<Map> map) const {
 
 Tagged<Map> FullObjectSlot::load_map() const {
 #ifdef V8_MAP_PACKING
-  return Map::unchecked_cast(Object(MapWord::Unpack(*location())));
+  return Map::unchecked_cast(Tagged<Object>(MapWord::Unpack(*location())));
 #else
-  return Map::unchecked_cast(Object(*location()));
+  return Map::unchecked_cast(Tagged<Object>(*location()));
 #endif
 }
 
 Tagged<Object> FullObjectSlot::Acquire_Load() const {
-  return Object(base::AsAtomicPointer::Acquire_Load(location()));
+  return Tagged<Object>(base::AsAtomicPointer::Acquire_Load(location()));
 }
 
 Tagged<Object> FullObjectSlot::Acquire_Load(PtrComprCageBase cage_base) const {
@@ -72,7 +74,7 @@ Tagged<Object> FullObjectSlot::Acquire_Load(PtrComprCageBase cage_base) const {
 }
 
 Tagged<Object> FullObjectSlot::Relaxed_Load() const {
-  return Object(base::AsAtomicPointer::Relaxed_Load(location()));
+  return Tagged<Object>(base::AsAtomicPointer::Relaxed_Load(location()));
 }
 
 Tagged<Object> FullObjectSlot::Relaxed_Load(PtrComprCageBase cage_base) const {
@@ -91,14 +93,14 @@ Tagged<Object> FullObjectSlot::Relaxed_CompareAndSwap(
     Tagged<Object> old, Tagged<Object> target) const {
   Address result = base::AsAtomicPointer::Relaxed_CompareAndSwap(
       location(), old.ptr(), target.ptr());
-  return Object(result);
+  return Tagged<Object>(result);
 }
 
 Tagged<Object> FullObjectSlot::Release_CompareAndSwap(
     Tagged<Object> old, Tagged<Object> target) const {
   Address result = base::AsAtomicPointer::Release_CompareAndSwap(
       location(), old.ptr(), target.ptr());
-  return Object(result);
+  return Tagged<Object>(result);
 }
 
 //
@@ -155,7 +157,7 @@ void FullHeapObjectSlot::store(HeapObjectReference value) const {
 Tagged<HeapObject> FullHeapObjectSlot::ToHeapObject() const {
   TData value = *location();
   DCHECK(HAS_STRONG_HEAP_OBJECT_TAG(value));
-  return HeapObject::cast(Object(value));
+  return HeapObject::cast(Tagged<Object>(value));
 }
 
 void FullHeapObjectSlot::StoreHeapObject(Tagged<HeapObject> value) const {
@@ -306,7 +308,7 @@ Tagged<Object> IndirectPointerSlot::Relaxed_Load() const {
   // Smi::zero for kNullCodePointerHandle?
   if (!handle) return Smi::zero();
   Address addr = GetProcessWideCodePointerTable()->GetCodeObject(handle);
-  return Object(addr);
+  return Tagged<Object>(addr);
 #else
   UNREACHABLE();
 #endif  // V8_CODE_POINTER_SANDBOXING
@@ -319,7 +321,7 @@ Tagged<Object> IndirectPointerSlot::Acquire_Load() const {
   // Smi::zero for kNullCodePointerHandle?
   if (!handle) return Smi::zero();
   Address addr = GetProcessWideCodePointerTable()->GetCodeObject(handle);
-  return Object(addr);
+  return Tagged<Object>(addr);
 #else
   UNREACHABLE();
 #endif  // V8_CODE_POINTER_SANDBOXING
diff --git a/src/objects/smi.h b/src/objects/smi.h
index fba42f6d9e7..6b9e1ca9ea7 100644
--- a/src/objects/smi.h
+++ b/src/objects/smi.h
@@ -22,17 +22,6 @@ namespace internal {
 // Smi stands for small integer.
 class Smi : public Object {
  public:
-  // This replaces the OBJECT_CONSTRUCTORS macro, because Smis are special
-  // in that we want them to be constexprs.
-  constexpr Smi() : Object() {}
-  explicit constexpr Smi(Address ptr, SkipTypeCheckTag)
-      : Object(ptr, SkipTypeCheckTag()) {}
-  explicit constexpr Smi(Address ptr) : Object(ptr) {
-    DCHECK(HAS_SMI_TAG(ptr));
-  }
-
-  // Returns the integer value.
-  inline constexpr int value() const { return Internals::SmiValue(ptr()); }
   static inline constexpr Tagged<Smi> ToUint32Smi(Tagged<Smi> smi) {
     if (smi.value() <= 0) return Smi::FromInt(0);
     return Smi::FromInt(static_cast<uint32_t>(smi.value()));
@@ -116,15 +105,9 @@ class Smi : public Object {
   }
 };
 
-CAST_ACCESSOR(Smi)
-
-// Defined Tagged<Smi> now that Smi exists.
-
-// Implicit conversions to/from raw pointers
-// TODO(leszeks): Remove once we're using Tagged everywhere.
-// NOLINTNEXTLINE
-constexpr Tagged<Smi>::Tagged(Smi raw) : TaggedBase(raw.ptr()) {
-  static_assert(kTaggedCanConvertToRawObjects);
+Tagged<Smi> Smi::cast(Tagged<Object> object) {
+  DCHECK(object.IsSmi());
+  return Tagged<Smi>(object.ptr());
 }
 
 }  // namespace internal
diff --git a/src/objects/string-table.cc b/src/objects/string-table.cc
index 0af2a576730..43bec291a26 100644
--- a/src/objects/string-table.cc
+++ b/src/objects/string-table.cc
@@ -790,7 +790,7 @@ Address StringTable::Data::TryStringToIndexOrLookupExisting(
 // static
 Address StringTable::TryStringToIndexOrLookupExisting(Isolate* isolate,
                                                       Address raw_string) {
-  Tagged<String> string = String::cast(Object(raw_string));
+  Tagged<String> string = String::cast(Tagged<Object>(raw_string));
   if (IsInternalizedString(string)) {
     // string could be internalized, if the string table is shared and another
     // thread internalized it.
diff --git a/src/objects/tagged-field-inl.h b/src/objects/tagged-field-inl.h
index 065fe83c6cd..6e357ecd865 100644
--- a/src/objects/tagged-field-inl.h
+++ b/src/objects/tagged-field-inl.h
@@ -64,7 +64,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::load(Tagged<HeapObject> host,
                                                       int offset) {
   Tagged_t value = *location(host, offset);
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(host.ptr(), value));
+  return PtrType(tagged_to_full(host.ptr(), value));
 }
 
 // static
@@ -74,7 +74,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::load(
     PtrComprCageBase cage_base, Tagged<HeapObject> host, int offset) {
   Tagged_t value = *location(host, offset);
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(cage_base, value));
+  return PtrType(tagged_to_full(cage_base, value));
 }
 
 // static
@@ -110,7 +110,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::Relaxed_Load(
     Tagged<HeapObject> host, int offset) {
   AtomicTagged_t value = AsAtomicTagged::Relaxed_Load(location(host, offset));
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(host.ptr(), value));
+  return PtrType(tagged_to_full(host.ptr(), value));
 }
 
 // static
@@ -120,7 +120,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::Relaxed_Load(
     PtrComprCageBase cage_base, Tagged<HeapObject> host, int offset) {
   AtomicTagged_t value = AsAtomicTagged::Relaxed_Load(location(host, offset));
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(cage_base, value));
+  return PtrType(tagged_to_full(cage_base, value));
 }
 
 // static
@@ -129,7 +129,7 @@ typename TaggedField<T, kFieldOffset, CompressionScheme>::PtrType
 TaggedField<T, kFieldOffset, CompressionScheme>::Relaxed_Load_Map_Word(
     PtrComprCageBase cage_base, Tagged<HeapObject> host) {
   AtomicTagged_t value = AsAtomicTagged::Relaxed_Load(location(host, 0));
-  return T(tagged_to_full(cage_base, value));
+  return PtrType(tagged_to_full(cage_base, value));
 }
 
 // static
@@ -164,7 +164,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::Acquire_Load(
     Tagged<HeapObject> host, int offset) {
   AtomicTagged_t value = AsAtomicTagged::Acquire_Load(location(host, offset));
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(host.ptr(), value));
+  return PtrType(tagged_to_full(host.ptr(), value));
 }
 
 // static
@@ -173,7 +173,7 @@ typename TaggedField<T, kFieldOffset, CompressionScheme>::PtrType
 TaggedField<T, kFieldOffset, CompressionScheme>::Acquire_Load_No_Unpack(
     PtrComprCageBase cage_base, Tagged<HeapObject> host, int offset) {
   AtomicTagged_t value = AsAtomicTagged::Acquire_Load(location(host, offset));
-  return T(tagged_to_full(cage_base, value));
+  return PtrType(tagged_to_full(cage_base, value));
 }
 
 template <typename T, int kFieldOffset, typename CompressionScheme>
@@ -182,7 +182,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::Acquire_Load(
     PtrComprCageBase cage_base, Tagged<HeapObject> host, int offset) {
   AtomicTagged_t value = AsAtomicTagged::Acquire_Load(location(host, offset));
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(cage_base, value));
+  return PtrType(tagged_to_full(cage_base, value));
 }
 
 // static
@@ -230,7 +230,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::SeqCst_Load(
     Tagged<HeapObject> host, int offset) {
   AtomicTagged_t value = AsAtomicTagged::SeqCst_Load(location(host, offset));
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(host.ptr(), value));
+  return PtrType(tagged_to_full(host.ptr(), value));
 }
 
 // static
@@ -240,7 +240,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::SeqCst_Load(
     PtrComprCageBase cage_base, Tagged<HeapObject> host, int offset) {
   AtomicTagged_t value = AsAtomicTagged::SeqCst_Load(location(host, offset));
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
-  return T(tagged_to_full(cage_base, value));
+  return PtrType(tagged_to_full(cage_base, value));
 }
 
 // static
@@ -271,7 +271,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::SeqCst_Swap(
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
   AtomicTagged_t old_value =
       AsAtomicTagged::SeqCst_Swap(location(host, offset), full_to_tagged(ptr));
-  return T(tagged_to_full(host.ptr(), old_value));
+  return PtrType(tagged_to_full(host.ptr(), old_value));
 }
 
 // static
@@ -285,7 +285,7 @@ TaggedField<T, kFieldOffset, CompressionScheme>::SeqCst_Swap(
   DCHECK_NE(kFieldOffset + offset, HeapObject::kMapOffset);
   AtomicTagged_t old_value =
       AsAtomicTagged::SeqCst_Swap(location(host, offset), full_to_tagged(ptr));
-  return T(tagged_to_full(cage_base, old_value));
+  return PtrType(tagged_to_full(cage_base, old_value));
 }
 
 // static
diff --git a/src/objects/tagged-impl-inl.h b/src/objects/tagged-impl-inl.h
index af99089bc7b..76dcbee175e 100644
--- a/src/objects/tagged-impl-inl.h
+++ b/src/objects/tagged-impl-inl.h
@@ -100,7 +100,7 @@ bool TaggedImpl<kRefType, StorageType>::GetHeapObjectIfStrong(
     Tagged<HeapObject>* result) const {
   CHECK(kIsFull);
   if (IsStrong()) {
-    *result = HeapObject::cast(Object(ptr_));
+    *result = HeapObject::cast(Tagged<Object>(ptr_));
     return true;
   }
   return false;
@@ -112,8 +112,9 @@ bool TaggedImpl<kRefType, StorageType>::GetHeapObjectIfStrong(
   if (kIsFull) return GetHeapObjectIfStrong(result);
   // Implementation for compressed pointers.
   if (IsStrong()) {
-    *result = HeapObject::cast(Object(CompressionScheme::DecompressTagged(
-        isolate, static_cast<Tagged_t>(ptr_))));
+    *result =
+        HeapObject::cast(Tagged<Object>(CompressionScheme::DecompressTagged(
+            isolate, static_cast<Tagged_t>(ptr_))));
     return true;
   }
   return false;
@@ -128,7 +129,7 @@ Tagged<HeapObject>
 TaggedImpl<kRefType, StorageType>::GetHeapObjectAssumeStrong() const {
   CHECK(kIsFull);
   DCHECK(IsStrong());
-  return HeapObject::cast(Object(ptr_));
+  return HeapObject::cast(Tagged<Object>(ptr_));
 }
 
 template <HeapObjectReferenceType kRefType, typename StorageType>
@@ -137,7 +138,7 @@ Tagged<HeapObject> TaggedImpl<kRefType, StorageType>::GetHeapObjectAssumeStrong(
   if (kIsFull) return GetHeapObjectAssumeStrong();
   // Implementation for compressed pointers.
   DCHECK(IsStrong());
-  return HeapObject::cast(Object(CompressionScheme::DecompressTagged(
+  return HeapObject::cast(Tagged<Object>(CompressionScheme::DecompressTagged(
       isolate, static_cast<Tagged_t>(ptr_))));
 }
 
@@ -209,10 +210,10 @@ Tagged<HeapObject> TaggedImpl<kRefType, StorageType>::GetHeapObject() const {
   DCHECK(!IsSmi());
   if (kCanBeWeak) {
     DCHECK(!IsCleared());
-    return HeapObject::cast(Object(ptr_ & ~kWeakHeapObjectMask));
+    return HeapObject::cast(Tagged<Object>(ptr_ & ~kWeakHeapObjectMask));
   } else {
     DCHECK(!HAS_WEAK_HEAP_OBJECT_TAG(ptr_));
-    return HeapObject::cast(Object(ptr_));
+    return HeapObject::cast(Tagged<Object>(ptr_));
   }
 }
 
@@ -224,11 +225,11 @@ Tagged<HeapObject> TaggedImpl<kRefType, StorageType>::GetHeapObject(
   DCHECK(!IsSmi());
   if (kCanBeWeak) {
     DCHECK(!IsCleared());
-    return HeapObject::cast(Object(CompressionScheme::DecompressTagged(
+    return HeapObject::cast(Tagged<Object>(CompressionScheme::DecompressTagged(
         isolate, static_cast<Tagged_t>(ptr_) & ~kWeakHeapObjectMask)));
   } else {
     DCHECK(!HAS_WEAK_HEAP_OBJECT_TAG(ptr_));
-    return HeapObject::cast(Object(CompressionScheme::DecompressTagged(
+    return HeapObject::cast(Tagged<Object>(CompressionScheme::DecompressTagged(
         isolate, static_cast<Tagged_t>(ptr_))));
   }
 }
@@ -241,7 +242,7 @@ template <HeapObjectReferenceType kRefType, typename StorageType>
 Tagged<Object> TaggedImpl<kRefType, StorageType>::GetHeapObjectOrSmi() const {
   CHECK(kIsFull);
   if (IsSmi()) {
-    return Object(ptr_);
+    return Tagged<Object>(ptr_);
   }
   return GetHeapObject();
 }
@@ -252,7 +253,7 @@ Tagged<Object> TaggedImpl<kRefType, StorageType>::GetHeapObjectOrSmi(
   if (kIsFull) return GetHeapObjectOrSmi();
   // Implementation for compressed pointers.
   if (IsSmi()) {
-    return Object(
+    return Tagged<Object>(
         CompressionScheme::DecompressTaggedSigned(static_cast<Tagged_t>(ptr_)));
   }
   return GetHeapObject(isolate);
diff --git a/src/objects/tagged-impl.cc b/src/objects/tagged-impl.cc
index a35a0e1e180..533eb1f7897 100644
--- a/src/objects/tagged-impl.cc
+++ b/src/objects/tagged-impl.cc
@@ -25,8 +25,8 @@ bool CheckObjectComparisonAllowed(Address a, Address b) {
   if (!HAS_STRONG_HEAP_OBJECT_TAG(a) || !HAS_STRONG_HEAP_OBJECT_TAG(b)) {
     return true;
   }
-  Tagged<HeapObject> obj_a = HeapObject::unchecked_cast(Object(a));
-  Tagged<HeapObject> obj_b = HeapObject::unchecked_cast(Object(b));
+  Tagged<HeapObject> obj_a = HeapObject::unchecked_cast(Tagged<Object>(a));
+  Tagged<HeapObject> obj_b = HeapObject::unchecked_cast(Tagged<Object>(b));
   // This check might fail when we try to compare InstructionStream object with
   // non-InstructionStream object. The main legitimate case when such "mixed"
   // comparison could happen is comparing two AbstractCode objects. If that's
diff --git a/src/objects/tagged-index.h b/src/objects/tagged-index.h
index 2fb316c8893..246a8fd342a 100644
--- a/src/objects/tagged-index.h
+++ b/src/objects/tagged-index.h
@@ -34,15 +34,6 @@ namespace internal {
 //   safe to use them as indices in offset-computation functions.
 class TaggedIndex : public Object {
  public:
-  // This replaces the OBJECT_CONSTRUCTORS macro, because TaggedIndex are
-  // special in that we want them to be constexprs.
-  constexpr TaggedIndex() : Object() {}
-  explicit constexpr TaggedIndex(Address ptr, SkipTypeCheckTag)
-      : Object(ptr, SkipTypeCheckTag()) {}
-  explicit constexpr TaggedIndex(Address ptr) : Object(ptr) {
-    DCHECK(HAS_SMI_TAG(ptr));
-  }
-
   // Returns the integer value.
   inline intptr_t value() const {
     // Truncate and shift down (requires >> to be sign extending).
@@ -73,15 +64,9 @@ class TaggedIndex : public Object {
   static constexpr intptr_t kMaxValue = -(kMinValue + 1);
 };
 
-CAST_ACCESSOR(TaggedIndex)
-
-// Defined Tagged<TaggedIndex> now that TaggedIndex exists.
-
-// Implicit conversions to/from raw pointers
-// TODO(leszeks): Remove once we're using Tagged everywhere.
-// NOLINTNEXTLINE
-constexpr Tagged<TaggedIndex>::Tagged(TaggedIndex raw) : TaggedBase(raw.ptr()) {
-  static_assert(kTaggedCanConvertToRawObjects);
+Tagged<TaggedIndex> TaggedIndex::cast(Tagged<Object> object) {
+  DCHECK(HAS_SMI_TAG(object.ptr()));
+  return Tagged<TaggedIndex>(object.ptr());
 }
 
 }  // namespace internal
diff --git a/src/objects/tagged-value-inl.h b/src/objects/tagged-value-inl.h
index c729aa3988d..ce6ee5dff0f 100644
--- a/src/objects/tagged-value-inl.h
+++ b/src/objects/tagged-value-inl.h
@@ -31,9 +31,10 @@ inline StrongTaggedValue::StrongTaggedValue(Tagged<Object> o)
 Tagged<Object> StrongTaggedValue::ToObject(Isolate* isolate,
                                            StrongTaggedValue object) {
 #ifdef V8_COMPRESS_POINTERS
-  return Object(CompressionScheme::DecompressTagged(isolate, object.ptr()));
+  return Tagged<Object>(
+      CompressionScheme::DecompressTagged(isolate, object.ptr()));
 #else
-  return Object(object.ptr());
+  return Tagged<Object>(object.ptr());
 #endif
 }
 
diff --git a/src/objects/tagged.h b/src/objects/tagged.h
index fdbf6dde8d1..50df3fb52f1 100644
--- a/src/objects/tagged.h
+++ b/src/objects/tagged.h
@@ -127,16 +127,10 @@ class Tagged<Object> : public TaggedBase {
   // Allow Tagged<Object> to be created from any address.
   constexpr explicit Tagged(Address o) : TaggedBase(o) {}
 
-  // Allow explicit uninitialized initialization. In debug mode this is zapped.
-  // TODO(leszeks): Mark this somehow as uninitialized, so that we get some
-  // warning if it is used before initialization.
-  constexpr Tagged()
-      : TaggedBase(
-#ifdef DEBUG
-            kZapValue
-#endif
-        ) {
-  }
+  // Allow explicit uninitialized initialization.
+  // TODO(leszeks): Consider zapping this instead, since it's odd that
+  // Tagged<Object> implicitly initialises to Smi::zero().
+  constexpr Tagged() : TaggedBase(kNullAddress) {}
 
   // Implicit conversion for subclasses -- all classes are subclasses of Object,
   // so allow all tagged pointers.
@@ -150,10 +144,6 @@ class Tagged<Object> : public TaggedBase {
   // TODO(leszeks): Remove once we're using Tagged everywhere.
   // NOLINTNEXTLINE
   inline constexpr Tagged(Object raw);
-
- private:
-  friend class Object;
-  inline constexpr Object ToRawPtr() const;
 };
 
 // Specialization for Smi disallowing any implicit creation or access via ->,
@@ -184,19 +174,6 @@ class Tagged<Smi> : public TaggedBase {
   constexpr bool IsSmi() const { return true; }
 
   constexpr int32_t value() const { return Internals::SmiValue(ptr()); }
-
-  // Implicit conversions to/from raw pointers
-  // TODO(leszeks): Remove once we're using Tagged everywhere.
-  // NOLINTNEXTLINE
-  inline constexpr Tagged(Smi raw);
-
- private:
-  friend class Smi;
-  // Handles of the same type are allowed to access the Address constructor.
-  friend class Handle<Smi>;
-#ifdef V8_ENABLE_DIRECT_HANDLE
-  friend class DirectHandle<Smi>;
-#endif
 };
 
 // Specialization for TaggedIndex disallowing any implicit creation or access
@@ -240,12 +217,13 @@ class Tagged<TaggedIndex> : public TaggedBase {
   inline constexpr Tagged(TaggedIndex raw);
 
  private:
-  friend class TaggedIndex;
   // Handles of the same type are allowed to access the Address constructor.
   friend class Handle<TaggedIndex>;
 #ifdef V8_ENABLE_DIRECT_HANDLE
   friend class DirectHandle<TaggedIndex>;
 #endif
+  template <typename TFieldType, int kFieldOffset, typename CompressionScheme>
+  friend class TaggedField;
 };
 
 // Specialization for HeapObject, to group together functions shared between all
@@ -330,6 +308,8 @@ class Tagged<HeapObject> : public TaggedBase {
 #ifdef V8_ENABLE_DIRECT_HANDLE
   friend class DirectHandle<HeapObject>;
 #endif
+  template <typename TFieldType, int kFieldOffset, typename CompressionScheme>
+  friend class TaggedField;
 
   constexpr HeapObject ToRawPtr() const;
 };
@@ -402,6 +382,8 @@ class Tagged : public detail::BaseForTagged<T>::type {
 #ifdef V8_ENABLE_DIRECT_HANDLE
   friend class DirectHandle<T>;
 #endif
+  template <typename TFieldType, int kFieldOffset, typename CompressionScheme>
+  friend class TaggedField;
 
   constexpr explicit Tagged(Address ptr) : Base(ptr) {}
   constexpr T ToRawPtr() const {
diff --git a/src/objects/transitions.h b/src/objects/transitions.h
index 313918b2a2d..16f411d895f 100644
--- a/src/objects/transitions.h
+++ b/src/objects/transitions.h
@@ -239,7 +239,7 @@ class V8_EXPORT_PRIVATE TransitionsAccessor {
 // should use TransitionsAccessors.
 // TransitionArrays have the following format:
 // [0] Link to next TransitionArray (for weak handling support) (strong ref)
-// [1] Smi(0) or WeakFixedArray of prototype transitions (strong ref)
+// [1] Tagged<Smi>(0) or WeakFixedArray of prototype transitions (strong ref)
 // [2] Number of transitions (can be zero after trimming)
 // [3] First transition key (strong ref)
 // [4] First transition target (weak ref)
diff --git a/src/profiler/heap-snapshot-generator.cc b/src/profiler/heap-snapshot-generator.cc
index 359afa9a864..c780e739573 100644
--- a/src/profiler/heap-snapshot-generator.cc
+++ b/src/profiler/heap-snapshot-generator.cc
@@ -262,8 +262,8 @@ void HeapEntry::VerifyReference(HeapGraphEdge::Type type, HeapEntry* entry,
     // Verification is not possible.
     return;
   }
-  Tagged<HeapObject> from_obj = HeapObject::cast(Object(from_address));
-  Tagged<HeapObject> to_obj = HeapObject::cast(Object(to_address));
+  Tagged<HeapObject> from_obj = HeapObject::cast(Tagged<Object>(from_address));
+  Tagged<HeapObject> to_obj = HeapObject::cast(Tagged<Object>(to_address));
   if (BasicMemoryChunk::FromHeapObject(to_obj)->InReadOnlySpace()) {
     // We can't verify pointers into read-only space, because marking visitors
     // might not mark those. For example, every Map has a pointer to the
@@ -780,7 +780,8 @@ V8HeapExplorer::V8HeapExplorer(HeapSnapshot* snapshot,
       global_object_name_resolver_(resolver) {}
 
 HeapEntry* V8HeapExplorer::AllocateEntry(HeapThing ptr) {
-  return AddEntry(HeapObject::cast(Object(reinterpret_cast<Address>(ptr))));
+  return AddEntry(
+      HeapObject::cast(Tagged<Object>(reinterpret_cast<Address>(ptr))));
 }
 
 HeapEntry* V8HeapExplorer::AllocateEntry(Tagged<Smi> smi) {
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index fa2e345c53e..f9ea2047cfb 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -1210,7 +1210,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int RegExpMacroAssemblerARM::CheckStackGuardState(Address* return_address,
                                                   Address raw_code,
                                                   Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       frame_entry<int>(re_frame, kStartIndexOffset),
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.cc b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
index 566b3f0ba7b..08c98cbab68 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.cc
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
@@ -1433,7 +1433,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int RegExpMacroAssemblerARM64::CheckStackGuardState(
     Address* return_address, Address raw_code, Address re_frame,
     int start_index, const uint8_t** input_start, const uint8_t** input_end) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset), start_index,
       static_cast<RegExp::CallOrigin>(
diff --git a/src/regexp/experimental/experimental.cc b/src/regexp/experimental/experimental.cc
index 83b64b62840..642fbbf8ea0 100644
--- a/src/regexp/experimental/experimental.cc
+++ b/src/regexp/experimental/experimental.cc
@@ -191,9 +191,9 @@ int32_t ExperimentalRegExp::MatchForCallFromJs(
   DisallowHandleAllocation no_handles;
   DisallowHandleDereference no_deref;
 
-  Tagged<String> subject_string = String::cast(Object(subject));
+  Tagged<String> subject_string = String::cast(Tagged<Object>(subject));
 
-  Tagged<JSRegExp> regexp_obj = JSRegExp::cast(Object(regexp));
+  Tagged<JSRegExp> regexp_obj = JSRegExp::cast(Tagged<Object>(regexp));
 
   return ExecRaw(isolate, RegExp::kFromJs, regexp_obj, subject_string,
                  output_registers, output_register_count, start_position);
diff --git a/src/regexp/ia32/regexp-macro-assembler-ia32.cc b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
index 6ca07a8ebff..27248f4171a 100644
--- a/src/regexp/ia32/regexp-macro-assembler-ia32.cc
+++ b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
@@ -1247,7 +1247,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int RegExpMacroAssemblerIA32::CheckStackGuardState(Address* return_address,
                                                    Address raw_code,
                                                    Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       frame_entry<int>(re_frame, kStartIndexOffset),
diff --git a/src/regexp/loong64/regexp-macro-assembler-loong64.cc b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
index e13e7bd1698..8844b67bc93 100644
--- a/src/regexp/loong64/regexp-macro-assembler-loong64.cc
+++ b/src/regexp/loong64/regexp-macro-assembler-loong64.cc
@@ -1204,7 +1204,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 
 int64_t RegExpMacroAssemblerLOONG64::CheckStackGuardState(
     Address* return_address, Address raw_code, Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       static_cast<int>(frame_entry<int64_t>(re_frame, kStartIndexOffset)),
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.cc b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
index 2ae0b0c49f2..9e2cb70277f 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.cc
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
@@ -1255,7 +1255,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int64_t RegExpMacroAssemblerMIPS::CheckStackGuardState(Address* return_address,
                                                        Address raw_code,
                                                        Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       static_cast<int>(frame_entry<int64_t>(re_frame, kStartIndexOffset)),
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index d6ac210e8d4..b082886c1e2 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -1284,7 +1284,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int RegExpMacroAssemblerPPC::CheckStackGuardState(Address* return_address,
                                                   Address raw_code,
                                                   Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       frame_entry<intptr_t>(re_frame, kStartIndexOffset),
diff --git a/src/regexp/regexp-interpreter.cc b/src/regexp/regexp-interpreter.cc
index dd264d43796..2f4dff86ec4 100644
--- a/src/regexp/regexp-interpreter.cc
+++ b/src/regexp/regexp-interpreter.cc
@@ -1132,8 +1132,8 @@ IrregexpInterpreter::Result IrregexpInterpreter::MatchForCallFromJs(
   DisallowHandleAllocation no_handles;
   DisallowHandleDereference no_deref;
 
-  Tagged<String> subject_string = String::cast(Object(subject));
-  Tagged<JSRegExp> regexp_obj = JSRegExp::cast(Object(regexp));
+  Tagged<String> subject_string = String::cast(Tagged<Object>(subject));
+  Tagged<JSRegExp> regexp_obj = JSRegExp::cast(Tagged<Object>(regexp));
 
   if (regexp_obj->MarkedForTierUp()) {
     // Returning RETRY will re-enter through runtime, where actual recompilation
diff --git a/src/regexp/regexp-macro-assembler.cc b/src/regexp/regexp-macro-assembler.cc
index 704c7edf12a..bcf1c22d231 100644
--- a/src/regexp/regexp-macro-assembler.cc
+++ b/src/regexp/regexp-macro-assembler.cc
@@ -317,7 +317,8 @@ int NativeRegExpMacroAssembler::CheckStackGuardState(
   // Prepare for possible GC.
   HandleScope handles(isolate);
   Handle<InstructionStream> code_handle(re_code, isolate);
-  Handle<String> subject_handle(String::cast(Object(*subject)), isolate);
+  Handle<String> subject_handle(String::cast(Tagged<Object>(*subject)),
+                                isolate);
   bool is_one_byte = String::IsOneByteRepresentationUnderneath(*subject_handle);
   int return_value = 0;
 
diff --git a/src/regexp/riscv/regexp-macro-assembler-riscv.cc b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
index f60f03e5eee..b5e6041f9c0 100644
--- a/src/regexp/riscv/regexp-macro-assembler-riscv.cc
+++ b/src/regexp/riscv/regexp-macro-assembler-riscv.cc
@@ -1216,7 +1216,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int64_t RegExpMacroAssemblerRISCV::CheckStackGuardState(Address* return_address,
                                                         Address raw_code,
                                                         Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       static_cast<int>(frame_entry<int64_t>(re_frame, kStartIndexOffset)),
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.cc b/src/regexp/s390/regexp-macro-assembler-s390.cc
index 3a111c59f24..c7f72dcd7ef 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.cc
+++ b/src/regexp/s390/regexp-macro-assembler-s390.cc
@@ -1253,7 +1253,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int RegExpMacroAssemblerS390::CheckStackGuardState(Address* return_address,
                                                    Address raw_code,
                                                    Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       frame_entry<intptr_t>(re_frame, kStartIndexOffset),
diff --git a/src/regexp/x64/regexp-macro-assembler-x64.cc b/src/regexp/x64/regexp-macro-assembler-x64.cc
index 7c881f72b25..cde46461d1f 100644
--- a/src/regexp/x64/regexp-macro-assembler-x64.cc
+++ b/src/regexp/x64/regexp-macro-assembler-x64.cc
@@ -1310,7 +1310,8 @@ static T* frame_entry_address(Address re_frame, int frame_offset) {
 int RegExpMacroAssemblerX64::CheckStackGuardState(Address* return_address,
                                                   Address raw_code,
                                                   Address re_frame) {
-  Tagged<InstructionStream> re_code = InstructionStream::cast(Object(raw_code));
+  Tagged<InstructionStream> re_code =
+      InstructionStream::cast(Tagged<Object>(raw_code));
   return NativeRegExpMacroAssembler::CheckStackGuardState(
       frame_entry<Isolate*>(re_frame, kIsolateOffset),
       frame_entry<int>(re_frame, kStartIndexOffset),
diff --git a/src/runtime/runtime-scopes.cc b/src/runtime/runtime-scopes.cc
index c2072986289..e32d397701f 100644
--- a/src/runtime/runtime-scopes.cc
+++ b/src/runtime/runtime-scopes.cc
@@ -758,7 +758,7 @@ RUNTIME_FUNCTION_RETURN_PAIR(Runtime_LoadLookupSlotForCall) {
   Handle<Object> receiver;
   ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, value, LoadLookupSlot(isolate, name, kThrowOnError, &receiver),
-      MakePair(ReadOnlyRoots(isolate).exception(), Object()));
+      MakePair(ReadOnlyRoots(isolate).exception(), Tagged<Object>()));
   return MakePair(*value, *receiver);
 }
 
@@ -775,7 +775,7 @@ RUNTIME_FUNCTION(Runtime_LoadLookupSlotForCall_Baseline) {
            .ToHandle(&value)) {
     DCHECK((isolate)->has_pending_exception());
     value_ret.store(ReadOnlyRoots(isolate).exception());
-    receiver_ret.store(Object());
+    receiver_ret.store(Tagged<Object>());
     return ReadOnlyRoots(isolate).exception();
   }
   value_ret.store(*value);
diff --git a/src/runtime/runtime-test.cc b/src/runtime/runtime-test.cc
index a7d97b37dad..78eb5e58deb 100644
--- a/src/runtime/runtime-test.cc
+++ b/src/runtime/runtime-test.cc
@@ -1472,7 +1472,7 @@ RUNTIME_FUNCTION(Runtime_AbortJS) {
   Handle<String> message = args.at<String>(0);
   if (v8_flags.disable_abortjs) {
     base::OS::PrintError("[disabled] abort: %s\n", message->ToCString().get());
-    return Object();
+    return Tagged<Object>();
   }
   base::OS::PrintError("abort: %s\n", message->ToCString().get());
   isolate->PrintStack(stderr);
diff --git a/src/runtime/runtime-wasm.cc b/src/runtime/runtime-wasm.cc
index 5d27a4bb0d5..7bdf59f4302 100644
--- a/src/runtime/runtime-wasm.cc
+++ b/src/runtime/runtime-wasm.cc
@@ -1638,7 +1638,7 @@ RUNTIME_FUNCTION(Runtime_WasmStringViewWtf8Encode) {
   }
 
   // Unused.
-  return Smi(0);
+  return Tagged<Smi>(0);
 }
 
 RUNTIME_FUNCTION(Runtime_WasmStringViewWtf8Slice) {
diff --git a/src/sandbox/indirect-pointer-inl.h b/src/sandbox/indirect-pointer-inl.h
index 736ae48ba7a..5abea146d94 100644
--- a/src/sandbox/indirect-pointer-inl.h
+++ b/src/sandbox/indirect-pointer-inl.h
@@ -23,7 +23,8 @@ V8_INLINE Tagged<Object> ReadIndirectPointerField(Address field_address) {
   auto location = reinterpret_cast<IndirectPointerHandle*>(field_address);
   IndirectPointerHandle handle = base::AsAtomic32::Relaxed_Load(location);
   static_assert(kAllIndirectPointerObjectsAreCode);
-  return Object(GetProcessWideCodePointerTable()->GetCodeObject(handle));
+  return Tagged<Object>(
+      GetProcessWideCodePointerTable()->GetCodeObject(handle));
 #else
   UNREACHABLE();
 #endif  // V8_CODE_POINTER_SANDBOXING
diff --git a/src/snapshot/read-only-serializer.cc b/src/snapshot/read-only-serializer.cc
index ecf2a217835..83a1405c68d 100644
--- a/src/snapshot/read-only-serializer.cc
+++ b/src/snapshot/read-only-serializer.cc
@@ -117,7 +117,8 @@ struct ReadOnlySegmentForSerialization {
       if (o.address() >= segment_end) break;
       size_t o_offset = o.ptr() - segment_start;
       Address o_dst = reinterpret_cast<Address>(contents.get()) + o_offset;
-      pre_processor->PreProcessIfNeeded(HeapObject::cast(Object(o_dst)));
+      pre_processor->PreProcessIfNeeded(
+          HeapObject::cast(Tagged<Object>(o_dst)));
     }
   }
 
diff --git a/src/snapshot/snapshot.cc b/src/snapshot/snapshot.cc
index 03340e2cc33..f5789fcd606 100644
--- a/src/snapshot/snapshot.cc
+++ b/src/snapshot/snapshot.cc
@@ -937,7 +937,7 @@ size_t SnapshotCreatorImpl::AddData(Handle<NativeContext> context,
   DCHECK_NE(object, kNullAddress);
   DCHECK(!created());
   HandleScope scope(isolate_);
-  Handle<Object> obj(Object(object), isolate_);
+  Handle<Object> obj(Tagged<Object>(object), isolate_);
   Handle<ArrayList> list;
   if (!IsArrayList(context->serialized_objects())) {
     list = ArrayList::New(isolate_, 1);
@@ -955,7 +955,7 @@ size_t SnapshotCreatorImpl::AddData(Address object) {
   DCHECK_NE(object, kNullAddress);
   DCHECK(!created());
   HandleScope scope(isolate_);
-  Handle<Object> obj(Object(object), isolate_);
+  Handle<Object> obj(Tagged<Object>(object), isolate_);
   Handle<ArrayList> list;
   if (!IsArrayList(isolate_->heap()->serialized_objects())) {
     list = ArrayList::New(isolate_, 1);
diff --git a/src/strings/string-stream.cc b/src/strings/string-stream.cc
index 5618edfcdfd..bb28a299c2e 100644
--- a/src/strings/string-stream.cc
+++ b/src/strings/string-stream.cc
@@ -254,7 +254,7 @@ Handle<String> StringStream::ToString(Isolate* isolate) {
 }
 
 void StringStream::ClearMentionedObjectCache(Isolate* isolate) {
-  isolate->set_string_stream_current_security_token(Object());
+  isolate->set_string_stream_current_security_token(Tagged<Object>());
   if (isolate->string_stream_debug_object_cache() == nullptr) {
     isolate->set_string_stream_debug_object_cache(new DebugObjectCache());
   }
diff --git a/src/torque/implementation-visitor.cc b/src/torque/implementation-visitor.cc
index 561e846c805..4e19aba320e 100644
--- a/src/torque/implementation-visitor.cc
+++ b/src/torque/implementation-visitor.cc
@@ -1855,7 +1855,9 @@ cpp::Function ImplementationVisitor::GenerateFunction(
     f.SetReturnType(signature.return_type->GetRuntimeType());
   } else {
     DCHECK_EQ(output_type_, OutputType::kCSA);
-    f.SetReturnType(signature.return_type->GetGeneratedTypeName());
+    f.SetReturnType(signature.return_type->IsConstexpr()
+                        ? signature.return_type->TagglifiedCppTypeName()
+                        : signature.return_type->GetGeneratedTypeName());
   }
 
   bool ignore_first_parameter = true;
@@ -1879,7 +1881,11 @@ cpp::Function ImplementationVisitor::GenerateFunction(
       type = parameter_type->GetDebugType();
     } else {
       DCHECK_EQ(output_type_, OutputType::kCSA);
-      type = parameter_type->GetGeneratedTypeName();
+      if (parameter_type->IsConstexpr()) {
+        type = parameter_type->TagglifiedCppTypeName();
+      } else {
+        type = parameter_type->GetGeneratedTypeName();
+      }
     }
     f.AddParameter(std::move(type),
                    ExternalParameterName(i < parameter_names.size()
diff --git a/src/utils/address-map.cc b/src/utils/address-map.cc
index 25aa828b52a..b310a7a918d 100644
--- a/src/utils/address-map.cc
+++ b/src/utils/address-map.cc
@@ -38,7 +38,7 @@ RootIndexMap::RootIndexMap(Isolate* isolate) {
 }
 
 bool RootIndexMap::Lookup(Address obj, RootIndex* out_root_list) const {
-  return Lookup(HeapObject::cast(Object(obj)), out_root_list);
+  return Lookup(HeapObject::cast(Tagged<Object>(obj)), out_root_list);
 }
 
 }  // namespace internal
diff --git a/src/wasm/c-api.cc b/src/wasm/c-api.cc
index 333708e85d0..565f1ae73fc 100644
--- a/src/wasm/c-api.cc
+++ b/src/wasm/c-api.cc
@@ -1597,7 +1597,7 @@ void PopArgs(const i::wasm::FunctionSig* sig, Val results[],
       case i::wasm::kRefNull: {
         // TODO(14034): Make sure this works for all heap types.
         i::Address raw = packer->Pop<i::Address>();
-        i::Handle<i::Object> obj(i::Object(raw), store->i_isolate());
+        i::Handle<i::Object> obj(i::Tagged<i::Object>(raw), store->i_isolate());
         results[i] = Val(V8RefValueToWasm(store, obj));
         break;
       }
@@ -1717,7 +1717,8 @@ auto Func::call(const Val args[], Val results[]) const -> own<Trap> {
 i::Address FuncData::v8_callback(i::Address host_data_foreign,
                                  i::Address argv) {
   FuncData* self =
-      i::Managed<FuncData>::cast(i::Object(host_data_foreign))->raw();
+      i::Managed<FuncData>::cast(i::Tagged<i::Object>(host_data_foreign))
+          ->raw();
   StoreImpl* store = impl(self->store);
   i::Isolate* isolate = store->i_isolate();
   v8::Isolate::Scope isolate_scope(store->isolate());
@@ -1756,7 +1757,7 @@ i::Address FuncData::v8_callback(i::Address host_data_foreign,
       case FUNCREF: {
         i::Address raw = v8::base::ReadUnalignedValue<i::Address>(p);
         p += sizeof(raw);
-        i::Handle<i::Object> obj(i::Object(raw), isolate);
+        i::Handle<i::Object> obj(i::Tagged<i::Object>(raw), isolate);
         params[i] = Val(V8RefValueToWasm(store, obj));
         break;
       }
diff --git a/src/wasm/constant-expression-interface.cc b/src/wasm/constant-expression-interface.cc
index d0b3cec03b8..8adb0d73b92 100644
--- a/src/wasm/constant-expression-interface.cc
+++ b/src/wasm/constant-expression-interface.cc
@@ -348,8 +348,8 @@ void ConstantExpressionInterface::I31New(FullDecoder* decoder,
   // same as i31.get_s.
   intptr_t shifted =
       static_cast<intptr_t>(raw << (kSmiTagSize + kSmiShiftSize + 1)) >> 1;
-  result->runtime_value =
-      WasmValue(handle(Smi(shifted), isolate_), wasm::kWasmI31Ref.AsNonNull());
+  result->runtime_value = WasmValue(handle(Tagged<Smi>(shifted), isolate_),
+                                    wasm::kWasmI31Ref.AsNonNull());
 }
 
 void ConstantExpressionInterface::DoReturn(FullDecoder* decoder,
diff --git a/src/wasm/wasm-debug.cc b/src/wasm/wasm-debug.cc
index f2e970c71ff..d2f803983d1 100644
--- a/src/wasm/wasm-debug.cc
+++ b/src/wasm/wasm-debug.cc
@@ -613,7 +613,8 @@ class DebugInfoImpl {
           return WasmValue(ReadUnalignedValue<uint64_t>(gp_addr(reg.gp())));
         } else if (value->type.is_reference()) {
           Handle<Object> obj(
-              Object(ReadUnalignedValue<Address>(gp_addr(reg.gp()))), isolate);
+              Tagged<Object>(ReadUnalignedValue<Address>(gp_addr(reg.gp()))),
+              isolate);
           return WasmValue(obj, value->type);
         } else {
           UNREACHABLE();
@@ -657,8 +658,9 @@ class DebugInfoImpl {
       case kRef:
       case kRefNull:
       case kRtt: {
-        Handle<Object> obj(Object(ReadUnalignedValue<Address>(stack_address)),
-                           isolate);
+        Handle<Object> obj(
+            Tagged<Object>(ReadUnalignedValue<Address>(stack_address)),
+            isolate);
         return WasmValue(obj, value->type);
       }
       case kI8:
diff --git a/src/wasm/wasm-external-refs.cc b/src/wasm/wasm-external-refs.cc
index 44ee16e5343..5b6f2178076 100644
--- a/src/wasm/wasm-external-refs.cc
+++ b/src/wasm/wasm-external-refs.cc
@@ -477,8 +477,8 @@ int32_t memory_init_wrapper(Address data) {
   ThreadNotInWasmScope thread_not_in_wasm_scope;
   DisallowGarbageCollection no_gc;
   size_t offset = 0;
-  Tagged<WasmInstanceObject> instance =
-      WasmInstanceObject::cast(ReadAndIncrementOffset<Object>(data, &offset));
+  Tagged<WasmInstanceObject> instance = WasmInstanceObject::cast(
+      ReadAndIncrementOffset<Tagged<Object>>(data, &offset));
   uint32_t mem_index = ReadAndIncrementOffset<uint32_t>(data, &offset);
   uintptr_t dst = ReadAndIncrementOffset<uintptr_t>(data, &offset);
   uint32_t src = ReadAndIncrementOffset<uint32_t>(data, &offset);
@@ -502,8 +502,8 @@ int32_t memory_copy_wrapper(Address data) {
   ThreadNotInWasmScope thread_not_in_wasm_scope;
   DisallowGarbageCollection no_gc;
   size_t offset = 0;
-  Tagged<WasmInstanceObject> instance =
-      WasmInstanceObject::cast(ReadAndIncrementOffset<Object>(data, &offset));
+  Tagged<WasmInstanceObject> instance = WasmInstanceObject::cast(
+      ReadAndIncrementOffset<Tagged<Object>>(data, &offset));
   uint32_t dst_mem_index = ReadAndIncrementOffset<uint32_t>(data, &offset);
   uint32_t src_mem_index = ReadAndIncrementOffset<uint32_t>(data, &offset);
   uintptr_t dst = ReadAndIncrementOffset<uintptr_t>(data, &offset);
@@ -526,8 +526,8 @@ int32_t memory_fill_wrapper(Address data) {
   DisallowGarbageCollection no_gc;
 
   size_t offset = 0;
-  Tagged<WasmInstanceObject> instance =
-      WasmInstanceObject::cast(ReadAndIncrementOffset<Object>(data, &offset));
+  Tagged<WasmInstanceObject> instance = WasmInstanceObject::cast(
+      ReadAndIncrementOffset<Tagged<Object>>(data, &offset));
   uint32_t mem_index = ReadAndIncrementOffset<uint32_t>(data, &offset);
   uintptr_t dst = ReadAndIncrementOffset<uintptr_t>(data, &offset);
   uint8_t value =
@@ -559,8 +559,8 @@ void array_copy_wrapper(Address raw_instance, Address raw_dst_array,
   DCHECK_GT(length, 0);
   ThreadNotInWasmScope thread_not_in_wasm_scope;
   DisallowGarbageCollection no_gc;
-  Tagged<WasmArray> dst_array = WasmArray::cast(Object(raw_dst_array));
-  Tagged<WasmArray> src_array = WasmArray::cast(Object(raw_src_array));
+  Tagged<WasmArray> dst_array = WasmArray::cast(Tagged<Object>(raw_dst_array));
+  Tagged<WasmArray> src_array = WasmArray::cast(Tagged<Object>(raw_src_array));
 
   bool overlapping_ranges =
       dst_array.ptr() == src_array.ptr() &&
@@ -569,7 +569,7 @@ void array_copy_wrapper(Address raw_instance, Address raw_dst_array,
   wasm::ValueType element_type = src_array->type()->element_type();
   if (element_type.is_reference()) {
     Tagged<WasmInstanceObject> instance =
-        WasmInstanceObject::cast(Object(raw_instance));
+        WasmInstanceObject::cast(Tagged<Object>(raw_instance));
     Isolate* isolate = instance->GetIsolate();
     ObjectSlot dst_slot = dst_array->ElementSlot(dst_index);
     ObjectSlot src_slot = src_array->ElementSlot(src_index);
@@ -671,7 +671,7 @@ void array_fill_wrapper(Address raw_array, uint32_t index, uint32_t length,
 
   if (emit_write_barrier) {
     DCHECK(type.is_reference());
-    Tagged<WasmArray> array = WasmArray::cast(Object(raw_array));
+    Tagged<WasmArray> array = WasmArray::cast(Tagged<Object>(raw_array));
     Isolate* isolate = array->GetIsolate();
     ObjectSlot start(reinterpret_cast<Address>(initial_element_address));
     ObjectSlot end(
@@ -681,7 +681,7 @@ void array_fill_wrapper(Address raw_array, uint32_t index, uint32_t length,
 }
 
 double flat_string_to_f64(Address string_address) {
-  Tagged<String> s = String::cast(Object(string_address));
+  Tagged<String> s = String::cast(Tagged<Object>(string_address));
   return FlatStringToDouble(s, ALLOW_TRAILING_JUNK,
                             std::numeric_limits<double>::quiet_NaN());
 }
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 5a6b9dd1780..2d779945e61 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1109,11 +1109,11 @@ void ImportedFunctionEntry::SetWasmToWasm(Tagged<WasmInstanceObject> instance,
   instance_->imported_function_targets()->set(index_, call_target);
 }
 
-// Returns an empty Object() if no callable is available, a JSReceiver
+// Returns an empty Tagged<Object>() if no callable is available, a JSReceiver
 // otherwise.
 Tagged<Object> ImportedFunctionEntry::maybe_callable() {
   Tagged<Object> value = object_ref();
-  if (!IsWasmApiFunctionRef(value)) return Object();
+  if (!IsWasmApiFunctionRef(value)) return Tagged<Object>();
   return JSReceiver::cast(WasmApiFunctionRef::cast(value)->callable());
 }
 
diff --git a/test/cctest/compiler/test-code-generator.cc b/test/cctest/compiler/test-code-generator.cc
index 4e1a4330ede..9a8ec1cc4b3 100644
--- a/test/cctest/compiler/test-code-generator.cc
+++ b/test/cctest/compiler/test-code-generator.cc
@@ -783,13 +783,14 @@ class TestEnvironment : public HandleAndZoneScope {
       switch (constant.type()) {
         case Constant::kInt32:
           constant_value =
-              Handle<Smi>(Smi(static_cast<Address>(
+              Handle<Smi>(Tagged<Smi>(static_cast<Address>(
                               static_cast<intptr_t>(constant.ToInt32()))),
                           main_isolate());
           break;
         case Constant::kInt64:
-          constant_value = Handle<Smi>(
-              Smi(static_cast<Address>(constant.ToInt64())), main_isolate());
+          constant_value =
+              Handle<Smi>(Tagged<Smi>(static_cast<Address>(constant.ToInt64())),
+                          main_isolate());
           break;
         case Constant::kFloat32:
           constant_value = main_isolate()->factory()->NewHeapNumber(
diff --git a/test/cctest/heap/test-heap.cc b/test/cctest/heap/test-heap.cc
index a61eae7205c..acf1c5cbee4 100644
--- a/test/cctest/heap/test-heap.cc
+++ b/test/cctest/heap/test-heap.cc
@@ -252,7 +252,7 @@ TEST(HandleNull) {
   Isolate* isolate = CcTest::i_isolate();
   HandleScope outer_scope(isolate);
   LocalContext context;
-  Handle<Object> n(Object(0), isolate);
+  Handle<Object> n(Tagged<Object>(0), isolate);
   CHECK(!n.is_null());
 }
 
diff --git a/test/cctest/test-assembler-loong64.cc b/test/cctest/test-assembler-loong64.cc
index 220f583f596..433299d3862 100644
--- a/test/cctest/test-assembler-loong64.cc
+++ b/test/cctest/test-assembler-loong64.cc
@@ -4254,7 +4254,8 @@ TEST(jump_tables3) {
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kNumCases; ++i) {
     Handle<Object> result(
-        Object(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))), isolate);
+        Tagged<Object>(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))),
+        isolate);
 #ifdef OBJECT_PRINT
     ::printf("f(%d) = ", i);
     Print(*result);
diff --git a/test/cctest/test-assembler-mips64.cc b/test/cctest/test-assembler-mips64.cc
index 58a90bc248c..90133f2242a 100644
--- a/test/cctest/test-assembler-mips64.cc
+++ b/test/cctest/test-assembler-mips64.cc
@@ -3425,7 +3425,8 @@ TEST(jump_tables3) {
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kNumCases; ++i) {
     Handle<Object> result(
-        Object(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))), isolate);
+        Tagged<Object>(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))),
+        isolate);
 #ifdef OBJECT_PRINT
     ::printf("f(%d) = ", i);
     Print(*result);
diff --git a/test/cctest/test-assembler-riscv32.cc b/test/cctest/test-assembler-riscv32.cc
index dbbfaca3389..bc83656ad28 100644
--- a/test/cctest/test-assembler-riscv32.cc
+++ b/test/cctest/test-assembler-riscv32.cc
@@ -1726,7 +1726,8 @@ TEST(jump_tables3) {
 
   for (int i = 0; i < kNumCases; ++i) {
     Handle<Object> result(
-        Object(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))), isolate);
+        Tagged<Object>(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))),
+        isolate);
 #ifdef OBJECT_PRINT
     ::printf("f(%d) = ", i);
     Print(*result, std::cout);
diff --git a/test/cctest/test-assembler-riscv64.cc b/test/cctest/test-assembler-riscv64.cc
index 8b3df261159..059873aef0c 100644
--- a/test/cctest/test-assembler-riscv64.cc
+++ b/test/cctest/test-assembler-riscv64.cc
@@ -2003,7 +2003,8 @@ TEST(jump_tables3) {
 
   for (int i = 0; i < kNumCases; ++i) {
     Handle<Object> result(
-        Object(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))), isolate);
+        Tagged<Object>(reinterpret_cast<Address>(f.Call(i, 0, 0, 0, 0))),
+        isolate);
 #ifdef OBJECT_PRINT
     ::printf("f(%d) = ", i);
     Print(*result, std::cout);
diff --git a/test/cctest/test-js-weak-refs.cc b/test/cctest/test-js-weak-refs.cc
index b7968ca4061..de2237189db 100644
--- a/test/cctest/test-js-weak-refs.cc
+++ b/test/cctest/test-js-weak-refs.cc
@@ -153,12 +153,14 @@ void VerifyWeakCellChain(Isolate* isolate, Tagged<Object> list_head, int n_args,
     // Verify empty list
     CHECK(IsUndefined(list_head, isolate));
   } else {
-    Tagged<WeakCell> current = WeakCell::cast(Object(va_arg(args, Address)));
+    Tagged<WeakCell> current =
+        WeakCell::cast(Tagged<Object>(va_arg(args, Address)));
     CHECK_EQ(current, list_head);
     CHECK(IsUndefined(current->prev(), isolate));
 
     for (int i = 1; i < n_args; i++) {
-      Tagged<WeakCell> next = WeakCell::cast(Object(va_arg(args, Address)));
+      Tagged<WeakCell> next =
+          WeakCell::cast(Tagged<Object>(va_arg(args, Address)));
       CHECK_EQ(current->next(), next);
       CHECK_EQ(next->prev(), current);
       current = next;
@@ -189,13 +191,15 @@ void VerifyWeakCellKeyChain(Isolate* isolate,
     CHECK(entry.is_not_found());
   } else {
     CHECK(entry.is_found());
-    Tagged<WeakCell> current = WeakCell::cast(Object(va_arg(args, Address)));
+    Tagged<WeakCell> current =
+        WeakCell::cast(Tagged<Object>(va_arg(args, Address)));
     Tagged<Object> list_head = key_map->ValueAt(entry);
     CHECK_EQ(current, list_head);
     CHECK(IsUndefined(current->key_list_prev(), isolate));
 
     for (int i = 1; i < n_args; i++) {
-      Tagged<WeakCell> next = WeakCell::cast(Object(va_arg(args, Address)));
+      Tagged<WeakCell> next =
+          WeakCell::cast(Tagged<Object>(va_arg(args, Address)));
       CHECK_EQ(current->key_list_next(), next);
       CHECK_EQ(next->key_list_prev(), current);
       current = next;
diff --git a/test/cctest/test-mementos.cc b/test/cctest/test-mementos.cc
index e64f5239459..d3052d46009 100644
--- a/test/cctest/test-mementos.cc
+++ b/test/cctest/test-mementos.cc
@@ -51,7 +51,7 @@ static void SetUpNewSpaceWithPoisonedMementoAtTop() {
   // Create an allocation memento behind the string with a garbage allocation
   // site pointer.
   Tagged<AllocationMemento> memento = AllocationMemento::unchecked_cast(
-      Object(new_space->top() + kHeapObjectTag));
+      Tagged<Object>(new_space->top() + kHeapObjectTag));
   memento->set_map_after_allocation(
       ReadOnlyRoots(heap).allocation_memento_map(), SKIP_WRITE_BARRIER);
 
diff --git a/test/cctest/test-shared-strings.cc b/test/cctest/test-shared-strings.cc
index 0364edbf721..124db744ae3 100644
--- a/test/cctest/test-shared-strings.cc
+++ b/test/cctest/test-shared-strings.cc
@@ -478,7 +478,7 @@ class ConcurrentStringTableLookupThread final
   void RunForString(Handle<String> input_string, int counter) override {
     CHECK(input_string->IsShared());
     Tagged<Object> result =
-        Object(StringTable::TryStringToIndexOrLookupExisting(
+        Tagged<Object>(StringTable::TryStringToIndexOrLookupExisting(
             i_isolate, input_string->ptr()));
     if (IsString(result)) {
       Tagged<String> internalized = String::cast(result);
diff --git a/test/cctest/test-smi-lexicographic-compare.cc b/test/cctest/test-smi-lexicographic-compare.cc
index 333e6472f48..fa6851950f6 100644
--- a/test/cctest/test-smi-lexicographic-compare.cc
+++ b/test/cctest/test-smi-lexicographic-compare.cc
@@ -40,7 +40,7 @@ int ExpectedCompareResult(Tagged<Smi> a, Tagged<Smi> b) {
 }
 
 bool Test(Isolate* isolate, Tagged<Smi> a, Tagged<Smi> b) {
-  int actual = Smi(Smi::LexicographicCompare(isolate, a, b)).value();
+  int actual = Tagged<Smi>(Smi::LexicographicCompare(isolate, a, b)).value();
   int expected = ExpectedCompareResult(a, b);
 
   return actual == expected;
diff --git a/test/cctest/trace-extension.cc b/test/cctest/trace-extension.cc
index c83d189fe72..9cb6318e0b7 100644
--- a/test/cctest/trace-extension.cc
+++ b/test/cctest/trace-extension.cc
@@ -71,9 +71,11 @@ Address TraceExtension::GetFP(const v8::FunctionCallbackInfo<v8::Value>& info) {
   uint64_t kSmiValueMask =
       (static_cast<uintptr_t>(1) << (kSmiValueSize - 1)) - 1;
   uint64_t low_bits =
-      Smi(*reinterpret_cast<Address*>(*info[0])).value() & kSmiValueMask;
+      Tagged<Smi>(*reinterpret_cast<Address*>(*info[0])).value() &
+      kSmiValueMask;
   uint64_t high_bits =
-      Smi(*reinterpret_cast<Address*>(*info[1])).value() & kSmiValueMask;
+      Tagged<Smi>(*reinterpret_cast<Address*>(*info[1])).value() &
+      kSmiValueMask;
   Address fp =
       static_cast<Address>((high_bits << (kSmiValueSize - 1)) | low_bits);
 #else
diff --git a/test/cctest/wasm/test-gc.cc b/test/cctest/wasm/test-gc.cc
index 43c4a76bdf9..6e66a323822 100644
--- a/test/cctest/wasm/test-gc.cc
+++ b/test/cctest/wasm/test-gc.cc
@@ -141,7 +141,7 @@ class WasmGCTester {
     CallFunctionImpl(function_index, sig, &packer);
     CHECK(!isolate_->has_pending_exception());
     packer.Reset();
-    return Handle<Object>(Object(packer.Pop<Address>()), isolate_);
+    return Handle<Object>(Tagged<Object>(packer.Pop<Address>()), isolate_);
   }
 
   MaybeHandle<Object> GetResultObject(uint32_t function_index, int32_t arg) {
@@ -154,7 +154,7 @@ class WasmGCTester {
     CallFunctionImpl(function_index, sig, &packer);
     CHECK(!isolate_->has_pending_exception());
     packer.Reset();
-    return Handle<Object>(Object(packer.Pop<Address>()), isolate_);
+    return Handle<Object>(Tagged<Object>(packer.Pop<Address>()), isolate_);
   }
 
   void CheckHasThrown(uint32_t function_index, const char* expected = "") {
diff --git a/test/unittests/assembler/macro-assembler-x64-unittest.cc b/test/unittests/assembler/macro-assembler-x64-unittest.cc
index 07563d48d65..845cf7319d7 100644
--- a/test/unittests/assembler/macro-assembler-x64-unittest.cc
+++ b/test/unittests/assembler/macro-assembler-x64-unittest.cc
@@ -546,7 +546,7 @@ TEST_F(MacroAssemblerX64Test, EmbeddedObj) {
 #endif
   using myF0 = Address();
   auto f = GeneratedCode<myF0>::FromAddress(isolate, code->instruction_start());
-  Tagged<Object> result = Object(f.Call());
+  Tagged<Object> result = Tagged<Object>(f.Call());
   CHECK_EQ(old_array->ptr(), result.ptr());
 
   // Collect garbage to ensure reloc info can be walked by the heap.
diff --git a/test/unittests/compiler/codegen-unittest.cc b/test/unittests/compiler/codegen-unittest.cc
index ce112c0cf1e..5aa8ef35d23 100644
--- a/test/unittests/compiler/codegen-unittest.cc
+++ b/test/unittests/compiler/codegen-unittest.cc
@@ -382,7 +382,7 @@ TEST_F(CodeGenTest, RunHeapNumberConstant) {
   Handle<HeapObject> number = m.isolate()->factory()->NewHeapNumber(100.5);
   m.Return(m.HeapConstant(number));
   Tagged<HeapObject> result =
-      HeapObject::cast(Object(reinterpret_cast<Address>(m.Call())));
+      HeapObject::cast(Tagged<Object>(reinterpret_cast<Address>(m.Call())));
   CHECK_EQ(result, *number);
 }
 
diff --git a/test/unittests/heap/spaces-unittest.cc b/test/unittests/heap/spaces-unittest.cc
index 47cfa34b444..5a22554bc4f 100644
--- a/test/unittests/heap/spaces-unittest.cc
+++ b/test/unittests/heap/spaces-unittest.cc
@@ -62,13 +62,15 @@ TEST_F(SpacesTest, CompactionSpaceMerge) {
 
 TEST_F(SpacesTest, WriteBarrierFromHeapObject) {
   constexpr Address address1 = Page::kPageSize;
-  Tagged<HeapObject> object1 = HeapObject::unchecked_cast(Object(address1));
+  Tagged<HeapObject> object1 =
+      HeapObject::unchecked_cast(Tagged<Object>(address1));
   BasicMemoryChunk* chunk1 = BasicMemoryChunk::FromHeapObject(object1);
   heap_internals::MemoryChunk* slim_chunk1 =
       heap_internals::MemoryChunk::FromHeapObject(object1);
   EXPECT_EQ(static_cast<void*>(chunk1), static_cast<void*>(slim_chunk1));
   constexpr Address address2 = 2 * Page::kPageSize - 1;
-  Tagged<HeapObject> object2 = HeapObject::unchecked_cast(Object(address2));
+  Tagged<HeapObject> object2 =
+      HeapObject::unchecked_cast(Tagged<Object>(address2));
   BasicMemoryChunk* chunk2 = BasicMemoryChunk::FromHeapObject(object2);
   heap_internals::MemoryChunk* slim_chunk2 =
       heap_internals::MemoryChunk::FromHeapObject(object2);
diff --git a/test/unittests/objects/concurrent-js-array-unittest.cc b/test/unittests/objects/concurrent-js-array-unittest.cc
index 7d5058faf09..f2be16d912b 100644
--- a/test/unittests/objects/concurrent-js-array-unittest.cc
+++ b/test/unittests/objects/concurrent-js-array-unittest.cc
@@ -70,7 +70,7 @@ class BackgroundThread final : public v8::base::Thread {
 
       if (result.has_value()) {
         // On any success, the elements at index 1 must be the original value
-        // Smi(1).
+        // Tagged<Smi>(1).
         EXPECT_TRUE(IsSmi(result.value()));
         CHECK_EQ(Smi::ToInt(result.value()), 1);
       }
diff --git a/tools/grokdump.py b/tools/grokdump.py
index cdf1038f328..737101b2a2c 100755
--- a/tools/grokdump.py
+++ b/tools/grokdump.py
@@ -2079,7 +2079,7 @@ class InspectionPadawan(object):
     value = self.heap.SmiUntag(address)
     # On 32-bit systems almost everything looks like a Smi.
     if not self.reader.Is64() or value == 0: return None
-    return "Smi(%d)" % value
+    return "Tagged<Smi>(%d)" % value
 
   def SenseObject(self, address, slot=None):
     if self.IsFrameMarker(slot, address):
-- 
2.35.1


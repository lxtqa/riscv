From 932faf95b3335ce8d8dc72f2e55d132de0e4b376 Mon Sep 17 00:00:00 2001
From: Benedikt Meurer <bmeurer@chromium.org>
Date: Tue, 21 Aug 2018 11:29:52 +0200
Subject: [PATCH] [cleanup] Use ThrowIfNotInstanceType() more consistently.

There were still a few places left in builtins where we have custom
logic to check for a certain instance type and raise the incompatible
receiver error.

Bug: v8:8015
Change-Id: Ic5ed80aa6327b2902209b1822677f75b19d8a715
Reviewed-on: https://chromium-review.googlesource.com/1183183
Reviewed-by: Peter Marshall <petermarshall@chromium.org>
Commit-Queue: Benedikt Meurer <bmeurer@chromium.org>
Cr-Commit-Position: refs/heads/master@{#55252}
---
 src/builtins/builtins-generator-gen.cc   | 14 ++------------
 src/builtins/builtins-regexp-gen.cc      | 21 +++++----------------
 src/builtins/builtins-typed-array-gen.cc | 12 +-----------
 3 files changed, 8 insertions(+), 39 deletions(-)

diff --git a/src/builtins/builtins-generator-gen.cc b/src/builtins/builtins-generator-gen.cc
index fac79a0df1..04b378db3a 100644
--- a/src/builtins/builtins-generator-gen.cc
+++ b/src/builtins/builtins-generator-gen.cc
@@ -29,11 +29,8 @@ void GeneratorBuiltinsAssembler::GeneratorPrototypeResume(
     CodeStubArguments* args, Node* receiver, Node* value, Node* context,
     JSGeneratorObject::ResumeMode resume_mode, char const* const method_name) {
   // Check if the {receiver} is actually a JSGeneratorObject.
-  Label if_receiverisincompatible(this, Label::kDeferred);
-  GotoIf(TaggedIsSmi(receiver), &if_receiverisincompatible);
-  Node* receiver_instance_type = LoadInstanceType(receiver);
-  GotoIfNot(InstanceTypeEqual(receiver_instance_type, JS_GENERATOR_OBJECT_TYPE),
-            &if_receiverisincompatible);
+  ThrowIfNotInstanceType(context, receiver, JS_GENERATOR_OBJECT_TYPE,
+                         method_name);
 
   // Check if the {receiver} is running or already closed.
   TNode<Smi> receiver_continuation =
@@ -82,13 +79,6 @@ void GeneratorBuiltinsAssembler::GeneratorPrototypeResume(
                                    result, TrueConstant()));
   }
 
-  BIND(&if_receiverisincompatible);
-  {
-    // The {receiver} is not a valid JSGeneratorObject.
-    ThrowTypeError(context, MessageTemplate::kIncompatibleMethodReceiver,
-                   StringConstant(method_name), receiver);
-  }
-
   BIND(&if_receiverisclosed);
   {
     // The {receiver} is closed already.
diff --git a/src/builtins/builtins-regexp-gen.cc b/src/builtins/builtins-regexp-gen.cc
index 15e355b8f2..206602aaa7 100644
--- a/src/builtins/builtins-regexp-gen.cc
+++ b/src/builtins/builtins-regexp-gen.cc
@@ -3127,24 +3127,20 @@ class RegExpStringIteratorAssembler : public RegExpBuiltinsAssembler {
 // https://tc39.github.io/proposal-string-matchall/
 // %RegExpStringIteratorPrototype%.next ( )
 TF_BUILTIN(RegExpStringIteratorPrototypeNext, RegExpStringIteratorAssembler) {
+  const char* method_name = "%RegExpStringIterator%.prototype.next";
   TNode<Context> context = CAST(Parameter(Descriptor::kContext));
   TNode<Object> maybe_receiver = CAST(Parameter(Descriptor::kReceiver));
 
   Label if_match(this), if_no_match(this, Label::kDeferred),
-      return_empty_done_result(this, Label::kDeferred),
-      throw_bad_receiver(this, Label::kDeferred);
+      return_empty_done_result(this, Label::kDeferred);
 
   // 1. Let O be the this value.
   // 2. If Type(O) is not Object, throw a TypeError exception.
-  GotoIf(TaggedIsSmi(maybe_receiver), &throw_bad_receiver);
-  TNode<HeapObject> receiver = CAST(maybe_receiver);
-  GotoIfNot(IsJSReceiver(receiver), &throw_bad_receiver);
-
   // 3. If O does not have all of the internal slots of a RegExp String Iterator
   // Object Instance (see 5.3), throw a TypeError exception.
-  GotoIfNot(InstanceTypeEqual(LoadInstanceType(receiver),
-                              JS_REGEXP_STRING_ITERATOR_TYPE),
-            &throw_bad_receiver);
+  ThrowIfNotInstanceType(context, maybe_receiver,
+                         JS_REGEXP_STRING_ITERATOR_TYPE, method_name);
+  TNode<HeapObject> receiver = CAST(maybe_receiver);
 
   // 4. If O.[[Done]] is true, then
   //   a. Return ! CreateIterResultObject(undefined, true).
@@ -3294,13 +3290,6 @@ TF_BUILTIN(RegExpStringIteratorPrototypeNext, RegExpStringIteratorAssembler) {
   BIND(&return_empty_done_result);
   Return(
       AllocateJSIteratorResult(context, UndefinedConstant(), TrueConstant()));
-
-  BIND(&throw_bad_receiver);
-  {
-    ThrowTypeError(context, MessageTemplate::kIncompatibleMethodReceiver,
-                   StringConstant("%RegExpStringIterator%.prototype.next"),
-                   receiver);
-  }
 }
 
 }  // namespace internal
diff --git a/src/builtins/builtins-typed-array-gen.cc b/src/builtins/builtins-typed-array-gen.cc
index d0d45b3e14..3746c603f2 100644
--- a/src/builtins/builtins-typed-array-gen.cc
+++ b/src/builtins/builtins-typed-array-gen.cc
@@ -786,10 +786,7 @@ TF_BUILTIN(TypedArrayConstructor, TypedArrayBuiltinsAssembler) {
 void TypedArrayBuiltinsAssembler::GenerateTypedArrayPrototypeGetter(
     Node* context, Node* receiver, const char* method_name, int object_offset) {
   // Check if the {receiver} is actually a JSTypedArray.
-  Label receiver_is_incompatible(this, Label::kDeferred);
-  GotoIf(TaggedIsSmi(receiver), &receiver_is_incompatible);
-  GotoIfNot(HasInstanceType(receiver, JS_TYPED_ARRAY_TYPE),
-            &receiver_is_incompatible);
+  ThrowIfNotInstanceType(context, receiver, JS_TYPED_ARRAY_TYPE, method_name);
 
   // Check if the {receiver}'s JSArrayBuffer was neutered.
   Node* receiver_buffer =
@@ -803,13 +800,6 @@ void TypedArrayBuiltinsAssembler::GenerateTypedArrayPrototypeGetter(
     // The {receiver}s buffer was neutered, default to zero.
     Return(SmiConstant(0));
   }
-
-  BIND(&receiver_is_incompatible);
-  {
-    // The {receiver} is not a valid JSTypedArray.
-    ThrowTypeError(context, MessageTemplate::kIncompatibleMethodReceiver,
-                   StringConstant(method_name), receiver);
-  }
 }
 
 // ES6 #sec-get-%typedarray%.prototype.bytelength
-- 
2.35.1


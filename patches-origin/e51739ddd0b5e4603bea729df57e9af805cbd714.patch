From e51739ddd0b5e4603bea729df57e9af805cbd714 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Fri, 22 Apr 2022 20:13:23 +0800
Subject: [PATCH] [riscv64] Fix relocation attribute not loaded correctly

And port commit 5ee6b7a701b6a56d592f3c10a34f5634bd56a60d

Change-Id: Ia43d1d888154ebffcd56d436e6dfa8970eae6583
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3600174
Reviewed-by: ji qiu <qiuji@iscas.ac.cn>
Commit-Queue: Yahan Lu <yahan@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#80132}
---
 .../riscv64/baseline-assembler-riscv64-inl.h  |   6 +-
 .../riscv64/macro-assembler-riscv64.cc        |   6 +-
 .../riscv64/regexp-macro-assembler-riscv64.cc | 178 ++++++++----------
 .../riscv64/regexp-macro-assembler-riscv64.h  |  14 +-
 4 files changed, 92 insertions(+), 112 deletions(-)

diff --git a/src/baseline/riscv64/baseline-assembler-riscv64-inl.h b/src/baseline/riscv64/baseline-assembler-riscv64-inl.h
index d7b9566a16..c6b59c18e2 100644
--- a/src/baseline/riscv64/baseline-assembler-riscv64-inl.h
+++ b/src/baseline/riscv64/baseline-assembler-riscv64-inl.h
@@ -110,7 +110,7 @@ void BaselineAssembler::JumpIfSmi(Register value, Label* target,
 }
 void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,
                                      Label::Distance) {
-  __ JumpIfSmi(value, target);
+  __ JumpIfNotSmi(value, target);
 }
 void BaselineAssembler::JumpIfImmediate(Condition cc, Register left, int right,
                                         Label* target,
@@ -399,7 +399,7 @@ void BaselineAssembler::AddToInterruptBudgetAndJumpIfNotExceeded(
         FieldMemOperand(feedback_cell, FeedbackCell::kInterruptBudgetOffset));
   if (skip_interrupt_label) {
     DCHECK_LT(weight, 0);
-    __ Branch(skip_interrupt_label, ge, interrupt_budget, Operand(weight));
+    __ Branch(skip_interrupt_label, ge, interrupt_budget, Operand(zero_reg));
   }
 }
 
@@ -420,7 +420,7 @@ void BaselineAssembler::AddToInterruptBudgetAndJumpIfNotExceeded(
   __ Sw(interrupt_budget,
         FieldMemOperand(feedback_cell, FeedbackCell::kInterruptBudgetOffset));
   if (skip_interrupt_label)
-    __ Branch(skip_interrupt_label, ge, interrupt_budget, Operand(weight));
+    __ Branch(skip_interrupt_label, ge, interrupt_budget, Operand(zero_reg));
 }
 
 void BaselineAssembler::AddSmi(Register lhs, Smi rhs) {
diff --git a/src/codegen/riscv64/macro-assembler-riscv64.cc b/src/codegen/riscv64/macro-assembler-riscv64.cc
index 33816db57f..0a403cdb0b 100644
--- a/src/codegen/riscv64/macro-assembler-riscv64.cc
+++ b/src/codegen/riscv64/macro-assembler-riscv64.cc
@@ -400,7 +400,7 @@ void TurboAssembler::Add64(Register rd, Register rs, const Operand& rt) {
       UseScratchRegisterScope temps(this);
       Register scratch = temps.Acquire();
       BlockTrampolinePoolScope block_trampoline_pool(this);
-      Li(scratch, rt.immediate());
+      li(scratch, rt);
       add(rd, rs, scratch);
     }
   }
@@ -485,13 +485,13 @@ void TurboAssembler::Sub64(Register rd, Register rs, const Operand& rt) {
       DCHECK(rt.immediate() != std::numeric_limits<int32_t>::min());
       UseScratchRegisterScope temps(this);
       Register scratch = temps.Acquire();
-      Li(scratch, -rt.immediate());
+      li(scratch, Operand(-rt.immediate()));
       add(rd, rs, scratch);
     } else {
       // li handles the relocation.
       UseScratchRegisterScope temps(this);
       Register scratch = temps.Acquire();
-      Li(scratch, rt.immediate());
+      li(scratch, rt);
       sub(rd, rs, scratch);
     }
   }
diff --git a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
index bea3a7cb3d..2ee1a51c0e 100644
--- a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
+++ b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
@@ -19,20 +19,16 @@ namespace v8 {
 namespace internal {
 
 /* clang-format off
- *
  * This assembler uses the following register assignment convention
- * - s3 : kScratchReg. Temporarily stores the index of capture start after a matching pass
- *        for a global regexp.
- * - s4 : Pointer to current Code object including heap object tag.
- * - s1 : Current position in input, as negative offset from end of string.
+ * - s1 : Pointer to current Code object including heap object tag.
+ * - s2 : Current position in input, as negative offset from end of string.
  *        Please notice that this is the byte offset, not the character offset!
- * - s2 : Currently loaded character. Must be loaded using
+ * - s5 : Currently loaded character. Must be loaded using
  *        LoadCurrentCharacter before using any of the dispatch methods.
- * - t0 : Points to tip of backtrack stack
- * - t1 : Unused.
- * - t2 : End of input (points to byte after last character in input).
+ * - s6 : Points to tip of backtrack stack
+ * - s7 : End of input (points to byte after last character in input).
  * - fp : Frame pointer. Used to access arguments, local variables and
- *         RegExp registers.
+ *        RegExp registers.
  * - sp : Points to tip of C stack.
  *
  * The remaining registers are free for computations.
@@ -219,24 +215,8 @@ void RegExpMacroAssemblerRISCV::CheckGreedyLoop(Label* on_equal) {
   BranchOrBacktrack(on_equal, eq, current_input_offset(), Operand(a0));
 }
 
-// Push (pop) caller-saved registers used by irregexp.
-void RegExpMacroAssemblerRISCV::PushCallerSavedRegisters() {
-  RegList caller_saved_regexp = {current_input_offset(), current_character(),
-                                 end_of_input_address(),
-                                 backtrack_stackpointer()};
-  __ MultiPush(caller_saved_regexp);
-}
-
-void RegExpMacroAssemblerRISCV::PopCallerSavedRegisters() {
-  RegList caller_saved_regexp = {current_input_offset(), current_character(),
-                                 end_of_input_address(),
-                                 backtrack_stackpointer()};
-  __ MultiPop(caller_saved_regexp);
-}
-
 void RegExpMacroAssemblerRISCV::CallIsCharacterInRangeArray(
     const ZoneList<CharacterRange>* ranges) {
-  PushCallerSavedRegisters();
   static const int kNumArguments = 3;
   __ PrepareCallCFunction(kNumArguments, a0);
 
@@ -250,7 +230,6 @@ void RegExpMacroAssemblerRISCV::CallIsCharacterInRangeArray(
     __ CallCFunction(ExternalReference::re_is_character_in_range_array(),
                      kNumArguments);
   }
-  PopCallerSavedRegisters();
   __ li(code_pointer(), Operand(masm_->CodeObject()));
 }
 
@@ -348,7 +327,6 @@ void RegExpMacroAssemblerRISCV::CheckNotBackReferenceIgnoreCase(
     }
   } else {
     DCHECK(mode_ == UC16);
-    PushCallerSavedRegisters();
 
     int argument_count = 4;
     __ PrepareCallCFunction(argument_count, a2);
@@ -386,11 +364,6 @@ void RegExpMacroAssemblerRISCV::CheckNotBackReferenceIgnoreCase(
       __ CallCFunction(function, argument_count);
     }
 
-    // Restore regexp engine registers.
-    PopCallerSavedRegisters();
-    __ li(code_pointer(), Operand(masm_->CodeObject()), CONSTANT_SIZE);
-    __ Ld(end_of_input_address(), MemOperand(frame_pointer(), kInputEnd));
-
     // Check if function returned non-zero for success or zero for failure.
     BranchOrBacktrack(on_no_match, eq, a0, Operand(zero_reg));
     // On success, increment position by length of capture.
@@ -648,26 +621,26 @@ void RegExpMacroAssemblerRISCV::StoreRegExpStackPointerToMemory(
   __ Sd(src, MemOperand(scratch));
 }
 
-void RegExpMacroAssemblerRISCV::PushRegExpBasePointer(Register scratch1,
-                                                      Register scratch2) {
-  LoadRegExpStackPointerFromMemory(scratch1);
+void RegExpMacroAssemblerRISCV::PushRegExpBasePointer(Register stack_pointer,
+                                                      Register scratch) {
   ExternalReference ref =
       ExternalReference::address_of_regexp_stack_memory_top_address(isolate());
-  __ li(scratch2, Operand(ref));
-  __ Ld(scratch2, MemOperand(scratch2));
-  __ Sub64(scratch2, scratch1, scratch2);
-  __ Sd(scratch2, MemOperand(frame_pointer(), kRegExpStackBasePointer));
+  __ li(scratch, Operand(ref));
+  __ Ld(scratch, MemOperand(scratch));
+  __ Sub64(scratch, stack_pointer, scratch);
+  __ Sd(scratch, MemOperand(frame_pointer(), kRegExpStackBasePointer));
 }
 
-void RegExpMacroAssemblerRISCV::PopRegExpBasePointer(Register scratch1,
-                                                     Register scratch2) {
+void RegExpMacroAssemblerRISCV::PopRegExpBasePointer(Register stack_pointer_out,
+                                                     Register scratch) {
   ExternalReference ref =
       ExternalReference::address_of_regexp_stack_memory_top_address(isolate());
-  __ Ld(scratch1, MemOperand(frame_pointer(), kRegExpStackBasePointer));
-  __ li(scratch2, ref);
-  __ Ld(scratch2, MemOperand(scratch2));
-  __ Add64(scratch1, scratch1, scratch2);
-  StoreRegExpStackPointerToMemory(scratch1, scratch2);
+  __ Ld(stack_pointer_out,
+        MemOperand(frame_pointer(), kRegExpStackBasePointer));
+  __ li(scratch, Operand(ref));
+  __ Ld(scratch, MemOperand(scratch));
+  __ Add64(stack_pointer_out, stack_pointer_out, scratch);
+  StoreRegExpStackPointerToMemory(stack_pointer_out, scratch);
 }
 
 Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
@@ -734,36 +707,42 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
     STATIC_ASSERT(kRegExpStackBasePointer ==
                   kBacktrackCount - kSystemPointerSize);
     __ push(a0);  // The regexp stack base ptr.
+
+    // Initialize backtrack stack pointer. It must not be clobbered from here
+    // on. Note the backtrack_stackpointer is callee-saved.
+    STATIC_ASSERT(backtrack_stackpointer() == s7);
+    LoadRegExpStackPointerFromMemory(backtrack_stackpointer());
     // Store the regexp base pointer - we'll later restore it / write it to
     // memory when returning from this irregexp code object.
-    PushRegExpBasePointer(a0, a1);
-
-    // Check if we have space on the stack for registers.
-    Label stack_limit_hit;
-    Label stack_ok;
-
-    ExternalReference stack_limit =
-        ExternalReference::address_of_jslimit(masm_->isolate());
-    __ li(a0, Operand(stack_limit));
-    __ Ld(a0, MemOperand(a0));
-    __ Sub64(a0, sp, a0);
-    // Handle it if the stack pointer is already below the stack limit.
-    __ BranchShort(&stack_limit_hit, le, a0, Operand(zero_reg));
-    // Check if there is room for the variable number of registers above
-    // the stack limit.
-    __ BranchShort(&stack_ok, Ugreater_equal, a0,
-                   Operand(num_registers_ * kSystemPointerSize));
-    // Exit with OutOfMemory exception. There is not enough space on the stack
-    // for our working registers.
-    __ li(a0, Operand(EXCEPTION));
-    __ jmp(&return_a0);
-
-    __ bind(&stack_limit_hit);
-    CallCheckStackGuardState(a0);
-    // If returned value is non-zero, we exit with the returned value as result.
-    __ Branch(&return_a0, ne, a0, Operand(zero_reg));
-
-    __ bind(&stack_ok);
+    PushRegExpBasePointer(backtrack_stackpointer(), a1);
+
+    {
+      // Check if we have space on the stack for registers.
+      Label stack_limit_hit, stack_ok;
+
+      ExternalReference stack_limit =
+          ExternalReference::address_of_jslimit(masm_->isolate());
+      __ li(a0, Operand(stack_limit));
+      __ Ld(a0, MemOperand(a0));
+      __ Sub64(a0, sp, a0);
+      // Handle it if the stack pointer is already below the stack limit.
+      __ Branch(&stack_limit_hit, le, a0, Operand(zero_reg));
+      // Check if there is room for the variable number of registers above
+      // the stack limit.
+      __ Branch(&stack_ok, uge, a0, Operand(num_registers_ * kPointerSize));
+      // Exit with OutOfMemory exception. There is not enough space on the stack
+      // for our working registers.
+      __ li(a0, Operand(EXCEPTION));
+      __ jmp(&return_a0);
+
+      __ bind(&stack_limit_hit);
+      CallCheckStackGuardState(a0);
+      // If returned value is non-zero, we exit with the returned value as
+      // result.
+      __ Branch(&return_a0, ne, a0, Operand(zero_reg));
+
+      __ bind(&stack_ok);
+    }
     // Allocate space on stack for registers.
     __ Sub64(sp, sp, Operand(num_registers_ * kSystemPointerSize));
     // Load string end.
@@ -785,17 +764,20 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
     // Initialize code pointer register
     __ li(code_pointer(), Operand(masm_->CodeObject()), CONSTANT_SIZE);
 
-    Label load_char_start_regexp, start_regexp;
-    // Load newline if index is at start, previous character otherwise.
-    __ BranchShort(&load_char_start_regexp, ne, a1, Operand(zero_reg));
-    __ li(current_character(), Operand('\n'));
-    __ jmp(&start_regexp);
-
-    // Global regexp restarts matching here.
-    __ bind(&load_char_start_regexp);
-    // Load previous char as initial value of current character register.
-    LoadCurrentCharacterUnchecked(-1, 1);
-    __ bind(&start_regexp);
+    Label load_char_start_regexp;
+    {
+      Label start_regexp;
+      // Load newline if index is at start, previous character otherwise.
+      __ Branch(&load_char_start_regexp, ne, a1, Operand(zero_reg));
+      __ li(current_character(), Operand('\n'));
+      __ jmp(&start_regexp);
+
+      // Global regexp restarts matching here.
+      __ bind(&load_char_start_regexp);
+      // Load previous char as initial value of current character register.
+      LoadCurrentCharacterUnchecked(-1, 1);
+      __ bind(&start_regexp);
+    }
 
     // Initialize on-stack registers.
     if (num_saved_registers_ > 0) {  // Always is, if generated from a regexp.
@@ -817,9 +799,6 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
       }
     }
 
-    // Initialize backtrack stack pointer.
-    LoadRegExpStackPointerFromMemory(backtrack_stackpointer());
-
     __ jmp(&start_label_);
 
     // Exit code:
@@ -890,6 +869,10 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
         // Prepare a0 to initialize registers with its value in the next run.
         __ Ld(a0, MemOperand(frame_pointer(), kStringStartMinusOne));
 
+        // Restore the original regexp stack pointer value (effectively, pop the
+        // stored base pointer).
+        PopRegExpBasePointer(backtrack_stackpointer(), a2);
+
         if (global_with_zero_length_check()) {
           // Special case for zero-length matches.
           // s3: capture start index
@@ -921,7 +904,7 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
     __ bind(&return_a0);
     // Restore the original regexp stack pointer value (effectively, pop the
     // stored base pointer).
-    PopRegExpBasePointer(a1, a2);
+    PopRegExpBasePointer(backtrack_stackpointer(), a1);
     // Skip sp past regexp registers and local variables..
     __ mv(sp, frame_pointer());
 
@@ -943,16 +926,13 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
       SafeCallTarget(&check_preempt_label_);
       StoreRegExpStackPointerToMemory(backtrack_stackpointer(), a1);
       // Put regexp engine registers on stack.
-      PushCallerSavedRegisters();
       CallCheckStackGuardState(a0);
-      PopCallerSavedRegisters();
       // If returning non-zero, we should end execution with the given
       // result as return value.
       __ Branch(&return_a0, ne, a0, Operand(zero_reg));
       LoadRegExpStackPointerFromMemory(backtrack_stackpointer());
       // String might have moved: Reload end of string from frame.
       __ Ld(end_of_input_address(), MemOperand(frame_pointer(), kInputEnd));
-      __ li(code_pointer(), Operand(masm_->CodeObject()), CONSTANT_SIZE);
       SafeReturn();
     }
 
@@ -974,8 +954,6 @@ Handle<HeapObject> RegExpMacroAssemblerRISCV::GetCode(Handle<String> source) {
       // Otherwise use return value as new stack pointer.
       __ mv(backtrack_stackpointer(), a0);
       // Restore saved registers and continue.
-      __ li(code_pointer(), Operand(masm_->CodeObject()), CONSTANT_SIZE);
-      __ Ld(end_of_input_address(), MemOperand(frame_pointer(), kInputEnd));
       SafeReturn();
     }
 
@@ -1333,9 +1311,11 @@ void RegExpMacroAssemblerRISCV::LoadCurrentCharacterUnchecked(int cp_offset,
     DCHECK_EQ(1, characters);
   }
   if (cp_offset != 0) {
-    // t3 is not being used to store the capture start index at this point.
-    __ Add64(t3, current_input_offset(), Operand(cp_offset * char_size()));
-    offset = t3;
+    // kScratchReg2 is not being used to store the capture start index at this
+    // point.
+    __ Add64(kScratchReg2, current_input_offset(),
+             Operand(cp_offset * char_size()));
+    offset = kScratchReg2;
   }
 
   if (mode_ == LATIN1) {
@@ -1346,7 +1326,7 @@ void RegExpMacroAssemblerRISCV::LoadCurrentCharacterUnchecked(int cp_offset,
       __ Add64(kScratchReg, end_of_input_address(), offset);
       __ Lhu(current_character(), MemOperand(kScratchReg));
     } else {
-  DCHECK_EQ(1, characters);
+      DCHECK_EQ(1, characters);
       __ Add64(kScratchReg, end_of_input_address(), offset);
       __ Lbu(current_character(), MemOperand(kScratchReg));
     }
diff --git a/src/regexp/riscv64/regexp-macro-assembler-riscv64.h b/src/regexp/riscv64/regexp-macro-assembler-riscv64.h
index 7613b47b3e..4043f57f3e 100644
--- a/src/regexp/riscv64/regexp-macro-assembler-riscv64.h
+++ b/src/regexp/riscv64/regexp-macro-assembler-riscv64.h
@@ -156,13 +156,13 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerRISCV
 
   // Register holding the current input position as negative offset from
   // the end of the string.
-  static constexpr Register current_input_offset() { return s1; }
+  static constexpr Register current_input_offset() { return s2; }
 
   // The register containing the current character after LoadCurrentCharacter.
-  static constexpr Register current_character() { return s2; }
+  static constexpr Register current_character() { return s5; }
 
   // Register holding address of the end of the input string.
-  static constexpr Register end_of_input_address() { return t2; }
+  static constexpr Register end_of_input_address() { return s6; }
 
   // Register holding the frame address. Local variables, parameters and
   // regexp registers are addressed relative to this.
@@ -170,10 +170,10 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerRISCV
 
   // The register containing the backtrack stack top. Provides a meaningful
   // name to the register.
-  static constexpr Register backtrack_stackpointer() { return t0; }
+  static constexpr Register backtrack_stackpointer() { return s7; }
 
   // Register holding pointer to the current code object.
-  static constexpr Register code_pointer() { return s4; }
+  static constexpr Register code_pointer() { return s1; }
 
   // Byte size of chars in the string to match (decided by the Mode argument).
   inline int char_size() const { return static_cast<int>(mode_); }
@@ -200,8 +200,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerRISCV
 
   void LoadRegExpStackPointerFromMemory(Register dst);
   void StoreRegExpStackPointerToMemory(Register src, Register scratch);
-  void PushRegExpBasePointer(Register scratch1, Register scratch2);
-  void PopRegExpBasePointer(Register scratch1, Register scratch2);
+  void PushRegExpBasePointer(Register stack_pointer, Register scratch);
+  void PopRegExpBasePointer(Register stack_pointer_out, Register scratch);
 
   Isolate* isolate() const { return masm_->isolate(); }
 
-- 
2.35.1


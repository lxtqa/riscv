From 8b5783dcbc69c2c3faeb0144674d9d93ad10fbcd Mon Sep 17 00:00:00 2001
From: Dan Elphick <delphick@chromium.org>
Date: Thu, 31 Oct 2019 16:18:38 +0000
Subject: [PATCH] [cleanup] TNodify builtins-generator-gen.cc

Bug: v8:9810, v8:6949
Change-Id: If40852159e67b9bd0d6e5c7c6259fadf8b8ec3bc
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/1893345
Commit-Queue: Dan Elphick <delphick@chromium.org>
Reviewed-by: Santiago Aboy Solanes <solanes@chromium.org>
Cr-Commit-Position: refs/heads/master@{#64696}
---
 src/builtins/builtins-generator-gen.cc | 29 +++++++++++++++-----------
 1 file changed, 17 insertions(+), 12 deletions(-)

diff --git a/src/builtins/builtins-generator-gen.cc b/src/builtins/builtins-generator-gen.cc
index 0a4b3b205b9..4531994b60f 100644
--- a/src/builtins/builtins-generator-gen.cc
+++ b/src/builtins/builtins-generator-gen.cc
@@ -26,21 +26,23 @@ class GeneratorBuiltinsAssembler : public CodeStubAssembler {
   // prototype methods as well as AsyncModuleEvaluate. The only difference
   // between AsyncModuleEvaluate and JSGeneratorObject::PrototypeNext is
   // the expected reciever.
-  void InnerResume(CodeStubArguments* args, Node* receiver, Node* value,
-                   Node* context, JSGeneratorObject::ResumeMode resume_mode,
+  void InnerResume(CodeStubArguments* args, TNode<JSGeneratorObject> receiver,
+                   TNode<Object> value, TNode<Context> context,
+                   JSGeneratorObject::ResumeMode resume_mode,
                    char const* const method_name);
-  void GeneratorPrototypeResume(CodeStubArguments* args, Node* receiver,
-                                Node* value, Node* context,
+  void GeneratorPrototypeResume(CodeStubArguments* args, TNode<Object> receiver,
+                                TNode<Object> value, TNode<Context> context,
                                 JSGeneratorObject::ResumeMode resume_mode,
                                 char const* const method_name);
 };
 
 void GeneratorBuiltinsAssembler::InnerResume(
-    CodeStubArguments* args, Node* receiver, Node* value, Node* context,
+    CodeStubArguments* args, TNode<JSGeneratorObject> receiver,
+    TNode<Object> value, TNode<Context> context,
     JSGeneratorObject::ResumeMode resume_mode, char const* const method_name) {
   // Check if the {receiver} is running or already closed.
   TNode<Smi> receiver_continuation =
-      CAST(LoadObjectField(receiver, JSGeneratorObject::kContinuationOffset));
+      LoadObjectField<Smi>(receiver, JSGeneratorObject::kContinuationOffset);
   Label if_receiverisclosed(this, Label::kDeferred),
       if_receiverisrunning(this, Label::kDeferred);
   TNode<Smi> closed = SmiConstant(JSGeneratorObject::kGeneratorClosed);
@@ -64,7 +66,7 @@ void GeneratorBuiltinsAssembler::InnerResume(
   // If the generator is not suspended (i.e., its state is 'executing'),
   // close it and wrap the return value in IteratorResult.
   TNode<Smi> result_continuation =
-      CAST(LoadObjectField(receiver, JSGeneratorObject::kContinuationOffset));
+      LoadObjectField<Smi>(receiver, JSGeneratorObject::kContinuationOffset);
 
   // The generator function should not close the generator by itself, let's
   // check it is indeed not closed yet.
@@ -88,7 +90,7 @@ void GeneratorBuiltinsAssembler::InnerResume(
   BIND(&if_receiverisclosed);
   {
     // The {receiver} is closed already.
-    Node* result = nullptr;
+    TNode<Object> result;
     switch (resume_mode) {
       case JSGeneratorObject::kNext:
         result = CallBuiltin(Builtins::kCreateIterResultObject, context,
@@ -118,12 +120,14 @@ void GeneratorBuiltinsAssembler::InnerResume(
 }
 
 void GeneratorBuiltinsAssembler::GeneratorPrototypeResume(
-    CodeStubArguments* args, Node* receiver, Node* value, Node* context,
-    JSGeneratorObject::ResumeMode resume_mode, char const* const method_name) {
+    CodeStubArguments* args, TNode<Object> receiver, TNode<Object> value,
+    TNode<Context> context, JSGeneratorObject::ResumeMode resume_mode,
+    char const* const method_name) {
   // Check if the {receiver} is actually a JSGeneratorObject.
   ThrowIfNotInstanceType(context, receiver, JS_GENERATOR_OBJECT_TYPE,
                          method_name);
-  InnerResume(args, receiver, value, context, resume_mode, method_name);
+  TNode<JSGeneratorObject> generator = CAST(receiver);
+  InnerResume(args, generator, value, context, resume_mode, method_name);
 }
 
 TF_BUILTIN(AsyncModuleEvaluate, GeneratorBuiltinsAssembler) {
@@ -142,7 +146,8 @@ TF_BUILTIN(AsyncModuleEvaluate, GeneratorBuiltinsAssembler) {
   char const* const method_name = "[AsyncModule].evaluate";
   ThrowIfNotInstanceType(context, receiver, JS_ASYNC_FUNCTION_OBJECT_TYPE,
                          method_name);
-  InnerResume(&args, receiver, value, context, JSGeneratorObject::kNext,
+  TNode<JSAsyncFunctionObject> async_function = CAST(receiver);
+  InnerResume(&args, async_function, value, context, JSGeneratorObject::kNext,
               method_name);
 }
 
-- 
2.35.1


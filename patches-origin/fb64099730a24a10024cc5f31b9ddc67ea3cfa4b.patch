From fb64099730a24a10024cc5f31b9ddc67ea3cfa4b Mon Sep 17 00:00:00 2001
From: Camillo Bruni <cbruni@chromium.org>
Date: Thu, 6 Apr 2017 12:46:06 +0200
Subject: [PATCH] [csa] Use BIND macro for debug information

Change-Id: Ie84fbc26a3f3782564f3d0734c284f19a75853f3
Reviewed-on: https://chromium-review.googlesource.com/469826
Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
Commit-Queue: Camillo Bruni <cbruni@chromium.org>
Cr-Commit-Position: refs/heads/master@{#44438}
---
 src/builtins/builtins-arguments-gen.cc        |  22 +-
 src/builtins/builtins-array-gen.cc            | 270 +++---
 src/builtins/builtins-async-function-gen.cc   |   4 +-
 src/builtins/builtins-async-gen.cc            |   4 +-
 src/builtins/builtins-async-generator-gen.cc  |  34 +-
 src/builtins/builtins-async-iterator-gen.cc   |  20 +-
 src/builtins/builtins-constructor-gen.cc      |  62 +-
 src/builtins/builtins-conversion-gen.cc       |  46 +-
 src/builtins/builtins-date-gen.cc             |  12 +-
 src/builtins/builtins-forin-gen.cc            |  22 +-
 src/builtins/builtins-function-gen.cc         |  14 +-
 src/builtins/builtins-generator-gen.cc        |   6 +-
 src/builtins/builtins-global-gen.cc           |  20 +-
 src/builtins/builtins-handler-gen.cc          |   6 +-
 src/builtins/builtins-internal-gen.cc         |  20 +-
 src/builtins/builtins-math-gen.cc             |  46 +-
 src/builtins/builtins-number-gen.cc           | 258 ++---
 src/builtins/builtins-object-gen.cc           |  64 +-
 src/builtins/builtins-promise-gen.cc          | 178 ++--
 src/builtins/builtins-regexp-gen.cc           | 290 +++---
 .../builtins-sharedarraybuffer-gen.cc         |  66 +-
 src/builtins/builtins-string-gen.cc           | 154 +--
 src/builtins/builtins-typedarray-gen.cc       |  62 +-
 src/code-stub-assembler.cc                    | 908 +++++++++---------
 src/code-stubs.cc                             |  44 +-
 src/ic/accessor-assembler.cc                  | 284 +++---
 src/ic/binary-op-assembler.cc                 | 154 +--
 src/ic/keyed-store-generic.cc                 | 120 +--
 28 files changed, 1595 insertions(+), 1595 deletions(-)

diff --git a/src/builtins/builtins-arguments-gen.cc b/src/builtins/builtins-arguments-gen.cc
index 2f562622d5e..b583a71a1fd 100644
--- a/src/builtins/builtins-arguments-gen.cc
+++ b/src/builtins/builtins-arguments-gen.cc
@@ -53,7 +53,7 @@ ArgumentsBuiltinsAssembler::GetArgumentsFrameAndCount(Node* function,
   argument_count.Bind(TaggedToParameter(adapted_parameter_count, mode));
   Goto(&done_argument_count);
 
-  Bind(&done_argument_count);
+  BIND(&done_argument_count);
   return std::tuple<Node*, Node*, Node*>(
       frame_ptr.value(), argument_count.value(), formal_parameter_count);
 }
@@ -179,7 +179,7 @@ Node* ArgumentsBuiltinsAssembler::EmitFastNewRestParameter(Node* context,
       mode, JSArray::kSize));
   Goto(&done);
 
-  Bind(&no_rest_parameters);
+  BIND(&no_rest_parameters);
   {
     Node* arguments;
     Node* elements;
@@ -190,13 +190,13 @@ Node* ArgumentsBuiltinsAssembler::EmitFastNewRestParameter(Node* context,
     Goto(&done);
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     result.Bind(CallRuntime(Runtime::kNewRestParameter, context, function));
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -235,7 +235,7 @@ Node* ArgumentsBuiltinsAssembler::EmitFastNewStrictArguments(Node* context,
       JSStrictArgumentsObject::kSize));
   Goto(&done);
 
-  Bind(&empty);
+  BIND(&empty);
   {
     Node* arguments;
     Node* elements;
@@ -246,13 +246,13 @@ Node* ArgumentsBuiltinsAssembler::EmitFastNewStrictArguments(Node* context,
     Goto(&done);
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     result.Bind(CallRuntime(Runtime::kNewStrictArguments, context, function));
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -372,7 +372,7 @@ Node* ArgumentsBuiltinsAssembler::EmitFastNewSloppyArguments(Node* context,
     Goto(&done);
   }
 
-  Bind(&no_parameters);
+  BIND(&no_parameters);
   {
     Comment("No parameters JSSloppyArgumentsObject");
     GotoIfFixedArraySizeDoesntFitInNewSpace(
@@ -389,7 +389,7 @@ Node* ArgumentsBuiltinsAssembler::EmitFastNewSloppyArguments(Node* context,
     Goto(&done);
   }
 
-  Bind(&empty);
+  BIND(&empty);
   {
     Comment("Empty JSSloppyArgumentsObject");
     Node* const native_context = LoadNativeContext(context);
@@ -406,13 +406,13 @@ Node* ArgumentsBuiltinsAssembler::EmitFastNewSloppyArguments(Node* context,
     Goto(&done);
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     result.Bind(CallRuntime(Runtime::kNewSloppyArguments, context, function));
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.cc
index 6a51a4ac36e..2f3c4f1c334 100644
--- a/src/builtins/builtins-array-gen.cc
+++ b/src/builtins/builtins-array-gen.cc
@@ -45,9 +45,9 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
                          this_arg(), k_value, k, o());
     Label false_continue(this), return_true(this);
     BranchIfToBooleanIsTrue(value, &return_true, &false_continue);
-    Bind(&return_true);
+    BIND(&return_true);
     Return(TrueConstant());
-    Bind(&false_continue);
+    BIND(&false_continue);
     return a();
   }
 
@@ -58,9 +58,9 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
                          this_arg(), k_value, k, o());
     Label true_continue(this), return_false(this);
     BranchIfToBooleanIsTrue(value, &true_continue, &return_false);
-    Bind(&return_false);
+    BIND(&return_false);
     Return(FalseConstant());
-    Bind(&true_continue);
+    BIND(&true_continue);
     return a();
   }
 
@@ -84,17 +84,17 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
            &no_initial_value, &has_initial_value);
 
     // a. Set accumulator to initialValue.
-    Bind(&has_initial_value);
+    BIND(&has_initial_value);
     a.Bind(this_arg());
     Goto(&done);
 
     // 9. Else initialValue is not present,
-    Bind(&no_initial_value);
+    BIND(&no_initial_value);
 
     // a. Let kPresent be false.
     a.Bind(TheHoleConstant());
     Goto(&done);
-    Bind(&done);
+    BIND(&done);
     return a.value();
   }
 
@@ -106,11 +106,11 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
                        UndefinedConstant(), a(), k_value, k, o()));
     Goto(&done);
 
-    Bind(&initial);
+    BIND(&initial);
     result.Bind(k_value);
     Goto(&done);
 
-    Bind(&done);
+    BIND(&done);
     return result.value();
   }
 
@@ -120,7 +120,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
     CallRuntime(Runtime::kThrowTypeError, context(),
                 SmiConstant(MessageTemplate::kReduceNoInitial));
     Unreachable();
-    Bind(&ok);
+    BIND(&ok);
   }
 
   Node* FilterResultGenerator() {
@@ -134,7 +134,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
                             callbackfn(), this_arg(), k_value, k, o());
     Label true_continue(this, &to_), false_continue(this);
     BranchIfToBooleanIsTrue(selected, &true_continue, &false_continue);
-    Bind(&true_continue);
+    BIND(&true_continue);
     // iii. If selected is true, then...
     {
       // 1. Perform ? CreateDataPropertyOrThrow(A, ToString(to), kValue).
@@ -145,7 +145,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       to_.Bind(NumberInc(to_.value()));
       Goto(&false_continue);
     }
-    Bind(&false_continue);
+    BIND(&false_continue);
     return a();
   }
 
@@ -220,13 +220,13 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
     GotoIf(DoesntHaveInstanceType(o(), JS_ARRAY_TYPE), &not_js_array);
     merged_length.Bind(LoadJSArrayLength(o()));
     Goto(&has_length);
-    Bind(&not_js_array);
+    BIND(&not_js_array);
     Node* len_property =
         GetProperty(context(), o(), isolate()->factory()->length_string());
     merged_length.Bind(
         CallStub(CodeFactory::ToLength(isolate()), context(), len_property));
     Goto(&has_length);
-    Bind(&has_length);
+    BIND(&has_length);
     len_ = merged_length.value();
 
     // 5. If IsCallable(callbackfn) is false, throw a TypeError exception.
@@ -235,7 +235,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
     GotoIf(TaggedIsSmi(callbackfn()), &type_exception);
     Branch(IsCallableMap(LoadMap(callbackfn())), &done, &type_exception);
 
-    Bind(&throw_null_undefined_exception);
+    BIND(&throw_null_undefined_exception);
     {
       CallRuntime(
           Runtime::kThrowTypeError, context(),
@@ -244,7 +244,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       Unreachable();
     }
 
-    Bind(&type_exception);
+    BIND(&type_exception);
     {
       CallRuntime(Runtime::kThrowTypeError, context(),
                   SmiConstant(MessageTemplate::kCalledNonCallable),
@@ -252,7 +252,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       Unreachable();
     }
 
-    Bind(&done);
+    BIND(&done);
 
     // 6. If thisArg was supplied, let T be thisArg; else let T be undefined.
     // [Already done by the arguments adapter]
@@ -269,7 +269,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
 
     HandleFastElements(processor, action, &slow, direction);
 
-    Bind(&slow);
+    BIND(&slow);
 
     Node* target = LoadFromFrame(StandardFrameConstants::kFunctionOffset,
                                  MachineType::TaggedPointer());
@@ -322,14 +322,14 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
     Branch(IsCallableMap(LoadMap(callbackfn_)), &distinguish_types,
            &throw_not_callable);
 
-    Bind(&throw_not_typed_array);
+    BIND(&throw_not_typed_array);
     {
       CallRuntime(Runtime::kThrowTypeError, context_,
                   SmiConstant(MessageTemplate::kNotTypedArray));
       Unreachable();
     }
 
-    Bind(&throw_detached);
+    BIND(&throw_detached);
     {
       CallRuntime(Runtime::kThrowTypeError, context_,
                   SmiConstant(MessageTemplate::kDetachedOperation),
@@ -337,7 +337,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       Unreachable();
     }
 
-    Bind(&throw_not_callable);
+    BIND(&throw_not_callable);
     {
       CallRuntime(Runtime::kThrowTypeError, context_,
                   SmiConstant(MessageTemplate::kCalledNonCallable),
@@ -346,7 +346,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
     }
 
     Label unexpected_instance_type(this);
-    Bind(&unexpected_instance_type);
+    BIND(&unexpected_instance_type);
     Unreachable();
 
     std::vector<int32_t> instance_types = {
@@ -363,14 +363,14 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       label_ptrs.push_back(&label);
     }
 
-    Bind(&distinguish_types);
+    BIND(&distinguish_types);
     a_.Bind(generator(this));
     Node* elements_type = LoadInstanceType(LoadElements(o_));
     Switch(elements_type, &unexpected_instance_type, instance_types.data(),
            label_ptrs.data(), labels.size());
 
     for (size_t i = 0; i < labels.size(); ++i) {
-      Bind(&labels[i]);
+      BIND(&labels[i]);
       Label done(this);
       // TODO(tebbi): Silently cancelling the loop on buffer detachment is a
       // spec violation. Should go to &detached and throw a TypeError instead.
@@ -381,7 +381,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       Goto(&done);
       action(this);
       // No exception, return success
-      Bind(&done);
+      BIND(&done);
       Return(a_.value());
     }
   }
@@ -392,7 +392,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
     Label loop(this, {&k_, &a_, &to_});
     Label after_loop(this);
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       if (direction == ForEachDirection::kForward) {
         // 8. Repeat, while k < len
@@ -423,7 +423,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       a_.Bind(processor(this, k_value, k()));
       Goto(&done_element);
 
-      Bind(&done_element);
+      BIND(&done_element);
 
       if (direction == ForEachDirection::kForward) {
         // e. Increase k by 1.
@@ -434,7 +434,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       }
       Goto(&loop);
     }
-    Bind(&after_loop);
+    BIND(&after_loop);
 
     action(this);
     Return(a_.value());
@@ -532,13 +532,13 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
           a_.Bind(processor(this, value, k()));
           Goto(&one_element_done);
 
-          Bind(&hole_element);
+          BIND(&hole_element);
           // Check if o's prototype change unexpectedly has elements after the
           // callback in the case of a hole.
           BranchIfPrototypesHaveNoElements(o_map, &one_element_done,
                                            array_changed);
 
-          Bind(&one_element_done);
+          BIND(&one_element_done);
         },
         1, mode, advance_mode);
     Comment("end VisitAllFastElementsOneKind");
@@ -558,7 +558,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
                         CodeStubAssembler::FastJSArrayAccessMode::INBOUNDS_READ,
                         &switch_on_elements_kind, slow);
 
-    Bind(&switch_on_elements_kind);
+    BIND(&switch_on_elements_kind);
     // Select by ElementsKind
     Node* o_map = LoadMap(o());
     Node* bit_field2 = LoadMapBitField2(o_map);
@@ -567,7 +567,7 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
            &maybe_double_elements, &fast_elements);
 
     ParameterMode mode = OptimalParameterMode();
-    Bind(&fast_elements);
+    BIND(&fast_elements);
     {
       VisitAllFastElementsOneKind(FAST_ELEMENTS, processor, slow, mode,
                                   direction);
@@ -578,11 +578,11 @@ class ArrayBuiltinCodeStubAssembler : public CodeStubAssembler {
       Return(a_.value());
     }
 
-    Bind(&maybe_double_elements);
+    BIND(&maybe_double_elements);
     Branch(Int32GreaterThan(kind, Int32Constant(FAST_HOLEY_DOUBLE_ELEMENTS)),
            slow, &fast_double_elements);
 
-    Bind(&fast_double_elements);
+    BIND(&fast_double_elements);
     {
       VisitAllFastElementsOneKind(FAST_DOUBLE_ELEMENTS, processor, slow, mode,
                                   direction);
@@ -630,7 +630,7 @@ TF_BUILTIN(FastArrayPush, CodeStubAssembler) {
   BranchIfFastJSArray(receiver, context, FastJSArrayAccessMode::ANY_ACCESS,
                       &fast, &runtime);
 
-  Bind(&fast);
+  BIND(&fast);
   {
     // Disallow pushing onto prototypes. It might be the JSArray prototype.
     // Disallow pushing onto non-extensible objects.
@@ -672,7 +672,7 @@ TF_BUILTIN(FastArrayPush, CodeStubAssembler) {
   // transition the array for only the single next element. If the argument is
   // a smi, the failure is due to some other reason and we should fall back on
   // the most generic implementation for the rest of the array.
-  Bind(&smi_transition);
+  BIND(&smi_transition);
   {
     Node* arg = args.AtIndex(arg_index.value());
     GotoIf(TaggedIsSmi(arg), &default_label);
@@ -694,20 +694,20 @@ TF_BUILTIN(FastArrayPush, CodeStubAssembler) {
     Goto(&double_push);
   }
 
-  Bind(&object_push_pre);
+  BIND(&object_push_pre);
   {
     Branch(Int32GreaterThan(kind, Int32Constant(FAST_HOLEY_ELEMENTS)),
            &double_push, &object_push);
   }
 
-  Bind(&object_push);
+  BIND(&object_push);
   {
     Node* new_length = BuildAppendJSArray(FAST_ELEMENTS, context, receiver,
                                           args, arg_index, &default_label);
     args.PopAndReturn(new_length);
   }
 
-  Bind(&double_push);
+  BIND(&double_push);
   {
     Node* new_length =
         BuildAppendJSArray(FAST_DOUBLE_ELEMENTS, context, receiver, args,
@@ -719,7 +719,7 @@ TF_BUILTIN(FastArrayPush, CodeStubAssembler) {
   // transition the array for only the single next element. If the argument is
   // a double, the failure is due to some other reason and we should fall back
   // on the most generic implementation for the rest of the array.
-  Bind(&double_transition);
+  BIND(&double_transition);
   {
     Node* arg = args.AtIndex(arg_index.value());
     GotoIfNumber(arg, &default_label);
@@ -741,7 +741,7 @@ TF_BUILTIN(FastArrayPush, CodeStubAssembler) {
 
   // Fallback that stores un-processed arguments using the full, heavyweight
   // SetProperty machinery.
-  Bind(&default_label);
+  BIND(&default_label);
   {
     args.ForEach(
         [this, receiver, context](Node* arg) {
@@ -753,7 +753,7 @@ TF_BUILTIN(FastArrayPush, CodeStubAssembler) {
     args.PopAndReturn(LoadJSArrayLength(receiver));
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     Node* target = LoadFromFrame(StandardFrameConstants::kFunctionOffset,
                                  MachineType::TaggedPointer());
@@ -1079,13 +1079,13 @@ TF_BUILTIN(ArrayIsArray, CodeStubAssembler) {
   Branch(Word32Equal(instance_type, Int32Constant(JS_PROXY_TYPE)),
          &call_runtime, &return_false);
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   Return(CallRuntime(Runtime::kArrayIsArray, context, object));
 }
 
@@ -1107,7 +1107,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
   BranchIfFastJSArray(array, context, FastJSArrayAccessMode::INBOUNDS_READ,
                       &init_len, &call_runtime);
 
-  Bind(&init_len);
+  BIND(&init_len);
   // JSArray length is always an Smi for fast arrays.
   CSA_ASSERT(this, TaggedIsSmi(LoadObjectField(array, JSArray::kLengthOffset)));
   Node* const len = LoadAndUntagObjectField(array, JSArray::kLengthOffset);
@@ -1117,7 +1117,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
   // Bailout to slow path if startIndex is not an Smi.
   Branch(TaggedIsSmi(start_from), &init_k, &call_runtime);
 
-  Bind(&init_k);
+  BIND(&init_k);
   CSA_ASSERT(this, TaggedIsSmi(start_from));
   Node* const untagged_start_from = SmiToWord(start_from);
   index_var.Bind(
@@ -1132,7 +1132,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
              MachineType::PointerRepresentation()));
 
   Goto(&select_loop);
-  Bind(&select_loop);
+  BIND(&select_loop);
   static int32_t kElementsKind[] = {
       FAST_SMI_ELEMENTS,   FAST_HOLEY_SMI_ELEMENTS, FAST_ELEMENTS,
       FAST_HOLEY_ELEMENTS, FAST_DOUBLE_ELEMENTS,    FAST_HOLEY_DOUBLE_ELEMENTS,
@@ -1149,7 +1149,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
   Switch(elements_kind, &return_false, kElementsKind, element_kind_handlers,
          arraysize(kElementsKind));
 
-  Bind(&if_smiorobjects);
+  BIND(&if_smiorobjects);
   {
     Variable search_num(this, MachineRepresentation::kFloat64);
     Label ident_loop(this, &index_var), heap_num_loop(this, &search_num),
@@ -1160,19 +1160,19 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
     search_num.Bind(SmiToFloat64(search_element));
     Goto(&heap_num_loop);
 
-    Bind(&not_smi);
+    BIND(&not_smi);
     GotoIf(WordEqual(search_element, UndefinedConstant()), &undef_loop);
     Node* map = LoadMap(search_element);
     GotoIfNot(IsHeapNumberMap(map), &not_heap_num);
     search_num.Bind(LoadHeapNumberValue(search_element));
     Goto(&heap_num_loop);
 
-    Bind(&not_heap_num);
+    BIND(&not_heap_num);
     Node* search_type = LoadMapInstanceType(map);
     GotoIf(IsStringInstanceType(search_type), &string_loop);
     Goto(&ident_loop);
 
-    Bind(&ident_loop);
+    BIND(&ident_loop);
     {
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
       Node* element_k = LoadFixedArrayElement(elements, index_var.value());
@@ -1182,7 +1182,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
       Goto(&ident_loop);
     }
 
-    Bind(&undef_loop);
+    BIND(&undef_loop);
     {
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
       Node* element_k = LoadFixedArrayElement(elements, index_var.value());
@@ -1193,12 +1193,12 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
       Goto(&undef_loop);
     }
 
-    Bind(&heap_num_loop);
+    BIND(&heap_num_loop);
     {
       Label nan_loop(this, &index_var), not_nan_loop(this, &index_var);
       BranchIfFloat64IsNaN(search_num.value(), &nan_loop, &not_nan_loop);
 
-      Bind(&not_nan_loop);
+      BIND(&not_nan_loop);
       {
         Label continue_loop(this), not_smi(this);
         GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
@@ -1207,17 +1207,17 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
         Branch(Float64Equal(search_num.value(), SmiToFloat64(element_k)),
                &return_true, &continue_loop);
 
-        Bind(&not_smi);
+        BIND(&not_smi);
         GotoIfNot(IsHeapNumber(element_k), &continue_loop);
         Branch(Float64Equal(search_num.value(), LoadHeapNumberValue(element_k)),
                &return_true, &continue_loop);
 
-        Bind(&continue_loop);
+        BIND(&continue_loop);
         index_var.Bind(IntPtrAdd(index_var.value(), IntPtrConstant(1)));
         Goto(&not_nan_loop);
       }
 
-      Bind(&nan_loop);
+      BIND(&nan_loop);
       {
         Label continue_loop(this);
         GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
@@ -1227,13 +1227,13 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
         BranchIfFloat64IsNaN(LoadHeapNumberValue(element_k), &return_true,
                              &continue_loop);
 
-        Bind(&continue_loop);
+        BIND(&continue_loop);
         index_var.Bind(IntPtrAdd(index_var.value(), IntPtrConstant(1)));
         Goto(&nan_loop);
       }
     }
 
-    Bind(&string_loop);
+    BIND(&string_loop);
     {
       Label continue_loop(this);
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
@@ -1248,13 +1248,13 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
       Branch(WordEqual(BooleanConstant(true), result), &return_true,
              &continue_loop);
 
-      Bind(&continue_loop);
+      BIND(&continue_loop);
       index_var.Bind(IntPtrAdd(index_var.value(), IntPtrConstant(1)));
       Goto(&string_loop);
     }
   }
 
-  Bind(&if_packed_doubles);
+  BIND(&if_packed_doubles);
   {
     Label nan_loop(this, &index_var), not_nan_loop(this, &index_var),
         hole_loop(this, &index_var), search_notnan(this);
@@ -1264,7 +1264,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
     search_num.Bind(SmiToFloat64(search_element));
     Goto(&not_nan_loop);
 
-    Bind(&search_notnan);
+    BIND(&search_notnan);
     GotoIfNot(IsHeapNumber(search_element), &return_false);
 
     search_num.Bind(LoadHeapNumberValue(search_element));
@@ -1272,7 +1272,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
     BranchIfFloat64IsNaN(search_num.value(), &nan_loop, &not_nan_loop);
 
     // Search for HeapNumber
-    Bind(&not_nan_loop);
+    BIND(&not_nan_loop);
     {
       Label continue_loop(this);
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
@@ -1280,26 +1280,26 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
                                                     MachineType::Float64());
       Branch(Float64Equal(element_k, search_num.value()), &return_true,
              &continue_loop);
-      Bind(&continue_loop);
+      BIND(&continue_loop);
       index_var.Bind(IntPtrAdd(index_var.value(), IntPtrConstant(1)));
       Goto(&not_nan_loop);
     }
 
     // Search for NaN
-    Bind(&nan_loop);
+    BIND(&nan_loop);
     {
       Label continue_loop(this);
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
       Node* element_k = LoadFixedDoubleArrayElement(elements, index_var.value(),
                                                     MachineType::Float64());
       BranchIfFloat64IsNaN(element_k, &return_true, &continue_loop);
-      Bind(&continue_loop);
+      BIND(&continue_loop);
       index_var.Bind(IntPtrAdd(index_var.value(), IntPtrConstant(1)));
       Goto(&nan_loop);
     }
   }
 
-  Bind(&if_holey_doubles);
+  BIND(&if_holey_doubles);
   {
     Label nan_loop(this, &index_var), not_nan_loop(this, &index_var),
         hole_loop(this, &index_var), search_notnan(this);
@@ -1309,7 +1309,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
     search_num.Bind(SmiToFloat64(search_element));
     Goto(&not_nan_loop);
 
-    Bind(&search_notnan);
+    BIND(&search_notnan);
     GotoIf(WordEqual(search_element, UndefinedConstant()), &hole_loop);
     GotoIfNot(IsHeapNumber(search_element), &return_false);
 
@@ -1318,7 +1318,7 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
     BranchIfFloat64IsNaN(search_num.value(), &nan_loop, &not_nan_loop);
 
     // Search for HeapNumber
-    Bind(&not_nan_loop);
+    BIND(&not_nan_loop);
     {
       Label continue_loop(this);
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
@@ -1330,13 +1330,13 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
 
       Branch(Float64Equal(element_k, search_num.value()), &return_true,
              &continue_loop);
-      Bind(&continue_loop);
+      BIND(&continue_loop);
       index_var.Bind(IntPtrAdd(index_var.value(), IntPtrConstant(1)));
       Goto(&not_nan_loop);
     }
 
     // Search for NaN
-    Bind(&nan_loop);
+    BIND(&nan_loop);
     {
       Label continue_loop(this);
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
@@ -1347,13 +1347,13 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
           INTPTR_PARAMETERS, &continue_loop);
 
       BranchIfFloat64IsNaN(element_k, &return_true, &continue_loop);
-      Bind(&continue_loop);
+      BIND(&continue_loop);
       index_var.Bind(IntPtrAdd(index_var.value(), IntPtrConstant(1)));
       Goto(&nan_loop);
     }
 
     // Search for the Hole
-    Bind(&hole_loop);
+    BIND(&hole_loop);
     {
       GotoIfNot(UintPtrLessThan(index_var.value(), len), &return_false);
 
@@ -1367,13 +1367,13 @@ TF_BUILTIN(ArrayIncludes, CodeStubAssembler) {
     }
   }
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(TrueConstant());
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(FalseConstant());
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   Return(CallRuntime(Runtime::kArrayIncludes_Slow, context, array,
                      search_element, start_from));
 }
@@ -1404,7 +1404,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
   BranchIfFastJSArray(array, context, FastJSArrayAccessMode::INBOUNDS_READ,
                       &init_len, &call_runtime);
 
-  Bind(&init_len);
+  BIND(&init_len);
   {
     // JSArray length is always an Smi for fast arrays.
     CSA_ASSERT(this,
@@ -1415,7 +1415,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
     Branch(WordEqual(len_var.value(), intptr_zero), &return_not_found, &init_k);
   }
 
-  Bind(&init_k);
+  BIND(&init_k);
   {
     // For now only deal with undefined and Smis here; we must be really careful
     // with side-effects from the ToInteger conversion as the side-effects might
@@ -1425,14 +1425,14 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
         init_k_n(this);
     Branch(TaggedIsSmi(start_from), &init_k_smi, &init_k_other);
 
-    Bind(&init_k_smi);
+    BIND(&init_k_smi);
     {
       // The fromIndex is a Smi.
       start_from_var.Bind(SmiUntag(start_from));
       Goto(&init_k_n);
     }
 
-    Bind(&init_k_other);
+    BIND(&init_k_other);
     {
       // The fromIndex must be undefined then, otherwise bailout and let the
       // runtime deal with the full ToInteger conversion.
@@ -1441,32 +1441,32 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
       Goto(&init_k_n);
     }
 
-    Bind(&init_k_n);
+    BIND(&init_k_n);
     {
       Label if_positive(this), if_negative(this), done(this);
       Branch(IntPtrLessThan(start_from_var.value(), intptr_zero), &if_negative,
              &if_positive);
 
-      Bind(&if_positive);
+      BIND(&if_positive);
       {
         index_var.Bind(start_from_var.value());
         Goto(&done);
       }
 
-      Bind(&if_negative);
+      BIND(&if_negative);
       {
         index_var.Bind(IntPtrAdd(len_var.value(), start_from_var.value()));
         Branch(IntPtrLessThan(index_var.value(), intptr_zero), &init_k_zero,
                &done);
       }
 
-      Bind(&init_k_zero);
+      BIND(&init_k_zero);
       {
         index_var.Bind(intptr_zero);
         Goto(&done);
       }
 
-      Bind(&done);
+      BIND(&done);
     }
   }
 
@@ -1486,7 +1486,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
   Switch(elements_kind, &return_not_found, kElementsKind, element_kind_handlers,
          arraysize(kElementsKind));
 
-  Bind(&if_smiorobjects);
+  BIND(&if_smiorobjects);
   {
     Variable search_num(this, MachineRepresentation::kFloat64);
     Label ident_loop(this, &index_var), heap_num_loop(this, &search_num),
@@ -1496,18 +1496,18 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
     search_num.Bind(SmiToFloat64(search_element));
     Goto(&heap_num_loop);
 
-    Bind(&not_smi);
+    BIND(&not_smi);
     Node* map = LoadMap(search_element);
     GotoIfNot(IsHeapNumberMap(map), &not_heap_num);
     search_num.Bind(LoadHeapNumberValue(search_element));
     Goto(&heap_num_loop);
 
-    Bind(&not_heap_num);
+    BIND(&not_heap_num);
     Node* search_type = LoadMapInstanceType(map);
     GotoIf(IsStringInstanceType(search_type), &string_loop);
     Goto(&ident_loop);
 
-    Bind(&ident_loop);
+    BIND(&ident_loop);
     {
       GotoIfNot(UintPtrLessThan(index_var.value(), len_var.value()),
                 &return_not_found);
@@ -1518,13 +1518,13 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
       Goto(&ident_loop);
     }
 
-    Bind(&heap_num_loop);
+    BIND(&heap_num_loop);
     {
       Label not_nan_loop(this, &index_var);
       BranchIfFloat64IsNaN(search_num.value(), &return_not_found,
                            &not_nan_loop);
 
-      Bind(&not_nan_loop);
+      BIND(&not_nan_loop);
       {
         Label continue_loop(this), not_smi(this);
         GotoIfNot(UintPtrLessThan(index_var.value(), len_var.value()),
@@ -1534,18 +1534,18 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
         Branch(Float64Equal(search_num.value(), SmiToFloat64(element_k)),
                &return_found, &continue_loop);
 
-        Bind(&not_smi);
+        BIND(&not_smi);
         GotoIfNot(IsHeapNumber(element_k), &continue_loop);
         Branch(Float64Equal(search_num.value(), LoadHeapNumberValue(element_k)),
                &return_found, &continue_loop);
 
-        Bind(&continue_loop);
+        BIND(&continue_loop);
         index_var.Bind(IntPtrAdd(index_var.value(), intptr_one));
         Goto(&not_nan_loop);
       }
     }
 
-    Bind(&string_loop);
+    BIND(&string_loop);
     {
       Label continue_loop(this);
       GotoIfNot(UintPtrLessThan(index_var.value(), len_var.value()),
@@ -1560,13 +1560,13 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
       Branch(WordEqual(BooleanConstant(true), result), &return_found,
              &continue_loop);
 
-      Bind(&continue_loop);
+      BIND(&continue_loop);
       index_var.Bind(IntPtrAdd(index_var.value(), intptr_one));
       Goto(&string_loop);
     }
   }
 
-  Bind(&if_packed_doubles);
+  BIND(&if_packed_doubles);
   {
     Label not_nan_loop(this, &index_var), search_notnan(this);
     Variable search_num(this, MachineRepresentation::kFloat64);
@@ -1575,7 +1575,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
     search_num.Bind(SmiToFloat64(search_element));
     Goto(&not_nan_loop);
 
-    Bind(&search_notnan);
+    BIND(&search_notnan);
     GotoIfNot(IsHeapNumber(search_element), &return_not_found);
 
     search_num.Bind(LoadHeapNumberValue(search_element));
@@ -1583,7 +1583,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
     BranchIfFloat64IsNaN(search_num.value(), &return_not_found, &not_nan_loop);
 
     // Search for HeapNumber
-    Bind(&not_nan_loop);
+    BIND(&not_nan_loop);
     {
       GotoIfNot(UintPtrLessThan(index_var.value(), len_var.value()),
                 &return_not_found);
@@ -1596,7 +1596,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
     }
   }
 
-  Bind(&if_holey_doubles);
+  BIND(&if_holey_doubles);
   {
     Label not_nan_loop(this, &index_var), search_notnan(this);
     Variable search_num(this, MachineRepresentation::kFloat64);
@@ -1605,7 +1605,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
     search_num.Bind(SmiToFloat64(search_element));
     Goto(&not_nan_loop);
 
-    Bind(&search_notnan);
+    BIND(&search_notnan);
     GotoIfNot(IsHeapNumber(search_element), &return_not_found);
 
     search_num.Bind(LoadHeapNumberValue(search_element));
@@ -1613,7 +1613,7 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
     BranchIfFloat64IsNaN(search_num.value(), &return_not_found, &not_nan_loop);
 
     // Search for HeapNumber
-    Bind(&not_nan_loop);
+    BIND(&not_nan_loop);
     {
       Label continue_loop(this);
       GotoIfNot(UintPtrLessThan(index_var.value(), len_var.value()),
@@ -1626,19 +1626,19 @@ TF_BUILTIN(ArrayIndexOf, CodeStubAssembler) {
 
       Branch(Float64Equal(element_k, search_num.value()), &return_found,
              &continue_loop);
-      Bind(&continue_loop);
+      BIND(&continue_loop);
       index_var.Bind(IntPtrAdd(index_var.value(), intptr_one));
       Goto(&not_nan_loop);
     }
   }
 
-  Bind(&return_found);
+  BIND(&return_found);
   Return(SmiTag(index_var.value()));
 
-  Bind(&return_not_found);
+  BIND(&return_not_found);
   Return(NumberConstant(-1));
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   Return(CallRuntime(Runtime::kArrayIndexOf, context, array, search_element,
                      start_from));
 }
@@ -1665,7 +1665,7 @@ class ArrayPrototypeIterationAssembler : public CodeStubAssembler {
     Branch(IsJSReceiverInstanceType(var_type.value()), &create_array_iterator,
            &if_isnotobject);
 
-    Bind(&if_isnotobject);
+    BIND(&if_isnotobject);
     {
       Callable callable = CodeFactory::ToObject(isolate());
       Node* result = CallStub(callable, context, receiver);
@@ -1675,7 +1675,7 @@ class ArrayPrototypeIterationAssembler : public CodeStubAssembler {
       Goto(&create_array_iterator);
     }
 
-    Bind(&create_array_iterator);
+    BIND(&create_array_iterator);
     Return(CreateArrayIterator(var_array.value(), var_map.value(),
                                var_type.value(), context, iteration_kind));
   }
@@ -1749,7 +1749,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
 
   Branch(WordEqual(orig_map, array_map), &if_isfastarray, &if_isnotfastarray);
 
-  Bind(&if_isfastarray);
+  BIND(&if_isfastarray);
   {
     CSA_ASSERT(this, Word32Equal(LoadMapInstanceType(array_map),
                                  Int32Constant(JS_ARRAY_TYPE)));
@@ -1796,13 +1796,13 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
     Switch(instance_type, &throw_bad_receiver, kInstanceType,
            kInstanceTypeHandlers, arraysize(kInstanceType));
 
-    Bind(&packed_object_values);
+    BIND(&packed_object_values);
     {
       var_value.Bind(LoadFixedArrayElement(elements, index, 0, SMI_PARAMETERS));
       Goto(&allocate_entry_if_needed);
     }
 
-    Bind(&packed_double_values);
+    BIND(&packed_double_values);
     {
       Node* value = LoadFixedDoubleArrayElement(
           elements, index, MachineType::Float64(), 0, SMI_PARAMETERS);
@@ -1810,7 +1810,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
       Goto(&allocate_entry_if_needed);
     }
 
-    Bind(&holey_object_values);
+    BIND(&holey_object_values);
     {
       // Check the array_protector cell, and take the slow path if it's invalid.
       Node* invalid = SmiConstant(Smi::FromInt(Isolate::kProtectorInvalid));
@@ -1825,7 +1825,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
       Goto(&allocate_entry_if_needed);
     }
 
-    Bind(&holey_double_values);
+    BIND(&holey_double_values);
     {
       // Check the array_protector cell, and take the slow path if it's invalid.
       Node* invalid = SmiConstant(Smi::FromInt(Isolate::kProtectorInvalid));
@@ -1842,7 +1842,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
     }
   }
 
-  Bind(&if_isnotfastarray);
+  BIND(&if_isnotfastarray);
   {
     Label if_istypedarray(this), if_isgeneric(this);
 
@@ -1853,7 +1853,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
     Branch(Word32Equal(array_type, Int32Constant(JS_TYPED_ARRAY_TYPE)),
            &if_istypedarray, &if_isgeneric);
 
-    Bind(&if_isgeneric);
+    BIND(&if_isgeneric);
     {
       Label if_wasfastarray(this);
 
@@ -1864,7 +1864,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
         Branch(Word32Equal(array_type, Int32Constant(JS_ARRAY_TYPE)),
                &if_isarray, &if_isnotarray);
 
-        Bind(&if_isarray);
+        BIND(&if_isarray);
         {
           var_length.Bind(LoadObjectField(array, JSArray::kLengthOffset));
 
@@ -1872,7 +1872,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
           Branch(WordNotEqual(orig_map, UndefinedConstant()), &if_wasfastarray,
                  &done);
 
-          Bind(&if_wasfastarray);
+          BIND(&if_wasfastarray);
           {
             Label if_invalid(this, Label::kDeferred);
             // A fast array iterator transitioned to a slow iterator during
@@ -1894,7 +1894,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
           }
         }
 
-        Bind(&if_isnotarray);
+        BIND(&if_isnotarray);
         {
           Node* length =
               GetProperty(context, array, factory()->length_string());
@@ -1903,7 +1903,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
           Goto(&done);
         }
 
-        Bind(&done);
+        BIND(&done);
         length = var_length.value();
       }
 
@@ -1918,14 +1918,14 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
               instance_type, Int32Constant(JS_GENERIC_ARRAY_KEY_ITERATOR_TYPE)),
           &allocate_key_result, &generic_values);
 
-      Bind(&generic_values);
+      BIND(&generic_values);
       {
         var_value.Bind(GetProperty(context, array, index));
         Goto(&allocate_entry_if_needed);
       }
     }
 
-    Bind(&if_istypedarray);
+    BIND(&if_istypedarray);
     {
       Node* buffer = LoadObjectField(array, JSTypedArray::kBufferOffset);
       GotoIf(IsDetachedBuffer(buffer), &if_isdetached);
@@ -1989,49 +1989,49 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
       Switch(instance_type, &throw_bad_receiver, kInstanceType,
              kInstanceTypeHandlers, arraysize(kInstanceType));
 
-      Bind(&uint8_values);
+      BIND(&uint8_values);
       {
         Node* value_uint8 = LoadFixedTypedArrayElement(
             data_ptr, index, UINT8_ELEMENTS, SMI_PARAMETERS);
         var_value.Bind(SmiFromWord32(value_uint8));
         Goto(&allocate_entry_if_needed);
       }
-      Bind(&int8_values);
+      BIND(&int8_values);
       {
         Node* value_int8 = LoadFixedTypedArrayElement(
             data_ptr, index, INT8_ELEMENTS, SMI_PARAMETERS);
         var_value.Bind(SmiFromWord32(value_int8));
         Goto(&allocate_entry_if_needed);
       }
-      Bind(&uint16_values);
+      BIND(&uint16_values);
       {
         Node* value_uint16 = LoadFixedTypedArrayElement(
             data_ptr, index, UINT16_ELEMENTS, SMI_PARAMETERS);
         var_value.Bind(SmiFromWord32(value_uint16));
         Goto(&allocate_entry_if_needed);
       }
-      Bind(&int16_values);
+      BIND(&int16_values);
       {
         Node* value_int16 = LoadFixedTypedArrayElement(
             data_ptr, index, INT16_ELEMENTS, SMI_PARAMETERS);
         var_value.Bind(SmiFromWord32(value_int16));
         Goto(&allocate_entry_if_needed);
       }
-      Bind(&uint32_values);
+      BIND(&uint32_values);
       {
         Node* value_uint32 = LoadFixedTypedArrayElement(
             data_ptr, index, UINT32_ELEMENTS, SMI_PARAMETERS);
         var_value.Bind(ChangeUint32ToTagged(value_uint32));
         Goto(&allocate_entry_if_needed);
       }
-      Bind(&int32_values);
+      BIND(&int32_values);
       {
         Node* value_int32 = LoadFixedTypedArrayElement(
             data_ptr, index, INT32_ELEMENTS, SMI_PARAMETERS);
         var_value.Bind(ChangeInt32ToTagged(value_int32));
         Goto(&allocate_entry_if_needed);
       }
-      Bind(&float32_values);
+      BIND(&float32_values);
       {
         Node* value_float32 = LoadFixedTypedArrayElement(
             data_ptr, index, FLOAT32_ELEMENTS, SMI_PARAMETERS);
@@ -2039,7 +2039,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
             AllocateHeapNumberWithValue(ChangeFloat32ToFloat64(value_float32)));
         Goto(&allocate_entry_if_needed);
       }
-      Bind(&float64_values);
+      BIND(&float64_values);
       {
         Node* value_float64 = LoadFixedTypedArrayElement(
             data_ptr, index, FLOAT64_ELEMENTS, SMI_PARAMETERS);
@@ -2049,21 +2049,21 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
     }
   }
 
-  Bind(&set_done);
+  BIND(&set_done);
   {
     StoreObjectFieldNoWriteBarrier(
         iterator, JSArrayIterator::kIteratedObjectOffset, UndefinedConstant());
     Goto(&allocate_iterator_result);
   }
 
-  Bind(&allocate_key_result);
+  BIND(&allocate_key_result);
   {
     var_value.Bind(index);
     var_done.Bind(FalseConstant());
     Goto(&allocate_iterator_result);
   }
 
-  Bind(&allocate_entry_if_needed);
+  BIND(&allocate_entry_if_needed);
   {
     GotoIf(Int32GreaterThan(instance_type,
                             Int32Constant(LAST_ARRAY_KEY_VALUE_ITERATOR_TYPE)),
@@ -2088,7 +2088,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
     Goto(&allocate_iterator_result);
   }
 
-  Bind(&allocate_iterator_result);
+  BIND(&allocate_iterator_result);
   {
     Node* result = Allocate(JSIteratorResult::kSize);
     Node* map = LoadContextElement(LoadNativeContext(context),
@@ -2105,7 +2105,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
     Return(result);
   }
 
-  Bind(&throw_bad_receiver);
+  BIND(&throw_bad_receiver);
   {
     // The {receiver} is not a valid JSArrayIterator.
     CallRuntime(Runtime::kThrowIncompatibleMethodReceiver, context,
@@ -2113,7 +2113,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
     Unreachable();
   }
 
-  Bind(&if_isdetached);
+  BIND(&if_isdetached);
   {
     Node* message = SmiConstant(MessageTemplate::kDetachedOperation);
     CallRuntime(Runtime::kThrowTypeError, context, message,
diff --git a/src/builtins/builtins-async-function-gen.cc b/src/builtins/builtins-async-function-gen.cc
index 1530dbdf4ad..f661f7e82ed 100644
--- a/src/builtins/builtins-async-function-gen.cc
+++ b/src/builtins/builtins-async-function-gen.cc
@@ -169,7 +169,7 @@ TF_BUILTIN(AsyncFunctionPromiseCreate, AsyncFunctionBuiltinsAssembler) {
   // Early exit if debug is not active.
   Return(promise);
 
-  Bind(&if_is_debug_active);
+  BIND(&if_is_debug_active);
   {
     // Push the Promise under construction in an async function on
     // the catch prediction stack to handle exceptions thrown before
@@ -192,7 +192,7 @@ TF_BUILTIN(AsyncFunctionPromiseRelease, AsyncFunctionBuiltinsAssembler) {
   // Early exit if debug is not active.
   Return(UndefinedConstant());
 
-  Bind(&if_is_debug_active);
+  BIND(&if_is_debug_active);
   {
     // Pop the Promise under construction in an async function on
     // from catch prediction stack.
diff --git a/src/builtins/builtins-async-gen.cc b/src/builtins/builtins-async-gen.cc
index 46b76454eb6..1bb38b9355c 100644
--- a/src/builtins/builtins-async-gen.cc
+++ b/src/builtins/builtins-async-gen.cc
@@ -76,7 +76,7 @@ Node* AsyncBuiltinsAssembler::Await(
     }
 
     Goto(&common);
-    Bind(&common);
+    BIND(&common);
     // Mark the dependency to outer Promise in case the throwaway Promise is
     // found on the Promise stack
     CSA_SLOW_ASSERT(this, HasInstanceType(outer_promise, JS_PROMISE_TYPE));
@@ -87,7 +87,7 @@ Node* AsyncBuiltinsAssembler::Await(
   }
 
   Goto(&do_perform_promise_then);
-  Bind(&do_perform_promise_then);
+  BIND(&do_perform_promise_then);
   InternalPerformPromiseThen(context, wrapped_value, on_resolve, on_reject,
                              throwaway_promise, UndefinedConstant(),
                              UndefinedConstant());
diff --git a/src/builtins/builtins-async-generator-gen.cc b/src/builtins/builtins-async-generator-gen.cc
index 5315e12950c..f781f24ea40 100644
--- a/src/builtins/builtins-async-generator-gen.cc
+++ b/src/builtins/builtins-async-generator-gen.cc
@@ -153,7 +153,7 @@ void AsyncGeneratorBuiltinsAssembler::AsyncGeneratorEnqueue(
   Branch(HasInstanceType(generator, JS_ASYNC_GENERATOR_OBJECT_TYPE), &enqueue,
          &if_receiverisincompatible);
 
-  Bind(&enqueue);
+  BIND(&enqueue);
   {
     Label done(this);
     Node* const req =
@@ -174,11 +174,11 @@ void AsyncGeneratorBuiltinsAssembler::AsyncGeneratorEnqueue(
     CallBuiltin(Builtins::kAsyncGeneratorResumeNext, context, generator);
 
     Goto(&done);
-    Bind(&done);
+    BIND(&done);
     Return(promise);
   }
 
-  Bind(&if_receiverisincompatible);
+  BIND(&if_receiverisincompatible);
   {
     Node* const error =
         MakeTypeError(MessageTemplate::kIncompatibleMethodReceiver, context,
@@ -282,32 +282,32 @@ void AsyncGeneratorBuiltinsAssembler::AddAsyncGeneratorRequestToQueue(
       LoadObjectField(generator, JSAsyncGeneratorObject::kQueueOffset));
   Branch(IsUndefined(var_current.value()), &empty, &loop);
 
-  Bind(&empty);
+  BIND(&empty);
   {
     StoreObjectField(generator, JSAsyncGeneratorObject::kQueueOffset, request);
     Goto(&done);
   }
 
-  Bind(&loop);
+  BIND(&loop);
   {
     Label loop_next(this), next_empty(this);
     Node* current = var_current.value();
     Node* next = LoadObjectField(current, AsyncGeneratorRequest::kNextOffset);
 
     Branch(IsUndefined(next), &next_empty, &loop_next);
-    Bind(&next_empty);
+    BIND(&next_empty);
     {
       StoreObjectField(current, AsyncGeneratorRequest::kNextOffset, request);
       Goto(&done);
     }
 
-    Bind(&loop_next);
+    BIND(&loop_next);
     {
       var_current.Bind(next);
       Goto(&loop);
     }
   }
-  Bind(&done);
+  BIND(&done);
 }
 
 Node* AsyncGeneratorBuiltinsAssembler::TakeFirstAsyncGeneratorRequestFromQueue(
@@ -399,7 +399,7 @@ TF_BUILTIN(AsyncGeneratorRawYield, AsyncGeneratorBuiltinsAssembler) {
   var_done.Bind(LoadObjectField(iter_result, JSIteratorResult::kDoneOffset));
   Goto(&async_generator_resolve);
 
-  Bind(&if_slow);
+  BIND(&if_slow);
   {
     var_value.Bind(
         GetProperty(context, iter_result, factory()->value_string()));
@@ -413,7 +413,7 @@ TF_BUILTIN(AsyncGeneratorRawYield, AsyncGeneratorBuiltinsAssembler) {
     Goto(&async_generator_resolve);
   }
 
-  Bind(&async_generator_resolve);
+  BIND(&async_generator_resolve);
   Node* const value = var_value.value();
   Node* const done = var_done.value();
   CallBuiltin(Builtins::kAsyncGeneratorResolve, context, generator, value,
@@ -465,7 +465,7 @@ TF_BUILTIN(AsyncGeneratorResumeNext, AsyncGeneratorBuiltinsAssembler) {
   Variable* labels[] = {&var_state, &var_next};
   Label start(this, 2, labels);
   Goto(&start);
-  Bind(&start);
+  BIND(&start);
 
   CSA_ASSERT(this, IsGeneratorNotExecuting(generator));
 
@@ -480,7 +480,7 @@ TF_BUILTIN(AsyncGeneratorResumeNext, AsyncGeneratorBuiltinsAssembler) {
 
   Label if_abrupt(this), if_normal(this), resume_generator(this);
   Branch(IsAbruptResumeType(resume_type), &if_abrupt, &if_normal);
-  Bind(&if_abrupt);
+  BIND(&if_abrupt);
   {
     Label settle_promise(this), fulfill_promise(this), reject_promise(this);
     GotoIfNot(IsGeneratorStateSuspendedAtStart(var_state.value()),
@@ -489,27 +489,27 @@ TF_BUILTIN(AsyncGeneratorResumeNext, AsyncGeneratorBuiltinsAssembler) {
     var_state.Bind(SmiConstant(JSGeneratorObject::kGeneratorClosed));
 
     Goto(&settle_promise);
-    Bind(&settle_promise);
+    BIND(&settle_promise);
 
     GotoIfNot(IsGeneratorStateClosed(var_state.value()), &resume_generator);
 
     Branch(SmiEqual(resume_type, SmiConstant(JSGeneratorObject::kReturn)),
            &fulfill_promise, &reject_promise);
 
-    Bind(&fulfill_promise);
+    BIND(&fulfill_promise);
     CallBuiltin(Builtins::kAsyncGeneratorResolve, context, generator,
                 LoadValueFromAsyncGeneratorRequest(next), TrueConstant());
     var_next.Bind(LoadFirstAsyncGeneratorRequestFromQueue(generator));
     Goto(&start);
 
-    Bind(&reject_promise);
+    BIND(&reject_promise);
     CallBuiltin(Builtins::kAsyncGeneratorReject, context, generator,
                 LoadValueFromAsyncGeneratorRequest(next));
     var_next.Bind(LoadFirstAsyncGeneratorRequestFromQueue(generator));
     Goto(&start);
   }
 
-  Bind(&if_normal);
+  BIND(&if_normal);
   {
     GotoIfNot(IsGeneratorStateClosed(var_state.value()), &resume_generator);
     CallBuiltin(Builtins::kAsyncGeneratorResolve, context, generator,
@@ -519,7 +519,7 @@ TF_BUILTIN(AsyncGeneratorResumeNext, AsyncGeneratorBuiltinsAssembler) {
     Goto(&start);
   }
 
-  Bind(&resume_generator);
+  BIND(&resume_generator);
   {
     CallStub(CodeFactory::ResumeGenerator(isolate()), context,
              LoadValueFromAsyncGeneratorRequest(next), generator, resume_type,
diff --git a/src/builtins/builtins-async-iterator-gen.cc b/src/builtins/builtins-async-iterator-gen.cc
index 28a0bb30428..3c9b117917d 100644
--- a/src/builtins/builtins-async-iterator-gen.cc
+++ b/src/builtins/builtins-async-iterator-gen.cc
@@ -58,7 +58,7 @@ void AsyncFromSyncBuiltinsAssembler::ThrowIfNotAsyncFromSyncIterator(
   Branch(HasInstanceType(object, JS_ASYNC_FROM_SYNC_ITERATOR_TYPE), &done,
          &if_receiverisincompatible);
 
-  Bind(&if_receiverisincompatible);
+  BIND(&if_receiverisincompatible);
   {
     // If Type(O) is not Object, or if O does not have a [[SyncIterator]]
     // internal slot, then
@@ -74,7 +74,7 @@ void AsyncFromSyncBuiltinsAssembler::ThrowIfNotAsyncFromSyncIterator(
     Goto(if_exception);
   }
 
-  Bind(&done);
+  BIND(&done);
 }
 
 void AsyncFromSyncBuiltinsAssembler::Generate_AsyncFromSyncIteratorMethod(
@@ -105,7 +105,7 @@ void AsyncFromSyncBuiltinsAssembler::Generate_AsyncFromSyncIteratorMethod(
     GotoIfNot(IsUndefined(method), &if_isnotundefined);
     if_method_undefined(native_context, promise, &reject_promise);
 
-    Bind(&if_isnotundefined);
+    BIND(&if_isnotundefined);
   }
 
   Node* const iter_result = CallJS(CodeFactory::Call(isolate()), context,
@@ -134,7 +134,7 @@ void AsyncFromSyncBuiltinsAssembler::Generate_AsyncFromSyncIteratorMethod(
                              undefined, undefined);
   Return(promise);
 
-  Bind(&reject_promise);
+  BIND(&reject_promise);
   {
     Node* const exception = var_exception.value();
     InternalPromiseReject(context, promise, exception, TrueConstant());
@@ -161,7 +161,7 @@ std::pair<Node*, Node*> AsyncFromSyncBuiltinsAssembler::LoadIteratorResult(
   Branch(WordEqual(iter_result_map, fast_iter_result_map), &if_fastpath,
          &if_slowpath);
 
-  Bind(&if_fastpath);
+  BIND(&if_fastpath);
   {
     var_value.Bind(
         LoadObjectField(iter_result, JSIteratorResult::kValueOffset));
@@ -169,7 +169,7 @@ std::pair<Node*, Node*> AsyncFromSyncBuiltinsAssembler::LoadIteratorResult(
     Goto(&merge);
   }
 
-  Bind(&if_slowpath);
+  BIND(&if_slowpath);
   {
     // Let nextValue be IteratorValue(nextResult).
     // IfAbruptRejectPromise(nextValue, promiseCapability).
@@ -188,7 +188,7 @@ std::pair<Node*, Node*> AsyncFromSyncBuiltinsAssembler::LoadIteratorResult(
     Goto(&merge);
   }
 
-  Bind(&if_notanobject);
+  BIND(&if_notanobject);
   {
     // Sync iterator result is not an object --- Produce a TypeError and jump
     // to the `if_exception` path.
@@ -198,12 +198,12 @@ std::pair<Node*, Node*> AsyncFromSyncBuiltinsAssembler::LoadIteratorResult(
     Goto(if_exception);
   }
 
-  Bind(&merge);
+  BIND(&merge);
   // Ensure `iterResult.done` is a Boolean.
   GotoIf(TaggedIsSmi(var_done.value()), &to_boolean);
   Branch(IsBoolean(var_done.value()), &done, &to_boolean);
 
-  Bind(&to_boolean);
+  BIND(&to_boolean);
   {
     Node* const result =
         CallStub(CodeFactory::ToBoolean(isolate()), context, var_done.value());
@@ -211,7 +211,7 @@ std::pair<Node*, Node*> AsyncFromSyncBuiltinsAssembler::LoadIteratorResult(
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return std::make_pair(var_value.value(), var_done.value());
 }
 }  // namespace
diff --git a/src/builtins/builtins-constructor-gen.cc b/src/builtins/builtins-constructor-gen.cc
index 71388053b01..d31b3b28a7e 100644
--- a/src/builtins/builtins-constructor-gen.cc
+++ b/src/builtins/builtins-constructor-gen.cc
@@ -77,7 +77,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewClosure(Node* shared_info,
   }
   Goto(&if_function_without_prototype);
 
-  Bind(&if_normal);
+  BIND(&if_normal);
   {
     map_index.Bind(SelectIntPtrConstant(is_strict,
                                         Context::STRICT_FUNCTION_MAP_INDEX,
@@ -85,7 +85,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewClosure(Node* shared_info,
     Goto(&load_map);
   }
 
-  Bind(&if_generator);
+  BIND(&if_generator);
   {
     Node* is_async =
         Word32And(compiler_hints,
@@ -97,26 +97,26 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewClosure(Node* shared_info,
     Goto(&load_map);
   }
 
-  Bind(&if_async);
+  BIND(&if_async);
   {
     map_index.Bind(IntPtrConstant(Context::ASYNC_FUNCTION_MAP_INDEX));
     Goto(&load_map);
   }
 
-  Bind(&if_class_constructor);
+  BIND(&if_class_constructor);
   {
     map_index.Bind(IntPtrConstant(Context::CLASS_FUNCTION_MAP_INDEX));
     Goto(&load_map);
   }
 
-  Bind(&if_function_without_prototype);
+  BIND(&if_function_without_prototype);
   {
     map_index.Bind(
         IntPtrConstant(Context::STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX));
     Goto(&load_map);
   }
 
-  Bind(&load_map);
+  BIND(&load_map);
 
   // Get the function map in the current native context and set that
   // as the map of the allocated object.
@@ -143,15 +143,15 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewClosure(Node* shared_info,
     CSA_ASSERT(this, IsManyClosuresCellMap(cell_map));
     Goto(&cell_done);
 
-    Bind(&no_closures);
+    BIND(&no_closures);
     StoreMapNoWriteBarrier(literals_cell, Heap::kOneClosureCellMapRootIndex);
     Goto(&cell_done);
 
-    Bind(&one_closure);
+    BIND(&one_closure);
     StoreMapNoWriteBarrier(literals_cell, Heap::kManyClosuresCellMapRootIndex);
     Goto(&cell_done);
 
-    Bind(&cell_done);
+    BIND(&cell_done);
   }
   StoreObjectFieldNoWriteBarrier(result, JSFunction::kFeedbackVectorOffset,
                                  literals_cell);
@@ -193,7 +193,7 @@ TF_BUILTIN(FastNewObject, ConstructorBuiltinsAssembler) {
   Node* result = EmitFastNewObject(context, target, new_target, &call_runtime);
   Return(result);
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   TailCallRuntime(Runtime::kNewObject, context, target, new_target);
 }
 
@@ -207,11 +207,11 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewObject(Node* context,
   var_obj.Bind(result);
   Goto(&end);
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   var_obj.Bind(CallRuntime(Runtime::kNewObject, context, target, new_target));
   Goto(&end);
 
-  Bind(&end);
+  BIND(&end);
   return var_obj.value();
 }
 
@@ -227,7 +227,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewObject(Node* context,
   GotoIf(HasInstanceType(new_target, JS_FUNCTION_TYPE), &fast);
   Goto(call_runtime);
 
-  Bind(&fast);
+  BIND(&fast);
 
   // Load the initial map and verify that it's in fact a map.
   Node* initial_map =
@@ -249,13 +249,13 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewObject(Node* context,
     properties.Bind(EmptyFixedArrayConstant());
     Goto(&instantiate_map);
   }
-  Bind(&allocate_properties);
+  BIND(&allocate_properties);
   {
     properties.Bind(AllocateNameDictionary(NameDictionary::kInitialCapacity));
     Goto(&instantiate_map);
   }
 
-  Bind(&instantiate_map);
+  BIND(&instantiate_map);
 
   Node* object = AllocateJSObjectFromMap(initial_map, properties.value());
 
@@ -278,7 +278,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewObject(Node* context,
   }
 
   {
-    Bind(&slack_tracking);
+    BIND(&slack_tracking);
 
     // Decrease generous allocation count.
     STATIC_ASSERT(Map::ConstructionCounter::kNext == 32);
@@ -308,7 +308,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewObject(Node* context,
 
   {
     // Finalize the instance size.
-    Bind(&finalize);
+    BIND(&finalize);
 
     Node* unused_fields = LoadObjectField(
         initial_map, Map::kUnusedPropertyFieldsOffset, MachineType::Uint8());
@@ -328,7 +328,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastNewObject(Node* context,
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return object;
 }
 
@@ -428,14 +428,14 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneRegExp(Node* closure,
     Goto(&end);
   }
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     result.Bind(CallRuntime(Runtime::kCreateRegExpLiteral, context, closure,
                             literal_index, pattern, flags));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return result.value();
 }
 
@@ -519,7 +519,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowArray(
       Branch(IsFixedDoubleArrayMap(elements_map), &correct_elements_map,
              &abort);
 
-      Bind(&abort);
+      BIND(&abort);
       {
         Node* abort_id = SmiConstant(
             Smi::FromInt(BailoutReason::kExpectedFixedDoubleArrayMap));
@@ -527,7 +527,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowArray(
         result.Bind(UndefinedConstant());
         Goto(&return_result);
       }
-      Bind(&correct_elements_map);
+      BIND(&correct_elements_map);
     }
 
     Node* array =
@@ -537,7 +537,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowArray(
     Goto(&return_result);
   }
 
-  Bind(&fast_elements);
+  BIND(&fast_elements);
   {
     Comment("fast elements path");
     Node* array =
@@ -551,7 +551,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowArray(
       elements(this, MachineRepresentation::kTagged);
   Label allocate_without_elements(this);
 
-  Bind(&cow_elements);
+  BIND(&cow_elements);
   {
     Comment("fixed cow path");
     length.Bind(LoadJSArrayLength(boilerplate));
@@ -560,7 +560,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowArray(
     Goto(&allocate_without_elements);
   }
 
-  Bind(&zero_capacity);
+  BIND(&zero_capacity);
   {
     Comment("zero capacity path");
     length.Bind(zero);
@@ -569,7 +569,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowArray(
     Goto(&allocate_without_elements);
   }
 
-  Bind(&allocate_without_elements);
+  BIND(&allocate_without_elements);
   {
     Node* array = AllocateUninitializedJSArrayWithoutElements(
         FAST_ELEMENTS, boilerplate_map, length.value(), allocation_site);
@@ -578,7 +578,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowArray(
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   return result.value();
 }
 
@@ -594,7 +594,7 @@ void ConstructorBuiltinsAssembler::CreateFastCloneShallowArrayBuiltin(
   Return(EmitFastCloneShallowArray(closure, literal_index, context,
                                    &call_runtime, allocation_site_mode));
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     Comment("call runtime");
     Node* flags =
@@ -648,7 +648,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowObject(
   Label loop_body(this, &offset), loop_check(this, &offset);
   // We should always have an object size greater than zero.
   Goto(&loop_body);
-  Bind(&loop_body);
+  BIND(&loop_body);
   {
     // The Allocate above guarantees that the copy lies in new space. This
     // allows us to skip write barriers. This is necessary since we may also be
@@ -658,7 +658,7 @@ Node* ConstructorBuiltinsAssembler::EmitFastCloneShallowObject(
                         offset.value(), field);
     Goto(&loop_check);
   }
-  Bind(&loop_check);
+  BIND(&loop_check);
   {
     offset.Bind(IntPtrAdd(offset.value(), IntPtrConstant(kPointerSize)));
     GotoIfNot(IntPtrGreaterThanOrEqual(offset.value(), end_offset), &loop_body);
@@ -699,7 +699,7 @@ void ConstructorBuiltinsAssembler::CreateFastCloneShallowObjectBuiltin(
       &call_runtime, closure, literals_index, properties_count_node);
   Return(copy);
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   Node* constant_properties = Parameter(Descriptor::kConstantProperties);
   Node* flags = Parameter(Descriptor::kFlags);
   Node* context = Parameter(Descriptor::kContext);
diff --git a/src/builtins/builtins-conversion-gen.cc b/src/builtins/builtins-conversion-gen.cc
index ae5edf8301c..96d2e69e035 100644
--- a/src/builtins/builtins-conversion-gen.cc
+++ b/src/builtins/builtins-conversion-gen.cc
@@ -55,13 +55,13 @@ void ConversionBuiltinsAssembler::Generate_NonPrimitiveToPrimitive(
                                 Int32Constant(LAST_PRIMITIVE_TYPE)),
            &if_resultisprimitive, &if_resultisnotprimitive);
 
-    Bind(&if_resultisprimitive);
+    BIND(&if_resultisprimitive);
     {
       // Just return the {result}.
       Return(result);
     }
 
-    Bind(&if_resultisnotprimitive);
+    BIND(&if_resultisnotprimitive);
     {
       // Somehow the @@toPrimitive method on {input} didn't yield a primitive.
       TailCallRuntime(Runtime::kThrowCannotConvertToPrimitive, context);
@@ -69,7 +69,7 @@ void ConversionBuiltinsAssembler::Generate_NonPrimitiveToPrimitive(
   }
 
   // Convert using the OrdinaryToPrimitive algorithm instead.
-  Bind(&ordinary_to_primitive);
+  BIND(&ordinary_to_primitive);
   {
     Callable callable = CodeFactory::OrdinaryToPrimitive(
         isolate(), (hint == ToPrimitiveHint::kString)
@@ -147,20 +147,20 @@ TF_BUILTIN(ToString, CodeStubAssembler) {
 
   Label not_heap_number(this);
 
-  Bind(&not_string);
+  BIND(&not_string);
   { Branch(IsHeapNumberMap(input_map), &is_number, &not_heap_number); }
 
-  Bind(&is_number);
+  BIND(&is_number);
   { Return(NumberToString(context, input)); }
 
-  Bind(&not_heap_number);
+  BIND(&not_heap_number);
   {
     GotoIf(Word32NotEqual(input_instance_type, Int32Constant(ODDBALL_TYPE)),
            &runtime);
     Return(LoadObjectField(input, Oddball::kToStringOffset));
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   { Return(CallRuntime(Runtime::kToString, context, input)); }
 }
 
@@ -193,7 +193,7 @@ void ConversionBuiltinsAssembler::Generate_OrdinaryToPrimitive(
     Branch(IsCallableMap(method_map), &if_methodiscallable,
            &if_methodisnotcallable);
 
-    Bind(&if_methodiscallable);
+    BIND(&if_methodiscallable);
     {
       // Call the {method} on the {input}.
       Callable callable = CodeFactory::Call(
@@ -212,12 +212,12 @@ void ConversionBuiltinsAssembler::Generate_OrdinaryToPrimitive(
 
     // Just continue with the next {name} if the {method} is not callable.
     Goto(&if_methodisnotcallable);
-    Bind(&if_methodisnotcallable);
+    BIND(&if_methodisnotcallable);
   }
 
   TailCallRuntime(Runtime::kThrowCannotConvertToPrimitive, context);
 
-  Bind(&return_result);
+  BIND(&return_result);
   Return(var_result.value());
 }
 
@@ -242,10 +242,10 @@ TF_BUILTIN(ToBoolean, CodeStubAssembler) {
   Label return_true(this), return_false(this);
   BranchIfToBooleanIsTrue(value, &return_true, &return_false);
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 }
 
@@ -257,7 +257,7 @@ TF_BUILTIN(ToLength, CodeStubAssembler) {
                    Parameter(Descriptor::kArgument));
   Label loop(this, &var_len);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Shared entry points.
     Label return_len(this), return_two53minus1(this, Label::kDeferred),
@@ -278,7 +278,7 @@ TF_BUILTIN(ToLength, CodeStubAssembler) {
     Branch(IsHeapNumberMap(LoadMap(len)), &if_lenisheapnumber,
            &if_lenisnotheapnumber);
 
-    Bind(&if_lenisheapnumber);
+    BIND(&if_lenisheapnumber);
     {
       // Load the floating-point value of {len}.
       Node* len_value = LoadHeapNumberValue(len);
@@ -298,7 +298,7 @@ TF_BUILTIN(ToLength, CodeStubAssembler) {
       Return(result);
     }
 
-    Bind(&if_lenisnotheapnumber);
+    BIND(&if_lenisnotheapnumber);
     {
       // Need to convert {len} to a Number first.
       Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -306,13 +306,13 @@ TF_BUILTIN(ToLength, CodeStubAssembler) {
       Goto(&loop);
     }
 
-    Bind(&return_len);
+    BIND(&return_len);
     Return(var_len.value());
 
-    Bind(&return_two53minus1);
+    BIND(&return_two53minus1);
     Return(NumberConstant(kMaxSafeInteger));
 
-    Bind(&return_zero);
+    BIND(&return_zero);
     Return(SmiConstant(Smi::kZero));
   }
 }
@@ -337,7 +337,7 @@ TF_BUILTIN(ToObject, CodeStubAssembler) {
 
   Branch(TaggedIsSmi(object), &if_number, &if_notsmi);
 
-  Bind(&if_notsmi);
+  BIND(&if_notsmi);
   Node* map = LoadMap(object);
 
   GotoIf(IsHeapNumberMap(map), &if_number);
@@ -352,12 +352,12 @@ TF_BUILTIN(ToObject, CodeStubAssembler) {
   constructor_function_index_var.Bind(constructor_function_index);
   Goto(&if_wrapjsvalue);
 
-  Bind(&if_number);
+  BIND(&if_number);
   constructor_function_index_var.Bind(
       IntPtrConstant(Context::NUMBER_FUNCTION_INDEX));
   Goto(&if_wrapjsvalue);
 
-  Bind(&if_wrapjsvalue);
+  BIND(&if_wrapjsvalue);
   Node* native_context = LoadNativeContext(context);
   Node* constructor = LoadFixedArrayElement(
       native_context, constructor_function_index_var.value());
@@ -372,12 +372,12 @@ TF_BUILTIN(ToObject, CodeStubAssembler) {
   StoreObjectField(js_value, JSValue::kValueOffset, object);
   Return(js_value);
 
-  Bind(&if_noconstructor);
+  BIND(&if_noconstructor);
   TailCallRuntime(
       Runtime::kThrowUndefinedOrNullToObject, context,
       HeapConstant(factory()->NewStringFromAsciiChecked("ToObject", TENURED)));
 
-  Bind(&if_jsreceiver);
+  BIND(&if_jsreceiver);
   Return(object);
 }
 
diff --git a/src/builtins/builtins-date-gen.cc b/src/builtins/builtins-date-gen.cc
index c40ff612b06..10bb39f8613 100644
--- a/src/builtins/builtins-date-gen.cc
+++ b/src/builtins/builtins-date-gen.cc
@@ -47,7 +47,7 @@ void DateBuiltinsAssembler::Generate_DatePrototype_GetField(Node* context,
       Return(LoadObjectField(
           receiver, JSDate::kValueOffset + field_index * kPointerSize));
 
-      Bind(&stamp_mismatch);
+      BIND(&stamp_mismatch);
     }
 
     Node* field_index_smi = SmiConstant(Smi::FromInt(field_index));
@@ -60,7 +60,7 @@ void DateBuiltinsAssembler::Generate_DatePrototype_GetField(Node* context,
   }
 
   // Raise a TypeError if the receiver is not a date.
-  Bind(&receiver_not_date);
+  BIND(&receiver_not_date);
   {
     CallRuntime(Runtime::kThrowNotDateError, context);
     Unreachable();
@@ -219,7 +219,7 @@ TF_BUILTIN(DatePrototypeToPrimitive, CodeStubAssembler) {
   Goto(&hint_is_invalid);
 
   // Use the OrdinaryToPrimitive builtin to convert to a Number.
-  Bind(&hint_is_number);
+  BIND(&hint_is_number);
   {
     Callable callable = CodeFactory::OrdinaryToPrimitive(
         isolate(), OrdinaryToPrimitiveHint::kNumber);
@@ -228,7 +228,7 @@ TF_BUILTIN(DatePrototypeToPrimitive, CodeStubAssembler) {
   }
 
   // Use the OrdinaryToPrimitive builtin to convert to a String.
-  Bind(&hint_is_string);
+  BIND(&hint_is_string);
   {
     Callable callable = CodeFactory::OrdinaryToPrimitive(
         isolate(), OrdinaryToPrimitiveHint::kString);
@@ -237,14 +237,14 @@ TF_BUILTIN(DatePrototypeToPrimitive, CodeStubAssembler) {
   }
 
   // Raise a TypeError if the {hint} is invalid.
-  Bind(&hint_is_invalid);
+  BIND(&hint_is_invalid);
   {
     CallRuntime(Runtime::kThrowInvalidHint, context, hint);
     Unreachable();
   }
 
   // Raise a TypeError if the {receiver} is not a JSReceiver instance.
-  Bind(&receiver_is_invalid);
+  BIND(&receiver_is_invalid);
   {
     CallRuntime(Runtime::kThrowIncompatibleMethodReceiver, context,
                 HeapConstant(factory()->NewStringFromAsciiChecked(
diff --git a/src/builtins/builtins-forin-gen.cc b/src/builtins/builtins-forin-gen.cc
index 0f428b68c04..9b1e0b2a66d 100644
--- a/src/builtins/builtins-forin-gen.cc
+++ b/src/builtins/builtins-forin-gen.cc
@@ -34,7 +34,7 @@ Node* ForInBuiltinsAssembler::ForInFilter(Node* key, Node* object,
   var_result.Bind(UndefinedConstant());
   Goto(&end);
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -46,7 +46,7 @@ std::tuple<Node*, Node*, Node*> ForInBuiltinsAssembler::EmitForInPrepare(
 
   CheckEnumCache(object, &use_cache, nothing_to_iterate, call_runtime);
 
-  Bind(&use_cache);
+  BIND(&use_cache);
   Node* map = LoadMap(object);
   Node* enum_length = EnumLength(map);
   GotoIf(WordEqual(enum_length, SmiConstant(0)), nothing_to_iterate);
@@ -79,7 +79,7 @@ void ForInBuiltinsAssembler::CheckPrototypeEnumCache(Node* receiver, Node* map,
   Goto(&loop);
   // Check that there are no elements. |current_js_object| contains
   // the current JS object we've reached through the prototype chain.
-  Bind(&loop);
+  BIND(&loop);
   {
     Label if_elements(this), if_no_elements(this);
     Node* elements = LoadElements(current_js_object.value());
@@ -87,7 +87,7 @@ void ForInBuiltinsAssembler::CheckPrototypeEnumCache(Node* receiver, Node* map,
     // Check that there are no elements.
     Branch(WordEqual(elements, empty_fixed_array), &if_no_elements,
            &if_elements);
-    Bind(&if_elements);
+    BIND(&if_elements);
     {
       // Second chance, the object may be using the empty slow element
       // dictionary.
@@ -97,7 +97,7 @@ void ForInBuiltinsAssembler::CheckPrototypeEnumCache(Node* receiver, Node* map,
              &if_no_elements);
     }
 
-    Bind(&if_no_elements);
+    BIND(&if_no_elements);
     {
       // Update map prototype.
       current_js_object.Bind(LoadMapPrototype(current_map.value()));
@@ -106,7 +106,7 @@ void ForInBuiltinsAssembler::CheckPrototypeEnumCache(Node* receiver, Node* map,
     }
   }
 
-  Bind(&next);
+  BIND(&next);
   {
     // For all objects but the receiver, check that the cache is empty.
     current_map.Bind(LoadMap(current_js_object.value()));
@@ -136,11 +136,11 @@ void ForInBuiltinsAssembler::CheckEnumCache(Node* receiver, Label* use_cache,
 
   // Check that there are no elements on the fast |receiver| and its prototype
   // chain.
-  Bind(&check_empty_prototype);
+  BIND(&check_empty_prototype);
   CheckPrototypeEnumCache(receiver, map, use_cache, use_runtime);
 
   Label dict_loop(this);
-  Bind(&check_dict_receiver);
+  BIND(&check_dict_receiver);
   {
     // Avoid runtime-call for empty dictionary receivers.
     GotoIfNot(IsDictionaryMap(map), use_runtime);
@@ -176,7 +176,7 @@ TF_BUILTIN(ForInNext, ForInBuiltinsAssembler) {
   Node* map = LoadMap(object);
   GotoIfNot(WordEqual(map, cache_type), &filter);
   Return(key);
-  Bind(&filter);
+  BIND(&filter);
   Return(ForInFilter(key, object, context));
 }
 
@@ -193,10 +193,10 @@ TF_BUILTIN(ForInPrepare, ForInBuiltinsAssembler) {
 
   Return(cache_type, cache_array, cache_length);
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   TailCallRuntime(Runtime::kForInPrepare, context, object);
 
-  Bind(&nothing_to_iterate);
+  BIND(&nothing_to_iterate);
   {
     Node* zero = SmiConstant(0);
     Return(zero, zero, zero);
diff --git a/src/builtins/builtins-function-gen.cc b/src/builtins/builtins-function-gen.cc
index 9ff23930257..2d1f6ccbb1f 100644
--- a/src/builtins/builtins-function-gen.cc
+++ b/src/builtins/builtins-function-gen.cc
@@ -86,12 +86,12 @@ TF_BUILTIN(FastFunctionPrototypeBind, CodeStubAssembler) {
       native_context, Context::BOUND_FUNCTION_WITHOUT_CONSTRUCTOR_MAP_INDEX));
   Goto(&map_done);
 
-  Bind(&with_constructor);
+  BIND(&with_constructor);
   bound_function_map.Bind(LoadContextElement(
       native_context, Context::BOUND_FUNCTION_WITH_CONSTRUCTOR_MAP_INDEX));
   Goto(&map_done);
 
-  Bind(&map_done);
+  BIND(&map_done);
 
   // Verify that __proto__ matches that of a the target bound function.
   Comment("Verify that __proto__ matches target bound function");
@@ -119,11 +119,11 @@ TF_BUILTIN(FastFunctionPrototypeBind, CodeStubAssembler) {
   argument_array.Bind(elements);
   Goto(&arguments_done);
 
-  Bind(&empty_arguments);
+  BIND(&empty_arguments);
   argument_array.Bind(EmptyFixedArrayConstant());
   Goto(&arguments_done);
 
-  Bind(&arguments_done);
+  BIND(&arguments_done);
 
   // Determine bound receiver.
   Comment("Determine bound receiver");
@@ -134,11 +134,11 @@ TF_BUILTIN(FastFunctionPrototypeBind, CodeStubAssembler) {
   bound_receiver.Bind(UndefinedConstant());
   Goto(&receiver_done);
 
-  Bind(&has_receiver);
+  BIND(&has_receiver);
   bound_receiver.Bind(args.AtIndex(0));
   Goto(&receiver_done);
 
-  Bind(&receiver_done);
+  BIND(&receiver_done);
 
   // Allocate the resulting bound function.
   Comment("Allocate the resulting bound function");
@@ -159,7 +159,7 @@ TF_BUILTIN(FastFunctionPrototypeBind, CodeStubAssembler) {
                                  empty_fixed_array);
 
   args.PopAndReturn(bound_function);
-  Bind(&slow);
+  BIND(&slow);
 
   Node* target = LoadFromFrame(StandardFrameConstants::kFunctionOffset,
                                MachineType::TaggedPointer());
diff --git a/src/builtins/builtins-generator-gen.cc b/src/builtins/builtins-generator-gen.cc
index 912c136afd6..b011f1e5cd7 100644
--- a/src/builtins/builtins-generator-gen.cc
+++ b/src/builtins/builtins-generator-gen.cc
@@ -53,7 +53,7 @@ void GeneratorBuiltinsAssembler::GeneratorPrototypeResume(
                SmiConstant(static_cast<int>(SuspendFlags::kGeneratorYield)));
   Return(result);
 
-  Bind(&if_receiverisincompatible);
+  BIND(&if_receiverisincompatible);
   {
     // The {receiver} is not a valid JSGeneratorObject.
     CallRuntime(Runtime::kThrowIncompatibleMethodReceiver, context,
@@ -63,7 +63,7 @@ void GeneratorBuiltinsAssembler::GeneratorPrototypeResume(
     Unreachable();
   }
 
-  Bind(&if_receiverisclosed);
+  BIND(&if_receiverisclosed);
   {
     Callable create_iter_result_object =
         CodeFactory::CreateIterResultObject(isolate());
@@ -86,7 +86,7 @@ void GeneratorBuiltinsAssembler::GeneratorPrototypeResume(
     Return(result);
   }
 
-  Bind(&if_receiverisrunning);
+  BIND(&if_receiverisrunning);
   {
     CallRuntime(Runtime::kThrowGeneratorRunning, context);
     Unreachable();
diff --git a/src/builtins/builtins-global-gen.cc b/src/builtins/builtins-global-gen.cc
index c98b0540d7d..dfad5e49ed7 100644
--- a/src/builtins/builtins-global-gen.cc
+++ b/src/builtins/builtins-global-gen.cc
@@ -20,7 +20,7 @@ TF_BUILTIN(GlobalIsFinite, CodeStubAssembler) {
   Label loop(this, &var_num);
   var_num.Bind(Parameter(Descriptor::kNumber));
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* num = var_num.value();
 
@@ -33,7 +33,7 @@ TF_BUILTIN(GlobalIsFinite, CodeStubAssembler) {
     Branch(IsHeapNumberMap(LoadMap(num)), &if_numisheapnumber,
            &if_numisnotheapnumber);
 
-    Bind(&if_numisheapnumber);
+    BIND(&if_numisheapnumber);
     {
       // Check if {num} contains a finite, non-NaN value.
       Node* num_value = LoadHeapNumberValue(num);
@@ -41,7 +41,7 @@ TF_BUILTIN(GlobalIsFinite, CodeStubAssembler) {
                            &return_true);
     }
 
-    Bind(&if_numisnotheapnumber);
+    BIND(&if_numisnotheapnumber);
     {
       // Need to convert {num} to a Number first.
       Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -50,10 +50,10 @@ TF_BUILTIN(GlobalIsFinite, CodeStubAssembler) {
     }
   }
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 }
 
@@ -68,7 +68,7 @@ TF_BUILTIN(GlobalIsNaN, CodeStubAssembler) {
   Label loop(this, &var_num);
   var_num.Bind(Parameter(Descriptor::kNumber));
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* num = var_num.value();
 
@@ -81,14 +81,14 @@ TF_BUILTIN(GlobalIsNaN, CodeStubAssembler) {
     Branch(IsHeapNumberMap(LoadMap(num)), &if_numisheapnumber,
            &if_numisnotheapnumber);
 
-    Bind(&if_numisheapnumber);
+    BIND(&if_numisheapnumber);
     {
       // Check if {num} contains a NaN.
       Node* num_value = LoadHeapNumberValue(num);
       BranchIfFloat64IsNaN(num_value, &return_true, &return_false);
     }
 
-    Bind(&if_numisnotheapnumber);
+    BIND(&if_numisnotheapnumber);
     {
       // Need to convert {num} to a Number first.
       Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -97,10 +97,10 @@ TF_BUILTIN(GlobalIsNaN, CodeStubAssembler) {
     }
   }
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 }
 
diff --git a/src/builtins/builtins-handler-gen.cc b/src/builtins/builtins-handler-gen.cc
index 08146d66d59..31bf3af1155 100644
--- a/src/builtins/builtins-handler-gen.cc
+++ b/src/builtins/builtins-handler-gen.cc
@@ -30,7 +30,7 @@ TF_BUILTIN(KeyedLoadIC_IndexedString, CodeStubAssembler) {
   Node* result = StringFromCharCode(code);
   Return(result);
 
-  Bind(&miss);
+  BIND(&miss);
   TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, index, slot,
                   vector);
 }
@@ -142,10 +142,10 @@ TF_BUILTIN(LoadIC_FunctionPrototype, CodeStubAssembler) {
   var_result.Bind(LoadMapPrototype(proto_or_map));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
   Return(var_result.value());
 
-  Bind(&miss);
+  BIND(&miss);
   TailCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name, slot, vector);
 }
 
diff --git a/src/builtins/builtins-internal-gen.cc b/src/builtins/builtins-internal-gen.cc
index bc1efd5ad3f..a9a9fe3c6a0 100644
--- a/src/builtins/builtins-internal-gen.cc
+++ b/src/builtins/builtins-internal-gen.cc
@@ -42,7 +42,7 @@ TF_BUILTIN(CopyFastSmiOrObjectElements, CodeStubAssembler) {
                               mode),
          &if_newspace, &if_oldspace);
 
-  Bind(&if_newspace);
+  BIND(&if_newspace);
   {
     Node* target = AllocateFixedArray(kind, length, mode);
     CopyFixedArrayElements(kind, source, target, length, SKIP_WRITE_BARRIER,
@@ -51,7 +51,7 @@ TF_BUILTIN(CopyFastSmiOrObjectElements, CodeStubAssembler) {
     Return(target);
   }
 
-  Bind(&if_oldspace);
+  BIND(&if_oldspace);
   {
     Node* target = AllocateFixedArray(kind, length, mode, kPretenured);
     CopyFixedArrayElements(kind, source, target, length, UPDATE_WRITE_BARRIER,
@@ -72,7 +72,7 @@ TF_BUILTIN(GrowFastDoubleElements, CodeStubAssembler) {
                                      key, &runtime);
   Return(elements);
 
-  Bind(&runtime);
+  BIND(&runtime);
   TailCallRuntime(Runtime::kGrowArrayElements, context, object, key);
 }
 
@@ -87,7 +87,7 @@ TF_BUILTIN(GrowFastSmiOrObjectElements, CodeStubAssembler) {
       TryGrowElementsCapacity(object, elements, FAST_ELEMENTS, key, &runtime);
   Return(elements);
 
-  Bind(&runtime);
+  BIND(&runtime);
   TailCallRuntime(Runtime::kGrowArrayElements, context, object, key);
 }
 
@@ -102,7 +102,7 @@ TF_BUILTIN(NewUnmappedArgumentsElements, CodeStubAssembler) {
   Branch(IntPtrLessThan(length, IntPtrConstant(max_elements)), &if_newspace,
          &if_oldspace);
 
-  Bind(&if_newspace);
+  BIND(&if_newspace);
   {
     // Prefer EmptyFixedArray in case of non-positive {length} (the {length}
     // can be negative here for rest parameters).
@@ -110,10 +110,10 @@ TF_BUILTIN(NewUnmappedArgumentsElements, CodeStubAssembler) {
     Branch(IntPtrLessThanOrEqual(length, IntPtrConstant(0)), &if_empty,
            &if_notempty);
 
-    Bind(&if_empty);
+    BIND(&if_empty);
     Return(EmptyFixedArrayConstant());
 
-    Bind(&if_notempty);
+    BIND(&if_notempty);
     {
       // Allocate a FixedArray in new space.
       Node* result = AllocateFixedArray(kind, length);
@@ -126,7 +126,7 @@ TF_BUILTIN(NewUnmappedArgumentsElements, CodeStubAssembler) {
       Label loop(this, &var_index), done_loop(this);
       var_index.Bind(IntPtrConstant(0));
       Goto(&loop);
-      Bind(&loop);
+      BIND(&loop);
       {
         // Load the current {index}.
         Node* index = var_index.value();
@@ -147,12 +147,12 @@ TF_BUILTIN(NewUnmappedArgumentsElements, CodeStubAssembler) {
         Goto(&loop);
       }
 
-      Bind(&done_loop);
+      BIND(&done_loop);
       Return(result);
     }
   }
 
-  Bind(&if_oldspace);
+  BIND(&if_oldspace);
   {
     // Allocate in old space (or large object space).
     TailCallRuntime(Runtime::kNewArgumentsElements, NoContextConstant(),
diff --git a/src/builtins/builtins-math-gen.cc b/src/builtins/builtins-math-gen.cc
index 6210e20d84e..62ca5d58758 100644
--- a/src/builtins/builtins-math-gen.cc
+++ b/src/builtins/builtins-math-gen.cc
@@ -37,7 +37,7 @@ TF_BUILTIN(MathAbs, CodeStubAssembler) {
   Label loop(this, &var_x);
   var_x.Bind(Parameter(Descriptor::kX));
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {x} value.
     Node* x = var_x.value();
@@ -46,7 +46,7 @@ TF_BUILTIN(MathAbs, CodeStubAssembler) {
     Label if_xissmi(this), if_xisnotsmi(this);
     Branch(TaggedIsSmi(x), &if_xissmi, &if_xisnotsmi);
 
-    Bind(&if_xissmi);
+    BIND(&if_xissmi);
     {
       Label if_overflow(this, Label::kDeferred), if_notoverflow(this);
       Node* pair = NULL;
@@ -62,13 +62,13 @@ TF_BUILTIN(MathAbs, CodeStubAssembler) {
         BranchIfSmiLessThanOrEqual(SmiConstant(Smi::FromInt(0)), x,
                                    &if_xispositive, &if_xisnotpositive);
 
-        Bind(&if_xispositive);
+        BIND(&if_xispositive);
         {
           // Just return the input {x}.
           Return(x);
         }
 
-        Bind(&if_xisnotpositive);
+        BIND(&if_xisnotpositive);
         {
           // Try to negate the {x} value.
           pair =
@@ -78,25 +78,25 @@ TF_BUILTIN(MathAbs, CodeStubAssembler) {
         }
       }
 
-      Bind(&if_notoverflow);
+      BIND(&if_notoverflow);
       {
         // There is a Smi representation for negated {x}.
         Node* result = Projection(0, pair);
         Return(BitcastWordToTagged(result));
       }
 
-      Bind(&if_overflow);
+      BIND(&if_overflow);
       { Return(NumberConstant(0.0 - Smi::kMinValue)); }
     }
 
-    Bind(&if_xisnotsmi);
+    BIND(&if_xisnotsmi);
     {
       // Check if {x} is a HeapNumber.
       Label if_xisheapnumber(this), if_xisnotheapnumber(this, Label::kDeferred);
       Branch(IsHeapNumberMap(LoadMap(x)), &if_xisheapnumber,
              &if_xisnotheapnumber);
 
-      Bind(&if_xisheapnumber);
+      BIND(&if_xisheapnumber);
       {
         Node* x_value = LoadHeapNumberValue(x);
         Node* value = Float64Abs(x_value);
@@ -104,7 +104,7 @@ TF_BUILTIN(MathAbs, CodeStubAssembler) {
         Return(result);
       }
 
-      Bind(&if_xisnotheapnumber);
+      BIND(&if_xisnotheapnumber);
       {
         // Need to convert {x} to a Number first.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -121,7 +121,7 @@ void MathBuiltinsAssembler::MathRoundingOperation(
   Variable var_x(this, MachineRepresentation::kTagged, x);
   Label loop(this, &var_x);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {x} value.
     Node* x = var_x.value();
@@ -130,20 +130,20 @@ void MathBuiltinsAssembler::MathRoundingOperation(
     Label if_xissmi(this), if_xisnotsmi(this);
     Branch(TaggedIsSmi(x), &if_xissmi, &if_xisnotsmi);
 
-    Bind(&if_xissmi);
+    BIND(&if_xissmi);
     {
       // Nothing to do when {x} is a Smi.
       Return(x);
     }
 
-    Bind(&if_xisnotsmi);
+    BIND(&if_xisnotsmi);
     {
       // Check if {x} is a HeapNumber.
       Label if_xisheapnumber(this), if_xisnotheapnumber(this, Label::kDeferred);
       Branch(IsHeapNumberMap(LoadMap(x)), &if_xisheapnumber,
              &if_xisnotheapnumber);
 
-      Bind(&if_xisheapnumber);
+      BIND(&if_xisheapnumber);
       {
         Node* x_value = LoadHeapNumberValue(x);
         Node* value = (this->*float64op)(x_value);
@@ -151,7 +151,7 @@ void MathBuiltinsAssembler::MathRoundingOperation(
         Return(result);
       }
 
-      Bind(&if_xisnotheapnumber);
+      BIND(&if_xisnotheapnumber);
       {
         // Need to convert {x} to a Number first.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -270,7 +270,7 @@ TF_BUILTIN(MathClz32, CodeStubAssembler) {
   Label loop(this, &var_x);
   var_x.Bind(Parameter(Descriptor::kX));
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {x} value.
     Node* x = var_x.value();
@@ -279,26 +279,26 @@ TF_BUILTIN(MathClz32, CodeStubAssembler) {
     Label if_xissmi(this), if_xisnotsmi(this);
     Branch(TaggedIsSmi(x), &if_xissmi, &if_xisnotsmi);
 
-    Bind(&if_xissmi);
+    BIND(&if_xissmi);
     {
       var_clz32_x.Bind(SmiToWord32(x));
       Goto(&do_clz32);
     }
 
-    Bind(&if_xisnotsmi);
+    BIND(&if_xisnotsmi);
     {
       // Check if {x} is a HeapNumber.
       Label if_xisheapnumber(this), if_xisnotheapnumber(this, Label::kDeferred);
       Branch(IsHeapNumberMap(LoadMap(x)), &if_xisheapnumber,
              &if_xisnotheapnumber);
 
-      Bind(&if_xisheapnumber);
+      BIND(&if_xisheapnumber);
       {
         var_clz32_x.Bind(TruncateHeapNumberValueToWord32(x));
         Goto(&do_clz32);
       }
 
-      Bind(&if_xisnotheapnumber);
+      BIND(&if_xisnotheapnumber);
       {
         // Need to convert {x} to a Number first.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -308,7 +308,7 @@ TF_BUILTIN(MathClz32, CodeStubAssembler) {
     }
   }
 
-  Bind(&do_clz32);
+  BIND(&do_clz32);
   {
     Node* x_value = var_clz32_x.value();
     Node* value = Word32Clz(x_value);
@@ -434,7 +434,7 @@ TF_BUILTIN(MathRandom, CodeStubAssembler) {
   Goto(&if_cached);
 
   // Compute next index by decrement.
-  Bind(&if_cached);
+  BIND(&if_cached);
   Node* new_smi_index = SmiSub(smi_index.value(), SmiConstant(Smi::FromInt(1)));
   StoreContextElement(native_context, Context::MATH_RANDOM_INDEX_INDEX,
                       new_smi_index);
@@ -467,10 +467,10 @@ TF_BUILTIN(MathSign, CodeStubAssembler) {
   GotoIf(Float64LessThan(Float64Constant(0.0), x_value), &if_xispositive);
   Return(ChangeFloat64ToTagged(x_value));
 
-  Bind(&if_xisnegative);
+  BIND(&if_xisnegative);
   Return(SmiConstant(Smi::FromInt(-1)));
 
-  Bind(&if_xispositive);
+  BIND(&if_xispositive);
   Return(SmiConstant(Smi::FromInt(1)));
 }
 
diff --git a/src/builtins/builtins-number-gen.cc b/src/builtins/builtins-number-gen.cc
index 85f494e7c6d..ac3170612c9 100644
--- a/src/builtins/builtins-number-gen.cc
+++ b/src/builtins/builtins-number-gen.cc
@@ -72,10 +72,10 @@ TF_BUILTIN(NumberIsFinite, CodeStubAssembler) {
   BranchIfFloat64IsNaN(Float64Sub(number_value, number_value), &return_false,
                        &return_true);
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 }
 
@@ -101,10 +101,10 @@ TF_BUILTIN(NumberIsInteger, CodeStubAssembler) {
   Branch(Float64Equal(Float64Sub(number_value, integer), Float64Constant(0.0)),
          &return_true, &return_false);
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 }
 
@@ -124,10 +124,10 @@ TF_BUILTIN(NumberIsNaN, CodeStubAssembler) {
   Node* number_value = LoadHeapNumberValue(number);
   BranchIfFloat64IsNaN(number_value, &return_true, &return_false);
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 }
 
@@ -159,10 +159,10 @@ TF_BUILTIN(NumberIsSafeInteger, CodeStubAssembler) {
                                 Float64Constant(kMaxSafeInteger)),
          &return_true, &return_false);
 
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 }
 
@@ -175,7 +175,7 @@ TF_BUILTIN(NumberParseFloat, CodeStubAssembler) {
                      Parameter(Descriptor::kString));
   Label loop(this, &var_input);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {input} value.
     Node* input = var_input.value();
@@ -184,13 +184,13 @@ TF_BUILTIN(NumberParseFloat, CodeStubAssembler) {
     Label if_inputissmi(this), if_inputisnotsmi(this);
     Branch(TaggedIsSmi(input), &if_inputissmi, &if_inputisnotsmi);
 
-    Bind(&if_inputissmi);
+    BIND(&if_inputissmi);
     {
       // The {input} is already a Number, no need to do anything.
       Return(input);
     }
 
-    Bind(&if_inputisnotsmi);
+    BIND(&if_inputisnotsmi);
     {
       // The {input} is a HeapObject, check if it's already a String.
       Label if_inputisstring(this), if_inputisnotstring(this);
@@ -199,7 +199,7 @@ TF_BUILTIN(NumberParseFloat, CodeStubAssembler) {
       Branch(IsStringInstanceType(input_instance_type), &if_inputisstring,
              &if_inputisnotstring);
 
-      Bind(&if_inputisstring);
+      BIND(&if_inputisstring);
       {
         // The {input} is already a String, check if {input} contains
         // a cached array index.
@@ -210,7 +210,7 @@ TF_BUILTIN(NumberParseFloat, CodeStubAssembler) {
         Branch(Word32Equal(input_bit, Int32Constant(0)), &if_inputcached,
                &if_inputnotcached);
 
-        Bind(&if_inputcached);
+        BIND(&if_inputcached);
         {
           // Just return the {input}s cached array index.
           Node* input_array_index =
@@ -218,14 +218,14 @@ TF_BUILTIN(NumberParseFloat, CodeStubAssembler) {
           Return(SmiTag(input_array_index));
         }
 
-        Bind(&if_inputnotcached);
+        BIND(&if_inputnotcached);
         {
           // Need to fall back to the runtime to convert {input} to double.
           Return(CallRuntime(Runtime::kStringParseFloat, context, input));
         }
       }
 
-      Bind(&if_inputisnotstring);
+      BIND(&if_inputisnotstring);
       {
         // The {input} is neither a String nor a Smi, check for HeapNumber.
         Label if_inputisnumber(this),
@@ -233,7 +233,7 @@ TF_BUILTIN(NumberParseFloat, CodeStubAssembler) {
         Branch(IsHeapNumberMap(input_map), &if_inputisnumber,
                &if_inputisnotnumber);
 
-        Bind(&if_inputisnumber);
+        BIND(&if_inputisnumber);
         {
           // The {input} is already a Number, take care of -0.
           Label if_inputiszero(this), if_inputisnotzero(this);
@@ -241,14 +241,14 @@ TF_BUILTIN(NumberParseFloat, CodeStubAssembler) {
           Branch(Float64Equal(input_value, Float64Constant(0.0)),
                  &if_inputiszero, &if_inputisnotzero);
 
-          Bind(&if_inputiszero);
+          BIND(&if_inputiszero);
           Return(SmiConstant(0));
 
-          Bind(&if_inputisnotzero);
+          BIND(&if_inputisnotzero);
           Return(input);
         }
 
-        Bind(&if_inputisnotnumber);
+        BIND(&if_inputisnotnumber);
         {
           // Need to convert the {input} to String first.
           // TODO(bmeurer): This could be more efficient if necessary.
@@ -274,7 +274,7 @@ TF_BUILTIN(NumberParseInt, CodeStubAssembler) {
   GotoIf(WordEqual(radix, SmiConstant(Smi::FromInt(0))), &if_radix10);
   Goto(&if_generic);
 
-  Bind(&if_radix10);
+  BIND(&if_radix10);
   {
     // Check if we can avoid the ToString conversion on {input}.
     Label if_inputissmi(this), if_inputisheapnumber(this),
@@ -286,13 +286,13 @@ TF_BUILTIN(NumberParseInt, CodeStubAssembler) {
     Branch(IsStringInstanceType(input_instance_type), &if_inputisstring,
            &if_generic);
 
-    Bind(&if_inputissmi);
+    BIND(&if_inputissmi);
     {
       // Just return the {input}.
       Return(input);
     }
 
-    Bind(&if_inputisheapnumber);
+    BIND(&if_inputisheapnumber);
     {
       // Check if the {input} value is in Signed32 range.
       Label if_inputissigned32(this);
@@ -310,12 +310,12 @@ TF_BUILTIN(NumberParseInt, CodeStubAssembler) {
              &if_inputissigned32, &if_generic);
 
       // Return the truncated int32 value, and return the tagged result.
-      Bind(&if_inputissigned32);
+      BIND(&if_inputissigned32);
       Node* result = ChangeInt32ToTagged(input_value32);
       Return(result);
     }
 
-    Bind(&if_inputisstring);
+    BIND(&if_inputisstring);
     {
       // Check if the String {input} has a cached array index.
       Node* input_hash = LoadNameHashField(input);
@@ -331,7 +331,7 @@ TF_BUILTIN(NumberParseInt, CodeStubAssembler) {
     }
   }
 
-  Bind(&if_generic);
+  BIND(&if_generic);
   {
     Node* result = CallRuntime(Runtime::kStringParseInt, context, input, radix);
     Return(result);
@@ -370,7 +370,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
   var_lhs.Bind(left);
   var_rhs.Bind(right);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {lhs} and {rhs} values.
     Node* lhs = var_lhs.value();
@@ -380,13 +380,13 @@ TF_BUILTIN(Add, CodeStubAssembler) {
     Label if_lhsissmi(this), if_lhsisnotsmi(this);
     Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-    Bind(&if_lhsissmi);
+    BIND(&if_lhsissmi);
     {
       // Check if the {rhs} is also a Smi.
       Label if_rhsissmi(this), if_rhsisnotsmi(this);
       Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-      Bind(&if_rhsissmi);
+      BIND(&if_rhsissmi);
       {
         // Try fast Smi addition first.
         Node* pair = IntPtrAddWithOverflow(BitcastTaggedToWord(lhs),
@@ -397,19 +397,19 @@ TF_BUILTIN(Add, CodeStubAssembler) {
         Label if_overflow(this), if_notoverflow(this);
         Branch(overflow, &if_overflow, &if_notoverflow);
 
-        Bind(&if_overflow);
+        BIND(&if_overflow);
         {
           var_fadd_lhs.Bind(SmiToFloat64(lhs));
           var_fadd_rhs.Bind(SmiToFloat64(rhs));
           Goto(&do_fadd);
         }
 
-        Bind(&if_notoverflow);
+        BIND(&if_notoverflow);
         var_result.Bind(BitcastWordToTaggedSigned(Projection(0, pair)));
         Goto(&end);
       }
 
-      Bind(&if_rhsisnotsmi);
+      BIND(&if_rhsisnotsmi);
       {
         // Load the map of {rhs}.
         Node* rhs_map = LoadMap(rhs);
@@ -418,14 +418,14 @@ TF_BUILTIN(Add, CodeStubAssembler) {
         Label if_rhsisnumber(this), if_rhsisnotnumber(this, Label::kDeferred);
         Branch(IsHeapNumberMap(rhs_map), &if_rhsisnumber, &if_rhsisnotnumber);
 
-        Bind(&if_rhsisnumber);
+        BIND(&if_rhsisnumber);
         {
           var_fadd_lhs.Bind(SmiToFloat64(lhs));
           var_fadd_rhs.Bind(LoadHeapNumberValue(rhs));
           Goto(&do_fadd);
         }
 
-        Bind(&if_rhsisnotnumber);
+        BIND(&if_rhsisnotnumber);
         {
           // Load the instance type of {rhs}.
           Node* rhs_instance_type = LoadMapInstanceType(rhs_map);
@@ -436,14 +436,14 @@ TF_BUILTIN(Add, CodeStubAssembler) {
           Branch(IsStringInstanceType(rhs_instance_type), &if_rhsisstring,
                  &if_rhsisnotstring);
 
-          Bind(&if_rhsisstring);
+          BIND(&if_rhsisstring);
           {
             var_lhs.Bind(lhs);
             var_rhs.Bind(rhs);
             Goto(&string_add_convert_left);
           }
 
-          Bind(&if_rhsisnotstring);
+          BIND(&if_rhsisnotstring);
           {
             // Check if {rhs} is a JSReceiver.
             Label if_rhsisreceiver(this, Label::kDeferred),
@@ -451,7 +451,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
             Branch(IsJSReceiverInstanceType(rhs_instance_type),
                    &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-            Bind(&if_rhsisreceiver);
+            BIND(&if_rhsisreceiver);
             {
               // Convert {rhs} to a primitive first passing no hint.
               Callable callable =
@@ -460,7 +460,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
               Goto(&loop);
             }
 
-            Bind(&if_rhsisnotreceiver);
+            BIND(&if_rhsisnotreceiver);
             {
               // Convert {rhs} to a Number first.
               Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -472,7 +472,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
       }
     }
 
-    Bind(&if_lhsisnotsmi);
+    BIND(&if_lhsisnotsmi);
     {
       // Load the map and instance type of {lhs}.
       Node* lhs_instance_type = LoadInstanceType(lhs);
@@ -482,20 +482,20 @@ TF_BUILTIN(Add, CodeStubAssembler) {
       Branch(IsStringInstanceType(lhs_instance_type), &if_lhsisstring,
              &if_lhsisnotstring);
 
-      Bind(&if_lhsisstring);
+      BIND(&if_lhsisstring);
       {
         var_lhs.Bind(lhs);
         var_rhs.Bind(rhs);
         Goto(&string_add_convert_right);
       }
 
-      Bind(&if_lhsisnotstring);
+      BIND(&if_lhsisnotstring);
       {
         // Check if {rhs} is a Smi.
         Label if_rhsissmi(this), if_rhsisnotsmi(this);
         Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-        Bind(&if_rhsissmi);
+        BIND(&if_rhsissmi);
         {
           // Check if {lhs} is a Number.
           Label if_lhsisnumber(this), if_lhsisnotnumber(this, Label::kDeferred);
@@ -503,7 +503,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
               Word32Equal(lhs_instance_type, Int32Constant(HEAP_NUMBER_TYPE)),
               &if_lhsisnumber, &if_lhsisnotnumber);
 
-          Bind(&if_lhsisnumber);
+          BIND(&if_lhsisnumber);
           {
             // The {lhs} is a HeapNumber, the {rhs} is a Smi, just add them.
             var_fadd_lhs.Bind(LoadHeapNumberValue(lhs));
@@ -511,7 +511,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
             Goto(&do_fadd);
           }
 
-          Bind(&if_lhsisnotnumber);
+          BIND(&if_lhsisnotnumber);
           {
             // The {lhs} is neither a Number nor a String, and the {rhs} is a
             // Smi.
@@ -520,7 +520,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
             Branch(IsJSReceiverInstanceType(lhs_instance_type),
                    &if_lhsisreceiver, &if_lhsisnotreceiver);
 
-            Bind(&if_lhsisreceiver);
+            BIND(&if_lhsisreceiver);
             {
               // Convert {lhs} to a primitive first passing no hint.
               Callable callable =
@@ -529,7 +529,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
               Goto(&loop);
             }
 
-            Bind(&if_lhsisnotreceiver);
+            BIND(&if_lhsisnotreceiver);
             {
               // Convert {lhs} to a Number first.
               Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -539,7 +539,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
           }
         }
 
-        Bind(&if_rhsisnotsmi);
+        BIND(&if_rhsisnotsmi);
         {
           // Load the instance type of {rhs}.
           Node* rhs_instance_type = LoadInstanceType(rhs);
@@ -549,14 +549,14 @@ TF_BUILTIN(Add, CodeStubAssembler) {
           Branch(IsStringInstanceType(rhs_instance_type), &if_rhsisstring,
                  &if_rhsisnotstring);
 
-          Bind(&if_rhsisstring);
+          BIND(&if_rhsisstring);
           {
             var_lhs.Bind(lhs);
             var_rhs.Bind(rhs);
             Goto(&string_add_convert_left);
           }
 
-          Bind(&if_rhsisnotstring);
+          BIND(&if_rhsisnotstring);
           {
             // Check if {lhs} is a HeapNumber.
             Label if_lhsisnumber(this), if_lhsisnotnumber(this);
@@ -564,7 +564,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                 Word32Equal(lhs_instance_type, Int32Constant(HEAP_NUMBER_TYPE)),
                 &if_lhsisnumber, &if_lhsisnotnumber);
 
-            Bind(&if_lhsisnumber);
+            BIND(&if_lhsisnumber);
             {
               // Check if {rhs} is also a HeapNumber.
               Label if_rhsisnumber(this),
@@ -573,7 +573,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                                  Int32Constant(HEAP_NUMBER_TYPE)),
                      &if_rhsisnumber, &if_rhsisnotnumber);
 
-              Bind(&if_rhsisnumber);
+              BIND(&if_rhsisnumber);
               {
                 // Perform a floating point addition.
                 var_fadd_lhs.Bind(LoadHeapNumberValue(lhs));
@@ -581,7 +581,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                 Goto(&do_fadd);
               }
 
-              Bind(&if_rhsisnotnumber);
+              BIND(&if_rhsisnotnumber);
               {
                 // Check if {rhs} is a JSReceiver.
                 Label if_rhsisreceiver(this, Label::kDeferred),
@@ -589,7 +589,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                 Branch(IsJSReceiverInstanceType(rhs_instance_type),
                        &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-                Bind(&if_rhsisreceiver);
+                BIND(&if_rhsisreceiver);
                 {
                   // Convert {rhs} to a primitive first passing no hint.
                   Callable callable =
@@ -598,7 +598,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                   Goto(&loop);
                 }
 
-                Bind(&if_rhsisnotreceiver);
+                BIND(&if_rhsisnotreceiver);
                 {
                   // Convert {rhs} to a Number first.
                   Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -608,7 +608,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
               }
             }
 
-            Bind(&if_lhsisnotnumber);
+            BIND(&if_lhsisnotnumber);
             {
               // Check if {lhs} is a JSReceiver.
               Label if_lhsisreceiver(this, Label::kDeferred),
@@ -616,7 +616,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
               Branch(IsJSReceiverInstanceType(lhs_instance_type),
                      &if_lhsisreceiver, &if_lhsisnotreceiver);
 
-              Bind(&if_lhsisreceiver);
+              BIND(&if_lhsisreceiver);
               {
                 // Convert {lhs} to a primitive first passing no hint.
                 Callable callable =
@@ -625,7 +625,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                 Goto(&loop);
               }
 
-              Bind(&if_lhsisnotreceiver);
+              BIND(&if_lhsisnotreceiver);
               {
                 // Check if {rhs} is a JSReceiver.
                 Label if_rhsisreceiver(this, Label::kDeferred),
@@ -633,7 +633,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                 Branch(IsJSReceiverInstanceType(rhs_instance_type),
                        &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-                Bind(&if_rhsisreceiver);
+                BIND(&if_rhsisreceiver);
                 {
                   // Convert {rhs} to a primitive first passing no hint.
                   Callable callable =
@@ -642,7 +642,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
                   Goto(&loop);
                 }
 
-                Bind(&if_rhsisnotreceiver);
+                BIND(&if_rhsisnotreceiver);
                 {
                   // Convert {lhs} to a Number first.
                   Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -656,7 +656,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
       }
     }
   }
-  Bind(&string_add_convert_left);
+  BIND(&string_add_convert_left);
   {
     // Convert {lhs}, which is a Smi, to a String and concatenate the
     // resulting string with the String {rhs}.
@@ -667,7 +667,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
     Goto(&end);
   }
 
-  Bind(&string_add_convert_right);
+  BIND(&string_add_convert_right);
   {
     // Convert {lhs}, which is a Smi, to a String and concatenate the
     // resulting string with the String {rhs}.
@@ -678,7 +678,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
     Goto(&end);
   }
 
-  Bind(&do_fadd);
+  BIND(&do_fadd);
   {
     Node* lhs_value = var_fadd_lhs.value();
     Node* rhs_value = var_fadd_rhs.value();
@@ -687,7 +687,7 @@ TF_BUILTIN(Add, CodeStubAssembler) {
     var_result.Bind(result);
     Goto(&end);
   }
-  Bind(&end);
+  BIND(&end);
   Return(var_result.value());
 }
 
@@ -711,7 +711,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
   var_lhs.Bind(left);
   var_rhs.Bind(right);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {lhs} and {rhs} values.
     Node* lhs = var_lhs.value();
@@ -721,13 +721,13 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
     Label if_lhsissmi(this), if_lhsisnotsmi(this);
     Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-    Bind(&if_lhsissmi);
+    BIND(&if_lhsissmi);
     {
       // Check if the {rhs} is also a Smi.
       Label if_rhsissmi(this), if_rhsisnotsmi(this);
       Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-      Bind(&if_rhsissmi);
+      BIND(&if_rhsissmi);
       {
         // Try a fast Smi subtraction first.
         Node* pair = IntPtrSubWithOverflow(BitcastTaggedToWord(lhs),
@@ -738,7 +738,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
         Label if_overflow(this), if_notoverflow(this);
         Branch(overflow, &if_overflow, &if_notoverflow);
 
-        Bind(&if_overflow);
+        BIND(&if_overflow);
         {
           // The result doesn't fit into Smi range.
           var_fsub_lhs.Bind(SmiToFloat64(lhs));
@@ -746,12 +746,12 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
           Goto(&do_fsub);
         }
 
-        Bind(&if_notoverflow);
+        BIND(&if_notoverflow);
         var_result.Bind(BitcastWordToTaggedSigned(Projection(0, pair)));
         Goto(&end);
       }
 
-      Bind(&if_rhsisnotsmi);
+      BIND(&if_rhsisnotsmi);
       {
         // Load the map of the {rhs}.
         Node* rhs_map = LoadMap(rhs);
@@ -760,7 +760,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
         Label if_rhsisnumber(this), if_rhsisnotnumber(this, Label::kDeferred);
         Branch(IsHeapNumberMap(rhs_map), &if_rhsisnumber, &if_rhsisnotnumber);
 
-        Bind(&if_rhsisnumber);
+        BIND(&if_rhsisnumber);
         {
           // Perform a floating point subtraction.
           var_fsub_lhs.Bind(SmiToFloat64(lhs));
@@ -768,7 +768,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
           Goto(&do_fsub);
         }
 
-        Bind(&if_rhsisnotnumber);
+        BIND(&if_rhsisnotnumber);
         {
           // Convert the {rhs} to a Number first.
           Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -778,7 +778,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
       }
     }
 
-    Bind(&if_lhsisnotsmi);
+    BIND(&if_lhsisnotsmi);
     {
       // Load the map of the {lhs}.
       Node* lhs_map = LoadMap(lhs);
@@ -787,13 +787,13 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
       Label if_lhsisnumber(this), if_lhsisnotnumber(this, Label::kDeferred);
       Branch(IsHeapNumberMap(lhs_map), &if_lhsisnumber, &if_lhsisnotnumber);
 
-      Bind(&if_lhsisnumber);
+      BIND(&if_lhsisnumber);
       {
         // Check if the {rhs} is a Smi.
         Label if_rhsissmi(this), if_rhsisnotsmi(this);
         Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-        Bind(&if_rhsissmi);
+        BIND(&if_rhsissmi);
         {
           // Perform a floating point subtraction.
           var_fsub_lhs.Bind(LoadHeapNumberValue(lhs));
@@ -801,7 +801,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
           Goto(&do_fsub);
         }
 
-        Bind(&if_rhsisnotsmi);
+        BIND(&if_rhsisnotsmi);
         {
           // Load the map of the {rhs}.
           Node* rhs_map = LoadMap(rhs);
@@ -810,7 +810,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
           Label if_rhsisnumber(this), if_rhsisnotnumber(this, Label::kDeferred);
           Branch(IsHeapNumberMap(rhs_map), &if_rhsisnumber, &if_rhsisnotnumber);
 
-          Bind(&if_rhsisnumber);
+          BIND(&if_rhsisnumber);
           {
             // Perform a floating point subtraction.
             var_fsub_lhs.Bind(LoadHeapNumberValue(lhs));
@@ -818,7 +818,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
             Goto(&do_fsub);
           }
 
-          Bind(&if_rhsisnotnumber);
+          BIND(&if_rhsisnotnumber);
           {
             // Convert the {rhs} to a Number first.
             Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -828,7 +828,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
         }
       }
 
-      Bind(&if_lhsisnotnumber);
+      BIND(&if_lhsisnotnumber);
       {
         // Convert the {lhs} to a Number first.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -838,7 +838,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
     }
   }
 
-  Bind(&do_fsub);
+  BIND(&do_fsub);
   {
     Node* lhs_value = var_fsub_lhs.value();
     Node* rhs_value = var_fsub_rhs.value();
@@ -846,7 +846,7 @@ TF_BUILTIN(Subtract, CodeStubAssembler) {
     var_result.Bind(AllocateHeapNumberWithValue(value));
     Goto(&end);
   }
-  Bind(&end);
+  BIND(&end);
   Return(var_result.value());
 }
 
@@ -869,7 +869,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
   var_lhs.Bind(left);
   var_rhs.Bind(right);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* lhs = var_lhs.value();
     Node* rhs = var_rhs.value();
@@ -877,12 +877,12 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
     Label lhs_is_smi(this), lhs_is_not_smi(this);
     Branch(TaggedIsSmi(lhs), &lhs_is_smi, &lhs_is_not_smi);
 
-    Bind(&lhs_is_smi);
+    BIND(&lhs_is_smi);
     {
       Label rhs_is_smi(this), rhs_is_not_smi(this);
       Branch(TaggedIsSmi(rhs), &rhs_is_smi, &rhs_is_not_smi);
 
-      Bind(&rhs_is_smi);
+      BIND(&rhs_is_smi);
       {
         // Both {lhs} and {rhs} are Smis. The result is not necessarily a smi,
         // in case of overflow.
@@ -890,7 +890,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
         Goto(&return_result);
       }
 
-      Bind(&rhs_is_not_smi);
+      BIND(&rhs_is_not_smi);
       {
         Node* rhs_map = LoadMap(rhs);
 
@@ -898,7 +898,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
         Label rhs_is_number(this), rhs_is_not_number(this, Label::kDeferred);
         Branch(IsHeapNumberMap(rhs_map), &rhs_is_number, &rhs_is_not_number);
 
-        Bind(&rhs_is_number);
+        BIND(&rhs_is_number);
         {
           // Convert {lhs} to a double and multiply it with the value of {rhs}.
           var_lhs_float64.Bind(SmiToFloat64(lhs));
@@ -906,7 +906,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
           Goto(&do_fmul);
         }
 
-        Bind(&rhs_is_not_number);
+        BIND(&rhs_is_not_number);
         {
           // Multiplication is commutative, swap {lhs} with {rhs} and loop.
           var_lhs.Bind(rhs);
@@ -916,7 +916,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
       }
     }
 
-    Bind(&lhs_is_not_smi);
+    BIND(&lhs_is_not_smi);
     {
       Node* lhs_map = LoadMap(lhs);
 
@@ -924,13 +924,13 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
       Label lhs_is_number(this), lhs_is_not_number(this, Label::kDeferred);
       Branch(IsHeapNumberMap(lhs_map), &lhs_is_number, &lhs_is_not_number);
 
-      Bind(&lhs_is_number);
+      BIND(&lhs_is_number);
       {
         // Check if {rhs} is a Smi.
         Label rhs_is_smi(this), rhs_is_not_smi(this);
         Branch(TaggedIsSmi(rhs), &rhs_is_smi, &rhs_is_not_smi);
 
-        Bind(&rhs_is_smi);
+        BIND(&rhs_is_smi);
         {
           // Convert {rhs} to a double and multiply it with the value of {lhs}.
           var_lhs_float64.Bind(LoadHeapNumberValue(lhs));
@@ -938,7 +938,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
           Goto(&do_fmul);
         }
 
-        Bind(&rhs_is_not_smi);
+        BIND(&rhs_is_not_smi);
         {
           Node* rhs_map = LoadMap(rhs);
 
@@ -946,7 +946,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
           Label rhs_is_number(this), rhs_is_not_number(this, Label::kDeferred);
           Branch(IsHeapNumberMap(rhs_map), &rhs_is_number, &rhs_is_not_number);
 
-          Bind(&rhs_is_number);
+          BIND(&rhs_is_number);
           {
             // Both {lhs} and {rhs} are HeapNumbers. Load their values and
             // multiply them.
@@ -955,7 +955,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
             Goto(&do_fmul);
           }
 
-          Bind(&rhs_is_not_number);
+          BIND(&rhs_is_not_number);
           {
             // Multiplication is commutative, swap {lhs} with {rhs} and loop.
             var_lhs.Bind(rhs);
@@ -965,7 +965,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
         }
       }
 
-      Bind(&lhs_is_not_number);
+      BIND(&lhs_is_not_number);
       {
         // Convert {lhs} to a Number and loop.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -975,7 +975,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
     }
   }
 
-  Bind(&do_fmul);
+  BIND(&do_fmul);
   {
     Node* value = Float64Mul(var_lhs_float64.value(), var_rhs_float64.value());
     Node* result = AllocateHeapNumberWithValue(value);
@@ -983,7 +983,7 @@ TF_BUILTIN(Multiply, CodeStubAssembler) {
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   Return(var_result.value());
 }
 
@@ -1006,7 +1006,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
   var_dividend.Bind(left);
   var_divisor.Bind(right);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* dividend = var_dividend.value();
     Node* divisor = var_divisor.value();
@@ -1014,12 +1014,12 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
     Label dividend_is_smi(this), dividend_is_not_smi(this);
     Branch(TaggedIsSmi(dividend), &dividend_is_smi, &dividend_is_not_smi);
 
-    Bind(&dividend_is_smi);
+    BIND(&dividend_is_smi);
     {
       Label divisor_is_smi(this), divisor_is_not_smi(this);
       Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-      Bind(&divisor_is_smi);
+      BIND(&divisor_is_smi);
       {
         Label bailout(this);
 
@@ -1032,12 +1032,12 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
         Branch(SmiEqual(dividend, SmiConstant(0)), &dividend_is_zero,
                &dividend_is_not_zero);
 
-        Bind(&dividend_is_zero);
+        BIND(&dividend_is_zero);
         {
           GotoIf(SmiLessThan(divisor, SmiConstant(0)), &bailout);
           Goto(&dividend_is_not_zero);
         }
-        Bind(&dividend_is_not_zero);
+        BIND(&dividend_is_not_zero);
 
         Node* untagged_divisor = SmiToWord32(divisor);
         Node* untagged_dividend = SmiToWord32(dividend);
@@ -1048,7 +1048,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
         Branch(Word32Equal(untagged_divisor, Int32Constant(-1)),
                &divisor_is_minus_one, &divisor_is_not_minus_one);
 
-        Bind(&divisor_is_minus_one);
+        BIND(&divisor_is_minus_one);
         {
           GotoIf(
               Word32Equal(untagged_dividend,
@@ -1057,7 +1057,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
               &bailout);
           Goto(&divisor_is_not_minus_one);
         }
-        Bind(&divisor_is_not_minus_one);
+        BIND(&divisor_is_not_minus_one);
 
         // TODO(epertoso): consider adding a machine instruction that returns
         // both the result and the remainder.
@@ -1070,7 +1070,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
 
         // Bailout: convert {dividend} and {divisor} to double and do double
         // division.
-        Bind(&bailout);
+        BIND(&bailout);
         {
           var_dividend_float64.Bind(SmiToFloat64(dividend));
           var_divisor_float64.Bind(SmiToFloat64(divisor));
@@ -1078,7 +1078,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
         }
       }
 
-      Bind(&divisor_is_not_smi);
+      BIND(&divisor_is_not_smi);
       {
         Node* divisor_map = LoadMap(divisor);
 
@@ -1088,7 +1088,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
         Branch(IsHeapNumberMap(divisor_map), &divisor_is_number,
                &divisor_is_not_number);
 
-        Bind(&divisor_is_number);
+        BIND(&divisor_is_number);
         {
           // Convert {dividend} to a double and divide it with the value of
           // {divisor}.
@@ -1097,7 +1097,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
           Goto(&do_fdiv);
         }
 
-        Bind(&divisor_is_not_number);
+        BIND(&divisor_is_not_number);
         {
           // Convert {divisor} to a number and loop.
           Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -1107,7 +1107,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
       }
     }
 
-    Bind(&dividend_is_not_smi);
+    BIND(&dividend_is_not_smi);
     {
       Node* dividend_map = LoadMap(dividend);
 
@@ -1117,13 +1117,13 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
       Branch(IsHeapNumberMap(dividend_map), &dividend_is_number,
              &dividend_is_not_number);
 
-      Bind(&dividend_is_number);
+      BIND(&dividend_is_number);
       {
         // Check if {divisor} is a Smi.
         Label divisor_is_smi(this), divisor_is_not_smi(this);
         Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-        Bind(&divisor_is_smi);
+        BIND(&divisor_is_smi);
         {
           // Convert {divisor} to a double and use it for a floating point
           // division.
@@ -1132,7 +1132,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
           Goto(&do_fdiv);
         }
 
-        Bind(&divisor_is_not_smi);
+        BIND(&divisor_is_not_smi);
         {
           Node* divisor_map = LoadMap(divisor);
 
@@ -1142,7 +1142,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
           Branch(IsHeapNumberMap(divisor_map), &divisor_is_number,
                  &divisor_is_not_number);
 
-          Bind(&divisor_is_number);
+          BIND(&divisor_is_number);
           {
             // Both {dividend} and {divisor} are HeapNumbers. Load their values
             // and divide them.
@@ -1151,7 +1151,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
             Goto(&do_fdiv);
           }
 
-          Bind(&divisor_is_not_number);
+          BIND(&divisor_is_not_number);
           {
             // Convert {divisor} to a number and loop.
             Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -1161,7 +1161,7 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
         }
       }
 
-      Bind(&dividend_is_not_number);
+      BIND(&dividend_is_not_number);
       {
         // Convert {dividend} to a Number and loop.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -1171,14 +1171,14 @@ TF_BUILTIN(Divide, CodeStubAssembler) {
     }
   }
 
-  Bind(&do_fdiv);
+  BIND(&do_fdiv);
   {
     Node* value =
         Float64Div(var_dividend_float64.value(), var_divisor_float64.value());
     var_result.Bind(AllocateHeapNumberWithValue(value));
     Goto(&end);
   }
-  Bind(&end);
+  BIND(&end);
   Return(var_result.value());
 }
 
@@ -1203,7 +1203,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
   var_dividend.Bind(left);
   var_divisor.Bind(right);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* dividend = var_dividend.value();
     Node* divisor = var_divisor.value();
@@ -1211,20 +1211,20 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
     Label dividend_is_smi(this), dividend_is_not_smi(this);
     Branch(TaggedIsSmi(dividend), &dividend_is_smi, &dividend_is_not_smi);
 
-    Bind(&dividend_is_smi);
+    BIND(&dividend_is_smi);
     {
       Label dividend_is_not_zero(this);
       Label divisor_is_smi(this), divisor_is_not_smi(this);
       Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-      Bind(&divisor_is_smi);
+      BIND(&divisor_is_smi);
       {
         // Compute the modulus of two Smis.
         var_result.Bind(SmiMod(dividend, divisor));
         Goto(&return_result);
       }
 
-      Bind(&divisor_is_not_smi);
+      BIND(&divisor_is_not_smi);
       {
         Node* divisor_map = LoadMap(divisor);
 
@@ -1234,7 +1234,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
         Branch(IsHeapNumberMap(divisor_map), &divisor_is_number,
                &divisor_is_not_number);
 
-        Bind(&divisor_is_number);
+        BIND(&divisor_is_number);
         {
           // Convert {dividend} to a double and compute its modulus with the
           // value of {dividend}.
@@ -1243,7 +1243,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
           Goto(&do_fmod);
         }
 
-        Bind(&divisor_is_not_number);
+        BIND(&divisor_is_not_number);
         {
           // Convert {divisor} to a number and loop.
           Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -1253,7 +1253,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
       }
     }
 
-    Bind(&dividend_is_not_smi);
+    BIND(&dividend_is_not_smi);
     {
       Node* dividend_map = LoadMap(dividend);
 
@@ -1263,13 +1263,13 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
       Branch(IsHeapNumberMap(dividend_map), &dividend_is_number,
              &dividend_is_not_number);
 
-      Bind(&dividend_is_number);
+      BIND(&dividend_is_number);
       {
         // Check if {divisor} is a Smi.
         Label divisor_is_smi(this), divisor_is_not_smi(this);
         Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-        Bind(&divisor_is_smi);
+        BIND(&divisor_is_smi);
         {
           // Convert {divisor} to a double and compute {dividend}'s modulus with
           // it.
@@ -1278,7 +1278,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
           Goto(&do_fmod);
         }
 
-        Bind(&divisor_is_not_smi);
+        BIND(&divisor_is_not_smi);
         {
           Node* divisor_map = LoadMap(divisor);
 
@@ -1288,7 +1288,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
           Branch(IsHeapNumberMap(divisor_map), &divisor_is_number,
                  &divisor_is_not_number);
 
-          Bind(&divisor_is_number);
+          BIND(&divisor_is_number);
           {
             // Both {dividend} and {divisor} are HeapNumbers. Load their values
             // and compute their modulus.
@@ -1297,7 +1297,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
             Goto(&do_fmod);
           }
 
-          Bind(&divisor_is_not_number);
+          BIND(&divisor_is_not_number);
           {
             // Convert {divisor} to a number and loop.
             Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -1307,7 +1307,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
         }
       }
 
-      Bind(&dividend_is_not_number);
+      BIND(&dividend_is_not_number);
       {
         // Convert {dividend} to a Number and loop.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -1317,7 +1317,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
     }
   }
 
-  Bind(&do_fmod);
+  BIND(&do_fmod);
   {
     Node* value =
         Float64Mod(var_dividend_float64.value(), var_divisor_float64.value());
@@ -1325,7 +1325,7 @@ TF_BUILTIN(Modulus, CodeStubAssembler) {
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   Return(var_result.value());
 }
 
diff --git a/src/builtins/builtins-object-gen.cc b/src/builtins/builtins-object-gen.cc
index cd50e76ed88..36cb8d30fc8 100644
--- a/src/builtins/builtins-object-gen.cc
+++ b/src/builtins/builtins-object-gen.cc
@@ -29,7 +29,7 @@ void ObjectBuiltinsAssembler::IsString(Node* object, Label* if_string,
   Label if_notsmi(this);
   Branch(TaggedIsSmi(object), if_notstring, &if_notsmi);
 
-  Bind(&if_notsmi);
+  BIND(&if_notsmi);
   {
     Node* instance_type = LoadInstanceType(object);
 
@@ -59,7 +59,7 @@ TF_BUILTIN(ObjectHasOwnProperty, ObjectBuiltinsAssembler) {
   // Smi receivers do not have own properties.
   Label if_objectisnotsmi(this);
   Branch(TaggedIsSmi(object), &return_false, &if_objectisnotsmi);
-  Bind(&if_objectisnotsmi);
+  BIND(&if_objectisnotsmi);
 
   Node* map = LoadMap(object);
   Node* instance_type = LoadMapInstanceType(map);
@@ -72,23 +72,23 @@ TF_BUILTIN(ObjectHasOwnProperty, ObjectBuiltinsAssembler) {
     TryToName(key, &keyisindex, &var_index, &if_iskeyunique, &var_unique,
               &call_runtime);
 
-    Bind(&if_iskeyunique);
+    BIND(&if_iskeyunique);
     TryHasOwnProperty(object, map, instance_type, var_unique.value(),
                       &return_true, &return_false, &call_runtime);
 
-    Bind(&keyisindex);
+    BIND(&keyisindex);
     // Handle negative keys in the runtime.
     GotoIf(IntPtrLessThan(var_index.value(), IntPtrConstant(0)), &call_runtime);
     TryLookupElement(object, map, instance_type, var_index.value(),
                      &return_true, &return_false, &return_false, &call_runtime);
   }
-  Bind(&return_true);
+  BIND(&return_true);
   Return(BooleanConstant(true));
 
-  Bind(&return_false);
+  BIND(&return_false);
   Return(BooleanConstant(false));
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   Return(CallRuntime(Runtime::kObjectHasOwnProperty, context, object, key));
 }
 
@@ -126,7 +126,7 @@ TF_BUILTIN(ObjectProtoToString, ObjectBuiltinsAssembler) {
   Branch(Word32Equal(receiver_instance_type, Int32Constant(JS_PROXY_TYPE)),
          &if_isproxy, &checkstringtag);
 
-  Bind(&if_isproxy);
+  BIND(&if_isproxy);
   {
     // This can throw
     var_proxy_is_array.Bind(
@@ -134,7 +134,7 @@ TF_BUILTIN(ObjectProtoToString, ObjectBuiltinsAssembler) {
     Goto(&checkstringtag);
   }
 
-  Bind(&checkstringtag);
+  BIND(&checkstringtag);
   {
     Node* to_string_tag_symbol =
         HeapConstant(isolate()->factory()->to_string_tag_symbol());
@@ -147,10 +147,10 @@ TF_BUILTIN(ObjectProtoToString, ObjectBuiltinsAssembler) {
 
     IsString(to_string_tag_value, &if_tostringtag, &if_notostringtag);
 
-    Bind(&if_tostringtag);
+    BIND(&if_tostringtag);
     ReturnToStringFormat(context, to_string_tag_value);
   }
-  Bind(&if_notostringtag);
+  BIND(&if_notostringtag);
   {
     size_t const kNumCases = 11;
     Label* case_labels[kNumCases];
@@ -181,37 +181,37 @@ TF_BUILTIN(ObjectProtoToString, ObjectBuiltinsAssembler) {
     Switch(receiver_instance_type, &return_object, case_values, case_labels,
            arraysize(case_values));
 
-    Bind(&return_undefined);
+    BIND(&return_undefined);
     Return(HeapConstant(isolate()->factory()->undefined_to_string()));
 
-    Bind(&return_null);
+    BIND(&return_null);
     Return(HeapConstant(isolate()->factory()->null_to_string()));
 
-    Bind(&return_arguments);
+    BIND(&return_arguments);
     Return(HeapConstant(isolate()->factory()->arguments_to_string()));
 
-    Bind(&return_array);
+    BIND(&return_array);
     Return(HeapConstant(isolate()->factory()->array_to_string()));
 
-    Bind(&return_function);
+    BIND(&return_function);
     Return(HeapConstant(isolate()->factory()->function_to_string()));
 
-    Bind(&return_error);
+    BIND(&return_error);
     Return(HeapConstant(isolate()->factory()->error_to_string()));
 
-    Bind(&return_date);
+    BIND(&return_date);
     Return(HeapConstant(isolate()->factory()->date_to_string()));
 
-    Bind(&return_regexp);
+    BIND(&return_regexp);
     Return(HeapConstant(isolate()->factory()->regexp_to_string()));
 
-    Bind(&return_api);
+    BIND(&return_api);
     {
       Node* class_name = CallRuntime(Runtime::kClassOf, context, receiver);
       ReturnToStringFormat(context, class_name);
     }
 
-    Bind(&return_jsvalue);
+    BIND(&return_jsvalue);
     {
       Label return_boolean(this), return_number(this), return_string(this);
 
@@ -228,17 +228,17 @@ TF_BUILTIN(ObjectProtoToString, ObjectBuiltinsAssembler) {
       CSA_ASSERT(this, Word32Equal(instance_type, Int32Constant(SYMBOL_TYPE)));
       Goto(&return_object);
 
-      Bind(&return_string);
+      BIND(&return_string);
       Return(HeapConstant(isolate()->factory()->string_to_string()));
 
-      Bind(&return_number);
+      BIND(&return_number);
       Return(HeapConstant(isolate()->factory()->number_to_string()));
 
-      Bind(&return_boolean);
+      BIND(&return_boolean);
       Return(HeapConstant(isolate()->factory()->boolean_to_string()));
     }
 
-    Bind(&return_jsproxy);
+    BIND(&return_jsproxy);
     {
       GotoIf(WordEqual(var_proxy_is_array.value(), BooleanConstant(true)),
              &return_array);
@@ -250,7 +250,7 @@ TF_BUILTIN(ObjectProtoToString, ObjectBuiltinsAssembler) {
     }
 
     // Default
-    Bind(&return_object);
+    BIND(&return_object);
     Return(HeapConstant(isolate()->factory()->object_to_string()));
   }
 }
@@ -280,7 +280,7 @@ TF_BUILTIN(ObjectCreate, ObjectBuiltinsAssembler) {
     BranchIfJSReceiver(prototype, &prototype_valid, &call_runtime);
   }
 
-  Bind(&prototype_valid);
+  BIND(&prototype_valid);
   {
     Comment("Argument 2 check: properties");
     // Check that we have a simple object
@@ -301,7 +301,7 @@ TF_BUILTIN(ObjectCreate, ObjectBuiltinsAssembler) {
   }
 
   // Create a new object with the given prototype.
-  Bind(&no_properties);
+  BIND(&no_properties);
   {
     Variable map(this, MachineRepresentation::kTagged);
     Variable properties(this, MachineRepresentation::kTagged);
@@ -309,7 +309,7 @@ TF_BUILTIN(ObjectCreate, ObjectBuiltinsAssembler) {
 
     Branch(WordEqual(prototype, NullConstant()), &good, &non_null_proto);
 
-    Bind(&good);
+    BIND(&good);
     {
       map.Bind(LoadContextElement(
           context, Context::SLOW_OBJECT_WITH_NULL_PROTOTYPE_MAP));
@@ -317,7 +317,7 @@ TF_BUILTIN(ObjectCreate, ObjectBuiltinsAssembler) {
       Goto(&instantiate_map);
     }
 
-    Bind(&non_null_proto);
+    BIND(&non_null_proto);
     {
       properties.Bind(EmptyFixedArrayConstant());
       Node* object_function =
@@ -338,14 +338,14 @@ TF_BUILTIN(ObjectCreate, ObjectBuiltinsAssembler) {
       Goto(&instantiate_map);
     }
 
-    Bind(&instantiate_map);
+    BIND(&instantiate_map);
     {
       Node* instance = AllocateJSObjectFromMap(map.value(), properties.value());
       Return(instance);
     }
   }
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     Return(CallRuntime(Runtime::kObjectCreate, context, prototype, properties));
   }
diff --git a/src/builtins/builtins-promise-gen.cc b/src/builtins/builtins-promise-gen.cc
index 08d7760bb06..8c5861df024 100644
--- a/src/builtins/builtins-promise-gen.cc
+++ b/src/builtins/builtins-promise-gen.cc
@@ -47,7 +47,7 @@ Node* PromiseBuiltinsAssembler::AllocateAndInitJSPromise(Node* context,
   CallRuntime(Runtime::kPromiseHookInit, context, instance, parent);
   Goto(&out);
 
-  Bind(&out);
+  BIND(&out);
   return instance;
 }
 
@@ -69,7 +69,7 @@ Node* PromiseBuiltinsAssembler::AllocateAndSetJSPromise(Node* context,
               UndefinedConstant());
   Goto(&out);
 
-  Bind(&out);
+  BIND(&out);
   return instance;
 }
 
@@ -120,7 +120,7 @@ Node* PromiseBuiltinsAssembler::NewPromiseCapability(Node* context,
                                       Context::PROMISE_FUNCTION_INDEX)),
          &if_builtin_promise, &if_custom_promise);
 
-  Bind(&if_builtin_promise);
+  BIND(&if_builtin_promise);
   {
     Node* promise = AllocateJSPromise(context);
     PromiseInit(promise);
@@ -140,7 +140,7 @@ Node* PromiseBuiltinsAssembler::NewPromiseCapability(Node* context,
     Goto(&out);
   }
 
-  Bind(&if_custom_promise);
+  BIND(&if_custom_promise);
   {
     Label if_notcallable(this, Label::kDeferred);
     Node* executor_context =
@@ -169,7 +169,7 @@ Node* PromiseBuiltinsAssembler::NewPromiseCapability(Node* context,
 
     Goto(&out);
 
-    Bind(&if_notcallable);
+    BIND(&if_notcallable);
     Node* message = SmiConstant(MessageTemplate::kPromiseNonCallable);
     StoreObjectField(capability, JSPromiseCapability::kPromiseOffset,
                      UndefinedConstant());
@@ -181,7 +181,7 @@ Node* PromiseBuiltinsAssembler::NewPromiseCapability(Node* context,
     Unreachable();
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -241,7 +241,7 @@ Node* PromiseBuiltinsAssembler::ThrowIfNotJSReceiver(
   Branch(IsJSReceiverInstanceType(value_instance_type), &out, &throw_exception);
 
   // The {value} is not a compatible receiver for this method.
-  Bind(&throw_exception);
+  BIND(&throw_exception);
   {
     Node* const method =
         method_name == nullptr
@@ -253,7 +253,7 @@ Node* PromiseBuiltinsAssembler::ThrowIfNotJSReceiver(
     Unreachable();
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_value_map.value();
 }
 
@@ -313,7 +313,7 @@ Node* PromiseBuiltinsAssembler::SpeciesConstructor(Node* context, Node* object,
   Goto(&out);
 
   // 8. Throw a TypeError exception.
-  Bind(&throw_error);
+  BIND(&throw_error);
   {
     Node* const message_id =
         SmiConstant(MessageTemplate::kSpeciesNotConstructor);
@@ -321,7 +321,7 @@ Node* PromiseBuiltinsAssembler::SpeciesConstructor(Node* context, Node* object,
     Unreachable();
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -379,7 +379,7 @@ Node* PromiseBuiltinsAssembler::InternalPromiseThen(Node* context,
   Branch(WordEqual(promise_fun, constructor), &fast_promise_capability,
          &promise_capability);
 
-  Bind(&fast_promise_capability);
+  BIND(&fast_promise_capability);
   {
     Node* const deferred_promise = AllocateAndInitJSPromise(context, promise);
     var_deferred_promise.Bind(deferred_promise);
@@ -388,7 +388,7 @@ Node* PromiseBuiltinsAssembler::InternalPromiseThen(Node* context,
     Goto(&perform_promise_then);
   }
 
-  Bind(&promise_capability);
+  BIND(&promise_capability);
   {
     Node* const capability = NewPromiseCapability(context, constructor);
     var_deferred_promise.Bind(
@@ -402,7 +402,7 @@ Node* PromiseBuiltinsAssembler::InternalPromiseThen(Node* context,
 
   // 5. Return PerformPromiseThen(promise, onFulfilled, onRejected,
   //    resultCapability).
-  Bind(&perform_promise_then);
+  BIND(&perform_promise_then);
   Node* const result = InternalPerformPromiseThen(
       context, promise, on_resolve, on_reject, var_deferred_promise.value(),
       var_deferred_on_resolve.value(), var_deferred_on_reject.value());
@@ -428,7 +428,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
   Branch(IsCallableMap(on_resolve_map), &onrejectcheck,
          &if_onresolvenotcallable);
 
-  Bind(&if_onresolvenotcallable);
+  BIND(&if_onresolvenotcallable);
   {
     Node* const default_resolve_handler_symbol = HeapConstant(
         isolate->factory()->promise_default_resolve_handler_symbol());
@@ -436,7 +436,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
     Goto(&onrejectcheck);
   }
 
-  Bind(&onrejectcheck);
+  BIND(&onrejectcheck);
   {
     Label if_onrejectnotcallable(this);
     GotoIf(TaggedIsSmi(on_reject), &if_onrejectnotcallable);
@@ -445,7 +445,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
     Branch(IsCallableMap(on_reject_map), &append_callbacks,
            &if_onrejectnotcallable);
 
-    Bind(&if_onrejectnotcallable);
+    BIND(&if_onrejectnotcallable);
     {
       Node* const default_reject_handler_symbol = HeapConstant(
           isolate->factory()->promise_default_reject_handler_symbol());
@@ -454,7 +454,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
     }
   }
 
-  Bind(&append_callbacks);
+  BIND(&append_callbacks);
   {
     Label fulfilled_check(this);
     Node* const status = LoadObjectField(promise, JSPromise::kStatusOffset);
@@ -468,7 +468,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
     Branch(IsUndefined(existing_deferred_promise), &if_noexistingcallbacks,
            &if_existingcallbacks);
 
-    Bind(&if_noexistingcallbacks);
+    BIND(&if_noexistingcallbacks);
     {
       // Store callbacks directly in the slots.
       StoreObjectField(promise, JSPromise::kDeferredPromiseOffset,
@@ -484,13 +484,13 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
       Goto(&out);
     }
 
-    Bind(&if_existingcallbacks);
+    BIND(&if_existingcallbacks);
     {
       Label if_singlecallback(this), if_multiplecallbacks(this);
       BranchIfJSObject(existing_deferred_promise, &if_singlecallback,
                        &if_multiplecallbacks);
 
-      Bind(&if_singlecallback);
+      BIND(&if_singlecallback);
       {
         // Create new FixedArrays to store callbacks, and migrate
         // existing callbacks.
@@ -542,7 +542,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
         Goto(&out);
       }
 
-      Bind(&if_multiplecallbacks);
+      BIND(&if_multiplecallbacks);
       {
         AppendPromiseCallback(JSPromise::kDeferredPromiseOffset, promise,
                               deferred_promise);
@@ -558,7 +558,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
       }
     }
 
-    Bind(&fulfilled_check);
+    BIND(&fulfilled_check);
     {
       Label reject(this);
       Node* const result = LoadObjectField(promise, JSPromise::kResultOffset);
@@ -572,7 +572,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
       CallRuntime(Runtime::kEnqueuePromiseReactionJob, context, info);
       Goto(&out);
 
-      Bind(&reject);
+      BIND(&reject);
       {
         Node* const has_handler = PromiseHasHandler(promise);
         Label enqueue(this);
@@ -582,7 +582,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
         CallRuntime(Runtime::kPromiseRevokeReject, context, promise);
         Goto(&enqueue);
 
-        Bind(&enqueue);
+        BIND(&enqueue);
         {
           Node* info = AllocatePromiseReactionJobInfo(
               result, var_on_reject.value(), deferred_promise,
@@ -595,7 +595,7 @@ Node* PromiseBuiltinsAssembler::InternalPerformPromiseThen(
     }
   }
 
-  Bind(&out);
+  BIND(&out);
   PromiseSetHasHandler(promise);
   return deferred_promise;
 }
@@ -676,7 +676,7 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
   CallRuntime(Runtime::kPromiseHookResolve, context, promise);
   Goto(&cycle_check);
 
-  Bind(&cycle_check);
+  BIND(&cycle_check);
   // 6. If SameValue(resolution, promise) is true, then
   GotoIf(SameValue(promise, result), &if_cycle);
 
@@ -694,7 +694,7 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
   // Resolution is a native promise and if it's already resolved or
   // rejected, shortcircuit the resolution procedure by directly
   // reusing the value from the promise.
-  Bind(&if_nativepromise);
+  BIND(&if_nativepromise);
   {
     Node* const thenable_status =
         LoadObjectField(result, JSPromise::kStatusOffset);
@@ -713,13 +713,13 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
     var_then.Bind(then);
     Goto(&do_enqueue);
 
-    Bind(&if_isnotpending);
+    BIND(&if_isnotpending);
     {
       Label if_fulfilled(this), if_rejected(this);
       Branch(SmiEqual(SmiConstant(v8::Promise::kFulfilled), thenable_status),
              &if_fulfilled, &if_rejected);
 
-      Bind(&if_fulfilled);
+      BIND(&if_fulfilled);
       {
         PromiseFulfill(context, promise, thenable_value,
                        v8::Promise::kFulfilled);
@@ -727,7 +727,7 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
         Goto(&out);
       }
 
-      Bind(&if_rejected);
+      BIND(&if_rejected);
       {
         Label reject(this);
         Node* const has_handler = PromiseHasHandler(result);
@@ -738,7 +738,7 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
         CallRuntime(Runtime::kPromiseRevokeReject, context, result);
         Goto(&reject);
 
-        Bind(&reject);
+        BIND(&reject);
         // Don't cause a debug event as this case is forwarding a rejection.
         InternalPromiseReject(context, promise, thenable_value, false);
         PromiseSetHasHandler(result);
@@ -747,7 +747,7 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
     }
   }
 
-  Bind(&if_notnativepromise);
+  BIND(&if_notnativepromise);
   {
     // 8. Let then be Get(resolution, "then").
     Node* const then =
@@ -764,7 +764,7 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
     Goto(&do_enqueue);
   }
 
-  Bind(&do_enqueue);
+  BIND(&do_enqueue);
   {
     // TODO(gsathya): Add fast path for native promises with unmodified
     // PromiseThen (which don't need these resolving functions, but
@@ -792,20 +792,20 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
 
     // 12. Perform EnqueueJob("PromiseJobs",
     // PromiseResolveThenableJob,  promise, resolution, thenAction).
-    Bind(&enqueue);
+    BIND(&enqueue);
     // TODO(gsathya): Move this to TF
     CallRuntime(Runtime::kEnqueuePromiseResolveThenableJob, context, info);
     Goto(&out);
   }
 
   // 7.b Return FulfillPromise(promise, resolution).
-  Bind(&fulfill);
+  BIND(&fulfill);
   {
     PromiseFulfill(context, promise, result, v8::Promise::kFulfilled);
     Goto(&out);
   }
 
-  Bind(&if_cycle);
+  BIND(&if_cycle);
   {
     // 6.a Let selfResolutionError be a newly created TypeError object.
     Node* const message_id = SmiConstant(MessageTemplate::kPromiseCyclic);
@@ -818,14 +818,14 @@ void PromiseBuiltinsAssembler::InternalResolvePromise(Node* context,
   }
 
   // 9.a Return RejectPromise(promise, then.[[Value]]).
-  Bind(&if_rejectpromise);
+  BIND(&if_rejectpromise);
   {
     // Don't cause a debug event as this case is forwarding a rejection.
     InternalPromiseReject(context, promise, var_reason.value(), false);
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
 }
 
 void PromiseBuiltinsAssembler::PromiseFulfill(
@@ -856,7 +856,7 @@ void PromiseBuiltinsAssembler::PromiseFulfill(
   CallRuntime(Runtime::kEnqueuePromiseReactionJob, context, info);
   Goto(&debug_async_event_enqueue_recurring);
 
-  Bind(&debug_async_event_enqueue_recurring);
+  BIND(&debug_async_event_enqueue_recurring);
   {
     GotoIfNot(IsDebugActive(), &do_promisereset);
     CallRuntime(Runtime::kDebugAsyncEventEnqueueRecurring, context, promise,
@@ -864,7 +864,7 @@ void PromiseBuiltinsAssembler::PromiseFulfill(
     Goto(&do_promisereset);
   }
 
-  Bind(&do_promisereset);
+  BIND(&do_promisereset);
   {
     StoreObjectField(promise, JSPromise::kStatusOffset, status_smi);
     StoreObjectField(promise, JSPromise::kResultOffset, result);
@@ -892,7 +892,7 @@ void PromiseBuiltinsAssembler::BranchIfAccessCheckFailed(
   // reached an actual function.
   Label found_function(this), loop_over_bound_function(this, &var_executor);
   Goto(&loop_over_bound_function);
-  Bind(&loop_over_bound_function);
+  BIND(&loop_over_bound_function);
   {
     Node* executor_type = LoadInstanceType(var_executor.value());
     GotoIf(InstanceTypeEqual(executor_type, JS_FUNCTION_TYPE), &found_function);
@@ -906,7 +906,7 @@ void PromiseBuiltinsAssembler::BranchIfAccessCheckFailed(
   // Load the context from the function and compare it to the Promise
   // constructor's context. If they match, everything is fine, otherwise, bail
   // out to the runtime.
-  Bind(&found_function);
+  BIND(&found_function);
   {
     Node* function_context =
         LoadObjectField(var_executor.value(), JSFunction::kContextOffset);
@@ -915,7 +915,7 @@ void PromiseBuiltinsAssembler::BranchIfAccessCheckFailed(
            &call_runtime);
   }
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     Branch(WordEqual(CallRuntime(Runtime::kAllowDynamicFunction, context,
                                  promise_constructor),
@@ -923,7 +923,7 @@ void PromiseBuiltinsAssembler::BranchIfAccessCheckFailed(
            &has_access, if_noaccess);
   }
 
-  Bind(&has_access);
+  BIND(&has_access);
 }
 
 void PromiseBuiltinsAssembler::InternalPromiseReject(Node* context,
@@ -935,7 +935,7 @@ void PromiseBuiltinsAssembler::InternalPromiseReject(Node* context,
   CallRuntime(Runtime::kDebugPromiseReject, context, promise, value);
   Goto(&out);
 
-  Bind(&out);
+  BIND(&out);
   InternalPromiseReject(context, promise, value, false);
 }
 
@@ -954,21 +954,21 @@ void PromiseBuiltinsAssembler::InternalPromiseReject(Node* context,
     Goto(&run_promise_hook);
   }
 
-  Bind(&run_promise_hook);
+  BIND(&run_promise_hook);
   {
     GotoIfNot(IsPromiseHookEnabledOrDebugIsActive(), &report_unhandledpromise);
     CallRuntime(Runtime::kPromiseHookResolve, context, promise);
     Goto(&report_unhandledpromise);
   }
 
-  Bind(&report_unhandledpromise);
+  BIND(&report_unhandledpromise);
   {
     GotoIf(PromiseHasHandler(promise), &fulfill);
     CallRuntime(Runtime::kReportPromiseReject, context, promise, value);
     Goto(&fulfill);
   }
 
-  Bind(&fulfill);
+  BIND(&fulfill);
   PromiseFulfill(context, promise, value, v8::Promise::kRejected);
 }
 
@@ -1002,7 +1002,7 @@ TF_BUILTIN(PromiseRejectClosure, PromiseBuiltinsAssembler) {
   InternalPromiseReject(context, promise, value, debug_event);
   Return(UndefinedConstant());
 
-  Bind(&out);
+  BIND(&out);
   Return(UndefinedConstant());
 }
 
@@ -1042,14 +1042,14 @@ TF_BUILTIN(PromiseConstructor, PromiseBuiltinsAssembler) {
       var_reject_call(this, MachineRepresentation::kTagged),
       var_reason(this, MachineRepresentation::kTagged);
 
-  Bind(&if_targetisnotmodified);
+  BIND(&if_targetisnotmodified);
   {
     Node* const instance = AllocateAndInitJSPromise(context);
     var_result.Bind(instance);
     Goto(&debug_push);
   }
 
-  Bind(&if_targetismodified);
+  BIND(&if_targetismodified);
   {
     ConstructorBuiltinsAssembler constructor_assembler(this->state());
     Node* const instance = constructor_assembler.EmitFastNewObject(
@@ -1063,14 +1063,14 @@ TF_BUILTIN(PromiseConstructor, PromiseBuiltinsAssembler) {
     Goto(&debug_push);
   }
 
-  Bind(&debug_push);
+  BIND(&debug_push);
   {
     GotoIfNot(is_debug_active, &run_executor);
     CallRuntime(Runtime::kDebugPushPromise, context, var_result.value());
     Goto(&run_executor);
   }
 
-  Bind(&run_executor);
+  BIND(&run_executor);
   {
     Label out(this), if_rejectpromise(this), debug_pop(this, Label::kDeferred);
 
@@ -1085,7 +1085,7 @@ TF_BUILTIN(PromiseConstructor, PromiseBuiltinsAssembler) {
     GotoIfException(maybe_exception, &if_rejectpromise, &var_reason);
     Branch(is_debug_active, &debug_pop, &out);
 
-    Bind(&if_rejectpromise);
+    BIND(&if_rejectpromise);
     {
       Callable call_callable = CodeFactory::Call(isolate);
       CallJS(call_callable, context, reject, UndefinedConstant(),
@@ -1093,17 +1093,17 @@ TF_BUILTIN(PromiseConstructor, PromiseBuiltinsAssembler) {
       Branch(is_debug_active, &debug_pop, &out);
     }
 
-    Bind(&debug_pop);
+    BIND(&debug_pop);
     {
       CallRuntime(Runtime::kDebugPopPromise, context);
       Goto(&out);
     }
-    Bind(&out);
+    BIND(&out);
     Return(var_result.value());
   }
 
   // 1. If NewTarget is undefined, throw a TypeError exception.
-  Bind(&if_targetisundefined);
+  BIND(&if_targetisundefined);
   {
     Node* const message_id = SmiConstant(MessageTemplate::kNotAPromise);
     CallRuntime(Runtime::kThrowTypeError, context, message_id, new_target);
@@ -1111,7 +1111,7 @@ TF_BUILTIN(PromiseConstructor, PromiseBuiltinsAssembler) {
   }
 
   // 2. If IsCallable(executor) is false, throw a TypeError exception.
-  Bind(&if_notcallable);
+  BIND(&if_notcallable);
   {
     Node* const message_id =
         SmiConstant(MessageTemplate::kResolverNotAFunction);
@@ -1120,7 +1120,7 @@ TF_BUILTIN(PromiseConstructor, PromiseBuiltinsAssembler) {
   }
 
   // Silently fail if the stack looks fishy.
-  Bind(&if_noaccess);
+  BIND(&if_noaccess);
   {
     Node* const counter_id =
         SmiConstant(v8::Isolate::kPromiseConstructorReturnedUndefined);
@@ -1145,7 +1145,7 @@ TF_BUILTIN(IsPromise, PromiseBuiltinsAssembler) {
       SelectBooleanConstant(HasInstanceType(maybe_promise, JS_PROMISE_TYPE));
   Return(result);
 
-  Bind(&if_notpromise);
+  BIND(&if_notpromise);
   Return(FalseConstant());
 }
 
@@ -1191,7 +1191,7 @@ TF_BUILTIN(PromiseResolveClosure, PromiseBuiltinsAssembler) {
   InternalResolvePromise(context, promise, value);
   Return(UndefinedConstant());
 
-  Bind(&out);
+  BIND(&out);
   Return(UndefinedConstant());
 }
 
@@ -1217,13 +1217,13 @@ TF_BUILTIN(PromiseHandleReject, PromiseBuiltinsAssembler) {
   Label if_internalhandler(this), if_customhandler(this, Label::kDeferred);
   Branch(IsUndefined(on_reject), &if_internalhandler, &if_customhandler);
 
-  Bind(&if_internalhandler);
+  BIND(&if_internalhandler);
   {
     InternalPromiseReject(context, promise, exception, false);
     Return(UndefinedConstant());
   }
 
-  Bind(&if_customhandler);
+  BIND(&if_customhandler);
   {
     CallJS(call_callable, context, on_reject, UndefinedConstant(), exception);
     Return(UndefinedConstant());
@@ -1249,14 +1249,14 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {
   CallRuntime(Runtime::kDebugPushPromise, context, deferred_promise);
   Goto(&promisehook_before);
 
-  Bind(&promisehook_before);
+  BIND(&promisehook_before);
   {
     GotoIfNot(IsPromiseHookEnabledOrDebugIsActive(), &run_handler);
     CallRuntime(Runtime::kPromiseHookBefore, context, deferred_promise);
     Goto(&run_handler);
   }
 
-  Bind(&run_handler);
+  BIND(&run_handler);
   {
     Label if_defaulthandler(this), if_callablehandler(this),
         if_internalhandler(this), if_customhandler(this, Label::kDeferred);
@@ -1264,7 +1264,7 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {
 
     Branch(IsSymbol(handler), &if_defaulthandler, &if_callablehandler);
 
-    Bind(&if_defaulthandler);
+    BIND(&if_defaulthandler);
     {
       Label if_resolve(this), if_reject(this);
       Node* const default_resolve_handler_symbol = HeapConstant(
@@ -1272,21 +1272,21 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {
       Branch(WordEqual(default_resolve_handler_symbol, handler), &if_resolve,
              &if_reject);
 
-      Bind(&if_resolve);
+      BIND(&if_resolve);
       {
         var_result.Bind(value);
         Branch(IsUndefined(deferred_on_resolve), &if_internalhandler,
                &if_customhandler);
       }
 
-      Bind(&if_reject);
+      BIND(&if_reject);
       {
         var_reason.Bind(value);
         Goto(&if_rejectpromise);
       }
     }
 
-    Bind(&if_callablehandler);
+    BIND(&if_callablehandler);
     {
       Callable call_callable = CodeFactory::Call(isolate);
       Node* const result =
@@ -1297,11 +1297,11 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {
              &if_customhandler);
     }
 
-    Bind(&if_internalhandler);
+    BIND(&if_internalhandler);
     InternalResolvePromise(context, deferred_promise, var_result.value());
     Goto(&promisehook_after);
 
-    Bind(&if_customhandler);
+    BIND(&if_customhandler);
     {
       Callable call_callable = CodeFactory::Call(isolate);
       Node* const maybe_exception =
@@ -1312,7 +1312,7 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {
     }
   }
 
-  Bind(&if_rejectpromise);
+  BIND(&if_rejectpromise);
   {
     Callable promise_handle_reject = CodeFactory::PromiseHandleReject(isolate);
     CallStub(promise_handle_reject, context, deferred_promise,
@@ -1320,14 +1320,14 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {
     Goto(&promisehook_after);
   }
 
-  Bind(&promisehook_after);
+  BIND(&promisehook_after);
   {
     GotoIfNot(IsPromiseHookEnabledOrDebugIsActive(), &debug_pop);
     CallRuntime(Runtime::kPromiseHookAfter, context, deferred_promise);
     Goto(&debug_pop);
   }
 
-  Bind(&debug_pop);
+  BIND(&debug_pop);
   {
     Label out(this);
 
@@ -1335,7 +1335,7 @@ TF_BUILTIN(PromiseHandle, PromiseBuiltinsAssembler) {
     CallRuntime(Runtime::kDebugPopPromise, context);
     Goto(&out);
 
-    Bind(&out);
+    BIND(&out);
     Return(UndefinedConstant());
   }
 }
@@ -1353,14 +1353,14 @@ TF_BUILTIN(PromiseCatch, PromiseBuiltinsAssembler) {
   GotoIf(TaggedIsSmi(promise), &if_customthen);
   BranchIfFastPath(context, promise, &if_internalthen, &if_customthen);
 
-  Bind(&if_internalthen);
+  BIND(&if_internalthen);
   {
     Node* const result =
         InternalPromiseThen(context, promise, on_resolve, on_reject);
     Return(result);
   }
 
-  Bind(&if_customthen);
+  BIND(&if_customthen);
   {
     Node* const then =
         GetProperty(context, promise, isolate()->factory()->then_string());
@@ -1400,7 +1400,7 @@ TF_BUILTIN(PromiseResolve, PromiseBuiltinsAssembler) {
   BranchIfFastPath(native_context, promise_fun, value, &if_valueisnativepromise,
                    &if_valueisnotnativepromise);
 
-  Bind(&if_valueisnativepromise);
+  BIND(&if_valueisnativepromise);
   {
     GotoIfNot(WordEqual(promise_fun, receiver), &if_valueisnotnativepromise);
     Return(value);
@@ -1408,7 +1408,7 @@ TF_BUILTIN(PromiseResolve, PromiseBuiltinsAssembler) {
 
   // At this point, value or/and receiver are not native promises, but
   // they could be of the same subclass.
-  Bind(&if_valueisnotnativepromise);
+  BIND(&if_valueisnotnativepromise);
   {
     // 3.a Let xConstructor be ? Get(x, "constructor").
     // The constructor lookup is observable.
@@ -1421,7 +1421,7 @@ TF_BUILTIN(PromiseResolve, PromiseBuiltinsAssembler) {
     Return(value);
   }
 
-  Bind(&if_valueisnotpromise);
+  BIND(&if_valueisnotpromise);
   {
     Label if_nativepromise(this), if_notnativepromise(this);
     Branch(WordEqual(promise_fun, receiver), &if_nativepromise,
@@ -1429,14 +1429,14 @@ TF_BUILTIN(PromiseResolve, PromiseBuiltinsAssembler) {
 
     // This adds a fast path for native promises that don't need to
     // create NewPromiseCapability.
-    Bind(&if_nativepromise);
+    BIND(&if_nativepromise);
     {
       Node* const result = AllocateAndInitJSPromise(context);
       InternalResolvePromise(context, result, value);
       Return(result);
     }
 
-    Bind(&if_notnativepromise);
+    BIND(&if_notnativepromise);
     {
       // 4. Let promiseCapability be ? NewPromiseCapability(C).
       Node* const capability = NewPromiseCapability(context, receiver);
@@ -1478,7 +1478,7 @@ TF_BUILTIN(PromiseGetCapabilitiesExecutor, PromiseBuiltinsAssembler) {
 
   Return(UndefinedConstant());
 
-  Bind(&if_alreadyinvoked);
+  BIND(&if_alreadyinvoked);
   Node* message = SmiConstant(MessageTemplate::kPromiseExecutorAlreadyInvoked);
   CallRuntime(Runtime::kThrowTypeError, context, message);
   Unreachable();
@@ -1512,7 +1512,7 @@ TF_BUILTIN(PromiseReject, PromiseBuiltinsAssembler) {
   Branch(WordEqual(promise_fun, receiver), &if_nativepromise,
          &if_custompromise);
 
-  Bind(&if_nativepromise);
+  BIND(&if_nativepromise);
   {
     Node* const promise = AllocateAndSetJSPromise(
         context, SmiConstant(v8::Promise::kRejected), reason);
@@ -1521,7 +1521,7 @@ TF_BUILTIN(PromiseReject, PromiseBuiltinsAssembler) {
     Return(promise);
   }
 
-  Bind(&if_custompromise);
+  BIND(&if_custompromise);
   {
     // 3. Let promiseCapability be ? NewPromiseCapability(C).
     Node* const capability = NewPromiseCapability(context, receiver);
@@ -1727,7 +1727,7 @@ TF_BUILTIN(PromiseFinally, PromiseBuiltinsAssembler) {
   var_catch_finally.Bind(catch_finally);
   Goto(&perform_finally);
 
-  Bind(&if_notcallable);
+  BIND(&if_notcallable);
   {
     var_then_finally.Bind(on_finally);
     var_catch_finally.Bind(on_finally);
@@ -1736,11 +1736,11 @@ TF_BUILTIN(PromiseFinally, PromiseBuiltinsAssembler) {
 
   // 5. Return PerformPromiseThen(promise, valueThunk, undefined,
   // promiseCapability).
-  Bind(&perform_finally);
+  BIND(&perform_finally);
   Label if_nativepromise(this), if_custompromise(this, Label::kDeferred);
   BranchIfFastPath(context, promise, &if_nativepromise, &if_custompromise);
 
-  Bind(&if_nativepromise);
+  BIND(&if_nativepromise);
   {
     Node* deferred_promise = AllocateAndInitJSPromise(context, promise);
     InternalPerformPromiseThen(context, promise, var_then_finally.value(),
@@ -1749,7 +1749,7 @@ TF_BUILTIN(PromiseFinally, PromiseBuiltinsAssembler) {
     Return(deferred_promise);
   }
 
-  Bind(&if_custompromise);
+  BIND(&if_custompromise);
   {
     Node* const then =
         GetProperty(context, promise, isolate()->factory()->then_string());
diff --git a/src/builtins/builtins-regexp-gen.cc b/src/builtins/builtins-regexp-gen.cc
index d87fdf600d9..5e22b5f81ef 100644
--- a/src/builtins/builtins-regexp-gen.cc
+++ b/src/builtins/builtins-regexp-gen.cc
@@ -106,7 +106,7 @@ Node* RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(
   Label loop(this, 2, vars);
 
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* const from_cursor = var_from_cursor.value();
     Node* const to_cursor = var_to_cursor.value();
@@ -122,14 +122,14 @@ Node* RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(
     StoreFixedArrayElement(result_elements, to_cursor, capture);
     Goto(&next_iter);
 
-    Bind(&next_iter);
+    BIND(&next_iter);
     var_from_cursor.Bind(IntPtrAdd(from_cursor, IntPtrConstant(2)));
     var_to_cursor.Bind(IntPtrAdd(to_cursor, IntPtrConstant(1)));
     Branch(UintPtrLessThan(var_from_cursor.value(), limit), &loop,
            &named_captures);
   }
 
-  Bind(&named_captures);
+  BIND(&named_captures);
   {
     // We reach this point only if captures exist, implying that this is an
     // IRREGEXP JSRegExp.
@@ -184,7 +184,7 @@ Node* RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(
     Label loop(this, vars_count, vars);
 
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       Node* const i = var_i.value();
       Node* const i_plus_1 = IntPtrAdd(i, IntPtrConstant(1));
@@ -204,7 +204,7 @@ Node* RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(
     }
   }
 
-  Bind(&out);
+  BIND(&out);
   return result;
 }
 
@@ -322,7 +322,7 @@ Node* RegExpBuiltinsAssembler::IrregexpExec(Node* const context,
     Branch(IsOneByteStringInstanceType(to_direct.instance_type()),
            &if_isonebyte, &if_istwobyte);
 
-    Bind(&if_isonebyte);
+    BIND(&if_isonebyte);
     {
       GetStringPointers(direct_string_data, to_direct.offset(), int_last_index,
                         int_string_length, String::ONE_BYTE_ENCODING,
@@ -332,7 +332,7 @@ Node* RegExpBuiltinsAssembler::IrregexpExec(Node* const context,
       Goto(&next);
     }
 
-    Bind(&if_istwobyte);
+    BIND(&if_istwobyte);
     {
       GetStringPointers(direct_string_data, to_direct.offset(), int_last_index,
                         int_string_length, String::TWO_BYTE_ENCODING,
@@ -342,7 +342,7 @@ Node* RegExpBuiltinsAssembler::IrregexpExec(Node* const context,
       Goto(&next);
     }
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // Check that the irregexp code has been generated for the actual string
@@ -377,7 +377,7 @@ Node* RegExpBuiltinsAssembler::IrregexpExec(Node* const context,
     Goto(&runtime);
   }
 
-  Bind(&if_success);
+  BIND(&if_success);
   {
     // Check that the last match info has space for the capture registers and
     // the additional information. Ensure no overflow in add.
@@ -430,13 +430,13 @@ Node* RegExpBuiltinsAssembler::IrregexpExec(Node* const context,
     Goto(&out);
   }
 
-  Bind(&if_failure);
+  BIND(&if_failure);
   {
     var_result.Bind(NullConstant());
     Goto(&out);
   }
 
-  Bind(&if_exception);
+  BIND(&if_exception);
   {
     Node* const pending_exception =
         Load(MachineType::AnyTagged(), pending_exception_address);
@@ -447,16 +447,16 @@ Node* RegExpBuiltinsAssembler::IrregexpExec(Node* const context,
     Label stack_overflow(this), rethrow(this);
     Branch(IsTheHole(pending_exception), &stack_overflow, &rethrow);
 
-    Bind(&stack_overflow);
+    BIND(&stack_overflow);
     CallRuntime(Runtime::kThrowStackOverflow, context);
     Unreachable();
 
-    Bind(&rethrow);
+    BIND(&rethrow);
     CallRuntime(Runtime::kRegExpExecReThrow, context);
     Unreachable();
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     Node* const result = CallRuntime(Runtime::kRegExpExec, context, regexp,
                                      string, last_index, match_info);
@@ -464,7 +464,7 @@ Node* RegExpBuiltinsAssembler::IrregexpExec(Node* const context,
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 #endif  // V8_INTERPRETED_REGEXP
 }
@@ -509,14 +509,14 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
       Label call_tolength(this, Label::kDeferred), next(this);
       Branch(TaggedIsPositiveSmi(regexp_lastindex), &next, &call_tolength);
 
-      Bind(&call_tolength);
+      BIND(&call_tolength);
       {
         var_lastindex.Bind(
             CallBuiltin(Builtins::kToLength, context, regexp_lastindex));
         Goto(&next);
       }
 
-      Bind(&next);
+      BIND(&next);
     }
   }
 
@@ -534,7 +534,7 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
     Label if_doupdate(this), if_dontupdate(this);
     Branch(should_update_last_index, &if_doupdate, &if_dontupdate);
 
-    Bind(&if_doupdate);
+    BIND(&if_doupdate);
     {
       Node* const lastindex = var_lastindex.value();
 
@@ -544,7 +544,7 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
       GotoIfNot(SmiLessThanOrEqual(lastindex, string_length), &if_isoob);
       Goto(&run_exec);
 
-      Bind(&if_isoob);
+      BIND(&if_isoob);
       {
         StoreLastIndex(context, regexp, smi_zero, is_fastpath);
         var_result.Bind(null);
@@ -552,7 +552,7 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
       }
     }
 
-    Bind(&if_dontupdate);
+    BIND(&if_dontupdate);
     {
       var_lastindex.Bind(smi_zero);
       Goto(&run_exec);
@@ -561,7 +561,7 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
 
   Node* match_indices;
   Label successful_match(this);
-  Bind(&run_exec);
+  BIND(&run_exec);
   {
     // Get last match info from the context.
     Node* const native_context = LoadNativeContext(context);
@@ -583,7 +583,7 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
     Goto(if_didnotmatch);
   }
 
-  Bind(&successful_match);
+  BIND(&successful_match);
   {
     GotoIfNot(should_update_last_index, &out);
 
@@ -595,7 +595,7 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -622,13 +622,13 @@ Node* RegExpBuiltinsAssembler::RegExpPrototypeExecBody(Node* const context,
     Goto(&out);
   }
 
-  Bind(&if_didnotmatch);
+  BIND(&if_didnotmatch);
   {
     var_result.Bind(null);
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -647,7 +647,7 @@ Node* RegExpBuiltinsAssembler::ThrowIfNotJSReceiver(
   Branch(IsJSReceiverInstanceType(value_instance_type), &out, &throw_exception);
 
   // The {value} is not a compatible receiver for this method.
-  Bind(&throw_exception);
+  BIND(&throw_exception);
   {
     Node* const message_id = SmiConstant(Smi::FromInt(msg_template));
     Node* const method_name_str = HeapConstant(
@@ -661,7 +661,7 @@ Node* RegExpBuiltinsAssembler::ThrowIfNotJSReceiver(
     Unreachable();
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_value_map.value();
 }
 
@@ -687,7 +687,7 @@ Node* RegExpBuiltinsAssembler::IsFastRegExpNoPrototype(Node* const context,
   var_result.Bind(TaggedIsPositiveSmi(last_index));
   Goto(&out);
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -736,15 +736,15 @@ Node* RegExpBuiltinsAssembler::IsFastRegExp(Node* const context,
 
   BranchIfFastRegExp(context, object, map, &yup, &nope);
 
-  Bind(&yup);
+  BIND(&yup);
   var_result.Bind(Int32Constant(1));
   Goto(&out);
 
-  Bind(&nope);
+  BIND(&nope);
   var_result.Bind(Int32Constant(0));
   Goto(&out);
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -787,14 +787,14 @@ TF_BUILTIN(RegExpPrototypeExec, RegExpBuiltinsAssembler) {
   Branch(IsFastRegExpNoPrototype(context, receiver, regexp_map), &if_isfastpath,
          &if_isslowpath);
 
-  Bind(&if_isfastpath);
+  BIND(&if_isfastpath);
   {
     Node* const result =
         RegExpPrototypeExecBody(context, receiver, string, true);
     Return(result);
   }
 
-  Bind(&if_isslowpath);
+  BIND(&if_isslowpath);
   {
     Node* const result = CallBuiltin(Builtins::kRegExpPrototypeExecSlow,
                                      context, receiver, string);
@@ -829,7 +829,7 @@ Node* RegExpBuiltinsAssembler::FlagsGetter(Node* const context,
     GotoIfNot(IsSetWord(flags_intptr, FLAG), &next);         \
     var_length.Bind(IntPtrAdd(var_length.value(), int_one)); \
     Goto(&next);                                             \
-    Bind(&next);                                             \
+    BIND(&next);                                             \
   } while (false)
 
     CASE_FOR_FLAG(JSRegExp::kGlobal);
@@ -840,7 +840,7 @@ Node* RegExpBuiltinsAssembler::FlagsGetter(Node* const context,
       GotoIfNot(is_dotall_enabled, &next);
       CASE_FOR_FLAG(JSRegExp::kDotAll);
       Goto(&next);
-      Bind(&next);
+      BIND(&next);
     }
     CASE_FOR_FLAG(JSRegExp::kUnicode);
     CASE_FOR_FLAG(JSRegExp::kSticky);
@@ -858,11 +858,11 @@ Node* RegExpBuiltinsAssembler::FlagsGetter(Node* const context,
         context, regexp, isolate->factory()->InternalizeUtf8String(NAME)); \
     Label if_isflagset(this);                                              \
     BranchIfToBooleanIsTrue(flag, &if_isflagset, &next);                   \
-    Bind(&if_isflagset);                                                   \
+    BIND(&if_isflagset);                                                   \
     var_length.Bind(IntPtrAdd(var_length.value(), int_one));               \
     var_flags.Bind(WordOr(var_flags.value(), IntPtrConstant(FLAG)));       \
     Goto(&next);                                                           \
-    Bind(&next);                                                           \
+    BIND(&next);                                                           \
   } while (false)
 
     CASE_FOR_FLAG("global", JSRegExp::kGlobal);
@@ -873,7 +873,7 @@ Node* RegExpBuiltinsAssembler::FlagsGetter(Node* const context,
       GotoIfNot(is_dotall_enabled, &next);
       CASE_FOR_FLAG("dotAll", JSRegExp::kDotAll);
       Goto(&next);
-      Bind(&next);
+      BIND(&next);
     }
     CASE_FOR_FLAG("unicode", JSRegExp::kUnicode);
     CASE_FOR_FLAG("sticky", JSRegExp::kSticky);
@@ -900,7 +900,7 @@ Node* RegExpBuiltinsAssembler::FlagsGetter(Node* const context,
                         var_offset.value(), value);            \
     var_offset.Bind(IntPtrAdd(var_offset.value(), int_one));   \
     Goto(&next);                                               \
-    Bind(&next);                                               \
+    BIND(&next);                                               \
   } while (false)
 
     CASE_FOR_FLAG(JSRegExp::kGlobal, 'g');
@@ -911,7 +911,7 @@ Node* RegExpBuiltinsAssembler::FlagsGetter(Node* const context,
       GotoIfNot(is_dotall_enabled, &next);
       CASE_FOR_FLAG(JSRegExp::kDotAll, 's');
       Goto(&next);
-      Bind(&next);
+      BIND(&next);
     }
     CASE_FOR_FLAG(JSRegExp::kUnicode, 'u');
     CASE_FOR_FLAG(JSRegExp::kSticky, 'y');
@@ -941,18 +941,18 @@ Node* RegExpBuiltinsAssembler::IsRegExp(Node* const context,
     Label match_isundefined(this), match_isnotundefined(this);
     Branch(IsUndefined(value), &match_isundefined, &match_isnotundefined);
 
-    Bind(&match_isundefined);
+    BIND(&match_isundefined);
     Branch(HasInstanceType(receiver, JS_REGEXP_TYPE), &if_isregexp, &out);
 
-    Bind(&match_isnotundefined);
+    BIND(&match_isnotundefined);
     BranchIfToBooleanIsTrue(value, &if_isregexp, &out);
   }
 
-  Bind(&if_isregexp);
+  BIND(&if_isregexp);
   var_result.Bind(Int32Constant(1));
   Goto(&out);
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -994,10 +994,10 @@ TF_BUILTIN(RegExpPrototypeFlagsGetter, RegExpBuiltinsAssembler) {
   Branch(IsFastRegExpNoPrototype(context, receiver, map), &if_isfastpath,
          &if_isslowpath);
 
-  Bind(&if_isfastpath);
+  BIND(&if_isfastpath);
   Return(FlagsGetter(context, receiver, true));
 
-  Bind(&if_isslowpath);
+  BIND(&if_isslowpath);
   Return(FlagsGetter(context, receiver, false));
 }
 
@@ -1036,7 +1036,7 @@ TF_BUILTIN(RegExpConstructor, RegExpBuiltinsAssembler) {
     GotoIfNot(WordEqual(value, regexp_function), &next);
     Return(pattern);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   {
@@ -1048,7 +1048,7 @@ TF_BUILTIN(RegExpConstructor, RegExpBuiltinsAssembler) {
 
     Branch(pattern_is_regexp, &if_patternisslowregexp, &next);
 
-    Bind(&if_patternisfastregexp);
+    BIND(&if_patternisfastregexp);
     {
       Node* const source = LoadObjectField(pattern, JSRegExp::kSourceOffset);
       var_pattern.Bind(source);
@@ -1061,13 +1061,13 @@ TF_BUILTIN(RegExpConstructor, RegExpBuiltinsAssembler) {
         var_flags.Bind(value);
         Goto(&inner_next);
 
-        Bind(&inner_next);
+        BIND(&inner_next);
       }
 
       Goto(&next);
     }
 
-    Bind(&if_patternisslowregexp);
+    BIND(&if_patternisslowregexp);
     {
       {
         Node* const value =
@@ -1084,13 +1084,13 @@ TF_BUILTIN(RegExpConstructor, RegExpBuiltinsAssembler) {
         var_flags.Bind(value);
         Goto(&inner_next);
 
-        Bind(&inner_next);
+        BIND(&inner_next);
       }
 
       Goto(&next);
     }
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // Allocate.
@@ -1102,7 +1102,7 @@ TF_BUILTIN(RegExpConstructor, RegExpBuiltinsAssembler) {
     Branch(WordEqual(var_new_target.value(), regexp_function),
            &allocate_jsregexp, &allocate_generic);
 
-    Bind(&allocate_jsregexp);
+    BIND(&allocate_jsregexp);
     {
       Node* const initial_map = LoadObjectField(
           regexp_function, JSFunction::kPrototypeOrInitialMapOffset);
@@ -1111,7 +1111,7 @@ TF_BUILTIN(RegExpConstructor, RegExpBuiltinsAssembler) {
       Goto(&next);
     }
 
-    Bind(&allocate_generic);
+    BIND(&allocate_generic);
     {
       ConstructorBuiltinsAssembler constructor_assembler(this->state());
       Node* const regexp = constructor_assembler.EmitFastNewObject(
@@ -1120,7 +1120,7 @@ TF_BUILTIN(RegExpConstructor, RegExpBuiltinsAssembler) {
       Goto(&next);
     }
 
-    Bind(&next);
+    BIND(&next);
   }
 
   Node* const result = RegExpInitialize(context, var_regexp.value(),
@@ -1160,7 +1160,7 @@ TF_BUILTIN(RegExpPrototypeCompile, RegExpBuiltinsAssembler) {
       Node* const message_id = SmiConstant(MessageTemplate::kRegExpFlags);
       TailCallRuntime(Runtime::kThrowTypeError, context, message_id);
 
-      Bind(&next);
+      BIND(&next);
     }
 
     Node* const new_flags = FlagsGetter(context, pattern, true);
@@ -1170,7 +1170,7 @@ TF_BUILTIN(RegExpPrototypeCompile, RegExpBuiltinsAssembler) {
     var_pattern.Bind(new_pattern);
 
     Goto(&next);
-    Bind(&next);
+    BIND(&next);
   }
 
   Node* const result = RegExpInitialize(context, receiver, var_pattern.value(),
@@ -1191,13 +1191,13 @@ TF_BUILTIN(RegExpPrototypeSourceGetter, RegExpBuiltinsAssembler) {
   Branch(HasInstanceType(receiver, JS_REGEXP_TYPE), &if_isjsregexp,
          &if_isnotjsregexp);
 
-  Bind(&if_isjsregexp);
+  BIND(&if_isjsregexp);
   {
     Node* const source = LoadObjectField(receiver, JSRegExp::kSourceOffset);
     Return(source);
   }
 
-  Bind(&if_isnotjsregexp);
+  BIND(&if_isnotjsregexp);
   {
     Isolate* isolate = this->isolate();
     Node* const native_context = LoadNativeContext(context);
@@ -1211,7 +1211,7 @@ TF_BUILTIN(RegExpPrototypeSourceGetter, RegExpBuiltinsAssembler) {
     Branch(WordEqual(receiver, initial_prototype), &if_isprototype,
            &if_isnotprototype);
 
-    Bind(&if_isprototype);
+    BIND(&if_isprototype);
     {
       const int counter = v8::Isolate::kRegExpPrototypeSourceGetter;
       Node* const counter_smi = SmiConstant(counter);
@@ -1222,7 +1222,7 @@ TF_BUILTIN(RegExpPrototypeSourceGetter, RegExpBuiltinsAssembler) {
       Return(result);
     }
 
-    Bind(&if_isnotprototype);
+    BIND(&if_isnotprototype);
     {
       Node* const message_id =
           SmiConstant(Smi::FromInt(MessageTemplate::kRegExpNonRegExp));
@@ -1284,19 +1284,19 @@ Node* RegExpBuiltinsAssembler::SlowFlagGetter(Node* const context,
   Label if_true(this), if_false(this);
   BranchIfToBooleanIsTrue(value, &if_true, &if_false);
 
-  Bind(&if_true);
+  BIND(&if_true);
   {
     var_result.Bind(Int32Constant(1));
     Goto(&out);
   }
 
-  Bind(&if_false);
+  BIND(&if_false);
   {
     var_result.Bind(Int32Constant(0));
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -1325,14 +1325,14 @@ void RegExpBuiltinsAssembler::FlagGetter(Node* context, Node* receiver,
   Branch(Word32Equal(instance_type, Int32Constant(JS_REGEXP_TYPE)),
          &if_isunmodifiedjsregexp, &if_isnotunmodifiedjsregexp);
 
-  Bind(&if_isunmodifiedjsregexp);
+  BIND(&if_isunmodifiedjsregexp);
   {
     // Refer to JSRegExp's flag property on the fast-path.
     Node* const is_flag_set = FastFlagGetter(receiver, flag);
     Return(SelectBooleanConstant(is_flag_set));
   }
 
-  Bind(&if_isnotunmodifiedjsregexp);
+  BIND(&if_isnotunmodifiedjsregexp);
   {
     Node* const native_context = LoadNativeContext(context);
     Node* const regexp_fun =
@@ -1345,7 +1345,7 @@ void RegExpBuiltinsAssembler::FlagGetter(Node* context, Node* receiver,
     Branch(WordEqual(receiver, initial_prototype), &if_isprototype,
            &if_isnotprototype);
 
-    Bind(&if_isprototype);
+    BIND(&if_isprototype);
     {
       if (counter != -1) {
         Node* const counter_smi = SmiConstant(Smi::FromInt(counter));
@@ -1354,7 +1354,7 @@ void RegExpBuiltinsAssembler::FlagGetter(Node* context, Node* receiver,
       Return(UndefinedConstant());
     }
 
-    Bind(&if_isnotprototype);
+    BIND(&if_isnotprototype);
     {
       Node* const message_id =
           SmiConstant(Smi::FromInt(MessageTemplate::kRegExpNonRegExp));
@@ -1455,7 +1455,7 @@ Node* RegExpBuiltinsAssembler::RegExpExec(Node* context, Node* regexp,
   Node* const exec_map = LoadMap(exec);
   Branch(IsCallableMap(exec_map), &if_iscallable, &if_isnotcallable);
 
-  Bind(&if_iscallable);
+  BIND(&if_iscallable);
   {
     Callable call_callable = CodeFactory::Call(isolate());
     Node* const result = CallJS(call_callable, context, exec, regexp, string);
@@ -1469,7 +1469,7 @@ Node* RegExpBuiltinsAssembler::RegExpExec(Node* context, Node* regexp,
     Goto(&out);
   }
 
-  Bind(&if_isnotcallable);
+  BIND(&if_isnotcallable);
   {
     ThrowIfNotInstanceType(context, regexp, JS_REGEXP_TYPE,
                            "RegExp.prototype.exec");
@@ -1480,7 +1480,7 @@ Node* RegExpBuiltinsAssembler::RegExpExec(Node* context, Node* regexp,
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -1503,18 +1503,18 @@ TF_BUILTIN(RegExpPrototypeTest, RegExpBuiltinsAssembler) {
   Label fast_path(this), slow_path(this);
   BranchIfFastRegExp(context, receiver, map, &fast_path, &slow_path);
 
-  Bind(&fast_path);
+  BIND(&fast_path);
   {
     Label if_didnotmatch(this);
     RegExpPrototypeExecBodyWithoutResult(context, receiver, string,
                                          &if_didnotmatch, true);
     Return(TrueConstant());
 
-    Bind(&if_didnotmatch);
+    BIND(&if_didnotmatch);
     Return(FalseConstant());
   }
 
-  Bind(&slow_path);
+  BIND(&slow_path);
   {
     // Call exec.
     Node* const match_indices = RegExpExec(context, receiver, string);
@@ -1536,7 +1536,7 @@ Node* RegExpBuiltinsAssembler::AdvanceStringIndex(Node* const string,
   Label if_isunicode(this), out(this);
   Branch(is_unicode, &if_isunicode, &out);
 
-  Bind(&if_isunicode);
+  BIND(&if_isunicode);
   {
     Node* const string_length = LoadStringLength(string);
     GotoIfNot(SmiLessThan(index_plus_one, string_length), &out);
@@ -1558,7 +1558,7 @@ Node* RegExpBuiltinsAssembler::AdvanceStringIndex(Node* const string,
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -1593,7 +1593,7 @@ class GrowableFixedArray {
     Label grow(a), store(a);
     a->Branch(a->IntPtrEqual(capacity, length), &grow, &store);
 
-    a->Bind(&grow);
+    a->BIND(&grow);
     {
       Node* const new_capacity = NewCapacity(a, capacity);
       Node* const new_array = ResizeFixedArray(length, new_capacity);
@@ -1603,7 +1603,7 @@ class GrowableFixedArray {
       a->Goto(&store);
     }
 
-    a->Bind(&store);
+    a->BIND(&store);
     {
       Node* const array = var_array_.value();
       a->StoreFixedArrayElement(array, length, value);
@@ -1635,7 +1635,7 @@ class GrowableFixedArray {
       var_capacity_.Bind(length);
       a->Goto(&next);
 
-      a->Bind(&next);
+      a->BIND(&next);
     }
 
     Node* const result_length = a->SmiTag(length());
@@ -1728,7 +1728,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeMatchBody(Node* const context,
   Label if_isglobal(this), if_isnotglobal(this);
   Branch(is_global, &if_isglobal, &if_isnotglobal);
 
-  Bind(&if_isnotglobal);
+  BIND(&if_isnotglobal);
   {
     Node* const result =
         is_fastpath ? RegExpPrototypeExecBody(context, regexp, string, true)
@@ -1736,7 +1736,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeMatchBody(Node* const context,
     Return(result);
   }
 
-  Bind(&if_isglobal);
+  BIND(&if_isglobal);
   {
     Node* const is_unicode =
         FlagGetter(context, regexp, JSRegExp::kUnicode, is_fastpath);
@@ -1755,7 +1755,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeMatchBody(Node* const context,
     Label loop(this, 3, vars), out(this);
     Goto(&loop);
 
-    Bind(&loop);
+    BIND(&loop);
     {
       Variable var_match(this, MachineRepresentation::kTagged);
 
@@ -1782,13 +1782,13 @@ void RegExpBuiltinsAssembler::RegExpPrototypeMatchBody(Node* const context,
         Label load_match(this);
         Branch(WordEqual(result, null), &if_didnotmatch, &load_match);
 
-        Bind(&load_match);
+        BIND(&load_match);
         {
           Label fast_result(this), slow_result(this);
           BranchIfFastRegExpResult(context, LoadMap(result), &fast_result,
                                    &slow_result);
 
-          Bind(&fast_result);
+          BIND(&fast_result);
           {
             Node* const result_fixed_array = LoadElements(result);
             Node* const match = LoadFixedArrayElement(result_fixed_array, 0);
@@ -1800,7 +1800,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeMatchBody(Node* const context,
             Goto(&if_didmatch);
           }
 
-          Bind(&slow_result);
+          BIND(&slow_result);
           {
             // TODO(ishell): Use GetElement stub once it's available.
             Node* const match = GetProperty(context, result, smi_zero);
@@ -1810,14 +1810,14 @@ void RegExpBuiltinsAssembler::RegExpPrototypeMatchBody(Node* const context,
         }
       }
 
-      Bind(&if_didnotmatch);
+      BIND(&if_didnotmatch);
       {
         // Return null if there were no matches, otherwise just exit the loop.
         GotoIfNot(IntPtrEqual(array.length(), int_zero), &out);
         Return(null);
       }
 
-      Bind(&if_didmatch);
+      BIND(&if_didmatch);
       {
         Node* match = var_match.value();
 
@@ -1854,7 +1854,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeMatchBody(Node* const context,
       }
     }
 
-    Bind(&out);
+    BIND(&out);
     {
       // Wrap the match in a JSArray.
 
@@ -1883,10 +1883,10 @@ TF_BUILTIN(RegExpPrototypeMatch, RegExpBuiltinsAssembler) {
   Label fast_path(this), slow_path(this);
   BranchIfFastRegExp(context, receiver, map, &fast_path, &slow_path);
 
-  Bind(&fast_path);
+  BIND(&fast_path);
   RegExpPrototypeMatchBody(context, receiver, string, true);
 
-  Bind(&slow_path);
+  BIND(&slow_path);
   RegExpPrototypeMatchBody(context, receiver, string, false);
 }
 
@@ -1914,7 +1914,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSearchBodyFast(
     Return(index);
   }
 
-  Bind(&if_didnotmatch);
+  BIND(&if_didnotmatch);
   {
     // Reset last index and return -1.
     FastStoreLastIndex(regexp, previous_last_index);
@@ -1938,7 +1938,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSearchBodySlow(
 
     SlowStoreLastIndex(context, regexp, smi_zero);
     Goto(&next);
-    Bind(&next);
+    BIND(&next);
   }
 
   // Call exec.
@@ -1954,7 +1954,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSearchBodySlow(
     SlowStoreLastIndex(context, regexp, previous_last_index);
     Goto(&next);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // Return -1 if no match was found.
@@ -1962,7 +1962,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSearchBodySlow(
     Label next(this);
     GotoIfNot(WordEqual(exec_result, NullConstant()), &next);
     Return(SmiConstant(-1));
-    Bind(&next);
+    BIND(&next);
   }
 
   // Return the index of the match.
@@ -1971,14 +1971,14 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSearchBodySlow(
     BranchIfFastRegExpResult(context, LoadMap(exec_result), &fast_result,
                              &slow_result);
 
-    Bind(&fast_result);
+    BIND(&fast_result);
     {
       Node* const index =
           LoadObjectField(exec_result, JSRegExpResult::kIndexOffset);
       Return(index);
     }
 
-    Bind(&slow_result);
+    BIND(&slow_result);
     {
       Return(GetProperty(context, exec_result,
                          isolate->factory()->index_string()));
@@ -2005,10 +2005,10 @@ TF_BUILTIN(RegExpPrototypeSearch, RegExpBuiltinsAssembler) {
   Label fast_path(this), slow_path(this);
   BranchIfFastRegExp(context, receiver, map, &fast_path, &slow_path);
 
-  Bind(&fast_path);
+  BIND(&fast_path);
   RegExpPrototypeSearchBodyFast(context, receiver, string);
 
-  Bind(&slow_path);
+  BIND(&slow_path);
   RegExpPrototypeSearchBodySlow(context, receiver, string);
 }
 
@@ -2036,7 +2036,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
   {
     Label next(this), if_limitiszero(this, Label::kDeferred);
     Branch(SmiEqual(limit, smi_zero), &return_empty_array, &next);
-    Bind(&next);
+    BIND(&next);
   }
 
   Node* const string_length = LoadStringLength(string);
@@ -2047,7 +2047,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
     Label next(this), if_stringisempty(this, Label::kDeferred);
     Branch(SmiEqual(string_length, smi_zero), &if_stringisempty, &next);
 
-    Bind(&if_stringisempty);
+    BIND(&if_stringisempty);
     {
       Node* const last_match_info = LoadContextElement(
           native_context, Context::REGEXP_LAST_MATCH_INFO_INDEX);
@@ -2059,7 +2059,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
       Branch(WordEqual(match_indices, null), &return_singleton_array,
              &return_empty_array);
 
-      Bind(&return_singleton_array);
+      BIND(&return_singleton_array);
       {
         Node* const length = SmiConstant(1);
         Node* const capacity = IntPtrConstant(1);
@@ -2073,7 +2073,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
       }
     }
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // Loop preparations.
@@ -2093,7 +2093,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
   Label loop(this, vars_count, vars), push_suffix_and_out(this), out(this);
   Goto(&loop);
 
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* const next_search_from = var_next_search_from.value();
     Node* const last_matched_until = var_last_matched_until.value();
@@ -2103,7 +2103,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
       Label next(this);
       Branch(SmiEqual(next_search_from, string_length), &push_suffix_and_out,
              &next);
-      Bind(&next);
+      BIND(&next);
     }
 
     // Search for the given {regexp}.
@@ -2118,7 +2118,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
     {
       Label next(this);
       Branch(WordEqual(match_indices, null), &push_suffix_and_out, &next);
-      Bind(&next);
+      BIND(&next);
     }
 
     Node* const match_from = LoadFixedArrayElement(
@@ -2128,7 +2128,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
     {
       Label next(this);
       Branch(WordEqual(match_from, string_length), &push_suffix_and_out, &next);
-      Bind(&next);
+      BIND(&next);
     }
 
     Node* const match_to = LoadFixedArrayElement(
@@ -2147,7 +2147,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
       var_next_search_from.Bind(new_next_search_from);
       Goto(&loop);
 
-      Bind(&next);
+      BIND(&next);
     }
 
     // A valid match was found, add the new substring to the array.
@@ -2177,7 +2177,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
       Branch(IntPtrLessThan(var_reg.value(), int_num_registers), &nested_loop,
              &nested_loop_out);
 
-      Bind(&nested_loop);
+      BIND(&nested_loop);
       {
         Node* const reg = var_reg.value();
         Node* const from = LoadFixedArrayElement(
@@ -2192,21 +2192,21 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
         Branch(SmiEqual(to, SmiConstant(-1)), &select_undefined,
                &select_capture);
 
-        Bind(&select_capture);
+        BIND(&select_capture);
         {
           Node* const substr = SubString(context, string, from, to);
           var_value.Bind(substr);
           Goto(&store_value);
         }
 
-        Bind(&select_undefined);
+        BIND(&select_undefined);
         {
           Node* const undefined = UndefinedConstant();
           var_value.Bind(undefined);
           Goto(&store_value);
         }
 
-        Bind(&store_value);
+        BIND(&store_value);
         {
           array.Push(var_value.value());
           GotoIf(WordEqual(array.length(), int_limit), &out);
@@ -2219,7 +2219,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
         }
       }
 
-      Bind(&nested_loop_out);
+      BIND(&nested_loop_out);
     }
 
     var_last_matched_until.Bind(match_to);
@@ -2227,7 +2227,7 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
     Goto(&loop);
   }
 
-  Bind(&push_suffix_and_out);
+  BIND(&push_suffix_and_out);
   {
     Node* const from = var_last_matched_until.value();
     Node* const to = string_length;
@@ -2238,13 +2238,13 @@ void RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(Node* const context,
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   {
     Node* const result = array.ToJSArray(context);
     Return(result);
   }
 
-  Bind(&return_empty_array);
+  BIND(&return_empty_array);
   {
     Node* const length = smi_zero;
     Node* const capacity = int_zero;
@@ -2282,7 +2282,7 @@ TF_BUILTIN(RegExpSplit, RegExpBuiltinsAssembler) {
     Goto(&limit_done);
   }
 
-  Bind(&if_limitissmimax);
+  BIND(&if_limitissmimax);
   {
     // TODO(jgruber): In this case, we can probably avoid generation of limit
     // checks in Generate_RegExpPrototypeSplitBody.
@@ -2290,7 +2290,7 @@ TF_BUILTIN(RegExpSplit, RegExpBuiltinsAssembler) {
     Goto(&limit_done);
   }
 
-  Bind(&limit_done);
+  BIND(&limit_done);
   {
     Node* const limit = var_limit.value();
     RegExpPrototypeSplitBody(context, regexp, string, limit);
@@ -2317,11 +2317,11 @@ TF_BUILTIN(RegExpPrototypeSplit, RegExpBuiltinsAssembler) {
   Label stub(this), runtime(this, Label::kDeferred);
   BranchIfFastRegExp(context, receiver, map, &stub, &runtime);
 
-  Bind(&stub);
+  BIND(&stub);
   Return(CallBuiltin(Builtins::kRegExpSplit, context, receiver, string,
                      maybe_limit));
 
-  Bind(&runtime);
+  BIND(&runtime);
   Return(CallRuntime(Runtime::kRegExpSplit, context, receiver, string,
                      maybe_limit));
 }
@@ -2390,7 +2390,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
   Branch(SmiEqual(num_capture_registers, SmiConstant(Smi::FromInt(2))),
          &if_noexplicitcaptures, &if_hasexplicitcaptures);
 
-  Bind(&if_noexplicitcaptures);
+  BIND(&if_noexplicitcaptures);
   {
     // If the number of captures is two then there are no explicit captures in
     // the regexp, just the implicit capture that captures the whole match. In
@@ -2409,7 +2409,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
     Variable* vars[] = {&var_i, &var_match_start};
     Label loop(this, 2, vars);
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       Node* const i = var_i.value();
       GotoIfNot(IntPtrLessThan(i, end), &create_result);
@@ -2419,14 +2419,14 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
       Label if_issmi(this), if_isstring(this), loop_epilogue(this);
       Branch(TaggedIsSmi(elem), &if_issmi, &if_isstring);
 
-      Bind(&if_issmi);
+      BIND(&if_issmi);
       {
         // Integers represent slices of the original string.
         Label if_isnegativeorzero(this), if_ispositive(this);
         BranchIfSmiLessThanOrEqual(elem, smi_zero, &if_isnegativeorzero,
                                    &if_ispositive);
 
-        Bind(&if_ispositive);
+        BIND(&if_ispositive);
         {
           Node* const int_elem = SmiUntag(elem);
           Node* const new_match_start =
@@ -2436,7 +2436,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
           Goto(&loop_epilogue);
         }
 
-        Bind(&if_isnegativeorzero);
+        BIND(&if_isnegativeorzero);
         {
           Node* const next_i = IntPtrAdd(i, int_one);
           var_i.Bind(next_i);
@@ -2449,7 +2449,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
         }
       }
 
-      Bind(&if_isstring);
+      BIND(&if_isstring);
       {
         CSA_ASSERT(this, IsStringInstanceType(LoadInstanceType(elem)));
 
@@ -2469,7 +2469,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
         Goto(&loop_epilogue);
       }
 
-      Bind(&loop_epilogue);
+      BIND(&loop_epilogue);
       {
         var_i.Bind(IntPtrAdd(var_i.value(), int_one));
         Goto(&loop);
@@ -2477,7 +2477,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
     }
   }
 
-  Bind(&if_hasexplicitcaptures);
+  BIND(&if_hasexplicitcaptures);
   {
     Node* const from = int_zero;
     Node* const to = SmiUntag(res_length);
@@ -2515,7 +2515,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
                     StoreFixedArrayElement(res_elems, index, replacement_str);
 
                     Goto(&do_continue);
-                    Bind(&do_continue);
+                    BIND(&do_continue);
                   },
                   increment, CodeStubAssembler::INTPTR_PARAMETERS,
                   CodeStubAssembler::IndexAdvanceMode::kPost);
@@ -2523,7 +2523,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
     Goto(&create_result);
   }
 
-  Bind(&create_result);
+  BIND(&create_result);
   {
     Node* const result = CallRuntime(Runtime::kStringBuilderConcat, context,
                                      res, res_length, string);
@@ -2531,7 +2531,7 @@ Node* RegExpBuiltinsAssembler::ReplaceGlobalCallableFastPath(
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -2560,7 +2560,7 @@ Node* RegExpBuiltinsAssembler::ReplaceSimpleStringFastPath(
       WordAnd(SmiUntag(flags), IntPtrConstant(JSRegExp::kGlobal));
   Branch(WordEqual(is_global, int_zero), &if_isnonglobal, &if_isglobal);
 
-  Bind(&if_isglobal);
+  BIND(&if_isglobal);
   {
     // Hand off global regexps to runtime.
     FastStoreLastIndex(regexp, smi_zero);
@@ -2571,7 +2571,7 @@ Node* RegExpBuiltinsAssembler::ReplaceSimpleStringFastPath(
     Goto(&out);
   }
 
-  Bind(&if_isnonglobal);
+  BIND(&if_isnonglobal);
   {
     // Run exec, then manually construct the resulting string.
     Label if_didnotmatch(this);
@@ -2592,7 +2592,7 @@ Node* RegExpBuiltinsAssembler::ReplaceSimpleStringFastPath(
       Branch(SmiEqual(replace_length, smi_zero), &if_replaceisempty,
              &if_replaceisnotempty);
 
-      Bind(&if_replaceisempty);
+      BIND(&if_replaceisempty);
       {
         // TODO(jgruber): We could skip many of the checks that using SubString
         // here entails.
@@ -2607,7 +2607,7 @@ Node* RegExpBuiltinsAssembler::ReplaceSimpleStringFastPath(
         Goto(&out);
       }
 
-      Bind(&if_replaceisnotempty);
+      BIND(&if_replaceisnotempty);
       {
         Node* const first_part =
             SubString(context, string, subject_start, match_start);
@@ -2623,14 +2623,14 @@ Node* RegExpBuiltinsAssembler::ReplaceSimpleStringFastPath(
       }
     }
 
-    Bind(&if_didnotmatch);
+    BIND(&if_didnotmatch);
     {
       var_result.Bind(string);
       Goto(&out);
     }
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -2653,7 +2653,7 @@ TF_BUILTIN(RegExpReplace, RegExpBuiltinsAssembler) {
          &checkreplacestring);
 
   // 3. Does ToString({replace_value}) contain '$'?
-  Bind(&checkreplacestring);
+  BIND(&checkreplacestring);
   {
     Node* const replace_string =
         CallBuiltin(Builtins::kToString, context, replace_value);
@@ -2670,7 +2670,7 @@ TF_BUILTIN(RegExpReplace, RegExpBuiltinsAssembler) {
   }
 
   // {regexp} is unmodified and {replace_value} is callable.
-  Bind(&if_iscallable);
+  BIND(&if_iscallable);
   {
     Node* const replace_fn = replace_value;
 
@@ -2680,15 +2680,15 @@ TF_BUILTIN(RegExpReplace, RegExpBuiltinsAssembler) {
     Node* const is_global = FastFlagGetter(regexp, JSRegExp::kGlobal);
     Branch(is_global, &if_isglobal, &if_isnotglobal);
 
-    Bind(&if_isglobal);
+    BIND(&if_isglobal);
     Return(ReplaceGlobalCallableFastPath(context, regexp, string, replace_fn));
 
-    Bind(&if_isnotglobal);
+    BIND(&if_isnotglobal);
     Return(CallRuntime(Runtime::kStringReplaceNonGlobalRegExpWithFunction,
                        context, string, regexp, replace_fn));
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   Return(CallRuntime(Runtime::kRegExpReplace, context, regexp, string,
                      replace_value));
 }
@@ -2732,11 +2732,11 @@ TF_BUILTIN(RegExpPrototypeReplace, RegExpBuiltinsAssembler) {
   Label stub(this), runtime(this, Label::kDeferred);
   BranchIfFastRegExp(context, receiver, map, &stub, &runtime);
 
-  Bind(&stub);
+  BIND(&stub);
   Return(CallBuiltin(Builtins::kRegExpReplace, context, receiver, string,
                      replace_value));
 
-  Bind(&runtime);
+  BIND(&runtime);
   Return(CallRuntime(Runtime::kRegExpReplace, context, receiver, string,
                      replace_value));
 }
@@ -2761,10 +2761,10 @@ TF_BUILTIN(RegExpInternalMatch, RegExpBuiltinsAssembler) {
   Label if_matched(this), if_didnotmatch(this);
   Branch(WordEqual(match_indices, null), &if_didnotmatch, &if_matched);
 
-  Bind(&if_didnotmatch);
+  BIND(&if_didnotmatch);
   Return(null);
 
-  Bind(&if_matched);
+  BIND(&if_matched);
   {
     Node* result =
         ConstructNewResultFromMatchInfo(context, regexp, match_indices, string);
diff --git a/src/builtins/builtins-sharedarraybuffer-gen.cc b/src/builtins/builtins-sharedarraybuffer-gen.cc
index a3acbd55c89..04c2133c636 100644
--- a/src/builtins/builtins-sharedarraybuffer-gen.cc
+++ b/src/builtins/builtins-sharedarraybuffer-gen.cc
@@ -60,14 +60,14 @@ void SharedArrayBufferBuiltinsAssembler::ValidateSharedTypedArray(
                        Int32Constant(FIXED_FLOAT32_ARRAY_TYPE)),
          &not_float_or_clamped, &invalid);
 
-  Bind(&invalid);
+  BIND(&invalid);
   {
     CallRuntime(Runtime::kThrowNotIntegerSharedTypedArrayError, context,
                 tagged);
     Unreachable();
   }
 
-  Bind(&not_float_or_clamped);
+  BIND(&not_float_or_clamped);
   *out_instance_type = elements_instance_type;
 
   Node* backing_store =
@@ -94,13 +94,13 @@ Node* SharedArrayBufferBuiltinsAssembler::ConvertTaggedAtomicIndexToWord32(
   Label if_numberissmi(this), if_numberisnotsmi(this);
   Branch(TaggedIsSmi(*number_index), &if_numberissmi, &if_numberisnotsmi);
 
-  Bind(&if_numberissmi);
+  BIND(&if_numberissmi);
   {
     var_result.Bind(SmiToWord32(*number_index));
     Goto(&done);
   }
 
-  Bind(&if_numberisnotsmi);
+  BIND(&if_numberisnotsmi);
   {
     Node* number_index_value = LoadHeapNumberValue(*number_index);
     Node* access_index = TruncateFloat64ToWord32(number_index_value);
@@ -110,20 +110,20 @@ Node* SharedArrayBufferBuiltinsAssembler::ConvertTaggedAtomicIndexToWord32(
     Branch(Float64Equal(number_index_value, test_index), &if_indexesareequal,
            &if_indexesarenotequal);
 
-    Bind(&if_indexesareequal);
+    BIND(&if_indexesareequal);
     {
       var_result.Bind(access_index);
       Goto(&done);
     }
 
-    Bind(&if_indexesarenotequal);
+    BIND(&if_indexesarenotequal);
     {
       CallRuntime(Runtime::kThrowInvalidAtomicAccessIndexError, context);
       Unreachable();
     }
   }
 
-  Bind(&done);
+  BIND(&done);
   return var_result.value();
 }
 
@@ -136,7 +136,7 @@ void SharedArrayBufferBuiltinsAssembler::ValidateAtomicIndex(
   CallRuntime(Runtime::kThrowInvalidAtomicAccessIndexError, context);
   Unreachable();
 
-  Bind(&check_passed);
+  BIND(&check_passed);
 }
 
 TF_BUILTIN(AtomicsLoad, SharedArrayBufferBuiltinsAssembler) {
@@ -168,32 +168,32 @@ TF_BUILTIN(AtomicsLoad, SharedArrayBufferBuiltinsAssembler) {
   Switch(instance_type, &other, case_values, case_labels,
          arraysize(case_labels));
 
-  Bind(&i8);
+  BIND(&i8);
   Return(SmiFromWord32(
       AtomicLoad(MachineType::Int8(), backing_store, index_word)));
 
-  Bind(&u8);
+  BIND(&u8);
   Return(SmiFromWord32(
       AtomicLoad(MachineType::Uint8(), backing_store, index_word)));
 
-  Bind(&i16);
+  BIND(&i16);
   Return(SmiFromWord32(
       AtomicLoad(MachineType::Int16(), backing_store, WordShl(index_word, 1))));
 
-  Bind(&u16);
+  BIND(&u16);
   Return(SmiFromWord32(AtomicLoad(MachineType::Uint16(), backing_store,
                                   WordShl(index_word, 1))));
 
-  Bind(&i32);
+  BIND(&i32);
   Return(ChangeInt32ToTagged(
       AtomicLoad(MachineType::Int32(), backing_store, WordShl(index_word, 2))));
 
-  Bind(&u32);
+  BIND(&u32);
   Return(ChangeUint32ToTagged(AtomicLoad(MachineType::Uint32(), backing_store,
                                          WordShl(index_word, 2))));
 
   // This shouldn't happen, we've already validated the type.
-  Bind(&other);
+  BIND(&other);
   Unreachable();
 }
 
@@ -229,23 +229,23 @@ TF_BUILTIN(AtomicsStore, SharedArrayBufferBuiltinsAssembler) {
   Switch(instance_type, &other, case_values, case_labels,
          arraysize(case_labels));
 
-  Bind(&u8);
+  BIND(&u8);
   AtomicStore(MachineRepresentation::kWord8, backing_store, index_word,
               value_word32);
   Return(value_integer);
 
-  Bind(&u16);
+  BIND(&u16);
   AtomicStore(MachineRepresentation::kWord16, backing_store,
               WordShl(index_word, 1), value_word32);
   Return(value_integer);
 
-  Bind(&u32);
+  BIND(&u32);
   AtomicStore(MachineRepresentation::kWord32, backing_store,
               WordShl(index_word, 2), value_word32);
   Return(value_integer);
 
   // This shouldn't happen, we've already validated the type.
-  Bind(&other);
+  BIND(&other);
   Unreachable();
 }
 
@@ -288,34 +288,34 @@ TF_BUILTIN(AtomicsExchange, SharedArrayBufferBuiltinsAssembler) {
   Switch(instance_type, &other, case_values, case_labels,
          arraysize(case_labels));
 
-  Bind(&i8);
+  BIND(&i8);
   Return(SmiFromWord32(AtomicExchange(MachineType::Int8(), backing_store,
                                       index_word, value_word32)));
 
-  Bind(&u8);
+  BIND(&u8);
   Return(SmiFromWord32(AtomicExchange(MachineType::Uint8(), backing_store,
                                       index_word, value_word32)));
 
-  Bind(&i16);
+  BIND(&i16);
   Return(SmiFromWord32(AtomicExchange(MachineType::Int16(), backing_store,
                                       WordShl(index_word, 1), value_word32)));
 
-  Bind(&u16);
+  BIND(&u16);
   Return(SmiFromWord32(AtomicExchange(MachineType::Uint16(), backing_store,
                                       WordShl(index_word, 1), value_word32)));
 
-  Bind(&i32);
+  BIND(&i32);
   Return(ChangeInt32ToTagged(AtomicExchange(MachineType::Int32(), backing_store,
                                             WordShl(index_word, 2),
                                             value_word32)));
 
-  Bind(&u32);
+  BIND(&u32);
   Return(ChangeUint32ToTagged(
       AtomicExchange(MachineType::Uint32(), backing_store,
                      WordShl(index_word, 2), value_word32)));
 
   // This shouldn't happen, we've already validated the type.
-  Bind(&other);
+  BIND(&other);
   Unreachable();
 #endif  // V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64
 }
@@ -365,38 +365,38 @@ TF_BUILTIN(AtomicsCompareExchange, SharedArrayBufferBuiltinsAssembler) {
   Switch(instance_type, &other, case_values, case_labels,
          arraysize(case_labels));
 
-  Bind(&i8);
+  BIND(&i8);
   Return(SmiFromWord32(AtomicCompareExchange(MachineType::Int8(), backing_store,
                                              index_word, old_value_word32,
                                              new_value_word32)));
 
-  Bind(&u8);
+  BIND(&u8);
   Return(SmiFromWord32(
       AtomicCompareExchange(MachineType::Uint8(), backing_store, index_word,
                             old_value_word32, new_value_word32)));
 
-  Bind(&i16);
+  BIND(&i16);
   Return(SmiFromWord32(AtomicCompareExchange(
       MachineType::Int16(), backing_store, WordShl(index_word, 1),
       old_value_word32, new_value_word32)));
 
-  Bind(&u16);
+  BIND(&u16);
   Return(SmiFromWord32(AtomicCompareExchange(
       MachineType::Uint16(), backing_store, WordShl(index_word, 1),
       old_value_word32, new_value_word32)));
 
-  Bind(&i32);
+  BIND(&i32);
   Return(ChangeInt32ToTagged(AtomicCompareExchange(
       MachineType::Int32(), backing_store, WordShl(index_word, 2),
       old_value_word32, new_value_word32)));
 
-  Bind(&u32);
+  BIND(&u32);
   Return(ChangeUint32ToTagged(AtomicCompareExchange(
       MachineType::Uint32(), backing_store, WordShl(index_word, 2),
       old_value_word32, new_value_word32)));
 
   // This shouldn't happen, we've already validated the type.
-  Bind(&other);
+  BIND(&other);
   Unreachable();
 #endif  // V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_PPC64
         // || V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_S390 || V8_TARGET_ARCH_S390X
diff --git a/src/builtins/builtins-string-gen.cc b/src/builtins/builtins-string-gen.cc
index 46eb1f1937d..261e99f6424 100644
--- a/src/builtins/builtins-string-gen.cc
+++ b/src/builtins/builtins-string-gen.cc
@@ -50,7 +50,7 @@ class StringBuiltinsAssembler : public CodeStubAssembler {
       Goto(&if_join);
     }
 
-    Bind(&if_join);
+    BIND(&if_join);
     return var_data.value();
   }
 
@@ -165,7 +165,7 @@ void StringBuiltinsAssembler::GenerateStringEqual(Node* context, Node* left,
   Variable* input_vars[2] = {&var_left, &var_right};
   Label if_equal(this), if_notequal(this), restart(this, 2, input_vars);
   Goto(&restart);
-  Bind(&restart);
+  BIND(&restart);
   Node* lhs = var_left.value();
   Node* rhs = var_right.value();
 
@@ -213,7 +213,7 @@ void StringBuiltinsAssembler::GenerateStringEqual(Node* context, Node* left,
                      Int32Constant(kBothDirectOneByteStringTag)),
          &if_bothdirectonebytestrings, &if_notbothdirectonebytestrings);
 
-  Bind(&if_bothdirectonebytestrings);
+  BIND(&if_bothdirectonebytestrings);
   {
     // Compute the effective offset of the first character.
     Node* lhs_data = DirectStringData(lhs, lhs_instance_type);
@@ -227,7 +227,7 @@ void StringBuiltinsAssembler::GenerateStringEqual(Node* context, Node* left,
     Label loop(this, &var_offset);
     var_offset.Bind(IntPtrConstant(0));
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       // If {offset} equals {end}, no difference was found, so the
       // strings are equal.
@@ -247,7 +247,7 @@ void StringBuiltinsAssembler::GenerateStringEqual(Node* context, Node* left,
     }
   }
 
-  Bind(&if_notbothdirectonebytestrings);
+  BIND(&if_notbothdirectonebytestrings);
   {
     // Try to unwrap indirect strings, restart the above attempt on success.
     MaybeDerefIndirectStrings(&var_left, lhs_instance_type, &var_right,
@@ -257,10 +257,10 @@ void StringBuiltinsAssembler::GenerateStringEqual(Node* context, Node* left,
     TailCallRuntime(Runtime::kStringEqual, context, lhs, rhs);
   }
 
-  Bind(&if_equal);
+  BIND(&if_equal);
   Return(TrueConstant());
 
-  Bind(&if_notequal);
+  BIND(&if_notequal);
   Return(FalseConstant());
 }
 
@@ -273,7 +273,7 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
   Label if_less(this), if_equal(this), if_greater(this);
   Label restart(this, 2, input_vars);
   Goto(&restart);
-  Bind(&restart);
+  BIND(&restart);
 
   Node* lhs = var_left.value();
   Node* rhs = var_right.value();
@@ -302,7 +302,7 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
                      Int32Constant(kBothSeqOneByteStringTag)),
          &if_bothonebyteseqstrings, &if_notbothonebyteseqstrings);
 
-  Bind(&if_bothonebyteseqstrings);
+  BIND(&if_bothonebyteseqstrings);
   {
     // Load the length of {lhs} and {rhs}.
     Node* lhs_length = LoadStringLength(lhs);
@@ -323,14 +323,14 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
     Label loop(this, &var_offset);
     var_offset.Bind(begin);
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       // Check if {offset} equals {end}.
       Node* offset = var_offset.value();
       Label if_done(this), if_notdone(this);
       Branch(WordEqual(offset, end), &if_done, &if_notdone);
 
-      Bind(&if_notdone);
+      BIND(&if_notdone);
       {
         // Load the next characters from {lhs} and {rhs}.
         Node* lhs_value = Load(MachineType::Uint8(), lhs, offset);
@@ -341,18 +341,18 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
         Branch(Word32Equal(lhs_value, rhs_value), &if_valueissame,
                &if_valueisnotsame);
 
-        Bind(&if_valueissame);
+        BIND(&if_valueissame);
         {
           // Advance to next character.
           var_offset.Bind(IntPtrAdd(offset, IntPtrConstant(1)));
         }
         Goto(&loop);
 
-        Bind(&if_valueisnotsame);
+        BIND(&if_valueisnotsame);
         Branch(Uint32LessThan(lhs_value, rhs_value), &if_less, &if_greater);
       }
 
-      Bind(&if_done);
+      BIND(&if_done);
       {
         // All characters up to the min length are equal, decide based on
         // string length.
@@ -362,7 +362,7 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
     }
   }
 
-  Bind(&if_notbothonebyteseqstrings);
+  BIND(&if_notbothonebyteseqstrings);
   {
     // Try to unwrap indirect strings, restart the above attempt on success.
     MaybeDerefIndirectStrings(&var_left, lhs_instance_type, &var_right,
@@ -384,7 +384,7 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
     }
   }
 
-  Bind(&if_less);
+  BIND(&if_less);
   switch (mode) {
     case RelationalComparisonMode::kLessThan:
     case RelationalComparisonMode::kLessThanOrEqual:
@@ -397,7 +397,7 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
       break;
   }
 
-  Bind(&if_equal);
+  BIND(&if_equal);
   switch (mode) {
     case RelationalComparisonMode::kLessThan:
     case RelationalComparisonMode::kGreaterThan:
@@ -410,7 +410,7 @@ void StringBuiltinsAssembler::GenerateStringRelationalComparison(
       break;
   }
 
-  Bind(&if_greater);
+  BIND(&if_greater);
   switch (mode) {
     case RelationalComparisonMode::kLessThan:
     case RelationalComparisonMode::kLessThanOrEqual:
@@ -508,7 +508,7 @@ TF_BUILTIN(StringFromCharCode, CodeStubAssembler) {
   Branch(WordEqual(argc, IntPtrConstant(1)), &if_oneargument,
          &if_notoneargument);
 
-  Bind(&if_oneargument);
+  BIND(&if_oneargument);
   {
     // Single argument case, perform fast single character string cache lookup
     // for one-byte code units, or fall back to creating a single character
@@ -521,7 +521,7 @@ TF_BUILTIN(StringFromCharCode, CodeStubAssembler) {
   }
 
   Node* code16 = nullptr;
-  Bind(&if_notoneargument);
+  BIND(&if_notoneargument);
   {
     Label two_byte(this);
     // Assume that the resulting string contains only one-byte characters.
@@ -554,7 +554,7 @@ TF_BUILTIN(StringFromCharCode, CodeStubAssembler) {
     });
     arguments.PopAndReturn(one_byte_result);
 
-    Bind(&two_byte);
+    BIND(&two_byte);
 
     // At least one of the characters in the string requires a 16-bit
     // representation.  Allocate a SeqTwoByteString to hold the resulting
@@ -627,10 +627,10 @@ TF_BUILTIN(StringPrototypeCharAt, CodeStubAssembler) {
     Branch(SmiAboveOrEqual(position, receiver_length), &return_emptystring,
            &if_positioninbounds);
 
-    Bind(&return_emptystring);
+    BIND(&return_emptystring);
     Return(EmptyStringConstant());
 
-    Bind(&if_positioninbounds);
+    BIND(&if_positioninbounds);
   }
 
   // Load the character code at the {position} from the {receiver}.
@@ -666,10 +666,10 @@ TF_BUILTIN(StringPrototypeCharCodeAt, CodeStubAssembler) {
     Branch(SmiAboveOrEqual(position, receiver_length), &return_nan,
            &if_positioninbounds);
 
-    Bind(&return_nan);
+    BIND(&return_nan);
     Return(NaNConstant());
 
-    Bind(&if_positioninbounds);
+    BIND(&if_positioninbounds);
   }
 
   // Load the character at the {position} from the {receiver}.
@@ -744,14 +744,14 @@ void StringBuiltinsAssembler::StringIndexOf(
     DispatchOnStringInstanceType(instance_type, &if_onebyte_sequential,
                                  &if_onebyte_external, &call_runtime_unchecked);
 
-    Bind(&if_onebyte_sequential);
+    BIND(&if_onebyte_sequential);
     {
       var_string_addr.Bind(
           OneByteCharAddress(BitcastTaggedToWord(receiver), start_position));
       Goto(&check_search_string);
     }
 
-    Bind(&if_onebyte_external);
+    BIND(&if_onebyte_external);
     {
       Node* const unpacked = TryDerefExternalString(receiver, instance_type,
                                                     &call_runtime_unchecked);
@@ -761,7 +761,7 @@ void StringBuiltinsAssembler::StringIndexOf(
   }
 
   // Load the needle character.
-  Bind(&check_search_string);
+  BIND(&check_search_string);
   {
     Label if_onebyte_sequential(this);
     Label if_onebyte_external(this, Label::kDeferred);
@@ -770,14 +770,14 @@ void StringBuiltinsAssembler::StringIndexOf(
                                  &if_onebyte_sequential, &if_onebyte_external,
                                  &call_runtime_unchecked);
 
-    Bind(&if_onebyte_sequential);
+    BIND(&if_onebyte_sequential);
     {
       var_needle_byte.Bind(
           ChangeInt32ToIntPtr(LoadOneByteChar(search_string, int_zero)));
       Goto(&continue_fast_path);
     }
 
-    Bind(&if_onebyte_external);
+    BIND(&if_onebyte_external);
     {
       Node* const unpacked = TryDerefExternalString(
           search_string, search_string_instance_type, &call_runtime_unchecked);
@@ -787,7 +787,7 @@ void StringBuiltinsAssembler::StringIndexOf(
     }
   }
 
-  Bind(&continue_fast_path);
+  BIND(&continue_fast_path);
   {
     Node* needle_byte = var_needle_byte.value();
     Node* string_addr = var_string_addr.value();
@@ -806,16 +806,16 @@ void StringBuiltinsAssembler::StringIndexOf(
     f_return(SmiTag(result_index));
   }
 
-  Bind(&return_minus_1);
+  BIND(&return_minus_1);
   f_return(SmiConstant(-1));
 
-  Bind(&zero_length_needle);
+  BIND(&zero_length_needle);
   {
     Comment("0-length search_string");
     f_return(SmiTag(IntPtrMin(string_length, start_position)));
   }
 
-  Bind(&call_runtime_unchecked);
+  BIND(&call_runtime_unchecked);
   {
     // Simplified version of the runtime call where the types of the arguments
     // are already known due to type checks in this stub.
@@ -864,7 +864,7 @@ TF_BUILTIN(StringPrototypeIndexOf, StringBuiltinsAssembler) {
   GotoIf(IntPtrEqual(argc, IntPtrConstant(0)), &argc_0);
   GotoIf(IntPtrEqual(argc, IntPtrConstant(1)), &argc_1);
   Goto(&argc_2);
-  Bind(&argc_0);
+  BIND(&argc_0);
   {
     Comment("0 Argument case");
     Node* undefined = UndefinedConstant();
@@ -872,14 +872,14 @@ TF_BUILTIN(StringPrototypeIndexOf, StringBuiltinsAssembler) {
     position.Bind(undefined);
     Goto(&call_runtime);
   }
-  Bind(&argc_1);
+  BIND(&argc_1);
   {
     Comment("1 Argument case");
     search_string.Bind(arguments.AtIndex(0));
     position.Bind(SmiConstant(0));
     Goto(&fast_path);
   }
-  Bind(&argc_2);
+  BIND(&argc_2);
   {
     Comment("2 Argument case");
     search_string.Bind(arguments.AtIndex(0));
@@ -888,7 +888,7 @@ TF_BUILTIN(StringPrototypeIndexOf, StringBuiltinsAssembler) {
     Goto(&fast_path);
   }
 
-  Bind(&fast_path);
+  BIND(&fast_path);
   {
     Comment("Fast Path");
     GotoIf(TaggedIsSmi(receiver), &call_runtime);
@@ -906,7 +906,7 @@ TF_BUILTIN(StringPrototypeIndexOf, StringBuiltinsAssembler) {
         [&arguments](Node* result) { arguments.PopAndReturn(result); });
   }
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     Comment("Call Runtime");
     Node* result = CallRuntime(Runtime::kStringIndexOf, context, receiver,
@@ -925,12 +925,12 @@ void StringBuiltinsAssembler::RequireObjectCoercible(Node* const context,
   Label out(this), throw_exception(this, Label::kDeferred);
   Branch(IsNullOrUndefined(value), &throw_exception, &out);
 
-  Bind(&throw_exception);
+  BIND(&throw_exception);
   TailCallRuntime(
       Runtime::kThrowCalledOnNullOrUndefined, context,
       HeapConstant(factory()->NewStringFromAsciiChecked(method_name, TENURED)));
 
-  Bind(&out);
+  BIND(&out);
 }
 
 void StringBuiltinsAssembler::MaybeCallFunctionAtSymbol(
@@ -961,7 +961,7 @@ void StringBuiltinsAssembler::MaybeCallFunctionAtSymbol(
 
     Branch(WordEqual(proto_map, initial_proto_initial_map), &out, &next);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // Take the fast path for RegExps.
@@ -972,10 +972,10 @@ void StringBuiltinsAssembler::MaybeCallFunctionAtSymbol(
     regexp_asm.BranchIfFastRegExp(context, object, object_map, &stub_call,
                                   &slow_lookup);
 
-    Bind(&stub_call);
+    BIND(&stub_call);
     Return(regexp_call());
 
-    Bind(&slow_lookup);
+    BIND(&slow_lookup);
   }
 
   GotoIf(IsNullOrUndefined(object), &out);
@@ -990,7 +990,7 @@ void StringBuiltinsAssembler::MaybeCallFunctionAtSymbol(
   Node* const result = generic_call(maybe_func);
   Return(result);
 
-  Bind(&out);
+  BIND(&out);
 }
 
 // ES6 #sec-string.prototype.replace
@@ -1059,7 +1059,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
     Return(CallRuntime(Runtime::kStringReplaceOneCharWithString, context,
                        subject_string, search_string, replace));
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // TODO(jgruber): Extend StringIndexOf to handle two-byte strings and
@@ -1088,10 +1088,10 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
     CallStub(tostring_callable, context, replace);
     Goto(&return_subject);
 
-    Bind(&return_subject);
+    BIND(&return_subject);
     Return(subject_string);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   Node* const match_end_index = SmiAdd(match_start_index, search_length);
@@ -1113,7 +1113,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
     var_result.Bind(prefix);
 
     Goto(&next);
-    Bind(&next);
+    BIND(&next);
   }
 
   // Compute the string to replace with.
@@ -1123,7 +1123,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
   Branch(IsCallableMap(LoadMap(replace)), &if_iscallablereplace,
          &if_notcallablereplace);
 
-  Bind(&if_iscallablereplace);
+  BIND(&if_iscallablereplace);
   {
     Callable call_callable = CodeFactory::Call(isolate());
     Node* const replacement =
@@ -1136,7 +1136,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
     Goto(&out);
   }
 
-  Bind(&if_notcallablereplace);
+  BIND(&if_notcallablereplace);
   {
     Node* const replace_string = CallStub(tostring_callable, context, replace);
 
@@ -1151,7 +1151,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   {
     Node* const suffix = CallStub(substring_callable, context, subject_string,
                                   match_end_index, subject_length);
@@ -1221,7 +1221,7 @@ TF_BUILTIN(StringPrototypeSplit, StringBuiltinsAssembler) {
 
     Return(result);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // ECMA-262 says that if {separator} is undefined, the result should
@@ -1243,7 +1243,7 @@ TF_BUILTIN(StringPrototypeSplit, StringBuiltinsAssembler) {
 
     Return(result);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   // If the separator string is empty then return the elements in the subject.
@@ -1255,7 +1255,7 @@ TF_BUILTIN(StringPrototypeSplit, StringBuiltinsAssembler) {
                                      subject_string, limit_number);
     Return(result);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   Node* const result =
@@ -1292,7 +1292,7 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
     Label if_issmi(this), if_isheapnumber(this, Label::kDeferred);
     Branch(TaggedIsSmi(start_int), &if_issmi, &if_isheapnumber);
 
-    Bind(&if_issmi);
+    BIND(&if_issmi);
     {
       Node* const length_plus_start = SmiAdd(string_length, start_int);
       var_start.Bind(Select(SmiLessThan(start_int, zero),
@@ -1302,7 +1302,7 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
       Goto(&handle_length);
     }
 
-    Bind(&if_isheapnumber);
+    BIND(&if_isheapnumber);
     {
       // If {start} is a heap number, it is definitely out of bounds. If it is
       // negative, {start} = max({string_length} + {start}),0) = 0'. If it is
@@ -1317,7 +1317,7 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
   }
 
   // Conversions and bounds-checks for {length}.
-  Bind(&handle_length);
+  BIND(&handle_length);
   {
     Label if_issmi(this), if_isheapnumber(this, Label::kDeferred);
 
@@ -1327,11 +1327,11 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
       Branch(WordEqual(length, UndefinedConstant()), &if_isundefined,
              &if_isnotundefined);
 
-      Bind(&if_isundefined);
+      BIND(&if_isundefined);
       var_length.Bind(string_length);
       Goto(&if_issmi);
 
-      Bind(&if_isnotundefined);
+      BIND(&if_isnotundefined);
       var_length.Bind(
           ToInteger(context, length, CodeStubAssembler::kTruncateMinusZero));
     }
@@ -1339,7 +1339,7 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
     Branch(TaggedIsSmi(var_length.value()), &if_issmi, &if_isheapnumber);
 
     // Set {length} to min(max({length}, 0), {string_length} - {start}
-    Bind(&if_issmi);
+    BIND(&if_issmi);
     {
       Node* const positive_length = SmiMax(var_length.value(), zero);
 
@@ -1350,7 +1350,7 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
       Return(EmptyStringConstant());
     }
 
-    Bind(&if_isheapnumber);
+    BIND(&if_isheapnumber);
     {
       // If {length} is a heap number, it is definitely out of bounds. There are
       // two cases according to the spec: if it is negative, "" is returned; if
@@ -1364,10 +1364,10 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
       Branch(Float64LessThan(length_float, float_zero), &if_isnegative,
              &if_ispositive);
 
-      Bind(&if_isnegative);
+      BIND(&if_isnegative);
       Return(EmptyStringConstant());
 
-      Bind(&if_ispositive);
+      BIND(&if_ispositive);
       {
         var_length.Bind(SmiSub(string_length, var_start.value()));
         GotoIfNot(SmiLessThanOrEqual(var_length.value(), zero), &out);
@@ -1376,7 +1376,7 @@ TF_BUILTIN(StringPrototypeSubstr, CodeStubAssembler) {
     }
   }
 
-  Bind(&out);
+  BIND(&out);
   {
     Node* const end = SmiAdd(var_start.value(), var_length.value());
     Node* const result = SubString(context, string, var_start.value(), end);
@@ -1396,18 +1396,18 @@ compiler::Node* StringBuiltinsAssembler::ToSmiBetweenZeroAnd(Node* context,
   Label if_issmi(this), if_isnotsmi(this, Label::kDeferred);
   Branch(TaggedIsSmi(value_int), &if_issmi, &if_isnotsmi);
 
-  Bind(&if_issmi);
+  BIND(&if_issmi);
   {
     Label if_isinbounds(this), if_isoutofbounds(this, Label::kDeferred);
     Branch(SmiAbove(value_int, limit), &if_isoutofbounds, &if_isinbounds);
 
-    Bind(&if_isinbounds);
+    BIND(&if_isinbounds);
     {
       var_result.Bind(value_int);
       Goto(&out);
     }
 
-    Bind(&if_isoutofbounds);
+    BIND(&if_isoutofbounds);
     {
       Node* const zero = SmiConstant(Smi::kZero);
       var_result.Bind(
@@ -1416,7 +1416,7 @@ compiler::Node* StringBuiltinsAssembler::ToSmiBetweenZeroAnd(Node* context,
     }
   }
 
-  Bind(&if_isnotsmi);
+  BIND(&if_isnotsmi);
   {
     // {value} is a heap number - in this case, it is definitely out of bounds.
     CSA_ASSERT(this, IsHeapNumberMap(LoadMap(value_int)));
@@ -1429,7 +1429,7 @@ compiler::Node* StringBuiltinsAssembler::ToSmiBetweenZeroAnd(Node* context,
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -1465,7 +1465,7 @@ TF_BUILTIN(StringPrototypeSubstring, StringBuiltinsAssembler) {
     Branch(SmiLessThan(var_end.value(), var_start.value()),
            &if_endislessthanstart, &out);
 
-    Bind(&if_endislessthanstart);
+    BIND(&if_endislessthanstart);
     {
       Node* const tmp = var_end.value();
       var_end.Bind(var_start.value());
@@ -1474,7 +1474,7 @@ TF_BUILTIN(StringPrototypeSubstring, StringBuiltinsAssembler) {
     }
   }
 
-  Bind(&out);
+  BIND(&out);
   {
     Node* result =
         SubString(context, string, var_start.value(), var_end.value());
@@ -1548,7 +1548,7 @@ compiler::Node* StringBuiltinsAssembler::LoadSurrogatePairAt(
                      Int32Constant(0xDC00)),
          &handle_surrogate_pair, &return_result);
 
-  Bind(&handle_surrogate_pair);
+  BIND(&handle_surrogate_pair);
   {
     Node* lead = var_result.value();
     Node* trail = var_trail.value();
@@ -1587,7 +1587,7 @@ compiler::Node* StringBuiltinsAssembler::LoadSurrogatePairAt(
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
@@ -1616,7 +1616,7 @@ TF_BUILTIN(StringIteratorPrototypeNext, StringBuiltinsAssembler) {
 
   Branch(SmiLessThan(position, length), &next_codepoint, &return_result);
 
-  Bind(&next_codepoint);
+  BIND(&next_codepoint);
   {
     UnicodeEncoding encoding = UnicodeEncoding::UTF16;
     Node* ch = LoadSurrogatePairAt(string, length, position, encoding);
@@ -1629,7 +1629,7 @@ TF_BUILTIN(StringIteratorPrototypeNext, StringBuiltinsAssembler) {
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   {
     Node* native_context = LoadNativeContext(context);
     Node* map =
@@ -1647,7 +1647,7 @@ TF_BUILTIN(StringIteratorPrototypeNext, StringBuiltinsAssembler) {
     Return(result);
   }
 
-  Bind(&throw_bad_receiver);
+  BIND(&throw_bad_receiver);
   {
     // The {receiver} is not a valid JSGeneratorObject.
     CallRuntime(Runtime::kThrowIncompatibleMethodReceiver, context,
diff --git a/src/builtins/builtins-typedarray-gen.cc b/src/builtins/builtins-typedarray-gen.cc
index 015df5c5cd1..26a5c193a24 100644
--- a/src/builtins/builtins-typedarray-gen.cc
+++ b/src/builtins/builtins-typedarray-gen.cc
@@ -81,9 +81,9 @@ void TypedArrayBuiltinsAssembler::LoadMapAndElementsSize(Node* const array,
     }
   }
 
-  Bind(&unreachable);
+  BIND(&unreachable);
   { Unreachable(); }
-  Bind(&done);
+  BIND(&done);
 }
 
 // The byte_offset can be higher than Smi range, in which case to perform the
@@ -128,7 +128,7 @@ void TypedArrayBuiltinsAssembler::DoInitialize(Node* const holder, Node* length,
   CSA_ASSERT(this, TaggedIsSmi(byte_length));
   Goto(&setup_holder);
 
-  Bind(&setup_holder);
+  BIND(&setup_holder);
   {
     LoadMapAndElementsSize(holder, &fixed_typed_map, &element_size);
     // Setup the holder (JSArrayBufferView).
@@ -148,7 +148,7 @@ void TypedArrayBuiltinsAssembler::DoInitialize(Node* const holder, Node* length,
     Branch(IsNull(maybe_buffer), &alloc_array_buffer, &attach_buffer);
   }
 
-  Bind(&alloc_array_buffer);
+  BIND(&alloc_array_buffer);
   {
     // Allocate a new ArrayBuffer and initialize it with empty properties and
     // elements.
@@ -202,14 +202,14 @@ void TypedArrayBuiltinsAssembler::DoInitialize(Node* const holder, Node* length,
     Goto(&allocate_elements);
   }
 
-  Bind(&aligned);
+  BIND(&aligned);
   {
     Node* header_size = IntPtrConstant(FixedTypedArrayBase::kHeaderSize);
     total_size.Bind(IntPtrAdd(SmiToWord(byte_length), header_size));
     Goto(&allocate_elements);
   }
 
-  Bind(&allocate_elements);
+  BIND(&allocate_elements);
   {
     // Allocate a FixedTypedArray and set the length, base pointer and external
     // pointer.
@@ -240,7 +240,7 @@ void TypedArrayBuiltinsAssembler::DoInitialize(Node* const holder, Node* length,
     Goto(&done);
   }
 
-  Bind(&attach_buffer);
+  BIND(&attach_buffer);
   {
     StoreObjectField(holder, JSArrayBufferView::kBufferOffset, maybe_buffer);
 
@@ -264,7 +264,7 @@ void TypedArrayBuiltinsAssembler::DoInitialize(Node* const holder, Node* length,
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
 }
 
 TF_BUILTIN(TypedArrayInitialize, TypedArrayBuiltinsAssembler) {
@@ -300,7 +300,7 @@ void TypedArrayBuiltinsAssembler::InitializeBasedOnLength(
                             SmiConstant(FLAG_typed_array_max_size_in_heap)),
          &do_init, &allocate_buffer);
 
-  Bind(&allocate_buffer);
+  BIND(&allocate_buffer);
   {
     Node* const buffer_constructor = LoadContextElement(
         LoadNativeContext(context), Context::ARRAY_BUFFER_FUN_INDEX);
@@ -309,7 +309,7 @@ void TypedArrayBuiltinsAssembler::InitializeBasedOnLength(
     Goto(&do_init);
   }
 
-  Bind(&do_init);
+  BIND(&do_init);
   {
     DoInitialize(holder, length, maybe_buffer.value(), byte_offset, byte_length,
                  initialize, context);
@@ -340,7 +340,7 @@ TF_BUILTIN(TypedArrayConstructByLength, TypedArrayBuiltinsAssembler) {
                           context);
   Return(UndefinedConstant());
 
-  Bind(&invalid_length);
+  BIND(&invalid_length);
   {
     CallRuntime(Runtime::kThrowRangeError, context,
                 SmiConstant(MessageTemplate::kInvalidTypedArrayLength));
@@ -385,7 +385,7 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
   Branch(TaggedIsSmi(offset.value()), &offset_is_smi, &offset_not_smi);
 
   // Check that the offset is a multiple of the element size.
-  Bind(&offset_is_smi);
+  BIND(&offset_is_smi);
   {
     GotoIf(SmiEqual(offset.value(), SmiConstant(0)), &check_length);
     GotoIf(SmiLessThan(offset.value(), SmiConstant(0)), &invalid_length);
@@ -393,7 +393,7 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
     Branch(SmiEqual(remainder, SmiConstant(0)), &check_length,
            &start_offset_error);
   }
-  Bind(&offset_not_smi);
+  BIND(&offset_not_smi);
   {
     GotoIf(IsTrue(CallStub(less_than, context, offset.value(), SmiConstant(0))),
            &invalid_length);
@@ -403,11 +403,11 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
            &check_length, &start_offset_error);
   }
 
-  Bind(&check_length);
+  BIND(&check_length);
   // TODO(petermarshall): Throw on detached typedArray.
   Branch(IsUndefined(length), &length_undefined, &length_defined);
 
-  Bind(&length_undefined);
+  BIND(&length_undefined);
   {
     Node* buffer_byte_length =
         LoadObjectField(buffer, JSArrayBuffer::kByteLengthOffset);
@@ -425,7 +425,7 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
            &invalid_offset_error, &call_init);
   }
 
-  Bind(&length_defined);
+  BIND(&length_defined);
   {
     Node* new_length = ToSmiIndex(length, context, &invalid_length);
     new_byte_length.Bind(SmiMul(new_length, element_size));
@@ -440,7 +440,7 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
            &invalid_length, &call_init);
   }
 
-  Bind(&call_init);
+  BIND(&call_init);
   {
     Node* new_length =
         CallStub(div, context, new_byte_length.value(), element_size);
@@ -452,14 +452,14 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
     Return(UndefinedConstant());
   }
 
-  Bind(&invalid_offset_error);
+  BIND(&invalid_offset_error);
   {
     CallRuntime(Runtime::kThrowRangeError, context,
                 SmiConstant(MessageTemplate::kInvalidOffset), byte_offset);
     Unreachable();
   }
 
-  Bind(&start_offset_error);
+  BIND(&start_offset_error);
   {
     Node* holder_map = LoadMap(holder);
     Node* problem_string = HeapConstant(
@@ -470,7 +470,7 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
     Unreachable();
   }
 
-  Bind(&byte_length_error);
+  BIND(&byte_length_error);
   {
     Node* holder_map = LoadMap(holder);
     Node* problem_string = HeapConstant(
@@ -481,7 +481,7 @@ TF_BUILTIN(TypedArrayConstructByArrayBuffer, TypedArrayBuiltinsAssembler) {
     Unreachable();
   }
 
-  Bind(&invalid_length);
+  BIND(&invalid_length);
   {
     CallRuntime(Runtime::kThrowRangeError, context,
                 SmiConstant(MessageTemplate::kInvalidTypedArrayLength));
@@ -513,12 +513,12 @@ compiler::Node* TypedArrayBuiltinsAssembler::ByteLengthIsValid(
   is_valid.Bind(Float64LessThanOrEqual(float_value, max_byte_length_double));
   Goto(&done);
 
-  Bind(&smi);
+  BIND(&smi);
   Node* max_byte_length = IntPtrConstant(FixedTypedArrayBase::kMaxByteLength);
   is_valid.Bind(UintPtrLessThanOrEqual(SmiUntag(byte_length), max_byte_length));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
   return is_valid.value();
 }
 
@@ -543,7 +543,7 @@ TF_BUILTIN(TypedArrayConstructByArrayLike, TypedArrayBuiltinsAssembler) {
   GotoIf(SmiNotEqual(length, SmiConstant(0)), &fill);
   Return(UndefinedConstant());
 
-  Bind(&fill);
+  BIND(&fill);
   Node* holder_kind = LoadMapElementsKind(LoadMap(holder));
   Node* source_kind = LoadMapElementsKind(LoadMap(array_like));
   GotoIf(Word32Equal(holder_kind, source_kind), &fast_copy);
@@ -556,7 +556,7 @@ TF_BUILTIN(TypedArrayConstructByArrayLike, TypedArrayBuiltinsAssembler) {
          array_like, length, SmiConstant(0));
   Return(UndefinedConstant());
 
-  Bind(&fast_copy);
+  BIND(&fast_copy);
   {
     Node* holder_data_ptr = LoadDataPtr(holder);
     Node* source_data_ptr = LoadDataPtr(array_like);
@@ -583,7 +583,7 @@ TF_BUILTIN(TypedArrayConstructByArrayLike, TypedArrayBuiltinsAssembler) {
     Return(UndefinedConstant());
   }
 
-  Bind(&invalid_length);
+  BIND(&invalid_length);
   {
     CallRuntime(Runtime::kThrowRangeError, context,
                 SmiConstant(MessageTemplate::kInvalidTypedArrayLength));
@@ -606,13 +606,13 @@ void TypedArrayBuiltinsAssembler::GenerateTypedArrayPrototypeGetter(
   GotoIf(IsDetachedBuffer(receiver_buffer), &if_receiverisneutered);
   Return(LoadObjectField(receiver, object_offset));
 
-  Bind(&if_receiverisneutered);
+  BIND(&if_receiverisneutered);
   {
     // The {receiver}s buffer was neutered, default to zero.
     Return(SmiConstant(0));
   }
 
-  Bind(&receiver_is_incompatible);
+  BIND(&receiver_is_incompatible);
   {
     // The {receiver} is not a valid JSTypedArray.
     CallRuntime(Runtime::kThrowIncompatibleMethodReceiver, context,
@@ -673,16 +673,16 @@ void TypedArrayBuiltinsAssembler::GenerateTypedArrayPrototypeIterationMethod(
                              iteration_kind));
 
   Variable var_message(this, MachineRepresentation::kTagged);
-  Bind(&throw_bad_receiver);
+  BIND(&throw_bad_receiver);
   var_message.Bind(SmiConstant(MessageTemplate::kNotTypedArray));
   Goto(&throw_typeerror);
 
-  Bind(&if_receiverisneutered);
+  BIND(&if_receiverisneutered);
   var_message.Bind(
       SmiConstant(Smi::FromInt(MessageTemplate::kDetachedOperation)));
   Goto(&throw_typeerror);
 
-  Bind(&throw_typeerror);
+  BIND(&throw_typeerror);
   {
     Node* method_arg = HeapConstant(
         isolate()->factory()->NewStringFromAsciiChecked(method_name, TENURED));
diff --git a/src/code-stub-assembler.cc b/src/code-stub-assembler.cc
index 0fff014eb50..b366de13a19 100644
--- a/src/code-stub-assembler.cc
+++ b/src/code-stub-assembler.cc
@@ -58,7 +58,7 @@ void CodeStubAssembler::Assert(const NodeGenerator& codition_body,
     Node* condition = codition_body();
     DCHECK_NOT_NULL(condition);
     Branch(condition, &ok, &not_ok);
-    Bind(&not_ok);
+    BIND(&not_ok);
     if (message != nullptr) {
       char chars[1024];
       Vector<char> buffer(chars);
@@ -74,7 +74,7 @@ void CodeStubAssembler::Assert(const NodeGenerator& codition_body,
     }
     DebugBreak();
     Goto(&ok);
-    Bind(&ok);
+    BIND(&ok);
     Comment("] Assert");
   }
 #endif
@@ -87,18 +87,18 @@ Node* CodeStubAssembler::Select(Node* condition, const NodeGenerator& true_body,
   Label vtrue(this), vfalse(this), end(this);
   Branch(condition, &vtrue, &vfalse);
 
-  Bind(&vtrue);
+  BIND(&vtrue);
   {
     value.Bind(true_body());
     Goto(&end);
   }
-  Bind(&vfalse);
+  BIND(&vfalse);
   {
     value.Bind(false_body());
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return value.value();
 }
 
@@ -219,7 +219,7 @@ Node* CodeStubAssembler::Float64Round(Node* x) {
   var_x.Bind(Float64Sub(var_x.value(), one));
   Goto(&return_x);
 
-  Bind(&return_x);
+  BIND(&return_x);
   return var_x.value();
 }
 
@@ -241,7 +241,7 @@ Node* CodeStubAssembler::Float64Ceil(Node* x) {
   Branch(Float64GreaterThan(x, zero), &if_xgreaterthanzero,
          &if_xnotgreaterthanzero);
 
-  Bind(&if_xgreaterthanzero);
+  BIND(&if_xgreaterthanzero);
   {
     // Just return {x} unless it's in the range ]0,2^52[.
     GotoIf(Float64GreaterThanOrEqual(x, two_52), &return_x);
@@ -253,7 +253,7 @@ Node* CodeStubAssembler::Float64Ceil(Node* x) {
     Goto(&return_x);
   }
 
-  Bind(&if_xnotgreaterthanzero);
+  BIND(&if_xnotgreaterthanzero);
   {
     // Just return {x} unless it's in the range ]-2^52,0[
     GotoIf(Float64LessThanOrEqual(x, minus_two_52), &return_x);
@@ -267,11 +267,11 @@ Node* CodeStubAssembler::Float64Ceil(Node* x) {
     Goto(&return_minus_x);
   }
 
-  Bind(&return_minus_x);
+  BIND(&return_minus_x);
   var_x.Bind(Float64Neg(var_x.value()));
   Goto(&return_x);
 
-  Bind(&return_x);
+  BIND(&return_x);
   return var_x.value();
 }
 
@@ -293,7 +293,7 @@ Node* CodeStubAssembler::Float64Floor(Node* x) {
   Branch(Float64GreaterThan(x, zero), &if_xgreaterthanzero,
          &if_xnotgreaterthanzero);
 
-  Bind(&if_xgreaterthanzero);
+  BIND(&if_xgreaterthanzero);
   {
     // Just return {x} unless it's in the range ]0,2^52[.
     GotoIf(Float64GreaterThanOrEqual(x, two_52), &return_x);
@@ -305,7 +305,7 @@ Node* CodeStubAssembler::Float64Floor(Node* x) {
     Goto(&return_x);
   }
 
-  Bind(&if_xnotgreaterthanzero);
+  BIND(&if_xnotgreaterthanzero);
   {
     // Just return {x} unless it's in the range ]-2^52,0[
     GotoIf(Float64LessThanOrEqual(x, minus_two_52), &return_x);
@@ -319,11 +319,11 @@ Node* CodeStubAssembler::Float64Floor(Node* x) {
     Goto(&return_minus_x);
   }
 
-  Bind(&return_minus_x);
+  BIND(&return_minus_x);
   var_x.Bind(Float64Neg(var_x.value()));
   Goto(&return_x);
 
-  Bind(&return_x);
+  BIND(&return_x);
   return var_x.value();
 }
 
@@ -346,15 +346,15 @@ Node* CodeStubAssembler::Float64RoundToEven(Node* x) {
            &return_f_plus_one);
   }
 
-  Bind(&return_f);
+  BIND(&return_f);
   var_result.Bind(f);
   Goto(&done);
 
-  Bind(&return_f_plus_one);
+  BIND(&return_f_plus_one);
   var_result.Bind(Float64Add(f, Float64Constant(1.0)));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
   return var_result.value();
 }
 
@@ -376,7 +376,7 @@ Node* CodeStubAssembler::Float64Trunc(Node* x) {
   Branch(Float64GreaterThan(x, zero), &if_xgreaterthanzero,
          &if_xnotgreaterthanzero);
 
-  Bind(&if_xgreaterthanzero);
+  BIND(&if_xgreaterthanzero);
   {
     if (IsFloat64RoundDownSupported()) {
       var_x.Bind(Float64RoundDown(x));
@@ -392,7 +392,7 @@ Node* CodeStubAssembler::Float64Trunc(Node* x) {
     Goto(&return_x);
   }
 
-  Bind(&if_xnotgreaterthanzero);
+  BIND(&if_xnotgreaterthanzero);
   {
     if (IsFloat64RoundUpSupported()) {
       var_x.Bind(Float64RoundUp(x));
@@ -411,11 +411,11 @@ Node* CodeStubAssembler::Float64Trunc(Node* x) {
     }
   }
 
-  Bind(&return_minus_x);
+  BIND(&return_minus_x);
   var_x.Bind(Float64Neg(var_x.value()));
   Goto(&return_x);
 
-  Bind(&return_x);
+  BIND(&return_x);
   return var_x.value();
 }
 
@@ -475,7 +475,7 @@ Node* CodeStubAssembler::SmiMod(Node* a, Node* b) {
   Branch(Int32LessThanOrEqual(Int32Constant(0), a), &if_aisnotnegative,
          &if_aisnegative);
 
-  Bind(&if_aisnotnegative);
+  BIND(&if_aisnotnegative);
   {
     // Fast case, don't need to check any other edge cases.
     Node* r = Int32Mod(a, b);
@@ -483,7 +483,7 @@ Node* CodeStubAssembler::SmiMod(Node* a, Node* b) {
     Goto(&return_result);
   }
 
-  Bind(&if_aisnegative);
+  BIND(&if_aisnegative);
   {
     if (SmiValuesAre32Bits()) {
       // Check if {a} is kMinInt and {b} is -1 (only relevant if the
@@ -492,7 +492,7 @@ Node* CodeStubAssembler::SmiMod(Node* a, Node* b) {
       GotoIfNot(Word32Equal(a, Int32Constant(kMinInt)), &join);
       GotoIf(Word32Equal(b, Int32Constant(-1)), &return_minuszero);
       Goto(&join);
-      Bind(&join);
+      BIND(&join);
     }
 
     // Perform the integer modulus operation.
@@ -508,15 +508,15 @@ Node* CodeStubAssembler::SmiMod(Node* a, Node* b) {
     Goto(&return_result);
   }
 
-  Bind(&return_minuszero);
+  BIND(&return_minuszero);
   var_result.Bind(MinusZeroConstant());
   Goto(&return_result);
 
-  Bind(&return_nan);
+  BIND(&return_nan);
   var_result.Bind(NanConstant());
   Goto(&return_result);
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
@@ -536,7 +536,7 @@ Node* CodeStubAssembler::SmiMul(Node* a, Node* b) {
   // Check if the multiplication overflowed.
   Label if_overflow(this, Label::kDeferred), if_notoverflow(this);
   Branch(overflow, &if_overflow, &if_notoverflow);
-  Bind(&if_notoverflow);
+  BIND(&if_notoverflow);
   {
     // If the answer is zero, we may need to return -0.0, depending on the
     // input.
@@ -544,30 +544,30 @@ Node* CodeStubAssembler::SmiMul(Node* a, Node* b) {
     Node* answer = Projection(0, pair);
     Node* zero = Int32Constant(0);
     Branch(Word32Equal(answer, zero), &answer_zero, &answer_not_zero);
-    Bind(&answer_not_zero);
+    BIND(&answer_not_zero);
     {
       var_result.Bind(ChangeInt32ToTagged(answer));
       Goto(&return_result);
     }
-    Bind(&answer_zero);
+    BIND(&answer_zero);
     {
       Node* or_result = Word32Or(lhs32, rhs32);
       Label if_should_be_negative_zero(this), if_should_be_zero(this);
       Branch(Int32LessThan(or_result, zero), &if_should_be_negative_zero,
              &if_should_be_zero);
-      Bind(&if_should_be_negative_zero);
+      BIND(&if_should_be_negative_zero);
       {
         var_result.Bind(MinusZeroConstant());
         Goto(&return_result);
       }
-      Bind(&if_should_be_zero);
+      BIND(&if_should_be_zero);
       {
         var_result.Bind(SmiConstant(0));
         Goto(&return_result);
       }
     }
   }
-  Bind(&if_overflow);
+  BIND(&if_overflow);
   {
     var_lhs_float64.Bind(SmiToFloat64(a));
     var_rhs_float64.Bind(SmiToFloat64(b));
@@ -577,7 +577,7 @@ Node* CodeStubAssembler::SmiMul(Node* a, Node* b) {
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
@@ -618,7 +618,7 @@ void CodeStubAssembler::BranchIfPrototypesHaveNoElements(
   Node* empty_elements = LoadRoot(Heap::kEmptyFixedArrayRootIndex);
   Goto(&loop_body);
 
-  Bind(&loop_body);
+  BIND(&loop_body);
   {
     Node* map = var_map.value();
     Node* prototype = LoadMapPrototype(map);
@@ -705,7 +705,7 @@ Node* CodeStubAssembler::AllocateRaw(Node* size_in_bytes, AllocationFlags flags,
     result.Bind(runtime_result);
     Goto(&merge_runtime);
 
-    Bind(&next);
+    BIND(&next);
   }
 
   Variable adjusted_size(this, MachineType::PointerRepresentation(),
@@ -717,12 +717,12 @@ Node* CodeStubAssembler::AllocateRaw(Node* size_in_bytes, AllocationFlags flags,
     Branch(WordAnd(top, IntPtrConstant(kDoubleAlignmentMask)), &not_aligned,
            &done_alignment);
 
-    Bind(&not_aligned);
+    BIND(&not_aligned);
     Node* not_aligned_size = IntPtrAdd(size_in_bytes, IntPtrConstant(4));
     adjusted_size.Bind(not_aligned_size);
     Goto(&done_alignment);
 
-    Bind(&done_alignment);
+    BIND(&done_alignment);
   }
 
   Node* new_top = IntPtrAdd(top, adjusted_size.value());
@@ -730,7 +730,7 @@ Node* CodeStubAssembler::AllocateRaw(Node* size_in_bytes, AllocationFlags flags,
   Branch(UintPtrGreaterThanOrEqual(new_top, limit), &runtime_call,
          &no_runtime_call);
 
-  Bind(&runtime_call);
+  BIND(&runtime_call);
   Node* runtime_result;
   if (flags & kPretenured) {
     Node* runtime_flags = SmiConstant(
@@ -747,7 +747,7 @@ Node* CodeStubAssembler::AllocateRaw(Node* size_in_bytes, AllocationFlags flags,
   Goto(&merge_runtime);
 
   // When there is enough space, return `top' and bump it up.
-  Bind(&no_runtime_call);
+  BIND(&no_runtime_call);
   Node* no_runtime_result = top;
   StoreNoWriteBarrier(MachineType::PointerRepresentation(), top_address,
                       new_top);
@@ -760,7 +760,7 @@ Node* CodeStubAssembler::AllocateRaw(Node* size_in_bytes, AllocationFlags flags,
     Branch(IntPtrEqual(adjusted_size.value(), size_in_bytes), &done_filling,
            &needs_filler);
 
-    Bind(&needs_filler);
+    BIND(&needs_filler);
     // Store a filler and increase the address by kPointerSize.
     StoreNoWriteBarrier(MachineRepresentation::kTagged, top,
                         LoadRoot(Heap::kOnePointerFillerMapRootIndex));
@@ -768,7 +768,7 @@ Node* CodeStubAssembler::AllocateRaw(Node* size_in_bytes, AllocationFlags flags,
 
     Goto(&done_filling);
 
-    Bind(&done_filling);
+    BIND(&done_filling);
   }
 
   no_runtime_result = BitcastWordToTagged(
@@ -777,7 +777,7 @@ Node* CodeStubAssembler::AllocateRaw(Node* size_in_bytes, AllocationFlags flags,
   result.Bind(no_runtime_result);
   Goto(&merge_runtime);
 
-  Bind(&merge_runtime);
+  BIND(&merge_runtime);
   return result.value();
 }
 
@@ -875,13 +875,13 @@ void CodeStubAssembler::BranchIfToBooleanIsTrue(Node* value, Label* if_true,
   // Check if {value} is a Smi or a HeapObject.
   Branch(TaggedIsSmi(value), &if_valueissmi, &if_valueisnotsmi);
 
-  Bind(&if_valueissmi);
+  BIND(&if_valueissmi);
   {
     // The {value} is a Smi, only need to check against zero.
     BranchIfSmiEqual(value, SmiConstant(0), if_false, if_true);
   }
 
-  Bind(&if_valueisnotsmi);
+  BIND(&if_valueisnotsmi);
   {
     // Check if {value} is the empty string.
     GotoIf(IsEmptyString(value), if_false);
@@ -902,7 +902,7 @@ void CodeStubAssembler::BranchIfToBooleanIsTrue(Node* value, Label* if_true,
     // that make it here yield true.
     Branch(IsHeapNumberMap(value_map), &if_valueisheapnumber, if_true);
 
-    Bind(&if_valueisheapnumber);
+    BIND(&if_valueisheapnumber);
     {
       // Load the floating point value of {value}.
       Node* value_value = LoadObjectField(value, HeapNumber::kValueOffset,
@@ -1139,7 +1139,7 @@ Node* CodeStubAssembler::LoadMapConstructor(Node* map) {
 
   Label done(this), loop(this, &result);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     GotoIf(TaggedIsSmi(result.value()), &done);
     Node* is_map_type =
@@ -1149,7 +1149,7 @@ Node* CodeStubAssembler::LoadMapConstructor(Node* map) {
         LoadObjectField(result.value(), Map::kConstructorOrBackPointerOffset));
     Goto(&loop);
   }
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -1507,7 +1507,7 @@ Node* CodeStubAssembler::BuildAppendJSArray(ElementsKind kind, Node* context,
                                          kind, capacity, new_capacity, mode,
                                          &pre_bailout));
   Goto(&fits);
-  Bind(&fits);
+  BIND(&fits);
   Node* elements = var_elements.value();
 
   // Push each argument onto the end of the array now that there is enough
@@ -1542,7 +1542,7 @@ Node* CodeStubAssembler::BuildAppendJSArray(ElementsKind kind, Node* context,
     Goto(&success);
   }
 
-  Bind(&pre_bailout);
+  BIND(&pre_bailout);
   {
     Node* length = ParameterToTagged(var_length.value(), mode);
     var_tagged_length.Bind(length);
@@ -1552,7 +1552,7 @@ Node* CodeStubAssembler::BuildAppendJSArray(ElementsKind kind, Node* context,
     Goto(bailout);
   }
 
-  Bind(&success);
+  BIND(&success);
   return var_tagged_length.value();
 }
 
@@ -1608,7 +1608,7 @@ Node* CodeStubAssembler::AllocateSeqOneByteString(Node* context, Node* length,
   Branch(IntPtrLessThanOrEqual(size, IntPtrConstant(kMaxRegularHeapObjectSize)),
          &if_sizeissmall, &if_notsizeissmall);
 
-  Bind(&if_sizeissmall);
+  BIND(&if_sizeissmall);
   {
     // Just allocate the SeqOneByteString in new space.
     Node* result = AllocateInNewSpace(size, flags);
@@ -1624,7 +1624,7 @@ Node* CodeStubAssembler::AllocateSeqOneByteString(Node* context, Node* length,
     Goto(&if_join);
   }
 
-  Bind(&if_notsizeissmall);
+  BIND(&if_notsizeissmall);
   {
     // We might need to allocate in large object space, go to the runtime.
     Node* result = CallRuntime(Runtime::kAllocateSeqOneByteString, context,
@@ -1633,13 +1633,13 @@ Node* CodeStubAssembler::AllocateSeqOneByteString(Node* context, Node* length,
     Goto(&if_join);
   }
 
-  Bind(&if_lengthiszero);
+  BIND(&if_lengthiszero);
   {
     var_result.Bind(LoadRoot(Heap::kempty_stringRootIndex));
     Goto(&if_join);
   }
 
-  Bind(&if_join);
+  BIND(&if_join);
   return var_result.value();
 }
 
@@ -1679,7 +1679,7 @@ Node* CodeStubAssembler::AllocateSeqTwoByteString(Node* context, Node* length,
   Branch(IntPtrLessThanOrEqual(size, IntPtrConstant(kMaxRegularHeapObjectSize)),
          &if_sizeissmall, &if_notsizeissmall);
 
-  Bind(&if_sizeissmall);
+  BIND(&if_sizeissmall);
   {
     // Just allocate the SeqTwoByteString in new space.
     Node* result = AllocateInNewSpace(size, flags);
@@ -1696,7 +1696,7 @@ Node* CodeStubAssembler::AllocateSeqTwoByteString(Node* context, Node* length,
     Goto(&if_join);
   }
 
-  Bind(&if_notsizeissmall);
+  BIND(&if_notsizeissmall);
   {
     // We might need to allocate in large object space, go to the runtime.
     Node* result =
@@ -1706,13 +1706,13 @@ Node* CodeStubAssembler::AllocateSeqTwoByteString(Node* context, Node* length,
     Goto(&if_join);
   }
 
-  Bind(&if_lengthiszero);
+  BIND(&if_lengthiszero);
   {
     var_result.Bind(LoadRoot(Heap::kempty_stringRootIndex));
     Goto(&if_join);
   }
 
-  Bind(&if_join);
+  BIND(&if_join);
   return var_result.value();
 }
 
@@ -1829,17 +1829,17 @@ Node* CodeStubAssembler::NewConsString(Node* context, Node* length, Node* left,
                         Int32Constant(kOneByteStringTag | kOneByteDataHintTag)),
          &two_byte_map, &one_byte_map);
 
-  Bind(&one_byte_map);
+  BIND(&one_byte_map);
   Comment("One-byte ConsString");
   result.Bind(AllocateOneByteConsString(length, left, right, flags));
   Goto(&done);
 
-  Bind(&two_byte_map);
+  BIND(&two_byte_map);
   Comment("Two-byte ConsString");
   result.Bind(AllocateTwoByteConsString(length, left, right, flags));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
 
   return result.value();
 }
@@ -2216,7 +2216,7 @@ void CodeStubAssembler::CopyFixedArrayElements(
 
   Branch(WordEqual(var_from_offset.value(), limit_offset), &done, &decrement);
 
-  Bind(&decrement);
+  BIND(&decrement);
   {
     Node* from_offset = IntPtrSub(
         var_from_offset.value(),
@@ -2261,7 +2261,7 @@ void CodeStubAssembler::CopyFixedArrayElements(
     Goto(&next_iter);
 
     if (if_hole == &store_double_hole) {
-      Bind(&store_double_hole);
+      BIND(&store_double_hole);
       // Don't use doubles to store the hole double, since manipulating the
       // signaling NaN used for the hole in C++, e.g. with bit_cast, will
       // change its value on ia32 (the x87 stack is used to return values
@@ -2283,12 +2283,12 @@ void CodeStubAssembler::CopyFixedArrayElements(
       Goto(&next_iter);
     }
 
-    Bind(&next_iter);
+    BIND(&next_iter);
     Node* compare = WordNotEqual(from_offset, limit_offset);
     Branch(compare, &decrement, &done);
   }
 
-  Bind(&done);
+  BIND(&done);
   IncrementCounter(isolate()->counters()->inlined_copied_elements(), 1);
   Comment("] CopyFixedArrayElements");
 }
@@ -2476,28 +2476,28 @@ Node* CodeStubAssembler::TryTaggedToFloat64(Node* value,
   Label if_valueissmi(this), if_valueisnotsmi(this);
   Branch(TaggedIsSmi(value), &if_valueissmi, &if_valueisnotsmi);
 
-  Bind(&if_valueissmi);
+  BIND(&if_valueissmi);
   {
     // Convert the Smi {value}.
     var_result.Bind(SmiToFloat64(value));
     Goto(&out);
   }
 
-  Bind(&if_valueisnotsmi);
+  BIND(&if_valueisnotsmi);
   {
     // Check if {value} is a HeapNumber.
     Label if_valueisheapnumber(this);
     Branch(IsHeapNumberMap(LoadMap(value)), &if_valueisheapnumber,
            if_valueisnotnumber);
 
-    Bind(&if_valueisheapnumber);
+    BIND(&if_valueisheapnumber);
     {
       // Load the floating point value.
       var_result.Bind(LoadHeapNumberValue(value));
       Goto(&out);
     }
   }
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -2508,7 +2508,7 @@ Node* CodeStubAssembler::TruncateTaggedToFloat64(Node* context, Node* value) {
   Label loop(this, &var_value), done_loop(this, &var_result);
   var_value.Bind(value);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Label if_valueisnotnumber(this, Label::kDeferred);
 
@@ -2521,7 +2521,7 @@ Node* CodeStubAssembler::TruncateTaggedToFloat64(Node* context, Node* value) {
     var_result.Bind(result);
     Goto(&done_loop);
 
-    Bind(&if_valueisnotnumber);
+    BIND(&if_valueisnotnumber);
     {
       // Convert the {value} to a Number first.
       Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -2529,7 +2529,7 @@ Node* CodeStubAssembler::TruncateTaggedToFloat64(Node* context, Node* value) {
       Goto(&loop);
     }
   }
-  Bind(&done_loop);
+  BIND(&done_loop);
   return var_result.value();
 }
 
@@ -2539,7 +2539,7 @@ Node* CodeStubAssembler::TruncateTaggedToWord32(Node* context, Node* value) {
       var_result(this, MachineRepresentation::kWord32);
   Label loop(this, &var_value), done_loop(this, &var_result);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {value}.
     value = var_value.value();
@@ -2548,14 +2548,14 @@ Node* CodeStubAssembler::TruncateTaggedToWord32(Node* context, Node* value) {
     Label if_valueissmi(this), if_valueisnotsmi(this);
     Branch(TaggedIsSmi(value), &if_valueissmi, &if_valueisnotsmi);
 
-    Bind(&if_valueissmi);
+    BIND(&if_valueissmi);
     {
       // Convert the Smi {value}.
       var_result.Bind(SmiToWord32(value));
       Goto(&done_loop);
     }
 
-    Bind(&if_valueisnotsmi);
+    BIND(&if_valueisnotsmi);
     {
       // Check if {value} is a HeapNumber.
       Label if_valueisheapnumber(this),
@@ -2563,14 +2563,14 @@ Node* CodeStubAssembler::TruncateTaggedToWord32(Node* context, Node* value) {
       Branch(IsHeapNumberMap(LoadMap(value)), &if_valueisheapnumber,
              &if_valueisnotheapnumber);
 
-      Bind(&if_valueisheapnumber);
+      BIND(&if_valueisheapnumber);
       {
         // Truncate the floating point value.
         var_result.Bind(TruncateHeapNumberValueToWord32(value));
         Goto(&done_loop);
       }
 
-      Bind(&if_valueisnotheapnumber);
+      BIND(&if_valueisnotheapnumber);
       {
         // Convert the {value} to a Number first.
         Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -2579,7 +2579,7 @@ Node* CodeStubAssembler::TruncateTaggedToWord32(Node* context, Node* value) {
       }
     }
   }
-  Bind(&done_loop);
+  BIND(&done_loop);
   return var_result.value();
 }
 
@@ -2596,17 +2596,17 @@ Node* CodeStubAssembler::ChangeFloat64ToTagged(Node* value) {
 
   Label if_valueisequal(this), if_valueisnotequal(this);
   Branch(Float64Equal(value, value64), &if_valueisequal, &if_valueisnotequal);
-  Bind(&if_valueisequal);
+  BIND(&if_valueisequal);
   {
     GotoIfNot(Word32Equal(value32, Int32Constant(0)), &if_valueisint32);
     Branch(Int32LessThan(Float64ExtractHighWord32(value), Int32Constant(0)),
            &if_valueisheapnumber, &if_valueisint32);
   }
-  Bind(&if_valueisnotequal);
+  BIND(&if_valueisnotequal);
   Goto(&if_valueisheapnumber);
 
   Variable var_result(this, MachineRepresentation::kTagged);
-  Bind(&if_valueisint32);
+  BIND(&if_valueisint32);
   {
     if (Is64()) {
       Node* result = SmiTag(ChangeInt32ToInt64(value32));
@@ -2617,9 +2617,9 @@ Node* CodeStubAssembler::ChangeFloat64ToTagged(Node* value) {
       Node* overflow = Projection(1, pair);
       Label if_overflow(this, Label::kDeferred), if_notoverflow(this);
       Branch(overflow, &if_overflow, &if_notoverflow);
-      Bind(&if_overflow);
+      BIND(&if_overflow);
       Goto(&if_valueisheapnumber);
-      Bind(&if_notoverflow);
+      BIND(&if_notoverflow);
       {
         Node* result = BitcastWordToTaggedSigned(Projection(0, pair));
         var_result.Bind(result);
@@ -2627,13 +2627,13 @@ Node* CodeStubAssembler::ChangeFloat64ToTagged(Node* value) {
       }
     }
   }
-  Bind(&if_valueisheapnumber);
+  BIND(&if_valueisheapnumber);
   {
     Node* result = AllocateHeapNumberWithValue(value);
     var_result.Bind(result);
     Goto(&if_join);
   }
-  Bind(&if_join);
+  BIND(&if_join);
   return var_result.value();
 }
 
@@ -2647,20 +2647,20 @@ Node* CodeStubAssembler::ChangeInt32ToTagged(Node* value) {
   Label if_overflow(this, Label::kDeferred), if_notoverflow(this),
       if_join(this);
   Branch(overflow, &if_overflow, &if_notoverflow);
-  Bind(&if_overflow);
+  BIND(&if_overflow);
   {
     Node* value64 = ChangeInt32ToFloat64(value);
     Node* result = AllocateHeapNumberWithValue(value64);
     var_result.Bind(result);
   }
   Goto(&if_join);
-  Bind(&if_notoverflow);
+  BIND(&if_notoverflow);
   {
     Node* result = BitcastWordToTaggedSigned(Projection(0, pair));
     var_result.Bind(result);
   }
   Goto(&if_join);
-  Bind(&if_join);
+  BIND(&if_join);
   return var_result.value();
 }
 
@@ -2672,7 +2672,7 @@ Node* CodeStubAssembler::ChangeUint32ToTagged(Node* value) {
   Branch(Uint32LessThan(Int32Constant(Smi::kMaxValue), value), &if_overflow,
          &if_not_overflow);
 
-  Bind(&if_not_overflow);
+  BIND(&if_not_overflow);
   {
     if (Is64()) {
       var_result.Bind(SmiTag(ChangeUint32ToUint64(value)));
@@ -2689,14 +2689,14 @@ Node* CodeStubAssembler::ChangeUint32ToTagged(Node* value) {
   }
   Goto(&if_join);
 
-  Bind(&if_overflow);
+  BIND(&if_overflow);
   {
     Node* float64_value = ChangeUint32ToFloat64(value);
     var_result.Bind(AllocateHeapNumberWithValue(float64_value));
   }
   Goto(&if_join);
 
-  Bind(&if_join);
+  BIND(&if_join);
   return var_result.value();
 }
 
@@ -2708,7 +2708,7 @@ Node* CodeStubAssembler::ToThisString(Node* context, Node* value,
   Label if_valueissmi(this, Label::kDeferred), if_valueisnotsmi(this),
       if_valueisstring(this);
   Branch(TaggedIsSmi(value), &if_valueissmi, &if_valueisnotsmi);
-  Bind(&if_valueisnotsmi);
+  BIND(&if_valueisnotsmi);
   {
     // Load the instance type of the {value}.
     Node* value_instance_type = LoadInstanceType(value);
@@ -2717,7 +2717,7 @@ Node* CodeStubAssembler::ToThisString(Node* context, Node* value,
     Label if_valueisnotstring(this, Label::kDeferred);
     Branch(IsStringInstanceType(value_instance_type), &if_valueisstring,
            &if_valueisnotstring);
-    Bind(&if_valueisnotstring);
+    BIND(&if_valueisnotstring);
     {
       // Check if the {value} is null.
       Label if_valueisnullorundefined(this, Label::kDeferred),
@@ -2725,12 +2725,12 @@ Node* CodeStubAssembler::ToThisString(Node* context, Node* value,
           if_valueisnotnull(this, Label::kDeferred);
       Branch(WordEqual(value, NullConstant()), &if_valueisnullorundefined,
              &if_valueisnotnull);
-      Bind(&if_valueisnotnull);
+      BIND(&if_valueisnotnull);
       {
         // Check if the {value} is undefined.
         Branch(WordEqual(value, UndefinedConstant()),
                &if_valueisnullorundefined, &if_valueisnotnullorundefined);
-        Bind(&if_valueisnotnullorundefined);
+        BIND(&if_valueisnotnullorundefined);
         {
           // Convert the {value} to a String.
           Callable callable = CodeFactory::ToString(isolate());
@@ -2739,7 +2739,7 @@ Node* CodeStubAssembler::ToThisString(Node* context, Node* value,
         }
       }
 
-      Bind(&if_valueisnullorundefined);
+      BIND(&if_valueisnullorundefined);
       {
         // The {value} is either null or undefined.
         CallRuntime(Runtime::kThrowCalledOnNullOrUndefined, context,
@@ -2749,14 +2749,14 @@ Node* CodeStubAssembler::ToThisString(Node* context, Node* value,
       }
     }
   }
-  Bind(&if_valueissmi);
+  BIND(&if_valueissmi);
   {
     // The {value} is a Smi, convert it to a String.
     Callable callable = CodeFactory::NumberToString(isolate());
     var_value.Bind(CallStub(callable, context, value));
     Goto(&if_valueisstring);
   }
-  Bind(&if_valueisstring);
+  BIND(&if_valueisstring);
   return var_value.value();
 }
 
@@ -2769,13 +2769,13 @@ Node* CodeStubAssembler::ChangeNumberToFloat64(Node* value) {
       LoadObjectField(value, HeapNumber::kValueOffset, MachineType::Float64()));
   Goto(&done);
 
-  Bind(&smi);
+  BIND(&smi);
   {
     result.Bind(SmiToFloat64(value));
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -2788,11 +2788,11 @@ Node* CodeStubAssembler::ChangeNumberToIntPtr(Node* value) {
   result.Bind(ChangeFloat64ToUintPtr(LoadHeapNumberValue(value)));
   Goto(&done);
 
-  Bind(&smi);
+  BIND(&smi);
   result.Bind(SmiToWord(value));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -2804,7 +2804,7 @@ Node* CodeStubAssembler::ToThisValue(Node* context, Node* value,
   Label loop(this, &var_value), done_loop(this),
       done_throw(this, Label::kDeferred);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {value}.
     value = var_value.value();
@@ -2825,14 +2825,14 @@ Node* CodeStubAssembler::ToThisValue(Node* context, Node* value,
     Branch(Word32Equal(value_instance_type, Int32Constant(JS_VALUE_TYPE)),
            &if_valueisvalue, &if_valueisnotvalue);
 
-    Bind(&if_valueisvalue);
+    BIND(&if_valueisvalue);
     {
       // Load the actual value from the {value}.
       var_value.Bind(LoadObjectField(value, JSValue::kValueOffset));
       Goto(&loop);
     }
 
-    Bind(&if_valueisnotvalue);
+    BIND(&if_valueisnotvalue);
     {
       switch (primitive_type) {
         case PrimitiveType::kBoolean:
@@ -2855,7 +2855,7 @@ Node* CodeStubAssembler::ToThisValue(Node* context, Node* value,
     }
   }
 
-  Bind(&done_throw);
+  BIND(&done_throw);
   {
     // The {value} is not a compatible receiver for this method.
     CallRuntime(Runtime::kThrowNotGeneric, context,
@@ -2864,7 +2864,7 @@ Node* CodeStubAssembler::ToThisValue(Node* context, Node* value,
     Unreachable();
   }
 
-  Bind(&done_loop);
+  BIND(&done_loop);
   return var_value.value();
 }
 
@@ -2884,14 +2884,14 @@ Node* CodeStubAssembler::ThrowIfNotInstanceType(Node* context, Node* value,
          &throw_exception);
 
   // The {value} is not a compatible receiver for this method.
-  Bind(&throw_exception);
+  BIND(&throw_exception);
   CallRuntime(
       Runtime::kThrowIncompatibleMethodReceiver, context,
       HeapConstant(factory()->NewStringFromAsciiChecked(method_name, TENURED)),
       value);
   Unreachable();
 
-  Bind(&out);
+  BIND(&out);
   return var_value_map.value();
 }
 
@@ -3128,20 +3128,20 @@ Node* CodeStubAssembler::StringCharCodeAt(Node* string, Node* index,
   Branch(IsOneByteStringInstanceType(instance_type), &if_stringisonebyte,
          &if_stringistwobyte);
 
-  Bind(&if_stringisonebyte);
+  BIND(&if_stringisonebyte);
   {
     var_result.Bind(Load(MachineType::Uint8(), string_data, offset));
     Goto(&out);
   }
 
-  Bind(&if_stringistwobyte);
+  BIND(&if_stringistwobyte);
   {
     var_result.Bind(Load(MachineType::Uint16(), string_data,
                          WordShl(offset, IntPtrConstant(1))));
     Goto(&out);
   }
 
-  Bind(&runtime_generic);
+  BIND(&runtime_generic);
   {
     Node* const smi_index = ParameterToTagged(index, parameter_mode);
     Node* const result = CallRuntime(Runtime::kStringCharCodeAtRT,
@@ -3150,7 +3150,7 @@ Node* CodeStubAssembler::StringCharCodeAt(Node* string, Node* index,
     Goto(&out);
   }
 
-  Bind(&runtime_external);
+  BIND(&runtime_external);
   {
     Node* const result =
         CallRuntime(Runtime::kExternalStringGetChar, NoContextConstant(),
@@ -3159,7 +3159,7 @@ Node* CodeStubAssembler::StringCharCodeAt(Node* string, Node* index,
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -3171,7 +3171,7 @@ Node* CodeStubAssembler::StringFromCharCode(Node* code) {
       if_done(this);
   Branch(Int32LessThanOrEqual(code, Int32Constant(String::kMaxOneByteCharCode)),
          &if_codeisonebyte, &if_codeistwobyte);
-  Bind(&if_codeisonebyte);
+  BIND(&if_codeisonebyte);
   {
     // Load the isolate wide single character string cache.
     Node* cache = LoadRoot(Heap::kSingleCharacterStringCacheRootIndex);
@@ -3185,7 +3185,7 @@ Node* CodeStubAssembler::StringFromCharCode(Node* code) {
     Branch(WordEqual(entry, UndefinedConstant()), &if_entryisundefined,
            &if_entryisnotundefined);
 
-    Bind(&if_entryisundefined);
+    BIND(&if_entryisundefined);
     {
       // Allocate a new SeqOneByteString for {code} and store it in the {cache}.
       Node* result = AllocateSeqOneByteString(1);
@@ -3197,7 +3197,7 @@ Node* CodeStubAssembler::StringFromCharCode(Node* code) {
       Goto(&if_done);
     }
 
-    Bind(&if_entryisnotundefined);
+    BIND(&if_entryisnotundefined);
     {
       // Return the entry from the {cache}.
       var_result.Bind(entry);
@@ -3205,7 +3205,7 @@ Node* CodeStubAssembler::StringFromCharCode(Node* code) {
     }
   }
 
-  Bind(&if_codeistwobyte);
+  BIND(&if_codeistwobyte);
   {
     // Allocate a new SeqTwoByteString for {code}.
     Node* result = AllocateSeqTwoByteString(1);
@@ -3216,7 +3216,7 @@ Node* CodeStubAssembler::StringFromCharCode(Node* code) {
     Goto(&if_done);
   }
 
-  Bind(&if_done);
+  BIND(&if_done);
   return var_result.value();
 }
 
@@ -3243,7 +3243,7 @@ Node* AllocAndCopyStringCharacters(CodeStubAssembler* a, Node* context,
             &one_byte_sequential, &two_byte_sequential);
 
   // The subject string is a sequential one-byte string.
-  a->Bind(&one_byte_sequential);
+  a->BIND(&one_byte_sequential);
   {
     Node* result =
         a->AllocateSeqOneByteString(context, a->SmiToWord(character_count));
@@ -3257,7 +3257,7 @@ Node* AllocAndCopyStringCharacters(CodeStubAssembler* a, Node* context,
   }
 
   // The subject string is a sequential two-byte string.
-  a->Bind(&two_byte_sequential);
+  a->BIND(&two_byte_sequential);
   {
     Node* result =
         a->AllocateSeqTwoByteString(context, a->SmiToWord(character_count));
@@ -3270,7 +3270,7 @@ Node* AllocAndCopyStringCharacters(CodeStubAssembler* a, Node* context,
     a->Goto(&end);
   }
 
-  a->Bind(&end);
+  a->BIND(&end);
   return var_result.value();
 }
 
@@ -3335,21 +3335,21 @@ Node* CodeStubAssembler::SubString(Node* context, Node* string, Node* from,
       Branch(IsOneByteStringInstanceType(to_direct.instance_type()),
              &one_byte_slice, &two_byte_slice);
 
-      Bind(&one_byte_slice);
+      BIND(&one_byte_slice);
       {
         var_result.Bind(
             AllocateSlicedOneByteString(substr_length, direct_string, offset));
         Goto(&end);
       }
 
-      Bind(&two_byte_slice);
+      BIND(&two_byte_slice);
       {
         var_result.Bind(
             AllocateSlicedTwoByteString(substr_length, direct_string, offset));
         Goto(&end);
       }
 
-      Bind(&next);
+      BIND(&next);
     }
 
     // The subject string can only be external or sequential string of either
@@ -3366,7 +3366,7 @@ Node* CodeStubAssembler::SubString(Node* context, Node* string, Node* from,
   }
 
   // Handle external string.
-  Bind(&external_string);
+  BIND(&external_string);
   {
     Node* const fake_sequential_string = to_direct.PointerToString(&runtime);
 
@@ -3381,14 +3381,14 @@ Node* CodeStubAssembler::SubString(Node* context, Node* string, Node* from,
   }
 
   // Substrings of length 1 are generated through CharCodeAt and FromCharCode.
-  Bind(&single_char);
+  BIND(&single_char);
   {
     Node* char_code = StringCharCodeAt(string, from);
     var_result.Bind(StringFromCharCode(char_code));
     Goto(&end);
   }
 
-  Bind(&original_string_or_invalid_length);
+  BIND(&original_string_or_invalid_length);
   {
     // Longer than original string's length or negative: unsafe arguments.
     GotoIf(SmiAbove(substr_length, string_length), &runtime);
@@ -3406,14 +3406,14 @@ Node* CodeStubAssembler::SubString(Node* context, Node* string, Node* from,
   }
 
   // Fall back to a runtime call.
-  Bind(&runtime);
+  BIND(&runtime);
   {
     var_result.Bind(
         CallRuntime(Runtime::kSubString, context, string, from, to));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -3446,7 +3446,7 @@ Node* ToDirectStringAssembler::TryToDirect(Label* if_bailout) {
          &dispatch);
 
   // Dispatch based on string representation.
-  Bind(&dispatch);
+  BIND(&dispatch);
   {
     int32_t values[] = {
         kSeqStringTag,    kConsStringTag, kExternalStringTag,
@@ -3464,7 +3464,7 @@ Node* ToDirectStringAssembler::TryToDirect(Label* if_bailout) {
 
   // Cons string.  Check whether it is flat, then fetch first part.
   // Flat cons strings have an empty second part.
-  Bind(&if_iscons);
+  BIND(&if_iscons);
   {
     Node* const string = var_string_.value();
     GotoIfNot(IsEmptyString(LoadObjectField(string, ConsString::kSecondOffset)),
@@ -3478,7 +3478,7 @@ Node* ToDirectStringAssembler::TryToDirect(Label* if_bailout) {
   }
 
   // Sliced string. Fetch parent and correct start index by offset.
-  Bind(&if_issliced);
+  BIND(&if_issliced);
   {
     Node* const string = var_string_.value();
     Node* const sliced_offset =
@@ -3493,7 +3493,7 @@ Node* ToDirectStringAssembler::TryToDirect(Label* if_bailout) {
   }
 
   // Thin string. Fetch the actual string.
-  Bind(&if_isthin);
+  BIND(&if_isthin);
   {
     Node* const string = var_string_.value();
     Node* const actual_string =
@@ -3507,11 +3507,11 @@ Node* ToDirectStringAssembler::TryToDirect(Label* if_bailout) {
   }
 
   // External string.
-  Bind(&if_isexternal);
+  BIND(&if_isexternal);
   var_is_external_.Bind(Int32Constant(1));
   Goto(&out);
 
-  Bind(&out);
+  BIND(&out);
   return var_string_.value();
 }
 
@@ -3523,7 +3523,7 @@ Node* ToDirectStringAssembler::TryToSequential(StringPointerKind ptr_kind,
   Label out(this), if_issequential(this), if_isexternal(this, Label::kDeferred);
   Branch(is_external(), &if_isexternal, &if_issequential);
 
-  Bind(&if_issequential);
+  BIND(&if_issequential);
   {
     STATIC_ASSERT(SeqOneByteString::kHeaderSize ==
                   SeqTwoByteString::kHeaderSize);
@@ -3536,7 +3536,7 @@ Node* ToDirectStringAssembler::TryToSequential(StringPointerKind ptr_kind,
     Goto(&out);
   }
 
-  Bind(&if_isexternal);
+  BIND(&if_isexternal);
   {
     GotoIf(IsShortExternalStringInstanceType(var_instance_type_.value()),
            if_bailout);
@@ -3552,7 +3552,7 @@ Node* ToDirectStringAssembler::TryToSequential(StringPointerKind ptr_kind,
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -3589,14 +3589,14 @@ void CodeStubAssembler::MaybeDerefIndirectString(Variable* var_string,
   GotoIf(WordEqual(rhs, EmptyStringConstant()), &deref);
   Goto(&done);
 
-  Bind(&deref);
+  BIND(&deref);
   STATIC_ASSERT(ThinString::kActualOffset == ConsString::kFirstOffset);
   var_string->Bind(
       LoadObjectField(var_string->value(), ThinString::kActualOffset));
   var_did_something->Bind(IntPtrConstant(1));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
 }
 
 void CodeStubAssembler::MaybeDerefIndirectStrings(Variable* var_left,
@@ -3629,13 +3629,13 @@ Node* CodeStubAssembler::StringAdd(Node* context, Node* left, Node* right,
   result.Bind(right);
   Goto(&done_native);
 
-  Bind(&check_right);
+  BIND(&check_right);
   Node* right_length = LoadStringLength(right);
   GotoIf(WordNotEqual(IntPtrConstant(0), right_length), &cons);
   result.Bind(left);
   Goto(&done_native);
 
-  Bind(&cons);
+  BIND(&cons);
   {
     CSA_ASSERT(this, TaggedIsSmi(left_length));
     CSA_ASSERT(this, TaggedIsSmi(right_length));
@@ -3655,7 +3655,7 @@ Node* CodeStubAssembler::StringAdd(Node* context, Node* left, Node* right,
                               var_right.value(), flags));
     Goto(&done_native);
 
-    Bind(&non_cons);
+    BIND(&non_cons);
 
     Comment("Full string concatenate");
     Node* left_instance_type = LoadInstanceType(var_left.value());
@@ -3695,7 +3695,7 @@ Node* CodeStubAssembler::StringAdd(Node* context, Node* left, Node* right,
     result.Bind(new_string);
     Goto(&done_native);
 
-    Bind(&two_byte);
+    BIND(&two_byte);
     {
       // Two-byte sequential string case
       new_string =
@@ -3712,7 +3712,7 @@ Node* CodeStubAssembler::StringAdd(Node* context, Node* left, Node* right,
       Goto(&done_native);
     }
 
-    Bind(&slow);
+    BIND(&slow);
     {
       // Try to unwrap indirect strings, restart the above attempt on success.
       MaybeDerefIndirectStrings(&var_left, left_instance_type, &var_right,
@@ -3720,19 +3720,19 @@ Node* CodeStubAssembler::StringAdd(Node* context, Node* left, Node* right,
       Goto(&runtime);
     }
   }
-  Bind(&runtime);
+  BIND(&runtime);
   {
     result.Bind(CallRuntime(Runtime::kStringAdd, context, left, right));
     Goto(&done);
   }
 
-  Bind(&done_native);
+  BIND(&done_native);
   {
     IncrementCounter(counters->string_add_native(), 1);
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -3746,13 +3746,13 @@ Node* CodeStubAssembler::StringFromCodePoint(Node* codepoint,
   Branch(Uint32LessThan(codepoint, Int32Constant(0x10000)), &if_isword16,
          &if_isword32);
 
-  Bind(&if_isword16);
+  BIND(&if_isword16);
   {
     var_result.Bind(StringFromCharCode(codepoint));
     Goto(&return_result);
   }
 
-  Bind(&if_isword32);
+  BIND(&if_isword32);
   {
     switch (encoding) {
       case UnicodeEncoding::UTF16:
@@ -3784,7 +3784,7 @@ Node* CodeStubAssembler::StringFromCodePoint(Node* codepoint,
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
@@ -3804,13 +3804,13 @@ Node* CodeStubAssembler::StringToNumber(Node* context, Node* input) {
       SmiTag(DecodeWordFromWord32<String::ArrayIndexValueBits>(hash)));
   Goto(&end);
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     var_result.Bind(CallRuntime(Runtime::kStringToNumber, context, input));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -3866,14 +3866,14 @@ Node* CodeStubAssembler::NumberToString(Node* context, Node* argument) {
   result.Bind(LoadFixedArrayElement(number_string_cache, index, kPointerSize));
   Goto(&done);
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     // No cache entry, go to the runtime.
     result.Bind(CallRuntime(Runtime::kNumberToString, context, argument));
   }
   Goto(&done);
 
-  Bind(&smi);
+  BIND(&smi);
   {
     // Load the smi key, make sure it matches the smi we're looking for.
     Node* smi_index = BitcastWordToTagged(
@@ -3889,7 +3889,7 @@ Node* CodeStubAssembler::NumberToString(Node* context, Node* argument) {
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -3909,14 +3909,14 @@ Node* CodeStubAssembler::ToName(Node* context, Node* value) {
   var_result.Bind(value);
   Goto(&end);
 
-  Bind(&is_number);
+  BIND(&is_number);
   {
     Callable callable = CodeFactory::NumberToString(isolate());
     var_result.Bind(CallStub(callable, context, value));
     Goto(&end);
   }
 
-  Bind(&not_name);
+  BIND(&not_name);
   {
     GotoIf(Word32Equal(value_instance_type, Int32Constant(HEAP_NUMBER_TYPE)),
            &is_number);
@@ -3928,14 +3928,14 @@ Node* CodeStubAssembler::ToName(Node* context, Node* value) {
     var_result.Bind(LoadObjectField(value, Oddball::kToStringOffset));
     Goto(&end);
 
-    Bind(&not_oddball);
+    BIND(&not_oddball);
     {
       var_result.Bind(CallRuntime(Runtime::kToName, context, value));
       Goto(&end);
     }
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -3950,7 +3950,7 @@ Node* CodeStubAssembler::NonNumberToNumber(Node* context, Node* input) {
   Label loop(this, &var_input);
   Label end(this);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {input} value (known to be a HeapObject).
     Node* input = var_input.value();
@@ -3966,21 +3966,21 @@ Node* CodeStubAssembler::NonNumberToNumber(Node* context, Node* input) {
     Branch(IsJSReceiverInstanceType(input_instance_type), &if_inputisreceiver,
            &if_inputisother);
 
-    Bind(&if_inputisstring);
+    BIND(&if_inputisstring);
     {
       // The {input} is a String, use the fast stub to convert it to a Number.
       var_result.Bind(StringToNumber(context, input));
       Goto(&end);
     }
 
-    Bind(&if_inputisoddball);
+    BIND(&if_inputisoddball);
     {
       // The {input} is an Oddball, we just need to load the Number value of it.
       var_result.Bind(LoadObjectField(input, Oddball::kToNumberOffset));
       Goto(&end);
     }
 
-    Bind(&if_inputisreceiver);
+    BIND(&if_inputisreceiver);
     {
       // The {input} is a JSReceiver, we need to convert it to a Primitive first
       // using the ToPrimitive type conversion, preferably yielding a Number.
@@ -3995,14 +3995,14 @@ Node* CodeStubAssembler::NonNumberToNumber(Node* context, Node* input) {
       Branch(IsHeapNumberMap(result_map), &if_resultisnumber,
              &if_resultisnotnumber);
 
-      Bind(&if_resultisnumber);
+      BIND(&if_resultisnumber);
       {
         // The ToPrimitive conversion already gave us a Number, so we're done.
         var_result.Bind(result);
         Goto(&end);
       }
 
-      Bind(&if_resultisnotnumber);
+      BIND(&if_resultisnotnumber);
       {
         // We now have a Primitive {result}, but it's not yet a Number.
         var_input.Bind(result);
@@ -4010,7 +4010,7 @@ Node* CodeStubAssembler::NonNumberToNumber(Node* context, Node* input) {
       }
     }
 
-    Bind(&if_inputisother);
+    BIND(&if_inputisother);
     {
       // The {input} is something else (e.g. Symbol), let the runtime figure
       // out the correct exception.
@@ -4023,7 +4023,7 @@ Node* CodeStubAssembler::NonNumberToNumber(Node* context, Node* input) {
     }
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -4036,7 +4036,7 @@ Node* CodeStubAssembler::ToNumber(Node* context, Node* input) {
   var_result.Bind(input);
   Goto(&end);
 
-  Bind(&not_smi);
+  BIND(&not_smi);
   {
     Label not_heap_number(this, Label::kDeferred);
     Node* input_map = LoadMap(input);
@@ -4045,14 +4045,14 @@ Node* CodeStubAssembler::ToNumber(Node* context, Node* input) {
     var_result.Bind(input);
     Goto(&end);
 
-    Bind(&not_heap_number);
+    BIND(&not_heap_number);
     {
       var_result.Bind(NonNumberToNumber(context, input));
       Goto(&end);
     }
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -4070,7 +4070,7 @@ Node* CodeStubAssembler::ToUint32(Node* context, Node* input) {
     // have a ToNumber with multiple exits.
     Label next(this, Label::kDeferred);
     Branch(TaggedIsPositiveSmi(input), &out, &next);
-    Bind(&next);
+    BIND(&next);
   }
 
   Node* const number = ToNumber(context, input);
@@ -4080,13 +4080,13 @@ Node* CodeStubAssembler::ToUint32(Node* context, Node* input) {
   {
     Label next(this, Label::kDeferred);
     Branch(TaggedIsPositiveSmi(number), &out, &next);
-    Bind(&next);
+    BIND(&next);
   }
 
   Label if_isnegativesmi(this), if_isheapnumber(this);
   Branch(TaggedIsSmi(number), &if_isnegativesmi, &if_isheapnumber);
 
-  Bind(&if_isnegativesmi);
+  BIND(&if_isnegativesmi);
   {
     // floor({input}) mod 2^32 === {input} + 2^32.
     Node* const float_number = SmiToFloat64(number);
@@ -4096,7 +4096,7 @@ Node* CodeStubAssembler::ToUint32(Node* context, Node* input) {
     Goto(&out);
   }
 
-  Bind(&if_isheapnumber);
+  BIND(&if_isheapnumber);
   {
     Label return_zero(this);
     Node* const value = LoadHeapNumberValue(number);
@@ -4105,14 +4105,14 @@ Node* CodeStubAssembler::ToUint32(Node* context, Node* input) {
       // +-0.
       Label next(this);
       Branch(Float64Equal(value, float_zero), &return_zero, &next);
-      Bind(&next);
+      BIND(&next);
     }
 
     {
       // NaN.
       Label next(this);
       Branch(Float64Equal(value, value), &next, &return_zero);
-      Bind(&next);
+      BIND(&next);
     }
 
     {
@@ -4121,7 +4121,7 @@ Node* CodeStubAssembler::ToUint32(Node* context, Node* input) {
       Node* const positive_infinity =
           Float64Constant(std::numeric_limits<double>::infinity());
       Branch(Float64Equal(value, positive_infinity), &return_zero, &next);
-      Bind(&next);
+      BIND(&next);
     }
 
     {
@@ -4130,7 +4130,7 @@ Node* CodeStubAssembler::ToUint32(Node* context, Node* input) {
       Node* const negative_infinity =
           Float64Constant(-1.0 * std::numeric_limits<double>::infinity());
       Branch(Float64Equal(value, negative_infinity), &return_zero, &next);
-      Bind(&next);
+      BIND(&next);
     }
 
     // Return floor({input}) mod 2^32 (assuming mod semantics that always return
@@ -4146,14 +4146,14 @@ Node* CodeStubAssembler::ToUint32(Node* context, Node* input) {
       Goto(&out);
     }
 
-    Bind(&return_zero);
+    BIND(&return_zero);
     {
       var_result.Bind(SmiConstant(Smi::kZero));
       Goto(&out);
     }
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -4174,11 +4174,11 @@ Node* CodeStubAssembler::ToString(Node* context, Node* input) {
   Label not_heap_number(this);
   Branch(IsHeapNumberMap(input_map), &is_number, &not_heap_number);
 
-  Bind(&is_number);
+  BIND(&is_number);
   result.Bind(NumberToString(context, input));
   Goto(&done);
 
-  Bind(&not_heap_number);
+  BIND(&not_heap_number);
   {
     GotoIf(Word32NotEqual(input_instance_type, Int32Constant(ODDBALL_TYPE)),
            &runtime);
@@ -4186,13 +4186,13 @@ Node* CodeStubAssembler::ToString(Node* context, Node* input) {
     Goto(&done);
   }
 
-  Bind(&runtime);
+  BIND(&runtime);
   {
     result.Bind(CallRuntime(Runtime::kToString, context, input));
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -4203,7 +4203,7 @@ Node* CodeStubAssembler::JSReceiverToPrimitive(Node* context, Node* input) {
 
   BranchIfJSReceiver(input, &if_isreceiver, &if_isnotreceiver);
 
-  Bind(&if_isreceiver);
+  BIND(&if_isreceiver);
   {
     // Convert {input} to a primitive first passing Number hint.
     Callable callable = CodeFactory::NonPrimitiveToPrimitive(isolate());
@@ -4211,13 +4211,13 @@ Node* CodeStubAssembler::JSReceiverToPrimitive(Node* context, Node* input) {
     Goto(&done);
   }
 
-  Bind(&if_isnotreceiver);
+  BIND(&if_isnotreceiver);
   {
     result.Bind(input);
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -4228,24 +4228,24 @@ Node* CodeStubAssembler::ToSmiIndex(Node* const input, Node* const context,
       negative_check(this), done(this);
   Branch(TaggedIsSmi(result.value()), &negative_check, &check_undefined);
 
-  Bind(&check_undefined);
+  BIND(&check_undefined);
   Branch(IsUndefined(result.value()), &return_zero, &defined);
 
-  Bind(&defined);
+  BIND(&defined);
   result.Bind(ToInteger(context, result.value(),
                         CodeStubAssembler::kTruncateMinusZero));
   GotoIfNot(TaggedIsSmi(result.value()), range_error);
   CSA_ASSERT(this, TaggedIsSmi(result.value()));
   Goto(&negative_check);
 
-  Bind(&negative_check);
+  BIND(&negative_check);
   Branch(SmiLessThan(result.value(), SmiConstant(0)), range_error, &done);
 
-  Bind(&return_zero);
+  BIND(&return_zero);
   result.Bind(SmiConstant(0));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -4255,21 +4255,21 @@ Node* CodeStubAssembler::ToSmiLength(Node* input, Node* const context,
   Label to_integer(this), negative_check(this), return_zero(this), done(this);
   Branch(TaggedIsSmi(result.value()), &negative_check, &to_integer);
 
-  Bind(&to_integer);
+  BIND(&to_integer);
   result.Bind(ToInteger(context, result.value(),
                         CodeStubAssembler::kTruncateMinusZero));
   GotoIfNot(TaggedIsSmi(result.value()), range_error);
   CSA_ASSERT(this, TaggedIsSmi(result.value()));
   Goto(&negative_check);
 
-  Bind(&negative_check);
+  BIND(&negative_check);
   Branch(SmiLessThan(result.value(), SmiConstant(0)), &return_zero, &done);
 
-  Bind(&return_zero);
+  BIND(&return_zero);
   result.Bind(SmiConstant(0));
   Goto(&done);
 
-  Bind(&done);
+  BIND(&done);
   return result.value();
 }
 
@@ -4279,7 +4279,7 @@ Node* CodeStubAssembler::ToInteger(Node* context, Node* input,
   Variable var_arg(this, MachineRepresentation::kTagged, input);
   Label loop(this, &var_arg), out(this);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Shared entry points.
     Label return_zero(this, Label::kDeferred);
@@ -4296,7 +4296,7 @@ Node* CodeStubAssembler::ToInteger(Node* context, Node* input,
     Branch(IsHeapNumberMap(LoadMap(arg)), &if_argisheapnumber,
            &if_argisnotheapnumber);
 
-    Bind(&if_argisheapnumber);
+    BIND(&if_argisheapnumber);
     {
       // Load the floating-point value of {arg}.
       Node* arg_value = LoadHeapNumberValue(arg);
@@ -4316,7 +4316,7 @@ Node* CodeStubAssembler::ToInteger(Node* context, Node* input,
       Goto(&out);
     }
 
-    Bind(&if_argisnotheapnumber);
+    BIND(&if_argisnotheapnumber);
     {
       // Need to convert {arg} to a Number first.
       Callable callable = CodeFactory::NonNumberToNumber(isolate());
@@ -4324,12 +4324,12 @@ Node* CodeStubAssembler::ToInteger(Node* context, Node* input,
       Goto(&loop);
     }
 
-    Bind(&return_zero);
+    BIND(&return_zero);
     var_arg.Bind(SmiConstant(Smi::kZero));
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_arg.value();
 }
 
@@ -4398,7 +4398,7 @@ void CodeStubAssembler::TryToName(Node* key, Label* if_keyisindex,
   var_index->Bind(TryToIntptr(key, &if_keyisnotindex));
   Goto(if_keyisindex);
 
-  Bind(&if_keyisnotindex);
+  BIND(&if_keyisnotindex);
   Node* key_map = LoadMap(key);
   var_unique->Bind(key);
   // Symbols are unique.
@@ -4430,11 +4430,11 @@ void CodeStubAssembler::TryToName(Node* key, Label* if_keyisindex,
   GotoIf(Word32NotEqual(not_internalized, Int32Constant(0)), if_bailout);
   Goto(if_keyisunique);
 
-  Bind(&if_thinstring);
+  BIND(&if_thinstring);
   var_unique->Bind(LoadObjectField(key, ThinString::kActualOffset));
   Goto(if_keyisunique);
 
-  Bind(&if_hascachedindex);
+  BIND(&if_hascachedindex);
   var_index->Bind(DecodeWordFromWord32<Name::ArrayIndexValueBits>(hash));
   Goto(if_keyisindex);
 }
@@ -4548,7 +4548,7 @@ void CodeStubAssembler::NameDictionaryLookup(Node* dictionary,
   Variable* loop_vars[] = {&var_count, &var_entry, var_name_index};
   Label loop(this, 3, loop_vars);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* entry = var_entry.value();
 
@@ -4627,7 +4627,7 @@ void CodeStubAssembler::NumberDictionaryLookup(Node* dictionary,
   Label loop(this, 2, loop_vars);
   var_entry->Bind(entry);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* entry = var_entry->value();
 
@@ -4638,12 +4638,12 @@ void CodeStubAssembler::NumberDictionaryLookup(Node* dictionary,
     {
       Label if_currentissmi(this), if_currentisnotsmi(this);
       Branch(TaggedIsSmi(current), &if_currentissmi, &if_currentisnotsmi);
-      Bind(&if_currentissmi);
+      BIND(&if_currentissmi);
       {
         Node* current_value = SmiUntag(current);
         Branch(WordEqual(current_value, intptr_index), if_found, &next_probe);
       }
-      Bind(&if_currentisnotsmi);
+      BIND(&if_currentisnotsmi);
       {
         GotoIf(WordEqual(current, the_hole), &next_probe);
         // Current must be the Number.
@@ -4653,7 +4653,7 @@ void CodeStubAssembler::NumberDictionaryLookup(Node* dictionary,
       }
     }
 
-    Bind(&next_probe);
+    BIND(&next_probe);
     // See Dictionary::NextProbe().
     Increment(var_count);
     entry = WordAnd(IntPtrAdd(entry, var_count.value()), mask);
@@ -4675,7 +4675,7 @@ void CodeStubAssembler::FindInsertionEntry<NameDictionary>(
   Label done(this);
   NameDictionaryLookup<NameDictionary>(dictionary, key, nullptr, var_key_index,
                                        &done, 0, kFindInsertionIndex);
-  Bind(&done);
+  BIND(&done);
 }
 
 template <class Dictionary>
@@ -4712,7 +4712,7 @@ void CodeStubAssembler::InsertEntry<NameDictionary>(Node* dictionary,
       SmiShl(SmiConstant(DONT_ENUM), PropertyDetails::AttributesField::kShift);
   var_details.Bind(SmiOr(var_details.value(), dont_enum));
   Goto(&not_private);
-  Bind(&not_private);
+  BIND(&not_private);
 
   // Finally, store the details.
   StoreDetailsByKeyIndex<NameDictionary>(dictionary, index,
@@ -4848,7 +4848,7 @@ void CodeStubAssembler::DescriptorLookupBinary(Node* unique_name,
   Variable* loop_vars[] = {&var_high, &var_low};
   Label binary_loop(this, 2, loop_vars);
   Goto(&binary_loop);
-  Bind(&binary_loop);
+  BIND(&binary_loop);
   {
     // mid = low + (high - low) / 2 (to avoid overflow in "(low + high) / 2").
     Node* mid =
@@ -4862,23 +4862,23 @@ void CodeStubAssembler::DescriptorLookupBinary(Node* unique_name,
 
     Label mid_greater(this), mid_less(this), merge(this);
     Branch(Uint32GreaterThanOrEqual(mid_hash, hash), &mid_greater, &mid_less);
-    Bind(&mid_greater);
+    BIND(&mid_greater);
     {
       var_high.Bind(mid);
       Goto(&merge);
     }
-    Bind(&mid_less);
+    BIND(&mid_less);
     {
       var_low.Bind(Int32Add(mid, Int32Constant(1)));
       Goto(&merge);
     }
-    Bind(&merge);
+    BIND(&merge);
     GotoIf(Word32NotEqual(var_low.value(), var_high.value()), &binary_loop);
   }
 
   Label scan_loop(this, &var_low);
   Goto(&scan_loop);
-  Bind(&scan_loop);
+  BIND(&scan_loop);
   {
     GotoIf(Int32GreaterThan(var_low.value(), limit), if_not_found);
 
@@ -4893,7 +4893,7 @@ void CodeStubAssembler::DescriptorLookupBinary(Node* unique_name,
     var_name_index->Bind(DescriptorArrayToKeyIndex(sort_index));
     Goto(if_found);
 
-    Bind(&next);
+    BIND(&next);
     var_low.Bind(Int32Add(var_low.value(), Int32Constant(1)));
     Goto(&scan_loop);
   }
@@ -4910,12 +4910,12 @@ void CodeStubAssembler::DescriptorLookup(Node* unique_name, Node* descriptors,
   const int kMaxElementsForLinearSearch = 32;
   Branch(Int32LessThanOrEqual(nof, Int32Constant(kMaxElementsForLinearSearch)),
          &linear_search, &binary_search);
-  Bind(&linear_search);
+  BIND(&linear_search);
   {
     DescriptorLookupLinear(unique_name, descriptors, ChangeInt32ToIntPtr(nof),
                            if_found, var_name_index, if_not_found);
   }
-  Bind(&binary_search);
+  BIND(&binary_search);
   {
     DescriptorLookupBinary(unique_name, descriptors, nof, if_found,
                            var_name_index, if_not_found);
@@ -4945,7 +4945,7 @@ void CodeStubAssembler::TryLookupProperty(
   Label if_isfastmap(this), if_isslowmap(this);
   Branch(IsSetWord32<Map::DictionaryMap>(bit_field3), &if_isslowmap,
          &if_isfastmap);
-  Bind(&if_isfastmap);
+  BIND(&if_isfastmap);
   {
     Node* descriptors = LoadMapDescriptors(map);
     var_meta_storage->Bind(descriptors);
@@ -4953,7 +4953,7 @@ void CodeStubAssembler::TryLookupProperty(
     DescriptorLookup(unique_name, descriptors, bit_field3, if_found_fast,
                      var_name_index, if_not_found);
   }
-  Bind(&if_isslowmap);
+  BIND(&if_isslowmap);
   {
     Node* dictionary = LoadProperties(object);
     var_meta_storage->Bind(dictionary);
@@ -4961,7 +4961,7 @@ void CodeStubAssembler::TryLookupProperty(
     NameDictionaryLookup<NameDictionary>(dictionary, unique_name, if_found_dict,
                                          var_name_index, if_not_found);
   }
-  Bind(&if_objectisspecial);
+  BIND(&if_objectisspecial);
   {
     // Handle global object here and other special objects in runtime.
     GotoIfNot(Word32Equal(instance_type, Int32Constant(JS_GLOBAL_OBJECT_TYPE)),
@@ -4995,7 +4995,7 @@ void CodeStubAssembler::TryHasOwnProperty(Node* object, Node* map,
   TryLookupProperty(object, map, instance_type, unique_name, if_found, if_found,
                     &if_found_global, &var_meta_storage, &var_name_index,
                     if_not_found, if_bailout);
-  Bind(&if_found_global);
+  BIND(&if_found_global);
   {
     Variable var_value(this, MachineRepresentation::kTagged);
     Variable var_details(this, MachineRepresentation::kWord32);
@@ -5025,7 +5025,7 @@ void CodeStubAssembler::LoadPropertyFromFastObject(Node* object, Node* map,
   Label if_in_field(this), if_in_descriptor(this), done(this);
   Branch(Word32Equal(location, Int32Constant(kField)), &if_in_field,
          &if_in_descriptor);
-  Bind(&if_in_field);
+  BIND(&if_in_field);
   {
     Node* field_index =
         DecodeWordFromWord32<PropertyDetails::FieldIndexField>(details);
@@ -5039,7 +5039,7 @@ void CodeStubAssembler::LoadPropertyFromFastObject(Node* object, Node* map,
     Label rebox_double(this, &var_double_value);
     Branch(UintPtrLessThan(field_index, inobject_properties), &if_inobject,
            &if_backing_store);
-    Bind(&if_inobject);
+    BIND(&if_inobject);
     {
       Comment("if_inobject");
       Node* field_offset =
@@ -5051,12 +5051,12 @@ void CodeStubAssembler::LoadPropertyFromFastObject(Node* object, Node* map,
       Branch(Word32NotEqual(representation,
                             Int32Constant(Representation::kDouble)),
              &if_tagged, &if_double);
-      Bind(&if_tagged);
+      BIND(&if_tagged);
       {
         var_value->Bind(LoadObjectField(object, field_offset));
         Goto(&done);
       }
-      Bind(&if_double);
+      BIND(&if_double);
       {
         if (FLAG_unbox_double_fields) {
           var_double_value.Bind(
@@ -5068,7 +5068,7 @@ void CodeStubAssembler::LoadPropertyFromFastObject(Node* object, Node* map,
         Goto(&rebox_double);
       }
     }
-    Bind(&if_backing_store);
+    BIND(&if_backing_store);
     {
       Comment("if_backing_store");
       Node* properties = LoadProperties(object);
@@ -5079,18 +5079,18 @@ void CodeStubAssembler::LoadPropertyFromFastObject(Node* object, Node* map,
       Branch(Word32NotEqual(representation,
                             Int32Constant(Representation::kDouble)),
              &if_tagged, &if_double);
-      Bind(&if_tagged);
+      BIND(&if_tagged);
       {
         var_value->Bind(value);
         Goto(&done);
       }
-      Bind(&if_double);
+      BIND(&if_double);
       {
         var_double_value.Bind(LoadHeapNumberValue(value));
         Goto(&rebox_double);
       }
     }
-    Bind(&rebox_double);
+    BIND(&rebox_double);
     {
       Comment("rebox_double");
       Node* heap_number = AllocateHeapNumberWithValue(var_double_value.value());
@@ -5098,13 +5098,13 @@ void CodeStubAssembler::LoadPropertyFromFastObject(Node* object, Node* map,
       Goto(&done);
     }
   }
-  Bind(&if_in_descriptor);
+  BIND(&if_in_descriptor);
   {
     var_value->Bind(
         LoadValueByKeyIndex<DescriptorArray>(descriptors, name_index));
     Goto(&done);
   }
-  Bind(&done);
+  BIND(&done);
 
   Comment("] LoadPropertyFromFastObject");
 }
@@ -5184,7 +5184,7 @@ Node* CodeStubAssembler::CallGetterIfAccessor(Node* value, Node* details,
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return var_value.value();
 }
 
@@ -5207,7 +5207,7 @@ void CodeStubAssembler::TryGetOwnProperty(
   TryLookupProperty(object, map, instance_type, unique_name, &if_found_fast,
                     &if_found_dict, &if_found_global, &var_meta_storage,
                     &var_entry, if_not_found, if_bailout);
-  Bind(&if_found_fast);
+  BIND(&if_found_fast);
   {
     Node* descriptors = var_meta_storage.value();
     Node* name_index = var_entry.value();
@@ -5216,14 +5216,14 @@ void CodeStubAssembler::TryGetOwnProperty(
                                &var_details, var_value);
     Goto(&if_found);
   }
-  Bind(&if_found_dict);
+  BIND(&if_found_dict);
   {
     Node* dictionary = var_meta_storage.value();
     Node* entry = var_entry.value();
     LoadPropertyFromNameDictionary(dictionary, entry, &var_details, var_value);
     Goto(&if_found);
   }
-  Bind(&if_found_global);
+  BIND(&if_found_global);
   {
     Node* dictionary = var_meta_storage.value();
     Node* entry = var_entry.value();
@@ -5233,7 +5233,7 @@ void CodeStubAssembler::TryGetOwnProperty(
     Goto(&if_found);
   }
   // Here we have details and value which could be an accessor.
-  Bind(&if_found);
+  BIND(&if_found);
   {
     Node* value = CallGetterIfAccessor(var_value->value(), var_details.value(),
                                        context, receiver, if_bailout);
@@ -5306,7 +5306,7 @@ void CodeStubAssembler::TryLookupElement(Node* object, Node* map,
   STATIC_ASSERT(arraysize(values) == arraysize(labels));
   Switch(elements_kind, if_bailout, values, labels, arraysize(values));
 
-  Bind(&if_isobjectorsmi);
+  BIND(&if_isobjectorsmi);
   {
     Node* elements = LoadElements(object);
     Node* length = LoadAndUntagFixedArrayBaseLength(elements);
@@ -5317,7 +5317,7 @@ void CodeStubAssembler::TryLookupElement(Node* object, Node* map,
     Node* the_hole = TheHoleConstant();
     Branch(WordEqual(element, the_hole), if_not_found, if_found);
   }
-  Bind(&if_isdouble);
+  BIND(&if_isdouble);
   {
     Node* elements = LoadElements(object);
     Node* length = LoadAndUntagFixedArrayBaseLength(elements);
@@ -5329,7 +5329,7 @@ void CodeStubAssembler::TryLookupElement(Node* object, Node* map,
                                 INTPTR_PARAMETERS, if_not_found);
     Goto(if_found);
   }
-  Bind(&if_isdictionary);
+  BIND(&if_isdictionary);
   {
     // Negative keys must be converted to property names.
     GotoIf(IntPtrLessThan(intptr_index, IntPtrConstant(0)), if_bailout);
@@ -5339,7 +5339,7 @@ void CodeStubAssembler::TryLookupElement(Node* object, Node* map,
     NumberDictionaryLookup<SeededNumberDictionary>(
         elements, intptr_index, if_found, &var_entry, if_not_found);
   }
-  Bind(&if_isfaststringwrapper);
+  BIND(&if_isfaststringwrapper);
   {
     CSA_ASSERT(this, HasInstanceType(object, JS_VALUE_TYPE));
     Node* string = LoadJSValueValue(object);
@@ -5348,7 +5348,7 @@ void CodeStubAssembler::TryLookupElement(Node* object, Node* map,
     GotoIf(UintPtrLessThan(intptr_index, SmiUntag(length)), if_found);
     Goto(&if_isobjectorsmi);
   }
-  Bind(&if_isslowstringwrapper);
+  BIND(&if_isslowstringwrapper);
   {
     CSA_ASSERT(this, HasInstanceType(object, JS_VALUE_TYPE));
     Node* string = LoadJSValueValue(object);
@@ -5357,7 +5357,7 @@ void CodeStubAssembler::TryLookupElement(Node* object, Node* map,
     GotoIf(UintPtrLessThan(intptr_index, SmiUntag(length)), if_found);
     Goto(&if_isdictionary);
   }
-  Bind(&if_typedarray);
+  BIND(&if_typedarray);
   {
     Node* buffer = LoadObjectField(object, JSArrayBufferView::kBufferOffset);
     GotoIf(IsDetachedBuffer(buffer), if_absent);
@@ -5366,7 +5366,7 @@ void CodeStubAssembler::TryLookupElement(Node* object, Node* map,
         LoadObjectField(object, JSTypedArray::kLengthOffset), if_bailout);
     Branch(UintPtrLessThan(intptr_index, length), if_found, if_absent);
   }
-  Bind(&if_oob);
+  BIND(&if_oob);
   {
     // Positive OOB indices mean "not found", negative indices must be
     // converted to property names.
@@ -5388,7 +5388,7 @@ void CodeStubAssembler::TryPrototypeChainLookup(
   // Ensure receiver is JSReceiver, otherwise bailout.
   Label if_objectisnotsmi(this);
   Branch(TaggedIsSmi(receiver), if_bailout, &if_objectisnotsmi);
-  Bind(&if_objectisnotsmi);
+  BIND(&if_objectisnotsmi);
 
   Node* map = LoadMap(receiver);
   Node* instance_type = LoadMapInstanceType(map);
@@ -5399,7 +5399,7 @@ void CodeStubAssembler::TryPrototypeChainLookup(
     Branch(
         Int32GreaterThan(instance_type, Int32Constant(FIRST_JS_RECEIVER_TYPE)),
         &if_objectisreceiver, if_bailout);
-    Bind(&if_objectisreceiver);
+    BIND(&if_objectisreceiver);
   }
 
   Variable var_index(this, MachineType::PointerRepresentation());
@@ -5409,7 +5409,7 @@ void CodeStubAssembler::TryPrototypeChainLookup(
   TryToName(key, &if_keyisindex, &var_index, &if_iskeyunique, &var_unique,
             if_bailout);
 
-  Bind(&if_iskeyunique);
+  BIND(&if_iskeyunique);
   {
     Variable var_holder(this, MachineRepresentation::kTagged, receiver);
     Variable var_holder_map(this, MachineRepresentation::kTagged, map);
@@ -5420,7 +5420,7 @@ void CodeStubAssembler::TryPrototypeChainLookup(
                                     &var_holder_instance_type};
     Label loop(this, arraysize(merged_variables), merged_variables);
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       Node* holder_map = var_holder_map.value();
       Node* holder_instance_type = var_holder_instance_type.value();
@@ -5429,7 +5429,7 @@ void CodeStubAssembler::TryPrototypeChainLookup(
       lookup_property_in_holder(receiver, var_holder.value(), holder_map,
                                 holder_instance_type, var_unique.value(),
                                 &next_proto, if_bailout);
-      Bind(&next_proto);
+      BIND(&next_proto);
 
       // Bailout if it can be an integer indexed exotic case.
       GotoIf(
@@ -5440,7 +5440,7 @@ void CodeStubAssembler::TryPrototypeChainLookup(
 
       Label if_not_null(this);
       Branch(WordEqual(proto, NullConstant()), if_end, &if_not_null);
-      Bind(&if_not_null);
+      BIND(&if_not_null);
 
       Node* map = LoadMap(proto);
       Node* instance_type = LoadMapInstanceType(map);
@@ -5451,7 +5451,7 @@ void CodeStubAssembler::TryPrototypeChainLookup(
       Goto(&loop);
     }
   }
-  Bind(&if_keyisindex);
+  BIND(&if_keyisindex);
   {
     Variable var_holder(this, MachineRepresentation::kTagged, receiver);
     Variable var_holder_map(this, MachineRepresentation::kTagged, map);
@@ -5462,20 +5462,20 @@ void CodeStubAssembler::TryPrototypeChainLookup(
                                     &var_holder_instance_type};
     Label loop(this, arraysize(merged_variables), merged_variables);
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       Label next_proto(this);
       lookup_element_in_holder(receiver, var_holder.value(),
                                var_holder_map.value(),
                                var_holder_instance_type.value(),
                                var_index.value(), &next_proto, if_bailout);
-      Bind(&next_proto);
+      BIND(&next_proto);
 
       Node* proto = LoadMapPrototype(var_holder_map.value());
 
       Label if_not_null(this);
       Branch(WordEqual(proto, NullConstant()), if_end, &if_not_null);
-      Bind(&if_not_null);
+      BIND(&if_not_null);
 
       Node* map = LoadMap(proto);
       Node* instance_type = LoadMapInstanceType(map);
@@ -5514,7 +5514,7 @@ Node* CodeStubAssembler::OrdinaryHasInstance(Node* context, Node* callable,
               &instanceof_cache_miss);
     var_result.Bind(LoadRoot(Heap::kInstanceofCacheAnswerRootIndex));
     Goto(&return_result);
-    Bind(&instanceof_cache_miss);
+    BIND(&instanceof_cache_miss);
   }
 
   // Goto runtime if {callable} is a Smi.
@@ -5559,7 +5559,7 @@ Node* CodeStubAssembler::OrdinaryHasInstance(Node* context, Node* callable,
     var_callable_prototype.Bind(
         LoadObjectField(callable_prototype, Map::kPrototypeOffset));
     Goto(&callable_prototype_valid);
-    Bind(&callable_prototype_valid);
+    BIND(&callable_prototype_valid);
     callable_prototype = var_callable_prototype.value();
   }
 
@@ -5572,7 +5572,7 @@ Node* CodeStubAssembler::OrdinaryHasInstance(Node* context, Node* callable,
   Variable var_object_map(this, MachineRepresentation::kTagged, object_map);
   Label loop(this, &var_object_map);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* object_map = var_object_map.value();
 
@@ -5599,17 +5599,17 @@ Node* CodeStubAssembler::OrdinaryHasInstance(Node* context, Node* callable,
     Goto(&loop);
   }
 
-  Bind(&return_true);
+  BIND(&return_true);
   StoreRoot(Heap::kInstanceofCacheAnswerRootIndex, BooleanConstant(true));
   var_result.Bind(BooleanConstant(true));
   Goto(&return_result);
 
-  Bind(&return_false);
+  BIND(&return_false);
   StoreRoot(Heap::kInstanceofCacheAnswerRootIndex, BooleanConstant(false));
   var_result.Bind(BooleanConstant(false));
   Goto(&return_result);
 
-  Bind(&return_runtime);
+  BIND(&return_runtime);
   {
     // Invalidate the global instanceof cache.
     StoreRoot(Heap::kInstanceofCacheFunctionRootIndex, SmiConstant(0));
@@ -5619,7 +5619,7 @@ Node* CodeStubAssembler::OrdinaryHasInstance(Node* context, Node* callable,
   }
   Goto(&return_result);
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
@@ -5694,13 +5694,13 @@ Node* CodeStubAssembler::TryToIntptr(Node* key, Label* miss) {
     Goto(&done);
   }
 
-  Bind(&key_is_smi);
+  BIND(&key_is_smi);
   {
     var_intptr_key.Bind(SmiUntag(key));
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return var_intptr_key.value();
 }
 
@@ -5755,7 +5755,7 @@ Node* CodeStubAssembler::EmitKeyedSloppyArguments(Node* receiver, Node* key,
       LoadFixedArrayElement(elements, IntPtrAdd(key, intptr_two));
   Branch(WordEqual(mapped_index, TheHoleConstant()), &if_unmapped, &if_mapped);
 
-  Bind(&if_mapped);
+  BIND(&if_mapped);
   {
     CSA_ASSERT(this, TaggedIsSmi(mapped_index));
     mapped_index = SmiUntag(mapped_index);
@@ -5775,7 +5775,7 @@ Node* CodeStubAssembler::EmitKeyedSloppyArguments(Node* receiver, Node* key,
     Goto(&end);
   }
 
-  Bind(&if_unmapped);
+  BIND(&if_unmapped);
   {
     Node* backing_store = LoadFixedArrayElement(elements, 1);
     GotoIf(WordNotEqual(LoadMap(backing_store), FixedArrayMapConstant()),
@@ -5796,7 +5796,7 @@ Node* CodeStubAssembler::EmitKeyedSloppyArguments(Node* receiver, Node* key,
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -5873,7 +5873,7 @@ Node* CodeStubAssembler::Int32ToUint8Clamped(Node* int32_value) {
   GotoIf(Int32LessThan(int32_value, int32_zero), &done);
   var_value.Bind(int32_255);
   Goto(&done);
-  Bind(&done);
+  BIND(&done);
   return var_value.value();
 }
 
@@ -5888,7 +5888,7 @@ Node* CodeStubAssembler::Float64ToUint8Clamped(Node* float64_value) {
     var_value.Bind(TruncateFloat64ToWord32(rounded_value));
     Goto(&done);
   }
-  Bind(&done);
+  BIND(&done);
   return var_value.value();
 }
 
@@ -5940,7 +5940,7 @@ Node* CodeStubAssembler::PrepareValueForWriteToTypedArray(
     Goto(&done);
   }
 
-  Bind(&if_smi);
+  BIND(&if_smi);
   {
     Node* value = SmiToWord32(input);
     if (rep == MachineRepresentation::kFloat32) {
@@ -5957,7 +5957,7 @@ Node* CodeStubAssembler::PrepareValueForWriteToTypedArray(
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return var_result.value();
 }
 
@@ -6018,7 +6018,7 @@ void CodeStubAssembler::EmitElementStore(Node* object, Node* key, Node* value,
     StoreElement(backing_store, elements_kind, key, value, parameter_mode);
     Goto(&done);
 
-    Bind(&done);
+    BIND(&done);
     return;
   }
   DCHECK(IsFastSmiOrObjectElementsKind(elements_kind) ||
@@ -6068,7 +6068,7 @@ Node* CodeStubAssembler::CheckForCapacityGrow(Node* object, Node* elements,
   }
   Branch(condition, &grow_case, &no_grow_case);
 
-  Bind(&grow_case);
+  BIND(&grow_case);
   {
     Node* current_capacity =
         TaggedToParameter(LoadFixedArrayBaseLength(elements), mode);
@@ -6084,7 +6084,7 @@ Node* CodeStubAssembler::CheckForCapacityGrow(Node* object, Node* elements,
       checked_elements.Bind(new_elements);
       Goto(&fits_capacity);
     }
-    Bind(&fits_capacity);
+    BIND(&fits_capacity);
 
     if (is_js_array) {
       Node* new_length = IntPtrAdd(key, IntPtrOrSmiConstant(1, mode));
@@ -6094,14 +6094,14 @@ Node* CodeStubAssembler::CheckForCapacityGrow(Node* object, Node* elements,
     Goto(&done);
   }
 
-  Bind(&no_grow_case);
+  BIND(&no_grow_case);
   {
     GotoIfNot(UintPtrLessThan(key, length), bailout);
     checked_elements.Bind(elements);
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return checked_elements.value();
 }
 
@@ -6125,7 +6125,7 @@ Node* CodeStubAssembler::CopyElementsOnWrite(Node* object, Node* elements,
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return new_elements_var.value();
 }
 
@@ -6160,7 +6160,7 @@ void CodeStubAssembler::TransitionElementsKind(Node* object, Node* map,
     GrowElementsCapacity(object, elements, from_kind, to_kind, array_length,
                          elements_length, mode, bailout);
     Goto(&done);
-    Bind(&done);
+    BIND(&done);
   }
 
   StoreMap(object, map);
@@ -6209,21 +6209,21 @@ void CodeStubAssembler::TrapAllocationMemento(Node* object,
 
   // If top is on the same page as the current object, we need to check whether
   // we are below top.
-  Bind(&top_check);
+  BIND(&top_check);
   {
     Branch(UintPtrGreaterThanOrEqual(memento_last_word, new_space_top),
            &no_memento_found, &map_check);
   }
 
   // Memento map check.
-  Bind(&map_check);
+  BIND(&map_check);
   {
     Node* memento_map = LoadObjectField(object, kMementoMapOffset);
     Branch(
         WordEqual(memento_map, LoadRoot(Heap::kAllocationMementoMapRootIndex)),
         memento_found, &no_memento_found);
   }
-  Bind(&no_memento_found);
+  BIND(&no_memento_found);
   Comment("] TrapAllocationMemento");
 }
 
@@ -6314,7 +6314,7 @@ Node* CodeStubAssembler::BuildFastLoop(
   // it from the pre-header). The extra branch is slower in the case that the
   // loop actually iterates.
   Branch(WordEqual(var.value(), end_index), &after_loop, &loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     if (advance_mode == IndexAdvanceMode::kPre) {
       Increment(var, increment, parameter_mode);
@@ -6325,7 +6325,7 @@ Node* CodeStubAssembler::BuildFastLoop(
     }
     Branch(WordNotEqual(var.value(), end_index), &loop, &after_loop);
   }
-  Bind(&after_loop);
+  BIND(&after_loop);
   return var.value();
 }
 
@@ -6422,13 +6422,13 @@ void CodeStubAssembler::BranchIfNumericRelationalComparison(
   Label if_lhsissmi(this), if_lhsisnotsmi(this);
   Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-  Bind(&if_lhsissmi);
+  BIND(&if_lhsissmi);
   {
     // Check if {rhs} is a Smi or a HeapObject.
     Label if_rhsissmi(this), if_rhsisnotsmi(this);
     Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-    Bind(&if_rhsissmi);
+    BIND(&if_rhsissmi);
     {
       // Both {lhs} and {rhs} are Smi, so just perform a fast Smi comparison.
       switch (mode) {
@@ -6447,7 +6447,7 @@ void CodeStubAssembler::BranchIfNumericRelationalComparison(
       }
     }
 
-    Bind(&if_rhsisnotsmi);
+    BIND(&if_rhsisnotsmi);
     {
       CSA_ASSERT(this, IsHeapNumberMap(LoadMap(rhs)));
       // Convert the {lhs} and {rhs} to floating point values, and
@@ -6458,7 +6458,7 @@ void CodeStubAssembler::BranchIfNumericRelationalComparison(
     }
   }
 
-  Bind(&if_lhsisnotsmi);
+  BIND(&if_lhsisnotsmi);
   {
     CSA_ASSERT(this, IsHeapNumberMap(LoadMap(lhs)));
 
@@ -6466,7 +6466,7 @@ void CodeStubAssembler::BranchIfNumericRelationalComparison(
     Label if_rhsissmi(this), if_rhsisnotsmi(this);
     Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-    Bind(&if_rhsissmi);
+    BIND(&if_rhsissmi);
     {
       // Convert the {lhs} and {rhs} to floating point values, and
       // perform a floating point comparison.
@@ -6475,7 +6475,7 @@ void CodeStubAssembler::BranchIfNumericRelationalComparison(
       Goto(&do_fcmp);
     }
 
-    Bind(&if_rhsisnotsmi);
+    BIND(&if_rhsisnotsmi);
     {
       CSA_ASSERT(this, IsHeapNumberMap(LoadMap(rhs)));
 
@@ -6487,7 +6487,7 @@ void CodeStubAssembler::BranchIfNumericRelationalComparison(
     }
   }
 
-  Bind(&do_fcmp);
+  BIND(&do_fcmp);
   {
     // Load the {lhs} and {rhs} floating point values.
     Node* lhs = var_fcmp_lhs.value();
@@ -6515,7 +6515,7 @@ void CodeStubAssembler::GotoUnlessNumberLessThan(Node* lhs, Node* rhs,
                                                  Label* if_false) {
   Label if_true(this);
   BranchIfNumericRelationalComparison(kLessThan, lhs, rhs, &if_true, if_false);
-  Bind(&if_true);
+  BIND(&if_true);
 }
 
 Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
@@ -6536,7 +6536,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
   Variable* loop_vars[2] = {&var_lhs, &var_rhs};
   Label loop(this, 2, loop_vars);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {lhs} and {rhs} values.
     lhs = var_lhs.value();
@@ -6546,13 +6546,13 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
     Label if_lhsissmi(this), if_lhsisnotsmi(this);
     Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-    Bind(&if_lhsissmi);
+    BIND(&if_lhsissmi);
     {
       // Check if {rhs} is a Smi or a HeapObject.
       Label if_rhsissmi(this), if_rhsisnotsmi(this);
       Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-      Bind(&if_rhsissmi);
+      BIND(&if_rhsissmi);
       {
         // Both {lhs} and {rhs} are Smi, so just perform a fast Smi comparison.
         switch (mode) {
@@ -6571,7 +6571,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
         }
       }
 
-      Bind(&if_rhsisnotsmi);
+      BIND(&if_rhsisnotsmi);
       {
         // Load the map of {rhs}.
         Node* rhs_map = LoadMap(rhs);
@@ -6580,7 +6580,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
         Label if_rhsisnumber(this), if_rhsisnotnumber(this, Label::kDeferred);
         Branch(IsHeapNumberMap(rhs_map), &if_rhsisnumber, &if_rhsisnotnumber);
 
-        Bind(&if_rhsisnumber);
+        BIND(&if_rhsisnumber);
         {
           // Convert the {lhs} and {rhs} to floating point values, and
           // perform a floating point comparison.
@@ -6589,7 +6589,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
           Goto(&do_fcmp);
         }
 
-        Bind(&if_rhsisnotnumber);
+        BIND(&if_rhsisnotnumber);
         {
           // Convert the {rhs} to a Number; we don't need to perform the
           // dedicated ToPrimitive(rhs, hint Number) operation, as the
@@ -6602,7 +6602,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
       }
     }
 
-    Bind(&if_lhsisnotsmi);
+    BIND(&if_lhsisnotsmi);
     {
       // Load the map of {lhs}.
       Node* lhs_map = LoadMap(lhs);
@@ -6611,13 +6611,13 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
       Label if_rhsissmi(this), if_rhsisnotsmi(this);
       Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-      Bind(&if_rhsissmi);
+      BIND(&if_rhsissmi);
       {
         // Check if the {lhs} is a HeapNumber.
         Label if_lhsisnumber(this), if_lhsisnotnumber(this, Label::kDeferred);
         Branch(IsHeapNumberMap(lhs_map), &if_lhsisnumber, &if_lhsisnotnumber);
 
-        Bind(&if_lhsisnumber);
+        BIND(&if_lhsisnumber);
         {
           // Convert the {lhs} and {rhs} to floating point values, and
           // perform a floating point comparison.
@@ -6626,7 +6626,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
           Goto(&do_fcmp);
         }
 
-        Bind(&if_lhsisnotnumber);
+        BIND(&if_lhsisnotnumber);
         {
           // Convert the {lhs} to a Number; we don't need to perform the
           // dedicated ToPrimitive(lhs, hint Number) operation, as the
@@ -6638,7 +6638,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
         }
       }
 
-      Bind(&if_rhsisnotsmi);
+      BIND(&if_rhsisnotsmi);
       {
         // Load the map of {rhs}.
         Node* rhs_map = LoadMap(rhs);
@@ -6647,14 +6647,14 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
         Label if_lhsisnumber(this), if_lhsisnotnumber(this);
         Branch(IsHeapNumberMap(lhs_map), &if_lhsisnumber, &if_lhsisnotnumber);
 
-        Bind(&if_lhsisnumber);
+        BIND(&if_lhsisnumber);
         {
           // Check if {rhs} is also a HeapNumber.
           Label if_rhsisnumber(this), if_rhsisnotnumber(this, Label::kDeferred);
           Branch(WordEqual(lhs_map, rhs_map), &if_rhsisnumber,
                  &if_rhsisnotnumber);
 
-          Bind(&if_rhsisnumber);
+          BIND(&if_rhsisnumber);
           {
             // Convert the {lhs} and {rhs} to floating point values, and
             // perform a floating point comparison.
@@ -6663,7 +6663,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
             Goto(&do_fcmp);
           }
 
-          Bind(&if_rhsisnotnumber);
+          BIND(&if_rhsisnotnumber);
           {
             // Convert the {rhs} to a Number; we don't need to perform
             // dedicated ToPrimitive(rhs, hint Number) operation, as the
@@ -6675,7 +6675,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
           }
         }
 
-        Bind(&if_lhsisnotnumber);
+        BIND(&if_lhsisnotnumber);
         {
           // Load the instance type of {lhs}.
           Node* lhs_instance_type = LoadMapInstanceType(lhs_map);
@@ -6685,7 +6685,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
           Branch(IsStringInstanceType(lhs_instance_type), &if_lhsisstring,
                  &if_lhsisnotstring);
 
-          Bind(&if_lhsisstring);
+          BIND(&if_lhsisstring);
           {
             // Load the instance type of {rhs}.
             Node* rhs_instance_type = LoadMapInstanceType(rhs_map);
@@ -6696,7 +6696,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
             Branch(IsStringInstanceType(rhs_instance_type), &if_rhsisstring,
                    &if_rhsisnotstring);
 
-            Bind(&if_rhsisstring);
+            BIND(&if_rhsisstring);
             {
               // Both {lhs} and {rhs} are strings.
               switch (mode) {
@@ -6726,7 +6726,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
               }
             }
 
-            Bind(&if_rhsisnotstring);
+            BIND(&if_rhsisnotstring);
             {
               // The {lhs} is a String, while {rhs} is neither a Number nor a
               // String, so we need to call ToPrimitive(rhs, hint Number) if
@@ -6738,7 +6738,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
               Branch(IsJSReceiverInstanceType(rhs_instance_type),
                      &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-              Bind(&if_rhsisreceiver);
+              BIND(&if_rhsisreceiver);
               {
                 // Convert {rhs} to a primitive first passing Number hint.
                 Callable callable = CodeFactory::NonPrimitiveToPrimitive(
@@ -6747,7 +6747,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
                 Goto(&loop);
               }
 
-              Bind(&if_rhsisnotreceiver);
+              BIND(&if_rhsisnotreceiver);
               {
                 // Convert both {lhs} and {rhs} to Number.
                 Callable callable = CodeFactory::ToNumber(isolate());
@@ -6758,7 +6758,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
             }
           }
 
-          Bind(&if_lhsisnotstring);
+          BIND(&if_lhsisnotstring);
           {
             // The {lhs} is neither a Number nor a String, so we need to call
             // ToPrimitive(lhs, hint Number) if {lhs} is a receiver or
@@ -6769,7 +6769,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
             Branch(IsJSReceiverInstanceType(lhs_instance_type),
                    &if_lhsisreceiver, &if_lhsisnotreceiver);
 
-            Bind(&if_lhsisreceiver);
+            BIND(&if_lhsisreceiver);
             {
               // Convert {lhs} to a primitive first passing Number hint.
               Callable callable = CodeFactory::NonPrimitiveToPrimitive(
@@ -6778,7 +6778,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
               Goto(&loop);
             }
 
-            Bind(&if_lhsisnotreceiver);
+            BIND(&if_lhsisnotreceiver);
             {
               // Convert both {lhs} and {rhs} to Number.
               Callable callable = CodeFactory::ToNumber(isolate());
@@ -6792,7 +6792,7 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
     }
   }
 
-  Bind(&do_fcmp);
+  BIND(&do_fcmp);
   {
     // Load the {lhs} and {rhs} floating point values.
     Node* lhs = var_fcmp_lhs.value();
@@ -6816,19 +6816,19 @@ Node* CodeStubAssembler::RelationalComparison(RelationalComparisonMode mode,
     }
   }
 
-  Bind(&return_true);
+  BIND(&return_true);
   {
     result.Bind(BooleanConstant(true));
     Goto(&end);
   }
 
-  Bind(&return_false);
+  BIND(&return_false);
   {
     result.Bind(BooleanConstant(false));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return result.value();
 }
 
@@ -6848,7 +6848,7 @@ void GenerateEqual_Same(CodeStubAssembler* assembler, Node* value,
   assembler->Branch(assembler->TaggedIsSmi(value), &if_valueissmi,
                     &if_valueisnotsmi);
 
-  assembler->Bind(&if_valueisnotsmi);
+  assembler->BIND(&if_valueisnotsmi);
   {
     // Load the map of {value}.
     Node* value_map = assembler->LoadMap(value);
@@ -6858,7 +6858,7 @@ void GenerateEqual_Same(CodeStubAssembler* assembler, Node* value,
     assembler->Branch(assembler->IsHeapNumberMap(value_map), &if_valueisnumber,
                       &if_valueisnotnumber);
 
-    assembler->Bind(&if_valueisnumber);
+    assembler->BIND(&if_valueisnumber);
     {
       // Convert {value} (and therefore {rhs}) to floating point value.
       Node* value_value = assembler->LoadHeapNumberValue(value);
@@ -6867,11 +6867,11 @@ void GenerateEqual_Same(CodeStubAssembler* assembler, Node* value,
       assembler->BranchIfFloat64IsNaN(value_value, if_notequal, if_equal);
     }
 
-    assembler->Bind(&if_valueisnotnumber);
+    assembler->BIND(&if_valueisnotnumber);
     assembler->Goto(if_equal);
   }
 
-  assembler->Bind(&if_valueissmi);
+  assembler->BIND(&if_valueissmi);
   assembler->Goto(if_equal);
 }
 }  // namespace
@@ -6899,7 +6899,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
   Variable* loop_vars[2] = {&var_lhs, &var_rhs};
   Label loop(this, 2, loop_vars);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     // Load the current {lhs} and {rhs} values.
     lhs = var_lhs.value();
@@ -6909,31 +6909,31 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
     Label if_same(this), if_notsame(this);
     Branch(WordEqual(lhs, rhs), &if_same, &if_notsame);
 
-    Bind(&if_same);
+    BIND(&if_same);
     {
       // The {lhs} and {rhs} reference the exact same value, yet we need special
       // treatment for HeapNumber, as NaN is not equal to NaN.
       GenerateEqual_Same(this, lhs, &if_equal, &if_notequal);
     }
 
-    Bind(&if_notsame);
+    BIND(&if_notsame);
     {
       // Check if {lhs} is a Smi or a HeapObject.
       Label if_lhsissmi(this), if_lhsisnotsmi(this);
       Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-      Bind(&if_lhsissmi);
+      BIND(&if_lhsissmi);
       {
         // Check if {rhs} is a Smi or a HeapObject.
         Label if_rhsissmi(this), if_rhsisnotsmi(this);
         Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-        Bind(&if_rhsissmi);
+        BIND(&if_rhsissmi);
         // We have already checked for {lhs} and {rhs} being the same value, so
         // if both are Smis when we get here they must not be equal.
         Goto(&if_notequal);
 
-        Bind(&if_rhsisnotsmi);
+        BIND(&if_rhsisnotsmi);
         {
           // Load the map of {rhs}.
           Node* rhs_map = LoadMap(rhs);
@@ -6942,7 +6942,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
           Label if_rhsisnumber(this), if_rhsisnotnumber(this);
           Branch(IsHeapNumberMap(rhs_map), &if_rhsisnumber, &if_rhsisnotnumber);
 
-          Bind(&if_rhsisnumber);
+          BIND(&if_rhsisnumber);
           {
             // Convert {lhs} and {rhs} to floating point values, and
             // perform a floating point comparison.
@@ -6951,7 +6951,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             Goto(&do_fcmp);
           }
 
-          Bind(&if_rhsisnotnumber);
+          BIND(&if_rhsisnotnumber);
           {
             // Load the instance type of the {rhs}.
             Node* rhs_instance_type = LoadMapInstanceType(rhs_map);
@@ -6962,7 +6962,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             Branch(IsStringInstanceType(rhs_instance_type), &if_rhsisstring,
                    &if_rhsisnotstring);
 
-            Bind(&if_rhsisstring);
+            BIND(&if_rhsisstring);
             {
               // The {rhs} is a String and the {lhs} is a Smi; we need
               // to convert the {rhs} to a Number and compare the output to
@@ -6970,21 +6970,21 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
               Goto(&do_rhsstringtonumber);
             }
 
-            Bind(&if_rhsisnotstring);
+            BIND(&if_rhsisnotstring);
             {
               // Check if the {rhs} is a Boolean.
               Label if_rhsisboolean(this), if_rhsisnotboolean(this);
               Branch(IsBooleanMap(rhs_map), &if_rhsisboolean,
                      &if_rhsisnotboolean);
 
-              Bind(&if_rhsisboolean);
+              BIND(&if_rhsisboolean);
               {
                 // The {rhs} is a Boolean, load its number value.
                 var_rhs.Bind(LoadObjectField(rhs, Oddball::kToNumberOffset));
                 Goto(&loop);
               }
 
-              Bind(&if_rhsisnotboolean);
+              BIND(&if_rhsisnotboolean);
               {
                 // Check if the {rhs} is a Receiver.
                 STATIC_ASSERT(LAST_JS_RECEIVER_TYPE == LAST_TYPE);
@@ -6993,7 +6993,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                 Branch(IsJSReceiverInstanceType(rhs_instance_type),
                        &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-                Bind(&if_rhsisreceiver);
+                BIND(&if_rhsisreceiver);
                 {
                   // Convert {rhs} to a primitive first (passing no hint).
                   Callable callable =
@@ -7002,7 +7002,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                   Goto(&loop);
                 }
 
-                Bind(&if_rhsisnotreceiver);
+                BIND(&if_rhsisnotreceiver);
                 Goto(&if_notequal);
               }
             }
@@ -7010,13 +7010,13 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
         }
       }
 
-      Bind(&if_lhsisnotsmi);
+      BIND(&if_lhsisnotsmi);
       {
         // Check if {rhs} is a Smi or a HeapObject.
         Label if_rhsissmi(this), if_rhsisnotsmi(this);
         Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-        Bind(&if_rhsissmi);
+        BIND(&if_rhsissmi);
         {
           // The {lhs} is a HeapObject and the {rhs} is a Smi; swapping {lhs}
           // and {rhs} is not observable and doesn't matter for the result, so
@@ -7027,7 +7027,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
           Goto(&loop);
         }
 
-        Bind(&if_rhsisnotsmi);
+        BIND(&if_rhsisnotsmi);
         {
           Label if_lhsisstring(this), if_lhsisnumber(this),
               if_lhsissymbol(this), if_lhsisoddball(this),
@@ -7064,7 +7064,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             delete case_labels[i];
           }
 
-          Bind(&if_lhsisstring);
+          BIND(&if_lhsisstring);
           {
             // Check if {rhs} is also a String.
             Label if_rhsisstring(this, Label::kDeferred),
@@ -7072,7 +7072,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             Branch(IsStringInstanceType(rhs_instance_type), &if_rhsisstring,
                    &if_rhsisnotstring);
 
-            Bind(&if_rhsisstring);
+            BIND(&if_rhsisstring);
             {
               // Both {lhs} and {rhs} are of type String, just do the
               // string comparison then.
@@ -7081,7 +7081,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
               Goto(&end);
             }
 
-            Bind(&if_rhsisnotstring);
+            BIND(&if_rhsisnotstring);
             {
               // The {lhs} is a String and the {rhs} is some other HeapObject.
               // Swapping {lhs} and {rhs} is not observable and doesn't matter
@@ -7093,14 +7093,14 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             }
           }
 
-          Bind(&if_lhsisnumber);
+          BIND(&if_lhsisnumber);
           {
             // Check if {rhs} is also a HeapNumber.
             Label if_rhsisnumber(this), if_rhsisnotnumber(this);
             Branch(Word32Equal(lhs_instance_type, rhs_instance_type),
                    &if_rhsisnumber, &if_rhsisnotnumber);
 
-            Bind(&if_rhsisnumber);
+            BIND(&if_rhsisnumber);
             {
               // Convert {lhs} and {rhs} to floating point values, and
               // perform a floating point comparison.
@@ -7109,7 +7109,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
               Goto(&do_fcmp);
             }
 
-            Bind(&if_rhsisnotnumber);
+            BIND(&if_rhsisnotnumber);
             {
               // The {lhs} is a Number, the {rhs} is some other HeapObject.
               Label if_rhsisstring(this, Label::kDeferred),
@@ -7117,7 +7117,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
               Branch(IsStringInstanceType(rhs_instance_type), &if_rhsisstring,
                      &if_rhsisnotstring);
 
-              Bind(&if_rhsisstring);
+              BIND(&if_rhsisstring);
               {
                 // The {rhs} is a String and the {lhs} is a HeapNumber; we need
                 // to convert the {rhs} to a Number and compare the output to
@@ -7125,7 +7125,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                 Goto(&do_rhsstringtonumber);
               }
 
-              Bind(&if_rhsisnotstring);
+              BIND(&if_rhsisnotstring);
               {
                 // Check if the {rhs} is a JSReceiver.
                 Label if_rhsisreceiver(this), if_rhsisnotreceiver(this);
@@ -7133,7 +7133,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                 Branch(IsJSReceiverInstanceType(rhs_instance_type),
                        &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-                Bind(&if_rhsisreceiver);
+                BIND(&if_rhsisreceiver);
                 {
                   // The {lhs} is a Primitive and the {rhs} is a JSReceiver.
                   // Swapping {lhs} and {rhs} is not observable and doesn't
@@ -7145,14 +7145,14 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                   Goto(&loop);
                 }
 
-                Bind(&if_rhsisnotreceiver);
+                BIND(&if_rhsisnotreceiver);
                 {
                   // Check if {rhs} is a Boolean.
                   Label if_rhsisboolean(this), if_rhsisnotboolean(this);
                   Branch(IsBooleanMap(rhs_map), &if_rhsisboolean,
                          &if_rhsisnotboolean);
 
-                  Bind(&if_rhsisboolean);
+                  BIND(&if_rhsisboolean);
                   {
                     // The {rhs} is a Boolean, convert it to a Smi first.
                     var_rhs.Bind(
@@ -7160,14 +7160,14 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                     Goto(&loop);
                   }
 
-                  Bind(&if_rhsisnotboolean);
+                  BIND(&if_rhsisnotboolean);
                   Goto(&if_notequal);
                 }
               }
             }
           }
 
-          Bind(&if_lhsisoddball);
+          BIND(&if_lhsisoddball);
           {
             // The {lhs} is an Oddball and {rhs} is some other HeapObject.
             Label if_lhsisboolean(this), if_lhsisnotboolean(this);
@@ -7175,20 +7175,20 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             Branch(WordEqual(lhs_map, boolean_map), &if_lhsisboolean,
                    &if_lhsisnotboolean);
 
-            Bind(&if_lhsisboolean);
+            BIND(&if_lhsisboolean);
             {
               // The {lhs} is a Boolean, check if {rhs} is also a Boolean.
               Label if_rhsisboolean(this), if_rhsisnotboolean(this);
               Branch(WordEqual(rhs_map, boolean_map), &if_rhsisboolean,
                      &if_rhsisnotboolean);
 
-              Bind(&if_rhsisboolean);
+              BIND(&if_rhsisboolean);
               {
                 // Both {lhs} and {rhs} are distinct Boolean values.
                 Goto(&if_notequal);
               }
 
-              Bind(&if_rhsisnotboolean);
+              BIND(&if_rhsisnotboolean);
               {
                 // Convert the {lhs} to a Number first.
                 var_lhs.Bind(LoadObjectField(lhs, Oddball::kToNumberOffset));
@@ -7196,7 +7196,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
               }
             }
 
-            Bind(&if_lhsisnotboolean);
+            BIND(&if_lhsisnotboolean);
             {
               // The {lhs} is either Null or Undefined; check if the {rhs} is
               // undetectable (i.e. either also Null or Undefined or some
@@ -7210,7 +7210,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             }
           }
 
-          Bind(&if_lhsissymbol);
+          BIND(&if_lhsissymbol);
           {
             // Check if the {rhs} is a JSReceiver.
             Label if_rhsisreceiver(this), if_rhsisnotreceiver(this);
@@ -7218,7 +7218,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             Branch(IsJSReceiverInstanceType(rhs_instance_type),
                    &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-            Bind(&if_rhsisreceiver);
+            BIND(&if_rhsisreceiver);
             {
               // The {lhs} is a Primitive and the {rhs} is a JSReceiver.
               // Swapping {lhs} and {rhs} is not observable and doesn't
@@ -7229,7 +7229,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
               Goto(&loop);
             }
 
-            Bind(&if_rhsisnotreceiver);
+            BIND(&if_rhsisnotreceiver);
             {
               // The {rhs} is not a JSReceiver and also not the same Symbol
               // as the {lhs}, so this is equality check is considered false.
@@ -7237,7 +7237,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             }
           }
 
-          Bind(&if_lhsisreceiver);
+          BIND(&if_lhsisreceiver);
           {
             // Check if the {rhs} is also a JSReceiver.
             Label if_rhsisreceiver(this), if_rhsisnotreceiver(this);
@@ -7245,14 +7245,14 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
             Branch(IsJSReceiverInstanceType(rhs_instance_type),
                    &if_rhsisreceiver, &if_rhsisnotreceiver);
 
-            Bind(&if_rhsisreceiver);
+            BIND(&if_rhsisreceiver);
             {
               // Both {lhs} and {rhs} are different JSReceiver references, so
               // this cannot be considered equal.
               Goto(&if_notequal);
             }
 
-            Bind(&if_rhsisnotreceiver);
+            BIND(&if_rhsisnotreceiver);
             {
               // Check if {rhs} is Null or Undefined (an undetectable check
               // is sufficient here, since we already know that {rhs} is not
@@ -7266,7 +7266,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                          Int32Constant(0)),
                      &if_rhsisnotundetectable, &if_rhsisundetectable);
 
-              Bind(&if_rhsisundetectable);
+              BIND(&if_rhsisundetectable);
               {
                 // Check if {lhs} is an undetectable JSReceiver.
                 Node* lhs_bitfield = LoadMapBitField(lhs_map);
@@ -7277,7 +7277,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
                        &if_notequal, &if_equal);
               }
 
-              Bind(&if_rhsisnotundetectable);
+              BIND(&if_rhsisnotundetectable);
               {
                 // The {rhs} is some Primitive different from Null and
                 // Undefined, need to convert {lhs} to Primitive first.
@@ -7292,7 +7292,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
       }
     }
 
-    Bind(&do_rhsstringtonumber);
+    BIND(&do_rhsstringtonumber);
     {
       Callable callable = CodeFactory::StringToNumber(isolate());
       var_rhs.Bind(CallStub(callable, context, rhs));
@@ -7300,7 +7300,7 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
     }
   }
 
-  Bind(&do_fcmp);
+  BIND(&do_fcmp);
   {
     // Load the {lhs} and {rhs} floating point values.
     Node* lhs = var_fcmp_lhs.value();
@@ -7310,19 +7310,19 @@ Node* CodeStubAssembler::Equal(Node* lhs, Node* rhs, Node* context) {
     Branch(Float64Equal(lhs, rhs), &if_equal, &if_notequal);
   }
 
-  Bind(&if_equal);
+  BIND(&if_equal);
   {
     result.Bind(TrueConstant());
     Goto(&end);
   }
 
-  Bind(&if_notequal);
+  BIND(&if_notequal);
   {
     result.Bind(FalseConstant());
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return result.value();
 }
 
@@ -7378,14 +7378,14 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
   Label if_same(this), if_notsame(this);
   Branch(WordEqual(lhs, rhs), &if_same, &if_notsame);
 
-  Bind(&if_same);
+  BIND(&if_same);
   {
     // The {lhs} and {rhs} reference the exact same value, yet we need special
     // treatment for HeapNumber, as NaN is not equal to NaN.
     GenerateEqual_Same(this, lhs, &if_equal, &if_notequal);
   }
 
-  Bind(&if_notsame);
+  BIND(&if_notsame);
   {
     // The {lhs} and {rhs} reference different objects, yet for Smi, HeapNumber
     // and String they can still be considered equal.
@@ -7394,7 +7394,7 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
     Label if_lhsissmi(this), if_lhsisnotsmi(this);
     Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-    Bind(&if_lhsisnotsmi);
+    BIND(&if_lhsisnotsmi);
     {
       // Load the map of {lhs}.
       Node* lhs_map = LoadMap(lhs);
@@ -7403,13 +7403,13 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
       Label if_lhsisnumber(this), if_lhsisnotnumber(this);
       Branch(IsHeapNumberMap(lhs_map), &if_lhsisnumber, &if_lhsisnotnumber);
 
-      Bind(&if_lhsisnumber);
+      BIND(&if_lhsisnumber);
       {
         // Check if {rhs} is a Smi or a HeapObject.
         Label if_rhsissmi(this), if_rhsisnotsmi(this);
         Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-        Bind(&if_rhsissmi);
+        BIND(&if_rhsissmi);
         {
           // Convert {lhs} and {rhs} to floating point values.
           Node* lhs_value = LoadHeapNumberValue(lhs);
@@ -7419,7 +7419,7 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
           Branch(Float64Equal(lhs_value, rhs_value), &if_equal, &if_notequal);
         }
 
-        Bind(&if_rhsisnotsmi);
+        BIND(&if_rhsisnotsmi);
         {
           // Load the map of {rhs}.
           Node* rhs_map = LoadMap(rhs);
@@ -7428,7 +7428,7 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
           Label if_rhsisnumber(this), if_rhsisnotnumber(this);
           Branch(IsHeapNumberMap(rhs_map), &if_rhsisnumber, &if_rhsisnotnumber);
 
-          Bind(&if_rhsisnumber);
+          BIND(&if_rhsisnumber);
           {
             // Convert {lhs} and {rhs} to floating point values.
             Node* lhs_value = LoadHeapNumberValue(lhs);
@@ -7438,21 +7438,21 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
             Branch(Float64Equal(lhs_value, rhs_value), &if_equal, &if_notequal);
           }
 
-          Bind(&if_rhsisnotnumber);
+          BIND(&if_rhsisnotnumber);
           Goto(&if_notequal);
         }
       }
 
-      Bind(&if_lhsisnotnumber);
+      BIND(&if_lhsisnotnumber);
       {
         // Check if {rhs} is a Smi or a HeapObject.
         Label if_rhsissmi(this), if_rhsisnotsmi(this);
         Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-        Bind(&if_rhsissmi);
+        BIND(&if_rhsissmi);
         Goto(&if_notequal);
 
-        Bind(&if_rhsisnotsmi);
+        BIND(&if_rhsisnotsmi);
         {
           // Load the instance type of {lhs}.
           Node* lhs_instance_type = LoadMapInstanceType(lhs_map);
@@ -7462,7 +7462,7 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
           Branch(IsStringInstanceType(lhs_instance_type), &if_lhsisstring,
                  &if_lhsisnotstring);
 
-          Bind(&if_lhsisstring);
+          BIND(&if_lhsisstring);
           {
             // Load the instance type of {rhs}.
             Node* rhs_instance_type = LoadInstanceType(rhs);
@@ -7473,24 +7473,24 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
             Branch(IsStringInstanceType(rhs_instance_type), &if_rhsisstring,
                    &if_rhsisnotstring);
 
-            Bind(&if_rhsisstring);
+            BIND(&if_rhsisstring);
             {
               Callable callable = CodeFactory::StringEqual(isolate());
               result.Bind(CallStub(callable, NoContextConstant(), lhs, rhs));
               Goto(&end);
             }
 
-            Bind(&if_rhsisnotstring);
+            BIND(&if_rhsisnotstring);
             Goto(&if_notequal);
           }
 
-          Bind(&if_lhsisnotstring);
+          BIND(&if_lhsisnotstring);
           Goto(&if_notequal);
         }
       }
     }
 
-    Bind(&if_lhsissmi);
+    BIND(&if_lhsissmi);
     {
       // We already know that {lhs} and {rhs} are not reference equal, and {lhs}
       // is a Smi; so {lhs} and {rhs} can only be strictly equal if {rhs} is a
@@ -7500,10 +7500,10 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
       Label if_rhsissmi(this), if_rhsisnotsmi(this);
       Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-      Bind(&if_rhsissmi);
+      BIND(&if_rhsissmi);
       Goto(&if_notequal);
 
-      Bind(&if_rhsisnotsmi);
+      BIND(&if_rhsisnotsmi);
       {
         // Load the map of the {rhs}.
         Node* rhs_map = LoadMap(rhs);
@@ -7512,7 +7512,7 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
         Label if_rhsisnumber(this), if_rhsisnotnumber(this);
         Branch(IsHeapNumberMap(rhs_map), &if_rhsisnumber, &if_rhsisnotnumber);
 
-        Bind(&if_rhsisnumber);
+        BIND(&if_rhsisnumber);
         {
           // Convert {lhs} and {rhs} to floating point values.
           Node* lhs_value = SmiToFloat64(lhs);
@@ -7522,25 +7522,25 @@ Node* CodeStubAssembler::StrictEqual(Node* lhs, Node* rhs) {
           Branch(Float64Equal(lhs_value, rhs_value), &if_equal, &if_notequal);
         }
 
-        Bind(&if_rhsisnotnumber);
+        BIND(&if_rhsisnotnumber);
         Goto(&if_notequal);
       }
     }
   }
 
-  Bind(&if_equal);
+  BIND(&if_equal);
   {
     result.Bind(TrueConstant());
     Goto(&end);
   }
 
-  Bind(&if_notequal);
+  BIND(&if_notequal);
   {
     result.Bind(FalseConstant());
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return result.value();
 }
 
@@ -7557,7 +7557,7 @@ Node* CodeStubAssembler::SameValue(Node* lhs, Node* rhs) {
   Label if_equal(this), if_notequal(this);
   Branch(WordEqual(lhs, rhs), &if_equal, &if_notequal);
 
-  Bind(&if_equal);
+  BIND(&if_equal);
   {
     // This covers the case when {lhs} == {rhs}. We can simply return true
     // because SameValue considers two NaNs to be equal.
@@ -7566,7 +7566,7 @@ Node* CodeStubAssembler::SameValue(Node* lhs, Node* rhs) {
     Goto(&out);
   }
 
-  Bind(&if_notequal);
+  BIND(&if_notequal);
   {
     // This covers the case when {lhs} != {rhs}. We only handle numbers here
     // and defer to StrictEqual for the rest.
@@ -7577,7 +7577,7 @@ Node* CodeStubAssembler::SameValue(Node* lhs, Node* rhs) {
     Label if_lhsisnan(this), if_lhsnotnan(this);
     BranchIfFloat64IsNaN(lhs_float, &if_lhsisnan, &if_lhsnotnan);
 
-    Bind(&if_lhsisnan);
+    BIND(&if_lhsisnan);
     {
       // Return true iff {rhs} is NaN.
 
@@ -7588,13 +7588,13 @@ Node* CodeStubAssembler::SameValue(Node* lhs, Node* rhs) {
       Goto(&out);
     }
 
-    Bind(&if_lhsnotnan);
+    BIND(&if_lhsnotnan);
     {
       Label if_floatisequal(this), if_floatnotequal(this);
       Branch(Float64Equal(lhs_float, rhs_float), &if_floatisequal,
              &if_floatnotequal);
 
-      Bind(&if_floatisequal);
+      BIND(&if_floatisequal);
       {
         // We still need to handle the case when {lhs} and {rhs} are -0.0 and
         // 0.0 (or vice versa). Compare the high word to
@@ -7611,7 +7611,7 @@ Node* CodeStubAssembler::SameValue(Node* lhs, Node* rhs) {
         Goto(&out);
       }
 
-      Bind(&if_floatnotequal);
+      BIND(&if_floatnotequal);
       {
         var_result.Bind(int_false);
         Goto(&out);
@@ -7619,7 +7619,7 @@ Node* CodeStubAssembler::SameValue(Node* lhs, Node* rhs) {
     }
   }
 
-  Bind(&strict_equal);
+  BIND(&strict_equal);
   {
     Node* const is_equal = StrictEqual(lhs, rhs);
     Node* const result = WordEqual(is_equal, TrueConstant());
@@ -7627,7 +7627,7 @@ Node* CodeStubAssembler::SameValue(Node* lhs, Node* rhs) {
     Goto(&out);
   }
 
-  Bind(&out);
+  BIND(&out);
   return var_result.value();
 }
 
@@ -7659,26 +7659,26 @@ Node* CodeStubAssembler::HasProperty(
                           &call_runtime);
 
   Variable result(this, MachineRepresentation::kTagged);
-  Bind(&return_true);
+  BIND(&return_true);
   {
     result.Bind(BooleanConstant(true));
     Goto(&end);
   }
 
-  Bind(&return_false);
+  BIND(&return_false);
   {
     result.Bind(BooleanConstant(false));
     Goto(&end);
   }
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     result.Bind(
         CallRuntime(fallback_runtime_function_id, context, object, key));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return result.value();
 }
 
@@ -7722,30 +7722,30 @@ Node* CodeStubAssembler::ClassOf(Node* value) {
   Goto(&return_result);
 
   // For remote objects the constructor might be given as FTI.
-  Bind(&if_function_template_info);
+  BIND(&if_function_template_info);
   Node* class_name =
       LoadObjectField(constructor, FunctionTemplateInfo::kClassNameOffset);
   GotoIf(IsUndefined(class_name), &if_no_class_name);
   var_result.Bind(class_name);
   Goto(&return_result);
 
-  Bind(&if_no_class_name);
+  BIND(&if_no_class_name);
   var_result.Bind(LoadRoot(Heap::kempty_stringRootIndex));
   Goto(&return_result);
 
-  Bind(&if_function);
+  BIND(&if_function);
   var_result.Bind(LoadRoot(Heap::kFunction_stringRootIndex));
   Goto(&return_result);
 
-  Bind(&if_object);
+  BIND(&if_object);
   var_result.Bind(LoadRoot(Heap::kObject_stringRootIndex));
   Goto(&return_result);
 
-  Bind(&if_primitive);
+  BIND(&if_primitive);
   var_result.Bind(NullConstant());
   Goto(&return_result);
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
@@ -7785,44 +7785,44 @@ Node* CodeStubAssembler::Typeof(Node* value) {
   result_var.Bind(HeapConstant(isolate()->factory()->symbol_string()));
   Goto(&return_result);
 
-  Bind(&return_number);
+  BIND(&return_number);
   {
     result_var.Bind(HeapConstant(isolate()->factory()->number_string()));
     Goto(&return_result);
   }
 
-  Bind(&if_oddball);
+  BIND(&if_oddball);
   {
     Node* type = LoadObjectField(value, Oddball::kTypeOfOffset);
     result_var.Bind(type);
     Goto(&return_result);
   }
 
-  Bind(&return_function);
+  BIND(&return_function);
   {
     result_var.Bind(HeapConstant(isolate()->factory()->function_string()));
     Goto(&return_result);
   }
 
-  Bind(&return_undefined);
+  BIND(&return_undefined);
   {
     result_var.Bind(HeapConstant(isolate()->factory()->undefined_string()));
     Goto(&return_result);
   }
 
-  Bind(&return_object);
+  BIND(&return_object);
   {
     result_var.Bind(HeapConstant(isolate()->factory()->object_string()));
     Goto(&return_result);
   }
 
-  Bind(&return_string);
+  BIND(&return_string);
   {
     result_var.Bind(HeapConstant(isolate()->factory()->string_string()));
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   return result_var.value();
 }
 
@@ -7841,14 +7841,14 @@ Node* CodeStubAssembler::GetSuperConstructor(Node* active_function,
   result.Bind(prototype);
   Goto(&out);
 
-  Bind(&is_not_constructor);
+  BIND(&is_not_constructor);
   {
     CallRuntime(Runtime::kThrowNotSuperConstructor, context, prototype,
                 active_function);
     Unreachable();
   }
 
-  Bind(&out);
+  BIND(&out);
   return result.value();
 }
 
@@ -7885,7 +7885,7 @@ Node* CodeStubAssembler::InstanceOf(Node* object, Node* callable,
     Goto(&return_result);
   }
 
-  Bind(&if_otherhandler);
+  BIND(&if_otherhandler);
   {
     // Check if there's actually an {inst_of_handler}.
     GotoIf(IsNull(inst_of_handler), &if_nohandler);
@@ -7900,7 +7900,7 @@ Node* CodeStubAssembler::InstanceOf(Node* object, Node* callable,
     BranchIfToBooleanIsTrue(result, &return_true, &return_false);
   }
 
-  Bind(&if_nohandler);
+  BIND(&if_nohandler);
   {
     // Ensure that the {callable} is actually Callable.
     GotoIfNot(IsCallable(callable), &if_notcallable);
@@ -7912,27 +7912,27 @@ Node* CodeStubAssembler::InstanceOf(Node* object, Node* callable,
     Goto(&return_result);
   }
 
-  Bind(&if_notcallable);
+  BIND(&if_notcallable);
   {
     CallRuntime(Runtime::kThrowNonCallableInInstanceOfCheck, context);
     Unreachable();
   }
 
-  Bind(&if_notreceiver);
+  BIND(&if_notreceiver);
   {
     CallRuntime(Runtime::kThrowNonObjectInInstanceOfCheck, context);
     Unreachable();
   }
 
-  Bind(&return_true);
+  BIND(&return_true);
   var_result.Bind(TrueConstant());
   Goto(&return_result);
 
-  Bind(&return_false);
+  BIND(&return_false);
   var_result.Bind(FalseConstant());
   Goto(&return_result);
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
@@ -7942,7 +7942,7 @@ Node* CodeStubAssembler::NumberInc(Node* value) {
   Label if_issmi(this), if_isnotsmi(this), do_finc(this), end(this);
   Branch(TaggedIsSmi(value), &if_issmi, &if_isnotsmi);
 
-  Bind(&if_issmi);
+  BIND(&if_issmi);
   {
     // Try fast Smi addition first.
     Node* one = SmiConstant(Smi::FromInt(1));
@@ -7954,18 +7954,18 @@ Node* CodeStubAssembler::NumberInc(Node* value) {
     Label if_overflow(this), if_notoverflow(this);
     Branch(overflow, &if_overflow, &if_notoverflow);
 
-    Bind(&if_notoverflow);
+    BIND(&if_notoverflow);
     var_result.Bind(BitcastWordToTaggedSigned(Projection(0, pair)));
     Goto(&end);
 
-    Bind(&if_overflow);
+    BIND(&if_overflow);
     {
       var_finc_value.Bind(SmiToFloat64(value));
       Goto(&do_finc);
     }
   }
 
-  Bind(&if_isnotsmi);
+  BIND(&if_isnotsmi);
   {
     // Check if the value is a HeapNumber.
     CSA_ASSERT(this, IsHeapNumberMap(LoadMap(value)));
@@ -7975,7 +7975,7 @@ Node* CodeStubAssembler::NumberInc(Node* value) {
     Goto(&do_finc);
   }
 
-  Bind(&do_finc);
+  BIND(&do_finc);
   {
     Node* finc_value = var_finc_value.value();
     Node* one = Float64Constant(1.0);
@@ -7984,7 +7984,7 @@ Node* CodeStubAssembler::NumberInc(Node* value) {
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -7994,7 +7994,7 @@ Node* CodeStubAssembler::NumberDec(Node* value) {
   Label if_issmi(this), if_isnotsmi(this), do_fdec(this), end(this);
   Branch(TaggedIsSmi(value), &if_issmi, &if_isnotsmi);
 
-  Bind(&if_issmi);
+  BIND(&if_issmi);
   {
     // Try fast Smi addition first.
     Node* one = SmiConstant(Smi::FromInt(1));
@@ -8006,18 +8006,18 @@ Node* CodeStubAssembler::NumberDec(Node* value) {
     Label if_overflow(this), if_notoverflow(this);
     Branch(overflow, &if_overflow, &if_notoverflow);
 
-    Bind(&if_notoverflow);
+    BIND(&if_notoverflow);
     var_result.Bind(BitcastWordToTaggedSigned(Projection(0, pair)));
     Goto(&end);
 
-    Bind(&if_overflow);
+    BIND(&if_overflow);
     {
       var_fdec_value.Bind(SmiToFloat64(value));
       Goto(&do_fdec);
     }
   }
 
-  Bind(&if_isnotsmi);
+  BIND(&if_isnotsmi);
   {
     // Check if the value is a HeapNumber.
     CSA_ASSERT(this, IsHeapNumberMap(LoadMap(value)));
@@ -8027,7 +8027,7 @@ Node* CodeStubAssembler::NumberDec(Node* value) {
     Goto(&do_fdec);
   }
 
-  Bind(&do_fdec);
+  BIND(&do_fdec);
   {
     Node* fdec_value = var_fdec_value.value();
     Node* minus_one = Float64Constant(-1.0);
@@ -8036,7 +8036,7 @@ Node* CodeStubAssembler::NumberDec(Node* value) {
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   return var_result.value();
 }
 
@@ -8045,7 +8045,7 @@ void CodeStubAssembler::GotoIfNotNumber(Node* input, Label* is_not_number) {
   GotoIf(TaggedIsSmi(input), &is_number);
   Node* input_map = LoadMap(input);
   Branch(IsHeapNumberMap(input_map), &is_number, is_not_number);
-  Bind(&is_number);
+  BIND(&is_number);
 }
 
 void CodeStubAssembler::GotoIfNumber(Node* input, Label* is_number) {
@@ -8107,13 +8107,13 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
     Branch(Word32Equal(array_type, Int32Constant(JS_TYPED_ARRAY_TYPE)),
            &if_istypedarray, &if_isgeneric);
 
-    Bind(&if_isgeneric);
+    BIND(&if_isgeneric);
     {
       Label if_isfast(this), if_isslow(this);
       BranchIfFastJSArray(array, context, FastJSArrayAccessMode::INBOUNDS_READ,
                           &if_isfast, &if_isslow);
 
-      Bind(&if_isfast);
+      BIND(&if_isfast);
       {
         var_map_index.Bind(
             IntPtrConstant(Context::FAST_ARRAY_KEY_ITERATOR_MAP_INDEX));
@@ -8121,7 +8121,7 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
         Goto(&allocate_iterator);
       }
 
-      Bind(&if_isslow);
+      BIND(&if_isslow);
       {
         var_map_index.Bind(
             IntPtrConstant(Context::GENERIC_ARRAY_KEY_ITERATOR_MAP_INDEX));
@@ -8130,7 +8130,7 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
       }
     }
 
-    Bind(&if_istypedarray);
+    BIND(&if_istypedarray);
     {
       var_map_index.Bind(
           IntPtrConstant(Context::TYPED_ARRAY_KEY_ITERATOR_MAP_INDEX));
@@ -8142,20 +8142,20 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
     Branch(Word32Equal(array_type, Int32Constant(JS_TYPED_ARRAY_TYPE)),
            &if_istypedarray, &if_isgeneric);
 
-    Bind(&if_isgeneric);
+    BIND(&if_isgeneric);
     {
       Label if_isfast(this), if_isslow(this);
       BranchIfFastJSArray(array, context, FastJSArrayAccessMode::INBOUNDS_READ,
                           &if_isfast, &if_isslow);
 
-      Bind(&if_isfast);
+      BIND(&if_isfast);
       {
         Label if_ispacked(this), if_isholey(this);
         Node* elements_kind = LoadMapElementsKind(array_map);
         Branch(IsHoleyFastElementsKind(elements_kind), &if_isholey,
                &if_ispacked);
 
-        Bind(&if_isholey);
+        BIND(&if_isholey);
         {
           // Fast holey JSArrays can treat the hole as undefined if the
           // protector cell is valid, and the prototype chain is unchanged from
@@ -8187,7 +8187,7 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
           prototype = LoadMapPrototype(map);
           Branch(IsNull(prototype), &if_ispacked, &if_isslow);
         }
-        Bind(&if_ispacked);
+        BIND(&if_ispacked);
         {
           Node* map_index =
               IntPtrAdd(IntPtrConstant(kBaseMapIndex + kFastIteratorOffset),
@@ -8205,7 +8205,7 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
         }
       }
 
-      Bind(&if_isslow);
+      BIND(&if_isslow);
       {
         Node* map_index = IntPtrAdd(IntPtrConstant(kBaseMapIndex),
                                     IntPtrConstant(kSlowIteratorOffset));
@@ -8215,7 +8215,7 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
       }
     }
 
-    Bind(&if_istypedarray);
+    BIND(&if_istypedarray);
     {
       Node* map_index =
           IntPtrAdd(IntPtrConstant(kBaseMapIndex - UINT8_ELEMENTS),
@@ -8231,7 +8231,7 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
     }
   }
 
-  Bind(&allocate_iterator);
+  BIND(&allocate_iterator);
   {
     Node* map = LoadFixedArrayElement(LoadNativeContext(context),
                                       var_map_index.value());
@@ -8239,7 +8239,7 @@ Node* CodeStubAssembler::CreateArrayIterator(Node* array, Node* array_map,
     Goto(&return_result);
   }
 
-  Bind(&return_result);
+  BIND(&return_result);
   return var_result.value();
 }
 
diff --git a/src/code-stubs.cc b/src/code-stubs.cc
index 2f8891ffec6..4563e656ead 100644
--- a/src/code-stubs.cc
+++ b/src/code-stubs.cc
@@ -469,7 +469,7 @@ TF_STUB(ElementsTransitionAndStoreStub, CodeStubAssembler) {
     Return(value);
   }
 
-  Bind(&miss);
+  BIND(&miss);
   {
     Comment("Miss");
     TailCallRuntime(Runtime::kElementsTransitionAndStoreIC_Miss, context,
@@ -521,7 +521,7 @@ TF_STUB(KeyedLoadSloppyArgumentsStub, CodeStubAssembler) {
   Node* result = LoadKeyedSloppyArguments(receiver, key, &miss);
   Return(result);
 
-  Bind(&miss);
+  BIND(&miss);
   {
     Comment("Miss");
     TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
@@ -543,7 +543,7 @@ TF_STUB(KeyedStoreSloppyArgumentsStub, CodeStubAssembler) {
   StoreKeyedSloppyArguments(receiver, key, value, &miss);
   Return(value);
 
-  Bind(&miss);
+  BIND(&miss);
   {
     Comment("Miss");
     TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context, value, slot, vector,
@@ -597,10 +597,10 @@ TF_STUB(LoadIndexedInterceptorStub, CodeStubAssembler) {
 
   Label if_keyispositivesmi(this), if_keyisinvalid(this);
   Branch(TaggedIsPositiveSmi(key), &if_keyispositivesmi, &if_keyisinvalid);
-  Bind(&if_keyispositivesmi);
+  BIND(&if_keyispositivesmi);
   TailCallRuntime(Runtime::kLoadElementWithInterceptor, context, receiver, key);
 
-  Bind(&if_keyisinvalid);
+  BIND(&if_keyisinvalid);
   TailCallRuntime(Runtime::kKeyedLoadIC_Miss, context, receiver, key, slot,
                   vector);
 }
@@ -658,7 +658,7 @@ TF_STUB(CallICStub, CodeStubAssembler) {
   Node* is_smi = TaggedIsSmi(target);
   Branch(is_smi, &extra_checks, &call_function);
 
-  Bind(&call_function);
+  BIND(&call_function);
   {
     // Call using CallFunction builtin.
     Callable callable = CodeFactory::CallFunction(
@@ -666,7 +666,7 @@ TF_STUB(CallICStub, CodeStubAssembler) {
     TailCallStub(callable, context, target, argc);
   }
 
-  Bind(&extra_checks);
+  BIND(&extra_checks);
   {
     Label check_initialized(this), mark_megamorphic(this),
         create_allocation_site(this, Label::kDeferred),
@@ -693,7 +693,7 @@ TF_STUB(CallICStub, CodeStubAssembler) {
     Callable callable = CodeFactory::ArrayConstructor(isolate());
     TailCallStub(callable, context, target, target, argc, feedback_element);
 
-    Bind(&check_initialized);
+    BIND(&check_initialized);
     {
       Comment("check if uninitialized");
       // Check if it is uninitialized target first.
@@ -725,7 +725,7 @@ TF_STUB(CallICStub, CodeStubAssembler) {
       Branch(is_same_native_context, &create_weak_cell, &mark_megamorphic);
     }
 
-    Bind(&create_weak_cell);
+    BIND(&create_weak_cell);
     {
       // Wrap the {target} in a WeakCell and remember it.
       Comment("create weak cell");
@@ -735,7 +735,7 @@ TF_STUB(CallICStub, CodeStubAssembler) {
       Goto(&call_function);
     }
 
-    Bind(&create_allocation_site);
+    BIND(&create_allocation_site);
     {
       // Create an AllocationSite for the {target}.
       Comment("create allocation site");
@@ -747,7 +747,7 @@ TF_STUB(CallICStub, CodeStubAssembler) {
       Goto(&call_function);
     }
 
-    Bind(&mark_megamorphic);
+    BIND(&mark_megamorphic);
     {
       // Mark it as a megamorphic.
       // MegamorphicSentinel is created as a part of Heap::InitialObjects
@@ -761,7 +761,7 @@ TF_STUB(CallICStub, CodeStubAssembler) {
     }
   }
 
-  Bind(&call);
+  BIND(&call);
   {
     // Call using call builtin.
     Comment("call using Call builtin");
@@ -840,7 +840,7 @@ TF_STUB(GetPropertyStub, CodeStubAssembler) {
         TryGetOwnProperty(context, receiver, holder, holder_map,
                           holder_instance_type, unique_name, &if_found,
                           &var_value, next_holder, if_bailout);
-        Bind(&if_found);
+        BIND(&if_found);
         {
           var_result.Bind(var_value.value());
           Goto(&end);
@@ -860,19 +860,19 @@ TF_STUB(GetPropertyStub, CodeStubAssembler) {
                           lookup_element_in_holder, &return_undefined,
                           &call_runtime);
 
-  Bind(&return_undefined);
+  BIND(&return_undefined);
   {
     var_result.Bind(UndefinedConstant());
     Goto(&end);
   }
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     var_result.Bind(CallRuntime(Runtime::kGetProperty, context, object, key));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   Return(var_result.value());
 }
 
@@ -918,7 +918,7 @@ TF_STUB(StoreFastElementStub, CodeStubAssembler) {
                    stub->elements_kind(), stub->store_mode(), &miss);
   Return(value);
 
-  Bind(&miss);
+  BIND(&miss);
   {
     Comment("Miss");
     TailCallRuntime(Runtime::kKeyedStoreIC_Miss, context, value, slot, vector,
@@ -1065,14 +1065,14 @@ void ArrayConstructorAssembler::GenerateConstructor(
 
   Branch(TaggedIsSmi(array_size), &smi_size, &call_runtime);
 
-  Bind(&smi_size);
+  BIND(&smi_size);
 
   if (IsFastPackedElementsKind(elements_kind)) {
     Label abort(this, Label::kDeferred);
     Branch(SmiEqual(array_size, SmiConstant(Smi::kZero)), &small_smi_size,
            &abort);
 
-    Bind(&abort);
+    BIND(&abort);
     Node* reason = SmiConstant(Smi::FromInt(kAllocatingNonEmptyPackedArray));
     TailCallRuntime(Runtime::kAbort, context, reason);
   } else {
@@ -1087,7 +1087,7 @@ void ArrayConstructorAssembler::GenerateConstructor(
            &call_runtime, &small_smi_size);
   }
 
-  Bind(&small_smi_size);
+  BIND(&small_smi_size);
   {
     Node* array = AllocateJSArray(
         elements_kind, array_map, array_size, array_size,
@@ -1096,7 +1096,7 @@ void ArrayConstructorAssembler::GenerateConstructor(
     Return(array);
   }
 
-  Bind(&call_runtime);
+  BIND(&call_runtime);
   {
     TailCallRuntime(Runtime::kNewArray, context, array_function, array_size,
                     array_function, allocation_site);
@@ -1144,7 +1144,7 @@ TF_STUB(GrowArrayElementsStub, CodeStubAssembler) {
       TryGrowElementsCapacity(object, elements, kind, key, &runtime);
   Return(new_elements);
 
-  Bind(&runtime);
+  BIND(&runtime);
   // TODO(danno): Make this a tail call when the stub is only used from TurboFan
   // code. This musn't be a tail call for now, since the caller site in lithium
   // creates a safepoint. This safepoint musn't have a different number of
diff --git a/src/ic/accessor-assembler.cc b/src/ic/accessor-assembler.cc
index ee1388209f8..1707e33bc38 100644
--- a/src/ic/accessor-assembler.cc
+++ b/src/ic/accessor-assembler.cc
@@ -97,12 +97,12 @@ void AccessorAssembler::HandlePolymorphicCase(Node* receiver_map,
     var_handler->Bind(handler);
     Goto(if_handler);
 
-    Bind(&next_entry);
+    BIND(&next_entry);
   }
   Goto(&loop);
 
   // Loop from {kUnrolledIterations}*kEntrySize to {length}.
-  Bind(&loop);
+  BIND(&loop);
   Node* start_index = IntPtrConstant(kUnrolledIterations * kEntrySize);
   Node* end_index = LoadAndUntagFixedArrayBaseLength(feedback);
   BuildFastLoop(
@@ -119,7 +119,7 @@ void AccessorAssembler::HandlePolymorphicCase(Node* receiver_map,
         var_handler->Bind(handler);
         Goto(if_handler);
 
-        Bind(&next_entry);
+        BIND(&next_entry);
       },
       kEntrySize, INTPTR_PARAMETERS, IndexAdvanceMode::kPost);
   // The loop falls through if no handler was found.
@@ -143,20 +143,20 @@ void AccessorAssembler::HandleLoadICHandlerCase(
 
   // |handler| is a Smi, encoding what to do. See SmiHandler methods
   // for the encoding format.
-  Bind(&if_smi_handler);
+  BIND(&if_smi_handler);
   {
     HandleLoadICSmiHandlerCase(p, var_holder.value(), var_smi_handler.value(),
                                miss, exit_point, false, support_elements);
   }
 
-  Bind(&try_proto_handler);
+  BIND(&try_proto_handler);
   {
     GotoIf(IsCodeMap(LoadMap(handler)), &call_handler);
     HandleLoadICProtoHandlerCase(p, handler, &var_holder, &var_smi_handler,
                                  &if_smi_handler, miss, exit_point, false);
   }
 
-  Bind(&call_handler);
+  BIND(&call_handler);
   {
     typedef LoadWithVectorDescriptor Descriptor;
     exit_point->ReturnCallStub(Descriptor(isolate()), handler, p->context,
@@ -175,13 +175,13 @@ void AccessorAssembler::HandleLoadField(Node* holder, Node* handler_word,
   Branch(IsSetWord<LoadHandler::IsInobjectBits>(handler_word), &inobject,
          &out_of_object);
 
-  Bind(&inobject);
+  BIND(&inobject);
   {
     Label is_double(this);
     GotoIf(IsSetWord<LoadHandler::IsDoubleBits>(handler_word), &is_double);
     exit_point->Return(LoadObjectField(holder, offset));
 
-    Bind(&is_double);
+    BIND(&is_double);
     if (FLAG_unbox_double_fields) {
       var_double_value->Bind(
           LoadObjectField(holder, offset, MachineType::Float64()));
@@ -192,7 +192,7 @@ void AccessorAssembler::HandleLoadField(Node* holder, Node* handler_word,
     Goto(rebox_double);
   }
 
-  Bind(&out_of_object);
+  BIND(&out_of_object);
   {
     Label is_double(this);
     Node* properties = LoadProperties(holder);
@@ -200,7 +200,7 @@ void AccessorAssembler::HandleLoadField(Node* holder, Node* handler_word,
     GotoIf(IsSetWord<LoadHandler::IsDoubleBits>(handler_word), &is_double);
     exit_point->Return(value);
 
-    Bind(&is_double);
+    BIND(&is_double);
     var_double_value->Bind(LoadHeapNumberValue(value));
     Goto(rebox_double);
   }
@@ -234,7 +234,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
                     &var_double_value, &unimplemented_elements_kind,
                     out_of_bounds, miss, exit_point);
 
-    Bind(&unimplemented_elements_kind);
+    BIND(&unimplemented_elements_kind);
     {
       // Smi handlers should only be installed for supported elements kinds.
       // Crash if we get here.
@@ -242,7 +242,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
       Goto(miss);
     }
 
-    Bind(&if_hole);
+    BIND(&if_hole);
     {
       Comment("convert hole");
       GotoIfNot(IsSetWord<LoadHandler::ConvertHoleBits>(handler_word), miss);
@@ -255,7 +255,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
       exit_point->Return(UndefinedConstant());
     }
 
-    Bind(&property);
+    BIND(&property);
     Comment("property_load");
   }
 
@@ -279,11 +279,11 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
   Branch(WordEqual(handler_kind, IntPtrConstant(LoadHandler::kGlobal)), &global,
          &interceptor);
 
-  Bind(&field);
+  BIND(&field);
   HandleLoadField(holder, handler_word, &var_double_value, &rebox_double,
                   exit_point);
 
-  Bind(&nonexistent);
+  BIND(&nonexistent);
   // This is a handler for a load of a non-existent value.
   if (throw_reference_error_if_nonexistent) {
     exit_point->ReturnCallRuntime(Runtime::kThrowReferenceError, p->context,
@@ -292,7 +292,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
     exit_point->Return(UndefinedConstant());
   }
 
-  Bind(&constant);
+  BIND(&constant);
   {
     Comment("constant_load");
     Node* descriptors = LoadMapDescriptors(LoadMap(holder));
@@ -313,13 +313,13 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
            &if_accessor_info);
     exit_point->Return(value);
 
-    Bind(&if_accessor_info);
+    BIND(&if_accessor_info);
     Callable callable = CodeFactory::ApiGetter(isolate());
     exit_point->ReturnCallStub(callable, p->context, p->receiver, holder,
                                value);
   }
 
-  Bind(&normal);
+  BIND(&normal);
   {
     Comment("load_normal");
     Node* properties = LoadProperties(holder);
@@ -327,7 +327,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
     Label found(this, &var_name_index);
     NameDictionaryLookup<NameDictionary>(properties, p->name, &found,
                                          &var_name_index, miss);
-    Bind(&found);
+    BIND(&found);
     {
       Variable var_details(this, MachineRepresentation::kWord32);
       Variable var_value(this, MachineRepresentation::kTagged);
@@ -339,7 +339,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
     }
   }
 
-  Bind(&accessor);
+  BIND(&accessor);
   {
     Comment("accessor_load");
     Node* descriptors = LoadMapDescriptors(LoadMap(holder));
@@ -362,7 +362,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
     exit_point->Return(CallJS(callable, p->context, getter, p->receiver));
   }
 
-  Bind(&global);
+  BIND(&global);
   {
     CSA_ASSERT(this, IsPropertyCell(holder));
     // Ensure the property cell doesn't contain the hole.
@@ -375,7 +375,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
         CallGetterIfAccessor(value, details, p->context, p->receiver, miss));
   }
 
-  Bind(&interceptor);
+  BIND(&interceptor);
   {
     Comment("load_interceptor");
     exit_point->ReturnCallRuntime(Runtime::kLoadPropertyWithInterceptor,
@@ -383,7 +383,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerCase(
                                   p->slot, p->vector);
   }
 
-  Bind(&rebox_double);
+  BIND(&rebox_double);
   exit_point->Return(AllocateHeapNumberWithValue(var_double_value.value()));
 }
 
@@ -413,7 +413,7 @@ void AccessorAssembler::HandleLoadICProtoHandlerCase(
          miss);
   Goto(&validity_cell_check_done);
 
-  Bind(&validity_cell_check_done);
+  BIND(&validity_cell_check_done);
   Node* smi_handler = LoadObjectField(handler, LoadHandler::kSmiHandlerOffset);
   CSA_ASSERT(this, TaggedIsSmi(smi_handler));
   Node* handler_flags = SmiUntag(smi_handler);
@@ -429,7 +429,7 @@ void AccessorAssembler::HandleLoadICProtoHandlerCase(
     Label found(this, &var_name_index);
     NameDictionaryLookup<NameDictionary>(properties, p->name, &found,
                                          &var_name_index, &check_prototypes);
-    Bind(&found);
+    BIND(&found);
     {
       Variable var_details(this, MachineRepresentation::kWord32);
       Variable var_value(this, MachineRepresentation::kTagged);
@@ -441,20 +441,20 @@ void AccessorAssembler::HandleLoadICProtoHandlerCase(
     }
   }
 
-  Bind(&check_prototypes);
+  BIND(&check_prototypes);
   Node* maybe_holder_cell =
       LoadObjectField(handler, LoadHandler::kHolderCellOffset);
   Label array_handler(this), tuple_handler(this);
   Branch(TaggedIsSmi(maybe_holder_cell), &array_handler, &tuple_handler);
 
-  Bind(&tuple_handler);
+  BIND(&tuple_handler);
   {
     Label load_from_cached_holder(this), done(this);
 
     Branch(WordEqual(maybe_holder_cell, NullConstant()), &done,
            &load_from_cached_holder);
 
-    Bind(&load_from_cached_holder);
+    BIND(&load_from_cached_holder);
     {
       // For regular holders, having passed the receiver map check and the
       // validity cell check implies that |holder| is alive. However, for
@@ -465,12 +465,12 @@ void AccessorAssembler::HandleLoadICProtoHandlerCase(
       Goto(&done);
     }
 
-    Bind(&done);
+    BIND(&done);
     var_smi_handler->Bind(smi_handler);
     Goto(if_smi_handler);
   }
 
-  Bind(&array_handler);
+  BIND(&array_handler);
   {
     exit_point->ReturnCallStub(
         CodeFactory::LoadICProtoArray(isolate(),
@@ -512,7 +512,7 @@ Node* AccessorAssembler::EmitLoadICProtoArrayCheck(const LoadICParameters* p,
         LoadContextElement(native_context, Context::SECURITY_TOKEN_INDEX);
     Branch(WordEqual(expected_token, current_token), &can_access, miss);
   }
-  Bind(&can_access);
+  BIND(&can_access);
 
   BuildFastLoop(start_index.value(), handler_length,
                 [this, p, handler, miss](Node* current) {
@@ -537,7 +537,7 @@ Node* AccessorAssembler::EmitLoadICProtoArrayCheck(const LoadICParameters* p,
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
   return var_holder.value();
 }
 
@@ -558,7 +558,7 @@ void AccessorAssembler::HandleLoadGlobalICHandlerCase(
   HandleLoadICProtoHandlerCase(&p, handler, &var_holder, &var_smi_handler,
                                &if_smi_handler, miss, exit_point,
                                throw_reference_error_if_nonexistent);
-  Bind(&if_smi_handler);
+  BIND(&if_smi_handler);
   HandleLoadICSmiHandlerCase(
       &p, var_holder.value(), var_smi_handler.value(), miss, exit_point,
       throw_reference_error_if_nonexistent, kOnlyProperties);
@@ -585,7 +585,7 @@ void AccessorAssembler::HandleStoreICHandlerCase(
 
   // |handler| is a Smi, encoding what to do. See SmiHandler methods
   // for the encoding format.
-  Bind(&if_smi_handler);
+  BIND(&if_smi_handler);
   {
     Node* holder = p->receiver;
     Node* handler_word = SmiUntag(handler);
@@ -601,7 +601,7 @@ void AccessorAssembler::HandleStoreICHandlerCase(
     Label dictionary_found(this, &var_name_index);
     NameDictionaryLookup<NameDictionary>(properties, p->name, &dictionary_found,
                                          &var_name_index, miss);
-    Bind(&dictionary_found);
+    BIND(&dictionary_found);
     {
       Node* details = LoadDetailsByKeyIndex<NameDictionary>(
           properties, var_name_index.value());
@@ -616,12 +616,12 @@ void AccessorAssembler::HandleStoreICHandlerCase(
       Return(p->value);
     }
 
-    Bind(&if_fast_smi);
+    BIND(&if_fast_smi);
     // Handle non-transitioning field stores.
     HandleStoreICSmiHandlerCase(handler_word, holder, p->value, nullptr, miss);
   }
 
-  Bind(&if_nonsmi_handler);
+  BIND(&if_nonsmi_handler);
   {
     Node* handler_map = LoadMap(handler);
     if (support_elements == kSupportElements) {
@@ -632,22 +632,22 @@ void AccessorAssembler::HandleStoreICHandlerCase(
   }
 
   if (support_elements == kSupportElements) {
-    Bind(&if_element_handler);
+    BIND(&if_element_handler);
     { HandleStoreICElementHandlerCase(p, handler, miss); }
   }
 
-  Bind(&if_proto_handler);
+  BIND(&if_proto_handler);
   { HandleStoreICProtoHandler(p, handler, miss, support_elements); }
 
   // |handler| is a heap object. Must be code, call it.
-  Bind(&call_handler);
+  BIND(&call_handler);
   {
     StoreWithVectorDescriptor descriptor(isolate());
     TailCallStub(descriptor, handler, p->context, p->receiver, p->name,
                  p->value, p->slot, p->vector);
   }
 
-  Bind(&store_global);
+  BIND(&store_global);
   {
     Node* cell = LoadWeakCellValue(handler, miss);
     CSA_ASSERT(this, IsPropertyCell(cell));
@@ -685,7 +685,7 @@ void AccessorAssembler::HandleStoreICHandlerCase(
     GotoIfNot(TaggedIsSmi(p->value), miss);
     Goto(&store);
 
-    Bind(&not_smi);
+    BIND(&not_smi);
     {
       GotoIf(TaggedIsSmi(p->value), miss);
       Node* expected_map = LoadMap(cell_contents);
@@ -694,13 +694,13 @@ void AccessorAssembler::HandleStoreICHandlerCase(
       Goto(&store);
     }
 
-    Bind(&store);
+    BIND(&store);
     {
       StoreObjectField(cell, PropertyCell::kValueOffset, p->value);
       Return(p->value);
     }
 
-    Bind(&constant);
+    BIND(&constant);
     {
       GotoIfNot(WordEqual(cell_contents, p->value), miss);
       Return(p->value);
@@ -748,7 +748,7 @@ void AccessorAssembler::HandleStoreICProtoHandler(
          miss);
   Goto(&validity_cell_check_done);
 
-  Bind(&validity_cell_check_done);
+  BIND(&validity_cell_check_done);
   Node* smi_or_code = LoadObjectField(handler, StoreHandler::kSmiHandlerOffset);
 
   Node* maybe_transition_cell =
@@ -759,14 +759,14 @@ void AccessorAssembler::HandleStoreICProtoHandler(
   Variable var_transition(this, MachineRepresentation::kTagged);
   Label if_transition(this), if_transition_to_constant(this),
       if_store_normal(this);
-  Bind(&tuple_handler);
+  BIND(&tuple_handler);
   {
     Node* transition = LoadWeakCellValue(maybe_transition_cell, miss);
     var_transition.Bind(transition);
     Goto(&if_transition);
   }
 
-  Bind(&array_handler);
+  BIND(&array_handler);
   {
     Node* length = SmiUntag(maybe_transition_cell);
     BuildFastLoop(IntPtrConstant(StoreHandler::kFirstPrototypeIndex), length,
@@ -784,7 +784,7 @@ void AccessorAssembler::HandleStoreICProtoHandler(
     Goto(&if_transition);
   }
 
-  Bind(&if_transition);
+  BIND(&if_transition);
   {
     Node* holder = p->receiver;
     Node* transition = var_transition.value();
@@ -802,7 +802,7 @@ void AccessorAssembler::HandleStoreICProtoHandler(
       TailCallStub(descriptor, code_handler, p->context, p->receiver, p->name,
                    transition, p->value, p->slot, p->vector);
 
-      Bind(&if_smi_handler);
+      BIND(&if_smi_handler);
     }
 
     Node* smi_handler = smi_or_code;
@@ -820,7 +820,7 @@ void AccessorAssembler::HandleStoreICProtoHandler(
     HandleStoreICSmiHandlerCase(handler_word, holder, p->value, transition,
                                 miss);
 
-    Bind(&if_transition_to_constant);
+    BIND(&if_transition_to_constant);
     {
       // Check that constant matches value.
       Node* descriptor = DecodeWord<StoreHandler::DescriptorBits>(handler_word);
@@ -843,7 +843,7 @@ void AccessorAssembler::HandleStoreICProtoHandler(
       Return(p->value);
     }
 
-    Bind(&if_store_normal);
+    BIND(&if_store_normal);
     {
       Node* properties = LoadProperties(p->receiver);
 
@@ -851,7 +851,7 @@ void AccessorAssembler::HandleStoreICProtoHandler(
       Label found(this, &var_name_index), not_found(this);
       NameDictionaryLookup<NameDictionary>(properties, p->name, &found,
                                            &var_name_index, &not_found);
-      Bind(&found);
+      BIND(&found);
       {
         Node* details = LoadDetailsByKeyIndex<NameDictionary>(
             properties, var_name_index.value());
@@ -867,13 +867,13 @@ void AccessorAssembler::HandleStoreICProtoHandler(
         Return(p->value);
       }
 
-      Bind(&not_found);
+      BIND(&not_found);
       {
         Label slow(this);
         Add<NameDictionary>(properties, p->name, p->value, &slow);
         Return(p->value);
 
-        Bind(&slow);
+        BIND(&slow);
         TailCallRuntime(Runtime::kAddDictionaryProperty, p->context,
                         p->receiver, p->name, p->value);
       }
@@ -929,21 +929,21 @@ void AccessorAssembler::HandleStoreICSmiHandlerCase(Node* handler_word,
                              IntPtrConstant(StoreHandler::kSmi)));
   Goto(&if_smi_field);
 
-  Bind(&if_tagged_field);
+  BIND(&if_tagged_field);
   {
     Comment("store tagged field");
     HandleStoreFieldAndReturn(handler_word, holder, Representation::Tagged(),
                               value, transition, miss);
   }
 
-  Bind(&if_double_field);
+  BIND(&if_double_field);
   {
     Comment("store double field");
     HandleStoreFieldAndReturn(handler_word, holder, Representation::Double(),
                               value, transition, miss);
   }
 
-  Bind(&if_heap_object_field);
+  BIND(&if_heap_object_field);
   {
     Comment("store heap object field");
     HandleStoreFieldAndReturn(handler_word, holder,
@@ -951,7 +951,7 @@ void AccessorAssembler::HandleStoreICSmiHandlerCase(Node* handler_word,
                               miss);
   }
 
-  Bind(&if_smi_field);
+  BIND(&if_smi_field);
   {
     Comment("store smi field");
     HandleStoreFieldAndReturn(handler_word, holder, Representation::Smi(),
@@ -972,7 +972,7 @@ void AccessorAssembler::HandleStoreFieldAndReturn(Node* handler_word,
   Branch(IsSetWord<StoreHandler::IsInobjectBits>(handler_word), &if_inobject,
          &if_out_of_object);
 
-  Bind(&if_inobject);
+  BIND(&if_inobject);
   {
     StoreNamedField(handler_word, holder, true, representation, prepared_value,
                     transition_to_field, miss);
@@ -982,7 +982,7 @@ void AccessorAssembler::HandleStoreFieldAndReturn(Node* handler_word,
     Return(value);
   }
 
-  Bind(&if_out_of_object);
+  BIND(&if_out_of_object);
   {
     if (transition_to_field) {
       Label storage_extended(this);
@@ -993,7 +993,7 @@ void AccessorAssembler::HandleStoreFieldAndReturn(Node* handler_word,
       Comment("] Extend storage");
       Goto(&storage_extended);
 
-      Bind(&storage_extended);
+      BIND(&storage_extended);
     }
 
     StoreNamedField(handler_word, holder, false, representation, prepared_value,
@@ -1043,7 +1043,7 @@ Node* AccessorAssembler::PrepareValueForStore(Node* handler_word, Node* holder,
       Node* field_type = LoadWeakCellValue(maybe_field_type, bailout);
       Branch(WordEqual(LoadMap(value), field_type), &done, bailout);
     }
-    Bind(&done);
+    BIND(&done);
 
   } else if (representation.IsSmi()) {
     GotoIfNot(TaggedIsSmi(value), bailout);
@@ -1136,7 +1136,7 @@ void AccessorAssembler::StoreNamedField(Node* handler_word, Node* object,
       }
       Goto(&done);
     }
-    Bind(&done);
+    BIND(&done);
   }
 
   // Do the store.
@@ -1163,12 +1163,12 @@ void AccessorAssembler::EmitFastElementsBoundsCheck(Node* object,
     var_length.Bind(SmiUntag(LoadFixedArrayBaseLength(elements)));
     Goto(&length_loaded);
   }
-  Bind(&if_array);
+  BIND(&if_array);
   {
     var_length.Bind(SmiUntag(LoadJSArrayLength(object)));
     Goto(&length_loaded);
   }
-  Bind(&length_loaded);
+  BIND(&length_loaded);
   GotoIfNot(UintPtrLessThan(intptr_index, var_length.value()), miss);
 }
 
@@ -1205,13 +1205,13 @@ void AccessorAssembler::EmitElementLoad(
   Switch(elements_kind, unimplemented_elements_kind, kinds, labels,
          arraysize(kinds));
 
-  Bind(&if_fast_packed);
+  BIND(&if_fast_packed);
   {
     Comment("fast packed elements");
     exit_point->Return(LoadFixedArrayElement(elements, intptr_index));
   }
 
-  Bind(&if_fast_holey);
+  BIND(&if_fast_holey);
   {
     Comment("fast holey elements");
     Node* element = LoadFixedArrayElement(elements, intptr_index);
@@ -1219,7 +1219,7 @@ void AccessorAssembler::EmitElementLoad(
     exit_point->Return(element);
   }
 
-  Bind(&if_fast_double);
+  BIND(&if_fast_double);
   {
     Comment("packed double elements");
     var_double_value->Bind(LoadFixedDoubleArrayElement(elements, intptr_index,
@@ -1227,7 +1227,7 @@ void AccessorAssembler::EmitElementLoad(
     Goto(rebox_double);
   }
 
-  Bind(&if_fast_holey_double);
+  BIND(&if_fast_holey_double);
   {
     Comment("holey double elements");
     Node* value = LoadFixedDoubleArrayElement(elements, intptr_index,
@@ -1237,7 +1237,7 @@ void AccessorAssembler::EmitElementLoad(
     Goto(rebox_double);
   }
 
-  Bind(&if_nonfast);
+  BIND(&if_nonfast);
   {
     STATIC_ASSERT(LAST_ELEMENTS_KIND == LAST_FIXED_TYPED_ARRAY_ELEMENTS_KIND);
     GotoIf(Int32GreaterThanOrEqual(
@@ -1249,7 +1249,7 @@ void AccessorAssembler::EmitElementLoad(
     Goto(unimplemented_elements_kind);
   }
 
-  Bind(&if_dictionary);
+  BIND(&if_dictionary);
   {
     Comment("dictionary elements");
     GotoIf(IntPtrLessThan(intptr_index, IntPtrConstant(0)), out_of_bounds);
@@ -1257,7 +1257,7 @@ void AccessorAssembler::EmitElementLoad(
     Label if_found(this);
     NumberDictionaryLookup<SeededNumberDictionary>(
         elements, intptr_index, &if_found, &var_entry, if_hole);
-    Bind(&if_found);
+    BIND(&if_found);
     // Check that the value is a data property.
     Node* index = EntryToIndex<SeededNumberDictionary>(var_entry.value());
     Node* details =
@@ -1270,7 +1270,7 @@ void AccessorAssembler::EmitElementLoad(
         LoadValueByKeyIndex<SeededNumberDictionary>(elements, index));
   }
 
-  Bind(&if_typed_array);
+  BIND(&if_typed_array);
   {
     Comment("typed elements");
     // Check if buffer has been neutered.
@@ -1309,47 +1309,47 @@ void AccessorAssembler::EmitElementLoad(
     DCHECK_EQ(kTypedElementsKindCount, arraysize(elements_kind_labels));
     Switch(elements_kind, miss, elements_kinds, elements_kind_labels,
            kTypedElementsKindCount);
-    Bind(&uint8_elements);
+    BIND(&uint8_elements);
     {
       Comment("UINT8_ELEMENTS");  // Handles UINT8_CLAMPED_ELEMENTS too.
       Node* element = Load(MachineType::Uint8(), backing_store, intptr_index);
       exit_point->Return(SmiFromWord32(element));
     }
-    Bind(&int8_elements);
+    BIND(&int8_elements);
     {
       Comment("INT8_ELEMENTS");
       Node* element = Load(MachineType::Int8(), backing_store, intptr_index);
       exit_point->Return(SmiFromWord32(element));
     }
-    Bind(&uint16_elements);
+    BIND(&uint16_elements);
     {
       Comment("UINT16_ELEMENTS");
       Node* index = WordShl(intptr_index, IntPtrConstant(1));
       Node* element = Load(MachineType::Uint16(), backing_store, index);
       exit_point->Return(SmiFromWord32(element));
     }
-    Bind(&int16_elements);
+    BIND(&int16_elements);
     {
       Comment("INT16_ELEMENTS");
       Node* index = WordShl(intptr_index, IntPtrConstant(1));
       Node* element = Load(MachineType::Int16(), backing_store, index);
       exit_point->Return(SmiFromWord32(element));
     }
-    Bind(&uint32_elements);
+    BIND(&uint32_elements);
     {
       Comment("UINT32_ELEMENTS");
       Node* index = WordShl(intptr_index, IntPtrConstant(2));
       Node* element = Load(MachineType::Uint32(), backing_store, index);
       exit_point->Return(ChangeUint32ToTagged(element));
     }
-    Bind(&int32_elements);
+    BIND(&int32_elements);
     {
       Comment("INT32_ELEMENTS");
       Node* index = WordShl(intptr_index, IntPtrConstant(2));
       Node* element = Load(MachineType::Int32(), backing_store, index);
       exit_point->Return(ChangeInt32ToTagged(element));
     }
-    Bind(&float32_elements);
+    BIND(&float32_elements);
     {
       Comment("FLOAT32_ELEMENTS");
       Node* index = WordShl(intptr_index, IntPtrConstant(2));
@@ -1357,7 +1357,7 @@ void AccessorAssembler::EmitElementLoad(
       var_double_value->Bind(ChangeFloat32ToFloat64(element));
       Goto(rebox_double);
     }
-    Bind(&float64_elements);
+    BIND(&float64_elements);
     {
       Comment("FLOAT64_ELEMENTS");
       Node* index = WordShl(intptr_index, IntPtrConstant(3));
@@ -1379,14 +1379,14 @@ void AccessorAssembler::CheckPrototype(Node* prototype_cell, Node* name,
   Branch(IsPropertyCell(maybe_prototype), &if_property_cell,
          &if_dictionary_object);
 
-  Bind(&if_dictionary_object);
+  BIND(&if_dictionary_object);
   {
     CSA_ASSERT(this, IsDictionaryMap(LoadMap(maybe_prototype)));
     NameDictionaryNegativeLookup(maybe_prototype, name, miss);
     Goto(&done);
   }
 
-  Bind(&if_property_cell);
+  BIND(&if_property_cell);
   {
     // Ensure the property cell still contains the hole.
     Node* value = LoadObjectField(maybe_prototype, PropertyCell::kValueOffset);
@@ -1394,7 +1394,7 @@ void AccessorAssembler::CheckPrototype(Node* prototype_cell, Node* name,
     Goto(&done);
   }
 
-  Bind(&done);
+  BIND(&done);
 }
 
 void AccessorAssembler::NameDictionaryNegativeLookup(Node* object, Node* name,
@@ -1406,7 +1406,7 @@ void AccessorAssembler::NameDictionaryNegativeLookup(Node* object, Node* name,
   Label done(this);
   NameDictionaryLookup<NameDictionary>(properties, name, miss, &var_name_index,
                                        &done);
-  Bind(&done);
+  BIND(&done);
 }
 
 void AccessorAssembler::GenericElementLoad(Node* receiver, Node* receiver_map,
@@ -1437,10 +1437,10 @@ void AccessorAssembler::GenericElementLoad(Node* receiver, Node* receiver_map,
                   &var_double_value, unimplemented_elements_kind, &if_oob, slow,
                   &direct_exit);
 
-  Bind(&rebox_double);
+  BIND(&rebox_double);
   Return(AllocateHeapNumberWithValue(var_double_value.value()));
 
-  Bind(&if_oob);
+  BIND(&if_oob);
   {
     Comment("out of bounds");
     // Negative keys can't take the fast OOB path.
@@ -1449,13 +1449,13 @@ void AccessorAssembler::GenericElementLoad(Node* receiver, Node* receiver_map,
     Goto(&if_element_hole);
   }
 
-  Bind(&if_element_hole);
+  BIND(&if_element_hole);
   {
     Comment("found the hole");
     Label return_undefined(this);
     BranchIfPrototypesHaveNoElements(receiver_map, &return_undefined, slow);
 
-    Bind(&return_undefined);
+    BIND(&return_undefined);
     Return(UndefinedConstant());
   }
 }
@@ -1497,7 +1497,7 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
   DescriptorLookup(key, descriptors, bitfield3, &if_descriptor_found,
                    &var_name_index, notfound);
 
-  Bind(&if_descriptor_found);
+  BIND(&if_descriptor_found);
   {
     LoadPropertyFromFastObject(receiver, receiver_map, descriptors,
                                var_name_index.value(), &var_details,
@@ -1506,16 +1506,16 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
   }
 
   if (use_stub_cache == kUseStubCache) {
-    Bind(&stub_cache);
+    BIND(&stub_cache);
     Comment("stub cache probe for fast property load");
     Variable var_handler(this, MachineRepresentation::kTagged);
     Label found_handler(this, &var_handler), stub_cache_miss(this);
     TryProbeStubCache(isolate()->load_stub_cache(), receiver, key,
                       &found_handler, &var_handler, &stub_cache_miss);
-    Bind(&found_handler);
+    BIND(&found_handler);
     { HandleLoadICHandlerCase(p, var_handler.value(), slow, &direct_exit); }
 
-    Bind(&stub_cache_miss);
+    BIND(&stub_cache_miss);
     {
       // TODO(jkummerow): Check if the property exists on the prototype
       // chain. If it doesn't, then there's no point in missing.
@@ -1525,7 +1525,7 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
     }
   }
 
-  Bind(&if_property_dictionary);
+  BIND(&if_property_dictionary);
   {
     Comment("dictionary property load");
     // We checked for LAST_CUSTOM_ELEMENTS_RECEIVER before, which rules out
@@ -1536,7 +1536,7 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
     NameDictionaryLookup<NameDictionary>(properties, key, &dictionary_found,
                                          &var_name_index,
                                          &lookup_prototype_chain);
-    Bind(&dictionary_found);
+    BIND(&dictionary_found);
     {
       LoadPropertyFromNameDictionary(properties, var_name_index.value(),
                                      &var_details, &var_value);
@@ -1544,7 +1544,7 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
     }
   }
 
-  Bind(&if_found_on_receiver);
+  BIND(&if_found_on_receiver);
   {
     Node* value = CallGetterIfAccessor(var_value.value(), var_details.value(),
                                        p->context, receiver, slow);
@@ -1552,7 +1552,7 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
     Return(value);
   }
 
-  Bind(&lookup_prototype_chain);
+  BIND(&lookup_prototype_chain);
   {
     Variable var_holder_map(this, MachineRepresentation::kTagged);
     Variable var_holder_instance_type(this, MachineRepresentation::kWord32);
@@ -1565,7 +1565,7 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
     // Private symbols must not be looked up on the prototype chain.
     GotoIf(IsPrivateSymbol(key), &return_undefined);
     Goto(&loop);
-    Bind(&loop);
+    BIND(&loop);
     {
       // Bailout if it can be an integer indexed exotic case.
       GotoIf(Word32Equal(var_holder_instance_type.value(),
@@ -1584,17 +1584,17 @@ void AccessorAssembler::GenericPropertyLoad(Node* receiver, Node* receiver_map,
 
       // This trampoline and the next are required to appease Turbofan's
       // variable merging.
-      Bind(&next_proto);
+      BIND(&next_proto);
       Goto(&loop);
 
-      Bind(&goto_slow);
+      BIND(&goto_slow);
       Goto(slow);
 
-      Bind(&return_value);
+      BIND(&return_value);
       Return(var_value.value());
     }
 
-    Bind(&return_undefined);
+    BIND(&return_undefined);
     Return(UndefinedConstant());
   }
 }
@@ -1704,7 +1704,7 @@ void AccessorAssembler::TryProbeStubCache(StubCache* stub_cache, Node* receiver,
   TryProbeStubCacheTable(stub_cache, kPrimary, primary_offset, name,
                          receiver_map, if_handler, var_handler, &try_secondary);
 
-  Bind(&try_secondary);
+  BIND(&try_secondary);
   {
     // Probe the secondary table.
     Node* secondary_offset = StubCacheSecondaryOffset(name, primary_offset);
@@ -1712,7 +1712,7 @@ void AccessorAssembler::TryProbeStubCache(StubCache* stub_cache, Node* receiver,
                            receiver_map, if_handler, var_handler, &miss);
   }
 
-  Bind(&miss);
+  BIND(&miss);
   {
     IncrementCounter(counters->megamorphic_stub_cache_misses(), 1);
     Goto(if_miss);
@@ -1748,10 +1748,10 @@ void AccessorAssembler::LoadIC_BytecodeHandler(const LoadICParameters* p,
         TryMonomorphicCase(p->slot, p->vector, recv_map, &if_handler,
                            &var_handler, &try_polymorphic);
 
-    Bind(&if_handler);
+    BIND(&if_handler);
     HandleLoadICHandlerCase(p, var_handler.value(), &miss, exit_point);
 
-    Bind(&try_polymorphic);
+    BIND(&try_polymorphic);
     {
       GotoIfNot(WordEqual(LoadMap(feedback), FixedArrayMapConstant()),
                 &stub_call);
@@ -1760,7 +1760,7 @@ void AccessorAssembler::LoadIC_BytecodeHandler(const LoadICParameters* p,
     }
   }
 
-  Bind(&stub_call);
+  BIND(&stub_call);
   {
     Comment("LoadIC_BytecodeHandler_noninlined");
 
@@ -1771,7 +1771,7 @@ void AccessorAssembler::LoadIC_BytecodeHandler(const LoadICParameters* p,
                                p->receiver, p->name, p->slot, p->vector);
   }
 
-  Bind(&miss);
+  BIND(&miss);
   {
     Comment("LoadIC_BytecodeHandler_miss");
 
@@ -1796,10 +1796,10 @@ void AccessorAssembler::LoadIC(const LoadICParameters* p) {
   Node* feedback =
       TryMonomorphicCase(p->slot, p->vector, receiver_map, &if_handler,
                          &var_handler, &try_polymorphic);
-  Bind(&if_handler);
+  BIND(&if_handler);
   HandleLoadICHandlerCase(p, var_handler.value(), &miss, &direct_exit);
 
-  Bind(&try_polymorphic);
+  BIND(&try_polymorphic);
   {
     // Check polymorphic case.
     Comment("LoadIC_try_polymorphic");
@@ -1809,11 +1809,11 @@ void AccessorAssembler::LoadIC(const LoadICParameters* p) {
                           &miss, 2);
   }
 
-  Bind(&non_inlined);
+  BIND(&non_inlined);
   LoadIC_Noninlined(p, receiver_map, feedback, &var_handler, &if_handler, &miss,
                     &direct_exit);
 
-  Bind(&miss);
+  BIND(&miss);
   direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, p->context, p->receiver,
                                 p->name, p->slot, p->vector);
 }
@@ -1842,7 +1842,7 @@ void AccessorAssembler::LoadIC_Noninlined(const LoadICParameters* p,
                       if_handler, var_handler, miss);
   }
 
-  Bind(&try_uninitialized);
+  BIND(&try_uninitialized);
   {
     // Check uninitialized case.
     GotoIfNot(
@@ -1889,15 +1889,15 @@ void AccessorAssembler::LoadIC_Uninitialized(const LoadICParameters* p) {
     var_result.Bind(LoadMapPrototype(proto_or_map));
     Goto(&done);
 
-    Bind(&done);
+    BIND(&done);
     Return(var_result.value());
   }
-  Bind(&not_function_prototype);
+  BIND(&not_function_prototype);
 
   GenericPropertyLoad(receiver, receiver_map, instance_type, p->name, p, &miss,
                       kDontUseStubCache);
 
-  Bind(&miss);
+  BIND(&miss);
   {
     // Undo the optimistic state transition.
     StoreFixedArrayElement(p->vector, p->slot,
@@ -1930,7 +1930,7 @@ void AccessorAssembler::LoadICProtoArray(
                              throw_reference_error_if_nonexistent,
                              kOnlyProperties);
 
-  Bind(&miss);
+  BIND(&miss);
   {
     TailCallRuntime(Runtime::kLoadIC_Miss, p->context, p->receiver, p->name,
                     p->slot, p->vector);
@@ -1983,13 +1983,13 @@ void AccessorAssembler::LoadGlobalIC_TryHandlerCase(const LoadICParameters* pp,
                                kOnlyProperties);
   }
 
-  Bind(&non_smi);
+  BIND(&non_smi);
   GotoIf(IsCodeMap(LoadMap(handler)), &call_handler);
 
   HandleLoadGlobalICHandlerCase(pp, handler, miss, exit_point,
                                 throw_reference_error_if_nonexistent);
 
-  Bind(&call_handler);
+  BIND(&call_handler);
   {
     LoadWithVectorDescriptor descriptor(isolate());
     Node* native_context = LoadNativeContext(pp->context);
@@ -2018,10 +2018,10 @@ void AccessorAssembler::LoadGlobalIC(const LoadICParameters* p,
   LoadGlobalIC_TryPropertyCellCase(p->vector, p->slot, &direct_exit,
                                    &try_handler, &miss);
 
-  Bind(&try_handler);
+  BIND(&try_handler);
   LoadGlobalIC_TryHandlerCase(p, typeof_mode, &direct_exit, &miss);
 
-  Bind(&miss);
+  BIND(&miss);
   LoadGlobalIC_MissCase(p, &direct_exit);
 }
 
@@ -2041,13 +2041,13 @@ void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p) {
   Node* feedback =
       TryMonomorphicCase(p->slot, p->vector, receiver_map, &if_handler,
                          &var_handler, &try_polymorphic);
-  Bind(&if_handler);
+  BIND(&if_handler);
   {
     HandleLoadICHandlerCase(p, var_handler.value(), &miss, &direct_exit,
                             kSupportElements);
   }
 
-  Bind(&try_polymorphic);
+  BIND(&try_polymorphic);
   {
     // Check polymorphic case.
     Comment("KeyedLoadIC_try_polymorphic");
@@ -2057,7 +2057,7 @@ void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p) {
                           &miss, 2);
   }
 
-  Bind(&try_megamorphic);
+  BIND(&try_megamorphic);
   {
     // Check megamorphic case.
     Comment("KeyedLoadIC_try_megamorphic");
@@ -2067,7 +2067,7 @@ void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p) {
     TailCallStub(CodeFactory::KeyedLoadIC_Megamorphic(isolate()), p->context,
                  p->receiver, p->name, p->slot, p->vector);
   }
-  Bind(&try_polymorphic_name);
+  BIND(&try_polymorphic_name);
   {
     // We might have a name in feedback, and a fixed array in the next slot.
     Comment("KeyedLoadIC_try_polymorphic_name");
@@ -2079,7 +2079,7 @@ void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p) {
     HandlePolymorphicCase(receiver_map, array, &if_handler, &var_handler, &miss,
                           1);
   }
-  Bind(&miss);
+  BIND(&miss);
   {
     Comment("KeyedLoadIC_miss");
     TailCallRuntime(Runtime::kKeyedLoadIC_Miss, p->context, p->receiver,
@@ -2101,19 +2101,19 @@ void AccessorAssembler::KeyedLoadICGeneric(const LoadICParameters* p) {
   TryToName(p->name, &if_index, &var_index, &if_unique_name, &var_unique,
             &slow);
 
-  Bind(&if_index);
+  BIND(&if_index);
   {
     GenericElementLoad(receiver, receiver_map, instance_type, var_index.value(),
                        &slow);
   }
 
-  Bind(&if_unique_name);
+  BIND(&if_unique_name);
   {
     GenericPropertyLoad(receiver, receiver_map, instance_type,
                         var_unique.value(), p, &slow);
   }
 
-  Bind(&slow);
+  BIND(&slow);
   {
     Comment("KeyedLoadGeneric_slow");
     IncrementCounter(isolate()->counters()->ic_keyed_load_generic_slow(), 1);
@@ -2137,13 +2137,13 @@ void AccessorAssembler::StoreIC(const StoreICParameters* p,
   Node* feedback =
       TryMonomorphicCase(p->slot, p->vector, receiver_map, &if_handler,
                          &var_handler, &try_polymorphic);
-  Bind(&if_handler);
+  BIND(&if_handler);
   {
     Comment("StoreIC_if_handler");
     HandleStoreICHandlerCase(p, var_handler.value(), &miss);
   }
 
-  Bind(&try_polymorphic);
+  BIND(&try_polymorphic);
   {
     // Check polymorphic case.
     Comment("StoreIC_try_polymorphic");
@@ -2154,7 +2154,7 @@ void AccessorAssembler::StoreIC(const StoreICParameters* p,
                           &miss, 2);
   }
 
-  Bind(&try_megamorphic);
+  BIND(&try_megamorphic);
   {
     // Check megamorphic case.
     GotoIfNot(WordEqual(feedback, LoadRoot(Heap::kmegamorphic_symbolRootIndex)),
@@ -2163,7 +2163,7 @@ void AccessorAssembler::StoreIC(const StoreICParameters* p,
     TryProbeStubCache(isolate()->store_stub_cache(), p->receiver, p->name,
                       &if_handler, &var_handler, &miss);
   }
-  Bind(&try_uninitialized);
+  BIND(&try_uninitialized);
   {
     // Check uninitialized case.
     GotoIfNot(
@@ -2173,7 +2173,7 @@ void AccessorAssembler::StoreIC(const StoreICParameters* p,
                  p->context, p->receiver, p->name, p->value, p->slot,
                  p->vector);
   }
-  Bind(&miss);
+  BIND(&miss);
   {
     TailCallRuntime(Runtime::kStoreIC_Miss, p->context, p->value, p->slot,
                     p->vector, p->receiver, p->name);
@@ -2198,13 +2198,13 @@ void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p,
     Node* feedback =
         TryMonomorphicCase(p->slot, p->vector, receiver_map, &if_handler,
                            &var_handler, &try_polymorphic);
-    Bind(&if_handler);
+    BIND(&if_handler);
     {
       Comment("KeyedStoreIC_if_handler");
       HandleStoreICHandlerCase(p, var_handler.value(), &miss, kSupportElements);
     }
 
-    Bind(&try_polymorphic);
+    BIND(&try_polymorphic);
     {
       // CheckPolymorphic case.
       Comment("KeyedStoreIC_try_polymorphic");
@@ -2215,7 +2215,7 @@ void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p,
                             &miss, 2);
     }
 
-    Bind(&try_megamorphic);
+    BIND(&try_megamorphic);
     {
       // Check megamorphic case.
       Comment("KeyedStoreIC_try_megamorphic");
@@ -2227,7 +2227,7 @@ void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p,
           p->context, p->receiver, p->name, p->value, p->slot, p->vector);
     }
 
-    Bind(&try_polymorphic_name);
+    BIND(&try_polymorphic_name);
     {
       // We might have a name in feedback, and a fixed array in the next slot.
       Comment("KeyedStoreIC_try_polymorphic_name");
@@ -2240,7 +2240,7 @@ void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p,
                             &miss, 1);
     }
   }
-  Bind(&miss);
+  BIND(&miss);
   {
     Comment("KeyedStoreIC_miss");
     TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context, p->value, p->slot,
@@ -2283,10 +2283,10 @@ void AccessorAssembler::GenerateLoadIC_Noninlined() {
   LoadIC_Noninlined(&p, receiver_map, feedback, &var_handler, &if_handler,
                     &miss, &direct_exit);
 
-  Bind(&if_handler);
+  BIND(&if_handler);
   HandleLoadICHandlerCase(&p, var_handler.value(), &miss, &direct_exit);
 
-  Bind(&miss);
+  BIND(&miss);
   direct_exit.ReturnCallRuntime(Runtime::kLoadIC_Miss, context, receiver, name,
                                 slot, vector);
 }
@@ -2352,7 +2352,7 @@ void AccessorAssembler::GenerateLoadField() {
   HandleLoadField(receiver, handler_word, &var_double_value, &rebox_double,
                   &direct_exit);
 
-  Bind(&rebox_double);
+  BIND(&rebox_double);
   Return(AllocateHeapNumberWithValue(var_double_value.value()));
 }
 
diff --git a/src/ic/binary-op-assembler.cc b/src/ic/binary-op-assembler.cc
index b35c7dfb573..98b6dc1181a 100644
--- a/src/ic/binary-op-assembler.cc
+++ b/src/ic/binary-op-assembler.cc
@@ -28,13 +28,13 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
   Label if_lhsissmi(this), if_lhsisnotsmi(this);
   Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-  Bind(&if_lhsissmi);
+  BIND(&if_lhsissmi);
   {
     // Check if the {rhs} is also a Smi.
     Label if_rhsissmi(this), if_rhsisnotsmi(this);
     Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-    Bind(&if_rhsissmi);
+    BIND(&if_rhsissmi);
     {
       // Try fast Smi addition first.
       Node* pair = IntPtrAddWithOverflow(BitcastTaggedToWord(lhs),
@@ -45,14 +45,14 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
       Label if_overflow(this), if_notoverflow(this);
       Branch(overflow, &if_overflow, &if_notoverflow);
 
-      Bind(&if_overflow);
+      BIND(&if_overflow);
       {
         var_fadd_lhs.Bind(SmiToFloat64(lhs));
         var_fadd_rhs.Bind(SmiToFloat64(rhs));
         Goto(&do_fadd);
       }
 
-      Bind(&if_notoverflow);
+      BIND(&if_notoverflow);
       {
         var_type_feedback.Bind(
             SmiConstant(BinaryOperationFeedback::kSignedSmall));
@@ -61,7 +61,7 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
       }
     }
 
-    Bind(&if_rhsisnotsmi);
+    BIND(&if_rhsisnotsmi);
     {
       // Load the map of {rhs}.
       Node* rhs_map = LoadMap(rhs);
@@ -75,7 +75,7 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&if_lhsisnotsmi);
+  BIND(&if_lhsisnotsmi);
   {
     // Load the map of {lhs}.
     Node* lhs_map = LoadMap(lhs);
@@ -87,14 +87,14 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
     Label if_rhsissmi(this), if_rhsisnotsmi(this);
     Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-    Bind(&if_rhsissmi);
+    BIND(&if_rhsissmi);
     {
       var_fadd_lhs.Bind(LoadHeapNumberValue(lhs));
       var_fadd_rhs.Bind(SmiToFloat64(rhs));
       Goto(&do_fadd);
     }
 
-    Bind(&if_rhsisnotsmi);
+    BIND(&if_rhsisnotsmi);
     {
       // Load the map of {rhs}.
       Node* rhs_map = LoadMap(rhs);
@@ -108,7 +108,7 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&do_fadd);
+  BIND(&do_fadd);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kNumber));
     Node* value = Float64Add(var_fadd_lhs.value(), var_fadd_rhs.value());
@@ -117,7 +117,7 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
     Goto(&end);
   }
 
-  Bind(&if_lhsisnotnumber);
+  BIND(&if_lhsisnotnumber);
   {
     // No checks on rhs are done yet. We just know lhs is not a number or Smi.
     Label if_lhsisoddball(this), if_lhsisnotoddball(this);
@@ -126,7 +126,7 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
         Word32Equal(lhs_instance_type, Int32Constant(ODDBALL_TYPE));
     Branch(lhs_is_oddball, &if_lhsisoddball, &if_lhsisnotoddball);
 
-    Bind(&if_lhsisoddball);
+    BIND(&if_lhsisoddball);
     {
       GotoIf(TaggedIsSmi(rhs), &call_with_oddball_feedback);
 
@@ -138,7 +138,7 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
              &check_rhsisoddball);
     }
 
-    Bind(&if_lhsisnotoddball);
+    BIND(&if_lhsisnotoddball);
     {
       // Exit unless {lhs} is a string
       GotoIfNot(IsStringInstanceType(lhs_instance_type),
@@ -163,7 +163,7 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&check_rhsisoddball);
+  BIND(&check_rhsisoddball);
   {
     // Check if rhs is an oddball. At this point we know lhs is either a
     // Smi or number or oddball and rhs is not a number or Smi.
@@ -174,27 +174,27 @@ Node* BinaryOpAssembler::Generate_AddWithFeedback(Node* context, Node* lhs,
            &call_with_any_feedback);
   }
 
-  Bind(&call_with_oddball_feedback);
+  BIND(&call_with_oddball_feedback);
   {
     var_type_feedback.Bind(
         SmiConstant(BinaryOperationFeedback::kNumberOrOddball));
     Goto(&call_add_stub);
   }
 
-  Bind(&call_with_any_feedback);
+  BIND(&call_with_any_feedback);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kAny));
     Goto(&call_add_stub);
   }
 
-  Bind(&call_add_stub);
+  BIND(&call_add_stub);
   {
     Callable callable = CodeFactory::Add(isolate());
     var_result.Bind(CallStub(callable, context, lhs, rhs));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   UpdateFeedback(var_type_feedback.value(), feedback_vector, slot_id);
   return var_result.value();
 }
@@ -215,13 +215,13 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
   Label if_lhsissmi(this), if_lhsisnotsmi(this);
   Branch(TaggedIsSmi(lhs), &if_lhsissmi, &if_lhsisnotsmi);
 
-  Bind(&if_lhsissmi);
+  BIND(&if_lhsissmi);
   {
     // Check if the {rhs} is also a Smi.
     Label if_rhsissmi(this), if_rhsisnotsmi(this);
     Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-    Bind(&if_rhsissmi);
+    BIND(&if_rhsissmi);
     {
       // Try a fast Smi subtraction first.
       Node* pair = IntPtrSubWithOverflow(BitcastTaggedToWord(lhs),
@@ -232,7 +232,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
       Label if_overflow(this), if_notoverflow(this);
       Branch(overflow, &if_overflow, &if_notoverflow);
 
-      Bind(&if_overflow);
+      BIND(&if_overflow);
       {
         // lhs, rhs - smi and result - number. combined - number.
         // The result doesn't fit into Smi range.
@@ -241,7 +241,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
         Goto(&do_fsub);
       }
 
-      Bind(&if_notoverflow);
+      BIND(&if_notoverflow);
       // lhs, rhs, result smi. combined - smi.
       var_type_feedback.Bind(
           SmiConstant(BinaryOperationFeedback::kSignedSmall));
@@ -249,7 +249,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
       Goto(&end);
     }
 
-    Bind(&if_rhsisnotsmi);
+    BIND(&if_rhsisnotsmi);
     {
       // Load the map of the {rhs}.
       Node* rhs_map = LoadMap(rhs);
@@ -264,7 +264,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&if_lhsisnotsmi);
+  BIND(&if_lhsisnotsmi);
   {
     // Load the map of the {lhs}.
     Node* lhs_map = LoadMap(lhs);
@@ -276,7 +276,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
     Label if_rhsissmi(this), if_rhsisnotsmi(this);
     Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-    Bind(&if_rhsissmi);
+    BIND(&if_rhsissmi);
     {
       // Perform a floating point subtraction.
       var_fsub_lhs.Bind(LoadHeapNumberValue(lhs));
@@ -284,7 +284,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
       Goto(&do_fsub);
     }
 
-    Bind(&if_rhsisnotsmi);
+    BIND(&if_rhsisnotsmi);
     {
       // Load the map of the {rhs}.
       Node* rhs_map = LoadMap(rhs);
@@ -299,7 +299,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&do_fsub);
+  BIND(&do_fsub);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kNumber));
     Node* lhs_value = var_fsub_lhs.value();
@@ -309,7 +309,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
     Goto(&end);
   }
 
-  Bind(&if_lhsisnotnumber);
+  BIND(&if_lhsisnotnumber);
   {
     // No checks on rhs are done yet. We just know lhs is not a number or Smi.
     // Check if lhs is an oddball.
@@ -321,14 +321,14 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
     Label if_rhsissmi(this), if_rhsisnotsmi(this);
     Branch(TaggedIsSmi(rhs), &if_rhsissmi, &if_rhsisnotsmi);
 
-    Bind(&if_rhsissmi);
+    BIND(&if_rhsissmi);
     {
       var_type_feedback.Bind(
           SmiConstant(BinaryOperationFeedback::kNumberOrOddball));
       Goto(&call_subtract_stub);
     }
 
-    Bind(&if_rhsisnotsmi);
+    BIND(&if_rhsisnotsmi);
     {
       // Load the map of the {rhs}.
       Node* rhs_map = LoadMap(rhs);
@@ -342,7 +342,7 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&check_rhsisoddball);
+  BIND(&check_rhsisoddball);
   {
     // Check if rhs is an oddball. At this point we know lhs is either a
     // Smi or number or oddball and rhs is not a number or Smi.
@@ -356,20 +356,20 @@ Node* BinaryOpAssembler::Generate_SubtractWithFeedback(Node* context, Node* lhs,
     Goto(&call_subtract_stub);
   }
 
-  Bind(&call_with_any_feedback);
+  BIND(&call_with_any_feedback);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kAny));
     Goto(&call_subtract_stub);
   }
 
-  Bind(&call_subtract_stub);
+  BIND(&call_subtract_stub);
   {
     Callable callable = CodeFactory::Subtract(isolate());
     var_result.Bind(CallStub(callable, context, lhs, rhs));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   UpdateFeedback(var_type_feedback.value(), feedback_vector, slot_id);
   return var_result.value();
 }
@@ -390,12 +390,12 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
   Label lhs_is_smi(this), lhs_is_not_smi(this);
   Branch(TaggedIsSmi(lhs), &lhs_is_smi, &lhs_is_not_smi);
 
-  Bind(&lhs_is_smi);
+  BIND(&lhs_is_smi);
   {
     Label rhs_is_smi(this), rhs_is_not_smi(this);
     Branch(TaggedIsSmi(rhs), &rhs_is_smi, &rhs_is_not_smi);
 
-    Bind(&rhs_is_smi);
+    BIND(&rhs_is_smi);
     {
       // Both {lhs} and {rhs} are Smis. The result is not necessarily a smi,
       // in case of overflow.
@@ -407,7 +407,7 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
       Goto(&end);
     }
 
-    Bind(&rhs_is_not_smi);
+    BIND(&rhs_is_not_smi);
     {
       Node* rhs_map = LoadMap(rhs);
 
@@ -421,7 +421,7 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&lhs_is_not_smi);
+  BIND(&lhs_is_not_smi);
   {
     Node* lhs_map = LoadMap(lhs);
 
@@ -432,7 +432,7 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
     Label rhs_is_smi(this), rhs_is_not_smi(this);
     Branch(TaggedIsSmi(rhs), &rhs_is_smi, &rhs_is_not_smi);
 
-    Bind(&rhs_is_smi);
+    BIND(&rhs_is_smi);
     {
       // Convert {rhs} to a double and multiply it with the value of {lhs}.
       var_lhs_float64.Bind(LoadHeapNumberValue(lhs));
@@ -440,7 +440,7 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
       Goto(&do_fmul);
     }
 
-    Bind(&rhs_is_not_smi);
+    BIND(&rhs_is_not_smi);
     {
       Node* rhs_map = LoadMap(rhs);
 
@@ -455,7 +455,7 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
     }
   }
 
-  Bind(&do_fmul);
+  BIND(&do_fmul);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kNumber));
     Node* value = Float64Mul(var_lhs_float64.value(), var_rhs_float64.value());
@@ -464,7 +464,7 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
     Goto(&end);
   }
 
-  Bind(&if_lhsisnotnumber);
+  BIND(&if_lhsisnotnumber);
   {
     // No checks on rhs are done yet. We just know lhs is not a number or Smi.
     // Check if lhs is an oddball.
@@ -483,7 +483,7 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
            &check_rhsisoddball);
   }
 
-  Bind(&check_rhsisoddball);
+  BIND(&check_rhsisoddball);
   {
     // Check if rhs is an oddball. At this point we know lhs is either a
     // Smi or number or oddball and rhs is not a number or Smi.
@@ -494,27 +494,27 @@ Node* BinaryOpAssembler::Generate_MultiplyWithFeedback(Node* context, Node* lhs,
            &call_with_any_feedback);
   }
 
-  Bind(&call_with_oddball_feedback);
+  BIND(&call_with_oddball_feedback);
   {
     var_type_feedback.Bind(
         SmiConstant(BinaryOperationFeedback::kNumberOrOddball));
     Goto(&call_multiply_stub);
   }
 
-  Bind(&call_with_any_feedback);
+  BIND(&call_with_any_feedback);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kAny));
     Goto(&call_multiply_stub);
   }
 
-  Bind(&call_multiply_stub);
+  BIND(&call_multiply_stub);
   {
     Callable callable = CodeFactory::Multiply(isolate());
     var_result.Bind(CallStub(callable, context, lhs, rhs));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   UpdateFeedback(var_type_feedback.value(), feedback_vector, slot_id);
   return var_result.value();
 }
@@ -537,12 +537,12 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
   Label dividend_is_smi(this), dividend_is_not_smi(this);
   Branch(TaggedIsSmi(dividend), &dividend_is_smi, &dividend_is_not_smi);
 
-  Bind(&dividend_is_smi);
+  BIND(&dividend_is_smi);
   {
     Label divisor_is_smi(this), divisor_is_not_smi(this);
     Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-    Bind(&divisor_is_smi);
+    BIND(&divisor_is_smi);
     {
       Label bailout(this);
 
@@ -555,12 +555,12 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
       Branch(WordEqual(dividend, SmiConstant(0)), &dividend_is_zero,
              &dividend_is_not_zero);
 
-      Bind(&dividend_is_zero);
+      BIND(&dividend_is_zero);
       {
         GotoIf(SmiLessThan(divisor, SmiConstant(0)), &bailout);
         Goto(&dividend_is_not_zero);
       }
-      Bind(&dividend_is_not_zero);
+      BIND(&dividend_is_not_zero);
 
       Node* untagged_divisor = SmiToWord32(divisor);
       Node* untagged_dividend = SmiToWord32(dividend);
@@ -571,7 +571,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
       Branch(Word32Equal(untagged_divisor, Int32Constant(-1)),
              &divisor_is_minus_one, &divisor_is_not_minus_one);
 
-      Bind(&divisor_is_minus_one);
+      BIND(&divisor_is_minus_one);
       {
         GotoIf(Word32Equal(untagged_dividend,
                            Int32Constant(kSmiValueSize == 32 ? kMinInt
@@ -579,7 +579,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
                &bailout);
         Goto(&divisor_is_not_minus_one);
       }
-      Bind(&divisor_is_not_minus_one);
+      BIND(&divisor_is_not_minus_one);
 
       Node* untagged_result = Int32Div(untagged_dividend, untagged_divisor);
       Node* truncated = Int32Mul(untagged_result, untagged_divisor);
@@ -592,7 +592,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
 
       // Bailout: convert {dividend} and {divisor} to double and do double
       // division.
-      Bind(&bailout);
+      BIND(&bailout);
       {
         var_dividend_float64.Bind(SmiToFloat64(dividend));
         var_divisor_float64.Bind(SmiToFloat64(divisor));
@@ -600,7 +600,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
       }
     }
 
-    Bind(&divisor_is_not_smi);
+    BIND(&divisor_is_not_smi);
     {
       Node* divisor_map = LoadMap(divisor);
 
@@ -614,7 +614,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
       Goto(&do_fdiv);
     }
 
-    Bind(&dividend_is_not_smi);
+    BIND(&dividend_is_not_smi);
     {
       Node* dividend_map = LoadMap(dividend);
 
@@ -625,7 +625,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
       Label divisor_is_smi(this), divisor_is_not_smi(this);
       Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-      Bind(&divisor_is_smi);
+      BIND(&divisor_is_smi);
       {
         // Convert {divisor} to a double and use it for a floating point
         // division.
@@ -634,7 +634,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
         Goto(&do_fdiv);
       }
 
-      Bind(&divisor_is_not_smi);
+      BIND(&divisor_is_not_smi);
       {
         Node* divisor_map = LoadMap(divisor);
 
@@ -650,7 +650,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
     }
   }
 
-  Bind(&do_fdiv);
+  BIND(&do_fdiv);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kNumber));
     Node* value =
@@ -659,7 +659,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
     Goto(&end);
   }
 
-  Bind(&dividend_is_not_number);
+  BIND(&dividend_is_not_number);
   {
     // We just know dividend is not a number or Smi. No checks on divisor yet.
     // Check if dividend is an oddball.
@@ -678,7 +678,7 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
            &check_divisor_for_oddball);
   }
 
-  Bind(&check_divisor_for_oddball);
+  BIND(&check_divisor_for_oddball);
   {
     // Check if divisor is an oddball. At this point we know dividend is either
     // a Smi or number or oddball and divisor is not a number or Smi.
@@ -689,27 +689,27 @@ Node* BinaryOpAssembler::Generate_DivideWithFeedback(Node* context,
            &call_with_any_feedback);
   }
 
-  Bind(&call_with_oddball_feedback);
+  BIND(&call_with_oddball_feedback);
   {
     var_type_feedback.Bind(
         SmiConstant(BinaryOperationFeedback::kNumberOrOddball));
     Goto(&call_divide_stub);
   }
 
-  Bind(&call_with_any_feedback);
+  BIND(&call_with_any_feedback);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kAny));
     Goto(&call_divide_stub);
   }
 
-  Bind(&call_divide_stub);
+  BIND(&call_divide_stub);
   {
     Callable callable = CodeFactory::Divide(isolate());
     var_result.Bind(CallStub(callable, context, dividend, divisor));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   UpdateFeedback(var_type_feedback.value(), feedback_vector, slot_id);
   return var_result.value();
 }
@@ -732,12 +732,12 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
   Label dividend_is_smi(this), dividend_is_not_smi(this);
   Branch(TaggedIsSmi(dividend), &dividend_is_smi, &dividend_is_not_smi);
 
-  Bind(&dividend_is_smi);
+  BIND(&dividend_is_smi);
   {
     Label divisor_is_smi(this), divisor_is_not_smi(this);
     Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-    Bind(&divisor_is_smi);
+    BIND(&divisor_is_smi);
     {
       var_result.Bind(SmiMod(dividend, divisor));
       var_type_feedback.Bind(
@@ -747,7 +747,7 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
       Goto(&end);
     }
 
-    Bind(&divisor_is_not_smi);
+    BIND(&divisor_is_not_smi);
     {
       Node* divisor_map = LoadMap(divisor);
 
@@ -762,7 +762,7 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
     }
   }
 
-  Bind(&dividend_is_not_smi);
+  BIND(&dividend_is_not_smi);
   {
     Node* dividend_map = LoadMap(dividend);
 
@@ -773,7 +773,7 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
     Label divisor_is_smi(this), divisor_is_not_smi(this);
     Branch(TaggedIsSmi(divisor), &divisor_is_smi, &divisor_is_not_smi);
 
-    Bind(&divisor_is_smi);
+    BIND(&divisor_is_smi);
     {
       // Convert {divisor} to a double and use it for a floating point
       // division.
@@ -782,7 +782,7 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
       Goto(&do_fmod);
     }
 
-    Bind(&divisor_is_not_smi);
+    BIND(&divisor_is_not_smi);
     {
       Node* divisor_map = LoadMap(divisor);
 
@@ -797,7 +797,7 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
     }
   }
 
-  Bind(&do_fmod);
+  BIND(&do_fmod);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kNumber));
     Node* value =
@@ -806,7 +806,7 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
     Goto(&end);
   }
 
-  Bind(&dividend_is_not_number);
+  BIND(&dividend_is_not_number);
   {
     // No checks on divisor yet. We just know dividend is not a number or Smi.
     // Check if dividend is an oddball.
@@ -825,7 +825,7 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
            &check_divisor_for_oddball);
   }
 
-  Bind(&check_divisor_for_oddball);
+  BIND(&check_divisor_for_oddball);
   {
     // Check if divisor is an oddball. At this point we know dividend is either
     // a Smi or number or oddball and divisor is not a number or Smi.
@@ -836,27 +836,27 @@ Node* BinaryOpAssembler::Generate_ModulusWithFeedback(Node* context,
            &call_with_any_feedback);
   }
 
-  Bind(&call_with_oddball_feedback);
+  BIND(&call_with_oddball_feedback);
   {
     var_type_feedback.Bind(
         SmiConstant(BinaryOperationFeedback::kNumberOrOddball));
     Goto(&call_modulus_stub);
   }
 
-  Bind(&call_with_any_feedback);
+  BIND(&call_with_any_feedback);
   {
     var_type_feedback.Bind(SmiConstant(BinaryOperationFeedback::kAny));
     Goto(&call_modulus_stub);
   }
 
-  Bind(&call_modulus_stub);
+  BIND(&call_modulus_stub);
   {
     Callable callable = CodeFactory::Modulus(isolate());
     var_result.Bind(CallStub(callable, context, dividend, divisor));
     Goto(&end);
   }
 
-  Bind(&end);
+  BIND(&end);
   UpdateFeedback(var_type_feedback.value(), feedback_vector, slot_id);
   return var_result.value();
 }
diff --git a/src/ic/keyed-store-generic.cc b/src/ic/keyed-store-generic.cc
index 165aa14a342..69d99baeaf3 100644
--- a/src/ic/keyed-store-generic.cc
+++ b/src/ic/keyed-store-generic.cc
@@ -105,7 +105,7 @@ void KeyedStoreGenericAssembler::BranchIfPrototypesHaveNonFastElements(
   Label loop_body(this, &var_map);
   Goto(&loop_body);
 
-  Bind(&loop_body);
+  BIND(&loop_body);
   {
     Node* map = var_map.value();
     Node* prototype = LoadMapPrototype(map);
@@ -148,7 +148,7 @@ void KeyedStoreGenericAssembler::TryRewriteElements(
   }
 
   // Check if the receiver has the default |holey_from_kind| map.
-  Bind(&check_holey_map);
+  BIND(&check_holey_map);
   {
     Node* holey_map = LoadContextElement(
         native_context, Context::ArrayMapIndex(holey_from_kind));
@@ -159,7 +159,7 @@ void KeyedStoreGenericAssembler::TryRewriteElements(
   }
 
   // Found a supported transition target map, perform the transition!
-  Bind(&perform_transition);
+  BIND(&perform_transition);
   {
     if (IsFastDoubleElementsKind(from_kind) !=
         IsFastDoubleElementsKind(to_kind)) {
@@ -199,7 +199,7 @@ void KeyedStoreGenericAssembler::TryChangeToHoleyMap(
   Node* native_context = LoadNativeContext(context);
   TryChangeToHoleyMapHelper(receiver, receiver_map, native_context, packed_kind,
                             holey_kind, &already_holey, bailout, bailout);
-  Bind(&already_holey);
+  BIND(&already_holey);
 }
 
 void KeyedStoreGenericAssembler::TryChangeToHoleyMapMulti(
@@ -219,11 +219,11 @@ void KeyedStoreGenericAssembler::TryChangeToHoleyMapMulti(
   TryChangeToHoleyMapHelper(receiver, receiver_map, native_context, packed_kind,
                             holey_kind, &already_holey, &check_other_kind,
                             bailout);
-  Bind(&check_other_kind);
+  BIND(&check_other_kind);
   TryChangeToHoleyMapHelper(receiver, receiver_map, native_context,
                             packed_kind_2, holey_kind_2, &already_holey,
                             bailout, bailout);
-  Bind(&already_holey);
+  BIND(&already_holey);
 }
 
 void KeyedStoreGenericAssembler::MaybeUpdateLengthAndReturn(
@@ -277,7 +277,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
       }
       BranchIfPrototypesHaveNonFastElements(receiver_map, slow,
                                             &hole_check_passed);
-      Bind(&hole_check_passed);
+      BIND(&hole_check_passed);
     }
 
     // Check if the value we're storing matches the elements_kind. Smis
@@ -294,7 +294,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
                           value);
       MaybeUpdateLengthAndReturn(receiver, intptr_index, value, update_length);
 
-      Bind(&non_smi_value);
+      BIND(&non_smi_value);
     }
 
     // Check if we already have object elements; just do the store if so.
@@ -312,7 +312,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
       Store(elements, offset, value);
       MaybeUpdateLengthAndReturn(receiver, intptr_index, value, update_length);
 
-      Bind(&must_transition);
+      BIND(&must_transition);
     }
 
     // Transition to the required ElementsKind.
@@ -321,7 +321,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
       Node* native_context = LoadNativeContext(context);
       Branch(WordEqual(LoadMap(value), LoadRoot(Heap::kHeapNumberMapRootIndex)),
              &transition_to_double, &transition_to_object);
-      Bind(&transition_to_double);
+      BIND(&transition_to_double);
       {
         // If we're adding holes at the end, always transition to a holey
         // elements kind, otherwise try to remain packed.
@@ -342,7 +342,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
                                    update_length);
       }
 
-      Bind(&transition_to_object);
+      BIND(&transition_to_object);
       {
         // If we're adding holes at the end, always transition to a holey
         // elements kind, otherwise try to remain packed.
@@ -360,7 +360,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
     }
   }
 
-  Bind(&check_double_elements);
+  BIND(&check_double_elements);
   Node* fixed_double_array_map = LoadRoot(Heap::kFixedDoubleArrayMapRootIndex);
   GotoIf(WordNotEqual(elements_map, fixed_double_array_map),
          &check_cow_elements);
@@ -379,11 +379,11 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
         LoadDoubleWithHoleCheck(elements, offset, &found_hole,
                                 MachineType::None());
         Goto(&hole_check_passed);
-        Bind(&found_hole);
+        BIND(&found_hole);
       }
       BranchIfPrototypesHaveNonFastElements(receiver_map, slow,
                                             &hole_check_passed);
-      Bind(&hole_check_passed);
+      BIND(&hole_check_passed);
     }
 
     // Try to store the value as a double.
@@ -402,7 +402,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
                           double_value);
       MaybeUpdateLengthAndReturn(receiver, intptr_index, value, update_length);
 
-      Bind(&non_number_value);
+      BIND(&non_number_value);
     }
 
     // Transition to object elements.
@@ -422,7 +422,7 @@ void KeyedStoreGenericAssembler::StoreElementWithCapacity(
     }
   }
 
-  Bind(&check_cow_elements);
+  BIND(&check_cow_elements);
   {
     // TODO(jkummerow): Use GrowElementsCapacity instead of bailing out.
     Goto(slow);
@@ -438,7 +438,7 @@ void KeyedStoreGenericAssembler::EmitGenericElementStore(
   Node* elements = LoadElements(receiver);
   Node* elements_kind = LoadMapElementsKind(receiver_map);
   Branch(IsFastElementsKind(elements_kind), &if_fast, &if_nonfast);
-  Bind(&if_fast);
+  BIND(&if_fast);
 
   Label if_array(this);
   GotoIf(Word32Equal(instance_type, Int32Constant(JS_ARRAY_TYPE)), &if_array);
@@ -446,7 +446,7 @@ void KeyedStoreGenericAssembler::EmitGenericElementStore(
     Node* capacity = SmiUntag(LoadFixedArrayBaseLength(elements));
     Branch(UintPtrLessThan(intptr_index, capacity), &if_in_bounds, &if_grow);
   }
-  Bind(&if_array);
+  BIND(&if_array);
   {
     Node* length = SmiUntag(LoadJSArrayLength(receiver));
     GotoIf(UintPtrLessThan(intptr_index, length), &if_in_bounds);
@@ -456,21 +456,21 @@ void KeyedStoreGenericAssembler::EmitGenericElementStore(
            &if_bump_length_with_gap);
   }
 
-  Bind(&if_in_bounds);
+  BIND(&if_in_bounds);
   {
     StoreElementWithCapacity(receiver, receiver_map, elements, elements_kind,
                              intptr_index, value, context, slow,
                              kDontChangeLength);
   }
 
-  Bind(&if_increment_length_by_one);
+  BIND(&if_increment_length_by_one);
   {
     StoreElementWithCapacity(receiver, receiver_map, elements, elements_kind,
                              intptr_index, value, context, slow,
                              kIncrementLengthByOne);
   }
 
-  Bind(&if_bump_length_with_gap);
+  BIND(&if_bump_length_with_gap);
   {
     StoreElementWithCapacity(receiver, receiver_map, elements, elements_kind,
                              intptr_index, value, context, slow,
@@ -481,7 +481,7 @@ void KeyedStoreGenericAssembler::EmitGenericElementStore(
   // an ElementsKind transition might be necessary.
   // The index can also be negative at this point! Jump to the runtime in that
   // case to convert it to a named property.
-  Bind(&if_grow);
+  BIND(&if_grow);
   {
     Comment("Grow backing store");
     // TODO(jkummerow): Support inline backing store growth.
@@ -489,7 +489,7 @@ void KeyedStoreGenericAssembler::EmitGenericElementStore(
   }
 
   // Any ElementsKind > LAST_FAST_ELEMENTS_KIND jumps here for further dispatch.
-  Bind(&if_nonfast);
+  BIND(&if_nonfast);
   {
     STATIC_ASSERT(LAST_ELEMENTS_KIND == LAST_FIXED_TYPED_ARRAY_ELEMENTS_KIND);
     GotoIf(Int32GreaterThanOrEqual(
@@ -501,14 +501,14 @@ void KeyedStoreGenericAssembler::EmitGenericElementStore(
     Goto(slow);
   }
 
-  Bind(&if_dictionary);
+  BIND(&if_dictionary);
   {
     Comment("Dictionary");
     // TODO(jkummerow): Support storing to dictionary elements.
     Goto(slow);
   }
 
-  Bind(&if_typed_array);
+  BIND(&if_typed_array);
   {
     Comment("Typed array");
     // TODO(jkummerow): Support typed arrays.
@@ -529,7 +529,7 @@ void KeyedStoreGenericAssembler::LookupPropertyOnPrototypeChain(
   Variable* merged_variables[] = {&var_holder, &var_holder_map};
   Label loop(this, arraysize(merged_variables), merged_variables);
   Goto(&loop);
-  Bind(&loop);
+  BIND(&loop);
   {
     Node* holder = var_holder.value();
     Node* holder_map = var_holder_map.value();
@@ -542,7 +542,7 @@ void KeyedStoreGenericAssembler::LookupPropertyOnPrototypeChain(
       TryLookupProperty(holder, holder_map, instance_type, name, &found_fast,
                         &found_dict, &found_global, &var_meta_storage,
                         &var_entry, &next_proto, bailout);
-      Bind(&found_fast);
+      BIND(&found_fast);
       {
         Node* descriptors = var_meta_storage.value();
         Node* name_index = var_entry.value();
@@ -559,7 +559,7 @@ void KeyedStoreGenericAssembler::LookupPropertyOnPrototypeChain(
         Goto(accessor);
       }
 
-      Bind(&found_dict);
+      BIND(&found_dict);
       {
         Node* dictionary = var_meta_storage.value();
         Node* entry = var_entry.value();
@@ -574,7 +574,7 @@ void KeyedStoreGenericAssembler::LookupPropertyOnPrototypeChain(
         Goto(accessor);
       }
 
-      Bind(&found_global);
+      BIND(&found_global);
       {
         Node* dictionary = var_meta_storage.value();
         Node* entry = var_entry.value();
@@ -594,7 +594,7 @@ void KeyedStoreGenericAssembler::LookupPropertyOnPrototypeChain(
       }
     }
 
-    Bind(&next_proto);
+    BIND(&next_proto);
     // Bailout if it can be an integer indexed exotic case.
     GotoIf(Word32Equal(instance_type, Int32Constant(JS_TYPED_ARRAY_TYPE)),
            bailout);
@@ -604,7 +604,7 @@ void KeyedStoreGenericAssembler::LookupPropertyOnPrototypeChain(
     var_holder_map.Bind(LoadMap(proto));
     Goto(&loop);
   }
-  Bind(&ok_to_write);
+  BIND(&ok_to_write);
 }
 
 void KeyedStoreGenericAssembler::CheckFieldType(Node* descriptors,
@@ -628,10 +628,10 @@ void KeyedStoreGenericAssembler::CheckFieldType(Node* descriptors,
                                Int32Constant(Representation::kTagged)));
   Goto(&all_fine);
 
-  Bind(&r_smi);
+  BIND(&r_smi);
   { Branch(TaggedIsSmi(value), &all_fine, bailout); }
 
-  Bind(&r_double);
+  BIND(&r_double);
   {
     GotoIf(TaggedIsSmi(value), &all_fine);
     Node* value_map = LoadMap(value);
@@ -643,7 +643,7 @@ void KeyedStoreGenericAssembler::CheckFieldType(Node* descriptors,
     Branch(IsHeapNumberMap(value_map), &all_fine, bailout);
   }
 
-  Bind(&r_heapobject);
+  BIND(&r_heapobject);
   {
     GotoIf(TaggedIsSmi(value), bailout);
     Node* field_type =
@@ -662,7 +662,7 @@ void KeyedStoreGenericAssembler::CheckFieldType(Node* descriptors,
     Branch(WordEqual(LoadMap(value), field_type), &all_fine, bailout);
   }
 
-  Bind(&all_fine);
+  BIND(&all_fine);
 }
 
 void KeyedStoreGenericAssembler::OverwriteExistingFastProperty(
@@ -695,7 +695,7 @@ void KeyedStoreGenericAssembler::OverwriteExistingFastProperty(
   Branch(UintPtrLessThan(field_index, inobject_properties), &inobject,
          &backing_store);
 
-  Bind(&inobject);
+  BIND(&inobject);
   {
     Node* field_offset =
         IntPtrMul(IntPtrSub(LoadMapInstanceSize(object_map),
@@ -704,7 +704,7 @@ void KeyedStoreGenericAssembler::OverwriteExistingFastProperty(
     Label tagged_rep(this), double_rep(this);
     Branch(Word32Equal(representation, Int32Constant(Representation::kDouble)),
            &double_rep, &tagged_rep);
-    Bind(&double_rep);
+    BIND(&double_rep);
     {
       Node* double_value = ChangeNumberToFloat64(value);
       if (FLAG_unbox_double_fields) {
@@ -717,20 +717,20 @@ void KeyedStoreGenericAssembler::OverwriteExistingFastProperty(
       Goto(&done);
     }
 
-    Bind(&tagged_rep);
+    BIND(&tagged_rep);
     {
       StoreObjectField(object, field_offset, value);
       Goto(&done);
     }
   }
 
-  Bind(&backing_store);
+  BIND(&backing_store);
   {
     Node* backing_store_index = IntPtrSub(field_index, inobject_properties);
     Label tagged_rep(this), double_rep(this);
     Branch(Word32Equal(representation, Int32Constant(Representation::kDouble)),
            &double_rep, &tagged_rep);
-    Bind(&double_rep);
+    BIND(&double_rep);
     {
       Node* double_value = ChangeNumberToFloat64(value);
       Node* mutable_heap_number =
@@ -738,13 +738,13 @@ void KeyedStoreGenericAssembler::OverwriteExistingFastProperty(
       StoreHeapNumberValue(mutable_heap_number, double_value);
       Goto(&done);
     }
-    Bind(&tagged_rep);
+    BIND(&tagged_rep);
     {
       StoreFixedArrayElement(properties, backing_store_index, value);
       Goto(&done);
     }
   }
-  Bind(&done);
+  BIND(&done);
 }
 
 void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
@@ -759,7 +759,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
   Branch(WordEqual(properties_map, LoadRoot(Heap::kHashTableMapRootIndex)),
          &dictionary_properties, &fast_properties);
 
-  Bind(&fast_properties);
+  BIND(&fast_properties);
   {
     Comment("fast property store");
     Node* bitfield3 = LoadMapBitField3(receiver_map);
@@ -771,7 +771,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
     DescriptorLookup(p->name, descriptors, bitfield3, &descriptor_found,
                      &var_name_index, notfound);
 
-    Bind(&descriptor_found);
+    BIND(&descriptor_found);
     {
       Node* name_index = var_name_index.value();
       Node* details =
@@ -787,7 +787,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
       var_accessor_holder.Bind(receiver);
       Goto(&accessor);
 
-      Bind(&data_property);
+      BIND(&data_property);
       {
         OverwriteExistingFastProperty(receiver, receiver_map, properties,
                                       descriptors, name_index, details,
@@ -797,7 +797,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
     }
   }
 
-  Bind(&dictionary_properties);
+  BIND(&dictionary_properties);
   {
     Comment("dictionary property store");
     // We checked for LAST_CUSTOM_ELEMENTS_RECEIVER before, which rules out
@@ -807,7 +807,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
     Label dictionary_found(this, &var_name_index), not_found(this);
     NameDictionaryLookup<NameDictionary>(properties, p->name, &dictionary_found,
                                          &var_name_index, &not_found);
-    Bind(&dictionary_found);
+    BIND(&dictionary_found);
     {
       Label overwrite(this);
       Node* details = LoadDetailsByKeyIndex<NameDictionary>(
@@ -820,7 +820,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
       var_accessor_holder.Bind(receiver);
       Goto(&accessor);
 
-      Bind(&overwrite);
+      BIND(&overwrite);
       {
         StoreValueByKeyIndex<NameDictionary>(properties, var_name_index.value(),
                                              p->value);
@@ -828,7 +828,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
       }
     }
 
-    Bind(&not_found);
+    BIND(&not_found);
     {
       Label extensible(this);
       GotoIf(IsPrivateSymbol(p->name), &extensible);
@@ -836,7 +836,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
       Branch(IsSetWord32(bitfield2, 1 << Map::kIsExtensible), &extensible,
              slow);
 
-      Bind(&extensible);
+      BIND(&extensible);
       LookupPropertyOnPrototypeChain(receiver_map, p->name, &accessor,
                                      &var_accessor_pair, &var_accessor_holder,
                                      &readonly, slow);
@@ -845,7 +845,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
     }
   }
 
-  Bind(&accessor);
+  BIND(&accessor);
   {
     Label not_callable(this);
     Node* accessor_pair = var_accessor_pair.value();
@@ -861,7 +861,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
     CallJS(callable, p->context, setter, receiver, p->value);
     Return(p->value);
 
-    Bind(&not_callable);
+    BIND(&not_callable);
     {
       if (language_mode == STRICT) {
         Node* message =
@@ -875,7 +875,7 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
     }
   }
 
-  Bind(&readonly);
+  BIND(&readonly);
   {
     if (language_mode == STRICT) {
       Node* message =
@@ -890,18 +890,18 @@ void KeyedStoreGenericAssembler::EmitGenericPropertyStore(
   }
 
   if (use_stub_cache == kUseStubCache) {
-    Bind(&stub_cache);
+    BIND(&stub_cache);
     Comment("stub cache probe");
     Variable var_handler(this, MachineRepresentation::kTagged);
     Label found_handler(this, &var_handler), stub_cache_miss(this);
     TryProbeStubCache(isolate()->store_stub_cache(), receiver, p->name,
                       &found_handler, &var_handler, &stub_cache_miss);
-    Bind(&found_handler);
+    BIND(&found_handler);
     {
       Comment("KeyedStoreGeneric found handler");
       HandleStoreICHandlerCase(p, var_handler.value(), &stub_cache_miss);
     }
-    Bind(&stub_cache_miss);
+    BIND(&stub_cache_miss);
     {
       Comment("KeyedStoreGeneric_miss");
       TailCallRuntime(Runtime::kKeyedStoreIC_Miss, p->context, p->value,
@@ -936,14 +936,14 @@ void KeyedStoreGenericAssembler::KeyedStoreGeneric(LanguageMode language_mode) {
 
   TryToName(name, &if_index, &var_index, &if_unique_name, &var_unique, &slow);
 
-  Bind(&if_index);
+  BIND(&if_index);
   {
     Comment("integer index");
     EmitGenericElementStore(receiver, receiver_map, instance_type,
                             var_index.value(), value, context, &slow);
   }
 
-  Bind(&if_unique_name);
+  BIND(&if_unique_name);
   {
     Comment("key is unique name");
     StoreICParameters p(context, receiver, var_unique.value(), value, slot,
@@ -951,7 +951,7 @@ void KeyedStoreGenericAssembler::KeyedStoreGeneric(LanguageMode language_mode) {
     EmitGenericPropertyStore(receiver, receiver_map, &p, &slow, language_mode);
   }
 
-  Bind(&slow);
+  BIND(&slow);
   {
     Comment("KeyedStoreGeneric_slow");
     TailCallRuntime(Runtime::kSetProperty, context, receiver, name, value,
@@ -990,7 +990,7 @@ void KeyedStoreGenericAssembler::StoreIC_Uninitialized(
   EmitGenericPropertyStore(receiver, receiver_map, &p, &miss, language_mode,
                            kDontUseStubCache);
 
-  Bind(&miss);
+  BIND(&miss);
   {
     // Undo the optimistic state transition.
     StoreFixedArrayElement(vector, slot,
-- 
2.35.1


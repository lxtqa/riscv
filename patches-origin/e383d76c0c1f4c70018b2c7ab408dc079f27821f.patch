From e383d76c0c1f4c70018b2c7ab408dc079f27821f Mon Sep 17 00:00:00 2001
From: Jakob Kummerow <jkummerow@chromium.org>
Date: Wed, 10 Mar 2021 16:30:04 +0100
Subject: [PATCH] [build] Support Linux-arm64 builds hosts

Building arm64 binaries on arm64 hosts works as long as you set
the correct options in args.gn. This patch teaches gm.py to do
that.
Building 32-bit arm binaries on arm64 hosts requires an extra
definition in snapshot_toolchain.gni (as well as some system
setup to support running 32-bit binaries).

Change-Id: I66c1f8f51932e2f5425033ef09181c31ea5d633e
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2743889
Commit-Queue: Jakob Kummerow <jkummerow@chromium.org>
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Reviewed-by: Michael Achenbach <machenbach@chromium.org>
Cr-Commit-Position: refs/heads/master@{#73323}
---
 gni/snapshot_toolchain.gni |  4 ++++
 tools/dev/gm.py            | 46 ++++++++++++++++++++++++++------------
 2 files changed, 36 insertions(+), 14 deletions(-)

diff --git a/gni/snapshot_toolchain.gni b/gni/snapshot_toolchain.gni
index 53963a048bf..e855b88e430 100644
--- a/gni/snapshot_toolchain.gni
+++ b/gni/snapshot_toolchain.gni
@@ -60,6 +60,10 @@ if (v8_snapshot_toolchain == "") {
     # binaries built for the same OS, so build the snapshot with the current
     # toolchain here, too.
     v8_snapshot_toolchain = current_toolchain
+  } else if (current_os == host_os && host_cpu == "arm64" &&
+             current_cpu == "arm") {
+    # Trying to compile 32-bit arm on arm64. Good luck!
+    v8_snapshot_toolchain = current_toolchain
   } else if (host_cpu == "x64" &&
              (v8_current_cpu == "mips" || v8_current_cpu == "mips64")) {
     # We don't support snapshot generation for big-endian targets,
diff --git a/tools/dev/gm.py b/tools/dev/gm.py
index 17b62c7f6f1..a5200ccf6ee 100755
--- a/tools/dev/gm.py
+++ b/tools/dev/gm.py
@@ -241,33 +241,51 @@ class Config(object):
     self.tests.update(tests)
 
   def GetTargetCpu(self):
-    if self.arch == "android_arm": return "target_cpu = \"arm\""
-    if self.arch == "android_arm64": return "target_cpu = \"arm64\""
     cpu = "x86"
-    if "64" in self.arch or self.arch == "s390x":
+    if self.arch == "android_arm":
+      cpu = "arm"
+    elif self.arch == "android_arm64":
+      cpu = "arm64"
+    elif self.arch == "arm64" and os.uname().machine == "aarch64":
+      # arm64 build host:
+      cpu = "arm64"
+    elif self.arch == "arm" and os.uname().machine == "aarch64":
+      cpu = "arm"
+    elif "64" in self.arch or self.arch == "s390x":
+      # Native x64 or simulator build.
       cpu = "x64"
-    return "target_cpu = \"%s\"" % cpu
+    return ["target_cpu = \"%s\"" % cpu]
 
   def GetV8TargetCpu(self):
-    if self.arch == "android_arm": return "\nv8_target_cpu = \"arm\""
-    if self.arch == "android_arm64": return "\nv8_target_cpu = \"arm64\""
-    if self.arch in ("arm", "arm64", "mipsel", "mips64el", "ppc", "ppc64",
-                     "riscv64", "s390", "s390x"):
-      return "\nv8_target_cpu = \"%s\"" % self.arch
-    return ""
+    if self.arch == "android_arm":
+      v8_cpu = "arm"
+    elif self.arch == "android_arm64":
+      v8_cpu = "arm64"
+    elif self.arch in ("arm", "arm64", "mipsel", "mips64el", "ppc", "ppc64",
+                       "riscv64", "s390", "s390x"):
+      v8_cpu = self.arch
+    else:
+      return []
+    return ["v8_target_cpu = \"%s\"" % v8_cpu]
 
   def GetTargetOS(self):
     if self.arch in ("android_arm", "android_arm64"):
-      return "\ntarget_os = \"android\""
-    return ""
+      return ["target_os = \"android\""]
+    return []
+
+  def GetSpecialCompiler(self):
+    if os.uname().machine == "aarch64":
+      # We have no prebuilt Clang for arm64. Use the system Clang instead.
+      return ["clang_base_path = \"/usr\"", "clang_use_chrome_plugins = false"]
+    return []
 
   def GetGnArgs(self):
     # Use only substring before first '-' as the actual mode
     mode = re.match("([^-]+)", self.mode).group(1)
     template = ARGS_TEMPLATES[mode]
     arch_specific = (self.GetTargetCpu() + self.GetV8TargetCpu() +
-                     self.GetTargetOS())
-    return template % arch_specific
+                     self.GetTargetOS() + self.GetSpecialCompiler())
+    return template % "\n".join(arch_specific)
 
   def Build(self):
     path = GetPath(self.arch, self.mode)
-- 
2.35.1


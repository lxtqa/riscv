From f4426bce95788f0cf140a802afcf528eb982ec04 Mon Sep 17 00:00:00 2001
From: Igor Sheludko <ishell@chromium.org>
Date: Thu, 6 Apr 2023 11:34:02 +0200
Subject: [PATCH] [isolate] Combine is_profiling_ and debug_execution_mode_
 fields

... into one bit field.

This is a step towards supporting side-effect checking in
CallApiGetter and CallApiCallback builtins which is a step towards
using these builtins more widely, for example in HandleApiCall.

Drive-by: extend base::Flags<> to support atomic storage types.

Bug: v8:13825
Change-Id: Icb78a301914207b64c26f443ab5ded7a5d8b46a9
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4403219
Reviewed-by: Jakob Linke <jgruber@chromium.org>
Commit-Queue: Igor Sheludko <ishell@chromium.org>
Cr-Commit-Position: refs/heads/main@{#86963}
---
 src/api/api-arguments-inl.h              |  6 ++---
 src/api/api.cc                           | 10 +++++++-
 src/base/flags.h                         | 28 +++++++++++++++--------
 src/builtins/arm/builtins-arm.cc         | 12 +++++-----
 src/builtins/arm64/builtins-arm64.cc     | 12 +++++-----
 src/builtins/builtins-array.cc           |  2 +-
 src/builtins/ia32/builtins-ia32.cc       | 12 +++++-----
 src/builtins/loong64/builtins-loong64.cc | 12 +++++-----
 src/builtins/mips64/builtins-mips64.cc   | 12 +++++-----
 src/builtins/ppc/builtins-ppc.cc         | 12 +++++-----
 src/builtins/riscv/builtins-riscv.cc     | 14 +++++++-----
 src/builtins/s390/builtins-s390.cc       | 12 +++++-----
 src/builtins/x64/builtins-x64.cc         | 12 +++++-----
 src/codegen/code-stub-assembler.cc       | 15 ++++++------
 src/codegen/external-reference.cc        |  9 ++------
 src/codegen/external-reference.h         |  3 +--
 src/common/globals.h                     | 11 +++++++++
 src/debug/debug.cc                       | 10 ++++----
 src/execution/execution.cc               |  2 +-
 src/execution/isolate-data.h             | 12 +++++-----
 src/execution/isolate.h                  | 29 +++++++++++++++++-------
 21 files changed, 142 insertions(+), 105 deletions(-)

diff --git a/src/api/api-arguments-inl.h b/src/api/api-arguments-inl.h
index 80b5d00cd8b..fbb1625a4e7 100644
--- a/src/api/api-arguments-inl.h
+++ b/src/api/api-arguments-inl.h
@@ -65,7 +65,7 @@ inline JSReceiver FunctionCallbackArguments::holder() const {
 
 #define PREPARE_CALLBACK_INFO_ACCESSOR(ISOLATE, F, API_RETURN_TYPE,            \
                                        ACCESSOR_INFO, RECEIVER, ACCESSOR_KIND) \
-  if (ISOLATE->debug_execution_mode() == DebugInfo::kSideEffects &&            \
+  if (ISOLATE->should_check_side_effects() &&                                  \
       !ISOLATE->debug()->PerformSideEffectCheckForAccessor(                    \
           ACCESSOR_INFO, RECEIVER, ACCESSOR_KIND)) {                           \
     return {};                                                                 \
@@ -75,7 +75,7 @@ inline JSReceiver FunctionCallbackArguments::holder() const {
 
 #define PREPARE_CALLBACK_INFO_INTERCEPTOR(ISOLATE, F, API_RETURN_TYPE, \
                                           INTERCEPTOR_INFO)            \
-  if (ISOLATE->debug_execution_mode() == DebugInfo::kSideEffects &&    \
+  if (ISOLATE->should_check_side_effects() &&                          \
       !ISOLATE->debug()->PerformSideEffectCheckForInterceptor(         \
           INTERCEPTOR_INFO)) {                                         \
     return {};                                                         \
@@ -89,7 +89,7 @@ Handle<Object> FunctionCallbackArguments::Call(CallHandlerInfo handler) {
   v8::FunctionCallback f =
       reinterpret_cast<v8::FunctionCallback>(handler.callback());
   Handle<Object> receiver_check_unsupported;
-  if (isolate->debug_execution_mode() == DebugInfo::kSideEffects &&
+  if (isolate->should_check_side_effects() &&
       !isolate->debug()->PerformSideEffectCheckForCallback(
           handle(handler, isolate))) {
     return {};
diff --git a/src/api/api.cc b/src/api/api.cc
index f8f5b1c7b3d..775840c88f6 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -5486,7 +5486,7 @@ MaybeLocal<Object> Function::NewInstanceWithSideEffectType(
   static_assert(sizeof(v8::Local<v8::Value>) == sizeof(i::Handle<i::Object>));
   bool should_set_has_no_side_effect =
       side_effect_type == SideEffectType::kHasNoSideEffect &&
-      i_isolate->debug_execution_mode() == i::DebugInfo::kSideEffects;
+      i_isolate->should_check_side_effects();
   if (should_set_has_no_side_effect) {
     CHECK(self->IsJSFunction() &&
           i::JSFunction::cast(*self).shared().IsApiFunction());
@@ -11329,6 +11329,10 @@ void InvokeAccessorGetterCallback(
   // Leaving JavaScript.
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());
   RCS_SCOPE(i_isolate, RuntimeCallCounterId::kAccessorGetterCallback);
+
+  // TODO(v8:13825): perform side effect checks if necessary once
+  // AccessorInfo/InterceptorInfo is passed here.
+
   Address getter_address = reinterpret_cast<Address>(getter);
   ExternalCallbackScope call_scope(i_isolate, getter_address);
   getter(property, info);
@@ -11338,6 +11342,10 @@ void InvokeFunctionCallback(const v8::FunctionCallbackInfo<v8::Value>& info,
                             v8::FunctionCallback callback) {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(info.GetIsolate());
   RCS_SCOPE(i_isolate, RuntimeCallCounterId::kFunctionCallback);
+
+  // TODO(v8:13825): perform side effect checks if necessary once
+  // CallHandlerInfo is passed here.
+
   Address callback_address = reinterpret_cast<Address>(callback);
   ExternalCallbackScope call_scope(i_isolate, callback_address);
   callback(info);
diff --git a/src/base/flags.h b/src/base/flags.h
index 2a36ca77e82..ab36d617cfc 100644
--- a/src/base/flags.h
+++ b/src/base/flags.h
@@ -13,30 +13,32 @@ namespace v8 {
 namespace base {
 
 // The Flags class provides a type-safe way of storing OR-combinations of enum
-// values. The Flags<T, S> class is a template class, where T is an enum type,
-// and S is the underlying storage type (usually int).
+// values.
 //
 // The traditional C++ approach for storing OR-combinations of enum values is to
 // use an int or unsigned int variable. The inconvenience with this approach is
 // that there's no type checking at all; any enum value can be OR'd with any
 // other enum value and passed on to a function that takes an int or unsigned
 // int.
-template <typename T, typename S = int>
+template <typename EnumT, typename BitfieldT = int,
+          typename BitfieldStorageT = BitfieldT>
 class Flags final {
  public:
-  using flag_type = T;
-  using mask_type = S;
+  static_assert(sizeof(BitfieldStorageT) >= sizeof(BitfieldT));
+  using flag_type = EnumT;
+  using mask_type = BitfieldT;
 
   constexpr Flags() : mask_(0) {}
   constexpr Flags(flag_type flag)  // NOLINT(runtime/explicit)
-      : mask_(static_cast<S>(flag)) {}
-  constexpr explicit Flags(mask_type mask) : mask_(static_cast<S>(mask)) {}
+      : mask_(static_cast<mask_type>(flag)) {}
+  constexpr explicit Flags(mask_type mask)
+      : mask_(static_cast<mask_type>(mask)) {}
 
   constexpr bool operator==(flag_type flag) const {
-    return mask_ == static_cast<S>(flag);
+    return mask_ == static_cast<mask_type>(flag);
   }
   constexpr bool operator!=(flag_type flag) const {
-    return mask_ != static_cast<S>(flag);
+    return mask_ != static_cast<mask_type>(flag);
   }
 
   Flags& operator&=(const Flags& flags) {
@@ -66,6 +68,12 @@ class Flags final {
   Flags& operator|=(flag_type flag) { return operator|=(Flags(flag)); }
   Flags& operator^=(flag_type flag) { return operator^=(Flags(flag)); }
 
+  // Sets or clears given flag.
+  Flags& set(flag_type flag, bool value) {
+    if (value) return operator|=(Flags(flag));
+    return operator&=(~Flags(flag));
+  }
+
   constexpr Flags operator&(flag_type flag) const {
     return operator&(Flags(flag));
   }
@@ -86,7 +94,7 @@ class Flags final {
   friend size_t hash_value(const Flags& flags) { return flags.mask_; }
 
  private:
-  mask_type mask_;
+  BitfieldStorageT mask_;
 };
 
 #define DEFINE_OPERATORS_FOR_FLAGS(Type)                                 \
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index 52b5451178d..23e5115e8e5 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -3020,18 +3020,18 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     __ str(r6, MemOperand(r9, kLevelOffset));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ ldrb(r8, __ ExternalReferenceAsOperand(
-                  ExternalReference::is_profiling_address(isolate), r8));
+                  ExternalReference::execution_mode_address(isolate), r8));
   __ cmp(r8, Operand(0));
-  __ b(ne, &profiler_enabled);
+  __ b(ne, &profiler_or_side_effects_check_enabled);
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ Move(r8, ExternalReference::address_of_runtime_stats_flag());
   __ ldr(r8, MemOperand(r8, 0));
   __ cmp(r8, Operand(0));
-  __ b(ne, &profiler_enabled);
+  __ b(ne, &profiler_or_side_effects_check_enabled);
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -3106,7 +3106,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
 
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via thunk wrapper.");
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual callback.
     __ Move(r3, function_address);
     __ Move(r8, thunk_ref);
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index 68c2f261e43..68253e03427 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -5078,16 +5078,16 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     __ Str(level_reg, MemOperand(handle_scope_base, kLevelOffset));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ Ldrb(w10, __ ExternalReferenceAsOperand(
-                   ExternalReference::is_profiling_address(isolate), x10));
-  __ Cbnz(w10, &profiler_enabled);
+                   ExternalReference::execution_mode_address(isolate), x10));
+  __ Cbnz(w10, &profiler_or_side_effects_check_enabled);
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ Mov(x10, ExternalReference::address_of_runtime_stats_flag());
   __ Ldrsw(w10, MemOperand(x10));
-  __ Cbnz(w10, &profiler_enabled);
+  __ Cbnz(w10, &profiler_or_side_effects_check_enabled);
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -5174,7 +5174,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
 
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via thunk wrapper.");
-    __ Bind(&profiler_enabled);
+    __ Bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual callback.
     __ Mov(x3, function_address);
     __ Mov(x10, thunk_ref);
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index 7738f0ef90a..b9288c7409a 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -264,7 +264,7 @@ V8_WARN_UNUSED_RESULT Maybe<bool> TryFastArrayFill(
 
 BUILTIN(ArrayPrototypeFill) {
   HandleScope scope(isolate);
-  if (isolate->debug_execution_mode() == DebugInfo::kSideEffects) {
+  if (isolate->should_check_side_effects()) {
     if (!isolate->debug()->PerformSideEffectCheckForObject(args.receiver())) {
       return ReadOnlyRoots(isolate).exception();
     }
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 259e6fc09ab..96f5eb0042e 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -3313,17 +3313,17 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     __ mov(edi, __ ExternalReferenceAsOperand(limit_address, edi));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ cmpb(__ ExternalReferenceAsOperand(
-              ExternalReference::is_profiling_address(isolate), eax),
+              ExternalReference::execution_mode_address(isolate), eax),
           Immediate(0));
-  __ j(not_zero, &profiler_enabled);
+  __ j(not_zero, &profiler_or_side_effects_check_enabled);
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ Move(eax, Immediate(ExternalReference::address_of_runtime_stats_flag()));
   __ cmp(Operand(eax, 0), Immediate(0));
-  __ j(not_zero, &profiler_enabled);
+  __ j(not_zero, &profiler_or_side_effects_check_enabled);
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -3396,7 +3396,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
 
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via thunk wrapper.");
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual getter function.
     __ mov(thunk_last_arg, function_address);
     __ Move(eax, Immediate(thunk_ref));
diff --git a/src/builtins/loong64/builtins-loong64.cc b/src/builtins/loong64/builtins-loong64.cc
index e981f490b84..b45d362d6ef 100644
--- a/src/builtins/loong64/builtins-loong64.cc
+++ b/src/builtins/loong64/builtins-loong64.cc
@@ -3047,16 +3047,16 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     __ St_w(s2, MemOperand(s5, kLevelOffset));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ Ld_b(t7, __ ExternalReferenceAsOperand(
-                  ExternalReference::is_profiling_address(isolate), t7));
-  __ Branch(&profiler_enabled, ne, t7, Operand(zero_reg));
+                  ExternalReference::execution_mode_address(isolate), t7));
+  __ Branch(&profiler_or_side_effects_check_enabled, ne, t7, Operand(zero_reg));
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ li(t7, ExternalReference::address_of_runtime_stats_flag());
   __ Ld_w(t7, MemOperand(t7, 0));
-  __ Branch(&profiler_enabled, ne, t7, Operand(zero_reg));
+  __ Branch(&profiler_or_side_effects_check_enabled, ne, t7, Operand(zero_reg));
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -3131,7 +3131,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
 
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via thunk wrapper.");
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual callback.
     __ li(t7, thunk_ref);
     __ StoreReturnAddressAndCall(t7);
diff --git a/src/builtins/mips64/builtins-mips64.cc b/src/builtins/mips64/builtins-mips64.cc
index e69fb89e8d9..3c8ef7f9f93 100644
--- a/src/builtins/mips64/builtins-mips64.cc
+++ b/src/builtins/mips64/builtins-mips64.cc
@@ -3084,16 +3084,16 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     __ Sw(s2, MemOperand(s5, kLevelOffset));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ Lb(t9, __ ExternalReferenceAsOperand(
-                ExternalReference::is_profiling_address(isolate), t9));
-  __ Branch(&profiler_enabled, ne, t9, Operand(zero_reg));
+                ExternalReference::execution_mode_address(isolate), t9));
+  __ Branch(&profiler_or_side_effects_check_enabled, ne, t9, Operand(zero_reg));
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ li(t9, ExternalReference::address_of_runtime_stats_flag());
   __ Lw(t9, MemOperand(t9, 0));
-  __ Branch(&profiler_enabled, ne, t9, Operand(zero_reg));
+  __ Branch(&profiler_or_side_effects_check_enabled, ne, t9, Operand(zero_reg));
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -3169,7 +3169,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
 
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via thunk wrapper.");
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual callback.
     __ li(t9, thunk_ref);
     __ StoreReturnAddressAndCall(t9);
diff --git a/src/builtins/ppc/builtins-ppc.cc b/src/builtins/ppc/builtins-ppc.cc
index 84cc9acc995..fa182fbe9b9 100644
--- a/src/builtins/ppc/builtins-ppc.cc
+++ b/src/builtins/ppc/builtins-ppc.cc
@@ -3301,19 +3301,19 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,
     __ stw(r16, MemOperand(r17, kLevelOffset));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ lbz(scratch,
          __ ExternalReferenceAsOperand(
-             ExternalReference::is_profiling_address(isolate), scratch));
+             ExternalReference::execution_mode_address(isolate), scratch));
   __ cmpi(scratch, Operand::Zero());
-  __ bne(&profiler_enabled);
+  __ bne(&profiler_or_side_effects_check_enabled);
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ Move(scratch, ExternalReference::address_of_runtime_stats_flag());
   __ lwz(scratch, MemOperand(scratch, 0));
   __ cmpi(scratch, Operand::Zero());
-  __ bne(&profiler_enabled);
+  __ bne(&profiler_or_side_effects_check_enabled);
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -3387,7 +3387,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,
 
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via the thunk.");
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual callback.
     __ Move(r6, function_address);
     __ Move(ip, thunk_ref);
diff --git a/src/builtins/riscv/builtins-riscv.cc b/src/builtins/riscv/builtins-riscv.cc
index c6dde48d5b8..67814e7284c 100644
--- a/src/builtins/riscv/builtins-riscv.cc
+++ b/src/builtins/riscv/builtins-riscv.cc
@@ -3119,7 +3119,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
 
   DCHECK(function_address == a1 || function_address == a2);
 
-  Label profiler_enabled, done_api_call;
+  Label profiler_or_side_effects_check_enabled, done_api_call;
   {
     UseScratchRegisterScope temp(masm);
     Register scratch = temp.Acquire();
@@ -3133,16 +3133,18 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
       __ Add32(s2, s2, Operand(1));
       __ Sw(s2, MemOperand(s5, kLevelOffset));
     }
-    __ RecordComment("Check if profiler is enabled");
+    __ RecordComment("Check if profiler or side effects check is enabled");
     __ Lb(scratch,
           __ ExternalReferenceAsOperand(
-              ExternalReference::is_profiling_address(isolate), scratch));
-    __ Branch(&profiler_enabled, ne, scratch, Operand(zero_reg));
+              ExternalReference::execution_mode_address(isolate), scratch));
+    __ Branch(&profiler_or_side_effects_check_enabled, ne, scratch,
+              Operand(zero_reg));
 #ifdef V8_RUNTIME_CALL_STATS
     __ RecordComment("Check if RCS is enabled");
     __ li(scratch, ExternalReference::address_of_runtime_stats_flag());
     __ Lw(scratch, MemOperand(scratch, 0));
-    __ Branch(&profiler_enabled, ne, scratch, Operand(zero_reg));
+    __ Branch(&profiler_or_side_effects_check_enabled, ne, scratch,
+              Operand(zero_reg));
 #endif  // V8_RUNTIME_CALL_STATS
 
     // Call the api function directly.
@@ -3210,7 +3212,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     UseScratchRegisterScope temp(masm);
     Register scratch = temp.Acquire();
     // Call the api function via thunk wrapper.
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual callback.
     __ li(scratch, thunk_ref);
     __ StoreReturnAddressAndCall(scratch);
diff --git a/src/builtins/s390/builtins-s390.cc b/src/builtins/s390/builtins-s390.cc
index 4e0ee24e79f..9263552d1a8 100644
--- a/src/builtins/s390/builtins-s390.cc
+++ b/src/builtins/s390/builtins-s390.cc
@@ -3276,19 +3276,19 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,
     __ StoreU32(r8, MemOperand(r9, kLevelOffset));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ LoadU8(scratch,
             __ ExternalReferenceAsOperand(
-                ExternalReference::is_profiling_address(isolate), scratch));
+                ExternalReference::execution_mode_address(isolate), scratch));
   __ CmpS64(scratch, Operand::Zero());
-  __ bne(&profiler_enabled, Label::kNear);
+  __ bne(&profiler_or_side_effects_check_enabled, Label::kNear);
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ Move(scratch, ExternalReference::address_of_runtime_stats_flag());
   __ LoadU32(scratch, MemOperand(scratch, 0));
   __ CmpS64(scratch, Operand::Zero());
-  __ bne(&profiler_enabled, Label::kNear);
+  __ bne(&profiler_or_side_effects_check_enabled, Label::kNear);
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -3362,7 +3362,7 @@ static void CallApiFunctionAndReturn(MacroAssembler* masm,
 
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via thunk wrapper.");
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Additional parameter is the address of the actual callback.
     __ Move(r5, function_address);
     __ Move(ip, thunk_ref);
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index c617a1f78a6..c72238b18bf 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -4622,17 +4622,17 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     __ addl(Operand(base_reg, kLevelOffset), Immediate(1));
   }
 
-  Label profiler_enabled, done_api_call;
-  __ RecordComment("Check if profiler is enabled");
+  Label profiler_or_side_effects_check_enabled, done_api_call;
+  __ RecordComment("Check if profiler or side effects check is enabled");
   __ cmpb(__ ExternalReferenceAsOperand(
-              ExternalReference::is_profiling_address(isolate), rax),
+              ExternalReference::execution_mode_address(isolate), rax),
           Immediate(0));
-  __ j(not_zero, &profiler_enabled);
+  __ j(not_zero, &profiler_or_side_effects_check_enabled);
 #ifdef V8_RUNTIME_CALL_STATS
   __ RecordComment("Check if RCS is enabled");
   __ Move(rax, ExternalReference::address_of_runtime_stats_flag());
   __ cmpl(Operand(rax, 0), Immediate(0));
-  __ j(not_zero, &profiler_enabled);
+  __ j(not_zero, &profiler_or_side_effects_check_enabled);
 #endif  // V8_RUNTIME_CALL_STATS
 
   __ RecordComment("Call the api function directly.");
@@ -4703,7 +4703,7 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
   {
     ASM_CODE_COMMENT_STRING(masm, "Call the api function via thunk wrapper.");
     // Call the api function via thunk wrapper.
-    __ bind(&profiler_enabled);
+    __ bind(&profiler_or_side_effects_check_enabled);
     // Third parameter is the address of the actual getter function.
     __ Move(thunk_last_arg, function_address);
     __ Move(rax, thunk_ref);
diff --git a/src/codegen/code-stub-assembler.cc b/src/codegen/code-stub-assembler.cc
index 28b6236b88b..b11366b7845 100644
--- a/src/codegen/code-stub-assembler.cc
+++ b/src/codegen/code-stub-assembler.cc
@@ -15490,15 +15490,14 @@ TNode<BoolT> CodeStubAssembler::IsDebugActive() {
   return Word32NotEqual(is_debug_active, Int32Constant(0));
 }
 
+// TODO(v8:13825): remove once CallApiGetter/CallApiAccessor are able to handle
+// side effects checking.
 TNode<BoolT> CodeStubAssembler::IsSideEffectFreeDebuggingActive() {
-  TNode<Uint8T> debug_execution_mode = Load<Uint8T>(ExternalConstant(
-      ExternalReference::debug_execution_mode_address(isolate())));
-
-  TNode<BoolT> is_active =
-      Word32Equal(debug_execution_mode,
-                  Int32Constant(DebugInfo::ExecutionMode::kSideEffects));
-
-  return is_active;
+  TNode<Uint8T> execution_mode = Load<Uint8T>(
+      ExternalConstant(ExternalReference::execution_mode_address(isolate())));
+  int32_t mask =
+      static_cast<int32_t>(IsolateExecutionModeFlag::kCheckSideEffects);
+  return IsSetWord32(execution_mode, mask);
 }
 
 TNode<BoolT> CodeStubAssembler::HasAsyncEventDelegate() {
diff --git a/src/codegen/external-reference.cc b/src/codegen/external-reference.cc
index 7990f521692..3a2a3065a39 100644
--- a/src/codegen/external-reference.cc
+++ b/src/codegen/external-reference.cc
@@ -1303,11 +1303,6 @@ ExternalReference ExternalReference::async_event_delegate_address(
   return ExternalReference(isolate->async_event_delegate_address());
 }
 
-ExternalReference ExternalReference::debug_execution_mode_address(
-    Isolate* isolate) {
-  return ExternalReference(isolate->debug_execution_mode_address());
-}
-
 ExternalReference ExternalReference::debug_is_active_address(Isolate* isolate) {
   return ExternalReference(isolate->debug()->is_active_address());
 }
@@ -1365,8 +1360,8 @@ ExternalReference ExternalReference::stack_is_iterable_address(
       isolate->isolate_data()->stack_is_iterable_address());
 }
 
-ExternalReference ExternalReference::is_profiling_address(Isolate* isolate) {
-  return ExternalReference(isolate->isolate_data()->is_profiling_address());
+ExternalReference ExternalReference::execution_mode_address(Isolate* isolate) {
+  return ExternalReference(isolate->isolate_data()->execution_mode_address());
 }
 
 FUNCTION_REFERENCE(call_enqueue_microtask_function,
diff --git a/src/codegen/external-reference.h b/src/codegen/external-reference.h
index 503b5b681d9..6db565321fe 100644
--- a/src/codegen/external-reference.h
+++ b/src/codegen/external-reference.h
@@ -58,13 +58,12 @@ class StatsCounter;
   V(promise_hook_flags_address, "Isolate::promise_hook_flags_address()")       \
   V(promise_hook_address, "Isolate::promise_hook_address()")                   \
   V(async_event_delegate_address, "Isolate::async_event_delegate_address()")   \
-  V(debug_execution_mode_address, "Isolate::debug_execution_mode_address()")   \
   V(debug_is_active_address, "Debug::is_active_address()")                     \
   V(debug_hook_on_function_call_address,                                       \
     "Debug::hook_on_function_call_address()")                                  \
   V(runtime_function_table_address,                                            \
     "Runtime::runtime_function_table_address()")                               \
-  V(is_profiling_address, "IsolateData::is_profiling")                         \
+  V(execution_mode_address, "IsolateData::execution_mode")                     \
   V(debug_suspended_generator_address,                                         \
     "Debug::step_suspended_generator_address()")                               \
   V(fast_c_call_caller_fp_address,                                             \
diff --git a/src/common/globals.h b/src/common/globals.h
index 31aba238706..e2182dc6855 100644
--- a/src/common/globals.h
+++ b/src/common/globals.h
@@ -1854,6 +1854,17 @@ inline std::ostream& operator<<(std::ostream& os, CollectionKind kind) {
   UNREACHABLE();
 }
 
+enum class IsolateExecutionModeFlag : uint8_t {
+  // Default execution mode.
+  kNoFlags = 0,
+  // Set if the Isolate is being profiled. Causes collection of extra compile
+  // info.
+  kIsProfiling = 1 << 0,
+  // Set if side effect checking is enabled for the Isolate.
+  // See Debug::StartSideEffectCheckMode().
+  kCheckSideEffects = 1 << 1,
+};
+
 // Flags for the runtime function kDefineKeyedOwnPropertyInLiteral.
 // - Whether the function name should be set or not.
 enum class DefineKeyedOwnPropertyInLiteralFlag {
diff --git a/src/debug/debug.cc b/src/debug/debug.cc
index c4b7d5cd183..f105c193eef 100644
--- a/src/debug/debug.cc
+++ b/src/debug/debug.cc
@@ -2771,12 +2771,14 @@ void Debug::UpdateDebugInfosForExecutionMode() {
   // Walk all debug infos and update their execution mode if it is different
   // from the isolate execution mode.
   DebugInfoListNode* current = debug_info_list_;
+  DebugInfo::ExecutionMode current_debug_execution_mode =
+      isolate_->debug_execution_mode();
   while (current != nullptr) {
     Handle<DebugInfo> debug_info = current->debug_info();
     if (debug_info->HasInstrumentedBytecodeArray() &&
-        debug_info->DebugExecutionMode() != isolate_->debug_execution_mode()) {
+        debug_info->DebugExecutionMode() != current_debug_execution_mode) {
       DCHECK(debug_info->shared().HasBytecodeArray());
-      if (isolate_->debug_execution_mode() == DebugInfo::kBreakpoints) {
+      if (current_debug_execution_mode == DebugInfo::kBreakpoints) {
         ClearSideEffectChecks(debug_info);
         ApplyBreakPoints(debug_info);
       } else {
@@ -2798,7 +2800,7 @@ void Debug::SetTerminateOnResume() {
 
 void Debug::StartSideEffectCheckMode() {
   RCS_SCOPE(isolate_, RuntimeCallCounterId::kDebugger);
-  DCHECK(isolate_->debug_execution_mode() != DebugInfo::kSideEffects);
+  DCHECK_EQ(isolate_->debug_execution_mode(), DebugInfo::kBreakpoints);
   isolate_->set_debug_execution_mode(DebugInfo::kSideEffects);
   UpdateHookOnFunctionCall();
   side_effect_check_failed_ = false;
@@ -2817,7 +2819,7 @@ void Debug::StartSideEffectCheckMode() {
 
 void Debug::StopSideEffectCheckMode() {
   RCS_SCOPE(isolate_, RuntimeCallCounterId::kDebugger);
-  DCHECK(isolate_->debug_execution_mode() == DebugInfo::kSideEffects);
+  DCHECK_EQ(isolate_->debug_execution_mode(), DebugInfo::kSideEffects);
   if (side_effect_check_failed_) {
     DCHECK(isolate_->has_pending_exception());
     DCHECK_IMPLIES(v8_flags.strict_termination_checks,
diff --git a/src/execution/execution.cc b/src/execution/execution.cc
index 36f584eedd0..d434bfba24a 100644
--- a/src/execution/execution.cc
+++ b/src/execution/execution.cc
@@ -189,7 +189,7 @@ MaybeHandle<Context> NewScriptContext(Isolate* isolate,
   // TODO(cbruni, 1244145): Use passed in host_defined_options.
   // Creating a script context is a side effect, so abort if that's not
   // allowed.
-  if (isolate->debug_execution_mode() == DebugInfo::kSideEffects) {
+  if (isolate->should_check_side_effects()) {
     isolate->Throw(*isolate->factory()->NewEvalError(
         MessageTemplate::kNoSideEffectDebugEvaluate));
     return MaybeHandle<Context>();
diff --git a/src/execution/isolate-data.h b/src/execution/isolate-data.h
index 9961be3ff55..853b2eab70c 100644
--- a/src/execution/isolate-data.h
+++ b/src/execution/isolate-data.h
@@ -30,7 +30,7 @@ class Isolate;
   V(kIsMinorMarkingFlag, kUInt8Size, is_minor_marking_flag)                   \
   V(kIsSharedSpaceIsolateFlag, kUInt8Size, is_shared_space_isolate_flag)      \
   V(kUsesSharedHeapFlag, kUInt8Size, uses_shared_heap_flag)                   \
-  V(kIsProfilingOffset, kUInt8Size, is_profiling)                             \
+  V(kExecutionModeOffset, kUInt8Size, execution_mode)                         \
   V(kStackIsIterableOffset, kUInt8Size, stack_is_iterable)                    \
   V(kTablesAlignmentPaddingOffset, 2, tables_alignment_padding)               \
   /* Tier 0 tables (small but fast access). */                                \
@@ -190,11 +190,11 @@ class IsolateData final {
   uint8_t is_shared_space_isolate_flag_ = false;
   uint8_t uses_shared_heap_flag_ = false;
 
-  // true if the Isolate is being profiled. Causes collection of extra compile
-  // info.
-  // This flag is checked on every API callback/getter call.
-  // Only valid values are 0 or 1.
-  std::atomic<uint8_t> is_profiling_{false};
+  // Storage for is_profiling and should_check_side_effects booleans.
+  // This value is checked on every API callback/getter call.
+  base::Flags<IsolateExecutionModeFlag, uint8_t, std::atomic<uint8_t>>
+      execution_mode_ = {IsolateExecutionModeFlag::kNoFlags};
+  static_assert(sizeof(execution_mode_) == 1);
 
   //
   // Not super hot flags, which are put here because we have to align the
diff --git a/src/execution/isolate.h b/src/execution/isolate.h
index 929435239ff..3966b2bc36b 100644
--- a/src/execution/isolate.h
+++ b/src/execution/isolate.h
@@ -530,8 +530,6 @@ using DebugObjectCache = std::vector<Handle<HeapObject>>;
   V(size_t, num_cpu_profilers, 0)                                             \
   /* true if a trace is being formatted through Error.prepareStackTrace. */   \
   V(bool, formatting_stack_trace, false)                                      \
-  /* Perform side effect checks on function call and API callbacks. */        \
-  V(DebugInfo::ExecutionMode, debug_execution_mode, DebugInfo::kBreakpoints)  \
   V(bool, disable_bytecode_flushing, false)                                   \
   V(int, last_console_context_id, 0)                                          \
   V(v8_inspector::V8Inspector*, inspector, nullptr)                           \
@@ -1330,17 +1328,36 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
   Debug* debug() const { return debug_; }
 
   bool is_profiling() const {
-    return isolate_data_.is_profiling_.load(std::memory_order_relaxed);
+    return isolate_data_.execution_mode_ &
+           IsolateExecutionModeFlag::kIsProfiling;
   }
 
   void SetIsProfiling(bool enabled) {
     if (enabled) {
       CollectSourcePositionsForAllBytecodeArrays();
     }
-    isolate_data_.is_profiling_.store(enabled, std::memory_order_relaxed);
+    isolate_data_.execution_mode_.set(IsolateExecutionModeFlag::kIsProfiling,
+                                      enabled);
     UpdateLogObjectRelocation();
   }
 
+  // Perform side effect checks on function calls and API callbacks.
+  // See Debug::StartSideEffectCheckMode().
+  bool should_check_side_effects() const {
+    return isolate_data_.execution_mode_ &
+           IsolateExecutionModeFlag::kCheckSideEffects;
+  }
+
+  DebugInfo::ExecutionMode debug_execution_mode() const {
+    return should_check_side_effects() ? DebugInfo::kSideEffects
+                                       : DebugInfo::kBreakpoints;
+  }
+  void set_debug_execution_mode(DebugInfo::ExecutionMode debug_execution_mode) {
+    bool check_side_effects = debug_execution_mode == DebugInfo::kSideEffects;
+    isolate_data_.execution_mode_.set(
+        IsolateExecutionModeFlag::kCheckSideEffects, check_side_effects);
+  }
+
   Logger* logger() const { return logger_; }
   HeapProfiler* heap_profiler() const { return heap_profiler_; }
 
@@ -1562,10 +1579,6 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
 
   bool jitless() const { return jitless_; }
 
-  DebugInfo::ExecutionMode* debug_execution_mode_address() {
-    return &debug_execution_mode_;
-  }
-
   base::RandomNumberGenerator* random_number_generator();
 
   base::RandomNumberGenerator* fuzzer_rng();
-- 
2.35.1


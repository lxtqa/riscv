From f149912f337ca7ddb1dad734aab02eaf9bf76dcf Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Fri, 3 Jun 2022 10:35:58 +0200
Subject: [PATCH] [flags] Protect individual flag updates

Extend the effect of --freeze-flags-after-init to also protect updates
of individual flags instead of only the API.
For this, we wrap each flag in a {FlagValue} class which implicitly
converts to the value of the flag. Some cases still require the explicit
{value()} accessor though. That accessor is {constexpr}, in contrast to
the implicit conversion, because otherwise clang emits a lot of warnings
about dead code within "if (FLAG...)" scopes.

R=cbruni@chromium.org

Bug: v8:12887
Change-Id: I87d3457e49ceb317d34d6a21cf09c520d4171eb5
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3683321
Reviewed-by: Camillo Bruni <cbruni@chromium.org>
Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
Reviewed-by: Patrick Thier <pthier@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Reviewed-by: Maya Lekova <mslekova@chromium.org>
Cr-Commit-Position: refs/heads/main@{#80938}
---
 src/baseline/baseline-batch-compiler.cc       |  2 +-
 src/codegen/arm/assembler-arm.cc              | 47 +++++++++++--------
 src/codegen/arm64/assembler-arm64.cc          |  2 +-
 src/codegen/compiler.cc                       |  5 +-
 src/common/checks.h                           | 13 ++---
 src/compiler/backend/unwinding-info-writer.h  |  2 +-
 src/d8/d8.cc                                  |  6 ++-
 src/execution/frame-constants.h               |  2 +-
 src/execution/isolate.cc                      | 19 ++++----
 src/execution/messages.h                      |  5 +-
 src/execution/tiering-manager.cc              |  2 +-
 src/flags/flag-definitions.h                  | 14 +++---
 src/flags/flags.cc                            |  7 ++-
 src/flags/flags.h                             | 34 ++++++++++++--
 src/init/v8.cc                                | 27 +++++------
 src/logging/log.cc                            |  4 +-
 src/objects/code.h                            |  7 +--
 src/profiler/strings-storage.cc               |  9 ++--
 src/regexp/regexp.cc                          |  4 +-
 src/wasm/module-compiler.cc                   |  4 +-
 src/wasm/module-instantiate.cc                |  6 +--
 src/wasm/wasm-code-manager.cc                 |  4 +-
 src/wasm/wasm-engine.cc                       |  5 +-
 src/wasm/wasm-objects.cc                      |  2 +-
 test/cctest/wasm/wasm-run-utils.cc            |  2 +-
 test/common/flag-utils.h                      |  6 ++-
 .../flags/flag-definitions-unittest.cc        | 20 ++++----
 test/unittests/test-utils.cc                  |  5 +-
 28 files changed, 148 insertions(+), 117 deletions(-)

diff --git a/src/baseline/baseline-batch-compiler.cc b/src/baseline/baseline-batch-compiler.cc
index 327f1c53c7..7c98380d56 100644
--- a/src/baseline/baseline-batch-compiler.cc
+++ b/src/baseline/baseline-batch-compiler.cc
@@ -283,7 +283,7 @@ void BaselineBatchCompiler::EnqueueFunction(Handle<JSFunction> function) {
     PrintF(trace_scope.file(),
            " with estimated size %d (current budget: %d/%d)\n", estimated_size,
            estimated_instruction_size_,
-           FLAG_baseline_batch_compilation_threshold);
+           FLAG_baseline_batch_compilation_threshold.value());
   }
   if (ShouldCompileBatch()) {
     if (FLAG_trace_baseline_batch_compilation) {
diff --git a/src/codegen/arm/assembler-arm.cc b/src/codegen/arm/assembler-arm.cc
index 38d682117f..645edb17a4 100644
--- a/src/codegen/arm/assembler-arm.cc
+++ b/src/codegen/arm/assembler-arm.cc
@@ -59,17 +59,18 @@ static const unsigned kArmv8 = kArmv7WithSudiv | (1u << ARMv8);
 
 static unsigned CpuFeaturesFromCommandLine() {
   unsigned result;
-  if (strcmp(FLAG_arm_arch, "armv8") == 0) {
+  const char* arm_arch = FLAG_arm_arch;
+  if (strcmp(arm_arch, "armv8") == 0) {
     result = kArmv8;
-  } else if (strcmp(FLAG_arm_arch, "armv7+sudiv") == 0) {
+  } else if (strcmp(arm_arch, "armv7+sudiv") == 0) {
     result = kArmv7WithSudiv;
-  } else if (strcmp(FLAG_arm_arch, "armv7") == 0) {
+  } else if (strcmp(arm_arch, "armv7") == 0) {
     result = kArmv7;
-  } else if (strcmp(FLAG_arm_arch, "armv6") == 0) {
+  } else if (strcmp(arm_arch, "armv6") == 0) {
     result = kArmv6;
   } else {
     fprintf(stderr, "Error: unrecognised value for --arm-arch ('%s').\n",
-            FLAG_arm_arch);
+            arm_arch);
     fprintf(stderr,
             "Supported values are:  armv8\n"
             "                       armv7+sudiv\n"
@@ -81,9 +82,15 @@ static unsigned CpuFeaturesFromCommandLine() {
   // If any of the old (deprecated) flags are specified, print a warning, but
   // otherwise try to respect them for now.
   // TODO(jbramley): When all the old bots have been updated, remove this.
-  if (FLAG_enable_armv7.has_value() || FLAG_enable_vfp3.has_value() ||
-      FLAG_enable_32dregs.has_value() || FLAG_enable_neon.has_value() ||
-      FLAG_enable_sudiv.has_value() || FLAG_enable_armv8.has_value()) {
+  base::Optional<bool> maybe_enable_armv7 = FLAG_enable_armv7;
+  base::Optional<bool> maybe_enable_vfp3 = FLAG_enable_vfp3;
+  base::Optional<bool> maybe_enable_32dregs = FLAG_enable_32dregs;
+  base::Optional<bool> maybe_enable_neon = FLAG_enable_neon;
+  base::Optional<bool> maybe_enable_sudiv = FLAG_enable_sudiv;
+  base::Optional<bool> maybe_enable_armv8 = FLAG_enable_armv8;
+  if (maybe_enable_armv7.has_value() || maybe_enable_vfp3.has_value() ||
+      maybe_enable_32dregs.has_value() || maybe_enable_neon.has_value() ||
+      maybe_enable_sudiv.has_value() || maybe_enable_armv8.has_value()) {
     // As an approximation of the old behaviour, set the default values from the
     // arm_arch setting, then apply the flags over the top.
     bool enable_armv7 = (result & (1u << ARMv7)) != 0;
@@ -92,41 +99,41 @@ static unsigned CpuFeaturesFromCommandLine() {
     bool enable_neon = (result & (1u << ARMv7)) != 0;
     bool enable_sudiv = (result & (1u << ARMv7_SUDIV)) != 0;
     bool enable_armv8 = (result & (1u << ARMv8)) != 0;
-    if (FLAG_enable_armv7.has_value()) {
+    if (maybe_enable_armv7.has_value()) {
       fprintf(stderr,
               "Warning: --enable_armv7 is deprecated. "
               "Use --arm_arch instead.\n");
-      enable_armv7 = FLAG_enable_armv7.value();
+      enable_armv7 = maybe_enable_armv7.value();
     }
-    if (FLAG_enable_vfp3.has_value()) {
+    if (maybe_enable_vfp3.has_value()) {
       fprintf(stderr,
               "Warning: --enable_vfp3 is deprecated. "
               "Use --arm_arch instead.\n");
-      enable_vfp3 = FLAG_enable_vfp3.value();
+      enable_vfp3 = maybe_enable_vfp3.value();
     }
-    if (FLAG_enable_32dregs.has_value()) {
+    if (maybe_enable_32dregs.has_value()) {
       fprintf(stderr,
               "Warning: --enable_32dregs is deprecated. "
               "Use --arm_arch instead.\n");
-      enable_32dregs = FLAG_enable_32dregs.value();
+      enable_32dregs = maybe_enable_32dregs.value();
     }
-    if (FLAG_enable_neon.has_value()) {
+    if (maybe_enable_neon.has_value()) {
       fprintf(stderr,
               "Warning: --enable_neon is deprecated. "
               "Use --arm_arch instead.\n");
-      enable_neon = FLAG_enable_neon.value();
+      enable_neon = maybe_enable_neon.value();
     }
-    if (FLAG_enable_sudiv.has_value()) {
+    if (maybe_enable_sudiv.has_value()) {
       fprintf(stderr,
               "Warning: --enable_sudiv is deprecated. "
               "Use --arm_arch instead.\n");
-      enable_sudiv = FLAG_enable_sudiv.value();
+      enable_sudiv = maybe_enable_sudiv.value();
     }
-    if (FLAG_enable_armv8.has_value()) {
+    if (maybe_enable_armv8.has_value()) {
       fprintf(stderr,
               "Warning: --enable_armv8 is deprecated. "
               "Use --arm_arch instead.\n");
-      enable_armv8 = FLAG_enable_armv8.value();
+      enable_armv8 = maybe_enable_armv8.value();
     }
     // Emulate the old implications.
     if (enable_armv8) {
diff --git a/src/codegen/arm64/assembler-arm64.cc b/src/codegen/arm64/assembler-arm64.cc
index 2511a07520..52c5d32227 100644
--- a/src/codegen/arm64/assembler-arm64.cc
+++ b/src/codegen/arm64/assembler-arm64.cc
@@ -55,7 +55,7 @@ unsigned SimulatorFeaturesFromCommandLine() {
   fprintf(
       stderr,
       "Error: unrecognised value for --sim-arm64-optional-features ('%s').\n",
-      FLAG_sim_arm64_optional_features);
+      FLAG_sim_arm64_optional_features.value());
   fprintf(stderr,
           "Supported values are:  none\n"
           "                       all\n");
diff --git a/src/codegen/compiler.cc b/src/codegen/compiler.cc
index 67498d1fbd..8f87cad45c 100644
--- a/src/codegen/compiler.cc
+++ b/src/codegen/compiler.cc
@@ -1534,9 +1534,8 @@ BackgroundCompileTask::BackgroundCompileTask(
       flags_(UnoptimizedCompileFlags::ForToplevelCompile(
           isolate, true, construct_language_mode(FLAG_use_strict),
           REPLMode::kNo, type,
-          options == ScriptCompiler::CompileOptions::kEagerCompile
-              ? false
-              : FLAG_lazy_streaming)),
+          options != ScriptCompiler::CompileOptions::kEagerCompile &&
+              FLAG_lazy_streaming)),
       character_stream_(ScannerStream::For(streamed_data->source_stream.get(),
                                            streamed_data->encoding)),
       stack_size_(i::FLAG_stack_size),
diff --git a/src/common/checks.h b/src/common/checks.h
index eef59701d1..59c845b4f5 100644
--- a/src/common/checks.h
+++ b/src/common/checks.h
@@ -9,26 +9,19 @@
 #include "src/base/logging.h"
 #include "src/common/globals.h"
 
-namespace v8 {
-
-class Value;
-
-namespace internal {
+#ifdef ENABLE_SLOW_DCHECKS
+#include "src/flags/flags.h"
+#endif
 
 #ifdef ENABLE_SLOW_DCHECKS
 #define SLOW_DCHECK(condition) \
   CHECK(!v8::internal::FLAG_enable_slow_asserts || (condition))
 #define SLOW_DCHECK_IMPLIES(lhs, rhs) SLOW_DCHECK(!(lhs) || (rhs))
-V8_EXPORT_PRIVATE extern bool FLAG_enable_slow_asserts;
 #else
 #define SLOW_DCHECK(condition) ((void)0)
 #define SLOW_DCHECK_IMPLIES(v1, v2) ((void)0)
-static const bool FLAG_enable_slow_asserts = false;
 #endif
 
-}  // namespace internal
-}  // namespace v8
-
 #define DCHECK_TAG_ALIGNED(address) \
   DCHECK((address & ::v8::internal::kHeapObjectTagMask) == 0)
 
diff --git a/src/compiler/backend/unwinding-info-writer.h b/src/compiler/backend/unwinding-info-writer.h
index a288e219a8..ecc9658d33 100644
--- a/src/compiler/backend/unwinding-info-writer.h
+++ b/src/compiler/backend/unwinding-info-writer.h
@@ -33,7 +33,7 @@ namespace compiler {
 
 class InstructionBlock;
 
-static_assert(!FLAG_perf_prof_unwinding_info,
+static_assert(!FLAG_perf_prof_unwinding_info.value(),
               "--perf-prof-unwinding-info should be statically disabled if not "
               "supported");
 
diff --git a/src/d8/d8.cc b/src/d8/d8.cc
index 0cb87f3d5c..482ed60dbf 100644
--- a/src/d8/d8.cc
+++ b/src/d8/d8.cc
@@ -5646,9 +5646,11 @@ int Shell::Main(int argc, char* argv[]) {
           create_params2.array_buffer_allocator = Shell::array_buffer_allocator;
           create_params2.experimental_attach_to_shared_isolate =
               Shell::shared_isolate;
-          i::FLAG_hash_seed ^= 1337;  // Use a different hash seed.
+          // Use a different hash seed.
+          i::FLAG_hash_seed = i::FLAG_hash_seed ^ 1337;
           Isolate* isolate2 = Isolate::New(create_params2);
-          i::FLAG_hash_seed ^= 1337;  // Restore old hash seed.
+          // Restore old hash seed.
+          i::FLAG_hash_seed = i::FLAG_hash_seed ^ 1337;
           {
             D8Console console2(isolate2);
             Initialize(isolate2, &console2);
diff --git a/src/execution/frame-constants.h b/src/execution/frame-constants.h
index d171bdea0d..c2fd4d57c2 100644
--- a/src/execution/frame-constants.h
+++ b/src/execution/frame-constants.h
@@ -62,7 +62,7 @@ class CommonFrameConstants : public AllStatic {
   static constexpr int kFixedSlotCountAboveFp =
       kFixedFrameSizeAboveFp / kSystemPointerSize;
   static constexpr int kCPSlotSize =
-      FLAG_enable_embedded_constant_pool ? kSystemPointerSize : 0;
+      FLAG_enable_embedded_constant_pool.value() ? kSystemPointerSize : 0;
   static constexpr int kCPSlotCount = kCPSlotSize / kSystemPointerSize;
   static constexpr int kConstantPoolOffset =
       kCPSlotSize ? -1 * kSystemPointerSize : 0;
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index 5114342312..cba3da46a8 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -5190,19 +5190,16 @@ int Isolate::GetNextScriptId() { return heap()->NextScriptId(); }
 
 // static
 std::string Isolate::GetTurboCfgFileName(Isolate* isolate) {
-  if (FLAG_trace_turbo_cfg_file == nullptr) {
-    std::ostringstream os;
-    os << "turbo-" << base::OS::GetCurrentProcessId() << "-";
-    if (isolate != nullptr) {
-      os << isolate->id();
-    } else {
-      os << "any";
-    }
-    os << ".cfg";
-    return os.str();
+  if (const char* filename = FLAG_trace_turbo_cfg_file) return filename;
+  std::ostringstream os;
+  os << "turbo-" << base::OS::GetCurrentProcessId() << "-";
+  if (isolate != nullptr) {
+    os << isolate->id();
   } else {
-    return FLAG_trace_turbo_cfg_file;
+    os << "any";
   }
+  os << ".cfg";
+  return os.str();
 }
 
 // Heap::detached_contexts tracks detached contexts as pairs
diff --git a/src/execution/messages.h b/src/execution/messages.h
index 20b737894b..7e617ab88f 100644
--- a/src/execution/messages.h
+++ b/src/execution/messages.h
@@ -18,10 +18,9 @@
 #include "src/handles/handles.h"
 
 namespace v8 {
+class Value;
+
 namespace internal {
-namespace wasm {
-class WasmCode;
-}  // namespace wasm
 
 // Forward declarations.
 class AbstractCode;
diff --git a/src/execution/tiering-manager.cc b/src/execution/tiering-manager.cc
index abf0af9a16..23d839b615 100644
--- a/src/execution/tiering-manager.cc
+++ b/src/execution/tiering-manager.cc
@@ -312,7 +312,7 @@ OptimizationDecision TieringManager::ShouldOptimize(JSFunction function,
       PrintF("ICs changed]\n");
     } else {
       PrintF(" too large for small function optimization: %d/%d]\n",
-             bytecode.length(), FLAG_max_bytecode_size_for_early_opt);
+             bytecode.length(), FLAG_max_bytecode_size_for_early_opt.value());
     }
   }
 
diff --git a/src/flags/flag-definitions.h b/src/flags/flag-definitions.h
index 6468ddbea5..7742843df4 100644
--- a/src/flags/flag-definitions.h
+++ b/src/flags/flag-definitions.h
@@ -34,19 +34,19 @@
 // compiler make better optimizations by giving it the value.
 #if defined(FLAG_MODE_DECLARE)
 #define FLAG_FULL(ftype, ctype, nam, def, cmt) \
-  V8_EXPORT_PRIVATE extern ctype FLAG_##nam;
+  V8_EXPORT_PRIVATE extern FlagValue<ctype> FLAG_##nam;
 #define FLAG_READONLY(ftype, ctype, nam, def, cmt) \
-  static constexpr ctype FLAG_##nam = def;
+  static constexpr FlagValue<ctype> FLAG_##nam{def};
 
 // We want to supply the actual storage and value for the flag variable in the
 // .cc file.  We only do this for writable flags.
 #elif defined(FLAG_MODE_DEFINE)
 #ifdef USING_V8_SHARED
 #define FLAG_FULL(ftype, ctype, nam, def, cmt) \
-  V8_EXPORT_PRIVATE extern ctype FLAG_##nam;
+  V8_EXPORT_PRIVATE extern FlagValue<ctype> FLAG_##nam;
 #else
 #define FLAG_FULL(ftype, ctype, nam, def, cmt) \
-  V8_EXPORT_PRIVATE ctype FLAG_##nam = def;
+  V8_EXPORT_PRIVATE FlagValue<ctype> FLAG_##nam{def};
 #endif
 
 // We need to define all of our default values so that the Flag structure can
@@ -54,7 +54,7 @@
 // for MODE_META, so there is no impact on the flags interface.
 #elif defined(FLAG_MODE_DEFINE_DEFAULTS)
 #define FLAG_FULL(ftype, ctype, nam, def, cmt) \
-  static constexpr ctype FLAGDEFAULT_##nam = def;
+  static constexpr FlagValue<ctype> FLAGDEFAULT_##nam{def};
 
 // We want to write entries into our meta data table, for internal parsing and
 // printing / etc in the flag parser code.  We only do this for writable flags.
@@ -1957,10 +1957,12 @@ DEFINE_NEG_IMPLICATION(gdbjit, compact_code_space)
 #define FLAG FLAG_READONLY
 #endif
 
-// checks.cc
 #ifdef ENABLE_SLOW_DCHECKS
 DEFINE_BOOL(enable_slow_asserts, true,
             "enable asserts that are slow to execute")
+#else
+DEFINE_BOOL_READONLY(enable_slow_asserts, false,
+                     "enable asserts that are slow to execute")
 #endif
 
 // codegen-ia32.cc / codegen-arm.cc / macro-assembler-*.cc
diff --git a/src/flags/flags.cc b/src/flags/flags.cc
index ad2e6c4c71..691e904c3e 100644
--- a/src/flags/flags.cc
+++ b/src/flags/flags.cc
@@ -448,12 +448,11 @@ std::ostream& operator<<(std::ostream& os, const FlagName& flag_name) {
 }
 
 // Helper for printing flag values.
-struct FlagValue {
-  explicit FlagValue(const Flag& flag) : flag(flag) {}
+struct PrintFlagValue {
   const Flag& flag;
 };
 
-std::ostream& operator<<(std::ostream& os, const FlagValue& flag_value) {
+std::ostream& operator<<(std::ostream& os, PrintFlagValue flag_value) {
   const Flag& flag = flag_value.flag;
   switch (flag.type()) {
     case Flag::TYPE_BOOL:
@@ -492,7 +491,7 @@ std::ostream& operator<<(std::ostream& os, const Flag& flag) {
   if (flag.type() == Flag::TYPE_BOOL) {
     os << (flag.bool_variable() ? "--" : "--no") << FlagName(flag);
   } else {
-    os << "--" << FlagName(flag) << "=" << FlagValue(flag);
+    os << "--" << FlagName(flag) << "=" << PrintFlagValue{flag};
   }
   return os;
 }
diff --git a/src/flags/flags.h b/src/flags/flags.h
index 75d88f93e7..486f3b41d7 100644
--- a/src/flags/flags.h
+++ b/src/flags/flags.h
@@ -8,8 +8,28 @@
 #include "src/base/optional.h"
 #include "src/common/globals.h"
 
-namespace v8 {
-namespace internal {
+namespace v8::internal {
+
+// The value of a single flag (this is the type of all FLAG_* globals).
+template <typename T>
+class FlagValue {
+ public:
+  constexpr FlagValue(T value) : value_(value) {}
+
+  // Implicitly convert to a {T}. Not marked {constexpr} so we do not compiler
+  // warnings about dead code (when checking readonly flags).
+  operator T() const { return value_; }
+
+  // Explicitly convert to a {T} via {value()}. This is {constexpr} so we can
+  // use it for computing other constants.
+  constexpr T value() const { return value_; }
+
+  // Assign a new value (defined below).
+  inline FlagValue<T>& operator=(T new_value);
+
+ private:
+  T value_;
+};
 
 // Declare all of our flags.
 #define FLAG_MODE_DECLARE
@@ -85,7 +105,13 @@ class V8_EXPORT_PRIVATE FlagList {
   static uint32_t Hash();
 };
 
-}  // namespace internal
-}  // namespace v8
+template <typename T>
+FlagValue<T>& FlagValue<T>::operator=(T new_value) {
+  CHECK(!FlagList::IsFrozen());
+  value_ = new_value;
+  return *this;
+}
+
+}  // namespace v8::internal
 
 #endif  // V8_FLAGS_FLAGS_H_
diff --git a/src/init/v8.cc b/src/init/v8.cc
index 1459bbec6d..986dc39fac 100644
--- a/src/init/v8.cc
+++ b/src/init/v8.cc
@@ -137,16 +137,16 @@ void V8::Initialize() {
 #endif  // V8_ENABLE_SANDBOX
 
   // Update logging information before enforcing flag implications.
-  bool* log_all_flags[] = {&FLAG_turbo_profiling_log_builtins,
-                           &FLAG_log_all,
-                           &FLAG_log_code,
-                           &FLAG_log_code_disassemble,
-                           &FLAG_log_source_code,
-                           &FLAG_log_function_events,
-                           &FLAG_log_internal_timer_events,
-                           &FLAG_log_deopt,
-                           &FLAG_log_ic,
-                           &FLAG_log_maps};
+  FlagValue<bool>* log_all_flags[] = {&FLAG_turbo_profiling_log_builtins,
+                                      &FLAG_log_all,
+                                      &FLAG_log_code,
+                                      &FLAG_log_code_disassemble,
+                                      &FLAG_log_source_code,
+                                      &FLAG_log_function_events,
+                                      &FLAG_log_internal_timer_events,
+                                      &FLAG_log_deopt,
+                                      &FLAG_log_ic,
+                                      &FLAG_log_maps};
   if (FLAG_log_all) {
     // Enable all logging flags
     for (auto* flag : log_all_flags) {
@@ -161,11 +161,10 @@ void V8::Initialize() {
       break;
     }
     // Profiling flags depend on logging.
-    FLAG_log |= FLAG_perf_prof || FLAG_perf_basic_prof || FLAG_ll_prof ||
-                FLAG_prof || FLAG_prof_cpp;
-    FLAG_log |= FLAG_gdbjit;
+    FLAG_log = FLAG_log || FLAG_perf_prof || FLAG_perf_basic_prof ||
+               FLAG_ll_prof || FLAG_prof || FLAG_prof_cpp || FLAG_gdbjit;
 #if defined(V8_OS_WIN) && defined(V8_ENABLE_SYSTEM_INSTRUMENTATION)
-    FLAG_log |= FLAG_enable_system_instrumentation;
+    FLAG_log = FLAG_log || FLAG_enable_system_instrumentation;
 #endif
   }
 
diff --git a/src/logging/log.cc b/src/logging/log.cc
index be18be431b..cf4d248de3 100644
--- a/src/logging/log.cc
+++ b/src/logging/log.cc
@@ -2056,10 +2056,10 @@ bool V8FileLogger::SetUp(Isolate* isolate) {
   }
 #else
   static_assert(
-      !FLAG_perf_prof,
+      !FLAG_perf_prof.value(),
       "--perf-prof should be statically disabled on non-Linux platforms");
   static_assert(
-      !FLAG_perf_basic_prof,
+      !FLAG_perf_basic_prof.value(),
       "--perf-basic-prof should be statically disabled on non-Linux platforms");
 #endif
 
diff --git a/src/objects/code.h b/src/objects/code.h
index 78ec7d31a3..89b244be3f 100644
--- a/src/objects/code.h
+++ b/src/objects/code.h
@@ -652,7 +652,7 @@ class Code : public HeapObject {
   /* Offsets describing inline metadata tables, relative to MetadataStart. */ \
   V(kHandlerTableOffsetOffset, kIntSize)                                      \
   V(kConstantPoolOffsetOffset,                                                \
-    FLAG_enable_embedded_constant_pool ? kIntSize : 0)                        \
+    FLAG_enable_embedded_constant_pool.value() ? kIntSize : 0)                \
   V(kCodeCommentsOffsetOffset, kIntSize)                                      \
   V(kUnwindingInfoOffsetOffset, kInt32Size)                                   \
   V(kUnalignedHeaderSize, 0)                                                  \
@@ -684,8 +684,9 @@ class Code : public HeapObject {
   static constexpr int kHeaderPaddingSize = 8;
 #elif V8_TARGET_ARCH_PPC64
   static constexpr int kHeaderPaddingSize =
-      FLAG_enable_embedded_constant_pool ? (COMPRESS_POINTERS_BOOL ? 4 : 48)
-                                         : (COMPRESS_POINTERS_BOOL ? 8 : 52);
+      FLAG_enable_embedded_constant_pool.value()
+          ? (COMPRESS_POINTERS_BOOL ? 4 : 48)
+          : (COMPRESS_POINTERS_BOOL ? 8 : 52);
 #elif V8_TARGET_ARCH_S390X
   static constexpr int kHeaderPaddingSize = COMPRESS_POINTERS_BOOL ? 8 : 20;
 #elif V8_TARGET_ARCH_RISCV64
diff --git a/src/profiler/strings-storage.cc b/src/profiler/strings-storage.cc
index cec67433ae..592d101e68 100644
--- a/src/profiler/strings-storage.cc
+++ b/src/profiler/strings-storage.cc
@@ -81,7 +81,8 @@ const char* StringsStorage::GetSymbol(Symbol sym) {
     return "<symbol>";
   }
   String description = String::cast(sym.description());
-  int length = std::min(FLAG_heap_snapshot_string_limit, description.length());
+  int length =
+      std::min(FLAG_heap_snapshot_string_limit.value(), description.length());
   auto data = description.ToCString(DISALLOW_NULLS, ROBUST_STRING_TRAVERSAL, 0,
                                     length, &length);
   if (sym.is_private_name()) {
@@ -96,7 +97,8 @@ const char* StringsStorage::GetSymbol(Symbol sym) {
 const char* StringsStorage::GetName(Name name) {
   if (name.IsString()) {
     String str = String::cast(name);
-    int length = std::min(FLAG_heap_snapshot_string_limit, str.length());
+    int length =
+        std::min(FLAG_heap_snapshot_string_limit.value(), str.length());
     int actual_length = 0;
     std::unique_ptr<char[]> data = str.ToCString(
         DISALLOW_NULLS, ROBUST_STRING_TRAVERSAL, 0, length, &actual_length);
@@ -114,7 +116,8 @@ const char* StringsStorage::GetName(int index) {
 const char* StringsStorage::GetConsName(const char* prefix, Name name) {
   if (name.IsString()) {
     String str = String::cast(name);
-    int length = std::min(FLAG_heap_snapshot_string_limit, str.length());
+    int length =
+        std::min(FLAG_heap_snapshot_string_limit.value(), str.length());
     int actual_length = 0;
     std::unique_ptr<char[]> data = str.ToCString(
         DISALLOW_NULLS, ROBUST_STRING_TRAVERSAL, 0, length, &actual_length);
diff --git a/src/regexp/regexp.cc b/src/regexp/regexp.cc
index 8186d75696..f1faf82797 100644
--- a/src/regexp/regexp.cc
+++ b/src/regexp/regexp.cc
@@ -962,8 +962,8 @@ bool RegExpImpl::Compile(Isolate* isolate, Zone* zone, RegExpCompileData* data,
     if (backtrack_limit == JSRegExp::kNoBacktrackLimit) {
       backtrack_limit = FLAG_regexp_backtracks_before_fallback;
     } else {
-      backtrack_limit =
-          std::min(backtrack_limit, FLAG_regexp_backtracks_before_fallback);
+      backtrack_limit = std::min(
+          backtrack_limit, FLAG_regexp_backtracks_before_fallback.value());
     }
     macro_assembler->set_backtrack_limit(backtrack_limit);
     macro_assembler->set_can_fallback(true);
diff --git a/src/wasm/module-compiler.cc b/src/wasm/module-compiler.cc
index dccb4bc079..63950f4d71 100644
--- a/src/wasm/module-compiler.cc
+++ b/src/wasm/module-compiler.cc
@@ -1970,7 +1970,7 @@ std::shared_ptr<NativeModule> CompileToNativeModule(
   size_t code_size_estimate =
       wasm::WasmCodeManager::EstimateNativeModuleCodeSize(
           module.get(), include_liftoff,
-          DynamicTiering{FLAG_wasm_dynamic_tiering});
+          DynamicTiering{FLAG_wasm_dynamic_tiering.value()});
   native_module =
       engine->NewNativeModule(isolate, enabled, module, code_size_estimate);
   native_module->SetWireBytes(std::move(wire_bytes_copy));
@@ -2041,7 +2041,7 @@ AsyncCompileJob::AsyncCompileJob(
     : isolate_(isolate),
       api_method_name_(api_method_name),
       enabled_features_(enabled),
-      dynamic_tiering_(DynamicTiering{FLAG_wasm_dynamic_tiering}),
+      dynamic_tiering_(DynamicTiering{FLAG_wasm_dynamic_tiering.value()}),
       wasm_lazy_compilation_(FLAG_wasm_lazy_compilation),
       start_time_(base::TimeTicks::Now()),
       bytes_copy_(std::move(bytes_copy)),
diff --git a/src/wasm/module-instantiate.cc b/src/wasm/module-instantiate.cc
index 55402d39be..e7da2847b4 100644
--- a/src/wasm/module-instantiate.cc
+++ b/src/wasm/module-instantiate.cc
@@ -58,8 +58,8 @@ class CompileImportWrapperJob final : public JobTask {
         cache_scope_(cache_scope) {}
 
   size_t GetMaxConcurrency(size_t worker_count) const override {
-    size_t flag_limit =
-        static_cast<size_t>(std::max(1, FLAG_wasm_num_compilation_tasks));
+    size_t flag_limit = static_cast<size_t>(
+        std::max(1, FLAG_wasm_num_compilation_tasks.value()));
     // Add {worker_count} to the queue size because workers might still be
     // processing units that have already been popped from the queue.
     return std::min(flag_limit, worker_count + queue_->size());
@@ -611,7 +611,7 @@ MaybeHandle<WasmInstanceObject> InstanceBuilder::Build() {
         thrower_->RangeError(
             "initial table size (%u elements) is larger than implementation "
             "limit (%u elements)",
-            table.initial_size, FLAG_wasm_max_table_size);
+            table.initial_size, FLAG_wasm_max_table_size.value());
         return {};
       }
     }
diff --git a/src/wasm/wasm-code-manager.cc b/src/wasm/wasm-code-manager.cc
index 0fe29d9895..a5aa83e534 100644
--- a/src/wasm/wasm-code-manager.cc
+++ b/src/wasm/wasm-code-manager.cc
@@ -354,7 +354,7 @@ void WasmCode::MaybePrint() const {
        FLAG_print_wasm_code_function_index == static_cast<int>(index()));
   if (FLAG_print_code || (kind() == kWasmFunction
                               ? (FLAG_print_wasm_code || function_index_matches)
-                              : FLAG_print_wasm_stub_code)) {
+                              : FLAG_print_wasm_stub_code.value())) {
     std::string name = DebugName();
     Print(name.c_str());
   }
@@ -2280,7 +2280,7 @@ std::shared_ptr<NativeModule> WasmCodeManager::NewNativeModule(
   size_t size = code_space.size();
   Address end = code_space.end();
   std::shared_ptr<NativeModule> ret;
-  new NativeModule(enabled, DynamicTiering{FLAG_wasm_dynamic_tiering},
+  new NativeModule(enabled, DynamicTiering{FLAG_wasm_dynamic_tiering.value()},
                    std::move(code_space), std::move(module),
                    isolate->async_counters(), &ret);
   // The constructor initialized the shared_ptr.
diff --git a/src/wasm/wasm-engine.cc b/src/wasm/wasm-engine.cc
index 809a5d72e9..a35c7475ca 100644
--- a/src/wasm/wasm-engine.cc
+++ b/src/wasm/wasm-engine.cc
@@ -1651,13 +1651,14 @@ uint32_t max_mem_pages() {
       kV8MaxWasmMemoryPages * kWasmPageSize <= JSArrayBuffer::kMaxByteLength,
       "Wasm memories must not be bigger than JSArrayBuffers");
   static_assert(kV8MaxWasmMemoryPages <= kMaxUInt32);
-  return std::min(uint32_t{kV8MaxWasmMemoryPages}, FLAG_wasm_max_mem_pages);
+  return std::min(uint32_t{kV8MaxWasmMemoryPages},
+                  FLAG_wasm_max_mem_pages.value());
 }
 
 // {max_table_init_entries} is declared in wasm-limits.h.
 uint32_t max_table_init_entries() {
   return std::min(uint32_t{kV8MaxWasmTableInitEntries},
-                  FLAG_wasm_max_table_size);
+                  FLAG_wasm_max_table_size.value());
 }
 
 // {max_module_size} is declared in wasm-limits.h.
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index f2cc995d0e..e82ab59b7e 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -265,7 +265,7 @@ int WasmTableObject::Grow(Isolate* isolate, Handle<WasmTableObject> table,
   if (!table->maximum_length().ToUint32(&max_size)) {
     max_size = FLAG_wasm_max_table_size;
   }
-  max_size = std::min(max_size, FLAG_wasm_max_table_size);
+  max_size = std::min(max_size, FLAG_wasm_max_table_size.value());
   DCHECK_LE(old_size, max_size);
   if (max_size - old_size < count) return -1;
 
diff --git a/test/cctest/wasm/wasm-run-utils.cc b/test/cctest/wasm/wasm-run-utils.cc
index b87e7b4aca..5dc0654282 100644
--- a/test/cctest/wasm/wasm-run-utils.cc
+++ b/test/cctest/wasm/wasm-run-utils.cc
@@ -363,7 +363,7 @@ Handle<WasmInstanceObject> TestingModuleBuilder::InitInstanceObject() {
   size_t code_size_estimate =
       wasm::WasmCodeManager::EstimateNativeModuleCodeSize(
           test_module_.get(), kUsesLiftoff,
-          DynamicTiering{FLAG_wasm_dynamic_tiering});
+          DynamicTiering{FLAG_wasm_dynamic_tiering.value()});
   auto native_module = GetWasmEngine()->NewNativeModule(
       isolate_, enabled_features_, test_module_, code_size_estimate);
   native_module->SetWireBytes(base::OwnedVector<const uint8_t>());
diff --git a/test/common/flag-utils.h b/test/common/flag-utils.h
index cd44b56173..277aa46019 100644
--- a/test/common/flag-utils.h
+++ b/test/common/flag-utils.h
@@ -6,6 +6,7 @@
 #define V8_TEST_COMMON_FLAG_UTILS_H
 
 #include "src/base/macros.h"
+#include "src/flags/flags.h"
 
 namespace v8 {
 namespace internal {
@@ -13,13 +14,14 @@ namespace internal {
 template <typename T>
 class V8_NODISCARD FlagScope {
  public:
-  FlagScope(T* flag, T new_value) : flag_(flag), previous_value_(*flag) {
+  FlagScope(FlagValue<T>* flag, T new_value)
+      : flag_(flag), previous_value_(*flag) {
     *flag = new_value;
   }
   ~FlagScope() { *flag_ = previous_value_; }
 
  private:
-  T* flag_;
+  FlagValue<T>* flag_;
   T previous_value_;
 };
 
diff --git a/test/unittests/flags/flag-definitions-unittest.cc b/test/unittests/flags/flag-definitions-unittest.cc
index df1d45bfcd..3ecfff9bf6 100644
--- a/test/unittests/flags/flag-definitions-unittest.cc
+++ b/test/unittests/flags/flag-definitions-unittest.cc
@@ -69,8 +69,8 @@ TEST_F(FlagsTest, Flags2) {
                                                 false));
   CHECK_EQ(8, argc);
   CHECK(!FLAG_testing_bool_flag);
-  CHECK(FLAG_testing_maybe_bool_flag.has_value());
-  CHECK(!FLAG_testing_maybe_bool_flag.value());
+  CHECK(FLAG_testing_maybe_bool_flag.value().has_value());
+  CHECK(!FLAG_testing_maybe_bool_flag.value().value());
   CHECK_EQ(77, FLAG_testing_int_flag);
   CHECK_EQ(.25, FLAG_testing_float_flag);
   CHECK_EQ(0, strcmp(FLAG_testing_string_flag, "no way!"));
@@ -85,8 +85,8 @@ TEST_F(FlagsTest, Flags2b) {
       "--testing_string_flag   no_way!  ";
   CHECK_EQ(0, FlagList::SetFlagsFromString(str, strlen(str)));
   CHECK(!FLAG_testing_bool_flag);
-  CHECK(FLAG_testing_maybe_bool_flag.has_value());
-  CHECK(!FLAG_testing_maybe_bool_flag.value());
+  CHECK(FLAG_testing_maybe_bool_flag.value().has_value());
+  CHECK(!FLAG_testing_maybe_bool_flag.value().value());
   CHECK_EQ(77, FLAG_testing_int_flag);
   CHECK_EQ(.25, FLAG_testing_float_flag);
   CHECK_EQ(0, strcmp(FLAG_testing_string_flag, "no_way!"));
@@ -108,8 +108,8 @@ TEST_F(FlagsTest, Flags3) {
                                                 true));
   CHECK_EQ(2, argc);
   CHECK(FLAG_testing_bool_flag);
-  CHECK(FLAG_testing_maybe_bool_flag.has_value());
-  CHECK(FLAG_testing_maybe_bool_flag.value());
+  CHECK(FLAG_testing_maybe_bool_flag.value().has_value());
+  CHECK(FLAG_testing_maybe_bool_flag.value().value());
   CHECK_EQ(-666, FLAG_testing_int_flag);
   CHECK_EQ(-12E10, FLAG_testing_float_flag);
   CHECK_EQ(0, strcmp(FLAG_testing_string_flag, "foo-bar"));
@@ -124,8 +124,8 @@ TEST_F(FlagsTest, Flags3b) {
       "-testing-string-flag=foo-bar";
   CHECK_EQ(0, FlagList::SetFlagsFromString(str, strlen(str)));
   CHECK(FLAG_testing_bool_flag);
-  CHECK(FLAG_testing_maybe_bool_flag.has_value());
-  CHECK(FLAG_testing_maybe_bool_flag.value());
+  CHECK(FLAG_testing_maybe_bool_flag.value().has_value());
+  CHECK(FLAG_testing_maybe_bool_flag.value().value());
   CHECK_EQ(-666, FLAG_testing_int_flag);
   CHECK_EQ(-12E10, FLAG_testing_float_flag);
   CHECK_EQ(0, strcmp(FLAG_testing_string_flag, "foo-bar"));
@@ -138,14 +138,14 @@ TEST_F(FlagsTest, Flags4) {
   CHECK_EQ(0, FlagList::SetFlagsFromCommandLine(&argc, const_cast<char**>(argv),
                                                 true));
   CHECK_EQ(2, argc);
-  CHECK(!FLAG_testing_maybe_bool_flag.has_value());
+  CHECK(!FLAG_testing_maybe_bool_flag.value().has_value());
 }
 
 TEST_F(FlagsTest, Flags4b) {
   SetFlagsToDefault();
   const char* str = "--testing_bool_flag --foo";
   CHECK_EQ(2, FlagList::SetFlagsFromString(str, strlen(str)));
-  CHECK(!FLAG_testing_maybe_bool_flag.has_value());
+  CHECK(!FLAG_testing_maybe_bool_flag.value().has_value());
 }
 
 TEST_F(FlagsTest, Flags5) {
diff --git a/test/unittests/test-utils.cc b/test/unittests/test-utils.cc
index c3e4b993a8..ed514300e8 100644
--- a/test/unittests/test-utils.cc
+++ b/test/unittests/test-utils.cc
@@ -79,7 +79,8 @@ namespace internal {
 
 SaveFlags::SaveFlags() {
   // For each flag, save the current flag value.
-#define FLAG_MODE_APPLY(ftype, ctype, nam, def, cmt) SAVED_##nam = FLAG_##nam;
+#define FLAG_MODE_APPLY(ftype, ctype, nam, def, cmt) \
+  SAVED_##nam = FLAG_##nam.value();
 #include "src/flags/flag-definitions.h"
 #undef FLAG_MODE_APPLY
 }
@@ -88,7 +89,7 @@ SaveFlags::~SaveFlags() {
   // For each flag, set back the old flag value if it changed (don't write the
   // flag if it didn't change, to keep TSAN happy).
 #define FLAG_MODE_APPLY(ftype, ctype, nam, def, cmt) \
-  if (SAVED_##nam != FLAG_##nam) {                   \
+  if (SAVED_##nam != FLAG_##nam.value()) {           \
     FLAG_##nam = SAVED_##nam;                        \
   }
 #include "src/flags/flag-definitions.h"  // NOLINT
-- 
2.35.1


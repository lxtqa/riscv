From 053d1e0dce682d941b915b576e5077f3d52ad73e Mon Sep 17 00:00:00 2001
From: Leszek Swirski <leszeks@chromium.org>
Date: Mon, 15 Feb 2021 14:27:04 +0100
Subject: [PATCH] [frames] Add UnoptimizedFrame

Add a new StackFrame class for unoptimized frames (which are either
interpreted or baseline). BaselineFrame becomes a subclass of this
rather than InterpretedFrame, and the various frame constants helpers
are similarly amended.

Bug: v8:11420, v8:11429
Change-Id: I87e9368aef48ef06a39476bf826f379ce1441528
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2692208
Commit-Queue: Leszek Swirski <leszeks@chromium.org>
Auto-Submit: Leszek Swirski <leszeks@chromium.org>
Reviewed-by: Jakob Gruber <jgruber@chromium.org>
Reviewed-by: Ross McIlroy <rmcilroy@chromium.org>
Reviewed-by: Ulan Degenbaev <ulan@chromium.org>
Cr-Commit-Position: refs/heads/master@{#72743}
---
 .../arm64/baseline-compiler-arm64-inl.h       |  3 +
 src/baseline/baseline-compiler.cc             |  4 -
 src/baseline/x64/baseline-compiler-x64-inl.h  |  3 +
 src/builtins/arm64/builtins-arm64.cc          |  9 +-
 src/builtins/x64/builtins-x64.cc              |  4 +-
 src/compiler/backend/code-generator.cc        |  2 +-
 src/compiler/backend/instruction-selector.cc  |  2 +-
 src/compiler/backend/instruction.cc           |  6 +-
 src/compiler/bytecode-graph-builder.cc        |  2 +-
 src/compiler/frame-states.cc                  |  4 +-
 src/compiler/frame-states.h                   |  6 +-
 src/compiler/osr.cc                           |  4 +-
 src/compiler/verifier.cc                      |  2 +-
 src/debug/debug-frames.cc                     |  1 -
 src/debug/debug-frames.h                      |  1 -
 src/debug/debug.cc                            | 17 ++--
 src/deoptimizer/deoptimized-frame-info.cc     |  6 +-
 src/deoptimizer/deoptimizer.cc                | 20 ++--
 src/deoptimizer/deoptimizer.h                 |  2 +-
 src/deoptimizer/translated-state.cc           | 14 +--
 src/deoptimizer/translated-state.h            |  4 +-
 src/execution/arm/frame-constants-arm.cc      |  2 +-
 src/execution/arm64/frame-constants-arm64.cc  |  2 +-
 src/execution/frame-constants.h               | 72 ++++++++++++++-
 src/execution/frames-inl.h                    | 36 ++++----
 src/execution/frames.cc                       | 92 +++++++++----------
 src/execution/frames.h                        | 88 +++++++++++-------
 src/execution/ia32/frame-constants-ia32.cc    |  2 +-
 src/execution/isolate.cc                      | 39 ++++----
 src/execution/mips/frame-constants-mips.cc    |  2 +-
 .../mips64/frame-constants-mips64.cc          |  2 +-
 src/execution/ppc/frame-constants-ppc.cc      |  2 +-
 .../riscv64/frame-constants-riscv64.cc        |  2 +-
 src/execution/runtime-profiler.cc             | 14 +--
 src/execution/runtime-profiler.h              |  6 +-
 src/execution/s390/frame-constants-s390.cc    |  2 +-
 src/execution/x64/frame-constants-x64.cc      |  2 +-
 src/heap/mark-compact.cc                      |  2 +-
 src/objects/code-inl.h                        |  4 +-
 src/objects/objects.cc                        |  2 +-
 src/runtime/runtime-compiler.cc               | 20 ++--
 src/runtime/runtime-interpreter.cc            |  3 +-
 src/runtime/runtime-test.cc                   |  8 +-
 .../backend/instruction-selector-unittest.cc  |  2 +-
 test/unittests/compiler/graph-unittest.cc     |  2 +-
 .../compiler/js-create-lowering-unittest.cc   |  2 +-
 46 files changed, 297 insertions(+), 229 deletions(-)

diff --git a/src/baseline/arm64/baseline-compiler-arm64-inl.h b/src/baseline/arm64/baseline-compiler-arm64-inl.h
index 821b83840a3..b01ba065fb1 100644
--- a/src/baseline/arm64/baseline-compiler-arm64-inl.h
+++ b/src/baseline/arm64/baseline-compiler-arm64-inl.h
@@ -76,6 +76,9 @@ MemOperand BaselineAssembler::RegisterFrameOperand(
     interpreter::Register interpreter_register) {
   return MemOperand(fp, interpreter_register.ToOperand() * kSystemPointerSize);
 }
+MemOperand BaselineAssembler::FeedbackVectorOperand() {
+  return MemOperand(fp, BaselineFrameConstants::kFeedbackVectorFromFp);
+}
 
 void BaselineAssembler::Jump(Label* target, Label::Distance distance) {
   __ B(target);
diff --git a/src/baseline/baseline-compiler.cc b/src/baseline/baseline-compiler.cc
index 58bc527ab43..631359909b5 100644
--- a/src/baseline/baseline-compiler.cc
+++ b/src/baseline/baseline-compiler.cc
@@ -246,10 +246,6 @@ MemOperand BaselineAssembler::ContextOperand() {
 MemOperand BaselineAssembler::FunctionOperand() {
   return RegisterFrameOperand(interpreter::Register::function_closure());
 }
-MemOperand BaselineAssembler::FeedbackVectorOperand() {
-  // We re-use the bytecode offset slot for the feedback vector.
-  return RegisterFrameOperand(interpreter::Register::bytecode_offset());
-}
 
 void BaselineAssembler::LoadMap(Register output, Register value) {
   __ LoadMap(output, value);
diff --git a/src/baseline/x64/baseline-compiler-x64-inl.h b/src/baseline/x64/baseline-compiler-x64-inl.h
index 4390b37c649..e5883498a37 100644
--- a/src/baseline/x64/baseline-compiler-x64-inl.h
+++ b/src/baseline/x64/baseline-compiler-x64-inl.h
@@ -89,6 +89,9 @@ MemOperand BaselineAssembler::RegisterFrameOperand(
     interpreter::Register interpreter_register) {
   return MemOperand(rbp, interpreter_register.ToOperand() * kSystemPointerSize);
 }
+MemOperand BaselineAssembler::FeedbackVectorOperand() {
+  return MemOperand(rbp, BaselineFrameConstants::kFeedbackVectorFromFp);
+}
 
 void BaselineAssembler::Jump(Label* target, Label::Distance distance) {
   __ jmp(target, distance);
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index 895d7951dcf..521428ed6a5 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -1244,11 +1244,8 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
 
   __ Push(argc, bytecodeArray);
 
-  // Horrible hack: This should be the bytecode offset, but we calculate that
-  // from the PC, so we cache the feedback vector in there instead.
-  // TODO(v8:11429): Make this less a horrible hack, and more just a frame
-  // difference, by improving the approach distinguishing ignition and baseline
-  // frames.
+  // Baseline code frames store the feedback vector where interpreter would
+  // store the bytecode offset.
   if (__ emit_debug_code()) {
     __ CompareObjectType(feedback_vector, x4, x4, FEEDBACK_VECTOR_TYPE);
     __ Assert(eq, AbortReason::kExpectedFeedbackVector);
@@ -3654,7 +3651,7 @@ void Builtins::Generate_DirectCEntry(MacroAssembler* masm) {
   // making the call GC safe. The irregexp backend relies on this.
 
   __ Poke<TurboAssembler::kSignLR>(lr, 0);  // Store the return address.
-  __ Blr(x10);     // Call the C++ function.
+  __ Blr(x10);                              // Call the C++ function.
   __ Peek<TurboAssembler::kAuthLR>(lr, 0);  // Return to calling code.
   __ AssertFPCRState();
   __ Ret();
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index 3dfea65f0fd..cab1032733f 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -1676,8 +1676,8 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
           Immediate(0));
   __ Push(bytecode_array);
 
-  // Horrible hack: This should be the bytecode offset, but we calculate that
-  // from the PC, so we cache the feedback vector in there instead.
+  // Baseline code frames store the feedback vector where interpreter would
+  // store the bytecode offset.
   __ Push(feedback_vector);
 
   __ RecordComment("]");
diff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.cc
index ce13b5cb1a3..b68aec77723 100644
--- a/src/compiler/backend/code-generator.cc
+++ b/src/compiler/backend/code-generator.cc
@@ -1156,7 +1156,7 @@ void CodeGenerator::BuildTranslationForFrameStateDescriptor(
       static_cast<unsigned int>(descriptor->GetHeight());
 
   switch (descriptor->type()) {
-    case FrameStateType::kInterpretedFunction: {
+    case FrameStateType::kUnoptimizedFunction: {
       int return_offset = 0;
       int return_count = 0;
       if (!state_combine.IsOutputIgnored()) {
diff --git a/src/compiler/backend/instruction-selector.cc b/src/compiler/backend/instruction-selector.cc
index 340f9671dea..815aa7cb4a4 100644
--- a/src/compiler/backend/instruction-selector.cc
+++ b/src/compiler/backend/instruction-selector.cc
@@ -3306,7 +3306,7 @@ FrameStateDescriptor* GetFrameStateDescriptorInternal(Zone* zone,
   const FrameStateInfo& state_info = FrameStateInfoOf(state->op());
   int parameters = state_info.parameter_count();
   int locals = state_info.local_count();
-  int stack = state_info.type() == FrameStateType::kInterpretedFunction ? 1 : 0;
+  int stack = state_info.type() == FrameStateType::kUnoptimizedFunction ? 1 : 0;
 
   FrameStateDescriptor* outer_state = nullptr;
   if (state.has_outer_frame_state()) {
diff --git a/src/compiler/backend/instruction.cc b/src/compiler/backend/instruction.cc
index 8b2424a1bf6..a14ae2a7029 100644
--- a/src/compiler/backend/instruction.cc
+++ b/src/compiler/backend/instruction.cc
@@ -1003,8 +1003,8 @@ size_t GetConservativeFrameSizeInBytes(FrameStateType type,
                                        size_t locals_count,
                                        BytecodeOffset bailout_id) {
   switch (type) {
-    case FrameStateType::kInterpretedFunction: {
-      auto info = InterpretedFrameInfo::Conservative(
+    case FrameStateType::kUnoptimizedFunction: {
+      auto info = UnoptimizedFrameInfo::Conservative(
           static_cast<int>(parameters_count), static_cast<int>(locals_count));
       return info.frame_size_in_bytes();
     }
@@ -1071,7 +1071,7 @@ FrameStateDescriptor::FrameStateDescriptor(
 
 size_t FrameStateDescriptor::GetHeight() const {
   switch (type()) {
-    case FrameStateType::kInterpretedFunction:
+    case FrameStateType::kUnoptimizedFunction:
       return locals_count();  // The accumulator is *not* included.
     case FrameStateType::kBuiltinContinuation:
     case FrameStateType::kJSToWasmBuiltinContinuation:
diff --git a/src/compiler/bytecode-graph-builder.cc b/src/compiler/bytecode-graph-builder.cc
index 580528c2005..7d7f7f44c29 100644
--- a/src/compiler/bytecode-graph-builder.cc
+++ b/src/compiler/bytecode-graph-builder.cc
@@ -1061,7 +1061,7 @@ BytecodeGraphBuilder::BytecodeGraphBuilder(
               ? JSTypeHintLowering::kBailoutOnUninitialized
               : JSTypeHintLowering::kNoFlags),
       frame_state_function_info_(common()->CreateFrameStateFunctionInfo(
-          FrameStateType::kInterpretedFunction,
+          FrameStateType::kUnoptimizedFunction,
           bytecode_array().parameter_count(), bytecode_array().register_count(),
           shared_info.object())),
       source_position_iterator_(std::make_unique<SourcePositionTableIterator>(
diff --git a/src/compiler/frame-states.cc b/src/compiler/frame-states.cc
index 1c72d7618a2..924ca3ce71e 100644
--- a/src/compiler/frame-states.cc
+++ b/src/compiler/frame-states.cc
@@ -49,8 +49,8 @@ size_t hash_value(FrameStateInfo const& info) {
 
 std::ostream& operator<<(std::ostream& os, FrameStateType type) {
   switch (type) {
-    case FrameStateType::kInterpretedFunction:
-      os << "INTERPRETED_FRAME";
+    case FrameStateType::kUnoptimizedFunction:
+      os << "UNOPTIMIZED_FRAME";
       break;
     case FrameStateType::kArgumentsAdaptor:
       os << "ARGUMENTS_ADAPTOR";
diff --git a/src/compiler/frame-states.h b/src/compiler/frame-states.h
index 15d92167833..32586264e79 100644
--- a/src/compiler/frame-states.h
+++ b/src/compiler/frame-states.h
@@ -62,7 +62,7 @@ class OutputFrameStateCombine {
 
 // The type of stack frame that a FrameState node represents.
 enum class FrameStateType {
-  kInterpretedFunction,            // Represents an InterpretedFrame.
+  kUnoptimizedFunction,            // Represents an UnoptimizedFrame.
   kArgumentsAdaptor,               // Represents an ArgumentsAdaptorFrame.
   kConstructStub,                  // Represents a ConstructStubFrame.
   kBuiltinContinuation,            // Represents a continuation to a stub.
@@ -91,7 +91,7 @@ class FrameStateFunctionInfo {
   FrameStateType type() const { return type_; }
 
   static bool IsJSFunctionType(FrameStateType type) {
-    return type == FrameStateType::kInterpretedFunction ||
+    return type == FrameStateType::kUnoptimizedFunction ||
            type == FrameStateType::kJavaScriptBuiltinContinuation ||
            type == FrameStateType::kJavaScriptBuiltinContinuationWithCatch;
   }
@@ -130,7 +130,7 @@ class FrameStateInfo final {
         info_(info) {}
 
   FrameStateType type() const {
-    return info_ == nullptr ? FrameStateType::kInterpretedFunction
+    return info_ == nullptr ? FrameStateType::kUnoptimizedFunction
                             : info_->type();
   }
   BytecodeOffset bailout_id() const { return bailout_id_; }
diff --git a/src/compiler/osr.cc b/src/compiler/osr.cc
index d497fc56695..d8ebe23abd5 100644
--- a/src/compiler/osr.cc
+++ b/src/compiler/osr.cc
@@ -16,9 +16,9 @@ namespace compiler {
 
 OsrHelper::OsrHelper(OptimizedCompilationInfo* info)
     : parameter_count_(info->bytecode_array()->parameter_count()),
-      stack_slot_count_(InterpreterFrameConstants::RegisterStackSlotCount(
+      stack_slot_count_(UnoptimizedFrameConstants::RegisterStackSlotCount(
                             info->bytecode_array()->register_count()) +
-                        InterpreterFrameConstants::kExtraSlotCount) {}
+                        UnoptimizedFrameConstants::kExtraSlotCount) {}
 
 void OsrHelper::SetupFrame(Frame* frame) {
   // The optimized frame will subsume the unoptimized frame. Do so by reserving
diff --git a/src/compiler/verifier.cc b/src/compiler/verifier.cc
index 7205823c41b..f3cd4789e72 100644
--- a/src/compiler/verifier.cc
+++ b/src/compiler/verifier.cc
@@ -553,7 +553,7 @@ void Verifier::Visitor::Check(Node* node, const AllNodes& all) {
                  StateValuesAccess(state.locals()).size());
 
         Node* accumulator = state.stack();
-        if (func_info->type() == FrameStateType::kInterpretedFunction) {
+        if (func_info->type() == FrameStateType::kUnoptimizedFunction) {
           // The accumulator (InputAt(2)) cannot be kStateValues.
           // It can be kTypedStateValues (to signal the type) and it can have
           // other Node types including that of the optimized_out HeapConstant.
diff --git a/src/debug/debug-frames.cc b/src/debug/debug-frames.cc
index f8df0a987b1..8a3e4acb886 100644
--- a/src/debug/debug-frames.cc
+++ b/src/debug/debug-frames.cc
@@ -34,7 +34,6 @@ FrameInspector::FrameInspector(CommonFrame* frame, int inlined_frame_index,
       frame->is_java_script() ? javascript_frame() : nullptr;
   DCHECK(js_frame || frame->is_wasm());
   is_optimized_ = frame_->is_optimized();
-  is_interpreted_ = frame_->is_interpreted();
 
   // Calculate the deoptimized frame.
   if (is_optimized_) {
diff --git a/src/debug/debug-frames.h b/src/debug/debug-frames.h
index fb33342e546..5d21d0a22de 100644
--- a/src/debug/debug-frames.h
+++ b/src/debug/debug-frames.h
@@ -59,7 +59,6 @@ class FrameInspector {
   Handle<String> function_name_;
   int source_position_ = -1;
   bool is_optimized_ = false;
-  bool is_interpreted_ = false;
   bool is_constructor_ = false;
 };
 
diff --git a/src/debug/debug.cc b/src/debug/debug.cc
index 6ad21780f9b..df6429f038a 100644
--- a/src/debug/debug.cc
+++ b/src/debug/debug.cc
@@ -145,7 +145,7 @@ JSGeneratorObject BreakLocation::GetGeneratorObjectForSuspendedFrame(
   DCHECK(IsSuspend());
   DCHECK_GE(generator_obj_reg_index_, 0);
 
-  Object generator_obj = InterpretedFrame::cast(frame)->ReadInterpreterRegister(
+  Object generator_obj = UnoptimizedFrame::cast(frame)->ReadInterpreterRegister(
       generator_obj_reg_index_);
 
   return JSGeneratorObject::cast(generator_obj);
@@ -339,7 +339,6 @@ void DebugFeatureTracker::Track(DebugFeatureTracker::Feature feature) {
   bitfield_ |= mask;
 }
 
-
 // Threading support.
 void Debug::ThreadInit() {
   thread_local_.break_frame_id_ = StackFrameId::NO_ID;
@@ -359,7 +358,6 @@ void Debug::ThreadInit() {
   UpdateHookOnFunctionCall();
 }
 
-
 char* Debug::ArchiveDebug(char* storage) {
   MemCopy(storage, reinterpret_cast<char*>(&thread_local_),
           ArchiveSpacePerThread());
@@ -545,7 +543,6 @@ void Debug::Break(JavaScriptFrame* frame, Handle<JSFunction> break_target) {
   }
 }
 
-
 // Find break point objects for this location, if any, and evaluate them.
 // Return an array of break point objects that evaluated true, or an empty
 // handle if none evaluated true.
@@ -560,7 +557,6 @@ MaybeHandle<FixedArray> Debug::CheckBreakPoints(Handle<DebugInfo> debug_info,
   return Debug::GetHitBreakPoints(debug_info, location->position());
 }
 
-
 bool Debug::IsMutedAtCurrentLocation(JavaScriptFrame* frame) {
   HandleScope scope(isolate_);
   // A break location is considered muted if break locations on the current
@@ -884,7 +880,6 @@ void Debug::ChangeBreakOnException(ExceptionBreakType type, bool enable) {
   }
 }
 
-
 bool Debug::IsBreakOnException(ExceptionBreakType type) {
   if (type == BreakUncaughtException) {
     return break_on_uncaught_exception_;
@@ -1225,7 +1220,6 @@ void Debug::ClearStepping() {
   UpdateHookOnFunctionCall();
 }
 
-
 // Clears all the one-shot break points that are currently set. Normally this
 // function is called each time a break point is hit as one shot break points
 // are used to support stepping.
@@ -1254,12 +1248,13 @@ class DiscardBaselineCodeVisitor : public ThreadVisitor {
       if (it.frame()->type() == StackFrame::BASELINE) {
         BaselineFrame* frame = BaselineFrame::cast(it.frame());
         if (!deopt_all && frame->function().shared() != shared_) continue;
-        frame->InterpretedFrame::PatchBytecodeOffset(
-            frame->GetBytecodeOffset());
+        int bytecode_offset = frame->GetBytecodeOffset();
         Address* pc_addr = frame->pc_address();
         Address advance = BUILTIN_CODE(isolate, InterpreterEnterBytecodeAdvance)
                               ->InstructionStart();
         PointerAuthentication::ReplacePC(pc_addr, advance, kSystemPointerSize);
+        InterpretedFrame::cast(it.Reframe())
+            ->PatchBytecodeOffset(bytecode_offset);
       }
     }
   }
@@ -1680,7 +1675,6 @@ Handle<Object> Debug::FindSharedFunctionInfoInScript(Handle<Script> script,
   return isolate_->factory()->undefined_value();
 }
 
-
 // Ensures the debug information is present for shared.
 bool Debug::EnsureBreakInfo(Handle<SharedFunctionInfo> shared) {
   // Return if we already have the break info for shared.
@@ -2208,7 +2202,8 @@ void Debug::HandleDebugBreak(IgnoreBreakMode ignore_break_mode) {
   StackLimitCheck check(isolate_);
   if (check.HasOverflowed()) return;
 
-  { JavaScriptFrameIterator it(isolate_);
+  {
+    JavaScriptFrameIterator it(isolate_);
     DCHECK(!it.done());
     Object fun = it.frame()->function();
     if (fun.IsJSFunction()) {
diff --git a/src/deoptimizer/deoptimized-frame-info.cc b/src/deoptimizer/deoptimized-frame-info.cc
index 3d770598684..a424a73ea1e 100644
--- a/src/deoptimizer/deoptimized-frame-info.cc
+++ b/src/deoptimizer/deoptimized-frame-info.cc
@@ -40,7 +40,7 @@ DeoptimizedFrameInfo::DeoptimizedFrameInfo(TranslatedState* state,
   stack_it++;  // Skip the function.
   stack_it++;  // Skip the receiver.
 
-  DCHECK_EQ(TranslatedFrame::kInterpretedFunction, frame_it->kind());
+  DCHECK_EQ(TranslatedFrame::kUnoptimizedFunction, frame_it->kind());
 
   parameters_.resize(static_cast<size_t>(parameter_count));
   for (int i = 0; i < parameter_count; i++) {
@@ -54,7 +54,7 @@ DeoptimizedFrameInfo::DeoptimizedFrameInfo(TranslatedState* state,
   stack_it++;
 
   // Get the expression stack.
-  DCHECK_EQ(TranslatedFrame::kInterpretedFunction, frame_it->kind());
+  DCHECK_EQ(TranslatedFrame::kUnoptimizedFunction, frame_it->kind());
   const int stack_height = frame_it->height();  // Accumulator *not* included.
 
   expression_stack_.resize(static_cast<size_t>(stack_height));
@@ -64,7 +64,7 @@ DeoptimizedFrameInfo::DeoptimizedFrameInfo(TranslatedState* state,
     stack_it++;
   }
 
-  DCHECK_EQ(TranslatedFrame::kInterpretedFunction, frame_it->kind());
+  DCHECK_EQ(TranslatedFrame::kUnoptimizedFunction, frame_it->kind());
   stack_it++;  // Skip the accumulator.
 
   CHECK(stack_it == frame_it->end());
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index 8724c85dd3f..d348307b5a2 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -214,7 +214,7 @@ DeoptimizedFrameInfo* Deoptimizer::DebuggerInspectableFrame(
   int counter = jsframe_index;
   for (auto it = translated_values.begin(); it != translated_values.end();
        it++) {
-    if (it->kind() == TranslatedFrame::kInterpretedFunction ||
+    if (it->kind() == TranslatedFrame::kUnoptimizedFunction ||
         it->kind() == TranslatedFrame::kJavaScriptBuiltinContinuation ||
         it->kind() ==
             TranslatedFrame::kJavaScriptBuiltinContinuationWithCatch) {
@@ -228,7 +228,7 @@ DeoptimizedFrameInfo* Deoptimizer::DebuggerInspectableFrame(
   CHECK(frame_it != translated_values.end());
   // We only include kJavaScriptBuiltinContinuation frames above to get the
   // counting right.
-  CHECK_EQ(frame_it->kind(), TranslatedFrame::kInterpretedFunction);
+  CHECK_EQ(frame_it->kind(), TranslatedFrame::kUnoptimizedFunction);
 
   DeoptimizedFrameInfo* info =
       new DeoptimizedFrameInfo(&translated_values, frame_it, isolate);
@@ -707,7 +707,7 @@ namespace {
 int LookupCatchHandler(Isolate* isolate, TranslatedFrame* translated_frame,
                        int* data_out) {
   switch (translated_frame->kind()) {
-    case TranslatedFrame::kInterpretedFunction: {
+    case TranslatedFrame::kUnoptimizedFunction: {
       int bytecode_offset = translated_frame->bytecode_offset().ToInt();
       HandlerTable table(
           translated_frame->raw_shared_info().GetBytecodeArray(isolate));
@@ -925,8 +925,8 @@ void Deoptimizer::DoComputeOutputFrames() {
     TranslatedFrame* translated_frame = &(translated_state_.frames()[i]);
     const bool handle_exception = deoptimizing_throw_ && i == count - 1;
     switch (translated_frame->kind()) {
-      case TranslatedFrame::kInterpretedFunction:
-        DoComputeInterpretedFrame(translated_frame, frame_index,
+      case TranslatedFrame::kUnoptimizedFunction:
+        DoComputeUnoptimizedFrame(translated_frame, frame_index,
                                   handle_exception);
         break;
       case TranslatedFrame::kArgumentsAdaptor:
@@ -980,7 +980,7 @@ void Deoptimizer::DoComputeOutputFrames() {
       stack_guard->real_jslimit() - kStackLimitSlackForDeoptimizationInBytes);
 }
 
-void Deoptimizer::DoComputeInterpretedFrame(TranslatedFrame* translated_frame,
+void Deoptimizer::DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
                                             int frame_index,
                                             bool goto_catch_handler) {
   SharedFunctionInfo shared = translated_frame->raw_shared_info();
@@ -1004,13 +1004,13 @@ void Deoptimizer::DoComputeInterpretedFrame(TranslatedFrame* translated_frame,
                             TranslatedFrame::kArgumentsAdaptor;
 
   const int locals_count = translated_frame->height();
-  InterpretedFrameInfo frame_info = InterpretedFrameInfo::Precise(
+  UnoptimizedFrameInfo frame_info = UnoptimizedFrameInfo::Precise(
       parameters_count, locals_count, is_topmost, should_pad_arguments);
   const uint32_t output_frame_size = frame_info.frame_size_in_bytes();
 
   TranslatedFrame::iterator function_iterator = value_iterator++;
   if (verbose_tracing_enabled()) {
-    PrintF(trace_scope()->file(), "  translating interpreted frame ");
+    PrintF(trace_scope()->file(), "  translating unoptimized frame ");
     std::unique_ptr<char[]> name = shared.DebugNameCStr();
     PrintF(trace_scope()->file(), "%s", name.get());
     PrintF(trace_scope()->file(),
@@ -1084,7 +1084,7 @@ void Deoptimizer::DoComputeInterpretedFrame(TranslatedFrame* translated_frame,
   const intptr_t fp_value = top_address + frame_writer.top_offset();
   output_frame->SetFp(fp_value);
   if (is_topmost) {
-    Register fp_reg = InterpretedFrame::fp_register();
+    Register fp_reg = UnoptimizedFrame::fp_register();
     output_frame->SetRegister(fp_reg.code(), fp_value);
   }
 
@@ -1255,7 +1255,7 @@ void Deoptimizer::DoComputeInterpretedFrame(TranslatedFrame* translated_frame,
     output_frame->SetConstantPool(constant_pool_value);
     if (is_topmost) {
       Register constant_pool_reg =
-          InterpretedFrame::constant_pool_pointer_register();
+          UnoptimizedFrame::constant_pool_pointer_register();
       output_frame->SetRegister(constant_pool_reg.code(), constant_pool_value);
     }
   }
diff --git a/src/deoptimizer/deoptimizer.h b/src/deoptimizer/deoptimizer.h
index 10dc5c60040..cff97ac9439 100644
--- a/src/deoptimizer/deoptimizer.h
+++ b/src/deoptimizer/deoptimizer.h
@@ -154,7 +154,7 @@ class Deoptimizer : public Malloced {
   void DeleteFrameDescriptions();
 
   void DoComputeOutputFrames();
-  void DoComputeInterpretedFrame(TranslatedFrame* translated_frame,
+  void DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
                                  int frame_index, bool goto_catch_handler);
   void DoComputeArgumentsAdaptorFrame(TranslatedFrame* translated_frame,
                                       int frame_index);
diff --git a/src/deoptimizer/translated-state.cc b/src/deoptimizer/translated-state.cc
index aa385b5599e..137daf5fa65 100644
--- a/src/deoptimizer/translated-state.cc
+++ b/src/deoptimizer/translated-state.cc
@@ -626,10 +626,10 @@ void TranslatedValue::Handlify() {
   }
 }
 
-TranslatedFrame TranslatedFrame::InterpretedFrame(
+TranslatedFrame TranslatedFrame::UnoptimizedFrame(
     BytecodeOffset bytecode_offset, SharedFunctionInfo shared_info, int height,
     int return_value_offset, int return_value_count) {
-  TranslatedFrame frame(kInterpretedFunction, shared_info, height,
+  TranslatedFrame frame(kUnoptimizedFunction, shared_info, height,
                         return_value_offset, return_value_count);
   frame.bytecode_offset_ = bytecode_offset;
   return frame;
@@ -697,7 +697,7 @@ int TranslatedFrame::GetValueCount() {
   static constexpr int kTheFunction = 1;
 
   switch (kind()) {
-    case kInterpretedFunction: {
+    case kUnoptimizedFunction: {
       int parameter_count =
           InternalFormalParameterCountWithReceiver(raw_shared_info_);
       static constexpr int kTheContext = 1;
@@ -757,7 +757,7 @@ TranslatedFrame TranslatedState::CreateNextTranslatedFrame(
                bytecode_offset.ToInt(), arg_count, height, return_value_offset,
                return_value_count);
       }
-      return TranslatedFrame::InterpretedFrame(bytecode_offset, shared_info,
+      return TranslatedFrame::UnoptimizedFrame(bytecode_offset, shared_info,
                                                height, return_value_offset,
                                                return_value_count);
     }
@@ -1894,7 +1894,7 @@ TranslatedValue* TranslatedState::ResolveCapturedObject(TranslatedValue* slot) {
 
 TranslatedFrame* TranslatedState::GetFrameFromJSFrameIndex(int jsframe_index) {
   for (size_t i = 0; i < frames_.size(); i++) {
-    if (frames_[i].kind() == TranslatedFrame::kInterpretedFunction ||
+    if (frames_[i].kind() == TranslatedFrame::kUnoptimizedFunction ||
         frames_[i].kind() == TranslatedFrame::kJavaScriptBuiltinContinuation ||
         frames_[i].kind() ==
             TranslatedFrame::kJavaScriptBuiltinContinuationWithCatch) {
@@ -1911,7 +1911,7 @@ TranslatedFrame* TranslatedState::GetFrameFromJSFrameIndex(int jsframe_index) {
 TranslatedFrame* TranslatedState::GetArgumentsInfoFromJSFrameIndex(
     int jsframe_index, int* args_count) {
   for (size_t i = 0; i < frames_.size(); i++) {
-    if (frames_[i].kind() == TranslatedFrame::kInterpretedFunction ||
+    if (frames_[i].kind() == TranslatedFrame::kUnoptimizedFunction ||
         frames_[i].kind() == TranslatedFrame::kJavaScriptBuiltinContinuation ||
         frames_[i].kind() ==
             TranslatedFrame::kJavaScriptBuiltinContinuationWithCatch) {
@@ -2012,7 +2012,7 @@ void TranslatedState::StoreMaterializedValuesAndDeopt(JavaScriptFrame* frame) {
   if (new_store && value_changed) {
     materialized_store->Set(stack_frame_pointer_,
                             previously_materialized_objects);
-    CHECK_EQ(frames_[0].kind(), TranslatedFrame::kInterpretedFunction);
+    CHECK_EQ(frames_[0].kind(), TranslatedFrame::kUnoptimizedFunction);
     CHECK_EQ(frame->function(), frames_[0].front().GetRawValue());
     Deoptimizer::DeoptimizeFunction(frame->function(), frame->LookupCode());
   }
diff --git a/src/deoptimizer/translated-state.h b/src/deoptimizer/translated-state.h
index eb4117d63aa..21d2432854f 100644
--- a/src/deoptimizer/translated-state.h
+++ b/src/deoptimizer/translated-state.h
@@ -171,7 +171,7 @@ class TranslatedValue {
 class TranslatedFrame {
  public:
   enum Kind {
-    kInterpretedFunction,
+    kUnoptimizedFunction,
     kArgumentsAdaptor,
     kConstructStub,
     kBuiltinContinuation,
@@ -261,7 +261,7 @@ class TranslatedFrame {
   friend class Deoptimizer;
 
   // Constructor static methods.
-  static TranslatedFrame InterpretedFrame(BytecodeOffset bytecode_offset,
+  static TranslatedFrame UnoptimizedFrame(BytecodeOffset bytecode_offset,
                                           SharedFunctionInfo shared_info,
                                           int height, int return_value_offset,
                                           int return_value_count);
diff --git a/src/execution/arm/frame-constants-arm.cc b/src/execution/arm/frame-constants-arm.cc
index 602242ac97f..7a72dab870a 100644
--- a/src/execution/arm/frame-constants-arm.cc
+++ b/src/execution/arm/frame-constants-arm.cc
@@ -17,7 +17,7 @@ Register JavaScriptFrame::fp_register() { return v8::internal::fp; }
 Register JavaScriptFrame::context_register() { return cp; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/execution/arm64/frame-constants-arm64.cc b/src/execution/arm64/frame-constants-arm64.cc
index 94d12f058f0..07aebe48675 100644
--- a/src/execution/arm64/frame-constants-arm64.cc
+++ b/src/execution/arm64/frame-constants-arm64.cc
@@ -19,7 +19,7 @@ Register JavaScriptFrame::fp_register() { return v8::internal::fp; }
 Register JavaScriptFrame::context_register() { return cp; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   STATIC_ASSERT(InterpreterFrameConstants::kFixedFrameSize % 16 == 8);
   // Interpreter frame header size is not 16-bytes aligned, so we'll need at
   // least one register slot to make the frame a multiple of 16 bytes. The code
diff --git a/src/execution/frame-constants.h b/src/execution/frame-constants.h
index b742279fb00..6903ae0032b 100644
--- a/src/execution/frame-constants.h
+++ b/src/execution/frame-constants.h
@@ -71,7 +71,7 @@ class CommonFrameConstants : public AllStatic {
       -(kCPSlotSize + kContextOrFrameTypeSize);
 };
 
-// StandardFrames are used for interpreted and optimized JavaScript
+// StandardFrames are used for both unoptimized and optimized JavaScript
 // frames. They always have a context below the saved fp/constant
 // pool, below that the JSFunction of the executing function and below that an
 // integer (not a Smi) containing the actual number of arguments passed to the
@@ -284,12 +284,52 @@ class BuiltinExitFrameConstants : public ExitFrameConstants {
   static constexpr int kNumExtraArgsWithReceiver = 5;
 };
 
-class InterpreterFrameConstants : public StandardFrameConstants {
+// Unoptimized frames are used for interpreted and baseline-compiled JavaScript
+// frames. They are a "standard" frame, with an additional fixed header for the
+// BytecodeArray, bytecode offset (if running interpreted), feedback vector (if
+// running baseline code), and then the interpreter register file.
+//
+//  slot      JS frame
+//       +-----------------+--------------------------------
+//  -n-1 |   parameter n   |                            ^
+//       |- - - - - - - - -|                            |
+//  -n   |  parameter n-1  |                          Caller
+//  ...  |       ...       |                       frame slots
+//  -2   |   parameter 1   |                       (slot < 0)
+//       |- - - - - - - - -|                            |
+//  -1   |   parameter 0   |                            v
+//  -----+-----------------+--------------------------------
+//   0   |   return addr   |   ^                        ^
+//       |- - - - - - - - -|   |                        |
+//   1   | saved frame ptr | Fixed                      |
+//       |- - - - - - - - -| Header <-- frame ptr       |
+//   2   | [Constant Pool] |   |                        |
+//       |- - - - - - - - -|   |                        |
+// 2+cp  |     Context     |   |   if a constant pool   |
+//       |- - - - - - - - -|   |    is used, cp = 1,    |
+// 3+cp  |    JSFunction   |   |   otherwise, cp = 0    |
+//       |- - - - - - - - -|   |                        |
+// 4+cp  |      argc       |   v                        |
+//       +-----------------+----                        |
+// 5+cp  |  BytecodeArray  |   ^                        |
+//       |- - - - - - - - -| Unoptimized code header    |
+// 6+cp  |  offset or FBV  |   v                        |
+//       +-----------------+----                        |
+// 7+cp  |   register 0    |   ^                     Callee
+//       |- - - - - - - - -|   |                   frame slots
+// 8+cp  |   register 1    | Register file         (slot >= 0)
+//  ...  |       ...       |   |                        |
+//       |  register n-1   |   |                        |
+//       |- - - - - - - - -|   |                        |
+// 8+cp+n|   register n    |   v                        v
+//  -----+-----------------+----- <-- stack ptr -------------
+//
+class UnoptimizedFrameConstants : public StandardFrameConstants {
  public:
   // FP-relative.
   static constexpr int kBytecodeArrayFromFp =
       STANDARD_FRAME_EXTRA_PUSHED_VALUE_OFFSET(0);
-  static constexpr int kBytecodeOffsetFromFp =
+  static constexpr int kBytecodeOffsetOrFeedbackVectorFromFp =
       STANDARD_FRAME_EXTRA_PUSHED_VALUE_OFFSET(1);
   DEFINE_STANDARD_FRAME_SIZES(2);
 
@@ -301,7 +341,7 @@ class InterpreterFrameConstants : public StandardFrameConstants {
 
   // Expression index for {JavaScriptFrame::GetExpressionAddress}.
   static constexpr int kBytecodeArrayExpressionIndex = -2;
-  static constexpr int kBytecodeOffsetExpressionIndex = -1;
+  static constexpr int kBytecodeOffsetOrFeedbackVectorExpressionIndex = -1;
   static constexpr int kRegisterFileExpressionIndex = 0;
 
   // Returns the number of stack slots needed for 'register_count' registers.
@@ -310,6 +350,30 @@ class InterpreterFrameConstants : public StandardFrameConstants {
   static int RegisterStackSlotCount(int register_count);
 };
 
+// Interpreter frames are unoptimized frames that are being executed by the
+// interpreter. In this case, the "offset or FBV" slot contains the bytecode
+// offset of the currently executing bytecode.
+class InterpreterFrameConstants : public UnoptimizedFrameConstants {
+ public:
+  static constexpr int kBytecodeOffsetExpressionIndex =
+      kBytecodeOffsetOrFeedbackVectorExpressionIndex;
+
+  static constexpr int kBytecodeOffsetFromFp =
+      kBytecodeOffsetOrFeedbackVectorFromFp;
+};
+
+// Sparkplug frames are unoptimized frames that are being executed by
+// sparkplug-compiled baseline code. base. In this case, the "offset or FBV"
+// slot contains a cached pointer to the feedback vector.
+class BaselineFrameConstants : public UnoptimizedFrameConstants {
+ public:
+  static constexpr int kFeedbackVectorExpressionIndex =
+      kBytecodeOffsetOrFeedbackVectorExpressionIndex;
+
+  static constexpr int kFeedbackVectorFromFp =
+      kBytecodeOffsetOrFeedbackVectorFromFp;
+};
+
 inline static int FPOffsetToFrameSlot(int frame_offset) {
   return StandardFrameConstants::kFixedSlotCountAboveFp - 1 -
          frame_offset / kSystemPointerSize;
diff --git a/src/execution/frames-inl.h b/src/execution/frames-inl.h
index 2bcf90d7927..a5d60f825f0 100644
--- a/src/execution/frames-inl.h
+++ b/src/execution/frames-inl.h
@@ -47,7 +47,6 @@ inline Address StackHandler::address() const {
   return reinterpret_cast<Address>(const_cast<StackHandler*>(this));
 }
 
-
 inline StackHandler* StackHandler::next() const {
   const int offset = StackHandlerConstants::kNextOffset;
   return FromAddress(base::Memory<Address>(address() + offset));
@@ -61,10 +60,8 @@ inline StackHandler* StackHandler::FromAddress(Address address) {
   return reinterpret_cast<StackHandler*>(address);
 }
 
-
 inline StackFrame::StackFrame(StackFrameIteratorBase* iterator)
-    : iterator_(iterator), isolate_(iterator_->isolate()) {
-}
+    : iterator_(iterator), isolate_(iterator_->isolate()) {}
 
 inline StackHandler* StackFrame::top_handler() const {
   return iterator_->handler();
@@ -89,9 +86,8 @@ inline Address* StackFrame::ResolveReturnAddressLocation(Address* pc_address) {
   if (return_address_location_resolver_ == nullptr) {
     return pc_address;
   } else {
-    return reinterpret_cast<Address*>(
-        return_address_location_resolver_(
-            reinterpret_cast<uintptr_t>(pc_address)));
+    return reinterpret_cast<Address*>(return_address_location_resolver_(
+        reinterpret_cast<uintptr_t>(pc_address)));
   }
 }
 
@@ -212,14 +208,16 @@ inline StubFrame::StubFrame(StackFrameIteratorBase* iterator)
     : TypedFrame(iterator) {}
 
 inline OptimizedFrame::OptimizedFrame(StackFrameIteratorBase* iterator)
-    : JavaScriptFrame(iterator) {
-}
+    : JavaScriptFrame(iterator) {}
 
-inline InterpretedFrame::InterpretedFrame(StackFrameIteratorBase* iterator)
+inline UnoptimizedFrame::UnoptimizedFrame(StackFrameIteratorBase* iterator)
     : JavaScriptFrame(iterator) {}
 
+inline InterpretedFrame::InterpretedFrame(StackFrameIteratorBase* iterator)
+    : UnoptimizedFrame(iterator) {}
+
 inline BaselineFrame::BaselineFrame(StackFrameIteratorBase* iterator)
-    : InterpretedFrame(iterator) {}
+    : UnoptimizedFrame(iterator) {}
 
 inline BuiltinFrame::BuiltinFrame(StackFrameIteratorBase* iterator)
     : TypedFrameWithJSLinkage(iterator) {}
@@ -251,8 +249,7 @@ inline InternalFrame::InternalFrame(StackFrameIteratorBase* iterator)
     : TypedFrame(iterator) {}
 
 inline ConstructFrame::ConstructFrame(StackFrameIteratorBase* iterator)
-    : InternalFrame(iterator) {
-}
+    : InternalFrame(iterator) {}
 
 inline BuiltinContinuationFrame::BuiltinContinuationFrame(
     StackFrameIteratorBase* iterator)
@@ -267,14 +264,13 @@ inline JavaScriptBuiltinContinuationWithCatchFrame::
         StackFrameIteratorBase* iterator)
     : JavaScriptBuiltinContinuationFrame(iterator) {}
 
-inline JavaScriptFrameIterator::JavaScriptFrameIterator(
-    Isolate* isolate)
+inline JavaScriptFrameIterator::JavaScriptFrameIterator(Isolate* isolate)
     : iterator_(isolate) {
   if (!done()) Advance();
 }
 
-inline JavaScriptFrameIterator::JavaScriptFrameIterator(
-    Isolate* isolate, ThreadLocalTop* top)
+inline JavaScriptFrameIterator::JavaScriptFrameIterator(Isolate* isolate,
+                                                        ThreadLocalTop* top)
     : iterator_(isolate, top) {
   if (!done()) Advance();
 }
@@ -284,6 +280,11 @@ inline JavaScriptFrame* JavaScriptFrameIterator::frame() const {
   return JavaScriptFrame::cast(frame);
 }
 
+inline JavaScriptFrame* JavaScriptFrameIterator::Reframe() {
+  StackFrame* frame = iterator_.Reframe();
+  return JavaScriptFrame::cast(frame);
+}
+
 inline CommonFrame* StackTraceFrameIterator::frame() const {
   StackFrame* frame = iterator_.frame();
   DCHECK(frame->is_java_script() || frame->is_wasm());
@@ -313,7 +314,6 @@ inline StackFrame* SafeStackFrameIterator::frame() const {
   return frame_;
 }
 
-
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 0e5af4eae68..48aa7f65001 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -869,8 +869,8 @@ Address CommonFrame::GetExpressionAddress(int n) const {
   return fp() + offset - n * kSystemPointerSize;
 }
 
-Address InterpretedFrame::GetExpressionAddress(int n) const {
-  const int offset = InterpreterFrameConstants::kExpressionsOffset;
+Address UnoptimizedFrame::GetExpressionAddress(int n) const {
+  const int offset = UnoptimizedFrameConstants::kExpressionsOffset;
   return fp() + offset - n * kSystemPointerSize;
 }
 
@@ -1552,7 +1552,7 @@ void OptimizedFrame::Summarize(std::vector<FrameSummary>* frames) const {
   // in the deoptimization translation are ordered bottom-to-top.
   bool is_constructor = IsConstructor();
   for (auto it = translated.begin(); it != translated.end(); it++) {
-    if (it->kind() == TranslatedFrame::kInterpretedFunction ||
+    if (it->kind() == TranslatedFrame::kUnoptimizedFunction ||
         it->kind() == TranslatedFrame::kJavaScriptBuiltinContinuation ||
         it->kind() ==
             TranslatedFrame::kJavaScriptBuiltinContinuationWithCatch) {
@@ -1584,7 +1584,7 @@ void OptimizedFrame::Summarize(std::vector<FrameSummary>* frames) const {
                 Builtins::GetBuiltinFromBytecodeOffset(it->bytecode_offset()))),
             isolate());
       } else {
-        DCHECK_EQ(it->kind(), TranslatedFrame::kInterpretedFunction);
+        DCHECK_EQ(it->kind(), TranslatedFrame::kUnoptimizedFunction);
         code_offset = it->bytecode_offset().ToInt();
         abstract_code =
             handle(shared_info->abstract_code(isolate()), isolate());
@@ -1711,18 +1711,45 @@ Object OptimizedFrame::StackSlotAt(int index) const {
   return Object(Memory<Address>(fp() + StackSlotOffsetRelativeToFp(index)));
 }
 
-int InterpretedFrame::position() const {
+int UnoptimizedFrame::position() const {
   AbstractCode code = AbstractCode::cast(GetBytecodeArray());
   int code_offset = GetBytecodeOffset();
   return code.SourcePosition(code_offset);
 }
 
-int InterpretedFrame::LookupExceptionHandlerInTable(
+int UnoptimizedFrame::LookupExceptionHandlerInTable(
     int* context_register, HandlerTable::CatchPrediction* prediction) {
   HandlerTable table(GetBytecodeArray());
   return table.LookupRange(GetBytecodeOffset(), context_register, prediction);
 }
 
+BytecodeArray UnoptimizedFrame::GetBytecodeArray() const {
+  const int index = UnoptimizedFrameConstants::kBytecodeArrayExpressionIndex;
+  DCHECK_EQ(UnoptimizedFrameConstants::kBytecodeArrayFromFp,
+            UnoptimizedFrameConstants::kExpressionsOffset -
+                index * kSystemPointerSize);
+  return BytecodeArray::cast(GetExpression(index));
+}
+
+Object UnoptimizedFrame::ReadInterpreterRegister(int register_index) const {
+  const int index = UnoptimizedFrameConstants::kRegisterFileExpressionIndex;
+  DCHECK_EQ(UnoptimizedFrameConstants::kRegisterFileFromFp,
+            UnoptimizedFrameConstants::kExpressionsOffset -
+                index * kSystemPointerSize);
+  return GetExpression(index + register_index);
+}
+
+void UnoptimizedFrame::Summarize(std::vector<FrameSummary>* functions) const {
+  DCHECK(functions->empty());
+  Handle<AbstractCode> abstract_code(AbstractCode::cast(GetBytecodeArray()),
+                                     isolate());
+  Handle<FixedArray> params = GetParameters();
+  FrameSummary::JavaScriptFrameSummary summary(
+      isolate(), receiver(), function(), *abstract_code, GetBytecodeOffset(),
+      IsConstructor(), *params);
+  functions->push_back(summary);
+}
+
 int InterpretedFrame::GetBytecodeOffset() const {
   const int index = InterpreterFrameConstants::kBytecodeOffsetExpressionIndex;
   DCHECK_EQ(InterpreterFrameConstants::kBytecodeOffsetFromFp,
@@ -1732,6 +1759,7 @@ int InterpretedFrame::GetBytecodeOffset() const {
   return raw_offset - BytecodeArray::kHeaderSize + kHeapObjectTag;
 }
 
+// static
 int InterpretedFrame::GetBytecodeOffset(Address fp) {
   const int offset = InterpreterFrameConstants::kExpressionsOffset;
   const int index = InterpreterFrameConstants::kBytecodeOffsetExpressionIndex;
@@ -1752,22 +1780,6 @@ void InterpretedFrame::PatchBytecodeOffset(int new_offset) {
   SetExpression(index, Smi::FromInt(raw_offset));
 }
 
-int BaselineFrame::GetBytecodeOffset() const {
-  return LookupCode().GetBytecodeOffsetForBaselinePC(this->pc());
-}
-
-intptr_t BaselineFrame::GetPCForBytecodeOffset(int bytecode_offset) const {
-  return LookupCode().GetBaselinePCForBytecodeOffset(bytecode_offset);
-}
-
-BytecodeArray InterpretedFrame::GetBytecodeArray() const {
-  const int index = InterpreterFrameConstants::kBytecodeArrayExpressionIndex;
-  DCHECK_EQ(InterpreterFrameConstants::kBytecodeArrayFromFp,
-            InterpreterFrameConstants::kExpressionsOffset -
-                index * kSystemPointerSize);
-  return BytecodeArray::cast(GetExpression(index));
-}
-
 void InterpretedFrame::PatchBytecodeArray(BytecodeArray bytecode_array) {
   const int index = InterpreterFrameConstants::kBytecodeArrayExpressionIndex;
   DCHECK_EQ(InterpreterFrameConstants::kBytecodeArrayFromFp,
@@ -1776,32 +1788,17 @@ void InterpretedFrame::PatchBytecodeArray(BytecodeArray bytecode_array) {
   SetExpression(index, bytecode_array);
 }
 
-Object InterpretedFrame::ReadInterpreterRegister(int register_index) const {
-  const int index = InterpreterFrameConstants::kRegisterFileExpressionIndex;
-  DCHECK_EQ(InterpreterFrameConstants::kRegisterFileFromFp,
-            InterpreterFrameConstants::kExpressionsOffset -
-                index * kSystemPointerSize);
-  return GetExpression(index + register_index);
+int BaselineFrame::GetBytecodeOffset() const {
+  return LookupCode().GetBytecodeOffsetForBaselinePC(this->pc());
 }
 
-void InterpretedFrame::WriteInterpreterRegister(int register_index,
-                                                Object value) {
-  const int index = InterpreterFrameConstants::kRegisterFileExpressionIndex;
-  DCHECK_EQ(InterpreterFrameConstants::kRegisterFileFromFp,
-            InterpreterFrameConstants::kExpressionsOffset -
-                index * kSystemPointerSize);
-  return SetExpression(index + register_index, value);
+intptr_t BaselineFrame::GetPCForBytecodeOffset(int bytecode_offset) const {
+  return LookupCode().GetBaselinePCForBytecodeOffset(bytecode_offset);
 }
 
-void InterpretedFrame::Summarize(std::vector<FrameSummary>* functions) const {
-  DCHECK(functions->empty());
-  Handle<AbstractCode> abstract_code(AbstractCode::cast(GetBytecodeArray()),
-                                     isolate());
-  Handle<FixedArray> params = GetParameters();
-  FrameSummary::JavaScriptFrameSummary summary(
-      isolate(), receiver(), function(), *abstract_code, GetBytecodeOffset(),
-      IsConstructor(), *params);
-  functions->push_back(summary);
+void BaselineFrame::PatchContext(Context value) {
+  base::Memory<Address>(fp() + BaselineFrameConstants::kContextOffset) =
+      value.ptr();
 }
 
 JSFunction BuiltinFrame::function() const {
@@ -2034,8 +2031,7 @@ void JavaScriptFrame::Print(StringStream* accumulator, PrintMode mode,
     accumulator->PrintName(script.name());
 
     if (is_interpreted()) {
-      const InterpretedFrame* iframe =
-          reinterpret_cast<const InterpretedFrame*>(this);
+      const InterpretedFrame* iframe = InterpretedFrame::cast(this);
       BytecodeArray bytecodes = iframe->GetBytecodeArray();
       int offset = iframe->GetBytecodeOffset();
       int source_pos = AbstractCode::cast(bytecodes).SourcePosition(offset);
@@ -2223,14 +2219,14 @@ bool BuiltinContinuationModeIsWithCatch(BuiltinContinuationMode mode) {
 
 }  // namespace
 
-InterpretedFrameInfo::InterpretedFrameInfo(int parameters_count_with_receiver,
+UnoptimizedFrameInfo::UnoptimizedFrameInfo(int parameters_count_with_receiver,
                                            int translation_height,
                                            bool is_topmost, bool pad_arguments,
                                            FrameInfoKind frame_info_kind) {
   const int locals_count = translation_height;
 
   register_stack_slot_count_ =
-      InterpreterFrameConstants::RegisterStackSlotCount(locals_count);
+      UnoptimizedFrameConstants::RegisterStackSlotCount(locals_count);
 
   static constexpr int kTheAccumulator = 1;
   static constexpr int kTopOfStackPadding = TopOfStackRegisterPaddingSlots();
diff --git a/src/execution/frames.h b/src/execution/frames.h
index 838a967ad57..f985e53c99e 100644
--- a/src/execution/frames.h
+++ b/src/execution/frames.h
@@ -17,9 +17,10 @@
 // - CommonFrame
 //   - CommonFrameWithJSLinkage
 //     - JavaScriptFrame (aka StandardFrame)
-//       - InterpretedFrame
+//       - UnoptimizedFrame
+//         - InterpretedFrame
+//         - BaselineFrame
 //       - OptimizedFrame
-//       - BaselineFrame
 //     - TypedFrameWithJSLinkage
 //       - BuiltinFrame
 //       - JavaScriptBuiltinContinuationFrame
@@ -129,11 +130,6 @@ class StackFrame {
   };
 #undef DECLARE_TYPE
 
-  bool IsUnoptimizedJavaScriptFrame() const {
-    STATIC_ASSERT(BASELINE == INTERPRETED + 1);
-    return base::IsInRange(type(), INTERPRETED, BASELINE);
-  }
-
   // Used to mark the outermost JS entry frame.
   //
   // The mark is an opaque value that should be pushed onto the stack directly,
@@ -214,11 +210,11 @@ class StackFrame {
   bool is_construct_entry() const { return type() == CONSTRUCT_ENTRY; }
   bool is_exit() const { return type() == EXIT; }
   bool is_optimized() const { return type() == OPTIMIZED; }
-  // TODO(v8:11429): Clean up these predicates, distinguishing interpreted from
-  // baseline frames, and adding a new predicate that covers both.
-  bool is_interpreted() const {
-    return type() == INTERPRETED || type() == BASELINE;
+  bool is_unoptimized() const {
+    STATIC_ASSERT(BASELINE == INTERPRETED + 1);
+    return base::IsInRange(type(), INTERPRETED, BASELINE);
   }
+  bool is_interpreted() const { return type() == INTERPRETED; }
   bool is_baseline() const { return type() == BASELINE; }
   bool is_wasm() const { return this->type() == WASM; }
   bool is_wasm_compile_lazy() const { return type() == WASM_COMPILE_LAZY; }
@@ -556,7 +552,7 @@ class CommonFrameWithJSLinkage : public CommonFrame {
   // Lookup exception handler for current {pc}, returns -1 if none found. Also
   // returns data associated with the handler site specific to the frame type:
   //  - OptimizedFrame  : Data is not used and will not return a value.
-  //  - InterpretedFrame: Data is the register index holding the context.
+  //  - UnoptimizedFrame: Data is the register index holding the context.
   virtual int LookupExceptionHandlerInTable(
       int* data, HandlerTable::CatchPrediction* prediction);
 
@@ -832,10 +828,11 @@ class OptimizedFrame : public JavaScriptFrame {
   Object StackSlotAt(int index) const;
 };
 
-class InterpretedFrame : public JavaScriptFrame {
+// An unoptimized frame is a JavaScript frame that is executing bytecode. It
+// may be executing it using the interpreter, or via baseline code compiled from
+// the bytecode.
+class UnoptimizedFrame : public JavaScriptFrame {
  public:
-  Type type() const override { return INTERPRETED; }
-
   // Accessors.
   int position() const override;
 
@@ -844,43 +841,65 @@ class InterpretedFrame : public JavaScriptFrame {
       int* data, HandlerTable::CatchPrediction* prediction) override;
 
   // Returns the current offset into the bytecode stream.
-  virtual int GetBytecodeOffset() const;
-
-  // Updates the current offset into the bytecode stream, mainly used for stack
-  // unwinding to continue execution at a different bytecode offset.
-  void PatchBytecodeOffset(int new_offset);
+  virtual int GetBytecodeOffset() const = 0;
 
   // Returns the frame's current bytecode array.
   BytecodeArray GetBytecodeArray() const;
 
-  // Updates the frame's BytecodeArray with |bytecode_array|. Used by the
-  // debugger to swap execution onto a BytecodeArray patched with breakpoints.
-  void PatchBytecodeArray(BytecodeArray bytecode_array);
-
   // Access to the interpreter register file for this frame.
   Object ReadInterpreterRegister(int register_index) const;
-  void WriteInterpreterRegister(int register_index, Object value);
 
   // Build a list with summaries for this frame including all inlined frames.
   void Summarize(std::vector<FrameSummary>* frames) const override;
 
-  static int GetBytecodeOffset(Address fp);
+  static UnoptimizedFrame* cast(StackFrame* frame) {
+    DCHECK(frame->is_unoptimized());
+    return static_cast<UnoptimizedFrame*>(frame);
+  }
+
+ protected:
+  inline explicit UnoptimizedFrame(StackFrameIteratorBase* iterator);
+
+  Address GetExpressionAddress(int n) const override;
+
+ private:
+  friend class StackFrameIteratorBase;
+};
+
+class InterpretedFrame : public UnoptimizedFrame {
+ public:
+  Type type() const override { return INTERPRETED; }
+
+  // Returns the current offset into the bytecode stream.
+  int GetBytecodeOffset() const override;
+
+  // Updates the current offset into the bytecode stream, mainly used for stack
+  // unwinding to continue execution at a different bytecode offset.
+  void PatchBytecodeOffset(int new_offset);
+
+  // Updates the frame's BytecodeArray with |bytecode_array|. Used by the
+  // debugger to swap execution onto a BytecodeArray patched with breakpoints.
+  void PatchBytecodeArray(BytecodeArray bytecode_array);
 
   static InterpretedFrame* cast(StackFrame* frame) {
     DCHECK(frame->is_interpreted());
     return static_cast<InterpretedFrame*>(frame);
   }
+  static const InterpretedFrame* cast(const StackFrame* frame) {
+    DCHECK(frame->is_interpreted());
+    return static_cast<const InterpretedFrame*>(frame);
+  }
+
+  static int GetBytecodeOffset(Address fp);
 
  protected:
   inline explicit InterpretedFrame(StackFrameIteratorBase* iterator);
 
-  Address GetExpressionAddress(int n) const override;
-
  private:
   friend class StackFrameIteratorBase;
 };
 
-class BaselineFrame : public InterpretedFrame {
+class BaselineFrame : public UnoptimizedFrame {
  public:
   Type type() const override { return BASELINE; }
 
@@ -889,6 +908,8 @@ class BaselineFrame : public InterpretedFrame {
 
   intptr_t GetPCForBytecodeOffset(int lookup_offset) const;
 
+  void PatchContext(Context value);
+
   static BaselineFrame* cast(StackFrame* frame) {
     DCHECK(frame->is_baseline());
     return static_cast<BaselineFrame*>(frame);
@@ -1222,6 +1243,7 @@ class JavaScriptFrameIterator {
   bool done() const { return iterator_.done(); }
   V8_EXPORT_PRIVATE void Advance();
   void AdvanceOneFrame() { iterator_.Advance(); }
+  inline JavaScriptFrame* Reframe();
 
  private:
   StackFrameIterator iterator_;
@@ -1317,16 +1339,16 @@ enum class BuiltinContinuationMode {
   JAVASCRIPT_HANDLE_EXCEPTION  // JavaScriptBuiltinContinuationWithCatchFrame
 };
 
-class InterpretedFrameInfo {
+class UnoptimizedFrameInfo {
  public:
-  static InterpretedFrameInfo Precise(int parameters_count_with_receiver,
+  static UnoptimizedFrameInfo Precise(int parameters_count_with_receiver,
                                       int translation_height, bool is_topmost,
                                       bool pad_arguments) {
     return {parameters_count_with_receiver, translation_height, is_topmost,
             pad_arguments, FrameInfoKind::kPrecise};
   }
 
-  static InterpretedFrameInfo Conservative(int parameters_count_with_receiver,
+  static UnoptimizedFrameInfo Conservative(int parameters_count_with_receiver,
                                            int locals_count) {
     return {parameters_count_with_receiver, locals_count, false, true,
             FrameInfoKind::kConservative};
@@ -1341,7 +1363,7 @@ class InterpretedFrameInfo {
   uint32_t frame_size_in_bytes() const { return frame_size_in_bytes_; }
 
  private:
-  InterpretedFrameInfo(int parameters_count_with_receiver,
+  UnoptimizedFrameInfo(int parameters_count_with_receiver,
                        int translation_height, bool is_topmost,
                        bool pad_arguments, FrameInfoKind frame_info_kind);
 
diff --git a/src/execution/ia32/frame-constants-ia32.cc b/src/execution/ia32/frame-constants-ia32.cc
index 7faecdb858a..16e9e75a440 100644
--- a/src/execution/ia32/frame-constants-ia32.cc
+++ b/src/execution/ia32/frame-constants-ia32.cc
@@ -18,7 +18,7 @@ Register JavaScriptFrame::fp_register() { return ebp; }
 Register JavaScriptFrame::context_register() { return esi; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index b03a22a715d..f68950a425c 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -1214,8 +1214,8 @@ Address Isolate::GetAbstractPC(int* line, int* column) {
     *column = -1;
   }
 
-  if (frame->is_interpreted()) {
-    InterpretedFrame* iframe = static_cast<InterpretedFrame*>(frame);
+  if (frame->is_unoptimized()) {
+    UnoptimizedFrame* iframe = static_cast<UnoptimizedFrame*>(frame);
     Address bytecode_start =
         iframe->GetBytecodeArray().GetFirstBytecodeAddress();
     return bytecode_start + iframe->GetBytecodeOffset();
@@ -1827,8 +1827,8 @@ Object Isolate::UnwindAndFindHandler() {
       case StackFrame::BASELINE: {
         // For interpreted frame we perform a range lookup in the handler table.
         if (!catchable_by_js) break;
-        InterpretedFrame* js_frame = static_cast<InterpretedFrame*>(frame);
-        int register_slots = InterpreterFrameConstants::RegisterStackSlotCount(
+        UnoptimizedFrame* js_frame = UnoptimizedFrame::cast(frame);
+        int register_slots = UnoptimizedFrameConstants::RegisterStackSlotCount(
             js_frame->GetBytecodeArray().register_count());
         int context_reg = 0;  // Will contain register index holding context.
         int offset =
@@ -1851,25 +1851,24 @@ Object Isolate::UnwindAndFindHandler() {
             Context::cast(js_frame->ReadInterpreterRegister(context_reg));
         DCHECK(context.IsContext());
 
-        if (frame->type() == StackFrame::BASELINE) {
-          Code code = frame->LookupCode();
-          intptr_t pc_offset =
-              static_cast<BaselineFrame*>(frame)->GetPCForBytecodeOffset(
-                  offset);
-          // Write the context directly into the context register, so that we
-          // don't need to have a context read + write in the baseline code.
-          js_frame->WriteInterpreterRegister(
-              interpreter::Register::current_context().index(), context);
+        if (frame->is_baseline()) {
+          BaselineFrame* sp_frame = BaselineFrame::cast(js_frame);
+          Code code = sp_frame->LookupCode();
+          intptr_t pc_offset = sp_frame->GetPCForBytecodeOffset(offset);
+          // Patch the context register directly on the frame, so that we don't
+          // need to have a context read + write in the baseline code.
+          sp_frame->PatchContext(context);
           return FoundHandler(Context(), code.InstructionStart(), pc_offset,
+                              code.constant_pool(), return_sp, sp_frame->fp());
+        } else {
+          InterpretedFrame::cast(js_frame)->PatchBytecodeOffset(
+              static_cast<int>(offset));
+
+          Code code =
+              builtins()->builtin(Builtins::kInterpreterEnterBytecodeDispatch);
+          return FoundHandler(context, code.InstructionStart(), 0,
                               code.constant_pool(), return_sp, frame->fp());
         }
-
-        js_frame->PatchBytecodeOffset(static_cast<int>(offset));
-
-        Code code =
-            builtins()->builtin(Builtins::kInterpreterEnterBytecodeDispatch);
-        return FoundHandler(context, code.InstructionStart(), 0,
-                            code.constant_pool(), return_sp, frame->fp());
       }
 
       case StackFrame::BUILTIN:
diff --git a/src/execution/mips/frame-constants-mips.cc b/src/execution/mips/frame-constants-mips.cc
index 4c930e71a9b..1c593c05bc6 100644
--- a/src/execution/mips/frame-constants-mips.cc
+++ b/src/execution/mips/frame-constants-mips.cc
@@ -17,7 +17,7 @@ Register JavaScriptFrame::fp_register() { return v8::internal::fp; }
 Register JavaScriptFrame::context_register() { return cp; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/execution/mips64/frame-constants-mips64.cc b/src/execution/mips64/frame-constants-mips64.cc
index 97ef1835921..cfe899730ca 100644
--- a/src/execution/mips64/frame-constants-mips64.cc
+++ b/src/execution/mips64/frame-constants-mips64.cc
@@ -17,7 +17,7 @@ Register JavaScriptFrame::fp_register() { return v8::internal::fp; }
 Register JavaScriptFrame::context_register() { return cp; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/execution/ppc/frame-constants-ppc.cc b/src/execution/ppc/frame-constants-ppc.cc
index 97bef56a56d..7ef3ea12bf3 100644
--- a/src/execution/ppc/frame-constants-ppc.cc
+++ b/src/execution/ppc/frame-constants-ppc.cc
@@ -20,7 +20,7 @@ Register JavaScriptFrame::constant_pool_pointer_register() {
   return kConstantPoolRegister;
 }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/execution/riscv64/frame-constants-riscv64.cc b/src/execution/riscv64/frame-constants-riscv64.cc
index 43be3bde508..13e91639c98 100644
--- a/src/execution/riscv64/frame-constants-riscv64.cc
+++ b/src/execution/riscv64/frame-constants-riscv64.cc
@@ -17,7 +17,7 @@ Register JavaScriptFrame::fp_register() { return v8::internal::fp; }
 Register JavaScriptFrame::context_register() { return cp; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/execution/runtime-profiler.cc b/src/execution/runtime-profiler.cc
index 23fc5a941b9..a0abfa67305 100644
--- a/src/execution/runtime-profiler.cc
+++ b/src/execution/runtime-profiler.cc
@@ -143,7 +143,7 @@ void RuntimeProfiler::Optimize(JSFunction function, OptimizationReason reason,
   function.MarkForOptimization(ConcurrencyMode::kConcurrent);
 }
 
-void RuntimeProfiler::AttemptOnStackReplacement(InterpretedFrame* frame,
+void RuntimeProfiler::AttemptOnStackReplacement(UnoptimizedFrame* frame,
                                                 int loop_nesting_levels) {
   JSFunction function = frame->function();
   SharedFunctionInfo shared = function.shared();
@@ -164,7 +164,7 @@ void RuntimeProfiler::AttemptOnStackReplacement(InterpretedFrame* frame,
     PrintF(scope.file(), "]\n");
   }
 
-  DCHECK(frame->IsUnoptimizedJavaScriptFrame());
+  DCHECK(frame->is_unoptimized());
   int level = frame->GetBytecodeArray().osr_loop_nesting_level();
   frame->GetBytecodeArray().set_osr_loop_nesting_level(std::min(
       {level + loop_nesting_levels, AbstractCode::kMaxLoopNestingMarker}));
@@ -189,12 +189,12 @@ void RuntimeProfiler::MaybeOptimizeFrame(JSFunction function,
 
   // Note: We currently do not trigger OSR compilation from NCI or TP code.
   // TODO(jgruber,v8:8888): But we should.
-  if (frame->is_interpreted()) {
+  if (frame->is_unoptimized()) {
     if (FLAG_always_osr) {
-      AttemptOnStackReplacement(InterpretedFrame::cast(frame),
+      AttemptOnStackReplacement(UnoptimizedFrame::cast(frame),
                                 AbstractCode::kMaxLoopNestingMarker);
       // Fall through and do a normal optimized compile as well.
-    } else if (MaybeOSR(function, InterpretedFrame::cast(frame))) {
+    } else if (MaybeOSR(function, UnoptimizedFrame::cast(frame))) {
       return;
     }
   }
@@ -210,7 +210,7 @@ void RuntimeProfiler::MaybeOptimizeFrame(JSFunction function,
           current_global_ticks_);
 }
 
-bool RuntimeProfiler::MaybeOSR(JSFunction function, InterpretedFrame* frame) {
+bool RuntimeProfiler::MaybeOSR(JSFunction function, UnoptimizedFrame* frame) {
   int ticks = function.feedback_vector().profiler_ticks();
   // TODO(rmcilroy): Also ensure we only OSR top-level code if it is smaller
   // than kMaxToplevelSourceSize.
@@ -344,7 +344,7 @@ void RuntimeProfiler::MarkCandidatesForOptimization(JavaScriptFrame* frame) {
 
 void RuntimeProfiler::MarkCandidatesForOptimizationFromBytecode() {
   JavaScriptFrameIterator it(isolate_);
-  DCHECK(it.frame()->IsUnoptimizedJavaScriptFrame());
+  DCHECK(it.frame()->is_unoptimized());
   MarkCandidatesForOptimization(it.frame());
 }
 
diff --git a/src/execution/runtime-profiler.h b/src/execution/runtime-profiler.h
index 63fbf2e3b60..60234d12be9 100644
--- a/src/execution/runtime-profiler.h
+++ b/src/execution/runtime-profiler.h
@@ -14,7 +14,7 @@ namespace internal {
 
 class BytecodeArray;
 class Isolate;
-class InterpretedFrame;
+class UnoptimizedFrame;
 class JavaScriptFrame;
 class JSFunction;
 enum class CodeKind;
@@ -31,7 +31,7 @@ class RuntimeProfiler {
 
   void NotifyICChanged() { any_ic_changed_ = true; }
 
-  void AttemptOnStackReplacement(InterpretedFrame* frame,
+  void AttemptOnStackReplacement(UnoptimizedFrame* frame,
                                  int nesting_levels = 1);
 
  private:
@@ -45,7 +45,7 @@ class RuntimeProfiler {
 
   // Potentially attempts OSR from and returns whether no other
   // optimization attempts should be made.
-  bool MaybeOSR(JSFunction function, InterpretedFrame* frame);
+  bool MaybeOSR(JSFunction function, UnoptimizedFrame* frame);
   OptimizationReason ShouldOptimize(JSFunction function,
                                     BytecodeArray bytecode_array);
   void Optimize(JSFunction function, OptimizationReason reason,
diff --git a/src/execution/s390/frame-constants-s390.cc b/src/execution/s390/frame-constants-s390.cc
index ea36f6b370c..50f3445556c 100644
--- a/src/execution/s390/frame-constants-s390.cc
+++ b/src/execution/s390/frame-constants-s390.cc
@@ -17,7 +17,7 @@ Register JavaScriptFrame::fp_register() { return v8::internal::fp; }
 Register JavaScriptFrame::context_register() { return cp; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/execution/x64/frame-constants-x64.cc b/src/execution/x64/frame-constants-x64.cc
index 716a6d70823..fb242505dd0 100644
--- a/src/execution/x64/frame-constants-x64.cc
+++ b/src/execution/x64/frame-constants-x64.cc
@@ -17,7 +17,7 @@ Register JavaScriptFrame::fp_register() { return rbp; }
 Register JavaScriptFrame::context_register() { return rsi; }
 Register JavaScriptFrame::constant_pool_pointer_register() { UNREACHABLE(); }
 
-int InterpreterFrameConstants::RegisterStackSlotCount(int register_count) {
+int UnoptimizedFrameConstants::RegisterStackSlotCount(int register_count) {
   return register_count;
 }
 
diff --git a/src/heap/mark-compact.cc b/src/heap/mark-compact.cc
index 6c42f6210a1..f46ca120d49 100644
--- a/src/heap/mark-compact.cc
+++ b/src/heap/mark-compact.cc
@@ -1872,7 +1872,7 @@ void MarkCompactCollector::ProcessEphemeronMarking() {
 void MarkCompactCollector::ProcessTopOptimizedFrame(ObjectVisitor* visitor) {
   for (StackFrameIterator it(isolate(), isolate()->thread_local_top());
        !it.done(); it.Advance()) {
-    if (it.frame()->IsUnoptimizedJavaScriptFrame()) return;
+    if (it.frame()->is_unoptimized()) return;
     if (it.frame()->type() == StackFrame::OPTIMIZED) {
       Code code = it.frame()->LookupCode();
       if (!code.CanDeoptAt(it.frame()->pc())) {
diff --git a/src/objects/code-inl.h b/src/objects/code-inl.h
index d90704b4d2e..e3019fc1b4e 100644
--- a/src/objects/code-inl.h
+++ b/src/objects/code-inl.h
@@ -724,7 +724,7 @@ void BytecodeArray::set_parameter_count(int32_t number_of_parameters) {
   // Parameter count is stored as the size on stack of the parameters to allow
   // it to be used directly by generated code.
   WriteField<int32_t>(kParameterSizeOffset,
-                  (number_of_parameters << kSystemPointerSizeLog2));
+                      (number_of_parameters << kSystemPointerSizeLog2));
 }
 
 interpreter::Register BytecodeArray::incoming_new_target_or_generator_register()
@@ -747,7 +747,7 @@ void BytecodeArray::set_incoming_new_target_or_generator_register(
            register_count());
     DCHECK_NE(0, incoming_new_target_or_generator_register.ToOperand());
     WriteField<int32_t>(kIncomingNewTargetOrGeneratorRegisterOffset,
-                    incoming_new_target_or_generator_register.ToOperand());
+                        incoming_new_target_or_generator_register.ToOperand());
   }
 }
 
diff --git a/src/objects/objects.cc b/src/objects/objects.cc
index 408747a4919..58ed1e413e8 100644
--- a/src/objects/objects.cc
+++ b/src/objects/objects.cc
@@ -137,7 +137,7 @@ ShouldThrow GetShouldThrow(Isolate* isolate, Maybe<ShouldThrow> should_throw) {
   if (mode == LanguageMode::kStrict) return kThrowOnError;
 
   for (StackFrameIterator it(isolate); !it.done(); it.Advance()) {
-    if (!(it.frame()->is_optimized() || it.frame()->is_interpreted())) {
+    if (!(it.frame()->is_optimized() || it.frame()->is_unoptimized())) {
       continue;
     }
     // Get the language mode from closure.
diff --git a/src/runtime/runtime-compiler.cc b/src/runtime/runtime-compiler.cc
index 8dc55e1bc46..b3d40b52145 100644
--- a/src/runtime/runtime-compiler.cc
+++ b/src/runtime/runtime-compiler.cc
@@ -297,22 +297,22 @@ static bool IsSuitableForOnStackReplacement(Isolate* isolate,
 
 namespace {
 
-BytecodeOffset DetermineEntryAndDisarmOSRForInterpreter(
-    JavaScriptFrame* frame) {
-  InterpretedFrame* iframe = reinterpret_cast<InterpretedFrame*>(frame);
+BytecodeOffset DetermineEntryAndDisarmOSRForUnoptimized(
+    JavaScriptFrame* js_frame) {
+  UnoptimizedFrame* frame = reinterpret_cast<UnoptimizedFrame*>(js_frame);
 
   // Note that the bytecode array active on the stack might be different from
   // the one installed on the function (e.g. patched by debugger). This however
   // is fine because we guarantee the layout to be in sync, hence any
   // BytecodeOffset representing the entry point will be valid for any copy of
   // the bytecode.
-  Handle<BytecodeArray> bytecode(iframe->GetBytecodeArray(), iframe->isolate());
+  Handle<BytecodeArray> bytecode(frame->GetBytecodeArray(), frame->isolate());
 
-  DCHECK_IMPLIES(frame->type() == StackFrame::INTERPRETED,
+  DCHECK_IMPLIES(frame->is_interpreted(),
                  frame->LookupCode().is_interpreter_trampoline_builtin());
-  DCHECK_IMPLIES(frame->type() == StackFrame::BASELINE,
+  DCHECK_IMPLIES(frame->is_baseline(),
                  frame->LookupCode().kind() == CodeKind::BASELINE);
-  DCHECK(frame->is_interpreted());
+  DCHECK(frame->is_unoptimized());
   DCHECK(frame->function().shared().HasBytecodeArray());
 
   // Reset the OSR loop nesting depth to disarm back edges.
@@ -320,7 +320,7 @@ BytecodeOffset DetermineEntryAndDisarmOSRForInterpreter(
 
   // Return a BytecodeOffset representing the bytecode offset of the back
   // branch.
-  return BytecodeOffset(iframe->GetBytecodeOffset());
+  return BytecodeOffset(frame->GetBytecodeOffset());
 }
 
 }  // namespace
@@ -335,11 +335,11 @@ RUNTIME_FUNCTION(Runtime_CompileForOnStackReplacement) {
   // Determine frame triggering OSR request.
   JavaScriptFrameIterator it(isolate);
   JavaScriptFrame* frame = it.frame();
-  DCHECK(frame->is_interpreted());
+  DCHECK(frame->is_unoptimized());
 
   // Determine the entry point for which this OSR request has been fired and
   // also disarm all back edges in the calling code to stop new requests.
-  BytecodeOffset osr_offset = DetermineEntryAndDisarmOSRForInterpreter(frame);
+  BytecodeOffset osr_offset = DetermineEntryAndDisarmOSRForUnoptimized(frame);
   DCHECK(!osr_offset.IsNone());
 
   MaybeHandle<Code> maybe_result;
diff --git a/src/runtime/runtime-interpreter.cc b/src/runtime/runtime-interpreter.cc
index 74de31d14ec..10ff692f68a 100644
--- a/src/runtime/runtime-interpreter.cc
+++ b/src/runtime/runtime-interpreter.cc
@@ -66,8 +66,7 @@ void PrintRegisters(Isolate* isolate, std::ostream& os, bool is_input,
 
   // Print the registers.
   JavaScriptFrameIterator frame_iterator(isolate);
-  InterpretedFrame* frame =
-      reinterpret_cast<InterpretedFrame*>(frame_iterator.frame());
+  UnoptimizedFrame* frame = UnoptimizedFrame::cast(frame_iterator.frame());
   int operand_count = interpreter::Bytecodes::NumberOfOperands(bytecode);
   for (int operand_index = 0; operand_index < operand_count; operand_index++) {
     interpreter::OperandType operand_type =
diff --git a/src/runtime/runtime-test.cc b/src/runtime/runtime-test.cc
index 9f4f9cfd74b..4b483a6d79f 100644
--- a/src/runtime/runtime-test.cc
+++ b/src/runtime/runtime-test.cc
@@ -502,16 +502,15 @@ RUNTIME_FUNCTION(Runtime_OptimizeOsr) {
   function->MarkForOptimization(ConcurrencyMode::kNotConcurrent);
 
   // Make the profiler arm all back edges in unoptimized code.
-  if (it.frame()->IsUnoptimizedJavaScriptFrame()) {
+  if (it.frame()->is_unoptimized()) {
     isolate->runtime_profiler()->AttemptOnStackReplacement(
-        InterpretedFrame::cast(it.frame()),
+        UnoptimizedFrame::cast(it.frame()),
         AbstractCode::kMaxLoopNestingMarker);
   }
 
   return ReadOnlyRoots(isolate).undefined_value();
 }
 
-
 RUNTIME_FUNCTION(Runtime_NeverOptimizeFunction) {
   HandleScope scope(isolate);
   DCHECK_EQ(1, args.length());
@@ -712,7 +711,6 @@ RUNTIME_FUNCTION(Runtime_NotifyContextDisposed) {
   return ReadOnlyRoots(isolate).undefined_value();
 }
 
-
 RUNTIME_FUNCTION(Runtime_SetAllocationTimeout) {
   SealHandleScope shs(isolate);
   DCHECK(args.length() == 2 || args.length() == 3);
@@ -907,7 +905,6 @@ RUNTIME_FUNCTION(Runtime_GlobalPrint) {
   return string;
 }
 
-
 RUNTIME_FUNCTION(Runtime_SystemBreak) {
   // The code below doesn't create handles, but when breaking here in GDB
   // having a handle scope might be useful.
@@ -917,7 +914,6 @@ RUNTIME_FUNCTION(Runtime_SystemBreak) {
   return ReadOnlyRoots(isolate).undefined_value();
 }
 
-
 RUNTIME_FUNCTION(Runtime_SetForceSlowPath) {
   SealHandleScope shs(isolate);
   DCHECK_EQ(1, args.length());
diff --git a/test/unittests/compiler/backend/instruction-selector-unittest.cc b/test/unittests/compiler/backend/instruction-selector-unittest.cc
index 9d61442cc62..0c0214ce43d 100644
--- a/test/unittests/compiler/backend/instruction-selector-unittest.cc
+++ b/test/unittests/compiler/backend/instruction-selector-unittest.cc
@@ -149,7 +149,7 @@ const FrameStateFunctionInfo*
 InstructionSelectorTest::StreamBuilder::GetFrameStateFunctionInfo(
     int parameter_count, int local_count) {
   return common()->CreateFrameStateFunctionInfo(
-      FrameStateType::kInterpretedFunction, parameter_count, local_count,
+      FrameStateType::kUnoptimizedFunction, parameter_count, local_count,
       Handle<SharedFunctionInfo>());
 }
 
diff --git a/test/unittests/compiler/graph-unittest.cc b/test/unittests/compiler/graph-unittest.cc
index c1ffcbf6b45..4a197d557d9 100644
--- a/test/unittests/compiler/graph-unittest.cc
+++ b/test/unittests/compiler/graph-unittest.cc
@@ -93,7 +93,7 @@ Node* GraphTest::EmptyFrameState() {
       graph()->NewNode(common()->StateValues(0, SparseInputMask::Dense()));
   FrameStateFunctionInfo const* function_info =
       common()->CreateFrameStateFunctionInfo(
-          FrameStateType::kInterpretedFunction, 0, 0,
+          FrameStateType::kUnoptimizedFunction, 0, 0,
           Handle<SharedFunctionInfo>());
   return graph()->NewNode(
       common()->FrameState(BytecodeOffset::None(),
diff --git a/test/unittests/compiler/js-create-lowering-unittest.cc b/test/unittests/compiler/js-create-lowering-unittest.cc
index dde409a2481..de1271bc4cf 100644
--- a/test/unittests/compiler/js-create-lowering-unittest.cc
+++ b/test/unittests/compiler/js-create-lowering-unittest.cc
@@ -56,7 +56,7 @@ class JSCreateLoweringTest : public TypedGraphTest {
         common()->FrameState(
             BytecodeOffset::None(), OutputFrameStateCombine::Ignore(),
             common()->CreateFrameStateFunctionInfo(
-                FrameStateType::kInterpretedFunction, 1, 0, shared)),
+                FrameStateType::kUnoptimizedFunction, 1, 0, shared)),
         state_values, state_values, state_values, NumberConstant(0),
         UndefinedConstant(), outer_frame_state);
   }
-- 
2.35.1


From 10f6151d7e46ec3f353953752a670c1992127ad3 Mon Sep 17 00:00:00 2001
From: Nico Hartmann <nicohartmann@chromium.org>
Date: Thu, 24 Jun 2021 11:13:42 +0000
Subject: [PATCH] Revert "[base] Move most of src/numbers into base"

This reverts commit 9701d4a420000cfd76b125ff42eeb6e592a7ac21.

Reason for revert: https://ci.chromium.org/ui/p/v8/builders/ci/V8%20Mac64/40802/overview

Original change's description:
> [base] Move most of src/numbers into base
>
> Moves all but conversions.*, hash-seed-inl.h and math-random.* into
> base, in preparation for moving the parts of conversions that don't
> access HeapObjects.
>
> Also moves uc16 and uc32 out of commons/globals.h into base/strings.h.
>
> Bug: v8:11917
> Change-Id: Ife359148bb0961a63833aff40d26331454b6afb6
> Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2979595
> Reviewed-by: Ross McIlroy <rmcilroy@chromium.org>
> Reviewed-by: Clemens Backes <clemensb@chromium.org>
> Commit-Queue: Ross McIlroy <rmcilroy@chromium.org>
> Auto-Submit: Dan Elphick <delphick@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#75354}

Bug: v8:11917
Change-Id: Iacf796c95256016fa74f0a910c5bb1a86baa425a
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2982605
Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Reviewed-by: Nico Hartmann <nicohartmann@chromium.org>
Commit-Queue: Nico Hartmann <nicohartmann@chromium.org>
Cr-Commit-Position: refs/heads/master@{#75356}
---
 BUILD.bazel                                   |  34 ++--
 BUILD.gn                                      |  34 ++--
 src/asmjs/asm-scanner.cc                      |  26 ++-
 src/asmjs/asm-scanner.h                       |  18 +-
 src/ast/ast.cc                                |   4 +-
 src/base/strings.h                            |  23 ---
 src/builtins/arm/builtins-arm.cc              |   2 +-
 src/builtins/builtins-string-gen.cc           |   7 +-
 src/builtins/builtins-string.cc               |  24 ++-
 src/builtins/ia32/builtins-ia32.cc            |  10 +-
 src/builtins/ppc/builtins-ppc.cc              |   2 +-
 src/builtins/x64/builtins-x64.cc              |   3 +-
 src/codegen/arm/assembler-arm.cc              |   8 +-
 src/codegen/arm/assembler-arm.h               |   4 +-
 src/codegen/arm/macro-assembler-arm.cc        |   2 +-
 src/codegen/constant-pool.h                   |   8 +-
 src/codegen/external-reference.cc             |  13 +-
 src/codegen/mips64/macro-assembler-mips64.cc  |   2 +-
 src/codegen/ppc/assembler-ppc.h               |   5 +-
 src/codegen/ppc/macro-assembler-ppc.cc        |   4 +-
 src/codegen/ppc/macro-assembler-ppc.h         |   5 +-
 src/common/globals.h                          |   8 +-
 .../backend/arm/code-generator-arm.cc         |  18 +-
 src/compiler/backend/instruction.h            |   6 +-
 .../backend/ppc/code-generator-ppc.cc         |  14 +-
 src/compiler/machine-operator-reducer.cc      |   2 +-
 src/compiler/node-matchers.h                  |   4 +-
 src/diagnostics/objects-debug.cc              |   1 -
 .../externalize-string-extension.cc           |   5 +-
 src/heap/factory-base.cc                      |   6 +-
 src/heap/factory-base.h                       |   3 +-
 src/heap/factory.cc                           |  12 +-
 src/heap/factory.h                            |   9 +-
 src/json/json-parser.cc                       |  33 ++--
 src/json/json-parser.h                        |  14 +-
 src/json/json-stringifier.cc                  |  15 +-
 src/{base => }/numbers/bignum-dtoa.cc         |  25 +--
 src/{base => }/numbers/bignum-dtoa.h          |  17 +-
 src/{base => }/numbers/bignum.cc              |  15 +-
 src/{base => }/numbers/bignum.h               |  18 +-
 src/{base => }/numbers/cached-powers.cc       |   8 +-
 src/{base => }/numbers/cached-powers.h        |  12 +-
 src/numbers/conversions-inl.h                 |   6 +-
 src/numbers/conversions.cc                    |  63 ++++---
 src/numbers/conversions.h                     |   3 +-
 src/{base => }/numbers/diy-fp.cc              |   6 +-
 src/{base => }/numbers/diy-fp.h               |  12 +-
 src/{base => }/numbers/double.h               |  12 +-
 src/{base => }/numbers/dtoa.cc                |  21 ++-
 src/{base => }/numbers/dtoa.h                 |  17 +-
 src/{base => }/numbers/fast-dtoa.cc           |  41 ++---
 src/{base => }/numbers/fast-dtoa.h            |  16 +-
 src/{base => }/numbers/fixed-dtoa.cc          |  31 ++--
 src/{base => }/numbers/fixed-dtoa.h           |  16 +-
 src/{base => }/numbers/strtod.cc              |  57 +++----
 src/{base => }/numbers/strtod.h               |  12 +-
 src/objects/bigint.cc                         |  20 +--
 src/objects/intl-objects.cc                   |  11 +-
 src/objects/js-regexp.cc                      |   5 +-
 src/objects/objects-inl.h                     |   4 +-
 src/objects/stack-frame-info.cc               |   3 +-
 src/objects/string-inl.h                      |  25 ++-
 src/objects/string.cc                         |  24 +--
 src/objects/string.h                          |  29 ++--
 src/objects/value-serializer.cc               |  19 +--
 src/objects/value-serializer.h                |   3 +-
 src/parsing/literal-buffer.cc                 |  13 +-
 src/parsing/literal-buffer.h                  |   7 +-
 src/parsing/scanner-character-streams.cc      |  19 +--
 src/parsing/scanner-inl.h                     |   8 +-
 src/parsing/scanner.cc                        |  52 +++---
 src/parsing/scanner.h                         |  56 +++----
 src/regexp/arm/regexp-macro-assembler-arm.cc  |  39 +++--
 src/regexp/arm/regexp-macro-assembler-arm.h   |  19 ++-
 .../arm64/regexp-macro-assembler-arm64.cc     |  41 +++--
 .../arm64/regexp-macro-assembler-arm64.h      |  24 +--
 .../experimental/experimental-bytecode.cc     |   2 +-
 .../experimental/experimental-bytecode.h      |   7 +-
 .../experimental/experimental-compiler.cc     |  21 +--
 .../experimental/experimental-interpreter.cc  |  17 +-
 src/regexp/gen-regexp-special-case.cc         |   7 +-
 .../ia32/regexp-macro-assembler-ia32.cc       |  37 +++--
 src/regexp/ia32/regexp-macro-assembler-ia32.h |  18 +-
 .../mips/regexp-macro-assembler-mips.cc       |  37 +++--
 src/regexp/mips/regexp-macro-assembler-mips.h |  19 ++-
 .../mips64/regexp-macro-assembler-mips64.cc   |  39 +++--
 .../mips64/regexp-macro-assembler-mips64.h    |  19 ++-
 src/regexp/ppc/regexp-macro-assembler-ppc.cc  |  25 +--
 src/regexp/ppc/regexp-macro-assembler-ppc.h   |  15 +-
 src/regexp/property-sequences.cc              |   8 +-
 src/regexp/property-sequences.h               |   7 +-
 src/regexp/regexp-ast.cc                      |   2 +-
 src/regexp/regexp-ast.h                       |  54 +++---
 src/regexp/regexp-bytecode-generator.cc       |  14 +-
 src/regexp/regexp-bytecode-generator.h        |  13 +-
 src/regexp/regexp-bytecodes.h                 |  19 +--
 src/regexp/regexp-compiler-tonode.cc          |  73 ++++----
 src/regexp/regexp-compiler.cc                 | 100 ++++++-----
 src/regexp/regexp-compiler.h                  |   7 +-
 src/regexp/regexp-dotprinter.cc               |   3 +-
 src/regexp/regexp-interpreter.cc              |  19 +--
 src/regexp/regexp-macro-assembler-tracer.cc   |  40 +++--
 src/regexp/regexp-macro-assembler-tracer.h    |  15 +-
 src/regexp/regexp-macro-assembler.cc          |  10 +-
 src/regexp/regexp-macro-assembler.h           |  32 ++--
 src/regexp/regexp-parser.cc                   | 156 +++++++++---------
 src/regexp/regexp-parser.h                    |  57 ++++---
 src/regexp/regexp.cc                          |   7 +-
 .../riscv64/regexp-macro-assembler-riscv64.cc |  14 +-
 .../riscv64/regexp-macro-assembler-riscv64.h  |  15 +-
 .../s390/regexp-macro-assembler-s390.cc       |  15 +-
 src/regexp/s390/regexp-macro-assembler-s390.h |  15 +-
 src/regexp/x64/regexp-macro-assembler-x64.cc  |  40 +++--
 src/regexp/x64/regexp-macro-assembler-x64.h   |  15 +-
 src/runtime/runtime-regexp.cc                 |  17 +-
 src/runtime/runtime-test.cc                   |   3 +-
 src/strings/char-predicates-inl.h             |  48 +++---
 src/strings/char-predicates.cc                |   6 +-
 src/strings/char-predicates.h                 |  55 +++---
 src/strings/string-builder-inl.h              |  10 +-
 src/strings/string-builder.cc                 |  13 +-
 src/strings/string-search.h                   |   8 +-
 src/strings/string-stream.cc                  |   2 +-
 src/strings/string-stream.h                   |   6 +-
 src/strings/uri.cc                            |  78 ++++-----
 src/utils/ostreams.h                          |   3 +-
 src/utils/utils.h                             |  16 ++
 src/wasm/baseline/arm/liftoff-assembler-arm.h |  27 ++-
 test/cctest/gay-fixed.cc                      |   9 +-
 test/cctest/gay-fixed.h                       |   6 +-
 test/cctest/gay-precision.cc                  |  10 +-
 test/cctest/gay-precision.h                   |   6 +-
 test/cctest/gay-shortest.cc                   |  10 +-
 test/cctest/gay-shortest.h                    |   4 +-
 test/cctest/parsing/test-scanner-streams.cc   |  29 ++--
 test/cctest/test-api.cc                       |  12 +-
 test/cctest/test-assembler-arm.cc             |  22 +--
 test/cctest/test-assembler-ia32.cc            |   4 +-
 test/cctest/test-assembler-x64.cc             |  11 +-
 test/cctest/test-bignum-dtoa.cc               |  26 +--
 test/cctest/test-bignum.cc                    |  13 +-
 test/cctest/test-code-stub-assembler.cc       |  11 +-
 test/cctest/test-disasm-arm.cc                |   8 +-
 test/cctest/test-diy-fp.cc                    |   9 +-
 test/cctest/test-double.cc                    |  11 +-
 test/cctest/test-dtoa.cc                      |  12 +-
 test/cctest/test-fast-dtoa.cc                 |  25 +--
 test/cctest/test-fixed-dtoa.cc                |  17 +-
 test/cctest/test-regexp.cc                    |  74 ++++-----
 test/cctest/test-strings.cc                   |  21 +--
 test/cctest/test-strtod.cc                    |  41 ++---
 test/cctest/test-types.cc                     |   5 +-
 test/fuzzer/regexp.cc                         |   9 +-
 .../machine-operator-reducer-unittest.cc      |   3 +-
 154 files changed, 1472 insertions(+), 1458 deletions(-)
 rename src/{base => }/numbers/bignum-dtoa.cc (97%)
 rename src/{base => }/numbers/bignum-dtoa.h (86%)
 rename src/{base => }/numbers/bignum.cc (98%)
 rename src/{base => }/numbers/bignum.h (92%)
 rename src/{base => }/numbers/cached-powers.cc (98%)
 rename src/{base => }/numbers/cached-powers.h (87%)
 rename src/{base => }/numbers/diy-fp.cc (92%)
 rename src/{base => }/numbers/diy-fp.h (92%)
 rename src/{base => }/numbers/double.h (97%)
 rename src/{base => }/numbers/dtoa.cc (83%)
 rename src/{base => }/numbers/dtoa.h (89%)
 rename src/{base => }/numbers/fast-dtoa.cc (96%)
 rename src/{base => }/numbers/fast-dtoa.h (85%)
 rename src/{base => }/numbers/fixed-dtoa.cc (93%)
 rename src/{base => }/numbers/fixed-dtoa.h (75%)
 rename src/{base => }/numbers/strtod.cc (90%)
 rename src/{base => }/numbers/strtod.h (64%)

diff --git a/BUILD.bazel b/BUILD.bazel
index eb41f635fa..8f6d86c9ce 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -214,23 +214,6 @@ filegroup(
         "src/base/logging.h",
         "src/base/macros.h",
         "src/base/memory.h",
-        "src/base/numbers/bignum-dtoa.cc",
-        "src/base/numbers/bignum-dtoa.h",
-        "src/base/numbers/bignum.cc",
-        "src/base/numbers/bignum.h",
-        "src/base/numbers/cached-powers.cc",
-        "src/base/numbers/cached-powers.h",
-        "src/base/numbers/diy-fp.cc",
-        "src/base/numbers/diy-fp.h",
-        "src/base/numbers/double.h",
-        "src/base/numbers/dtoa.cc",
-        "src/base/numbers/dtoa.h",
-        "src/base/numbers/fast-dtoa.cc",
-        "src/base/numbers/fast-dtoa.h",
-        "src/base/numbers/fixed-dtoa.cc",
-        "src/base/numbers/fixed-dtoa.h",
-        "src/base/numbers/strtod.cc",
-        "src/base/numbers/strtod.h",
         "src/base/once.cc",
         "src/base/once.h",
         "src/base/optional.h",
@@ -1121,12 +1104,29 @@ filegroup(
         "src/logging/tracing-flags.h",
         "src/logging/runtime-call-stats.h",
         "src/logging/runtime-call-stats-scope.h",
+        "src/numbers/bignum-dtoa.cc",
+        "src/numbers/bignum-dtoa.h",
+        "src/numbers/bignum.cc",
+        "src/numbers/bignum.h",
+        "src/numbers/cached-powers.cc",
+        "src/numbers/cached-powers.h",
         "src/numbers/conversions-inl.h",
         "src/numbers/conversions.cc",
         "src/numbers/conversions.h",
+        "src/numbers/diy-fp.cc",
+        "src/numbers/diy-fp.h",
+        "src/numbers/double.h",
+        "src/numbers/dtoa.cc",
+        "src/numbers/dtoa.h",
+        "src/numbers/fast-dtoa.cc",
+        "src/numbers/fast-dtoa.h",
+        "src/numbers/fixed-dtoa.cc",
+        "src/numbers/fixed-dtoa.h",
         "src/numbers/hash-seed-inl.h",
         "src/numbers/math-random.cc",
         "src/numbers/math-random.h",
+        "src/numbers/strtod.cc",
+        "src/numbers/strtod.h",
         "src/objects/all-objects-inl.h",
         "src/objects/allocation-site-inl.h",
         "src/objects/allocation-site-scopes-inl.h",
diff --git a/BUILD.gn b/BUILD.gn
index 8201733f32..bcc86f64f5 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -2815,10 +2815,19 @@ v8_header_set("v8_internal_headers") {
     "src/logging/runtime-call-stats-scope.h",
     "src/logging/runtime-call-stats.h",
     "src/logging/tracing-flags.h",
+    "src/numbers/bignum-dtoa.h",
+    "src/numbers/bignum.h",
+    "src/numbers/cached-powers.h",
     "src/numbers/conversions-inl.h",
     "src/numbers/conversions.h",
+    "src/numbers/diy-fp.h",
+    "src/numbers/double.h",
+    "src/numbers/dtoa.h",
+    "src/numbers/fast-dtoa.h",
+    "src/numbers/fixed-dtoa.h",
     "src/numbers/hash-seed-inl.h",
     "src/numbers/math-random.h",
+    "src/numbers/strtod.h",
     "src/objects/all-objects-inl.h",
     "src/objects/allocation-site-inl.h",
     "src/objects/allocation-site-scopes-inl.h",
@@ -3899,8 +3908,16 @@ v8_source_set("v8_base_without_compiler") {
     "src/logging/metrics.cc",
     "src/logging/runtime-call-stats.cc",
     "src/logging/tracing-flags.cc",
+    "src/numbers/bignum-dtoa.cc",
+    "src/numbers/bignum.cc",
+    "src/numbers/cached-powers.cc",
     "src/numbers/conversions.cc",
+    "src/numbers/diy-fp.cc",
+    "src/numbers/dtoa.cc",
+    "src/numbers/fast-dtoa.cc",
+    "src/numbers/fixed-dtoa.cc",
     "src/numbers/math-random.cc",
+    "src/numbers/strtod.cc",
     "src/objects/backing-store.cc",
     "src/objects/bigint.cc",
     "src/objects/code-kind.cc",
@@ -4652,23 +4669,6 @@ v8_component("v8_libbase") {
     "src/base/logging.h",
     "src/base/macros.h",
     "src/base/memory.h",
-    "src/base/numbers/bignum-dtoa.cc",
-    "src/base/numbers/bignum-dtoa.h",
-    "src/base/numbers/bignum.cc",
-    "src/base/numbers/bignum.h",
-    "src/base/numbers/cached-powers.cc",
-    "src/base/numbers/cached-powers.h",
-    "src/base/numbers/diy-fp.cc",
-    "src/base/numbers/diy-fp.h",
-    "src/base/numbers/double.h",
-    "src/base/numbers/dtoa.cc",
-    "src/base/numbers/dtoa.h",
-    "src/base/numbers/fast-dtoa.cc",
-    "src/base/numbers/fast-dtoa.h",
-    "src/base/numbers/fixed-dtoa.cc",
-    "src/base/numbers/fixed-dtoa.h",
-    "src/base/numbers/strtod.cc",
-    "src/base/numbers/strtod.h",
     "src/base/once.cc",
     "src/base/once.h",
     "src/base/optional.h",
diff --git a/src/asmjs/asm-scanner.cc b/src/asmjs/asm-scanner.cc
index f3f99a543c..d9f74628d2 100644
--- a/src/asmjs/asm-scanner.cc
+++ b/src/asmjs/asm-scanner.cc
@@ -85,7 +85,7 @@ void AsmJsScanner::Next() {
 
   for (;;) {
     position_ = stream_->pos();
-    base::uc32 ch = stream_->Advance();
+    uc32 ch = stream_->Advance();
     switch (ch) {
       case ' ':
       case '\t':
@@ -223,7 +223,7 @@ void AsmJsScanner::Seek(size_t pos) {
   Next();
 }
 
-void AsmJsScanner::ConsumeIdentifier(base::uc32 ch) {
+void AsmJsScanner::ConsumeIdentifier(uc32 ch) {
   // Consume characters while still part of the identifier.
   identifier_string_.clear();
   while (IsIdentifierPart(ch)) {
@@ -271,7 +271,7 @@ void AsmJsScanner::ConsumeIdentifier(base::uc32 ch) {
   }
 }
 
-void AsmJsScanner::ConsumeNumber(base::uc32 ch) {
+void AsmJsScanner::ConsumeNumber(uc32 ch) {
   std::string number;
   number.assign(1, ch);
   bool has_dot = ch == '.';
@@ -344,7 +344,7 @@ void AsmJsScanner::ConsumeNumber(base::uc32 ch) {
 
 bool AsmJsScanner::ConsumeCComment() {
   for (;;) {
-    base::uc32 ch = stream_->Advance();
+    uc32 ch = stream_->Advance();
     while (ch == '*') {
       ch = stream_->Advance();
       if (ch == '/') {
@@ -362,7 +362,7 @@ bool AsmJsScanner::ConsumeCComment() {
 
 void AsmJsScanner::ConsumeCPPComment() {
   for (;;) {
-    base::uc32 ch = stream_->Advance();
+    uc32 ch = stream_->Advance();
     if (ch == '\n') {
       preceded_by_newline_ = true;
       return;
@@ -373,11 +373,11 @@ void AsmJsScanner::ConsumeCPPComment() {
   }
 }
 
-void AsmJsScanner::ConsumeString(base::uc32 quote) {
+void AsmJsScanner::ConsumeString(uc32 quote) {
   // Only string allowed is 'use asm' / "use asm".
   const char* expected = "use asm";
   for (; *expected != '\0'; ++expected) {
-    if (stream_->Advance() != static_cast<base::uc32>(*expected)) {
+    if (stream_->Advance() != static_cast<uc32>(*expected)) {
       token_ = kParseError;
       return;
     }
@@ -389,8 +389,8 @@ void AsmJsScanner::ConsumeString(base::uc32 quote) {
   token_ = kToken_UseAsm;
 }
 
-void AsmJsScanner::ConsumeCompareOrShift(base::uc32 ch) {
-  base::uc32 next_ch = stream_->Advance();
+void AsmJsScanner::ConsumeCompareOrShift(uc32 ch) {
+  uc32 next_ch = stream_->Advance();
   if (next_ch == '=') {
     switch (ch) {
       case '<':
@@ -423,16 +423,14 @@ void AsmJsScanner::ConsumeCompareOrShift(base::uc32 ch) {
   }
 }
 
-bool AsmJsScanner::IsIdentifierStart(base::uc32 ch) {
+bool AsmJsScanner::IsIdentifierStart(uc32 ch) {
   return base::IsInRange(AsciiAlphaToLower(ch), 'a', 'z') || ch == '_' ||
          ch == '$';
 }
 
-bool AsmJsScanner::IsIdentifierPart(base::uc32 ch) {
-  return IsAsciiIdentifier(ch);
-}
+bool AsmJsScanner::IsIdentifierPart(uc32 ch) { return IsAsciiIdentifier(ch); }
 
-bool AsmJsScanner::IsNumberStart(base::uc32 ch) {
+bool AsmJsScanner::IsNumberStart(uc32 ch) {
   return ch == '.' || IsDecimalDigit(ch);
 }
 
diff --git a/src/asmjs/asm-scanner.h b/src/asmjs/asm-scanner.h
index 942127eafb..9e7250ff2c 100644
--- a/src/asmjs/asm-scanner.h
+++ b/src/asmjs/asm-scanner.h
@@ -11,7 +11,6 @@
 
 #include "src/asmjs/asm-names.h"
 #include "src/base/logging.h"
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 
 namespace v8 {
@@ -136,8 +135,7 @@ class V8_EXPORT_PRIVATE AsmJsScanner {
   };
   // clang-format on
 
-  static constexpr base::uc32 kEndOfInputU =
-      static_cast<base::uc32>(kEndOfInput);
+  static constexpr uc32 kEndOfInputU = static_cast<uc32>(kEndOfInput);
 
  private:
   Utf16CharacterStream* stream_;
@@ -159,17 +157,17 @@ class V8_EXPORT_PRIVATE AsmJsScanner {
   bool preceded_by_newline_;
 
   // Consume multiple characters.
-  void ConsumeIdentifier(base::uc32 ch);
-  void ConsumeNumber(base::uc32 ch);
+  void ConsumeIdentifier(uc32 ch);
+  void ConsumeNumber(uc32 ch);
   bool ConsumeCComment();
   void ConsumeCPPComment();
-  void ConsumeString(base::uc32 quote);
-  void ConsumeCompareOrShift(base::uc32 ch);
+  void ConsumeString(uc32 quote);
+  void ConsumeCompareOrShift(uc32 ch);
 
   // Classify character categories.
-  bool IsIdentifierStart(base::uc32 ch);
-  bool IsIdentifierPart(base::uc32 ch);
-  bool IsNumberStart(base::uc32 ch);
+  bool IsIdentifierStart(uc32 ch);
+  bool IsIdentifierPart(uc32 ch);
+  bool IsNumberStart(uc32 ch);
 };
 
 }  // namespace internal
diff --git a/src/ast/ast.cc b/src/ast/ast.cc
index cf57b9e9b7..adece37f60 100644
--- a/src/ast/ast.cc
+++ b/src/ast/ast.cc
@@ -11,13 +11,13 @@
 #include "src/ast/scopes.h"
 #include "src/base/hashmap.h"
 #include "src/base/logging.h"
-#include "src/base/numbers/double.h"
 #include "src/base/platform/wrappers.h"
 #include "src/builtins/builtins-constructor.h"
 #include "src/builtins/builtins.h"
 #include "src/common/assert-scope.h"
 #include "src/heap/local-factory-inl.h"
 #include "src/numbers/conversions-inl.h"
+#include "src/numbers/double.h"
 #include "src/objects/contexts.h"
 #include "src/objects/elements-kind.h"
 #include "src/objects/elements.h"
@@ -1044,7 +1044,7 @@ uint32_t Literal::Hash() {
     return ComputeLongHash(index);
   }
   return IsString() ? AsRawString()->Hash()
-                    : ComputeLongHash(base::double_to_uint64(AsNumber()));
+                    : ComputeLongHash(double_to_uint64(AsNumber()));
 }
 
 // static
diff --git a/src/base/strings.h b/src/base/strings.h
index c3015e72c8..c19ff4aaba 100644
--- a/src/base/strings.h
+++ b/src/base/strings.h
@@ -12,13 +12,6 @@
 namespace v8 {
 namespace base {
 
-// Latin1/UTF-16 constants
-// Code-point values in Unicode 4.0 are 21 bits wide.
-// Code units in UTF-16 are 16 bits wide.
-using uc16 = uint16_t;
-using uc32 = uint32_t;
-constexpr int kUC16Size = sizeof(uc16);
-
 V8_BASE_EXPORT int PRINTF_FORMAT(2, 0)
     VSNPrintF(Vector<char> str, const char* format, va_list args);
 
@@ -29,22 +22,6 @@ V8_BASE_EXPORT int PRINTF_FORMAT(2, 3)
 
 V8_BASE_EXPORT void StrNCpy(base::Vector<char> dest, const char* src, size_t n);
 
-// Returns the value (0 .. 15) of a hexadecimal character c.
-// If c is not a legal hexadecimal character, returns a value < 0.
-inline int HexValue(uc32 c) {
-  c -= '0';
-  if (static_cast<unsigned>(c) <= 9) return c;
-  c = (c | 0x20) - ('a' - '0');  // detect 0x11..0x16 and 0x31..0x36.
-  if (static_cast<unsigned>(c) <= 5) return c + 10;
-  return -1;
-}
-
-inline char HexCharOfValue(int value) {
-  DCHECK(0 <= value && value <= 16);
-  if (value < 10) return value + '0';
-  return value - 10 + 'A';
-}
-
 }  // namespace base
 }  // namespace v8
 
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index 4bb39b4f4f..6ebd820d77 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -525,7 +525,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
     pushed_stack_space += kNumDoubleCalleeSaved * kDoubleSize;
 
     // Set up the reserved register for 0.0.
-    __ vmov(kDoubleRegZero, base::Double(0.0));
+    __ vmov(kDoubleRegZero, Double(0.0));
 
     // Initialize the root register.
     // C calling convention. The first argument is passed in r0.
diff --git a/src/builtins/builtins-string-gen.cc b/src/builtins/builtins-string-gen.cc
index 61c1d8d387..d0b480a98c 100644
--- a/src/builtins/builtins-string-gen.cc
+++ b/src/builtins/builtins-string-gen.cc
@@ -4,7 +4,6 @@
 
 #include "src/builtins/builtins-string-gen.h"
 
-#include "src/base/strings.h"
 #include "src/builtins/builtins-regexp-gen.h"
 #include "src/builtins/builtins-utils-gen.h"
 #include "src/builtins/builtins.h"
@@ -74,7 +73,7 @@ TNode<IntPtrT> StringBuiltinsAssembler::SearchOneByteStringInTwoByteString(
     const TNode<RawPtrT> subject_ptr, const TNode<IntPtrT> subject_length,
     const TNode<RawPtrT> search_ptr, const TNode<IntPtrT> search_length,
     const TNode<IntPtrT> start_position) {
-  return CallSearchStringRaw<const base::uc16, const uint8_t>(
+  return CallSearchStringRaw<const uc16, const uint8_t>(
       subject_ptr, subject_length, search_ptr, search_length, start_position);
 }
 TNode<IntPtrT> StringBuiltinsAssembler::SearchOneByteStringInOneByteString(
@@ -88,14 +87,14 @@ TNode<IntPtrT> StringBuiltinsAssembler::SearchTwoByteStringInTwoByteString(
     const TNode<RawPtrT> subject_ptr, const TNode<IntPtrT> subject_length,
     const TNode<RawPtrT> search_ptr, const TNode<IntPtrT> search_length,
     const TNode<IntPtrT> start_position) {
-  return CallSearchStringRaw<const base::uc16, const base::uc16>(
+  return CallSearchStringRaw<const uc16, const uc16>(
       subject_ptr, subject_length, search_ptr, search_length, start_position);
 }
 TNode<IntPtrT> StringBuiltinsAssembler::SearchTwoByteStringInOneByteString(
     const TNode<RawPtrT> subject_ptr, const TNode<IntPtrT> subject_length,
     const TNode<RawPtrT> search_ptr, const TNode<IntPtrT> search_length,
     const TNode<IntPtrT> start_position) {
-  return CallSearchStringRaw<const uint8_t, const base::uc16>(
+  return CallSearchStringRaw<const uint8_t, const uc16>(
       subject_ptr, subject_length, search_ptr, search_length, start_position);
 }
 TNode<IntPtrT> StringBuiltinsAssembler::SearchOneByteInOneByteString(
diff --git a/src/builtins/builtins-string.cc b/src/builtins/builtins-string.cc
index 950cefd7ba..16326794c9 100644
--- a/src/builtins/builtins-string.cc
+++ b/src/builtins/builtins-string.cc
@@ -11,7 +11,6 @@
 #ifdef V8_INTL_SUPPORT
 #include "src/objects/intl-objects.h"
 #endif
-#include "src/base/strings.h"
 #include "src/regexp/regexp-utils.h"
 #include "src/strings/string-builder-inl.h"
 #include "src/strings/string-case.h"
@@ -41,9 +40,9 @@ bool IsValidCodePoint(Isolate* isolate, Handle<Object> value) {
   return true;
 }
 
-static constexpr base::uc32 kInvalidCodePoint = static_cast<base::uc32>(-1);
+static constexpr uc32 kInvalidCodePoint = static_cast<uc32>(-1);
 
-base::uc32 NextCodePoint(Isolate* isolate, BuiltinArguments args, int index) {
+uc32 NextCodePoint(Isolate* isolate, BuiltinArguments args, int index) {
   Handle<Object> value = args.at(1 + index);
   ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, value, Object::ToNumber(isolate, value), kInvalidCodePoint);
@@ -68,7 +67,7 @@ BUILTIN(StringFromCodePoint) {
   // characters.
   std::vector<uint8_t> one_byte_buffer;
   one_byte_buffer.reserve(length);
-  base::uc32 code = 0;
+  uc32 code = 0;
   int index;
   for (index = 0; index < length; index++) {
     code = NextCodePoint(isolate, args, index);
@@ -87,12 +86,11 @@ BUILTIN(StringFromCodePoint) {
                      one_byte_buffer.data(), one_byte_buffer.size())));
   }
 
-  std::vector<base::uc16> two_byte_buffer;
+  std::vector<uc16> two_byte_buffer;
   two_byte_buffer.reserve(length - index);
 
   while (true) {
-    if (code <=
-        static_cast<base::uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
+    if (code <= static_cast<uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
       two_byte_buffer.push_back(code);
     } else {
       two_byte_buffer.push_back(unibrow::Utf16::LeadSurrogate(code));
@@ -232,11 +230,11 @@ BUILTIN(StringPrototypeNormalize) {
 #ifndef V8_INTL_SUPPORT
 namespace {
 
-inline bool ToUpperOverflows(base::uc32 character) {
+inline bool ToUpperOverflows(uc32 character) {
   // y with umlauts and the micro sign are the only characters that stop
   // fitting into one-byte when converting to uppercase.
-  static const base::uc32 yuml_code = 0xFF;
-  static const base::uc32 micro_code = 0xB5;
+  static const uc32 yuml_code = 0xFF;
+  static const uc32 micro_code = 0xB5;
   return (character == yuml_code || character == micro_code);
 }
 
@@ -261,11 +259,11 @@ V8_WARN_UNUSED_RESULT static Object ConvertCaseHelper(
   StringCharacterStream stream(string);
   unibrow::uchar chars[Converter::kMaxWidth];
   // We can assume that the string is not empty
-  base::uc32 current = stream.GetNext();
+  uc32 current = stream.GetNext();
   bool ignore_overflow = Converter::kIsToLower || result.IsSeqTwoByteString();
   for (int i = 0; i < result_length;) {
     bool has_next = stream.HasMore();
-    base::uc32 next = has_next ? stream.GetNext() : 0;
+    uc32 next = has_next ? stream.GetNext() : 0;
     int char_length = mapping->get(current, next, chars);
     if (char_length == 0) {
       // The case conversion of this character is the character itself.
@@ -274,7 +272,7 @@ V8_WARN_UNUSED_RESULT static Object ConvertCaseHelper(
     } else if (char_length == 1 &&
                (ignore_overflow || !ToUpperOverflows(current))) {
       // Common case: converting the letter resulted in one character.
-      DCHECK(static_cast<base::uc32>(chars[0]) != current);
+      DCHECK(static_cast<uc32>(chars[0]) != current);
       result.Set(i, chars[0]);
       has_changed_character = true;
       i++;
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 6df499ec47..3bbd350d03 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -3103,8 +3103,7 @@ void Builtins::Generate_DoubleToI(MacroAssembler* masm) {
   __ j(below, &process_64_bits);
 
   // Result is entirely in lower 32-bits of mantissa
-  int delta =
-      HeapNumber::kExponentBias + base::Double::kPhysicalSignificandSize;
+  int delta = HeapNumber::kExponentBias + Double::kPhysicalSignificandSize;
   if (CpuFeatures::IsSupported(SSE3)) {
     __ fstp(0);
   }
@@ -3130,11 +3129,10 @@ void Builtins::Generate_DoubleToI(MacroAssembler* masm) {
     __ sub(ecx, Immediate(delta));
     __ neg(ecx);
     __ mov(result_reg, exponent_operand);
-    __ and_(
-        result_reg,
-        Immediate(static_cast<uint32_t>(base::Double::kSignificandMask >> 32)));
+    __ and_(result_reg,
+            Immediate(static_cast<uint32_t>(Double::kSignificandMask >> 32)));
     __ add(result_reg,
-           Immediate(static_cast<uint32_t>(base::Double::kHiddenBit >> 32)));
+           Immediate(static_cast<uint32_t>(Double::kHiddenBit >> 32)));
     __ shrd_cl(scratch1, result_reg);
     __ shr_cl(result_reg);
     __ test(ecx, Immediate(32));
diff --git a/src/builtins/ppc/builtins-ppc.cc b/src/builtins/ppc/builtins-ppc.cc
index f01a518cd3..6b9030e632 100644
--- a/src/builtins/ppc/builtins-ppc.cc
+++ b/src/builtins/ppc/builtins-ppc.cc
@@ -527,7 +527,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
     // Save callee-saved double registers.
     __ MultiPushDoubles(kCalleeSavedDoubles);
     // Set up the reserved register for 0.0.
-    __ LoadDoubleLiteral(kDoubleRegZero, base::Double(0.0), r0);
+    __ LoadDoubleLiteral(kDoubleRegZero, Double(0.0), r0);
 
     // Initialize the root register.
     // C calling convention. The first argument is passed in r3.
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index 2be0fac3a3..981142ba6a 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -3772,8 +3772,7 @@ void Builtins::Generate_DoubleToI(MacroAssembler* masm) {
   __ j(below, &process_64_bits, Label::kNear);
 
   // Result is entirely in lower 32-bits of mantissa
-  int delta =
-      HeapNumber::kExponentBias + base::Double::kPhysicalSignificandSize;
+  int delta = HeapNumber::kExponentBias + Double::kPhysicalSignificandSize;
   __ subl(rcx, Immediate(delta));
   __ xorl(result_reg, result_reg);
   __ cmpl(rcx, Immediate(31));
diff --git a/src/codegen/arm/assembler-arm.cc b/src/codegen/arm/assembler-arm.cc
index a79622be13..a81ef98f2a 100644
--- a/src/codegen/arm/assembler-arm.cc
+++ b/src/codegen/arm/assembler-arm.cc
@@ -2674,7 +2674,7 @@ void Assembler::vstm(BlockAddrMode am, Register base, SwVfpRegister first,
        0xA * B8 | count);
 }
 
-static void DoubleAsTwoUInt32(base::Double d, uint32_t* lo, uint32_t* hi) {
+static void DoubleAsTwoUInt32(Double d, uint32_t* lo, uint32_t* hi) {
   uint64_t i = d.AsUint64();
 
   *lo = i & 0xFFFFFFFF;
@@ -2747,7 +2747,7 @@ void Assembler::vmov(const QwNeonRegister dst, uint64_t imm) {
 
 // Only works for little endian floating point formats.
 // We don't support VFP on the mixed endian floating point platform.
-static bool FitsVmovFPImmediate(base::Double d, uint32_t* encoding) {
+static bool FitsVmovFPImmediate(Double d, uint32_t* encoding) {
   // VMOV can accept an immediate of the form:
   //
   //  +/- m * 2^(-n) where 16 <= m <= 31 and 0 <= n <= 7
@@ -2796,7 +2796,7 @@ static bool FitsVmovFPImmediate(base::Double d, uint32_t* encoding) {
 void Assembler::vmov(const SwVfpRegister dst, Float32 imm) {
   uint32_t enc;
   if (CpuFeatures::IsSupported(VFPv3) &&
-      FitsVmovFPImmediate(base::Double(imm.get_scalar()), &enc)) {
+      FitsVmovFPImmediate(Double(imm.get_scalar()), &enc)) {
     CpuFeatureScope scope(this, VFPv3);
     // The float can be encoded in the instruction.
     //
@@ -2815,7 +2815,7 @@ void Assembler::vmov(const SwVfpRegister dst, Float32 imm) {
   }
 }
 
-void Assembler::vmov(const DwVfpRegister dst, base::Double imm,
+void Assembler::vmov(const DwVfpRegister dst, Double imm,
                      const Register extra_scratch) {
   DCHECK(VfpRegisterIsAvailable(dst));
   uint32_t enc;
diff --git a/src/codegen/arm/assembler-arm.h b/src/codegen/arm/assembler-arm.h
index 93dbba7d2d..330192de9e 100644
--- a/src/codegen/arm/assembler-arm.h
+++ b/src/codegen/arm/assembler-arm.h
@@ -45,13 +45,13 @@
 #include <memory>
 #include <vector>
 
-#include "src/base/numbers/double.h"
 #include "src/base/small-vector.h"
 #include "src/codegen/arm/constants-arm.h"
 #include "src/codegen/arm/register-arm.h"
 #include "src/codegen/assembler.h"
 #include "src/codegen/constant-pool.h"
 #include "src/codegen/machine-type.h"
+#include "src/numbers/double.h"
 #include "src/utils/boxed-float.h"
 
 namespace v8 {
@@ -712,7 +712,7 @@ class V8_EXPORT_PRIVATE Assembler : public AssemblerBase {
             SwVfpRegister last, Condition cond = al);
 
   void vmov(const SwVfpRegister dst, Float32 imm);
-  void vmov(const DwVfpRegister dst, base::Double imm,
+  void vmov(const DwVfpRegister dst, Double imm,
             const Register extra_scratch = no_reg);
   void vmov(const SwVfpRegister dst, const SwVfpRegister src,
             const Condition cond = al);
diff --git a/src/codegen/arm/macro-assembler-arm.cc b/src/codegen/arm/macro-assembler-arm.cc
index 49cb9d292c..f118381e0f 100644
--- a/src/codegen/arm/macro-assembler-arm.cc
+++ b/src/codegen/arm/macro-assembler-arm.cc
@@ -8,7 +8,6 @@
 
 #include "src/base/bits.h"
 #include "src/base/division-by-constant.h"
-#include "src/base/numbers/double.h"
 #include "src/base/utils/random-number-generator.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/callable.h"
@@ -22,6 +21,7 @@
 #include "src/heap/memory-chunk.h"
 #include "src/init/bootstrapper.h"
 #include "src/logging/counters.h"
+#include "src/numbers/double.h"
 #include "src/objects/objects-inl.h"
 #include "src/runtime/runtime.h"
 #include "src/snapshot/snapshot.h"
diff --git a/src/codegen/constant-pool.h b/src/codegen/constant-pool.h
index 47346d3455..fb4147507c 100644
--- a/src/codegen/constant-pool.h
+++ b/src/codegen/constant-pool.h
@@ -7,10 +7,10 @@
 
 #include <map>
 
-#include "src/base/numbers/double.h"
 #include "src/codegen/label.h"
 #include "src/codegen/reloc-info.h"
 #include "src/common/globals.h"
+#include "src/numbers/double.h"
 
 namespace v8 {
 namespace internal {
@@ -29,7 +29,7 @@ class ConstantPoolEntry {
         merged_index_(sharing_ok ? SHARING_ALLOWED : SHARING_PROHIBITED),
         value_(value),
         rmode_(rmode) {}
-  ConstantPoolEntry(int position, base::Double value,
+  ConstantPoolEntry(int position, Double value,
                     RelocInfo::Mode rmode = RelocInfo::NONE)
       : position_(position),
         merged_index_(SHARING_ALLOWED),
@@ -106,14 +106,14 @@ class ConstantPoolBuilder {
   }
 
   // Add double constant to the embedded constant pool
-  ConstantPoolEntry::Access AddEntry(int position, base::Double value) {
+  ConstantPoolEntry::Access AddEntry(int position, Double value) {
     ConstantPoolEntry entry(position, value);
     return AddEntry(&entry, ConstantPoolEntry::DOUBLE);
   }
 
   // Add double constant to the embedded constant pool
   ConstantPoolEntry::Access AddEntry(int position, double value) {
-    return AddEntry(position, base::Double(value));
+    return AddEntry(position, Double(value));
   }
 
   // Previews the access type required for the next new entry to be added.
diff --git a/src/codegen/external-reference.cc b/src/codegen/external-reference.cc
index 646e344113..ac850eb196 100644
--- a/src/codegen/external-reference.cc
+++ b/src/codegen/external-reference.cc
@@ -37,7 +37,6 @@
 
 #ifdef V8_INTL_SUPPORT
 #include "src/base/platform/wrappers.h"
-#include "src/base/strings.h"
 #include "src/objects/intl-objects.h"
 #endif  // V8_INTL_SUPPORT
 
@@ -836,15 +835,15 @@ ExternalReference ExternalReference::search_string_raw_one_one() {
 }
 
 ExternalReference ExternalReference::search_string_raw_one_two() {
-  return search_string_raw<const uint8_t, const base::uc16>();
+  return search_string_raw<const uint8_t, const uc16>();
 }
 
 ExternalReference ExternalReference::search_string_raw_two_one() {
-  return search_string_raw<const base::uc16, const uint8_t>();
+  return search_string_raw<const uc16, const uint8_t>();
 }
 
 ExternalReference ExternalReference::search_string_raw_two_two() {
-  return search_string_raw<const base::uc16, const base::uc16>();
+  return search_string_raw<const uc16, const uc16>();
 }
 
 namespace {
@@ -962,11 +961,11 @@ ExternalReference ExternalReference::intl_to_latin1_lower_table() {
 template ExternalReference
 ExternalReference::search_string_raw<const uint8_t, const uint8_t>();
 template ExternalReference
-ExternalReference::search_string_raw<const uint8_t, const base::uc16>();
+ExternalReference::search_string_raw<const uint8_t, const uc16>();
 template ExternalReference
-ExternalReference::search_string_raw<const base::uc16, const uint8_t>();
+ExternalReference::search_string_raw<const uc16, const uint8_t>();
 template ExternalReference
-ExternalReference::search_string_raw<const base::uc16, const base::uc16>();
+ExternalReference::search_string_raw<const uc16, const uc16>();
 
 ExternalReference ExternalReference::FromRawAddress(Address address) {
   return ExternalReference(address);
diff --git a/src/codegen/mips64/macro-assembler-mips64.cc b/src/codegen/mips64/macro-assembler-mips64.cc
index 784d08ca01..b74659e918 100644
--- a/src/codegen/mips64/macro-assembler-mips64.cc
+++ b/src/codegen/mips64/macro-assembler-mips64.cc
@@ -2142,7 +2142,7 @@ void TurboAssembler::Neg_d(FPURegister fd, FPURegister fs) {
     neg_d(fd, fs);  // In delay slot.
     bind(&is_nan);
     dmfc1(scratch1, fs);
-    li(scratch2, base::Double::kSignMask);
+    li(scratch2, Double::kSignMask);
     Xor(scratch1, scratch1, scratch2);
     dmtc1(scratch1, fd);
     bind(&done);
diff --git a/src/codegen/ppc/assembler-ppc.h b/src/codegen/ppc/assembler-ppc.h
index 74050c2382..76b85b07cc 100644
--- a/src/codegen/ppc/assembler-ppc.h
+++ b/src/codegen/ppc/assembler-ppc.h
@@ -41,17 +41,16 @@
 #define V8_CODEGEN_PPC_ASSEMBLER_PPC_H_
 
 #include <stdio.h>
-
 #include <memory>
 #include <vector>
 
-#include "src/base/numbers/double.h"
 #include "src/codegen/assembler.h"
 #include "src/codegen/constant-pool.h"
 #include "src/codegen/external-reference.h"
 #include "src/codegen/label.h"
 #include "src/codegen/ppc/constants-ppc.h"
 #include "src/codegen/ppc/register-ppc.h"
+#include "src/numbers/double.h"
 #include "src/objects/smi.h"
 
 namespace v8 {
@@ -1252,7 +1251,7 @@ class Assembler : public AssemblerBase {
          !RelocInfo::IsWasmCall(rmode) && !RelocInfo::IsWasmStubCall(rmode));
     return constant_pool_builder_.AddEntry(pc_offset(), value, sharing_ok);
   }
-  ConstantPoolEntry::Access ConstantPoolAddEntry(base::Double value) {
+  ConstantPoolEntry::Access ConstantPoolAddEntry(Double value) {
     return constant_pool_builder_.AddEntry(pc_offset(), value);
   }
 
diff --git a/src/codegen/ppc/macro-assembler-ppc.cc b/src/codegen/ppc/macro-assembler-ppc.cc
index 5acdb97357..e1cea12281 100644
--- a/src/codegen/ppc/macro-assembler-ppc.cc
+++ b/src/codegen/ppc/macro-assembler-ppc.cc
@@ -2341,8 +2341,8 @@ void TurboAssembler::LoadSmiLiteral(Register dst, Smi smi) {
   mov(dst, Operand(smi));
 }
 
-void TurboAssembler::LoadDoubleLiteral(DoubleRegister result,
-                                       base::Double value, Register scratch) {
+void TurboAssembler::LoadDoubleLiteral(DoubleRegister result, Double value,
+                                       Register scratch) {
   if (FLAG_enable_embedded_constant_pool && is_constant_pool_available() &&
       !(scratch == r0 && ConstantPoolAccessIsInOverflow())) {
     ConstantPoolEntry::Access access = ConstantPoolAddEntry(value);
diff --git a/src/codegen/ppc/macro-assembler-ppc.h b/src/codegen/ppc/macro-assembler-ppc.h
index 2fe383dd65..7f7d0e787f 100644
--- a/src/codegen/ppc/macro-assembler-ppc.h
+++ b/src/codegen/ppc/macro-assembler-ppc.h
@@ -9,10 +9,10 @@
 #ifndef V8_CODEGEN_PPC_MACRO_ASSEMBLER_PPC_H_
 #define V8_CODEGEN_PPC_MACRO_ASSEMBLER_PPC_H_
 
-#include "src/base/numbers/double.h"
 #include "src/codegen/bailout-reason.h"
 #include "src/codegen/ppc/assembler-ppc.h"
 #include "src/common/globals.h"
+#include "src/numbers/double.h"
 #include "src/objects/contexts.h"
 
 namespace v8 {
@@ -138,8 +138,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
     mov(kRootRegister, Operand(isolate_root));
   }
 
-  void LoadDoubleLiteral(DoubleRegister result, base::Double value,
-                         Register scratch);
+  void LoadDoubleLiteral(DoubleRegister result, Double value, Register scratch);
   void LoadSimd128(Simd128Register dst, const MemOperand& mem);
 
   // load a literal signed int value <value> to GPR <dst>
diff --git a/src/common/globals.h b/src/common/globals.h
index b2bfb19d6e..9ab29ce954 100644
--- a/src/common/globals.h
+++ b/src/common/globals.h
@@ -223,7 +223,7 @@ constexpr int kElidedFrameSlots = 0;
 constexpr int kDoubleSizeLog2 = 3;
 // The maximal length of the string representation for a double value
 // (e.g. "-2.2250738585072020E-308"). It is composed as follows:
-// - 17 decimal digits, see base::kBase10MaximalLength (dtoa.h)
+// - 17 decimal digits, see kBase10MaximalLength (dtoa.h)
 // - 1 sign
 // - 1 decimal point
 // - 1 E or e
@@ -379,7 +379,13 @@ constexpr int kBinary32ExponentShift = 23;
 // other bits set.
 constexpr uint64_t kQuietNaNMask = static_cast<uint64_t>(0xfff) << 51;
 
+// Latin1/UTF-16 constants
+// Code-point values in Unicode 4.0 are 21 bits wide.
+// Code units in UTF-16 are 16 bits wide.
+using uc16 = uint16_t;
+using uc32 = uint32_t;
 constexpr int kOneByteSize = kCharSize;
+constexpr int kUC16Size = sizeof(uc16);
 
 // 128 bit SIMD value size.
 constexpr int kSimd128Size = 16;
diff --git a/src/compiler/backend/arm/code-generator-arm.cc b/src/compiler/backend/arm/code-generator-arm.cc
index 31d21fc389..b8a1c81937 100644
--- a/src/compiler/backend/arm/code-generator-arm.cc
+++ b/src/compiler/backend/arm/code-generator-arm.cc
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/double.h"
 #include "src/codegen/arm/constants-arm.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
@@ -14,6 +13,7 @@
 #include "src/compiler/node-matchers.h"
 #include "src/compiler/osr.h"
 #include "src/heap/memory-chunk.h"
+#include "src/numbers/double.h"
 #include "src/utils/boxed-float.h"
 
 #if V8_ENABLE_WEBASSEMBLY
@@ -2511,8 +2511,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       __ vshr(NeonS32, tmp, src, 31);
       // Set i-th bit of each lane i. When AND with tmp, the lanes that
       // are signed will have i-th bit set, unsigned will be 0.
-      __ vmov(mask.low(), base::Double(uint64_t{0x0000'0002'0000'0001}));
-      __ vmov(mask.high(), base::Double(uint64_t{0x0000'0008'0000'0004}));
+      __ vmov(mask.low(), Double(uint64_t{0x0000'0002'0000'0001}));
+      __ vmov(mask.high(), Double(uint64_t{0x0000'0008'0000'0004}));
       __ vand(tmp, mask, tmp);
       __ vpadd(Neon32, tmp.low(), tmp.low(), tmp.high());
       __ vpadd(Neon32, tmp.low(), tmp.low(), kDoubleRegZero);
@@ -2715,8 +2715,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       __ vshr(NeonS16, tmp, src, 15);
       // Set i-th bit of each lane i. When AND with tmp, the lanes that
       // are signed will have i-th bit set, unsigned will be 0.
-      __ vmov(mask.low(), base::Double(uint64_t{0x0008'0004'0002'0001}));
-      __ vmov(mask.high(), base::Double(uint64_t{0x0080'0040'0020'0010}));
+      __ vmov(mask.low(), Double(uint64_t{0x0008'0004'0002'0001}));
+      __ vmov(mask.high(), Double(uint64_t{0x0080'0040'0020'0010}));
       __ vand(tmp, mask, tmp);
       __ vpadd(Neon16, tmp.low(), tmp.low(), tmp.high());
       __ vpadd(Neon16, tmp.low(), tmp.low(), tmp.low());
@@ -2870,8 +2870,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       __ vshr(NeonS8, tmp, src, 7);
       // Set i-th bit of each lane i. When AND with tmp, the lanes that
       // are signed will have i-th bit set, unsigned will be 0.
-      __ vmov(mask.low(), base::Double(uint64_t{0x8040'2010'0804'0201}));
-      __ vmov(mask.high(), base::Double(uint64_t{0x8040'2010'0804'0201}));
+      __ vmov(mask.low(), Double(uint64_t{0x8040'2010'0804'0201}));
+      __ vmov(mask.high(), Double(uint64_t{0x8040'2010'0804'0201}));
       __ vand(tmp, mask, tmp);
       __ vext(mask, tmp, tmp, 8);
       __ vzip(Neon8, mask, tmp);
@@ -2885,8 +2885,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
       QwNeonRegister dst = i.OutputSimd128Register();
       uint64_t imm1 = make_uint64(i.InputUint32(1), i.InputUint32(0));
       uint64_t imm2 = make_uint64(i.InputUint32(3), i.InputUint32(2));
-      __ vmov(dst.low(), base::Double(imm1));
-      __ vmov(dst.high(), base::Double(imm2));
+      __ vmov(dst.low(), Double(imm1));
+      __ vmov(dst.high(), Double(imm2));
       break;
     }
     case kArmS128Zero: {
diff --git a/src/compiler/backend/instruction.h b/src/compiler/backend/instruction.h
index f20955727a..550ce01dc2 100644
--- a/src/compiler/backend/instruction.h
+++ b/src/compiler/backend/instruction.h
@@ -11,7 +11,6 @@
 #include <set>
 
 #include "src/base/compiler-specific.h"
-#include "src/base/numbers/double.h"
 #include "src/codegen/external-reference.h"
 #include "src/codegen/register-arch.h"
 #include "src/codegen/source-position.h"
@@ -21,6 +20,7 @@
 #include "src/compiler/feedback-source.h"
 #include "src/compiler/frame.h"
 #include "src/compiler/opcodes.h"
+#include "src/numbers/double.h"
 #include "src/zone/zone-allocator.h"
 
 namespace v8 {
@@ -1147,9 +1147,9 @@ class V8_EXPORT_PRIVATE Constant final {
     return bit_cast<uint32_t>(static_cast<int32_t>(value_));
   }
 
-  base::Double ToFloat64() const {
+  Double ToFloat64() const {
     DCHECK_EQ(kFloat64, type());
-    return base::Double(bit_cast<uint64_t>(value_));
+    return Double(bit_cast<uint64_t>(value_));
   }
 
   ExternalReference ToExternalReference() const {
diff --git a/src/compiler/backend/ppc/code-generator-ppc.cc b/src/compiler/backend/ppc/code-generator-ppc.cc
index 6c81d03b61..767ce63256 100644
--- a/src/compiler/backend/ppc/code-generator-ppc.cc
+++ b/src/compiler/backend/ppc/code-generator-ppc.cc
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/double.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/callable.h"
 #include "src/codegen/macro-assembler.h"
@@ -13,6 +12,7 @@
 #include "src/compiler/node-matchers.h"
 #include "src/compiler/osr.h"
 #include "src/heap/memory-chunk.h"
+#include "src/numbers/double.h"
 
 #if V8_ENABLE_WEBASSEMBLY
 #include "src/wasm/wasm-code-manager.h"
@@ -4435,7 +4435,7 @@ void CodeGenerator::AssembleMove(InstructionOperand* source,
       DoubleRegister dst = destination->IsFPRegister()
                                ? g.ToDoubleRegister(destination)
                                : kScratchDoubleReg;
-      base::Double value;
+      Double value;
 #if V8_HOST_ARCH_IA32 || V8_HOST_ARCH_X64
       // casting double precision snan to single precision
       // converts it to qnan on ia32/x64
@@ -4445,17 +4445,17 @@ void CodeGenerator::AssembleMove(InstructionOperand* source,
           uint64_t dval = static_cast<uint64_t>(val);
           dval = ((dval & 0xC0000000) << 32) | ((dval & 0x40000000) << 31) |
                  ((dval & 0x40000000) << 30) | ((dval & 0x7FFFFFFF) << 29);
-          value = base::Double(dval);
+          value = Double(dval);
         } else {
-          value = base::Double(static_cast<double>(src.ToFloat32()));
+          value = Double(static_cast<double>(src.ToFloat32()));
         }
       } else {
-        value = base::Double(src.ToFloat64());
+        value = Double(src.ToFloat64());
       }
 #else
       value = src.type() == Constant::kFloat32
-                  ? base::Double(static_cast<double>(src.ToFloat32()))
-                  : base::Double(src.ToFloat64());
+                  ? Double(static_cast<double>(src.ToFloat32()))
+                  : Double(src.ToFloat64());
 #endif
       __ LoadDoubleLiteral(dst, value, kScratchReg);
       if (destination->IsDoubleStackSlot()) {
diff --git a/src/compiler/machine-operator-reducer.cc b/src/compiler/machine-operator-reducer.cc
index 1282d99ac9..5d61dfac6a 100644
--- a/src/compiler/machine-operator-reducer.cc
+++ b/src/compiler/machine-operator-reducer.cc
@@ -544,7 +544,7 @@ Reduction MachineOperatorReducer::Reduce(Node* node) {
     case IrOpcode::kFloat64Sub: {
       Float64BinopMatcher m(node);
       if (allow_signalling_nan_ && m.right().Is(0) &&
-          (base::Double(m.right().ResolvedValue()).Sign() > 0)) {
+          (Double(m.right().ResolvedValue()).Sign() > 0)) {
         return Replace(m.left().node());  // x - 0 => x
       }
       if (m.right().IsNaN()) {  // x - NaN => NaN
diff --git a/src/compiler/node-matchers.h b/src/compiler/node-matchers.h
index 1ce4023424..05ba661b51 100644
--- a/src/compiler/node-matchers.h
+++ b/src/compiler/node-matchers.h
@@ -10,13 +10,13 @@
 
 #include "src/base/bounds.h"
 #include "src/base/compiler-specific.h"
-#include "src/base/numbers/double.h"
 #include "src/codegen/external-reference.h"
 #include "src/common/globals.h"
 #include "src/compiler/common-operator.h"
 #include "src/compiler/machine-operator.h"
 #include "src/compiler/node.h"
 #include "src/compiler/operator.h"
+#include "src/numbers/double.h"
 #include "src/objects/heap-object.h"
 
 namespace v8 {
@@ -216,7 +216,7 @@ struct FloatMatcher final : public ValueMatcher<T, kOpcode> {
     if (!this->HasResolvedValue() || (this->ResolvedValue() == 0.0)) {
       return false;
     }
-    base::Double value = base::Double(this->ResolvedValue());
+    Double value = Double(this->ResolvedValue());
     return !value.IsInfinite() && base::bits::IsPowerOfTwo(value.Significand());
   }
 };
diff --git a/src/diagnostics/objects-debug.cc b/src/diagnostics/objects-debug.cc
index 08e819a453..4fbf628ed8 100644
--- a/src/diagnostics/objects-debug.cc
+++ b/src/diagnostics/objects-debug.cc
@@ -79,7 +79,6 @@
 #include "torque-generated/class-verifiers.h"
 
 #if V8_ENABLE_WEBASSEMBLY
-#include "src/base/strings.h"
 #include "src/debug/debug-wasm-objects-inl.h"
 #include "src/wasm/wasm-objects-inl.h"
 #endif  // V8_ENABLE_WEBASSEMBLY
diff --git a/src/extensions/externalize-string-extension.cc b/src/extensions/externalize-string-extension.cc
index 755023d8d6..3e42b214de 100644
--- a/src/extensions/externalize-string-extension.cc
+++ b/src/extensions/externalize-string-extension.cc
@@ -5,7 +5,6 @@
 #include "src/extensions/externalize-string-extension.h"
 
 #include "src/api/api-inl.h"
-#include "src/base/strings.h"
 #include "src/execution/isolate.h"
 #include "src/handles/handles.h"
 #include "src/objects/objects-inl.h"
@@ -35,7 +34,7 @@ class SimpleStringResource : public Base {
 using SimpleOneByteStringResource =
     SimpleStringResource<char, v8::String::ExternalOneByteStringResource>;
 using SimpleTwoByteStringResource =
-    SimpleStringResource<base::uc16, v8::String::ExternalStringResource>;
+    SimpleStringResource<uc16, v8::String::ExternalStringResource>;
 
 const char* const ExternalizeStringExtension::kSource =
     "native function externalizeString();"
@@ -88,7 +87,7 @@ void ExternalizeStringExtension::Externalize(
     result = Utils::ToLocal(string)->MakeExternal(resource);
     if (!result) delete resource;
   } else {
-    base::uc16* data = new base::uc16[string->length()];
+    uc16* data = new uc16[string->length()];
     String::WriteToFlat(*string, data, 0, string->length());
     SimpleTwoByteStringResource* resource = new SimpleTwoByteStringResource(
         data, string->length());
diff --git a/src/heap/factory-base.cc b/src/heap/factory-base.cc
index e7a536d04d..6c1db3e0e7 100644
--- a/src/heap/factory-base.cc
+++ b/src/heap/factory-base.cc
@@ -530,12 +530,12 @@ Handle<SeqOneByteString> FactoryBase<Impl>::NewOneByteInternalizedString(
 
 template <typename Impl>
 Handle<SeqTwoByteString> FactoryBase<Impl>::NewTwoByteInternalizedString(
-    const base::Vector<const base::uc16>& str, uint32_t raw_hash_field) {
+    const base::Vector<const uc16>& str, uint32_t raw_hash_field) {
   Handle<SeqTwoByteString> result =
       AllocateRawTwoByteInternalizedString(str.length(), raw_hash_field);
   DisallowGarbageCollection no_gc;
   MemCopy(result->GetChars(no_gc, SharedStringAccessGuardIfNeeded::NotNeeded()),
-          str.begin(), str.length() * base::kUC16Size);
+          str.begin(), str.length() * kUC16Size);
   return result;
 }
 
@@ -643,7 +643,7 @@ MaybeHandle<String> FactoryBase<Impl>::NewConsString(
 
     DisallowGarbageCollection no_gc;
     SharedStringAccessGuardIfNeeded access_guard(isolate());
-    base::uc16* sink = result->GetChars(no_gc, access_guard);
+    uc16* sink = result->GetChars(no_gc, access_guard);
     String::WriteToFlat(*left, sink, 0, left->length(), access_guard);
     String::WriteToFlat(*right, sink + left->length(), 0, right->length(),
                         access_guard);
diff --git a/src/heap/factory-base.h b/src/heap/factory-base.h
index 1db522d6e2..ecb73271d9 100644
--- a/src/heap/factory-base.h
+++ b/src/heap/factory-base.h
@@ -6,7 +6,6 @@
 #define V8_HEAP_FACTORY_BASE_H_
 
 #include "src/base/export-template.h"
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 #include "src/objects/function-kind.h"
 #include "src/objects/instance-type.h"
@@ -183,7 +182,7 @@ class EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) FactoryBase
   Handle<SeqOneByteString> NewOneByteInternalizedString(
       const base::Vector<const uint8_t>& str, uint32_t raw_hash_field);
   Handle<SeqTwoByteString> NewTwoByteInternalizedString(
-      const base::Vector<const base::uc16>& str, uint32_t raw_hash_field);
+      const base::Vector<const uc16>& str, uint32_t raw_hash_field);
 
   Handle<SeqOneByteString> AllocateRawOneByteInternalizedString(
       int length, uint32_t raw_hash_field);
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index 25452a11ce..5de59f9ff6 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -689,7 +689,7 @@ Handle<String> Factory::InternalizeUtf8String(
   std::unique_ptr<uint16_t[]> buffer(new uint16_t[decoder.utf16_length()]);
   decoder.Decode(buffer.get(), utf8_data);
   return InternalizeString(
-      base::Vector<const base::uc16>(buffer.get(), decoder.utf16_length()));
+      base::Vector<const uc16>(buffer.get(), decoder.utf16_length()));
 }
 
 template <typename SeqString>
@@ -811,7 +811,7 @@ MaybeHandle<String> Factory::NewStringFromUtf8SubString(
   return result;
 }
 
-MaybeHandle<String> Factory::NewStringFromTwoByte(const base::uc16* string,
+MaybeHandle<String> Factory::NewStringFromTwoByte(const uc16* string,
                                                   int length,
                                                   AllocationType allocation) {
   DCHECK_NE(allocation, AllocationType::kReadOnly);
@@ -835,12 +835,12 @@ MaybeHandle<String> Factory::NewStringFromTwoByte(const base::uc16* string,
 }
 
 MaybeHandle<String> Factory::NewStringFromTwoByte(
-    const base::Vector<const base::uc16>& string, AllocationType allocation) {
+    const base::Vector<const uc16>& string, AllocationType allocation) {
   return NewStringFromTwoByte(string.begin(), string.length(), allocation);
 }
 
 MaybeHandle<String> Factory::NewStringFromTwoByte(
-    const ZoneVector<base::uc16>* string, AllocationType allocation) {
+    const ZoneVector<uc16>* string, AllocationType allocation) {
   return NewStringFromTwoByte(string->data(), static_cast<int>(string->size()),
                               allocation);
 }
@@ -979,7 +979,7 @@ Handle<String> Factory::NewSurrogatePairString(uint16_t lead, uint16_t trail) {
   Handle<SeqTwoByteString> str =
       isolate()->factory()->NewRawTwoByteString(2).ToHandleChecked();
   DisallowGarbageCollection no_gc;
-  base::uc16* dest = str->GetChars(no_gc);
+  uc16* dest = str->GetChars(no_gc);
   dest[0] = lead;
   dest[1] = trail;
   return str;
@@ -1020,7 +1020,7 @@ Handle<String> Factory::NewProperSubString(Handle<String> str, int begin,
       Handle<SeqTwoByteString> result =
           NewRawTwoByteString(length).ToHandleChecked();
       DisallowGarbageCollection no_gc;
-      base::uc16* dest = result->GetChars(no_gc);
+      uc16* dest = result->GetChars(no_gc);
       String::WriteToFlat(*str, dest, begin, end);
       return result;
     }
diff --git a/src/heap/factory.h b/src/heap/factory.h
index f06cec3b26..3f6932e24a 100644
--- a/src/heap/factory.h
+++ b/src/heap/factory.h
@@ -7,7 +7,6 @@
 
 // Clients of this interface shouldn't depend on lots of heap internals.
 // Do not include anything from src/heap here!
-#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/baseline/baseline.h"
 #include "src/builtins/builtins.h"
@@ -267,11 +266,11 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
       AllocationType allocation = AllocationType::kYoung);
 
   V8_WARN_UNUSED_RESULT MaybeHandle<String> NewStringFromTwoByte(
-      const base::Vector<const base::uc16>& str,
+      const base::Vector<const uc16>& str,
       AllocationType allocation = AllocationType::kYoung);
 
   V8_WARN_UNUSED_RESULT MaybeHandle<String> NewStringFromTwoByte(
-      const ZoneVector<base::uc16>* str,
+      const ZoneVector<uc16>* str,
       AllocationType allocation = AllocationType::kYoung);
 
   Handle<JSStringIterator> NewJSStringIterator(Handle<String> string);
@@ -1008,9 +1007,9 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
                                                 uint32_t hash_field);
 
   Handle<String> AllocateTwoByteInternalizedString(
-      const base::Vector<const base::uc16>& str, uint32_t hash_field);
+      const base::Vector<const uc16>& str, uint32_t hash_field);
 
-  MaybeHandle<String> NewStringFromTwoByte(const base::uc16* string, int length,
+  MaybeHandle<String> NewStringFromTwoByte(const uc16* string, int length,
                                            AllocationType allocation);
 
   // Attempt to find the number in a small cache.  If we finds it, return
diff --git a/src/json/json-parser.cc b/src/json/json-parser.cc
index 24991a5c7f..7fc43405a7 100644
--- a/src/json/json-parser.cc
+++ b/src/json/json-parser.cc
@@ -4,7 +4,6 @@
 
 #include "src/json/json-parser.h"
 
-#include "src/base/strings.h"
 #include "src/common/message-template.h"
 #include "src/debug/debug.h"
 #include "src/numbers/conversions.h"
@@ -282,7 +281,7 @@ void JsonParser<Char>::ReportUnexpectedToken(JsonToken token) {
 }
 
 template <typename Char>
-void JsonParser<Char>::ReportUnexpectedCharacter(base::uc32 c) {
+void JsonParser<Char>::ReportUnexpectedCharacter(uc32 c) {
   JsonToken token = JsonToken::ILLEGAL;
   if (c == kEndOfString) {
     token = JsonToken::EOS;
@@ -332,10 +331,10 @@ void JsonParser<Char>::SkipWhitespace() {
 }
 
 template <typename Char>
-base::uc32 JsonParser<Char>::ScanUnicodeCharacter() {
-  base::uc32 value = 0;
+uc32 JsonParser<Char>::ScanUnicodeCharacter() {
+  uc32 value = 0;
   for (int i = 0; i < 4; i++) {
-    int digit = base::HexValue(NextCharacter());
+    int digit = HexValue(NextCharacter());
     if (V8_UNLIKELY(digit < 0)) return kInvalidUnicodeCharacter;
     value = value * 16 + digit;
   }
@@ -348,7 +347,7 @@ JsonString JsonParser<Char>::ScanJsonPropertyKey(JsonContinuation* cont) {
   {
     DisallowGarbageCollection no_gc;
     const Char* start = cursor_;
-    base::uc32 first = CurrentCharacter();
+    uc32 first = CurrentCharacter();
     if (first == '\\' && NextCharacter() == 'u') first = ScanUnicodeCharacter();
     if (IsDecimalDigit(first)) {
       if (first == '0') {
@@ -892,7 +891,7 @@ Handle<Object> JsonParser<Char>::ParseJsonNumber() {
     const Char* start = cursor_;
     DisallowGarbageCollection no_gc;
 
-    base::uc32 c = *cursor_;
+    uc32 c = *cursor_;
     if (c == '-') {
       sign = -1;
       c = NextCharacter();
@@ -921,7 +920,7 @@ Handle<Object> JsonParser<Char>::ParseJsonNumber() {
         ReportUnexpectedCharacter(CurrentCharacter());
         return handle(Smi::FromInt(0), isolate_);
       }
-      base::uc32 c = CurrentCharacter();
+      uc32 c = CurrentCharacter();
       STATIC_ASSERT(Smi::IsValid(-999999999));
       STATIC_ASSERT(Smi::IsValid(999999999));
       const int kMaxSmiLength = 9;
@@ -941,7 +940,7 @@ Handle<Object> JsonParser<Char>::ParseJsonNumber() {
     }
 
     if (CurrentCharacter() == '.') {
-      base::uc32 c = NextCharacter();
+      uc32 c = NextCharacter();
       if (!IsDecimalDigit(c)) {
         AllowGarbageCollection allow_before_exception;
         ReportUnexpectedCharacter(c);
@@ -951,7 +950,7 @@ Handle<Object> JsonParser<Char>::ParseJsonNumber() {
     }
 
     if (AsciiAlphaToLower(CurrentCharacter()) == 'e') {
-      base::uc32 c = NextCharacter();
+      uc32 c = NextCharacter();
       if (c == '-' || c == '+') c = NextCharacter();
       if (!IsDecimalDigit(c)) {
         AllowGarbageCollection allow_before_exception;
@@ -1081,12 +1080,12 @@ void JsonParser<Char>::DecodeString(SinkChar* sink, int start, int length) {
         break;
 
       case EscapeKind::kUnicode: {
-        base::uc32 value = 0;
+        uc32 value = 0;
         for (int i = 0; i < 4; i++) {
-          value = value * 16 + base::HexValue(*++cursor);
+          value = value * 16 + HexValue(*++cursor);
         }
         if (value <=
-            static_cast<base::uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
+            static_cast<uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
           *sink++ = value;
         } else {
           *sink++ = unibrow::Utf16::LeadSurrogate(value);
@@ -1108,7 +1107,7 @@ JsonString JsonParser<Char>::ScanJsonString(bool needs_internalization) {
   int start = position();
   int offset = start;
   bool has_escape = false;
-  base::uc32 bits = 0;
+  uc32 bits = 0;
 
   while (true) {
     cursor_ = std::find_if(cursor_, end_, [&bits](Char c) {
@@ -1137,7 +1136,7 @@ JsonString JsonParser<Char>::ScanJsonString(bool needs_internalization) {
 
     if (*cursor_ == '\\') {
       has_escape = true;
-      base::uc32 c = NextCharacter();
+      uc32 c = NextCharacter();
       if (V8_UNLIKELY(!base::IsInRange(
               c, 0, static_cast<int32_t>(unibrow::Latin1::kMaxChar)))) {
         AllowGarbageCollection allow_before_exception;
@@ -1156,7 +1155,7 @@ JsonString JsonParser<Char>::ScanJsonString(bool needs_internalization) {
           break;
 
         case EscapeKind::kUnicode: {
-          base::uc32 value = ScanUnicodeCharacter();
+          uc32 value = ScanUnicodeCharacter();
           if (value == kInvalidUnicodeCharacter) {
             AllowGarbageCollection allow_before_exception;
             ReportUnexpectedCharacter(CurrentCharacter());
@@ -1165,7 +1164,7 @@ JsonString JsonParser<Char>::ScanJsonString(bool needs_internalization) {
           bits |= value;
           // \uXXXX results in either 1 or 2 Utf16 characters, depending on
           // whether the decoded value requires a surrogate pair.
-          offset += 5 - (value > static_cast<base::uc32>(
+          offset += 5 - (value > static_cast<uc32>(
                                      unibrow::Utf16::kMaxNonSurrogateCharCode));
           break;
         }
diff --git a/src/json/json-parser.h b/src/json/json-parser.h
index 03e7537512..f6b9fb656d 100644
--- a/src/json/json-parser.h
+++ b/src/json/json-parser.h
@@ -6,7 +6,6 @@
 #define V8_JSON_JSON_PARSER_H_
 
 #include "src/base/small-vector.h"
-#include "src/base/strings.h"
 #include "src/execution/isolate.h"
 #include "src/heap/factory.h"
 #include "src/objects/objects.h"
@@ -153,9 +152,8 @@ class JsonParser final {
     return result;
   }
 
-  static constexpr base::uc32 kEndOfString = static_cast<base::uc32>(-1);
-  static constexpr base::uc32 kInvalidUnicodeCharacter =
-      static_cast<base::uc32>(-1);
+  static constexpr uc32 kEndOfString = static_cast<uc32>(-1);
+  static constexpr uc32 kInvalidUnicodeCharacter = static_cast<uc32>(-1);
 
  private:
   template <typename T>
@@ -188,12 +186,12 @@ class JsonParser final {
 
   void advance() { ++cursor_; }
 
-  base::uc32 CurrentCharacter() {
+  uc32 CurrentCharacter() {
     if (V8_UNLIKELY(is_at_end())) return kEndOfString;
     return *cursor_;
   }
 
-  base::uc32 NextCharacter() {
+  uc32 NextCharacter() {
     advance();
     return CurrentCharacter();
   }
@@ -265,7 +263,7 @@ class JsonParser final {
   // four-digit hex escapes (uXXXX). Any other use of backslashes is invalid.
   JsonString ScanJsonString(bool needs_internalization);
   JsonString ScanJsonPropertyKey(JsonContinuation* cont);
-  base::uc32 ScanUnicodeCharacter();
+  uc32 ScanUnicodeCharacter();
   Handle<String> MakeString(const JsonString& string,
                             Handle<String> hint = Handle<String>());
 
@@ -298,7 +296,7 @@ class JsonParser final {
       const SmallVector<Handle<Object>>& element_stack);
 
   // Mark that a parsing error has happened at the current character.
-  void ReportUnexpectedCharacter(base::uc32 c);
+  void ReportUnexpectedCharacter(uc32 c);
   // Mark that a parsing error has happened at the current token.
   void ReportUnexpectedToken(JsonToken token);
 
diff --git a/src/json/json-stringifier.cc b/src/json/json-stringifier.cc
index c86ab12a65..50f12a920d 100644
--- a/src/json/json-stringifier.cc
+++ b/src/json/json-stringifier.cc
@@ -4,7 +4,6 @@
 
 #include "src/json/json-stringifier.h"
 
-#include "src/base/strings.h"
 #include "src/common/message-template.h"
 #include "src/numbers/conversions.h"
 #include "src/objects/heap-number-inl.h"
@@ -128,7 +127,7 @@ class JsonStringifier {
   Handle<String> tojson_string_;
   Handle<FixedArray> property_list_;
   Handle<JSReceiver> replacer_function_;
-  base::uc16* gap_;
+  uc16* gap_;
   int indent_;
 
   using KeyObject = std::pair<Handle<Object>, Handle<Object>>;
@@ -304,7 +303,7 @@ bool JsonStringifier::InitializeGap(Handle<Object> gap) {
     Handle<String> gap_string = Handle<String>::cast(gap);
     if (gap_string->length() > 0) {
       int gap_length = std::min(gap_string->length(), 10);
-      gap_ = NewArray<base::uc16>(gap_length + 1);
+      gap_ = NewArray<uc16>(gap_length + 1);
       String::WriteToFlat(*gap_string, gap_, 0, gap_length);
       for (int i = 0; i < gap_length; i++) {
         if (gap_[i] > String::kMaxOneByteCharCode) {
@@ -318,7 +317,7 @@ bool JsonStringifier::InitializeGap(Handle<Object> gap) {
     int num_value = DoubleToInt32(gap->Number());
     if (num_value > 0) {
       int gap_length = std::min(num_value, 10);
-      gap_ = NewArray<base::uc16>(gap_length + 1);
+      gap_ = NewArray<uc16>(gap_length + 1);
       for (int i = 0; i < gap_length; i++) gap_[i] = ' ';
       gap_[gap_length] = '\0';
     }
@@ -878,8 +877,8 @@ template <typename SrcChar, typename DestChar>
 void JsonStringifier::SerializeStringUnchecked_(
     base::Vector<const SrcChar> src,
     IncrementalStringBuilder::NoExtend<DestChar>* dest) {
-  // Assert that base::uc16 character is not truncated down to 8 bit.
-  // The <base::uc16, char> version of this method must not be called.
+  // Assert that uc16 character is not truncated down to 8 bit.
+  // The <uc16, char> version of this method must not be called.
   DCHECK(sizeof(DestChar) >= sizeof(SrcChar));
   for (int i = 0; i < src.length(); i++) {
     SrcChar c = src[i];
@@ -1037,9 +1036,9 @@ void JsonStringifier::SerializeString(Handle<String> object) {
     }
   } else {
     if (String::IsOneByteRepresentationUnderneath(*object)) {
-      SerializeString_<uint8_t, base::uc16>(object);
+      SerializeString_<uint8_t, uc16>(object);
     } else {
-      SerializeString_<base::uc16, base::uc16>(object);
+      SerializeString_<uc16, uc16>(object);
     }
   }
 }
diff --git a/src/base/numbers/bignum-dtoa.cc b/src/numbers/bignum-dtoa.cc
similarity index 97%
rename from src/base/numbers/bignum-dtoa.cc
rename to src/numbers/bignum-dtoa.cc
index 6caf0dd936..5fc871a80d 100644
--- a/src/base/numbers/bignum-dtoa.cc
+++ b/src/numbers/bignum-dtoa.cc
@@ -2,16 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/bignum-dtoa.h"
+#include "src/numbers/bignum-dtoa.h"
 
 #include <cmath>
 
 #include "src/base/logging.h"
-#include "src/base/numbers/bignum.h"
-#include "src/base/numbers/double.h"
+#include "src/numbers/bignum.h"
+#include "src/numbers/double.h"
+#include "src/utils/utils.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 static int NormalizedExponent(uint64_t significand, int exponent) {
   DCHECK_NE(significand, 0);
@@ -44,22 +45,22 @@ static void FixupMultiply10(int estimated_power, bool is_even,
 // digits yield the shortest decimal representation of v.
 static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
                                    Bignum* delta_minus, Bignum* delta_plus,
-                                   bool is_even, Vector<char> buffer,
+                                   bool is_even, base::Vector<char> buffer,
                                    int* length);
 // Generates 'requested_digits' after the decimal point.
 static void BignumToFixed(int requested_digits, int* decimal_point,
                           Bignum* numerator, Bignum* denominator,
-                          Vector<char>(buffer), int* length);
+                          base::Vector<char>(buffer), int* length);
 // Generates 'count' digits of numerator/denominator.
 // Once 'count' digits have been produced rounds the result depending on the
 // remainder (remainders of exactly .5 round upwards). Might update the
 // decimal_point when rounding up (for example for 0.9999).
 static void GenerateCountedDigits(int count, int* decimal_point,
                                   Bignum* numerator, Bignum* denominator,
-                                  Vector<char>(buffer), int* length);
+                                  base::Vector<char>(buffer), int* length);
 
 void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
-                Vector<char> buffer, int* length, int* decimal_point) {
+                base::Vector<char> buffer, int* length, int* decimal_point) {
   DCHECK_GT(v, 0);
   DCHECK(!Double(v).IsSpecial());
   uint64_t significand = Double(v).Significand();
@@ -134,7 +135,7 @@ void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
 //   will be produced. This should be the standard precondition.
 static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
                                    Bignum* delta_minus, Bignum* delta_plus,
-                                   bool is_even, Vector<char> buffer,
+                                   bool is_even, base::Vector<char> buffer,
                                    int* length) {
   // Small optimization: if delta_minus and delta_plus are the same just reuse
   // one of the two bignums.
@@ -231,7 +232,7 @@ static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
 // exponent (decimal_point), when rounding upwards.
 static void GenerateCountedDigits(int count, int* decimal_point,
                                   Bignum* numerator, Bignum* denominator,
-                                  Vector<char>(buffer), int* length) {
+                                  base::Vector<char>(buffer), int* length) {
   DCHECK_GE(count, 0);
   for (int i = 0; i < count - 1; ++i) {
     uint16_t digit;
@@ -272,7 +273,7 @@ static void GenerateCountedDigits(int count, int* decimal_point,
 // Input verifies:  1 <= (numerator + delta) / denominator < 10.
 static void BignumToFixed(int requested_digits, int* decimal_point,
                           Bignum* numerator, Bignum* denominator,
-                          Vector<char>(buffer), int* length) {
+                          base::Vector<char>(buffer), int* length) {
   // Note that we have to look at more than just the requested_digits, since
   // a number could be rounded up. Example: v=0.5 with requested_digits=0.
   // Even though the power of v equals 0 we can't just stop here.
@@ -603,5 +604,5 @@ static void FixupMultiply10(int estimated_power, bool is_even,
   }
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/bignum-dtoa.h b/src/numbers/bignum-dtoa.h
similarity index 86%
rename from src/base/numbers/bignum-dtoa.h
rename to src/numbers/bignum-dtoa.h
index d90b62e4c4..8a9737df88 100644
--- a/src/base/numbers/bignum-dtoa.h
+++ b/src/numbers/bignum-dtoa.h
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_BIGNUM_DTOA_H_
-#define V8_BASE_NUMBERS_BIGNUM_DTOA_H_
+#ifndef V8_NUMBERS_BIGNUM_DTOA_H_
+#define V8_NUMBERS_BIGNUM_DTOA_H_
 
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 enum BignumDtoaMode {
   // Return the shortest correct representation.
@@ -52,11 +52,12 @@ enum BignumDtoaMode {
 //   Halfway cases are again rounded up.
 // 'BignumDtoa' expects the given buffer to be big enough to hold all digits
 // and a terminating null-character.
-V8_BASE_EXPORT void BignumDtoa(double v, BignumDtoaMode mode,
-                               int requested_digits, Vector<char> buffer,
-                               int* length, int* point);
+V8_EXPORT_PRIVATE void BignumDtoa(double v, BignumDtoaMode mode,
+                                  int requested_digits,
+                                  base::Vector<char> buffer, int* length,
+                                  int* point);
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_BIGNUM_DTOA_H_
+#endif  // V8_NUMBERS_BIGNUM_DTOA_H_
diff --git a/src/base/numbers/bignum.cc b/src/numbers/bignum.cc
similarity index 98%
rename from src/base/numbers/bignum.cc
rename to src/numbers/bignum.cc
index 007a1ca2d8..1b91d338b9 100644
--- a/src/base/numbers/bignum.cc
+++ b/src/numbers/bignum.cc
@@ -2,12 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/bignum.h"
-
-#include "src/base/strings.h"
+#include "src/numbers/bignum.h"
+#include "src/utils/utils.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 Bignum::Bignum()
     : bigits_(bigits_buffer_, kBigitCapacity), used_digits_(0), exponent_(0) {
@@ -60,7 +59,7 @@ void Bignum::AssignBignum(const Bignum& other) {
   used_digits_ = other.used_digits_;
 }
 
-static uint64_t ReadUInt64(Vector<const char> buffer, int from,
+static uint64_t ReadUInt64(base::Vector<const char> buffer, int from,
                            int digits_to_read) {
   uint64_t result = 0;
   int to = from + digits_to_read;
@@ -73,7 +72,7 @@ static uint64_t ReadUInt64(Vector<const char> buffer, int from,
   return result;
 }
 
-void Bignum::AssignDecimalString(Vector<const char> value) {
+void Bignum::AssignDecimalString(base::Vector<const char> value) {
   // 2^64 = 18446744073709551616 > 10^19
   const int kMaxUint64DecimalDigits = 19;
   Zero();
@@ -100,7 +99,7 @@ static int HexCharValue(char c) {
   UNREACHABLE();
 }
 
-void Bignum::AssignHexString(Vector<const char> value) {
+void Bignum::AssignHexString(base::Vector<const char> value) {
   Zero();
   int length = value.length();
 
@@ -713,5 +712,5 @@ void Bignum::SubtractTimes(const Bignum& other, int factor) {
   DCHECK(Bignum::Equal(a, *this));
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/bignum.h b/src/numbers/bignum.h
similarity index 92%
rename from src/base/numbers/bignum.h
rename to src/numbers/bignum.h
index 0e15c5bea3..b1721a436c 100644
--- a/src/base/numbers/bignum.h
+++ b/src/numbers/bignum.h
@@ -2,15 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_BIGNUM_H_
-#define V8_BASE_NUMBERS_BIGNUM_H_
+#ifndef V8_NUMBERS_BIGNUM_H_
+#define V8_NUMBERS_BIGNUM_H_
 
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
-class V8_BASE_EXPORT Bignum {
+class V8_EXPORT_PRIVATE Bignum {
  public:
   // 3584 = 128 * 28. We can represent 2^3584 > 10^1000 accurately.
   // This bignum can encode much bigger numbers, since it contains an
@@ -24,8 +24,8 @@ class V8_BASE_EXPORT Bignum {
   void AssignUInt64(uint64_t value);
   void AssignBignum(const Bignum& other);
 
-  void AssignDecimalString(Vector<const char> value);
-  void AssignHexString(Vector<const char> value);
+  void AssignDecimalString(base::Vector<const char> value);
+  void AssignHexString(base::Vector<const char> value);
 
   void AssignPowerUInt16(uint16_t base, int exponent);
 
@@ -109,13 +109,13 @@ class V8_BASE_EXPORT Bignum {
   Chunk bigits_buffer_[kBigitCapacity];
   // A vector backed by bigits_buffer_. This way accesses to the array are
   // checked for out-of-bounds errors.
-  Vector<Chunk> bigits_;
+  base::Vector<Chunk> bigits_;
   int used_digits_;
   // The Bignum's value equals value(bigits_) * 2^(exponent_ * kBigitSize).
   int exponent_;
 };
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_BIGNUM_H_
+#endif  // V8_NUMBERS_BIGNUM_H_
diff --git a/src/base/numbers/cached-powers.cc b/src/numbers/cached-powers.cc
similarity index 98%
rename from src/base/numbers/cached-powers.cc
rename to src/numbers/cached-powers.cc
index cff49a3468..d725a87711 100644
--- a/src/base/numbers/cached-powers.cc
+++ b/src/numbers/cached-powers.cc
@@ -2,18 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/cached-powers.h"
+#include "src/numbers/cached-powers.h"
 
 #include <limits.h>
 #include <stdarg.h>
 #include <stdint.h>
-
 #include <cmath>
 
 #include "src/base/logging.h"
+#include "src/common/globals.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 struct CachedPower {
   uint64_t significand;
@@ -109,5 +109,5 @@ void PowersOfTenCache::GetCachedPowerForDecimalExponent(int requested_exponent,
   DCHECK(requested_exponent < *found_exponent + kDecimalExponentDistance);
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/cached-powers.h b/src/numbers/cached-powers.h
similarity index 87%
rename from src/base/numbers/cached-powers.h
rename to src/numbers/cached-powers.h
index 98683ddb54..99ffe5068f 100644
--- a/src/base/numbers/cached-powers.h
+++ b/src/numbers/cached-powers.h
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_CACHED_POWERS_H_
-#define V8_BASE_NUMBERS_CACHED_POWERS_H_
+#ifndef V8_NUMBERS_CACHED_POWERS_H_
+#define V8_NUMBERS_CACHED_POWERS_H_
 
 #include "src/base/logging.h"
-#include "src/base/numbers/diy-fp.h"
+#include "src/numbers/diy-fp.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 class PowersOfTenCache {
  public:
@@ -37,7 +37,7 @@ class PowersOfTenCache {
                                                int* found_exponent);
 };
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_CACHED_POWERS_H_
+#endif  // V8_NUMBERS_CACHED_POWERS_H_
diff --git a/src/numbers/conversions-inl.h b/src/numbers/conversions-inl.h
index ce75141e81..71c95f3733 100644
--- a/src/numbers/conversions-inl.h
+++ b/src/numbers/conversions-inl.h
@@ -15,10 +15,10 @@
 // Extra POSIX/ANSI functions for Win32/MSVC.
 
 #include "src/base/bits.h"
-#include "src/base/numbers/double.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/wrappers.h"
 #include "src/numbers/conversions.h"
+#include "src/numbers/double.h"
 #include "src/objects/heap-number-inl.h"
 #include "src/objects/objects-inl.h"
 
@@ -94,11 +94,11 @@ int32_t DoubleToInt32(double x) {
     // All doubles within these limits are trivially convertable to an int.
     return static_cast<int32_t>(x);
   }
-  base::Double d(x);
+  Double d(x);
   int exponent = d.Exponent();
   uint64_t bits;
   if (exponent < 0) {
-    if (exponent <= -base::Double::kSignificandSize) return 0;
+    if (exponent <= -Double::kSignificandSize) return 0;
     bits = d.Significand() >> -exponent;
   } else {
     if (exponent > 31) return 0;
diff --git a/src/numbers/conversions.cc b/src/numbers/conversions.cc
index cbbfb3fae0..15e9c30bc3 100644
--- a/src/numbers/conversions.cc
+++ b/src/numbers/conversions.cc
@@ -9,12 +9,12 @@
 
 #include <cmath>
 
-#include "src/base/numbers/dtoa.h"
-#include "src/base/numbers/strtod.h"
 #include "src/base/platform/wrappers.h"
 #include "src/common/assert-scope.h"
 #include "src/handles/handles.h"
 #include "src/heap/factory.h"
+#include "src/numbers/dtoa.h"
+#include "src/numbers/strtod.h"
 #include "src/objects/bigint.h"
 #include "src/objects/objects-inl.h"
 #include "src/objects/string-inl.h"
@@ -143,7 +143,7 @@ inline double JunkStringValue() {
 }
 
 inline double SignedZero(bool negative) {
-  return negative ? base::uint64_to_double(base::Double::kSignMask) : 0.0;
+  return negative ? uint64_to_double(Double::kSignMask) : 0.0;
 }
 
 inline bool isDigit(int x, int radix) {
@@ -340,7 +340,7 @@ class StringToIntHelper {
     return subject_->GetFlatContent(no_gc).ToOneByteVector();
   }
 
-  base::Vector<const base::uc16> GetTwoByteVector() {
+  base::Vector<const uc16> GetTwoByteVector() {
     DisallowGarbageCollection no_gc;
     return subject_->GetFlatContent(no_gc).ToUC16Vector();
   }
@@ -381,7 +381,7 @@ void StringToIntHelper<IsolateT>::ParseInt() {
       base::Vector<const uint8_t> vector = GetOneByteVector();
       DetectRadixInternal(vector.begin(), vector.length());
     } else {
-      base::Vector<const base::uc16> vector = GetTwoByteVector();
+      base::Vector<const uc16> vector = GetTwoByteVector();
       DetectRadixInternal(vector.begin(), vector.length());
     }
   }
@@ -399,7 +399,7 @@ void StringToIntHelper<IsolateT>::ParseInt() {
           break;
         }
       } else {
-        base::Vector<const base::uc16> vector = GetTwoByteVector();
+        base::Vector<const uc16> vector = GetTwoByteVector();
         DCHECK_EQ(length_, vector.length());
         if (ParseChunkInternal(vector.begin())) {
           break;
@@ -612,7 +612,7 @@ class NumberParseIntHelper : public StringToIntHelper<Isolate> {
       result_ = is_power_of_two ? HandlePowerOfTwoCase(vector.begin())
                                 : HandleBaseTenCase(vector.begin());
     } else {
-      base::Vector<const base::uc16> vector = GetTwoByteVector();
+      base::Vector<const uc16> vector = GetTwoByteVector();
       DCHECK_EQ(length(), vector.length());
       result_ = is_power_of_two ? HandlePowerOfTwoCase(vector.begin())
                                 : HandleBaseTenCase(vector.begin());
@@ -957,9 +957,9 @@ double StringToDouble(base::Vector<const uint8_t> str, int flags,
                                 empty_string_val);
 }
 
-double StringToDouble(base::Vector<const base::uc16> str, int flags,
+double StringToDouble(base::Vector<const uc16> str, int flags,
                       double empty_string_val) {
-  const base::uc16* end = str.begin() + str.length();
+  const uc16* end = str.begin() + str.length();
   return InternalStringToDouble(str.begin(), end, flags, empty_string_val);
 }
 
@@ -1099,14 +1099,13 @@ const char* DoubleToCString(double v, base::Vector<char> buffer) {
       SimpleStringBuilder builder(buffer.begin(), buffer.length());
       int decimal_point;
       int sign;
-      const int kV8DtoaBufferCapacity = base::kBase10MaximalLength + 1;
+      const int kV8DtoaBufferCapacity = kBase10MaximalLength + 1;
       char decimal_rep[kV8DtoaBufferCapacity];
       int length;
 
-      base::DoubleToAscii(
-          v, base::DTOA_SHORTEST, 0,
-          base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
-          &length, &decimal_point);
+      DoubleToAscii(v, DTOA_SHORTEST, 0,
+                    base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity),
+                    &sign, &length, &decimal_point);
 
       if (sign) builder.AddCharacter('-');
 
@@ -1192,9 +1191,9 @@ char* DoubleToFixedCString(double value, int f) {
       kMaxDigitsBeforePoint + kMaxFractionDigits + 1;
   char decimal_rep[kDecimalRepCapacity];
   int decimal_rep_length;
-  base::DoubleToAscii(value, base::DTOA_FIXED, f,
-                      base::Vector<char>(decimal_rep, kDecimalRepCapacity),
-                      &sign, &decimal_rep_length, &decimal_point);
+  DoubleToAscii(value, DTOA_FIXED, f,
+                base::Vector<char>(decimal_rep, kDecimalRepCapacity), &sign,
+                &decimal_rep_length, &decimal_point);
 
   // Create a representation that is padded with zeros if needed.
   int zero_prefix_length = 0;
@@ -1282,19 +1281,19 @@ char* DoubleToExponentialCString(double value, int f) {
   const int kV8DtoaBufferCapacity = kMaxFractionDigits + 1 + 1;
   // Make sure that the buffer is big enough, even if we fall back to the
   // shortest representation (which happens when f equals -1).
-  DCHECK_LE(base::kBase10MaximalLength, kMaxFractionDigits + 1);
+  DCHECK_LE(kBase10MaximalLength, kMaxFractionDigits + 1);
   char decimal_rep[kV8DtoaBufferCapacity];
   int decimal_rep_length;
 
   if (f == -1) {
-    base::DoubleToAscii(value, base::DTOA_SHORTEST, 0,
-                        base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity),
-                        &sign, &decimal_rep_length, &decimal_point);
+    DoubleToAscii(value, DTOA_SHORTEST, 0,
+                  base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
+                  &decimal_rep_length, &decimal_point);
     f = decimal_rep_length - 1;
   } else {
-    base::DoubleToAscii(value, base::DTOA_PRECISION, f + 1,
-                        base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity),
-                        &sign, &decimal_rep_length, &decimal_point);
+    DoubleToAscii(value, DTOA_PRECISION, f + 1,
+                  base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
+                  &decimal_rep_length, &decimal_point);
   }
   DCHECK_GT(decimal_rep_length, 0);
   DCHECK(decimal_rep_length <= f + 1);
@@ -1325,9 +1324,9 @@ char* DoubleToPrecisionCString(double value, int p) {
   char decimal_rep[kV8DtoaBufferCapacity];
   int decimal_rep_length;
 
-  base::DoubleToAscii(value, base::DTOA_PRECISION, p,
-                      base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity),
-                      &sign, &decimal_rep_length, &decimal_point);
+  DoubleToAscii(value, DTOA_PRECISION, p,
+                base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
+                &decimal_rep_length, &decimal_point);
   DCHECK(decimal_rep_length <= p);
 
   int exponent = decimal_point - 1;
@@ -1399,8 +1398,8 @@ char* DoubleToRadixCString(double value, int radix) {
   double integer = std::floor(value);
   double fraction = value - integer;
   // We only compute fractional digits up to the input double's precision.
-  double delta = 0.5 * (base::Double(value).NextDouble() - value);
-  delta = std::max(base::Double(0.0).NextDouble(), delta);
+  double delta = 0.5 * (Double(value).NextDouble() - value);
+  delta = std::max(Double(0.0).NextDouble(), delta);
   DCHECK_GT(delta, 0.0);
   if (fraction >= delta) {
     // Insert decimal point.
@@ -1441,7 +1440,7 @@ char* DoubleToRadixCString(double value, int radix) {
   }
 
   // Compute integer digits. Fill unrepresented digits with zero.
-  while (base::Double(integer / radix).Exponent() > 0) {
+  while (Double(integer / radix).Exponent() > 0) {
     integer /= radix;
     buffer[--integer_cursor] = '0';
   }
@@ -1488,10 +1487,10 @@ base::Optional<double> TryStringToDouble(LocalIsolate* isolate,
   }
 
   const int flags = ALLOW_HEX | ALLOW_OCTAL | ALLOW_BINARY;
-  auto buffer = std::make_unique<base::uc16[]>(max_length_for_conversion);
+  auto buffer = std::make_unique<uc16[]>(max_length_for_conversion);
   SharedStringAccessGuardIfNeeded access_guard(isolate);
   String::WriteToFlat(*object, buffer.get(), 0, length, access_guard);
-  base::Vector<const base::uc16> v(buffer.get(), length);
+  base::Vector<const uc16> v(buffer.get(), length);
   return StringToDouble(v, flags);
 }
 
diff --git a/src/numbers/conversions.h b/src/numbers/conversions.h
index 9b958e22e6..265e95e270 100644
--- a/src/numbers/conversions.h
+++ b/src/numbers/conversions.h
@@ -8,7 +8,6 @@
 #include "src/base/export-template.h"
 #include "src/base/logging.h"
 #include "src/base/optional.h"
-#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/common/globals.h"
 
@@ -90,7 +89,7 @@ enum ConversionFlags {
 // Converts a string into a double value according to ECMA-262 9.3.1
 double StringToDouble(base::Vector<const uint8_t> str, int flags,
                       double empty_string_val = 0);
-double StringToDouble(base::Vector<const base::uc16> str, int flags,
+double StringToDouble(base::Vector<const uc16> str, int flags,
                       double empty_string_val = 0);
 // This version expects a zero-terminated character array.
 double V8_EXPORT_PRIVATE StringToDouble(const char* str, int flags,
diff --git a/src/base/numbers/diy-fp.cc b/src/numbers/diy-fp.cc
similarity index 92%
rename from src/base/numbers/diy-fp.cc
rename to src/numbers/diy-fp.cc
index 19d00d0fc5..600670ede3 100644
--- a/src/base/numbers/diy-fp.cc
+++ b/src/numbers/diy-fp.cc
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/diy-fp.h"
+#include "src/numbers/diy-fp.h"
 
 #include <stdint.h>
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 void DiyFp::Multiply(const DiyFp& other) {
   // Simply "emulates" a 128 bit multiplication.
@@ -32,5 +32,5 @@ void DiyFp::Multiply(const DiyFp& other) {
   f_ = result_f;
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/diy-fp.h b/src/numbers/diy-fp.h
similarity index 92%
rename from src/base/numbers/diy-fp.h
rename to src/numbers/diy-fp.h
index b23cbc4ddc..a7f54427f2 100644
--- a/src/base/numbers/diy-fp.h
+++ b/src/numbers/diy-fp.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_DIY_FP_H_
-#define V8_BASE_NUMBERS_DIY_FP_H_
+#ifndef V8_NUMBERS_DIY_FP_H_
+#define V8_NUMBERS_DIY_FP_H_
 
 #include <stdint.h>
 
@@ -11,7 +11,7 @@
 #include "src/base/macros.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 // This "Do It Yourself Floating Point" class implements a floating-point number
 // with a uint64 significand and an int exponent. Normalized DiyFp numbers will
@@ -45,7 +45,7 @@ class DiyFp {
   }
 
   // this = this * other.
-  V8_BASE_EXPORT void Multiply(const DiyFp& other);
+  V8_EXPORT_PRIVATE void Multiply(const DiyFp& other);
 
   // returns a * b;
   static DiyFp Times(const DiyFp& a, const DiyFp& b) {
@@ -93,7 +93,7 @@ class DiyFp {
   int e_;
 };
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_DIY_FP_H_
+#endif  // V8_NUMBERS_DIY_FP_H_
diff --git a/src/base/numbers/double.h b/src/numbers/double.h
similarity index 97%
rename from src/base/numbers/double.h
rename to src/numbers/double.h
index 8cb9d2a6b8..d3ec8d01ed 100644
--- a/src/base/numbers/double.h
+++ b/src/numbers/double.h
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_DOUBLE_H_
-#define V8_BASE_NUMBERS_DOUBLE_H_
+#ifndef V8_NUMBERS_DOUBLE_H_
+#define V8_NUMBERS_DOUBLE_H_
 
 #include "src/base/macros.h"
-#include "src/base/numbers/diy-fp.h"
+#include "src/numbers/diy-fp.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 // We assume that doubles and uint64_t have the same endianness.
 inline uint64_t double_to_uint64(double d) { return bit_cast<uint64_t>(d); }
@@ -204,7 +204,7 @@ class Double {
   }
 };
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_DOUBLE_H_
+#endif  // V8_NUMBERS_DOUBLE_H_
diff --git a/src/base/numbers/dtoa.cc b/src/numbers/dtoa.cc
similarity index 83%
rename from src/base/numbers/dtoa.cc
rename to src/numbers/dtoa.cc
index 6cdf076750..4ab9efafdc 100644
--- a/src/base/numbers/dtoa.cc
+++ b/src/numbers/dtoa.cc
@@ -2,18 +2,20 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/dtoa.h"
-
 #include <cmath>
 
 #include "src/base/logging.h"
-#include "src/base/numbers/bignum-dtoa.h"
-#include "src/base/numbers/double.h"
-#include "src/base/numbers/fast-dtoa.h"
-#include "src/base/numbers/fixed-dtoa.h"
+#include "src/utils/utils.h"
+
+#include "src/numbers/dtoa.h"
+
+#include "src/numbers/bignum-dtoa.h"
+#include "src/numbers/double.h"
+#include "src/numbers/fast-dtoa.h"
+#include "src/numbers/fixed-dtoa.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 static BignumDtoaMode DtoaToBignumDtoaMode(DtoaMode dtoa_mode) {
   switch (dtoa_mode) {
@@ -29,7 +31,8 @@ static BignumDtoaMode DtoaToBignumDtoaMode(DtoaMode dtoa_mode) {
 }
 
 void DoubleToAscii(double v, DtoaMode mode, int requested_digits,
-                   Vector<char> buffer, int* sign, int* length, int* point) {
+                   base::Vector<char> buffer, int* sign, int* length,
+                   int* point) {
   DCHECK(!Double(v).IsSpecial());
   DCHECK(mode == DTOA_SHORTEST || requested_digits >= 0);
 
@@ -77,5 +80,5 @@ void DoubleToAscii(double v, DtoaMode mode, int requested_digits,
   buffer[*length] = '\0';
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/dtoa.h b/src/numbers/dtoa.h
similarity index 89%
rename from src/base/numbers/dtoa.h
rename to src/numbers/dtoa.h
index 4633269db1..42caef4a94 100644
--- a/src/base/numbers/dtoa.h
+++ b/src/numbers/dtoa.h
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_DTOA_H_
-#define V8_BASE_NUMBERS_DTOA_H_
+#ifndef V8_NUMBERS_DTOA_H_
+#define V8_NUMBERS_DTOA_H_
 
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 enum DtoaMode {
   // Return the shortest correct representation.
@@ -61,11 +61,12 @@ const int kBase10MaximalLength = 17;
 // and a terminating null-character. In SHORTEST-mode it expects a buffer of
 // at least kBase10MaximalLength + 1. Otherwise, the size of the output is
 // limited to requested_digits digits plus the null terminator.
-V8_BASE_EXPORT void DoubleToAscii(double v, DtoaMode mode, int requested_digits,
-                                  Vector<char> buffer, int* sign, int* length,
-                                  int* point);
+V8_EXPORT_PRIVATE void DoubleToAscii(double v, DtoaMode mode,
+                                     int requested_digits,
+                                     base::Vector<char> buffer, int* sign,
+                                     int* length, int* point);
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_DTOA_H_
+#endif  // V8_NUMBERS_DTOA_H_
diff --git a/src/base/numbers/fast-dtoa.cc b/src/numbers/fast-dtoa.cc
similarity index 96%
rename from src/base/numbers/fast-dtoa.cc
rename to src/numbers/fast-dtoa.cc
index 7c0345a061..c9de2ee924 100644
--- a/src/base/numbers/fast-dtoa.cc
+++ b/src/numbers/fast-dtoa.cc
@@ -2,18 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/fast-dtoa.h"
-
 #include <stdint.h>
-
 #include "src/base/logging.h"
-#include "src/base/numbers/cached-powers.h"
-#include "src/base/numbers/diy-fp.h"
-#include "src/base/numbers/double.h"
-#include "src/base/v8-fallthrough.h"
+#include "src/utils/utils.h"
+
+#include "src/numbers/fast-dtoa.h"
+
+#include "src/numbers/cached-powers.h"
+#include "src/numbers/diy-fp.h"
+#include "src/numbers/double.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 // The minimal and maximal target exponent define the range of w's binary
 // exponent, where 'w' is the result of multiplying the input by a cached power
@@ -39,7 +39,7 @@ static const int kMaximalTargetExponent = -32;
 // Output: returns true if the buffer is guaranteed to contain the closest
 //    representable number to the input.
 //  Modifies the generated digits in the buffer to approach (round towards) w.
-static bool RoundWeed(Vector<char> buffer, int length,
+static bool RoundWeed(base::Vector<char> buffer, int length,
                       uint64_t distance_too_high_w, uint64_t unsafe_interval,
                       uint64_t rest, uint64_t ten_kappa, uint64_t unit) {
   uint64_t small_distance = distance_too_high_w - unit;
@@ -153,8 +153,9 @@ static bool RoundWeed(Vector<char> buffer, int length,
 // unambiguously determined.
 //
 // Precondition: rest < ten_kappa.
-static bool RoundWeedCounted(Vector<char> buffer, int length, uint64_t rest,
-                             uint64_t ten_kappa, uint64_t unit, int* kappa) {
+static bool RoundWeedCounted(base::Vector<char> buffer, int length,
+                             uint64_t rest, uint64_t ten_kappa, uint64_t unit,
+                             int* kappa) {
   DCHECK(rest < ten_kappa);
   // The following tests are done in a specific order to avoid overflows. They
   // will work correctly with any uint64 values of rest < ten_kappa and unit.
@@ -354,7 +355,7 @@ static void BiggestPowerTen(uint32_t number, int number_bits, uint32_t* power,
 // represent 'w' we can stop. Everything inside the interval low - high
 // represents w. However we have to pay attention to low, high and w's
 // imprecision.
-static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, Vector<char> buffer,
+static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, base::Vector<char> buffer,
                      int* length, int* kappa) {
   DCHECK(low.e() == w.e() && w.e() == high.e());
   DCHECK(low.f() + 1 <= high.f() - 1);
@@ -474,8 +475,9 @@ static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, Vector<char> buffer,
 //   numbers. If the precision is not enough to guarantee all the postconditions
 //   then false is returned. This usually happens rarely, but the failure-rate
 //   increases with higher requested_digits.
-static bool DigitGenCounted(DiyFp w, int requested_digits, Vector<char> buffer,
-                            int* length, int* kappa) {
+static bool DigitGenCounted(DiyFp w, int requested_digits,
+                            base::Vector<char> buffer, int* length,
+                            int* kappa) {
   DCHECK(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);
   DCHECK_GE(kMinimalTargetExponent, -60);
   DCHECK_LE(kMaximalTargetExponent, -32);
@@ -559,7 +561,7 @@ static bool DigitGenCounted(DiyFp w, int requested_digits, Vector<char> buffer,
 // The last digit will be closest to the actual v. That is, even if several
 // digits might correctly yield 'v' when read again, the closest will be
 // computed.
-static bool Grisu3(double v, Vector<char> buffer, int* length,
+static bool Grisu3(double v, base::Vector<char> buffer, int* length,
                    int* decimal_exponent) {
   DiyFp w = Double(v).AsNormalizedDiyFp();
   // boundary_minus and boundary_plus are the boundaries between v and its
@@ -620,8 +622,9 @@ static bool Grisu3(double v, Vector<char> buffer, int* length,
 // and with enough requested digits 0.1 will at some point print as 0.9999999...
 // Grisu3 is too imprecise for real halfway cases (1.5 will not work) and
 // therefore the rounding strategy for halfway cases is irrelevant.
-static bool Grisu3Counted(double v, int requested_digits, Vector<char> buffer,
-                          int* length, int* decimal_exponent) {
+static bool Grisu3Counted(double v, int requested_digits,
+                          base::Vector<char> buffer, int* length,
+                          int* decimal_exponent) {
   DiyFp w = Double(v).AsNormalizedDiyFp();
   DiyFp ten_mk;  // Cached power of ten: 10^-k
   int mk;        // -k
@@ -660,7 +663,7 @@ static bool Grisu3Counted(double v, int requested_digits, Vector<char> buffer,
 }
 
 bool FastDtoa(double v, FastDtoaMode mode, int requested_digits,
-              Vector<char> buffer, int* length, int* decimal_point) {
+              base::Vector<char> buffer, int* length, int* decimal_point) {
   DCHECK_GT(v, 0);
   DCHECK(!Double(v).IsSpecial());
 
@@ -684,5 +687,5 @@ bool FastDtoa(double v, FastDtoaMode mode, int requested_digits,
   return result;
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/fast-dtoa.h b/src/numbers/fast-dtoa.h
similarity index 85%
rename from src/base/numbers/fast-dtoa.h
rename to src/numbers/fast-dtoa.h
index 0a10b090b3..467d095d7b 100644
--- a/src/base/numbers/fast-dtoa.h
+++ b/src/numbers/fast-dtoa.h
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_FAST_DTOA_H_
-#define V8_BASE_NUMBERS_FAST_DTOA_H_
+#ifndef V8_NUMBERS_FAST_DTOA_H_
+#define V8_NUMBERS_FAST_DTOA_H_
 
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 enum FastDtoaMode {
   // Computes the shortest representation of the given input. The returned
@@ -50,11 +50,11 @@ const int kFastDtoaMaximalLength = 17;
 //     If there are two values that are equally close, then FastDtoa returns
 //     false.
 // For both modes the buffer must be large enough to hold the result.
-V8_BASE_EXPORT bool FastDtoa(double d, FastDtoaMode mode, int requested_digits,
-                             Vector<char> buffer, int* length,
-                             int* decimal_point);
+V8_EXPORT_PRIVATE bool FastDtoa(double d, FastDtoaMode mode,
+                                int requested_digits, base::Vector<char> buffer,
+                                int* length, int* decimal_point);
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_FAST_DTOA_H_
+#endif  // V8_NUMBERS_FAST_DTOA_H_
diff --git a/src/base/numbers/fixed-dtoa.cc b/src/numbers/fixed-dtoa.cc
similarity index 93%
rename from src/base/numbers/fixed-dtoa.cc
rename to src/numbers/fixed-dtoa.cc
index f992537608..7e71d672aa 100644
--- a/src/base/numbers/fixed-dtoa.cc
+++ b/src/numbers/fixed-dtoa.cc
@@ -2,17 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/fixed-dtoa.h"
-
 #include <stdint.h>
 
 #include <cmath>
 
 #include "src/base/logging.h"
-#include "src/base/numbers/double.h"
+#include "src/utils/utils.h"
+
+#include "src/numbers/double.h"
+#include "src/numbers/fixed-dtoa.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 // Represents a 128bit type. This class should be replaced by a native type on
 // platforms that support 128bit integers.
@@ -96,7 +97,7 @@ class UInt128 {
 static const int kDoubleSignificandSize = 53;  // Includes the hidden bit.
 
 static void FillDigits32FixedLength(uint32_t number, int requested_length,
-                                    Vector<char> buffer, int* length) {
+                                    base::Vector<char> buffer, int* length) {
   for (int i = requested_length - 1; i >= 0; --i) {
     buffer[(*length) + i] = '0' + number % 10;
     number /= 10;
@@ -104,7 +105,8 @@ static void FillDigits32FixedLength(uint32_t number, int requested_length,
   *length += requested_length;
 }
 
-static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {
+static void FillDigits32(uint32_t number, base::Vector<char> buffer,
+                         int* length) {
   int number_length = 0;
   // We fill the digits in reverse order and exchange them afterwards.
   while (number != 0) {
@@ -127,7 +129,7 @@ static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {
 }
 
 static void FillDigits64FixedLength(uint64_t number, int requested_length,
-                                    Vector<char> buffer, int* length) {
+                                    base::Vector<char> buffer, int* length) {
   const uint32_t kTen7 = 10000000;
   // For efficiency cut the number into 3 uint32_t parts, and print those.
   uint32_t part2 = static_cast<uint32_t>(number % kTen7);
@@ -140,7 +142,8 @@ static void FillDigits64FixedLength(uint64_t number, int requested_length,
   FillDigits32FixedLength(part2, 7, buffer, length);
 }
 
-static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {
+static void FillDigits64(uint64_t number, base::Vector<char> buffer,
+                         int* length) {
   const uint32_t kTen7 = 10000000;
   // For efficiency cut the number into 3 uint32_t parts, and print those.
   uint32_t part2 = static_cast<uint32_t>(number % kTen7);
@@ -160,7 +163,8 @@ static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {
   }
 }
 
-static void DtoaRoundUp(Vector<char> buffer, int* length, int* decimal_point) {
+static void DtoaRoundUp(base::Vector<char> buffer, int* length,
+                        int* decimal_point) {
   // An empty buffer represents 0.
   if (*length == 0) {
     buffer[0] = '1';
@@ -201,7 +205,7 @@ static void DtoaRoundUp(Vector<char> buffer, int* length, int* decimal_point) {
 // already contained "199" (thus yielding a buffer of "19999") then a
 // rounding-up will change the contents of the buffer to "20000".
 static void FillFractionals(uint64_t fractionals, int exponent,
-                            int fractional_count, Vector<char> buffer,
+                            int fractional_count, base::Vector<char> buffer,
                             int* length, int* decimal_point) {
   DCHECK(-128 <= exponent && exponent <= 0);
   // 'fractionals' is a fixed-point number, with binary point at bit
@@ -258,7 +262,8 @@ static void FillFractionals(uint64_t fractionals, int exponent,
 
 // Removes leading and trailing zeros.
 // If leading zeros are removed then the decimal point position is adjusted.
-static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {
+static void TrimZeros(base::Vector<char> buffer, int* length,
+                      int* decimal_point) {
   while (*length > 0 && buffer[(*length) - 1] == '0') {
     (*length)--;
   }
@@ -275,7 +280,7 @@ static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {
   }
 }
 
-bool FastFixedDtoa(double v, int fractional_count, Vector<char> buffer,
+bool FastFixedDtoa(double v, int fractional_count, base::Vector<char> buffer,
                    int* length, int* decimal_point) {
   const uint32_t kMaxUInt32 = 0xFFFFFFFF;
   uint64_t significand = Double(v).Significand();
@@ -367,5 +372,5 @@ bool FastFixedDtoa(double v, int fractional_count, Vector<char> buffer,
   return true;
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/fixed-dtoa.h b/src/numbers/fixed-dtoa.h
similarity index 75%
rename from src/base/numbers/fixed-dtoa.h
rename to src/numbers/fixed-dtoa.h
index 94930da4ee..3a6dbe720d 100644
--- a/src/base/numbers/fixed-dtoa.h
+++ b/src/numbers/fixed-dtoa.h
@@ -2,13 +2,13 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_FIXED_DTOA_H_
-#define V8_BASE_NUMBERS_FIXED_DTOA_H_
+#ifndef V8_NUMBERS_FIXED_DTOA_H_
+#define V8_NUMBERS_FIXED_DTOA_H_
 
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 // Produces digits necessary to print a given number with
 // 'fractional_count' digits after the decimal point.
@@ -26,11 +26,11 @@ namespace base {
 //
 // This method only works for some parameters. If it can't handle the input it
 // returns false. The output is null-terminated when the function succeeds.
-V8_BASE_EXPORT bool FastFixedDtoa(double v, int fractional_count,
-                                  Vector<char> buffer, int* length,
-                                  int* decimal_point);
+V8_EXPORT_PRIVATE bool FastFixedDtoa(double v, int fractional_count,
+                                     base::Vector<char> buffer, int* length,
+                                     int* decimal_point);
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_FIXED_DTOA_H_
+#endif  // V8_NUMBERS_FIXED_DTOA_H_
diff --git a/src/base/numbers/strtod.cc b/src/numbers/strtod.cc
similarity index 90%
rename from src/base/numbers/strtod.cc
rename to src/numbers/strtod.cc
index f74bf43fca..6d0fae38c1 100644
--- a/src/base/numbers/strtod.cc
+++ b/src/numbers/strtod.cc
@@ -2,19 +2,19 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/numbers/strtod.h"
+#include "src/numbers/strtod.h"
 
 #include <stdarg.h>
-
 #include <cmath>
-#include <limits>
 
-#include "src/base/numbers/bignum.h"
-#include "src/base/numbers/cached-powers.h"
-#include "src/base/numbers/double.h"
+#include "src/common/globals.h"
+#include "src/numbers/bignum.h"
+#include "src/numbers/cached-powers.h"
+#include "src/numbers/double.h"
+#include "src/utils/utils.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 // 2^53 = 9007199254740992.
 // Any integer with at most 15 decimal digits will hence fit into a double
@@ -70,26 +70,28 @@ static const int kExactPowersOfTenSize = arraysize(exact_powers_of_ten);
 // we round up to 780.
 static const int kMaxSignificantDecimalDigits = 780;
 
-static Vector<const char> TrimLeadingZeros(Vector<const char> buffer) {
+static base::Vector<const char> TrimLeadingZeros(
+    base::Vector<const char> buffer) {
   for (int i = 0; i < buffer.length(); i++) {
     if (buffer[i] != '0') {
       return buffer.SubVector(i, buffer.length());
     }
   }
-  return Vector<const char>(buffer.begin(), 0);
+  return base::Vector<const char>(buffer.begin(), 0);
 }
 
-static Vector<const char> TrimTrailingZeros(Vector<const char> buffer) {
+static base::Vector<const char> TrimTrailingZeros(
+    base::Vector<const char> buffer) {
   for (int i = buffer.length() - 1; i >= 0; --i) {
     if (buffer[i] != '0') {
       return buffer.SubVector(0, i + 1);
     }
   }
-  return Vector<const char>(buffer.begin(), 0);
+  return base::Vector<const char>(buffer.begin(), 0);
 }
 
-static void TrimToMaxSignificantDigits(Vector<const char> buffer, int exponent,
-                                       char* significant_buffer,
+static void TrimToMaxSignificantDigits(base::Vector<const char> buffer,
+                                       int exponent, char* significant_buffer,
                                        int* significant_exponent) {
   for (int i = 0; i < kMaxSignificantDecimalDigits - 1; ++i) {
     significant_buffer[i] = buffer[i];
@@ -109,7 +111,7 @@ static void TrimToMaxSignificantDigits(Vector<const char> buffer, int exponent,
 // When the string starts with "1844674407370955161" no further digit is read.
 // Since 2^64 = 18446744073709551616 it would still be possible read another
 // digit if it was less or equal than 6, but this would complicate the code.
-static uint64_t ReadUint64(Vector<const char> buffer,
+static uint64_t ReadUint64(base::Vector<const char> buffer,
                            int* number_of_read_digits) {
   uint64_t result = 0;
   int i = 0;
@@ -126,7 +128,7 @@ static uint64_t ReadUint64(Vector<const char> buffer,
 // The returned DiyFp is not necessarily normalized.
 // If remaining_decimals is zero then the returned DiyFp is accurate.
 // Otherwise it has been rounded and has error of at most 1/2 ulp.
-static void ReadDiyFp(Vector<const char> buffer, DiyFp* result,
+static void ReadDiyFp(base::Vector<const char> buffer, DiyFp* result,
                       int* remaining_decimals) {
   int read_digits;
   uint64_t significand = ReadUint64(buffer, &read_digits);
@@ -145,7 +147,7 @@ static void ReadDiyFp(Vector<const char> buffer, DiyFp* result,
   }
 }
 
-static bool DoubleStrtod(Vector<const char> trimmed, int exponent,
+static bool DoubleStrtod(base::Vector<const char> trimmed, int exponent,
                          double* result) {
 #if (V8_TARGET_ARCH_IA32 || defined(USE_SIMULATOR)) && !defined(_MSC_VER)
   // On x86 the floating-point stack can be 64 or 80 bits wide. If it is
@@ -231,7 +233,7 @@ static DiyFp AdjustmentPowerOfTen(int exponent) {
 // If the function returns true then the result is the correct double.
 // Otherwise it is either the correct double or the double that is just below
 // the correct double.
-static bool DiyFpStrtod(Vector<const char> buffer, int exponent,
+static bool DiyFpStrtod(base::Vector<const char> buffer, int exponent,
                         double* result) {
   DiyFp input;
   int remaining_decimals;
@@ -345,9 +347,9 @@ static bool DiyFpStrtod(Vector<const char> buffer, int exponent,
 //   buffer.length() + exponent <= kMaxDecimalPower + 1
 //   buffer.length() + exponent > kMinDecimalPower
 //   buffer.length() <= kMaxDecimalSignificantDigits
-static double BignumStrtod(Vector<const char> buffer, int exponent,
+static double BignumStrtod(base::Vector<const char> buffer, int exponent,
                            double guess) {
-  if (guess == std::numeric_limits<double>::infinity()) {
+  if (guess == V8_INFINITY) {
     return guess;
   }
 
@@ -388,9 +390,9 @@ static double BignumStrtod(Vector<const char> buffer, int exponent,
   }
 }
 
-double Strtod(Vector<const char> buffer, int exponent) {
-  Vector<const char> left_trimmed = TrimLeadingZeros(buffer);
-  Vector<const char> trimmed = TrimTrailingZeros(left_trimmed);
+double Strtod(base::Vector<const char> buffer, int exponent) {
+  base::Vector<const char> left_trimmed = TrimLeadingZeros(buffer);
+  base::Vector<const char> trimmed = TrimTrailingZeros(left_trimmed);
   exponent += left_trimmed.length() - trimmed.length();
   if (trimmed.length() == 0) return 0.0;
   if (trimmed.length() > kMaxSignificantDecimalDigits) {
@@ -398,12 +400,11 @@ double Strtod(Vector<const char> buffer, int exponent) {
     int significant_exponent;
     TrimToMaxSignificantDigits(trimmed, exponent, significant_buffer,
                                &significant_exponent);
-    return Strtod(
-        Vector<const char>(significant_buffer, kMaxSignificantDecimalDigits),
-        significant_exponent);
+    return Strtod(base::Vector<const char>(significant_buffer,
+                                           kMaxSignificantDecimalDigits),
+                  significant_exponent);
   }
-  if (exponent + trimmed.length() - 1 >= kMaxDecimalPower)
-    return std::numeric_limits<double>::infinity();
+  if (exponent + trimmed.length() - 1 >= kMaxDecimalPower) return V8_INFINITY;
   if (exponent + trimmed.length() <= kMinDecimalPower) return 0.0;
 
   double guess;
@@ -414,5 +415,5 @@ double Strtod(Vector<const char> buffer, int exponent) {
   return BignumStrtod(trimmed, exponent, guess);
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/src/base/numbers/strtod.h b/src/numbers/strtod.h
similarity index 64%
rename from src/base/numbers/strtod.h
rename to src/numbers/strtod.h
index 7faeb934d3..6ca23ed1b4 100644
--- a/src/base/numbers/strtod.h
+++ b/src/numbers/strtod.h
@@ -2,19 +2,19 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_BASE_NUMBERS_STRTOD_H_
-#define V8_BASE_NUMBERS_STRTOD_H_
+#ifndef V8_NUMBERS_STRTOD_H_
+#define V8_NUMBERS_STRTOD_H_
 
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 // The buffer must only contain digits in the range [0-9]. It must not
 // contain a dot or a sign. It must not start with '0', and must not be empty.
-V8_BASE_EXPORT double Strtod(Vector<const char> buffer, int exponent);
+V8_EXPORT_PRIVATE double Strtod(base::Vector<const char> buffer, int exponent);
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
-#endif  // V8_BASE_NUMBERS_STRTOD_H_
+#endif  // V8_NUMBERS_STRTOD_H_
diff --git a/src/objects/bigint.cc b/src/objects/bigint.cc
index a4bb34c559..1213e88e3c 100644
--- a/src/objects/bigint.cc
+++ b/src/objects/bigint.cc
@@ -19,12 +19,12 @@
 
 #include "src/objects/bigint.h"
 
-#include "src/base/numbers/double.h"
 #include "src/bigint/bigint.h"
 #include "src/execution/isolate-inl.h"
 #include "src/heap/factory.h"
 #include "src/heap/heap-write-barrier-inl.h"
 #include "src/numbers/conversions.h"
+#include "src/numbers/double.h"
 #include "src/objects/heap-number-inl.h"
 #include "src/objects/instance-type-inl.h"
 #include "src/objects/objects-inl.h"
@@ -295,8 +295,7 @@ Handle<BigInt> MutableBigInt::NewFromDouble(Isolate* isolate, double value) {
   bool sign = value < 0;  // -0 was already handled above.
   uint64_t double_bits = bit_cast<uint64_t>(value);
   int raw_exponent =
-      static_cast<int>(double_bits >> base::Double::kPhysicalSignificandSize) &
-      0x7FF;
+      static_cast<int>(double_bits >> Double::kPhysicalSignificandSize) & 0x7FF;
   DCHECK_NE(raw_exponent, 0x7FF);
   DCHECK_GE(raw_exponent, 0x3FF);
   int exponent = raw_exponent - 0x3FF;
@@ -315,8 +314,8 @@ Handle<BigInt> MutableBigInt::NewFromDouble(Isolate* isolate, double value) {
   //          msd_topbit         kDigitBits
   //
   uint64_t mantissa =
-      (double_bits & base::Double::kSignificandMask) | base::Double::kHiddenBit;
-  const int kMantissaTopBit = base::Double::kSignificandSize - 1;  // 0-indexed.
+      (double_bits & Double::kSignificandMask) | Double::kHiddenBit;
+  const int kMantissaTopBit = Double::kSignificandSize - 1;  // 0-indexed.
   // 0-indexed position of most significant bit in the most significant digit.
   int msd_topbit = exponent % kDigitBits;
   // Number of unused bits in {mantissa}. We'll keep them shifted to the
@@ -913,9 +912,8 @@ ComparisonResult BigInt::CompareToDouble(Handle<BigInt> x, double y) {
   }
   uint64_t double_bits = bit_cast<uint64_t>(y);
   int raw_exponent =
-      static_cast<int>(double_bits >> base::Double::kPhysicalSignificandSize) &
-      0x7FF;
-  uint64_t mantissa = double_bits & base::Double::kSignificandMask;
+      static_cast<int>(double_bits >> Double::kPhysicalSignificandSize) & 0x7FF;
+  uint64_t mantissa = double_bits & Double::kSignificandMask;
   // Non-finite doubles are handled above.
   DCHECK_NE(raw_exponent, 0x7FF);
   int exponent = raw_exponent - 0x3FF;
@@ -946,7 +944,7 @@ ComparisonResult BigInt::CompareToDouble(Handle<BigInt> x, double y) {
   //                    <-->          <------>
   //              msd_topbit         kDigitBits
   //
-  mantissa |= base::Double::kHiddenBit;
+  mantissa |= Double::kHiddenBit;
   const int kMantissaTopBit = 52;  // 0-indexed.
   // 0-indexed position of {x}'s most significant bit within the {msd}.
   int msd_topbit = kDigitBits - 1 - msd_leading_zeros;
@@ -1109,7 +1107,7 @@ double MutableBigInt::ToDouble(Handle<BigIntBase> x) {
     mantissa++;
     // Incrementing the mantissa can overflow the mantissa bits. In that case
     // the new mantissa will be all zero (plus hidden bit).
-    if ((mantissa >> base::Double::kPhysicalSignificandSize) != 0) {
+    if ((mantissa >> Double::kPhysicalSignificandSize) != 0) {
       mantissa = 0;
       exponent++;
       // Incrementing the exponent can overflow too.
@@ -1120,7 +1118,7 @@ double MutableBigInt::ToDouble(Handle<BigIntBase> x) {
   }
   // Assemble the result.
   uint64_t sign_bit = x->sign() ? (static_cast<uint64_t>(1) << 63) : 0;
-  exponent = (exponent + 0x3FF) << base::Double::kPhysicalSignificandSize;
+  exponent = (exponent + 0x3FF) << Double::kPhysicalSignificandSize;
   uint64_t double_bits = sign_bit | exponent | mantissa;
   return bit_cast<double>(double_bits);
 }
diff --git a/src/objects/intl-objects.cc b/src/objects/intl-objects.cc
index 3ac85b609c..8bc7014a21 100644
--- a/src/objects/intl-objects.cc
+++ b/src/objects/intl-objects.cc
@@ -14,7 +14,6 @@
 #include <vector>
 
 #include "src/api/api-inl.h"
-#include "src/base/strings.h"
 #include "src/execution/isolate.h"
 #include "src/handles/global-handles.h"
 #include "src/heap/factory.h"
@@ -164,12 +163,12 @@ inline int FindFirstUpperOrNonAscii(String s, int length) {
 }
 
 const UChar* GetUCharBufferFromFlat(const String::FlatContent& flat,
-                                    std::unique_ptr<base::uc16[]>* dest,
+                                    std::unique_ptr<uc16[]>* dest,
                                     int32_t length) {
   DCHECK(flat.IsFlat());
   if (flat.IsOneByte()) {
     if (!*dest) {
-      dest->reset(NewArray<base::uc16>(length));
+      dest->reset(NewArray<uc16>(length));
       CopyChars(dest->get(), flat.ToOneByteVector().begin(), length);
     }
     return reinterpret_cast<const UChar*>(dest->get());
@@ -196,7 +195,7 @@ icu::UnicodeString Intl::ToICUUnicodeString(Isolate* isolate,
                                             Handle<String> string) {
   DCHECK(string->IsFlat());
   DisallowGarbageCollection no_gc;
-  std::unique_ptr<base::uc16[]> sap;
+  std::unique_ptr<uc16[]> sap;
   // Short one-byte strings can be expanded on the stack to avoid allocating a
   // temporary buffer.
   constexpr int kShortStringSize = 80;
@@ -238,7 +237,7 @@ MaybeHandle<String> LocaleConvertCase(Isolate* isolate, Handle<String> s,
   int32_t dest_length = src_length;
   UErrorCode status;
   Handle<SeqTwoByteString> result;
-  std::unique_ptr<base::uc16[]> sap;
+  std::unique_ptr<uc16[]> sap;
 
   if (dest_length == 0) return ReadOnlyRoots(isolate).empty_string_handle();
 
@@ -1961,7 +1960,7 @@ MaybeHandle<String> Intl::Normalize(Isolate* isolate, Handle<String> string,
   int length = string->length();
   string = String::Flatten(isolate, string);
   icu::UnicodeString result;
-  std::unique_ptr<base::uc16[]> sap;
+  std::unique_ptr<uc16[]> sap;
   UErrorCode status = U_ZERO_ERROR;
   icu::UnicodeString input = ToICUUnicodeString(isolate, string);
   // Getting a singleton. Should not free it.
diff --git a/src/objects/js-regexp.cc b/src/objects/js-regexp.cc
index bfc16d1b85..b5e9978390 100644
--- a/src/objects/js-regexp.cc
+++ b/src/objects/js-regexp.cc
@@ -4,7 +4,6 @@
 
 #include "src/objects/js-regexp.h"
 
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 #include "src/objects/js-array-inl.h"
 #include "src/objects/js-regexp-inl.h"
@@ -384,7 +383,7 @@ MaybeHandle<String> EscapeRegExpSource(Isolate* isolate,
   bool needs_escapes = false;
   int additional_escape_chars =
       one_byte ? CountAdditionalEscapeChars<uint8_t>(source, &needs_escapes)
-               : CountAdditionalEscapeChars<base::uc16>(source, &needs_escapes);
+               : CountAdditionalEscapeChars<uc16>(source, &needs_escapes);
   if (!needs_escapes) return source;
   int length = source->length() + additional_escape_chars;
   if (one_byte) {
@@ -398,7 +397,7 @@ MaybeHandle<String> EscapeRegExpSource(Isolate* isolate,
     ASSIGN_RETURN_ON_EXCEPTION(isolate, result,
                                isolate->factory()->NewRawTwoByteString(length),
                                String);
-    return WriteEscapedRegExpSource<base::uc16>(source, result);
+    return WriteEscapedRegExpSource<uc16>(source, result);
   }
 }
 
diff --git a/src/objects/objects-inl.h b/src/objects/objects-inl.h
index 4815c702a5..43e526d7af 100644
--- a/src/objects/objects-inl.h
+++ b/src/objects/objects-inl.h
@@ -14,7 +14,6 @@
 
 #include "src/base/bits.h"
 #include "src/base/memory.h"
-#include "src/base/numbers/double.h"
 #include "src/builtins/builtins.h"
 #include "src/common/external-pointer-inl.h"
 #include "src/common/globals.h"
@@ -23,6 +22,7 @@
 #include "src/heap/heap-write-barrier-inl.h"
 #include "src/heap/read-only-heap-inl.h"
 #include "src/numbers/conversions-inl.h"
+#include "src/numbers/double.h"
 #include "src/objects/bigint.h"
 #include "src/objects/heap-number-inl.h"
 #include "src/objects/heap-object.h"
@@ -1056,7 +1056,7 @@ Object Object::GetSimpleHash(Object object) {
     if (num >= kMinInt && num <= kMaxInt && FastI2D(FastD2I(num)) == num) {
       hash = ComputeUnseededHash(FastD2I(num));
     } else {
-      hash = ComputeLongHash(base::double_to_uint64(num));
+      hash = ComputeLongHash(double_to_uint64(num));
     }
     return Smi::FromInt(hash & Smi::kMaxValue);
   }
diff --git a/src/objects/stack-frame-info.cc b/src/objects/stack-frame-info.cc
index 08675bc49e..965577bec3 100644
--- a/src/objects/stack-frame-info.cc
+++ b/src/objects/stack-frame-info.cc
@@ -4,7 +4,6 @@
 
 #include "src/objects/stack-frame-info.h"
 
-#include "src/base/strings.h"
 #include "src/objects/shared-function-info.h"
 #include "src/objects/stack-frame-info-inl.h"
 #include "src/strings/string-builder-inl.h"
@@ -619,7 +618,7 @@ bool StringEndsWithMethodName(Isolate* isolate, Handle<String> subject,
       return false;
     }
 
-    const base::uc32 subject_char = subject_reader.Get(subject_index);
+    const uc32 subject_char = subject_reader.Get(subject_index);
     if (i == pattern_reader.length()) {
       if (subject_char != '.') return false;
     } else if (subject_char != pattern_reader.Get(pattern_index)) {
diff --git a/src/objects/string-inl.h b/src/objects/string-inl.h
index d5e7fda181..16210cda96 100644
--- a/src/objects/string-inl.h
+++ b/src/objects/string-inl.h
@@ -300,11 +300,11 @@ bool String::IsOneByteRepresentationUnderneath(String string) {
   }
 }
 
-base::uc32 FlatStringReader::Get(int index) const {
+uc32 FlatStringReader::Get(int index) const {
   if (is_one_byte_) {
     return Get<uint8_t>(index);
   } else {
-    return Get<base::uc16>(index);
+    return Get<uc16>(index);
   }
 }
 
@@ -315,7 +315,7 @@ Char FlatStringReader::Get(int index) const {
   if (sizeof(Char) == 1) {
     return static_cast<Char>(static_cast<const uint8_t*>(start_)[index]);
   } else {
-    return static_cast<Char>(static_cast<const base::uc16*>(start_)[index]);
+    return static_cast<Char>(static_cast<const uc16*>(start_)[index]);
   }
 }
 
@@ -766,7 +766,7 @@ inline base::Vector<const uint8_t> String::GetCharVector(
 }
 
 template <>
-inline base::Vector<const base::uc16> String::GetCharVector(
+inline base::Vector<const uc16> String::GetCharVector(
     const DisallowGarbageCollection& no_gc) {
   String::FlatContent flat = GetFlatContent(no_gc);
   DCHECK(flat.IsTwoByte());
@@ -813,19 +813,18 @@ Address SeqTwoByteString::GetCharsAddress() const {
   return field_address(kHeaderSize);
 }
 
-base::uc16* SeqTwoByteString::GetChars(
-    const DisallowGarbageCollection& no_gc) const {
+uc16* SeqTwoByteString::GetChars(const DisallowGarbageCollection& no_gc) const {
   USE(no_gc);
   DCHECK(!SharedStringAccessGuardIfNeeded::IsNeeded(*this));
-  return reinterpret_cast<base::uc16*>(GetCharsAddress());
+  return reinterpret_cast<uc16*>(GetCharsAddress());
 }
 
-base::uc16* SeqTwoByteString::GetChars(
+uc16* SeqTwoByteString::GetChars(
     const DisallowGarbageCollection& no_gc,
     const SharedStringAccessGuardIfNeeded& access_guard) const {
   USE(no_gc);
   USE(access_guard);
-  return reinterpret_cast<base::uc16*>(GetCharsAddress());
+  return reinterpret_cast<uc16*>(GetCharsAddress());
 }
 
 uint16_t SeqTwoByteString::Get(
@@ -1194,13 +1193,13 @@ class SubStringRange::iterator final {
  public:
   using iterator_category = std::forward_iterator_tag;
   using difference_type = int;
-  using value_type = base::uc16;
-  using pointer = base::uc16*;
-  using reference = base::uc16&;
+  using value_type = uc16;
+  using pointer = uc16*;
+  using reference = uc16&;
 
   iterator(const iterator& other) = default;
 
-  base::uc16 operator*() { return content_.Get(offset_); }
+  uc16 operator*() { return content_.Get(offset_); }
   bool operator==(const iterator& other) const {
     return content_.UsesSameString(other.content_) && offset_ == other.offset_;
   }
diff --git a/src/objects/string.cc b/src/objects/string.cc
index 7af83a5175..d68e142580 100644
--- a/src/objects/string.cc
+++ b/src/objects/string.cc
@@ -156,7 +156,7 @@ bool String::MakeExternal(v8::String::ExternalStringResource* resource) {
   if (FLAG_enable_slow_asserts) {
     // Assert that the resource and the string are equivalent.
     DCHECK(static_cast<size_t>(this->length()) == resource->length());
-    base::ScopedVector<base::uc16> smart_chars(this->length());
+    base::ScopedVector<uc16> smart_chars(this->length());
     String::WriteToFlat(*this, smart_chars.begin(), 0, this->length());
     DCHECK_EQ(0, memcmp(smart_chars.begin(), resource->data(),
                         resource->length() * sizeof(smart_chars[0])));
@@ -572,7 +572,7 @@ String::FlatContent String::GetFlatContent(
     return FlatContent(start + offset, length, no_gc);
   } else {
     DCHECK_EQ(shape.encoding_tag(), kTwoByteStringTag);
-    const base::uc16* start;
+    const uc16* start;
     if (shape.representation_tag() == kSeqStringTag) {
       start = SeqTwoByteString::cast(string).GetChars(no_gc);
     } else {
@@ -654,7 +654,7 @@ void String::WriteToFlat(String source, sinkchar* sink, int from, int to,
         return;
       }
       case kTwoByteStringTag | kExternalStringTag: {
-        const base::uc16* data = ExternalTwoByteString::cast(source).GetChars();
+        const uc16* data = ExternalTwoByteString::cast(source).GetChars();
         CopyChars(sink, data + from, to - from);
         return;
       }
@@ -947,16 +947,16 @@ ComparisonResult String::Compare(Isolate* isolate, Handle<String> x,
       base::Vector<const uint8_t> y_chars = y_content.ToOneByteVector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     } else {
-      base::Vector<const base::uc16> y_chars = y_content.ToUC16Vector();
+      base::Vector<const uc16> y_chars = y_content.ToUC16Vector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     }
   } else {
-    base::Vector<const base::uc16> x_chars = x_content.ToUC16Vector();
+    base::Vector<const uc16> x_chars = x_content.ToUC16Vector();
     if (y_content.IsOneByte()) {
       base::Vector<const uint8_t> y_chars = y_content.ToOneByteVector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     } else {
-      base::Vector<const base::uc16> y_chars = y_content.ToUC16Vector();
+      base::Vector<const uc16> y_chars = y_content.ToUC16Vector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     }
   }
@@ -1043,9 +1043,9 @@ int String::IndexOf(Isolate* isolate, Handle<String> receiver,
     return SearchString<const uint8_t>(isolate, receiver_content, pat_vector,
                                        start_index);
   }
-  base::Vector<const base::uc16> pat_vector = search_content.ToUC16Vector();
-  return SearchString<const base::uc16>(isolate, receiver_content, pat_vector,
-                                        start_index);
+  base::Vector<const uc16> pat_vector = search_content.ToUC16Vector();
+  return SearchString<const uc16>(isolate, receiver_content, pat_vector,
+                                  start_index);
 }
 
 MaybeHandle<String> String::GetSubstitution(Isolate* isolate, Match* match,
@@ -1219,7 +1219,7 @@ int StringMatchBackwards(base::Vector<const schar> subject,
 
   if (sizeof(schar) == 1 && sizeof(pchar) > 1) {
     for (int i = 0; i < pattern_length; i++) {
-      base::uc16 c = pattern[i];
+      uc16 c = pattern[i];
       if (c > String::kMaxOneByteCharCode) {
         return -1;
       }
@@ -1304,7 +1304,7 @@ Object String::LastIndexOf(Isolate* isolate, Handle<Object> receiver,
                                         pat_vector, start_index);
     }
   } else {
-    base::Vector<const base::uc16> pat_vector = search_content.ToUC16Vector();
+    base::Vector<const uc16> pat_vector = search_content.ToUC16Vector();
     if (receiver_content.IsOneByte()) {
       last_index = StringMatchBackwards(receiver_content.ToOneByteVector(),
                                         pat_vector, start_index);
@@ -1469,7 +1469,7 @@ void SeqOneByteString::clear_padding() {
 }
 
 void SeqTwoByteString::clear_padding() {
-  int data_size = SeqString::kHeaderSize + length() * base::kUC16Size;
+  int data_size = SeqString::kHeaderSize + length() * kUC16Size;
   memset(reinterpret_cast<void*>(address() + data_size), 0,
          SizeFor(length()) - data_size);
 }
diff --git a/src/objects/string.h b/src/objects/string.h
index 184f4ba4fb..f56c0a971c 100644
--- a/src/objects/string.h
+++ b/src/objects/string.h
@@ -9,7 +9,6 @@
 
 #include "src/base/bits.h"
 #include "src/base/export-template.h"
-#include "src/base/strings.h"
 #include "src/objects/instance-type.h"
 #include "src/objects/name.h"
 #include "src/objects/smi.h"
@@ -125,12 +124,12 @@ class String : public TorqueGeneratedString<String, Name> {
     }
     // Return the two-byte content of the string. Only use if IsTwoByte()
     // returns true.
-    base::Vector<const base::uc16> ToUC16Vector() const {
+    base::Vector<const uc16> ToUC16Vector() const {
       DCHECK_EQ(TWO_BYTE, state_);
-      return base::Vector<const base::uc16>(twobyte_start, length_);
+      return base::Vector<const uc16>(twobyte_start, length_);
     }
 
-    base::uc16 Get(int i) const {
+    uc16 Get(int i) const {
       DCHECK(i < length_);
       DCHECK(state_ != NON_FLAT);
       if (state_ == ONE_BYTE) return onebyte_start[i];
@@ -151,7 +150,7 @@ class String : public TorqueGeneratedString<String, Name> {
           length_(length),
           state_(ONE_BYTE),
           no_gc_(no_gc) {}
-    FlatContent(const base::uc16* start, int length,
+    FlatContent(const uc16* start, int length,
                 const DisallowGarbageCollection& no_gc)
         : twobyte_start(start),
           length_(length),
@@ -162,7 +161,7 @@ class String : public TorqueGeneratedString<String, Name> {
 
     union {
       const uint8_t* onebyte_start;
-      const base::uc16* twobyte_start;
+      const uc16* twobyte_start;
     };
     int length_;
     State state_;
@@ -251,7 +250,7 @@ class String : public TorqueGeneratedString<String, Name> {
       AllocationType allocation = AllocationType::kYoung);
 
   // Tries to return the content of a flat string as a structure holding either
-  // a flat vector of char or of base::uc16.
+  // a flat vector of char or of uc16.
   // If the string isn't flat, and therefore doesn't have flat content, the
   // returned structure will report so, and can't provide a vector of either
   // kind.
@@ -433,7 +432,7 @@ class String : public TorqueGeneratedString<String, Name> {
   static const uint32_t kMaxOneByteCharCodeU = unibrow::Latin1::kMaxChar;
   static const int kMaxUtf16CodeUnit = 0xffff;
   static const uint32_t kMaxUtf16CodeUnitU = kMaxUtf16CodeUnit;
-  static const base::uc32 kMaxCodePoint = 0x10ffff;
+  static const uc32 kMaxCodePoint = 0x10ffff;
 
   // Maximal string length.
   // The max length is different on 32 and 64 bit platforms. Max length for
@@ -482,8 +481,8 @@ class String : public TorqueGeneratedString<String, Name> {
     return NonAsciiStart(chars, length) >= length;
   }
 
-  static inline int NonOneByteStart(const base::uc16* chars, int length) {
-    DCHECK(IsAligned(reinterpret_cast<Address>(chars), sizeof(base::uc16)));
+  static inline int NonOneByteStart(const uc16* chars, int length) {
+    DCHECK(IsAligned(reinterpret_cast<Address>(chars), sizeof(uc16)));
     const uint16_t* start = chars;
     const uint16_t* limit = chars + length;
 
@@ -507,7 +506,7 @@ class String : public TorqueGeneratedString<String, Name> {
         if (*reinterpret_cast<const uintptr_t*>(chars) & non_one_byte_mask) {
           break;
         }
-        chars += (sizeof(uintptr_t) / sizeof(base::uc16));
+        chars += (sizeof(uintptr_t) / sizeof(uc16));
       }
     }
 
@@ -522,7 +521,7 @@ class String : public TorqueGeneratedString<String, Name> {
     return static_cast<int>(chars - start);
   }
 
-  static inline bool IsOneByte(const base::uc16* chars, int length) {
+  static inline bool IsOneByte(const uc16* chars, int length) {
     return NonOneByteStart(chars, length) >= length;
   }
 
@@ -701,10 +700,10 @@ class SeqTwoByteString
   // Get a pointer to the characters of the string. May only be called when a
   // SharedStringAccessGuard is not needed (i.e. on the main thread or on
   // read-only strings).
-  inline base::uc16* GetChars(const DisallowGarbageCollection& no_gc) const;
+  inline uc16* GetChars(const DisallowGarbageCollection& no_gc) const;
 
   // Get a pointer to the characters of the string.
-  inline base::uc16* GetChars(
+  inline uc16* GetChars(
       const DisallowGarbageCollection& no_gc,
       const SharedStringAccessGuardIfNeeded& access_guard) const;
 
@@ -959,7 +958,7 @@ class V8_EXPORT_PRIVATE FlatStringReader : public Relocatable {
  public:
   FlatStringReader(Isolate* isolate, Handle<String> str);
   void PostGarbageCollection() override;
-  inline base::uc32 Get(int index) const;
+  inline uc32 Get(int index) const;
   template <typename Char>
   inline Char Get(int index) const;
   int length() { return length_; }
diff --git a/src/objects/value-serializer.cc b/src/objects/value-serializer.cc
index a2345102c9..ba74177f7c 100644
--- a/src/objects/value-serializer.cc
+++ b/src/objects/value-serializer.cc
@@ -315,10 +315,10 @@ void ValueSerializer::WriteOneByteString(base::Vector<const uint8_t> chars) {
   WriteRawBytes(chars.begin(), chars.length() * sizeof(uint8_t));
 }
 
-void ValueSerializer::WriteTwoByteString(base::Vector<const base::uc16> chars) {
+void ValueSerializer::WriteTwoByteString(base::Vector<const uc16> chars) {
   // Warning: this uses host endianness.
-  WriteVarint<uint32_t>(chars.length() * sizeof(base::uc16));
-  WriteRawBytes(chars.begin(), chars.length() * sizeof(base::uc16));
+  WriteVarint<uint32_t>(chars.length() * sizeof(uc16));
+  WriteRawBytes(chars.begin(), chars.length() * sizeof(uc16));
 }
 
 void ValueSerializer::WriteBigIntContents(BigInt bigint) {
@@ -497,8 +497,8 @@ void ValueSerializer::WriteString(Handle<String> string) {
     WriteTag(SerializationTag::kOneByteString);
     WriteOneByteString(chars);
   } else if (flat.IsTwoByte()) {
-    base::Vector<const base::uc16> chars = flat.ToUC16Vector();
-    uint32_t byte_length = chars.length() * sizeof(base::uc16);
+    base::Vector<const uc16> chars = flat.ToUC16Vector();
+    uint32_t byte_length = chars.length() * sizeof(uc16);
     // The existing reading code expects 16-byte strings to be aligned.
     if ((buffer_size_ + 1 + BytesNeededForVarint(byte_length)) & 1)
       WriteTag(SerializationTag::kPadding);
@@ -1447,7 +1447,7 @@ MaybeHandle<String> ValueDeserializer::ReadTwoByteString() {
   if (!ReadVarint<uint32_t>().To(&byte_length) ||
       byte_length >
           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()) ||
-      byte_length % sizeof(base::uc16) != 0 ||
+      byte_length % sizeof(uc16) != 0 ||
       !ReadRawBytes(byte_length).To(&bytes)) {
     return MaybeHandle<String>();
   }
@@ -1457,7 +1457,7 @@ MaybeHandle<String> ValueDeserializer::ReadTwoByteString() {
   if (byte_length == 0) return isolate_->factory()->empty_string();
   Handle<SeqTwoByteString> string;
   if (!isolate_->factory()
-           ->NewRawTwoByteString(byte_length / sizeof(base::uc16))
+           ->NewRawTwoByteString(byte_length / sizeof(uc16))
            .ToHandle(&string)) {
     return MaybeHandle<String>();
   }
@@ -1496,9 +1496,8 @@ bool ValueDeserializer::ReadExpectedString(Handle<String> expected) {
       return true;
     }
   } else if (tag == SerializationTag::kTwoByteString && flat.IsTwoByte()) {
-    base::Vector<const base::uc16> chars = flat.ToUC16Vector();
-    if (byte_length ==
-            static_cast<unsigned>(chars.length()) * sizeof(base::uc16) &&
+    base::Vector<const uc16> chars = flat.ToUC16Vector();
+    if (byte_length == static_cast<unsigned>(chars.length()) * sizeof(uc16) &&
         memcmp(bytes.begin(), chars.begin(), byte_length) == 0) {
       return true;
     }
diff --git a/src/objects/value-serializer.h b/src/objects/value-serializer.h
index 8a381d1691..3b9e3a7361 100644
--- a/src/objects/value-serializer.h
+++ b/src/objects/value-serializer.h
@@ -11,7 +11,6 @@
 #include "include/v8.h"
 #include "src/base/compiler-specific.h"
 #include "src/base/macros.h"
-#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/common/message-template.h"
 #include "src/handles/maybe-handles.h"
@@ -107,7 +106,7 @@ class ValueSerializer {
   template <typename T>
   void WriteZigZag(T value);
   void WriteOneByteString(base::Vector<const uint8_t> chars);
-  void WriteTwoByteString(base::Vector<const base::uc16> chars);
+  void WriteTwoByteString(base::Vector<const uc16> chars);
   void WriteBigIntContents(BigInt bigint);
   Maybe<uint8_t*> ReserveRawBytes(size_t bytes);
 
diff --git a/src/parsing/literal-buffer.cc b/src/parsing/literal-buffer.cc
index 25388e938a..de74b4d9f1 100644
--- a/src/parsing/literal-buffer.cc
+++ b/src/parsing/literal-buffer.cc
@@ -4,7 +4,6 @@
 
 #include "src/parsing/literal-buffer.h"
 
-#include "src/base/strings.h"
 #include "src/execution/isolate.h"
 #include "src/execution/local-isolate.h"
 #include "src/heap/factory.h"
@@ -44,7 +43,7 @@ void LiteralBuffer::ExpandBuffer() {
 void LiteralBuffer::ConvertToTwoByte() {
   DCHECK(is_one_byte());
   base::Vector<byte> new_store;
-  int new_content_size = position_ * base::kUC16Size;
+  int new_content_size = position_ * kUC16Size;
   if (new_content_size >= backing_store_.length()) {
     // Ensure room for all currently read code units as UC16 as well
     // as the code unit about to be stored.
@@ -65,21 +64,21 @@ void LiteralBuffer::ConvertToTwoByte() {
   is_one_byte_ = false;
 }
 
-void LiteralBuffer::AddTwoByteChar(base::uc32 code_unit) {
+void LiteralBuffer::AddTwoByteChar(uc32 code_unit) {
   DCHECK(!is_one_byte());
   if (position_ >= backing_store_.length()) ExpandBuffer();
   if (code_unit <=
-      static_cast<base::uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
+      static_cast<uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
     *reinterpret_cast<uint16_t*>(&backing_store_[position_]) = code_unit;
-    position_ += base::kUC16Size;
+    position_ += kUC16Size;
   } else {
     *reinterpret_cast<uint16_t*>(&backing_store_[position_]) =
         unibrow::Utf16::LeadSurrogate(code_unit);
-    position_ += base::kUC16Size;
+    position_ += kUC16Size;
     if (position_ >= backing_store_.length()) ExpandBuffer();
     *reinterpret_cast<uint16_t*>(&backing_store_[position_]) =
         unibrow::Utf16::TrailSurrogate(code_unit);
-    position_ += base::kUC16Size;
+    position_ += kUC16Size;
   }
 }
 
diff --git a/src/parsing/literal-buffer.h b/src/parsing/literal-buffer.h
index 408c11381e..0f28b16b34 100644
--- a/src/parsing/literal-buffer.h
+++ b/src/parsing/literal-buffer.h
@@ -5,7 +5,6 @@
 #ifndef V8_PARSING_LITERAL_BUFFER_H_
 #define V8_PARSING_LITERAL_BUFFER_H_
 
-#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/strings/unicode-decoder.h"
 
@@ -27,9 +26,9 @@ class LiteralBuffer final {
     AddOneByteChar(static_cast<byte>(code_unit));
   }
 
-  V8_INLINE void AddChar(base::uc32 code_unit) {
+  V8_INLINE void AddChar(uc32 code_unit) {
     if (is_one_byte()) {
-      if (code_unit <= static_cast<base::uc32>(unibrow::Latin1::kMaxChar)) {
+      if (code_unit <= static_cast<uc32>(unibrow::Latin1::kMaxChar)) {
         AddOneByteChar(static_cast<byte>(code_unit));
         return;
       }
@@ -92,7 +91,7 @@ class LiteralBuffer final {
     position_ += kOneByteSize;
   }
 
-  void AddTwoByteChar(base::uc32 code_unit);
+  void AddTwoByteChar(uc32 code_unit);
   int NewCapacity(int min_capacity);
   void ExpandBuffer();
   void ConvertToTwoByte();
diff --git a/src/parsing/scanner-character-streams.cc b/src/parsing/scanner-character-streams.cc
index becc72c12d..8b42d9914a 100644
--- a/src/parsing/scanner-character-streams.cc
+++ b/src/parsing/scanner-character-streams.cc
@@ -8,7 +8,6 @@
 #include <vector>
 
 #include "include/v8.h"
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 #include "src/handles/handles.h"
 #include "src/logging/runtime-call-stats-scope.h"
@@ -279,7 +278,7 @@ class BufferedCharacterStream : public Utf16CharacterStream {
       : byte_stream_(other.byte_stream_) {}
 
   static const size_t kBufferSize = 512;
-  base::uc16 buffer_[kBufferSize];
+  uc16 buffer_[kBufferSize];
   ByteStream<uint8_t> byte_stream_;
 };
 
@@ -393,7 +392,7 @@ class BufferedUtf16CharacterStream : public Utf16CharacterStream {
 
   // Fixed sized buffer that this class reads from.
   // The base class' buffer_start_ should always point to buffer_.
-  base::uc16 buffer_[kBufferSize];
+  uc16 buffer_[kBufferSize];
 };
 
 BufferedUtf16CharacterStream::BufferedUtf16CharacterStream()
@@ -419,7 +418,7 @@ bool BufferedUtf16CharacterStream::ReadBlock() {
 
 namespace {
 
-static const base::uc16 kWindows1252ToUC16[256] = {
+static const uc16 kWindows1252ToUC16[256] = {
     0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,  // 00-07
     0x0008, 0x0009, 0x000A, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F,  // 08-0F
     0x0010, 0x0011, 0x0012, 0x0013, 0x0014, 0x0015, 0x0016, 0x0017,  // 10-17
@@ -505,7 +504,7 @@ class Windows1252CharacterStream final : public Utf16CharacterStream {
       V8_NOEXCEPT : byte_stream_(other.byte_stream_) {}
 
   static const size_t kBufferSize = 512;
-  base::uc16 buffer_[kBufferSize];
+  uc16 buffer_[kBufferSize];
   ChunkedStream<uint8_t> byte_stream_;
 };
 
@@ -654,7 +653,7 @@ void Utf8ExternalStreamingStream::FillBufferFromCurrentChunk() {
     unibrow::uchar t = unibrow::Utf8::ValueOfIncrementalFinish(&state);
     if (t != unibrow::Utf8::kBufferEmpty) {
       DCHECK_EQ(t, unibrow::Utf8::kBadChar);
-      *output_cursor = static_cast<base::uc16>(t);
+      *output_cursor = static_cast<uc16>(t);
       buffer_end_++;
       current_.pos.chars++;
       current_.pos.incomplete_char = 0;
@@ -673,14 +672,13 @@ void Utf8ExternalStreamingStream::FillBufferFromCurrentChunk() {
       unibrow::uchar t =
           unibrow::Utf8::ValueOfIncremental(&cursor, &state, &incomplete_char);
       if (V8_LIKELY(t < kUtf8Bom)) {
-        *(output_cursor++) =
-            static_cast<base::uc16>(t);  // The most frequent case.
+        *(output_cursor++) = static_cast<uc16>(t);  // The most frequent case.
       } else if (t == unibrow::Utf8::kIncomplete) {
         continue;
       } else if (t == kUtf8Bom) {
         // BOM detected at beginning of the stream. Don't copy it.
       } else if (t <= unibrow::Utf16::kMaxNonSurrogateCharCode) {
-        *(output_cursor++) = static_cast<base::uc16>(t);
+        *(output_cursor++) = static_cast<uc16>(t);
       } else {
         *(output_cursor++) = unibrow::Utf16::LeadSurrogate(t);
         *(output_cursor++) = unibrow::Utf16::TrailSurrogate(t);
@@ -694,8 +692,7 @@ void Utf8ExternalStreamingStream::FillBufferFromCurrentChunk() {
     unibrow::uchar t =
         unibrow::Utf8::ValueOfIncremental(&cursor, &state, &incomplete_char);
     if (V8_LIKELY(t <= unibrow::Utf16::kMaxNonSurrogateCharCode)) {
-      *(output_cursor++) =
-          static_cast<base::uc16>(t);  // The most frequent case.
+      *(output_cursor++) = static_cast<uc16>(t);  // The most frequent case.
     } else if (t == unibrow::Utf8::kIncomplete) {
       continue;
     } else {
diff --git a/src/parsing/scanner-inl.h b/src/parsing/scanner-inl.h
index 0e191330c0..6bcc12cfd9 100644
--- a/src/parsing/scanner-inl.h
+++ b/src/parsing/scanner-inl.h
@@ -251,7 +251,7 @@ static constexpr const uint8_t character_scan_flags[128] = {
 #undef CALL_GET_SCAN_FLAGS
 };
 
-inline bool CharCanBeKeyword(base::uc32 c) {
+inline bool CharCanBeKeyword(uc32 c) {
   return static_cast<uint32_t>(c) < arraysize(character_scan_flags) &&
          CanBeKeyword(character_scan_flags[c]);
 }
@@ -273,7 +273,7 @@ V8_INLINE Token::Value Scanner::ScanIdentifierOrKeywordInner() {
       // Otherwise we'll fall into the slow path after scanning the identifier.
       DCHECK(!IdentifierNeedsSlowPath(scan_flags));
       AddLiteralChar(static_cast<char>(c0_));
-      AdvanceUntil([this, &scan_flags](base::uc32 c0) {
+      AdvanceUntil([this, &scan_flags](uc32 c0) {
         if (V8_UNLIKELY(static_cast<uint32_t>(c0) > kMaxAscii)) {
           // A non-ascii character means we need to drop through to the slow
           // path.
@@ -305,7 +305,7 @@ V8_INLINE Token::Value Scanner::ScanIdentifierOrKeywordInner() {
     } else {
       // Special case for escapes at the start of an identifier.
       escaped = true;
-      base::uc32 c = ScanIdentifierUnicodeEscape();
+      uc32 c = ScanIdentifierUnicodeEscape();
       DCHECK(!IsIdentifierStart(Invalid()));
       if (c == '\\' || !IsIdentifierStart(c)) {
         return Token::ILLEGAL;
@@ -454,7 +454,7 @@ V8_INLINE Token::Value Scanner::ScanSingleToken() {
           // /  // /* /=
           Advance();
           if (c0_ == '/') {
-            base::uc32 c = Peek();
+            uc32 c = Peek();
             if (c == '#' || c == '@') {
               Advance();
               Advance();
diff --git a/src/parsing/scanner.cc b/src/parsing/scanner.cc
index b624694295..6dd3dbcb0f 100644
--- a/src/parsing/scanner.cc
+++ b/src/parsing/scanner.cc
@@ -12,7 +12,6 @@
 
 #include "src/ast/ast-value-factory.h"
 #include "src/base/platform/wrappers.h"
-#include "src/base/strings.h"
 #include "src/numbers/conversions-inl.h"
 #include "src/objects/bigint.h"
 #include "src/parsing/parse-info.h"
@@ -110,19 +109,19 @@ void Scanner::Initialize() {
 }
 
 // static
-bool Scanner::IsInvalid(base::uc32 c) {
+bool Scanner::IsInvalid(uc32 c) {
   DCHECK(c == Invalid() || base::IsInRange(c, 0u, String::kMaxCodePoint));
   return c == Scanner::Invalid();
 }
 
 template <bool capture_raw, bool unicode>
-base::uc32 Scanner::ScanHexNumber(int expected_length) {
+uc32 Scanner::ScanHexNumber(int expected_length) {
   DCHECK_LE(expected_length, 4);  // prevent overflow
 
   int begin = source_pos() - 2;
-  base::uc32 x = 0;
+  uc32 x = 0;
   for (int i = 0; i < expected_length; i++) {
-    int d = base::HexValue(c0_);
+    int d = HexValue(c0_);
     if (d < 0) {
       ReportScannerError(Location(begin, begin + expected_length + 2),
                          unicode
@@ -138,10 +137,9 @@ base::uc32 Scanner::ScanHexNumber(int expected_length) {
 }
 
 template <bool capture_raw>
-base::uc32 Scanner::ScanUnlimitedLengthHexNumber(base::uc32 max_value,
-                                                 int beg_pos) {
-  base::uc32 x = 0;
-  int d = base::HexValue(c0_);
+uc32 Scanner::ScanUnlimitedLengthHexNumber(uc32 max_value, int beg_pos) {
+  uc32 x = 0;
+  int d = HexValue(c0_);
   if (d < 0) return Invalid();
 
   while (d >= 0) {
@@ -152,7 +150,7 @@ base::uc32 Scanner::ScanUnlimitedLengthHexNumber(base::uc32 max_value,
       return Invalid();
     }
     Advance<capture_raw>();
-    d = base::HexValue(c0_);
+    d = HexValue(c0_);
   }
 
   return x;
@@ -211,7 +209,7 @@ Token::Value Scanner::SkipSingleLineComment() {
   // separately by the lexical grammar and becomes part of the
   // stream of input elements for the syntactic grammar (see
   // ECMA-262, section 7.4).
-  AdvanceUntil([](base::uc32 c0_) { return unibrow::IsLineTerminator(c0_); });
+  AdvanceUntil([](uc32 c0_) { return unibrow::IsLineTerminator(c0_); });
 
   return Token::WHITESPACE;
 }
@@ -278,7 +276,7 @@ Token::Value Scanner::SkipMultiLineComment() {
   // Until we see the first newline, check for * and newline characters.
   if (!next().after_line_terminator) {
     do {
-      AdvanceUntil([](base::uc32 c0) {
+      AdvanceUntil([](uc32 c0) {
         if (V8_UNLIKELY(static_cast<uint32_t>(c0) > kMaxAscii)) {
           return unibrow::IsLineTerminator(c0);
         }
@@ -303,7 +301,7 @@ Token::Value Scanner::SkipMultiLineComment() {
 
   // After we've seen newline, simply try to find '*/'.
   while (c0_ != kEndOfInput) {
-    AdvanceUntil([](base::uc32 c0) { return c0 == '*'; });
+    AdvanceUntil([](uc32 c0) { return c0 == '*'; });
 
     while (c0_ == '*') {
       Advance();
@@ -371,7 +369,7 @@ void Scanner::SeekForward(int pos) {
 
 template <bool capture_raw>
 bool Scanner::ScanEscape() {
-  base::uc32 c = c0_;
+  uc32 c = c0_;
   Advance<capture_raw>();
 
   // Skip escaped newlines.
@@ -427,9 +425,9 @@ bool Scanner::ScanEscape() {
 }
 
 template <bool capture_raw>
-base::uc32 Scanner::ScanOctalEscape(base::uc32 c, int length) {
+uc32 Scanner::ScanOctalEscape(uc32 c, int length) {
   DCHECK('0' <= c && c <= '7');
-  base::uc32 x = c - '0';
+  uc32 x = c - '0';
   int i = 0;
   for (; i < length; i++) {
     int d = c0_ - '0';
@@ -453,11 +451,11 @@ base::uc32 Scanner::ScanOctalEscape(base::uc32 c, int length) {
 }
 
 Token::Value Scanner::ScanString() {
-  base::uc32 quote = c0_;
+  uc32 quote = c0_;
 
   next().literal_chars.Start();
   while (true) {
-    AdvanceUntil([this](base::uc32 c0) {
+    AdvanceUntil([this](uc32 c0) {
       if (V8_UNLIKELY(static_cast<uint32_t>(c0) > kMaxAscii)) {
         if (V8_UNLIKELY(unibrow::IsStringLiteralLineTerminator(c0))) {
           return true;
@@ -533,7 +531,7 @@ Token::Value Scanner::ScanTemplateSpan() {
   next().raw_literal_chars.Start();
   const bool capture_raw = true;
   while (true) {
-    base::uc32 c = c0_;
+    uc32 c = c0_;
     if (c == '`') {
       Advance();  // Consume '`'
       result = Token::TEMPLATE_TAIL;
@@ -549,7 +547,7 @@ Token::Value Scanner::ScanTemplateSpan() {
       if (unibrow::IsLineTerminator(c0_)) {
         // The TV of LineContinuation :: \ LineTerminatorSequence is the empty
         // code unit sequence.
-        base::uc32 lastChar = c0_;
+        uc32 lastChar = c0_;
         Advance();
         if (lastChar == '\r') {
           // Also skip \n.
@@ -612,7 +610,7 @@ Handle<String> Scanner::SourceMappingUrl(IsolateT* isolate) const {
 template Handle<String> Scanner::SourceMappingUrl(Isolate* isolate) const;
 template Handle<String> Scanner::SourceMappingUrl(LocalIsolate* isolate) const;
 
-bool Scanner::ScanDigitsWithNumericSeparators(bool (*predicate)(base::uc32 ch),
+bool Scanner::ScanDigitsWithNumericSeparators(bool (*predicate)(uc32 ch),
                                               bool is_check_first_digit) {
   // we must have at least one digit after 'x'/'b'/'o'
   if (is_check_first_digit && !predicate(c0_)) return false;
@@ -672,7 +670,7 @@ bool Scanner::ScanDecimalAsSmiWithNumericSeparators(uint64_t* value) {
     }
     separator_seen = false;
     *value = 10 * *value + (c0_ - '0');
-    base::uc32 first_char = c0_;
+    uc32 first_char = c0_;
     Advance();
     AddLiteralChar(first_char);
   }
@@ -693,7 +691,7 @@ bool Scanner::ScanDecimalAsSmi(uint64_t* value, bool allow_numeric_separator) {
 
   while (IsDecimalDigit(c0_)) {
     *value = 10 * *value + (c0_ - '0');
-    base::uc32 first_char = c0_;
+    uc32 first_char = c0_;
     Advance();
     AddLiteralChar(first_char);
   }
@@ -871,7 +869,7 @@ Token::Value Scanner::ScanNumber(bool seen_period) {
   return is_bigint ? Token::BIGINT : Token::NUMBER;
 }
 
-base::uc32 Scanner::ScanIdentifierUnicodeEscape() {
+uc32 Scanner::ScanIdentifierUnicodeEscape() {
   Advance();
   if (c0_ != 'u') return Invalid();
   Advance();
@@ -879,13 +877,13 @@ base::uc32 Scanner::ScanIdentifierUnicodeEscape() {
 }
 
 template <bool capture_raw>
-base::uc32 Scanner::ScanUnicodeEscape() {
+uc32 Scanner::ScanUnicodeEscape() {
   // Accept both \uxxxx and \u{xxxxxx}. In the latter case, the number of
   // hex digits between { } is arbitrary. \ and u have already been read.
   if (c0_ == '{') {
     int begin = source_pos() - 2;
     Advance<capture_raw>();
-    base::uc32 cp =
+    uc32 cp =
         ScanUnlimitedLengthHexNumber<capture_raw>(String::kMaxCodePoint, begin);
     if (cp == kInvalidSequence || c0_ != '}') {
       ReportScannerError(source_pos(),
@@ -904,7 +902,7 @@ Token::Value Scanner::ScanIdentifierOrKeywordInnerSlow(bool escaped,
   while (true) {
     if (c0_ == '\\') {
       escaped = true;
-      base::uc32 c = ScanIdentifierUnicodeEscape();
+      uc32 c = ScanIdentifierUnicodeEscape();
       // Only allow legal identifier part characters.
       // TODO(verwaest): Make this true.
       // DCHECK(!IsIdentifierPart('\'));
diff --git a/src/parsing/scanner.h b/src/parsing/scanner.h
index 3474f7270d..fc1eb7b0c1 100644
--- a/src/parsing/scanner.h
+++ b/src/parsing/scanner.h
@@ -12,7 +12,6 @@
 
 #include "include/v8.h"
 #include "src/base/logging.h"
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 #include "src/common/message-template.h"
 #include "src/parsing/literal-buffer.h"
@@ -40,7 +39,7 @@ class Zone;
 // or one part of a surrogate pair that make a single 21 bit code point.
 class Utf16CharacterStream {
  public:
-  static constexpr base::uc32 kEndOfInput = static_cast<base::uc32>(-1);
+  static constexpr uc32 kEndOfInput = static_cast<uc32>(-1);
 
   virtual ~Utf16CharacterStream() = default;
 
@@ -51,11 +50,11 @@ class Utf16CharacterStream {
   V8_INLINE void reset_parser_error_flag() { has_parser_error_ = false; }
   V8_INLINE bool has_parser_error() const { return has_parser_error_; }
 
-  inline base::uc32 Peek() {
+  inline uc32 Peek() {
     if (V8_LIKELY(buffer_cursor_ < buffer_end_)) {
-      return static_cast<base::uc32>(*buffer_cursor_);
+      return static_cast<uc32>(*buffer_cursor_);
     } else if (ReadBlockChecked()) {
-      return static_cast<base::uc32>(*buffer_cursor_);
+      return static_cast<uc32>(*buffer_cursor_);
     } else {
       return kEndOfInput;
     }
@@ -63,8 +62,8 @@ class Utf16CharacterStream {
 
   // Returns and advances past the next UTF-16 code unit in the input
   // stream. If there are no more code units it returns kEndOfInput.
-  inline base::uc32 Advance() {
-    base::uc32 result = Peek();
+  inline uc32 Advance() {
+    uc32 result = Peek();
     buffer_cursor_++;
     return result;
   }
@@ -73,11 +72,11 @@ class Utf16CharacterStream {
   // that meets the checks requirement. If there are no more code units it
   // returns kEndOfInput.
   template <typename FunctionType>
-  V8_INLINE base::uc32 AdvanceUntil(FunctionType check) {
+  V8_INLINE uc32 AdvanceUntil(FunctionType check) {
     while (true) {
       auto next_cursor_pos =
           std::find_if(buffer_cursor_, buffer_end_, [&check](uint16_t raw_c0_) {
-            base::uc32 c0_ = static_cast<base::uc32>(raw_c0_);
+            uc32 c0_ = static_cast<uc32>(raw_c0_);
             return check(c0_);
           });
 
@@ -89,7 +88,7 @@ class Utf16CharacterStream {
         }
       } else {
         buffer_cursor_ = next_cursor_pos + 1;
-        return static_cast<base::uc32>(*next_cursor_pos);
+        return static_cast<uc32>(*next_cursor_pos);
       }
     }
   }
@@ -268,11 +267,11 @@ class V8_EXPORT_PRIVATE Scanner {
   };
 
   // -1 is outside of the range of any real source code.
-  static constexpr base::uc32 kEndOfInput = Utf16CharacterStream::kEndOfInput;
-  static constexpr base::uc32 kInvalidSequence = static_cast<base::uc32>(-1);
+  static constexpr uc32 kEndOfInput = Utf16CharacterStream::kEndOfInput;
+  static constexpr uc32 kInvalidSequence = static_cast<uc32>(-1);
 
-  static constexpr base::uc32 Invalid() { return Scanner::kInvalidSequence; }
-  static bool IsInvalid(base::uc32 c);
+  static constexpr uc32 Invalid() { return Scanner::kInvalidSequence; }
+  static bool IsInvalid(uc32 c);
 
   explicit Scanner(Utf16CharacterStream* source, UnoptimizedCompileFlags flags);
 
@@ -472,7 +471,7 @@ class V8_EXPORT_PRIVATE Scanner {
 
   // Scans octal escape sequence. Also accepts "\0" decimal escape sequence.
   template <bool capture_raw>
-  base::uc32 ScanOctalEscape(base::uc32 c, int length);
+  uc32 ScanOctalEscape(uc32 c, int length);
 
   // Call this after setting source_ to the input.
   void Init() {
@@ -503,13 +502,11 @@ class V8_EXPORT_PRIVATE Scanner {
   // Seek to the next_ token at the given position.
   void SeekNext(size_t position);
 
-  V8_INLINE void AddLiteralChar(base::uc32 c) {
-    next().literal_chars.AddChar(c);
-  }
+  V8_INLINE void AddLiteralChar(uc32 c) { next().literal_chars.AddChar(c); }
 
   V8_INLINE void AddLiteralChar(char c) { next().literal_chars.AddChar(c); }
 
-  V8_INLINE void AddRawLiteralChar(base::uc32 c) {
+  V8_INLINE void AddRawLiteralChar(uc32 c) {
     next().raw_literal_chars.AddChar(c);
   }
 
@@ -535,7 +532,7 @@ class V8_EXPORT_PRIVATE Scanner {
   bool CombineSurrogatePair() {
     DCHECK(!unibrow::Utf16::IsLeadSurrogate(kEndOfInput));
     if (unibrow::Utf16::IsLeadSurrogate(c0_)) {
-      base::uc32 c1 = source_->Advance();
+      uc32 c1 = source_->Advance();
       DCHECK(!unibrow::Utf16::IsTrailSurrogate(kEndOfInput));
       if (unibrow::Utf16::IsTrailSurrogate(c1)) {
         c0_ = unibrow::Utf16::CombineSurrogatePair(c0_, c1);
@@ -546,22 +543,21 @@ class V8_EXPORT_PRIVATE Scanner {
     return false;
   }
 
-  void PushBack(base::uc32 ch) {
+  void PushBack(uc32 ch) {
     DCHECK(IsInvalid(c0_) ||
            base::IsInRange(c0_, 0u, unibrow::Utf16::kMaxNonSurrogateCharCode));
     source_->Back();
     c0_ = ch;
   }
 
-  base::uc32 Peek() const { return source_->Peek(); }
+  uc32 Peek() const { return source_->Peek(); }
 
   inline Token::Value Select(Token::Value tok) {
     Advance();
     return tok;
   }
 
-  inline Token::Value Select(base::uc32 next, Token::Value then,
-                             Token::Value else_) {
+  inline Token::Value Select(uc32 next, Token::Value then, Token::Value else_) {
     Advance();
     if (c0_ == next) {
       Advance();
@@ -626,12 +622,12 @@ class V8_EXPORT_PRIVATE Scanner {
   }
 
   template <bool capture_raw, bool unicode = false>
-  base::uc32 ScanHexNumber(int expected_length);
+  uc32 ScanHexNumber(int expected_length);
   // Scan a number of any length but not bigger than max_value. For example, the
   // number can be 000000001, so it's very long in characters but its value is
   // small.
   template <bool capture_raw>
-  base::uc32 ScanUnlimitedLengthHexNumber(base::uc32 max_value, int beg_pos);
+  uc32 ScanUnlimitedLengthHexNumber(uc32 max_value, int beg_pos);
 
   // Scans a single JavaScript token.
   V8_INLINE Token::Value ScanSingleToken();
@@ -651,7 +647,7 @@ class V8_EXPORT_PRIVATE Scanner {
   // Scans a possible HTML comment -- begins with '<!'.
   Token::Value ScanHtmlComment();
 
-  bool ScanDigitsWithNumericSeparators(bool (*predicate)(base::uc32 ch),
+  bool ScanDigitsWithNumericSeparators(bool (*predicate)(uc32 ch),
                                        bool is_check_first_digit);
   bool ScanDecimalDigits(bool allow_numeric_separator);
   // Optimized function to scan decimal number as Smi.
@@ -680,10 +676,10 @@ class V8_EXPORT_PRIVATE Scanner {
 
   // Decodes a Unicode escape-sequence which is part of an identifier.
   // If the escape sequence cannot be decoded the result is kBadChar.
-  base::uc32 ScanIdentifierUnicodeEscape();
+  uc32 ScanIdentifierUnicodeEscape();
   // Helper for the above functions.
   template <bool capture_raw>
-  base::uc32 ScanUnicodeEscape();
+  uc32 ScanUnicodeEscape();
 
   Token::Value ScanTemplateSpan();
 
@@ -722,7 +718,7 @@ class V8_EXPORT_PRIVATE Scanner {
   Utf16CharacterStream* const source_;
 
   // One Unicode character look-ahead; c0_ < 0 at the end of the input.
-  base::uc32 c0_;
+  uc32 c0_;
 
   TokenDesc token_storage_[3];
 
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index 6c90e00817..4b7153b35f 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -191,8 +191,8 @@ void RegExpMacroAssemblerARM::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(eq, on_equal);
 }
 
-void RegExpMacroAssemblerARM::CheckCharacterGT(base::uc16 limit,
-                                               Label* on_greater) {
+
+void RegExpMacroAssemblerARM::CheckCharacterGT(uc16 limit, Label* on_greater) {
   __ cmp(current_character(), Operand(limit));
   BranchOrBacktrack(gt, on_greater);
 }
@@ -214,12 +214,13 @@ void RegExpMacroAssemblerARM::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(ne, on_not_at_start);
 }
 
-void RegExpMacroAssemblerARM::CheckCharacterLT(base::uc16 limit,
-                                               Label* on_less) {
+
+void RegExpMacroAssemblerARM::CheckCharacterLT(uc16 limit, Label* on_less) {
   __ cmp(current_character(), Operand(limit));
   BranchOrBacktrack(lt, on_less);
 }
 
+
 void RegExpMacroAssemblerARM::CheckGreedyLoop(Label* on_equal) {
   __ ldr(r0, MemOperand(backtrack_stackpointer(), 0));
   __ cmp(current_input_offset(), r0);
@@ -457,8 +458,12 @@ void RegExpMacroAssemblerARM::CheckNotCharacterAfterAnd(unsigned c,
   BranchOrBacktrack(ne, on_not_equal);
 }
 
+
 void RegExpMacroAssemblerARM::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c,
+    uc16 minus,
+    uc16 mask,
+    Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ sub(r0, current_character(), Operand(minus));
   __ and_(r0, r0, Operand(mask));
@@ -466,22 +471,27 @@ void RegExpMacroAssemblerARM::CheckNotCharacterAfterMinusAnd(
   BranchOrBacktrack(ne, on_not_equal);
 }
 
-void RegExpMacroAssemblerARM::CheckCharacterInRange(base::uc16 from,
-                                                    base::uc16 to,
-                                                    Label* on_in_range) {
+
+void RegExpMacroAssemblerARM::CheckCharacterInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_in_range) {
   __ sub(r0, current_character(), Operand(from));
   __ cmp(r0, Operand(to - from));
   BranchOrBacktrack(ls, on_in_range);  // Unsigned lower-or-same condition.
 }
 
-void RegExpMacroAssemblerARM::CheckCharacterNotInRange(base::uc16 from,
-                                                       base::uc16 to,
-                                                       Label* on_not_in_range) {
+
+void RegExpMacroAssemblerARM::CheckCharacterNotInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_not_in_range) {
   __ sub(r0, current_character(), Operand(from));
   __ cmp(r0, Operand(to - from));
   BranchOrBacktrack(hi, on_not_in_range);  // Unsigned higher condition.
 }
 
+
 void RegExpMacroAssemblerARM::CheckBitInTable(
     Handle<ByteArray> table,
     Label* on_bit_set) {
@@ -499,7 +509,8 @@ void RegExpMacroAssemblerARM::CheckBitInTable(
   BranchOrBacktrack(ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerARM::CheckSpecialCharacterClass(base::uc16 type,
+
+bool RegExpMacroAssemblerARM::CheckSpecialCharacterClass(uc16 type,
                                                          Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
@@ -614,6 +625,7 @@ bool RegExpMacroAssemblerARM::CheckSpecialCharacterClass(base::uc16 type,
   }
 }
 
+
 void RegExpMacroAssemblerARM::Fail() {
   __ mov(r0, Operand(FAILURE));
   __ jmp(&exit_label_);
@@ -816,7 +828,8 @@ Handle<HeapObject> RegExpMacroAssemblerARM::GetCode(Handle<String> source) {
         // Advance current position after a zero-length match.
         Label advance;
         __ bind(&advance);
-        __ add(current_input_offset(), current_input_offset(),
+        __ add(current_input_offset(),
+               current_input_offset(),
                Operand((mode_ == UC16) ? 2 : 1));
         if (global_unicode()) CheckNotInSurrogatePair(0, &advance);
       }
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.h b/src/regexp/arm/regexp-macro-assembler-arm.h
index a02a4dc2af..92cac644e5 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.h
+++ b/src/regexp/arm/regexp-macro-assembler-arm.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_ARM_REGEXP_MACRO_ASSEMBLER_ARM_H_
 #define V8_REGEXP_ARM_REGEXP_MACRO_ASSEMBLER_ARM_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/arm/assembler-arm.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -29,8 +28,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM
   virtual void CheckCharacterAfterAnd(unsigned c,
                                       unsigned mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -44,19 +43,23 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM
   virtual void CheckNotCharacterAfterAnd(unsigned c,
                                          unsigned mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c,
+                                              uc16 minus,
+                                              uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from,
+                                     uc16 to,
                                      Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterNotInRange(uc16 from,
+                                        uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type,
+                                          Label* on_no_match);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
   virtual void GoTo(Label* label);
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.cc b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
index 6edb133576..72186cfc25 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.cc
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
@@ -231,7 +231,8 @@ void RegExpMacroAssemblerARM64::CheckCharacter(uint32_t c, Label* on_equal) {
   CompareAndBranchOrBacktrack(current_character(), c, eq, on_equal);
 }
 
-void RegExpMacroAssemblerARM64::CheckCharacterGT(base::uc16 limit,
+
+void RegExpMacroAssemblerARM64::CheckCharacterGT(uc16 limit,
                                                  Label* on_greater) {
   CompareAndBranchOrBacktrack(current_character(), limit, hi, on_greater);
 }
@@ -252,14 +253,15 @@ void RegExpMacroAssemblerARM64::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(ne, on_not_at_start);
 }
 
-void RegExpMacroAssemblerARM64::CheckCharacterLT(base::uc16 limit,
-                                                 Label* on_less) {
+
+void RegExpMacroAssemblerARM64::CheckCharacterLT(uc16 limit, Label* on_less) {
   CompareAndBranchOrBacktrack(current_character(), limit, lo, on_less);
 }
 
-void RegExpMacroAssemblerARM64::CheckCharacters(
-    base::Vector<const base::uc16> str, int cp_offset, Label* on_failure,
-    bool check_end_of_string) {
+void RegExpMacroAssemblerARM64::CheckCharacters(base::Vector<const uc16> str,
+                                                int cp_offset,
+                                                Label* on_failure,
+                                                bool check_end_of_string) {
   // This method is only ever called from the cctests.
 
   if (check_end_of_string) {
@@ -555,29 +557,39 @@ void RegExpMacroAssemblerARM64::CheckNotCharacterAfterAnd(unsigned c,
   CompareAndBranchOrBacktrack(w10, c, ne, on_not_equal);
 }
 
+
 void RegExpMacroAssemblerARM64::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c,
+    uc16 minus,
+    uc16 mask,
+    Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ Sub(w10, current_character(), minus);
   __ And(w10, w10, mask);
   CompareAndBranchOrBacktrack(w10, c, ne, on_not_equal);
 }
 
-void RegExpMacroAssemblerARM64::CheckCharacterInRange(base::uc16 from,
-                                                      base::uc16 to,
-                                                      Label* on_in_range) {
+
+void RegExpMacroAssemblerARM64::CheckCharacterInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_in_range) {
   __ Sub(w10, current_character(), from);
   // Unsigned lower-or-same condition.
   CompareAndBranchOrBacktrack(w10, to - from, ls, on_in_range);
 }
 
+
 void RegExpMacroAssemblerARM64::CheckCharacterNotInRange(
-    base::uc16 from, base::uc16 to, Label* on_not_in_range) {
+    uc16 from,
+    uc16 to,
+    Label* on_not_in_range) {
   __ Sub(w10, current_character(), from);
   // Unsigned higher condition.
   CompareAndBranchOrBacktrack(w10, to - from, hi, on_not_in_range);
 }
 
+
 void RegExpMacroAssemblerARM64::CheckBitInTable(
     Handle<ByteArray> table,
     Label* on_bit_set) {
@@ -592,7 +604,8 @@ void RegExpMacroAssemblerARM64::CheckBitInTable(
   CompareAndBranchOrBacktrack(w11, 0, ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerARM64::CheckSpecialCharacterClass(base::uc16 type,
+
+bool RegExpMacroAssemblerARM64::CheckSpecialCharacterClass(uc16 type,
                                                            Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
@@ -695,6 +708,7 @@ bool RegExpMacroAssemblerARM64::CheckSpecialCharacterClass(base::uc16 type,
   }
 }
 
+
 void RegExpMacroAssemblerARM64::Fail() {
   __ Mov(w0, FAILURE);
   __ B(&exit_label_);
@@ -1002,7 +1016,8 @@ Handle<HeapObject> RegExpMacroAssemblerARM64::GetCode(Handle<String> source) {
         // Advance current position after a zero-length match.
         Label advance;
         __ bind(&advance);
-        __ Add(current_input_offset(), current_input_offset(),
+        __ Add(current_input_offset(),
+               current_input_offset(),
                Operand((mode_ == UC16) ? 2 : 1));
         if (global_unicode()) CheckNotInSurrogatePair(0, &advance);
       }
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.h b/src/regexp/arm64/regexp-macro-assembler-arm64.h
index 80931e3ca4..253bdec8fb 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.h
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_ARM64_REGEXP_MACRO_ASSEMBLER_ARM64_H_
 #define V8_REGEXP_ARM64_REGEXP_MACRO_ASSEMBLER_ARM64_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/arm64/assembler-arm64.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -30,11 +29,10 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM64
   virtual void CheckCharacterAfterAnd(unsigned c,
                                       unsigned mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
-  virtual void CheckCharacters(base::Vector<const base::uc16> str,
-                               int cp_offset, Label* on_failure,
-                               bool check_end_of_string);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
+  virtual void CheckCharacters(base::Vector<const uc16> str, int cp_offset,
+                               Label* on_failure, bool check_end_of_string);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -48,19 +46,23 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM64
   virtual void CheckNotCharacterAfterAnd(unsigned c,
                                          unsigned mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c,
+                                              uc16 minus,
+                                              uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from,
+                                     uc16 to,
                                      Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterNotInRange(uc16 from,
+                                        uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type,
+                                          Label* on_no_match);
   virtual void BindJumpTarget(Label* label = nullptr);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
diff --git a/src/regexp/experimental/experimental-bytecode.cc b/src/regexp/experimental/experimental-bytecode.cc
index 3992b62155..8dc51d1696 100644
--- a/src/regexp/experimental/experimental-bytecode.cc
+++ b/src/regexp/experimental/experimental-bytecode.cc
@@ -11,7 +11,7 @@ namespace internal {
 
 namespace {
 
-std::ostream& PrintAsciiOrHex(std::ostream& os, base::uc16 c) {
+std::ostream& PrintAsciiOrHex(std::ostream& os, uc16 c) {
   if (c < 128 && std::isprint(c)) {
     os << static_cast<char>(c);
   } else {
diff --git a/src/regexp/experimental/experimental-bytecode.h b/src/regexp/experimental/experimental-bytecode.h
index 7042f95af1..39b3dd5ef3 100644
--- a/src/regexp/experimental/experimental-bytecode.h
+++ b/src/regexp/experimental/experimental-bytecode.h
@@ -7,7 +7,6 @@
 
 #include <ios>
 
-#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/regexp/regexp-ast.h"
 
@@ -103,11 +102,11 @@ struct RegExpInstruction {
   };
 
   struct Uc16Range {
-    base::uc16 min;  // Inclusive.
-    base::uc16 max;  // Inclusive.
+    uc16 min;  // Inclusive.
+    uc16 max;  // Inclusive.
   };
 
-  static RegExpInstruction ConsumeRange(base::uc16 min, base::uc16 max) {
+  static RegExpInstruction ConsumeRange(uc16 min, uc16 max) {
     RegExpInstruction result;
     result.opcode = CONSUME_RANGE;
     result.payload.consume_range = Uc16Range{min, max};
diff --git a/src/regexp/experimental/experimental-compiler.cc b/src/regexp/experimental/experimental-compiler.cc
index 277b8df570..4d53c2c0c5 100644
--- a/src/regexp/experimental/experimental-compiler.cc
+++ b/src/regexp/experimental/experimental-compiler.cc
@@ -4,7 +4,6 @@
 
 #include "src/regexp/experimental/experimental-compiler.h"
 
-#include "src/base/strings.h"
 #include "src/regexp/experimental/experimental.h"
 #include "src/zone/zone-list-inl.h"
 
@@ -15,7 +14,7 @@ namespace {
 
 // TODO(mbid, v8:10765): Currently the experimental engine doesn't support
 // UTF-16, but this shouldn't be too hard to implement.
-constexpr base::uc32 kMaxSupportedCodepoint = 0xFFFFu;
+constexpr uc32 kMaxSupportedCodepoint = 0xFFFFu;
 
 class CanBeHandledVisitor final : private RegExpVisitor {
   // Visitor to implement `ExperimentalRegExp::CanBeHandled`.
@@ -230,7 +229,7 @@ class BytecodeAssembler {
     code_.Add(RegExpInstruction::ClearRegister(register_index), zone_);
   }
 
-  void ConsumeRange(base::uc16 from, base::uc16 to) {
+  void ConsumeRange(uc16 from, uc16 to) {
     code_.Add(RegExpInstruction::ConsumeRange(from, to), zone_);
   }
 
@@ -403,18 +402,16 @@ class CompileVisitor : private RegExpVisitor {
 
     CompileDisjunction(ranges->length(), [&](int i) {
       // We don't support utf16 for now, so only ranges that can be specified
-      // by (complements of) ranges with base::uc16 bounds.
-      STATIC_ASSERT(kMaxSupportedCodepoint <=
-                    std::numeric_limits<base::uc16>::max());
+      // by (complements of) ranges with uc16 bounds.
+      STATIC_ASSERT(kMaxSupportedCodepoint <= std::numeric_limits<uc16>::max());
 
-      base::uc32 from = (*ranges)[i].from();
+      uc32 from = (*ranges)[i].from();
       DCHECK_LE(from, kMaxSupportedCodepoint);
-      base::uc16 from_uc16 = static_cast<base::uc16>(from);
+      uc16 from_uc16 = static_cast<uc16>(from);
 
-      base::uc32 to = (*ranges)[i].to();
+      uc32 to = (*ranges)[i].to();
       DCHECK_IMPLIES(to > kMaxSupportedCodepoint, to == String::kMaxCodePoint);
-      base::uc16 to_uc16 =
-          static_cast<base::uc16>(std::min(to, kMaxSupportedCodepoint));
+      uc16 to_uc16 = static_cast<uc16>(std::min(to, kMaxSupportedCodepoint));
 
       assembler_.ConsumeRange(from_uc16, to_uc16);
     });
@@ -422,7 +419,7 @@ class CompileVisitor : private RegExpVisitor {
   }
 
   void* VisitAtom(RegExpAtom* node, void*) override {
-    for (base::uc16 c : node->data()) {
+    for (uc16 c : node->data()) {
       assembler_.ConsumeRange(c, c);
     }
     return nullptr;
diff --git a/src/regexp/experimental/experimental-interpreter.cc b/src/regexp/experimental/experimental-interpreter.cc
index 06283db011..e688468b71 100644
--- a/src/regexp/experimental/experimental-interpreter.cc
+++ b/src/regexp/experimental/experimental-interpreter.cc
@@ -5,7 +5,6 @@
 #include "src/regexp/experimental/experimental-interpreter.h"
 
 #include "src/base/optional.h"
-#include "src/base/strings.h"
 #include "src/common/assert-scope.h"
 #include "src/objects/fixed-array-inl.h"
 #include "src/objects/string-inl.h"
@@ -77,7 +76,7 @@ base::Vector<const uint8_t> ToCharacterVector<uint8_t>(
 }
 
 template <>
-base::Vector<const base::uc16> ToCharacterVector<base::uc16>(
+base::Vector<const uc16> ToCharacterVector<uc16>(
     String str, const DisallowGarbageCollection& no_gc) {
   DCHECK(str.IsFlat());
   String::FlatContent content = str.GetFlatContent(no_gc);
@@ -88,8 +87,8 @@ base::Vector<const base::uc16> ToCharacterVector<base::uc16>(
 template <class Character>
 class NfaInterpreter {
   // Executes a bytecode program in breadth-first mode, without backtracking.
-  // `Character` can be instantiated with `uint8_t` or `base::uc16` for one byte
-  // or two byte input strings.
+  // `Character` can be instantiated with `uint8_t` or `uc16` for one byte or
+  // two byte input strings.
   //
   // In contrast to the backtracking implementation, this has linear time
   // complexity in the length of the input string. Breadth-first mode means
@@ -344,7 +343,7 @@ class NfaInterpreter {
     while (input_index_ != input_.length() &&
            !(FoundMatch() && blocked_threads_.is_empty())) {
       DCHECK(active_threads_.is_empty());
-      base::uc16 input_char = input_[input_index_];
+      uc16 input_char = input_[input_index_];
       ++input_index_;
 
       static constexpr int kTicksBetweenInterruptHandling = 64;
@@ -440,7 +439,7 @@ class NfaInterpreter {
   // Unblock all blocked_threads_ by feeding them an `input_char`.  Should only
   // be called with `input_index_` pointing to the character *after*
   // `input_char` so that `pc_last_input_index_` is updated correctly.
-  void FlushBlockedThreads(base::uc16 input_char) {
+  void FlushBlockedThreads(uc16 input_char) {
     // The threads in blocked_threads_ are sorted from high to low priority,
     // but active_threads_ needs to be sorted from low to high priority, so we
     // need to activate blocked threads in reverse order.
@@ -569,9 +568,9 @@ int ExperimentalRegExpInterpreter::FindMatches(
     return interpreter.FindMatches(output_registers, output_register_count);
   } else {
     DCHECK(input.GetFlatContent(no_gc).IsTwoByte());
-    NfaInterpreter<base::uc16> interpreter(isolate, call_origin, bytecode,
-                                           register_count_per_match, input,
-                                           start_index, zone);
+    NfaInterpreter<uc16> interpreter(isolate, call_origin, bytecode,
+                                     register_count_per_match, input,
+                                     start_index, zone);
     return interpreter.FindMatches(output_registers, output_register_count);
   }
 }
diff --git a/src/regexp/gen-regexp-special-case.cc b/src/regexp/gen-regexp-special-case.cc
index 86f6b212c9..9ed338fc1d 100644
--- a/src/regexp/gen-regexp-special-case.cc
+++ b/src/regexp/gen-regexp-special-case.cc
@@ -7,15 +7,14 @@
 #include <iostream>
 #include <sstream>
 
-#include "src/base/strings.h"
 #include "src/regexp/special-case.h"
 
 namespace v8 {
 namespace internal {
 
-static const base::uc32 kSurrogateStart = 0xd800;
-static const base::uc32 kSurrogateEnd = 0xdfff;
-static const base::uc32 kNonBmpStart = 0x10000;
+static const uc32 kSurrogateStart = 0xd800;
+static const uc32 kSurrogateEnd = 0xdfff;
+static const uc32 kNonBmpStart = 0x10000;
 
 // The following code generates "src/regexp/special-case.cc".
 void PrintSet(std::ofstream& out, const char* name,
diff --git a/src/regexp/ia32/regexp-macro-assembler-ia32.cc b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
index 6af1d02eed..27c1300ced 100644
--- a/src/regexp/ia32/regexp-macro-assembler-ia32.cc
+++ b/src/regexp/ia32/regexp-macro-assembler-ia32.cc
@@ -176,8 +176,8 @@ void RegExpMacroAssemblerIA32::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(equal, on_equal);
 }
 
-void RegExpMacroAssemblerIA32::CheckCharacterGT(base::uc16 limit,
-                                                Label* on_greater) {
+
+void RegExpMacroAssemblerIA32::CheckCharacterGT(uc16 limit, Label* on_greater) {
   __ cmp(current_character(), limit);
   BranchOrBacktrack(greater, on_greater);
 }
@@ -195,12 +195,13 @@ void RegExpMacroAssemblerIA32::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(not_equal, on_not_at_start);
 }
 
-void RegExpMacroAssemblerIA32::CheckCharacterLT(base::uc16 limit,
-                                                Label* on_less) {
+
+void RegExpMacroAssemblerIA32::CheckCharacterLT(uc16 limit, Label* on_less) {
   __ cmp(current_character(), limit);
   BranchOrBacktrack(less, on_less);
 }
 
+
 void RegExpMacroAssemblerIA32::CheckGreedyLoop(Label* on_equal) {
   Label fallthrough;
   __ cmp(edi, Operand(backtrack_stackpointer(), 0));
@@ -480,8 +481,12 @@ void RegExpMacroAssemblerIA32::CheckNotCharacterAfterAnd(uint32_t c,
   BranchOrBacktrack(not_equal, on_not_equal);
 }
 
+
 void RegExpMacroAssemblerIA32::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c,
+    uc16 minus,
+    uc16 mask,
+    Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ lea(eax, Operand(current_character(), -minus));
   if (c == 0) {
@@ -493,21 +498,27 @@ void RegExpMacroAssemblerIA32::CheckNotCharacterAfterMinusAnd(
   BranchOrBacktrack(not_equal, on_not_equal);
 }
 
-void RegExpMacroAssemblerIA32::CheckCharacterInRange(base::uc16 from,
-                                                     base::uc16 to,
-                                                     Label* on_in_range) {
+
+void RegExpMacroAssemblerIA32::CheckCharacterInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_in_range) {
   __ lea(eax, Operand(current_character(), -from));
   __ cmp(eax, to - from);
   BranchOrBacktrack(below_equal, on_in_range);
 }
 
+
 void RegExpMacroAssemblerIA32::CheckCharacterNotInRange(
-    base::uc16 from, base::uc16 to, Label* on_not_in_range) {
+    uc16 from,
+    uc16 to,
+    Label* on_not_in_range) {
   __ lea(eax, Operand(current_character(), -from));
   __ cmp(eax, to - from);
   BranchOrBacktrack(above, on_not_in_range);
 }
 
+
 void RegExpMacroAssemblerIA32::CheckBitInTable(
     Handle<ByteArray> table,
     Label* on_bit_set) {
@@ -523,7 +534,8 @@ void RegExpMacroAssemblerIA32::CheckBitInTable(
   BranchOrBacktrack(not_equal, on_bit_set);
 }
 
-bool RegExpMacroAssemblerIA32::CheckSpecialCharacterClass(base::uc16 type,
+
+bool RegExpMacroAssemblerIA32::CheckSpecialCharacterClass(uc16 type,
                                                           Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
@@ -647,6 +659,7 @@ bool RegExpMacroAssemblerIA32::CheckSpecialCharacterClass(base::uc16 type,
   }
 }
 
+
 void RegExpMacroAssemblerIA32::Fail() {
   STATIC_ASSERT(FAILURE == 0);  // Return value for failure is zero.
   if (!global()) {
@@ -1250,11 +1263,11 @@ void RegExpMacroAssemblerIA32::LoadCurrentCharacterUnchecked(int cp_offset,
     DCHECK(mode_ == UC16);
     if (characters == 2) {
       __ mov(current_character(),
-             Operand(esi, edi, times_1, cp_offset * sizeof(base::uc16)));
+             Operand(esi, edi, times_1, cp_offset * sizeof(uc16)));
     } else {
       DCHECK_EQ(1, characters);
       __ movzx_w(current_character(),
-                 Operand(esi, edi, times_1, cp_offset * sizeof(base::uc16)));
+                 Operand(esi, edi, times_1, cp_offset * sizeof(uc16)));
     }
   }
 }
diff --git a/src/regexp/ia32/regexp-macro-assembler-ia32.h b/src/regexp/ia32/regexp-macro-assembler-ia32.h
index 93fb2c9aba..0cb29979d7 100644
--- a/src/regexp/ia32/regexp-macro-assembler-ia32.h
+++ b/src/regexp/ia32/regexp-macro-assembler-ia32.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_IA32_REGEXP_MACRO_ASSEMBLER_IA32_H_
 #define V8_REGEXP_IA32_REGEXP_MACRO_ASSEMBLER_IA32_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/ia32/assembler-ia32.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -29,8 +28,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerIA32
   virtual void CheckCharacterAfterAnd(uint32_t c,
                                       uint32_t mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -44,19 +43,22 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerIA32
   virtual void CheckNotCharacterAfterAnd(uint32_t c,
                                          uint32_t mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c,
+                                              uc16 minus,
+                                              uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from,
+                                     uc16 to,
                                      Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterNotInRange(uc16 from,
+                                        uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
   virtual void GoTo(Label* label);
diff --git a/src/regexp/mips/regexp-macro-assembler-mips.cc b/src/regexp/mips/regexp-macro-assembler-mips.cc
index db4f2480b8..043f71d161 100644
--- a/src/regexp/mips/regexp-macro-assembler-mips.cc
+++ b/src/regexp/mips/regexp-macro-assembler-mips.cc
@@ -192,11 +192,12 @@ void RegExpMacroAssemblerMIPS::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(on_equal, eq, current_character(), Operand(c));
 }
 
-void RegExpMacroAssemblerMIPS::CheckCharacterGT(base::uc16 limit,
-                                                Label* on_greater) {
+
+void RegExpMacroAssemblerMIPS::CheckCharacterGT(uc16 limit, Label* on_greater) {
   BranchOrBacktrack(on_greater, gt, current_character(), Operand(limit));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckAtStart(int cp_offset, Label* on_at_start) {
   __ lw(a1, MemOperand(frame_pointer(), kStringStartMinusOne));
   __ Addu(a0, current_input_offset(),
@@ -213,11 +214,12 @@ void RegExpMacroAssemblerMIPS::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(on_not_at_start, ne, a0, Operand(a1));
 }
 
-void RegExpMacroAssemblerMIPS::CheckCharacterLT(base::uc16 limit,
-                                                Label* on_less) {
+
+void RegExpMacroAssemblerMIPS::CheckCharacterLT(uc16 limit, Label* on_less) {
   BranchOrBacktrack(on_less, lt, current_character(), Operand(limit));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckGreedyLoop(Label* on_equal) {
   Label backtrack_non_equal;
   __ lw(a0, MemOperand(backtrack_stackpointer(), 0));
@@ -460,29 +462,39 @@ void RegExpMacroAssemblerMIPS::CheckNotCharacterAfterAnd(uint32_t c,
   BranchOrBacktrack(on_not_equal, ne, a0, rhs);
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c,
+    uc16 minus,
+    uc16 mask,
+    Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ Subu(a0, current_character(), Operand(minus));
   __ And(a0, a0, Operand(mask));
   BranchOrBacktrack(on_not_equal, ne, a0, Operand(c));
 }
 
-void RegExpMacroAssemblerMIPS::CheckCharacterInRange(base::uc16 from,
-                                                     base::uc16 to,
-                                                     Label* on_in_range) {
+
+void RegExpMacroAssemblerMIPS::CheckCharacterInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_in_range) {
   __ Subu(a0, current_character(), Operand(from));
   // Unsigned lower-or-same condition.
   BranchOrBacktrack(on_in_range, ls, a0, Operand(to - from));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckCharacterNotInRange(
-    base::uc16 from, base::uc16 to, Label* on_not_in_range) {
+    uc16 from,
+    uc16 to,
+    Label* on_not_in_range) {
   __ Subu(a0, current_character(), Operand(from));
   // Unsigned higher condition.
   BranchOrBacktrack(on_not_in_range, hi, a0, Operand(to - from));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckBitInTable(
     Handle<ByteArray> table,
     Label* on_bit_set) {
@@ -498,7 +510,8 @@ void RegExpMacroAssemblerMIPS::CheckBitInTable(
   BranchOrBacktrack(on_bit_set, ne, a0, Operand(zero_reg));
 }
 
-bool RegExpMacroAssemblerMIPS::CheckSpecialCharacterClass(base::uc16 type,
+
+bool RegExpMacroAssemblerMIPS::CheckSpecialCharacterClass(uc16 type,
                                                           Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check.
@@ -602,6 +615,7 @@ bool RegExpMacroAssemblerMIPS::CheckSpecialCharacterClass(base::uc16 type,
   }
 }
 
+
 void RegExpMacroAssemblerMIPS::Fail() {
   __ li(v0, Operand(FAILURE));
   __ jmp(&exit_label_);
@@ -813,7 +827,8 @@ Handle<HeapObject> RegExpMacroAssemblerMIPS::GetCode(Handle<String> source) {
           // Advance current position after a zero-length match.
           Label advance;
           __ bind(&advance);
-          __ Addu(current_input_offset(), current_input_offset(),
+          __ Addu(current_input_offset(),
+                  current_input_offset(),
                   Operand((mode_ == UC16) ? 2 : 1));
           if (global_unicode()) CheckNotInSurrogatePair(0, &advance);
         }
diff --git a/src/regexp/mips/regexp-macro-assembler-mips.h b/src/regexp/mips/regexp-macro-assembler-mips.h
index 9f85d94d65..dd1c27a7db 100644
--- a/src/regexp/mips/regexp-macro-assembler-mips.h
+++ b/src/regexp/mips/regexp-macro-assembler-mips.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_MIPS_REGEXP_MACRO_ASSEMBLER_MIPS_H_
 #define V8_REGEXP_MIPS_REGEXP_MACRO_ASSEMBLER_MIPS_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/mips/assembler-mips.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -29,8 +28,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerMIPS
   virtual void CheckCharacterAfterAnd(uint32_t c,
                                       uint32_t mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -44,19 +43,23 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerMIPS
   virtual void CheckNotCharacterAfterAnd(uint32_t c,
                                          uint32_t mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c,
+                                              uc16 minus,
+                                              uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from,
+                                     uc16 to,
                                      Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterNotInRange(uc16 from,
+                                        uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type,
+                                          Label* on_no_match);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
   virtual void GoTo(Label* label);
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.cc b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
index 7e3ab11a46..dad4329157 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.cc
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
@@ -228,11 +228,12 @@ void RegExpMacroAssemblerMIPS::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(on_equal, eq, current_character(), Operand(c));
 }
 
-void RegExpMacroAssemblerMIPS::CheckCharacterGT(base::uc16 limit,
-                                                Label* on_greater) {
+
+void RegExpMacroAssemblerMIPS::CheckCharacterGT(uc16 limit, Label* on_greater) {
   BranchOrBacktrack(on_greater, gt, current_character(), Operand(limit));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckAtStart(int cp_offset, Label* on_at_start) {
   __ Ld(a1, MemOperand(frame_pointer(), kStringStartMinusOne));
   __ Daddu(a0, current_input_offset(),
@@ -249,11 +250,12 @@ void RegExpMacroAssemblerMIPS::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(on_not_at_start, ne, a0, Operand(a1));
 }
 
-void RegExpMacroAssemblerMIPS::CheckCharacterLT(base::uc16 limit,
-                                                Label* on_less) {
+
+void RegExpMacroAssemblerMIPS::CheckCharacterLT(uc16 limit, Label* on_less) {
   BranchOrBacktrack(on_less, lt, current_character(), Operand(limit));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckGreedyLoop(Label* on_equal) {
   Label backtrack_non_equal;
   __ Lw(a0, MemOperand(backtrack_stackpointer(), 0));
@@ -490,29 +492,39 @@ void RegExpMacroAssemblerMIPS::CheckNotCharacterAfterAnd(uint32_t c,
   BranchOrBacktrack(on_not_equal, ne, a0, rhs);
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c,
+    uc16 minus,
+    uc16 mask,
+    Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ Dsubu(a0, current_character(), Operand(minus));
   __ And(a0, a0, Operand(mask));
   BranchOrBacktrack(on_not_equal, ne, a0, Operand(c));
 }
 
-void RegExpMacroAssemblerMIPS::CheckCharacterInRange(base::uc16 from,
-                                                     base::uc16 to,
-                                                     Label* on_in_range) {
+
+void RegExpMacroAssemblerMIPS::CheckCharacterInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_in_range) {
   __ Dsubu(a0, current_character(), Operand(from));
   // Unsigned lower-or-same condition.
   BranchOrBacktrack(on_in_range, ls, a0, Operand(to - from));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckCharacterNotInRange(
-    base::uc16 from, base::uc16 to, Label* on_not_in_range) {
+    uc16 from,
+    uc16 to,
+    Label* on_not_in_range) {
   __ Dsubu(a0, current_character(), Operand(from));
   // Unsigned higher condition.
   BranchOrBacktrack(on_not_in_range, hi, a0, Operand(to - from));
 }
 
+
 void RegExpMacroAssemblerMIPS::CheckBitInTable(
     Handle<ByteArray> table,
     Label* on_bit_set) {
@@ -528,7 +540,8 @@ void RegExpMacroAssemblerMIPS::CheckBitInTable(
   BranchOrBacktrack(on_bit_set, ne, a0, Operand(zero_reg));
 }
 
-bool RegExpMacroAssemblerMIPS::CheckSpecialCharacterClass(base::uc16 type,
+
+bool RegExpMacroAssemblerMIPS::CheckSpecialCharacterClass(uc16 type,
                                                           Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check.
@@ -632,6 +645,7 @@ bool RegExpMacroAssemblerMIPS::CheckSpecialCharacterClass(base::uc16 type,
   }
 }
 
+
 void RegExpMacroAssemblerMIPS::Fail() {
   __ li(v0, Operand(FAILURE));
   __ jmp(&exit_label_);
@@ -849,8 +863,9 @@ Handle<HeapObject> RegExpMacroAssemblerMIPS::GetCode(Handle<String> source) {
           // Advance current position after a zero-length match.
           Label advance;
           __ bind(&advance);
-          __ Daddu(current_input_offset(), current_input_offset(),
-                   Operand((mode_ == UC16) ? 2 : 1));
+          __ Daddu(current_input_offset(),
+                  current_input_offset(),
+                  Operand((mode_ == UC16) ? 2 : 1));
           if (global_unicode()) CheckNotInSurrogatePair(0, &advance);
         }
 
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.h b/src/regexp/mips64/regexp-macro-assembler-mips64.h
index 348d52724b..b9a29ca010 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.h
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_MIPS64_REGEXP_MACRO_ASSEMBLER_MIPS64_H_
 #define V8_REGEXP_MIPS64_REGEXP_MACRO_ASSEMBLER_MIPS64_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/mips64/assembler-mips64.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -29,8 +28,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerMIPS
   virtual void CheckCharacterAfterAnd(uint32_t c,
                                       uint32_t mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -44,19 +43,23 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerMIPS
   virtual void CheckNotCharacterAfterAnd(uint32_t c,
                                          uint32_t mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c,
+                                              uc16 minus,
+                                              uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from,
+                                     uc16 to,
                                      Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterNotInRange(uc16 from,
+                                        uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type,
+                                          Label* on_no_match);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
   virtual void GoTo(Label* label);
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index 6d549b5b79..ce088233c3 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -206,8 +206,8 @@ void RegExpMacroAssemblerPPC::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(eq, on_equal);
 }
 
-void RegExpMacroAssemblerPPC::CheckCharacterGT(base::uc16 limit,
-                                               Label* on_greater) {
+
+void RegExpMacroAssemblerPPC::CheckCharacterGT(uc16 limit, Label* on_greater) {
   __ Cmpli(current_character(), Operand(limit), r0);
   BranchOrBacktrack(gt, on_greater);
 }
@@ -229,12 +229,13 @@ void RegExpMacroAssemblerPPC::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(ne, on_not_at_start);
 }
 
-void RegExpMacroAssemblerPPC::CheckCharacterLT(base::uc16 limit,
-                                               Label* on_less) {
+
+void RegExpMacroAssemblerPPC::CheckCharacterLT(uc16 limit, Label* on_less) {
   __ Cmpli(current_character(), Operand(limit), r0);
   BranchOrBacktrack(lt, on_less);
 }
 
+
 void RegExpMacroAssemblerPPC::CheckGreedyLoop(Label* on_equal) {
   Label backtrack_non_equal;
   __ LoadU64(r3, MemOperand(backtrack_stackpointer(), 0));
@@ -487,8 +488,9 @@ void RegExpMacroAssemblerPPC::CheckNotCharacterAfterAnd(unsigned c,
   BranchOrBacktrack(ne, on_not_equal, cr0);
 }
 
+
 void RegExpMacroAssemblerPPC::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c, uc16 minus, uc16 mask, Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ subi(r3, current_character(), Operand(minus));
   __ mov(r0, Operand(mask));
@@ -497,8 +499,8 @@ void RegExpMacroAssemblerPPC::CheckNotCharacterAfterMinusAnd(
   BranchOrBacktrack(ne, on_not_equal);
 }
 
-void RegExpMacroAssemblerPPC::CheckCharacterInRange(base::uc16 from,
-                                                    base::uc16 to,
+
+void RegExpMacroAssemblerPPC::CheckCharacterInRange(uc16 from, uc16 to,
                                                     Label* on_in_range) {
   __ mov(r0, Operand(from));
   __ sub(r3, current_character(), r0);
@@ -506,8 +508,8 @@ void RegExpMacroAssemblerPPC::CheckCharacterInRange(base::uc16 from,
   BranchOrBacktrack(le, on_in_range);  // Unsigned lower-or-same condition.
 }
 
-void RegExpMacroAssemblerPPC::CheckCharacterNotInRange(base::uc16 from,
-                                                       base::uc16 to,
+
+void RegExpMacroAssemblerPPC::CheckCharacterNotInRange(uc16 from, uc16 to,
                                                        Label* on_not_in_range) {
   __ mov(r0, Operand(from));
   __ sub(r3, current_character(), r0);
@@ -515,6 +517,7 @@ void RegExpMacroAssemblerPPC::CheckCharacterNotInRange(base::uc16 from,
   BranchOrBacktrack(gt, on_not_in_range);  // Unsigned higher condition.
 }
 
+
 void RegExpMacroAssemblerPPC::CheckBitInTable(Handle<ByteArray> table,
                                               Label* on_bit_set) {
   __ mov(r3, Operand(table));
@@ -530,7 +533,8 @@ void RegExpMacroAssemblerPPC::CheckBitInTable(Handle<ByteArray> table,
   BranchOrBacktrack(ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerPPC::CheckSpecialCharacterClass(base::uc16 type,
+
+bool RegExpMacroAssemblerPPC::CheckSpecialCharacterClass(uc16 type,
                                                          Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
@@ -647,6 +651,7 @@ bool RegExpMacroAssemblerPPC::CheckSpecialCharacterClass(base::uc16 type,
   }
 }
 
+
 void RegExpMacroAssemblerPPC::Fail() {
   __ li(r3, Operand(FAILURE));
   __ b(&exit_label_);
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.h b/src/regexp/ppc/regexp-macro-assembler-ppc.h
index 430c3a241c..18b7c5b110 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.h
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_PPC_REGEXP_MACRO_ASSEMBLER_PPC_H_
 #define V8_REGEXP_PPC_REGEXP_MACRO_ASSEMBLER_PPC_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/ppc/assembler-ppc.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -28,8 +27,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerPPC
   virtual void CheckCharacter(unsigned c, Label* on_equal);
   virtual void CheckCharacterAfterAnd(unsigned c, unsigned mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -42,19 +41,17 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerPPC
   virtual void CheckNotCharacter(unsigned c, Label* on_not_equal);
   virtual void CheckNotCharacterAfterAnd(unsigned c, unsigned mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c, uc16 minus, uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
-                                     Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from, uc16 to, Label* on_in_range);
+  virtual void CheckCharacterNotInRange(uc16 from, uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
   virtual void GoTo(Label* label);
diff --git a/src/regexp/property-sequences.cc b/src/regexp/property-sequences.cc
index 643bde954b..9a48040083 100644
--- a/src/regexp/property-sequences.cc
+++ b/src/regexp/property-sequences.cc
@@ -42,7 +42,7 @@ const generateData = (property) => {
     buffer.push('    ' + codePoints.join(', ') + ', 0,');
   }
   const output =
-      `const base::uc32 UnicodePropertySequences::k${ id }[] = {\n` +
+      `const uc32 UnicodePropertySequences::k${ id }[] = {\n` +
       `${ buffer.join('\n') }\n    0  // null-terminating the list\n};\n`;
   return output;
 };
@@ -60,7 +60,7 @@ for (const property of properties) {
 */
 
 // clang-format off
-const base::uc32 UnicodePropertySequences::kEmojiFlagSequences[] = {
+const uc32 UnicodePropertySequences::kEmojiFlagSequences[] = {
     0x01F1E6, 0x01F1E8, 0,
     0x01F1FF, 0x01F1FC, 0,
     0x01F1E6, 0x01F1EA, 0,
@@ -322,14 +322,14 @@ const base::uc32 UnicodePropertySequences::kEmojiFlagSequences[] = {
     0  // null-terminating the list
 };
 
-const base::uc32 UnicodePropertySequences::kEmojiTagSequences[] = {
+const uc32 UnicodePropertySequences::kEmojiTagSequences[] = {
     0x01F3F4, 0x0E0067, 0x0E0062, 0x0E0065, 0x0E006E, 0x0E0067, 0x0E007F, 0,
     0x01F3F4, 0x0E0067, 0x0E0062, 0x0E0073, 0x0E0063, 0x0E0074, 0x0E007F, 0,
     0x01F3F4, 0x0E0067, 0x0E0062, 0x0E0077, 0x0E006C, 0x0E0073, 0x0E007F, 0,
     0  // null-terminating the list
 };
 
-const base::uc32 UnicodePropertySequences::kEmojiZWJSequences[] = {
+const uc32 UnicodePropertySequences::kEmojiZWJSequences[] = {
     0x01F468, 0x00200D, 0x002764, 0x00FE0F, 0x00200D, 0x01F468, 0,
     0x01F441, 0x00FE0F, 0x00200D, 0x01F5E8, 0x00FE0F, 0,
     0x01F468, 0x00200D, 0x01F466, 0,
diff --git a/src/regexp/property-sequences.h b/src/regexp/property-sequences.h
index 2647097499..10c79e82b1 100644
--- a/src/regexp/property-sequences.h
+++ b/src/regexp/property-sequences.h
@@ -7,7 +7,6 @@
 
 #ifdef V8_INTL_SUPPORT
 
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 
 namespace v8 {
@@ -15,9 +14,9 @@ namespace internal {
 
 class UnicodePropertySequences : public AllStatic {
  public:
-  static const base::uc32 kEmojiFlagSequences[];
-  static const base::uc32 kEmojiTagSequences[];
-  static const base::uc32 kEmojiZWJSequences[];
+  static const uc32 kEmojiFlagSequences[];
+  static const uc32 kEmojiTagSequences[];
+  static const uc32 kEmojiZWJSequences[];
 };
 
 }  // namespace internal
diff --git a/src/regexp/regexp-ast.cc b/src/regexp/regexp-ast.cc
index d10cc95924..661713d686 100644
--- a/src/regexp/regexp-ast.cc
+++ b/src/regexp/regexp-ast.cc
@@ -219,7 +219,7 @@ void* RegExpUnparser::VisitAssertion(RegExpAssertion* that, void* data) {
 
 void* RegExpUnparser::VisitAtom(RegExpAtom* that, void* data) {
   os_ << "'";
-  base::Vector<const base::uc16> chardata = that->data();
+  base::Vector<const uc16> chardata = that->data();
   for (int i = 0; i < chardata.length(); i++) {
     os_ << AsUC16(chardata[i]);
   }
diff --git a/src/regexp/regexp-ast.h b/src/regexp/regexp-ast.h
index c2ce0c4c0f..7b55a97330 100644
--- a/src/regexp/regexp-ast.h
+++ b/src/regexp/regexp-ast.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_REGEXP_AST_H_
 #define V8_REGEXP_REGEXP_AST_H_
 
-#include "src/base/strings.h"
 #include "src/objects/js-regexp.h"
 #include "src/objects/objects.h"
 #include "src/objects/string.h"
@@ -93,10 +92,10 @@ class CharacterRange {
       char type, ZoneList<CharacterRange>* ranges,
       bool add_unicode_case_equivalents, Zone* zone);
   static base::Vector<const int> GetWordBounds();
-  static inline CharacterRange Singleton(base::uc32 value) {
+  static inline CharacterRange Singleton(uc32 value) {
     return CharacterRange(value, value);
   }
-  static inline CharacterRange Range(base::uc32 from, base::uc32 to) {
+  static inline CharacterRange Range(uc32 from, uc32 to) {
     DCHECK(0 <= from && to <= String::kMaxCodePoint);
     DCHECK(static_cast<uint32_t>(from) <= static_cast<uint32_t>(to));
     return CharacterRange(from, to);
@@ -111,13 +110,13 @@ class CharacterRange {
     list->Add(range, zone);
     return list;
   }
-  bool Contains(base::uc32 i) { return from_ <= i && i <= to_; }
-  base::uc32 from() const { return from_; }
-  void set_from(base::uc32 value) { from_ = value; }
-  base::uc32 to() const { return to_; }
-  void set_to(base::uc32 value) { to_ = value; }
+  bool Contains(uc32 i) { return from_ <= i && i <= to_; }
+  uc32 from() const { return from_; }
+  void set_from(uc32 value) { from_ = value; }
+  uc32 to() const { return to_; }
+  void set_to(uc32 value) { to_ = value; }
   bool is_valid() { return from_ <= to_; }
-  bool IsEverything(base::uc32 max) { return from_ == 0 && to_ >= max; }
+  bool IsEverything(uc32 max) { return from_ == 0 && to_ >= max; }
   bool IsSingleton() { return (from_ == to_); }
   V8_EXPORT_PRIVATE static void AddCaseEquivalents(
       Isolate* isolate, Zone* zone, ZoneList<CharacterRange>* ranges,
@@ -137,21 +136,21 @@ class CharacterRange {
   static const int kPayloadMask = (1 << 24) - 1;
 
  private:
-  CharacterRange(base::uc32 from, base::uc32 to) : from_(from), to_(to) {}
+  CharacterRange(uc32 from, uc32 to) : from_(from), to_(to) {}
 
-  base::uc32 from_;
-  base::uc32 to_;
+  uc32 from_;
+  uc32 to_;
 };
 
 class CharacterSet final {
  public:
-  explicit CharacterSet(base::uc16 standard_set_type)
+  explicit CharacterSet(uc16 standard_set_type)
       : ranges_(nullptr), standard_set_type_(standard_set_type) {}
   explicit CharacterSet(ZoneList<CharacterRange>* ranges)
       : ranges_(ranges), standard_set_type_(0) {}
   ZoneList<CharacterRange>* ranges(Zone* zone);
-  base::uc16 standard_set_type() const { return standard_set_type_; }
-  void set_standard_set_type(base::uc16 special_set_type) {
+  uc16 standard_set_type() const { return standard_set_type_; }
+  void set_standard_set_type(uc16 special_set_type) {
     standard_set_type_ = special_set_type;
   }
   bool is_standard() { return standard_set_type_ != 0; }
@@ -161,7 +160,7 @@ class CharacterSet final {
   ZoneList<CharacterRange>* ranges_;
   // If non-zero, the value represents a standard set (e.g., all whitespace
   // characters) without having to expand the ranges.
-  base::uc16 standard_set_type_;
+  uc16 standard_set_type_;
 };
 
 class TextElement final {
@@ -323,7 +322,7 @@ class RegExpCharacterClass final : public RegExpTree {
       character_class_flags_ ^= NEGATED;
     }
   }
-  RegExpCharacterClass(base::uc16 type, JSRegExp::Flags flags)
+  RegExpCharacterClass(uc16 type, JSRegExp::Flags flags)
       : set_(type),
         flags_(flags),
         character_class_flags_(CharacterClassFlags()) {}
@@ -353,7 +352,7 @@ class RegExpCharacterClass final : public RegExpTree {
   // D : non-ASCII digit
   // . : non-newline
   // * : All characters, for advancing unanchored regexp
-  base::uc16 standard_type() const { return set_.standard_set_type(); }
+  uc16 standard_type() const { return set_.standard_set_type(); }
   ZoneList<CharacterRange>* ranges(Zone* zone) { return set_.ranges(zone); }
   bool is_negated() const { return (character_class_flags_ & NEGATED) != 0; }
   JSRegExp::Flags flags() const { return flags_; }
@@ -370,8 +369,7 @@ class RegExpCharacterClass final : public RegExpTree {
 
 class RegExpAtom final : public RegExpTree {
  public:
-  explicit RegExpAtom(base::Vector<const base::uc16> data,
-                      JSRegExp::Flags flags)
+  explicit RegExpAtom(base::Vector<const uc16> data, JSRegExp::Flags flags)
       : data_(data), flags_(flags) {}
   void* Accept(RegExpVisitor* visitor, void* data) override;
   RegExpNode* ToNode(RegExpCompiler* compiler, RegExpNode* on_success) override;
@@ -381,13 +379,13 @@ class RegExpAtom final : public RegExpTree {
   int min_match() override { return data_.length(); }
   int max_match() override { return data_.length(); }
   void AppendToText(RegExpText* text, Zone* zone) override;
-  base::Vector<const base::uc16> data() { return data_; }
+  base::Vector<const uc16> data() { return data_; }
   int length() { return data_.length(); }
   JSRegExp::Flags flags() const { return flags_; }
   bool ignore_case() const { return (flags_ & JSRegExp::kIgnoreCase) != 0; }
 
  private:
-  base::Vector<const base::uc16> data_;
+  base::Vector<const uc16> data_;
   const JSRegExp::Flags flags_;
 };
 
@@ -488,8 +486,8 @@ class RegExpCapture final : public RegExpTree {
     max_match_ = body->max_match();
   }
   int index() const { return index_; }
-  const ZoneVector<base::uc16>* name() const { return name_; }
-  void set_name(const ZoneVector<base::uc16>* name) { name_ = name; }
+  const ZoneVector<uc16>* name() const { return name_; }
+  void set_name(const ZoneVector<uc16>* name) { name_ = name; }
   static int StartRegister(int index) { return index * 2; }
   static int EndRegister(int index) { return index * 2 + 1; }
 
@@ -498,7 +496,7 @@ class RegExpCapture final : public RegExpTree {
   int index_;
   int min_match_;
   int max_match_;
-  const ZoneVector<base::uc16>* name_;
+  const ZoneVector<uc16>* name_;
 };
 
 class RegExpGroup final : public RegExpTree {
@@ -595,12 +593,12 @@ class RegExpBackReference final : public RegExpTree {
   int index() { return capture_->index(); }
   RegExpCapture* capture() { return capture_; }
   void set_capture(RegExpCapture* capture) { capture_ = capture; }
-  const ZoneVector<base::uc16>* name() const { return name_; }
-  void set_name(const ZoneVector<base::uc16>* name) { name_ = name; }
+  const ZoneVector<uc16>* name() const { return name_; }
+  void set_name(const ZoneVector<uc16>* name) { name_ = name; }
 
  private:
   RegExpCapture* capture_;
-  const ZoneVector<base::uc16>* name_;
+  const ZoneVector<uc16>* name_;
   const JSRegExp::Flags flags_;
 };
 
diff --git a/src/regexp/regexp-bytecode-generator.cc b/src/regexp/regexp-bytecode-generator.cc
index 397f4ba87a..8145ff9488 100644
--- a/src/regexp/regexp-bytecode-generator.cc
+++ b/src/regexp/regexp-bytecode-generator.cc
@@ -220,14 +220,12 @@ void RegExpBytecodeGenerator::LoadCurrentCharacterImpl(int cp_offset,
   if (check_bounds) EmitOrLink(on_failure);
 }
 
-void RegExpBytecodeGenerator::CheckCharacterLT(base::uc16 limit,
-                                               Label* on_less) {
+void RegExpBytecodeGenerator::CheckCharacterLT(uc16 limit, Label* on_less) {
   Emit(BC_CHECK_LT, limit);
   EmitOrLink(on_less);
 }
 
-void RegExpBytecodeGenerator::CheckCharacterGT(base::uc16 limit,
-                                               Label* on_greater) {
+void RegExpBytecodeGenerator::CheckCharacterGT(uc16 limit, Label* on_greater) {
   Emit(BC_CHECK_GT, limit);
   EmitOrLink(on_greater);
 }
@@ -290,15 +288,14 @@ void RegExpBytecodeGenerator::CheckNotCharacterAfterAnd(uint32_t c,
 }
 
 void RegExpBytecodeGenerator::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c, uc16 minus, uc16 mask, Label* on_not_equal) {
   Emit(BC_MINUS_AND_CHECK_NOT_CHAR, c);
   Emit16(minus);
   Emit16(mask);
   EmitOrLink(on_not_equal);
 }
 
-void RegExpBytecodeGenerator::CheckCharacterInRange(base::uc16 from,
-                                                    base::uc16 to,
+void RegExpBytecodeGenerator::CheckCharacterInRange(uc16 from, uc16 to,
                                                     Label* on_in_range) {
   Emit(BC_CHECK_CHAR_IN_RANGE, 0);
   Emit16(from);
@@ -306,8 +303,7 @@ void RegExpBytecodeGenerator::CheckCharacterInRange(base::uc16 from,
   EmitOrLink(on_in_range);
 }
 
-void RegExpBytecodeGenerator::CheckCharacterNotInRange(base::uc16 from,
-                                                       base::uc16 to,
+void RegExpBytecodeGenerator::CheckCharacterNotInRange(uc16 from, uc16 to,
                                                        Label* on_not_in_range) {
   Emit(BC_CHECK_CHAR_NOT_IN_RANGE, 0);
   Emit16(from);
diff --git a/src/regexp/regexp-bytecode-generator.h b/src/regexp/regexp-bytecode-generator.h
index 466b535c7e..534ebbe0a3 100644
--- a/src/regexp/regexp-bytecode-generator.h
+++ b/src/regexp/regexp-bytecode-generator.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_REGEXP_BYTECODE_GENERATOR_H_
 #define V8_REGEXP_REGEXP_BYTECODE_GENERATOR_H_
 
-#include "src/base/strings.h"
 #include "src/regexp/regexp-macro-assembler.h"
 
 namespace v8 {
@@ -53,20 +52,18 @@ class V8_EXPORT_PRIVATE RegExpBytecodeGenerator : public RegExpMacroAssembler {
   void CheckCharacter(unsigned c, Label* on_equal) override;
   void CheckCharacterAfterAnd(unsigned c, unsigned mask,
                               Label* on_equal) override;
-  void CheckCharacterGT(base::uc16 limit, Label* on_greater) override;
-  void CheckCharacterLT(base::uc16 limit, Label* on_less) override;
+  void CheckCharacterGT(uc16 limit, Label* on_greater) override;
+  void CheckCharacterLT(uc16 limit, Label* on_less) override;
   void CheckGreedyLoop(Label* on_tos_equals_current_position) override;
   void CheckAtStart(int cp_offset, Label* on_at_start) override;
   void CheckNotAtStart(int cp_offset, Label* on_not_at_start) override;
   void CheckNotCharacter(unsigned c, Label* on_not_equal) override;
   void CheckNotCharacterAfterAnd(unsigned c, unsigned mask,
                                  Label* on_not_equal) override;
-  void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                      base::uc16 mask,
+  void CheckNotCharacterAfterMinusAnd(uc16 c, uc16 minus, uc16 mask,
                                       Label* on_not_equal) override;
-  void CheckCharacterInRange(base::uc16 from, base::uc16 to,
-                             Label* on_in_range) override;
-  void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  void CheckCharacterInRange(uc16 from, uc16 to, Label* on_in_range) override;
+  void CheckCharacterNotInRange(uc16 from, uc16 to,
                                 Label* on_not_in_range) override;
   void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set) override;
   void CheckNotBackReference(int start_reg, bool read_backward,
diff --git a/src/regexp/regexp-bytecodes.h b/src/regexp/regexp-bytecodes.h
index e371e6af31..088fd93b23 100644
--- a/src/regexp/regexp-bytecodes.h
+++ b/src/regexp/regexp-bytecodes.h
@@ -7,7 +7,6 @@
 
 #include "src/base/bounds.h"
 #include "src/base/macros.h"
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 
 namespace v8 {
@@ -88,14 +87,12 @@ STATIC_ASSERT(1 << BYTECODE_SHIFT > BYTECODE_MASK);
   /* 0x10 - 0x1F:   Character to match against (after mask aplied)          */ \
   /* 0x20 - 0x3F:   Bitmask bitwise and combined with current character     */ \
   /* 0x40 - 0x5F:   Address of bytecode when matched                        */ \
-  V(AND_CHECK_CHAR, 28, 12)        /* bc8 pad8 uint16 uint32 addr32      */    \
-  V(AND_CHECK_NOT_4_CHARS, 29, 16) /* bc8 pad24 uint32 uint32 addr32 */        \
-  V(AND_CHECK_NOT_CHAR, 30, 12)    /* bc8 pad8 uint16 uint32 addr32 */         \
-  V(MINUS_AND_CHECK_NOT_CHAR, 31,                                              \
-    12) /* bc8 pad8 base::uc16 base::uc16 base::uc16 addr32 */                 \
-  V(CHECK_CHAR_IN_RANGE, 32, 12) /* bc8 pad24 base::uc16 base::uc16 addr32 */  \
-  V(CHECK_CHAR_NOT_IN_RANGE, 33,                                               \
-    12) /* bc8 pad24 base::uc16 base::uc16 addr32 */                           \
+  V(AND_CHECK_CHAR, 28, 12)           /* bc8 pad8 uint16 uint32 addr32      */ \
+  V(AND_CHECK_NOT_4_CHARS, 29, 16)    /* bc8 pad24 uint32 uint32 addr32 */     \
+  V(AND_CHECK_NOT_CHAR, 30, 12)       /* bc8 pad8 uint16 uint32 addr32 */      \
+  V(MINUS_AND_CHECK_NOT_CHAR, 31, 12) /* bc8 pad8 uc16 uc16 uc16 addr32 */     \
+  V(CHECK_CHAR_IN_RANGE, 32, 12)      /* bc8 pad24 uc16 uc16 addr32 */         \
+  V(CHECK_CHAR_NOT_IN_RANGE, 33, 12)  /* bc8 pad24 uc16 uc16 addr32 */         \
   /* Checks if the current character matches any of the characters encoded  */ \
   /* in a bit table. Similar to/inspired by boyer moore string search       */ \
   /* Bit Layout:                                                            */ \
@@ -104,8 +101,8 @@ STATIC_ASSERT(1 << BYTECODE_SHIFT > BYTECODE_MASK);
   /* 0x20 - 0x3F:   Address of bytecode when bit is set                     */ \
   /* 0x40 - 0xBF:   Bit table                                               */ \
   V(CHECK_BIT_IN_TABLE, 34, 24) /* bc8 pad24 addr32 bits128           */       \
-  V(CHECK_LT, 35, 8) /* bc8 pad8 base::uc16 addr32                       */    \
-  V(CHECK_GT, 36, 8) /* bc8 pad8 base::uc16 addr32                       */    \
+  V(CHECK_LT, 35, 8) /* bc8 pad8 uc16 addr32                       */          \
+  V(CHECK_GT, 36, 8) /* bc8 pad8 uc16 addr32                       */          \
   V(CHECK_NOT_BACK_REF, 37, 8)         /* bc8 reg_idx24 addr32 */              \
   V(CHECK_NOT_BACK_REF_NO_CASE, 38, 8) /* bc8 reg_idx24 addr32 */              \
   V(CHECK_NOT_BACK_REF_NO_CASE_UNICODE, 39, 8)                                 \
diff --git a/src/regexp/regexp-compiler-tonode.cc b/src/regexp/regexp-compiler-tonode.cc
index dd5d980db8..9c02b04c72 100644
--- a/src/regexp/regexp-compiler-tonode.cc
+++ b/src/regexp/regexp-compiler-tonode.cc
@@ -13,7 +13,6 @@
 #include "src/zone/zone-list-inl.h"
 
 #ifdef V8_INTL_SUPPORT
-#include "src/base/strings.h"
 #include "unicode/locid.h"
 #include "unicode/uniset.h"
 #include "unicode/utypes.h"
@@ -57,11 +56,11 @@ static bool CompareInverseRanges(ZoneList<CharacterRange>* ranges,
     return false;
   }
   for (int i = 0; i < length; i += 2) {
-    if (static_cast<base::uc32>(special_class[i]) != (range.to() + 1)) {
+    if (static_cast<uc32>(special_class[i]) != (range.to() + 1)) {
       return false;
     }
     range = ranges->at((i >> 1) + 1);
-    if (static_cast<base::uc32>(special_class[i + 1]) != range.from()) {
+    if (static_cast<uc32>(special_class[i + 1]) != range.from()) {
       return false;
     }
   }
@@ -80,8 +79,8 @@ static bool CompareRanges(ZoneList<CharacterRange>* ranges,
   }
   for (int i = 0; i < length; i += 2) {
     CharacterRange range = ranges->at(i >> 1);
-    if (range.from() != static_cast<base::uc32>(special_class[i]) ||
-        range.to() != static_cast<base::uc32>(special_class[i + 1] - 1)) {
+    if (range.from() != static_cast<uc32>(special_class[i]) ||
+        range.to() != static_cast<uc32>(special_class[i + 1] - 1)) {
       return false;
     }
   }
@@ -139,10 +138,10 @@ UnicodeRangeSplitter::UnicodeRangeSplitter(ZoneList<CharacterRange>* base) {
 }
 
 void UnicodeRangeSplitter::AddRange(CharacterRange range) {
-  static constexpr base::uc32 kBmp1Start = 0;
-  static constexpr base::uc32 kBmp1End = kLeadSurrogateStart - 1;
-  static constexpr base::uc32 kBmp2Start = kTrailSurrogateEnd + 1;
-  static constexpr base::uc32 kBmp2End = kNonBmpStart - 1;
+  static constexpr uc32 kBmp1Start = 0;
+  static constexpr uc32 kBmp1End = kLeadSurrogateStart - 1;
+  static constexpr uc32 kBmp2Start = kTrailSurrogateEnd + 1;
+  static constexpr uc32 kBmp2End = kNonBmpStart - 1;
 
   // Ends are all inclusive.
   STATIC_ASSERT(kBmp1Start == 0);
@@ -156,12 +155,12 @@ void UnicodeRangeSplitter::AddRange(CharacterRange range) {
   STATIC_ASSERT(kBmp2End + 1 == kNonBmpStart);
   STATIC_ASSERT(kNonBmpStart < kNonBmpEnd);
 
-  static constexpr base::uc32 kStarts[] = {
+  static constexpr uc32 kStarts[] = {
       kBmp1Start, kLeadSurrogateStart, kTrailSurrogateStart,
       kBmp2Start, kNonBmpStart,
   };
 
-  static constexpr base::uc32 kEnds[] = {
+  static constexpr uc32 kEnds[] = {
       kBmp1End, kLeadSurrogateEnd, kTrailSurrogateEnd, kBmp2End, kNonBmpEnd,
   };
 
@@ -175,8 +174,8 @@ void UnicodeRangeSplitter::AddRange(CharacterRange range) {
 
   for (int i = 0; i < kCount; i++) {
     if (kStarts[i] > range.to()) break;
-    const base::uc32 from = std::max(kStarts[i], range.from());
-    const base::uc32 to = std::min(kEnds[i], range.to());
+    const uc32 from = std::max(kStarts[i], range.from());
+    const uc32 to = std::min(kEnds[i], range.to());
     if (from > to) continue;
     kTargets[i]->emplace_back(CharacterRange::Range(from, to));
   }
@@ -225,12 +224,12 @@ void AddNonBmpSurrogatePairs(RegExpCompiler* compiler, ChoiceNode* result,
     //      \ud800[\udc05-\udfff]|
     //      [\ud801-\ud803][\udc00-\udfff]|
     //      \ud804[\udc00-\udc05]
-    base::uc32 from = non_bmp->at(i).from();
-    base::uc32 to = non_bmp->at(i).to();
-    base::uc16 from_l = unibrow::Utf16::LeadSurrogate(from);
-    base::uc16 from_t = unibrow::Utf16::TrailSurrogate(from);
-    base::uc16 to_l = unibrow::Utf16::LeadSurrogate(to);
-    base::uc16 to_t = unibrow::Utf16::TrailSurrogate(to);
+    uc32 from = non_bmp->at(i).from();
+    uc32 to = non_bmp->at(i).to();
+    uc16 from_l = unibrow::Utf16::LeadSurrogate(from);
+    uc16 from_t = unibrow::Utf16::TrailSurrogate(from);
+    uc16 to_l = unibrow::Utf16::LeadSurrogate(to);
+    uc16 to_t = unibrow::Utf16::TrailSurrogate(to);
     if (from_l == to_l) {
       // The lead surrogate is the same.
       result->AddAlternative(
@@ -448,8 +447,8 @@ RegExpNode* RegExpCharacterClass::ToNode(RegExpCompiler* compiler,
 int CompareFirstChar(RegExpTree* const* a, RegExpTree* const* b) {
   RegExpAtom* atom1 = (*a)->AsAtom();
   RegExpAtom* atom2 = (*b)->AsAtom();
-  base::uc16 character1 = atom1->data().at(0);
-  base::uc16 character2 = atom2->data().at(0);
+  uc16 character1 = atom1->data().at(0);
+  uc16 character2 = atom2->data().at(0);
   if (character1 < character2) return -1;
   if (character1 > character2) return 1;
   return 0;
@@ -1061,7 +1060,7 @@ static void AddClassNegated(const int* elmv, int elmc,
   DCHECK_EQ(kRangeEndMarker, elmv[elmc]);
   DCHECK_NE(0x0000, elmv[0]);
   DCHECK_NE(String::kMaxCodePoint, elmv[elmc - 1]);
-  base::uc16 last = 0x0000;
+  uc16 last = 0x0000;
   for (int i = 0; i < elmc; i += 2) {
     DCHECK(last <= elmv[i] - 1);
     DCHECK(elmv[i] < elmv[i + 1]);
@@ -1149,9 +1148,9 @@ void CharacterRange::AddCaseEquivalents(Isolate* isolate, Zone* zone,
   icu::UnicodeSet others;
   for (int i = 0; i < range_count; i++) {
     CharacterRange range = ranges->at(i);
-    base::uc32 from = range.from();
+    uc32 from = range.from();
     if (from > String::kMaxUtf16CodeUnit) continue;
-    base::uc32 to = std::min({range.to(), String::kMaxUtf16CodeUnitU});
+    uc32 to = std::min({range.to(), String::kMaxUtf16CodeUnitU});
     // Nothing to be done for surrogates.
     if (from >= kLeadSurrogateStart && to <= kTrailSurrogateEnd) continue;
     if (is_one_byte && !RangeContainsLatin1Equivalents(range)) {
@@ -1192,9 +1191,9 @@ void CharacterRange::AddCaseEquivalents(Isolate* isolate, Zone* zone,
 #else
   for (int i = 0; i < range_count; i++) {
     CharacterRange range = ranges->at(i);
-    base::uc32 bottom = range.from();
+    uc32 bottom = range.from();
     if (bottom > String::kMaxUtf16CodeUnit) continue;
-    base::uc32 top = std::min({range.to(), String::kMaxUtf16CodeUnitU});
+    uc32 top = std::min({range.to(), String::kMaxUtf16CodeUnitU});
     // Nothing to be done for surrogates.
     if (bottom >= kLeadSurrogateStart && top <= kTrailSurrogateEnd) continue;
     if (is_one_byte && !RangeContainsLatin1Equivalents(range)) {
@@ -1206,7 +1205,7 @@ void CharacterRange::AddCaseEquivalents(Isolate* isolate, Zone* zone,
       // If this is a singleton we just expand the one character.
       int length = isolate->jsregexp_uncanonicalize()->get(bottom, '\0', chars);
       for (int i = 0; i < length; i++) {
-        base::uc32 chr = chars[i];
+        uc32 chr = chars[i];
         if (chr != bottom) {
           ranges->Add(CharacterRange::Singleton(chars[i]), zone);
         }
@@ -1229,11 +1228,11 @@ void CharacterRange::AddCaseEquivalents(Isolate* isolate, Zone* zone,
       // block we do this for all the blocks covered by the range (handling
       // characters that is not in a block as a "singleton block").
       unibrow::uchar equivalents[unibrow::Ecma262UnCanonicalize::kMaxWidth];
-      base::uc32 pos = bottom;
+      uc32 pos = bottom;
       while (pos <= top) {
         int length =
             isolate->jsregexp_canonrange()->get(pos, '\0', equivalents);
-        base::uc32 block_end;
+        uc32 block_end;
         if (length == 0) {
           block_end = pos;
         } else {
@@ -1244,9 +1243,9 @@ void CharacterRange::AddCaseEquivalents(Isolate* isolate, Zone* zone,
         length = isolate->jsregexp_uncanonicalize()->get(block_end, '\0',
                                                          equivalents);
         for (int i = 0; i < length; i++) {
-          base::uc32 c = equivalents[i];
-          base::uc32 range_from = c - (block_end - pos);
-          base::uc32 range_to = c - (block_end - end);
+          uc32 c = equivalents[i];
+          uc32 range_from = c - (block_end - pos);
+          uc32 range_to = c - (block_end - end);
           if (!(bottom <= range_from && range_to <= top)) {
             ranges->Add(CharacterRange::Range(range_from, range_to), zone);
           }
@@ -1262,7 +1261,7 @@ bool CharacterRange::IsCanonical(ZoneList<CharacterRange>* ranges) {
   DCHECK_NOT_NULL(ranges);
   int n = ranges->length();
   if (n <= 1) return true;
-  base::uc32 max = ranges->at(0).to();
+  uc32 max = ranges->at(0).to();
   for (int i = 1; i < n; i++) {
     CharacterRange next_range = ranges->at(i);
     if (next_range.from() <= max + 1) return false;
@@ -1302,8 +1301,8 @@ static int InsertRangeInCanonicalList(ZoneList<CharacterRange>* list, int count,
   // list[0..count] for the result. Returns the number of resulting
   // canonicalized ranges. Inserting a range may collapse existing ranges into
   // fewer ranges, so the return value can be anything in the range 1..count+1.
-  base::uc32 from = insert.from();
-  base::uc32 to = insert.to();
+  uc32 from = insert.from();
+  uc32 to = insert.to();
   int start_pos = 0;
   int end_pos = count;
   for (int i = count - 1; i >= 0; i--) {
@@ -1363,7 +1362,7 @@ void CharacterRange::Canonicalize(ZoneList<CharacterRange>* character_ranges) {
   // Check whether ranges are already canonical (increasing, non-overlapping,
   // non-adjacent).
   int n = character_ranges->length();
-  base::uc32 max = character_ranges->at(0).to();
+  uc32 max = character_ranges->at(0).to();
   int i = 1;
   while (i < n) {
     CharacterRange current = character_ranges->at(i);
@@ -1399,7 +1398,7 @@ void CharacterRange::Negate(ZoneList<CharacterRange>* ranges,
   DCHECK(CharacterRange::IsCanonical(ranges));
   DCHECK_EQ(0, negated_ranges->length());
   int range_count = ranges->length();
-  base::uc32 from = 0;
+  uc32 from = 0;
   int i = 0;
   if (range_count > 0 && ranges->at(0).from() == 0) {
     from = ranges->at(0).to() + 1;
diff --git a/src/regexp/regexp-compiler.cc b/src/regexp/regexp-compiler.cc
index 5b121a3eef..74d78b58dc 100644
--- a/src/regexp/regexp-compiler.cc
+++ b/src/regexp/regexp-compiler.cc
@@ -176,7 +176,7 @@ using namespace regexp_compiler_constants;  // NOLINT(build/namespaces)
 
 namespace {
 
-constexpr base::uc32 MaxCodeUnit(const bool one_byte) {
+constexpr uc32 MaxCodeUnit(const bool one_byte) {
   STATIC_ASSERT(String::kMaxOneByteCharCodeU <=
                 std::numeric_limits<uint16_t>::max());
   STATIC_ASSERT(String::kMaxUtf16CodeUnitU <=
@@ -751,7 +751,7 @@ bool ContainsOnlyUtf16CodeUnits(unibrow::uchar* chars, int length) {
 
 // Returns the number of characters in the equivalence class, omitting those
 // that cannot occur in the source string because it is Latin1.
-static int GetCaseIndependentLetters(Isolate* isolate, base::uc16 character,
+static int GetCaseIndependentLetters(Isolate* isolate, uc16 character,
                                      bool one_byte_subject,
                                      unibrow::uchar* letters,
                                      int letter_length) {
@@ -815,7 +815,7 @@ static int GetCaseIndependentLetters(Isolate* isolate, base::uc16 character,
 }
 
 static inline bool EmitSimpleCharacter(Isolate* isolate,
-                                       RegExpCompiler* compiler, base::uc16 c,
+                                       RegExpCompiler* compiler, uc16 c,
                                        Label* on_failure, int cp_offset,
                                        bool check, bool preloaded) {
   RegExpMacroAssembler* assembler = compiler->macro_assembler();
@@ -831,9 +831,8 @@ static inline bool EmitSimpleCharacter(Isolate* isolate,
 // Only emits non-letters (things that don't have case).  Only used for case
 // independent matches.
 static inline bool EmitAtomNonLetter(Isolate* isolate, RegExpCompiler* compiler,
-                                     base::uc16 c, Label* on_failure,
-                                     int cp_offset, bool check,
-                                     bool preloaded) {
+                                     uc16 c, Label* on_failure, int cp_offset,
+                                     bool check, bool preloaded) {
   RegExpMacroAssembler* macro_assembler = compiler->macro_assembler();
   bool one_byte = compiler->one_byte();
   unibrow::uchar chars[4];
@@ -861,27 +860,27 @@ static inline bool EmitAtomNonLetter(Isolate* isolate, RegExpCompiler* compiler,
 }
 
 static bool ShortCutEmitCharacterPair(RegExpMacroAssembler* macro_assembler,
-                                      bool one_byte, base::uc16 c1,
-                                      base::uc16 c2, Label* on_failure) {
+                                      bool one_byte, uc16 c1, uc16 c2,
+                                      Label* on_failure) {
   const uint32_t char_mask = CharMask(one_byte);
-  base::uc16 exor = c1 ^ c2;
+  uc16 exor = c1 ^ c2;
   // Check whether exor has only one bit set.
   if (((exor - 1) & exor) == 0) {
     // If c1 and c2 differ only by one bit.
     // Ecma262UnCanonicalize always gives the highest number last.
     DCHECK(c2 > c1);
-    base::uc16 mask = char_mask ^ exor;
+    uc16 mask = char_mask ^ exor;
     macro_assembler->CheckNotCharacterAfterAnd(c1, mask, on_failure);
     return true;
   }
   DCHECK(c2 > c1);
-  base::uc16 diff = c2 - c1;
+  uc16 diff = c2 - c1;
   if (((diff - 1) & diff) == 0 && c1 >= diff) {
     // If the characters differ by 2^n but don't differ by one bit then
     // subtract the difference from the found character, then do the or
     // trick.  We avoid the theoretical case where negative numbers are
     // involved in order to simplify code generation.
-    base::uc16 mask = char_mask ^ diff;
+    uc16 mask = char_mask ^ diff;
     macro_assembler->CheckNotCharacterAfterMinusAnd(c1 - diff, diff, mask,
                                                     on_failure);
     return true;
@@ -892,8 +891,8 @@ static bool ShortCutEmitCharacterPair(RegExpMacroAssembler* macro_assembler,
 // Only emits letters (things that have case).  Only used for case independent
 // matches.
 static inline bool EmitAtomLetter(Isolate* isolate, RegExpCompiler* compiler,
-                                  base::uc16 c, Label* on_failure,
-                                  int cp_offset, bool check, bool preloaded) {
+                                  uc16 c, Label* on_failure, int cp_offset,
+                                  bool check, bool preloaded) {
   RegExpMacroAssembler* macro_assembler = compiler->macro_assembler();
   bool one_byte = compiler->one_byte();
   unibrow::uchar chars[4];
@@ -964,14 +963,14 @@ static void EmitDoubleBoundaryTest(RegExpMacroAssembler* masm, int first,
 // even_label is for ranges[i] to ranges[i + 1] where i - start_index is even.
 // odd_label is for ranges[i] to ranges[i + 1] where i - start_index is odd.
 static void EmitUseLookupTable(RegExpMacroAssembler* masm,
-                               ZoneList<base::uc32>* ranges,
-                               uint32_t start_index, uint32_t end_index,
-                               base::uc32 min_char, Label* fall_through,
-                               Label* even_label, Label* odd_label) {
+                               ZoneList<uc32>* ranges, uint32_t start_index,
+                               uint32_t end_index, uc32 min_char,
+                               Label* fall_through, Label* even_label,
+                               Label* odd_label) {
   static const uint32_t kSize = RegExpMacroAssembler::kTableSize;
   static const uint32_t kMask = RegExpMacroAssembler::kTableMask;
 
-  base::uc32 base = (min_char & ~kMask);
+  uc32 base = (min_char & ~kMask);
   USE(base);
 
   // Assert that everything is on one kTableSize page.
@@ -1018,10 +1017,10 @@ static void EmitUseLookupTable(RegExpMacroAssembler* masm,
   if (on_bit_clear != fall_through) masm->GoTo(on_bit_clear);
 }
 
-static void CutOutRange(RegExpMacroAssembler* masm,
-                        ZoneList<base::uc32>* ranges, uint32_t start_index,
-                        uint32_t end_index, uint32_t cut_index,
-                        Label* even_label, Label* odd_label) {
+static void CutOutRange(RegExpMacroAssembler* masm, ZoneList<uc32>* ranges,
+                        uint32_t start_index, uint32_t end_index,
+                        uint32_t cut_index, Label* even_label,
+                        Label* odd_label) {
   bool odd = (((cut_index - start_index) & 1) == 1);
   Label* in_range_label = odd ? odd_label : even_label;
   Label dummy;
@@ -1042,14 +1041,14 @@ static void CutOutRange(RegExpMacroAssembler* masm,
 
 // Unicode case.  Split the search space into kSize spaces that are handled
 // with recursion.
-static void SplitSearchSpace(ZoneList<base::uc32>* ranges, uint32_t start_index,
+static void SplitSearchSpace(ZoneList<uc32>* ranges, uint32_t start_index,
                              uint32_t end_index, uint32_t* new_start_index,
-                             uint32_t* new_end_index, base::uc32* border) {
+                             uint32_t* new_end_index, uc32* border) {
   static const uint32_t kSize = RegExpMacroAssembler::kTableSize;
   static const uint32_t kMask = RegExpMacroAssembler::kTableMask;
 
-  base::uc32 first = ranges->at(start_index);
-  base::uc32 last = ranges->at(end_index) - 1;
+  uc32 first = ranges->at(start_index);
+  uc32 last = ranges->at(end_index) - 1;
 
   *new_start_index = start_index;
   *border = (ranges->at(start_index) & ~kMask) + kSize;
@@ -1108,16 +1107,15 @@ static void SplitSearchSpace(ZoneList<base::uc32>* ranges, uint32_t start_index,
 // know that the character is in the range of min_char to max_char inclusive.
 // Either label can be nullptr indicating backtracking.  Either label can also
 // be equal to the fall_through label.
-static void GenerateBranches(RegExpMacroAssembler* masm,
-                             ZoneList<base::uc32>* ranges, uint32_t start_index,
-                             uint32_t end_index, base::uc32 min_char,
-                             base::uc32 max_char, Label* fall_through,
+static void GenerateBranches(RegExpMacroAssembler* masm, ZoneList<uc32>* ranges,
+                             uint32_t start_index, uint32_t end_index,
+                             uc32 min_char, uc32 max_char, Label* fall_through,
                              Label* even_label, Label* odd_label) {
   DCHECK_LE(min_char, String::kMaxUtf16CodeUnit);
   DCHECK_LE(max_char, String::kMaxUtf16CodeUnit);
 
-  base::uc32 first = ranges->at(start_index);
-  base::uc32 last = ranges->at(end_index) - 1;
+  uc32 first = ranges->at(start_index);
+  uc32 last = ranges->at(end_index) - 1;
 
   DCHECK_LT(min_char, first);
 
@@ -1177,7 +1175,7 @@ static void GenerateBranches(RegExpMacroAssembler* masm,
 
   uint32_t new_start_index = 0;
   uint32_t new_end_index = 0;
-  base::uc32 border = 0;
+  uc32 border = 0;
 
   SplitSearchSpace(ranges, start_index, end_index, &new_start_index,
                    &new_end_index, &border);
@@ -1227,7 +1225,7 @@ static void EmitCharClass(RegExpMacroAssembler* macro_assembler,
   ZoneList<CharacterRange>* ranges = cc->ranges(zone);
   CharacterRange::Canonicalize(ranges);
 
-  const base::uc32 max_char = MaxCodeUnit(one_byte);
+  const uc32 max_char = MaxCodeUnit(one_byte);
   int range_count = ranges->length();
 
   int last_valid_range = range_count - 1;
@@ -1274,8 +1272,8 @@ static void EmitCharClass(RegExpMacroAssembler* macro_assembler,
   // entry at zero which goes to the failure label, but if there
   // was already one there we fall through for success on that entry.
   // Subsequent entries have alternating meaning (success/failure).
-  ZoneList<base::uc32>* range_boundaries =
-      zone->New<ZoneList<base::uc32>>(last_valid_range, zone);
+  ZoneList<uc32>* range_boundaries =
+      zone->New<ZoneList<uc32>>(last_valid_range, zone);
 
   bool zeroth_entry_is_failure = !cc->is_negated();
 
@@ -1581,11 +1579,11 @@ void TextNode::GetQuickCheckDetails(QuickCheckDetails* details,
   for (int k = 0; k < elements()->length(); k++) {
     TextElement elm = elements()->at(k);
     if (elm.text_type() == TextElement::ATOM) {
-      base::Vector<const base::uc16> quarks = elm.atom()->data();
+      base::Vector<const uc16> quarks = elm.atom()->data();
       for (int i = 0; i < characters && i < quarks.length(); i++) {
         QuickCheckDetails::Position* pos =
             details->positions(characters_filled_in);
-        base::uc16 c = quarks[i];
+        uc16 c = quarks[i];
         if (elm.atom()->ignore_case()) {
           unibrow::uchar chars[4];
           int length = GetCaseIndependentLetters(
@@ -1666,9 +1664,8 @@ void TextNode::GetQuickCheckDetails(QuickCheckDetails* details,
           }
         }
         CharacterRange range = ranges->at(first_range);
-        const base::uc32 first_from = range.from();
-        const base::uc32 first_to =
-            (range.to() > char_mask) ? char_mask : range.to();
+        const uc32 first_from = range.from();
+        const uc32 first_to = (range.to() > char_mask) ? char_mask : range.to();
         const uint32_t differing_bits = (first_from ^ first_to);
         // A mask and compare is only perfect if the differing bits form a
         // number like 00011111 with one single block of trailing 1s.
@@ -1680,10 +1677,9 @@ void TextNode::GetQuickCheckDetails(QuickCheckDetails* details,
         uint32_t bits = (first_from & common_bits);
         for (int i = first_range + 1; i < ranges->length(); i++) {
           CharacterRange range = ranges->at(i);
-          const base::uc32 from = range.from();
+          const uc32 from = range.from();
           if (from > char_mask) continue;
-          const base::uc32 to =
-              (range.to() > char_mask) ? char_mask : range.to();
+          const uc32 to = (range.to() > char_mask) ? char_mask : range.to();
           // Here we are combining more ranges into the mask and compare
           // value.  With each new range the mask becomes more sparse and
           // so the chances of a false positive rise.  A character class
@@ -1855,15 +1851,15 @@ RegExpNode* TextNode::FilterOneByte(int depth) {
   for (int i = 0; i < element_count; i++) {
     TextElement elm = elements()->at(i);
     if (elm.text_type() == TextElement::ATOM) {
-      base::Vector<const base::uc16> quarks = elm.atom()->data();
+      base::Vector<const uc16> quarks = elm.atom()->data();
       for (int j = 0; j < quarks.length(); j++) {
-        base::uc16 c = quarks[j];
+        uc16 c = quarks[j];
         if (elm.atom()->ignore_case()) {
           c = unibrow::Latin1::TryConvertToLatin1(c);
         }
         if (c > unibrow::Latin1::kMaxChar) return set_replacement(nullptr);
         // Replace quark in case we converted to Latin-1.
-        base::uc16* writable_quarks = const_cast<base::uc16*>(quarks.begin());
+        uc16* writable_quarks = const_cast<uc16*>(quarks.begin());
         writable_quarks[j] = c;
       }
     } else {
@@ -2318,11 +2314,11 @@ void TextNode::TextEmitPass(RegExpCompiler* compiler, TextEmitPassType pass,
     int cp_offset = trace->cp_offset() + elm.cp_offset() + backward_offset;
     if (elm.text_type() == TextElement::ATOM) {
       if (SkipPass(pass, elm.atom()->ignore_case())) continue;
-      base::Vector<const base::uc16> quarks = elm.atom()->data();
+      base::Vector<const uc16> quarks = elm.atom()->data();
       for (int j = preloaded ? 0 : quarks.length() - 1; j >= 0; j--) {
         if (first_element_checked && i == 0 && j == 0) continue;
         if (DeterminedAlready(quick_check, elm.cp_offset() + j)) continue;
-        base::uc16 quark = quarks[j];
+        uc16 quark = quarks[j];
         if (elm.atom()->ignore_case()) {
           // Everywhere else we assume that a non-Latin-1 character cannot match
           // a Latin-1 character. Avoid the cases where this is assumption is
@@ -2527,7 +2523,7 @@ RegExpNode* TextNode::GetSuccessorOfOmnivorousTextNode(
     return ranges->length() == 0 ? on_success() : nullptr;
   }
   if (ranges->length() != 1) return nullptr;
-  const base::uc32 max_char = MaxCodeUnit(compiler->one_byte());
+  const uc32 max_char = MaxCodeUnit(compiler->one_byte());
   return ranges->at(0).IsEverything(max_char) ? on_success() : nullptr;
 }
 
@@ -3807,7 +3803,7 @@ void TextNode::FillInBMInfo(Isolate* isolate, int initial_offset, int budget,
           if (initial_offset == 0) set_bm_info(not_at_start, bm);
           return;
         }
-        base::uc16 character = atom->data()[j];
+        uc16 character = atom->data()[j];
         if (IgnoreCase(atom->flags())) {
           unibrow::uchar chars[4];
           int length = GetCaseIndependentLetters(
diff --git a/src/regexp/regexp-compiler.h b/src/regexp/regexp-compiler.h
index 4d53e47094..4e7652883c 100644
--- a/src/regexp/regexp-compiler.h
+++ b/src/regexp/regexp-compiler.h
@@ -8,7 +8,6 @@
 #include <bitset>
 
 #include "src/base/small-vector.h"
-#include "src/base/strings.h"
 #include "src/regexp/regexp-nodes.h"
 
 namespace v8 {
@@ -22,7 +21,7 @@ namespace regexp_compiler_constants {
 // The '2' variant is has inclusive from and exclusive to.
 // This covers \s as defined in ECMA-262 5.1, 15.10.2.12,
 // which include WhiteSpace (7.2) or LineTerminator (7.3) values.
-constexpr base::uc32 kRangeEndMarker = 0x110000;
+constexpr uc32 kRangeEndMarker = 0x110000;
 constexpr int kSpaceRanges[] = {
     '\t',   '\r' + 1, ' ',    ' ' + 1, 0x00A0, 0x00A1, 0x1680,
     0x1681, 0x2000,   0x200B, 0x2028,  0x202A, 0x202F, 0x2030,
@@ -97,8 +96,8 @@ class QuickCheckDetails {
   void set_cannot_match() { cannot_match_ = true; }
   struct Position {
     Position() : mask(0), value(0), determines_perfectly(false) {}
-    base::uc32 mask;
-    base::uc32 value;
+    uc32 mask;
+    uc32 value;
     bool determines_perfectly;
   };
   int characters() { return characters_; }
diff --git a/src/regexp/regexp-dotprinter.cc b/src/regexp/regexp-dotprinter.cc
index b4e92aebbf..323e725cfb 100644
--- a/src/regexp/regexp-dotprinter.cc
+++ b/src/regexp/regexp-dotprinter.cc
@@ -4,7 +4,6 @@
 
 #include "src/regexp/regexp-dotprinter.h"
 
-#include "src/base/strings.h"
 #include "src/regexp/regexp-compiler.h"
 #include "src/utils/ostreams.h"
 
@@ -129,7 +128,7 @@ void DotPrinterImpl::VisitText(TextNode* that) {
     TextElement elm = that->elements()->at(i);
     switch (elm.text_type()) {
       case TextElement::ATOM: {
-        base::Vector<const base::uc16> data = elm.atom()->data();
+        base::Vector<const uc16> data = elm.atom()->data();
         for (int i = 0; i < data.length(); i++) {
           os_ << static_cast<char>(data[i]);
         }
diff --git a/src/regexp/regexp-interpreter.cc b/src/regexp/regexp-interpreter.cc
index 02fc334920..76b685095a 100644
--- a/src/regexp/regexp-interpreter.cc
+++ b/src/regexp/regexp-interpreter.cc
@@ -8,7 +8,6 @@
 
 #include "src/ast/ast.h"
 #include "src/base/small-vector.h"
-#include "src/base/strings.h"
 #include "src/logging/counters.h"
 #include "src/objects/js-regexp-inl.h"
 #include "src/objects/objects-inl.h"
@@ -36,13 +35,12 @@ namespace internal {
 namespace {
 
 bool BackRefMatchesNoCase(Isolate* isolate, int from, int current, int len,
-                          base::Vector<const base::uc16> subject,
-                          bool unicode) {
+                          base::Vector<const uc16> subject, bool unicode) {
   Address offset_a =
-      reinterpret_cast<Address>(const_cast<base::uc16*>(&subject.at(from)));
+      reinterpret_cast<Address>(const_cast<uc16*>(&subject.at(from)));
   Address offset_b =
-      reinterpret_cast<Address>(const_cast<base::uc16*>(&subject.at(current)));
-  size_t length = len * base::kUC16Size;
+      reinterpret_cast<Address>(const_cast<uc16*>(&subject.at(current)));
+  size_t length = len * kUC16Size;
 
   bool result = unicode
                     ? RegExpMacroAssembler::CaseInsensitiveCompareUnicode(
@@ -291,8 +289,8 @@ IrregexpInterpreter::Result HandleInterrupts(
         return IrregexpInterpreter::EXCEPTION;
       }
 
-      // If we changed between a LATIN1 and a UC16 string, we need to
-      // restart regexp matching with the appropriate template instantiation of
+      // If we changed between a LATIN1 and a UC16 string, we need to restart
+      // regexp matching with the appropriate template instantiation of
       // RawMatch.
       if (String::IsOneByteRepresentationUnderneath(*subject_handle) !=
           was_one_byte) {
@@ -1082,7 +1080,7 @@ IrregexpInterpreter::Result IrregexpInterpreter::MatchInternal(
   //    after interrupts have run.
   DisallowGarbageCollection no_gc;
 
-  base::uc16 previous_char = '\n';
+  uc16 previous_char = '\n';
   String::FlatContent subject_content = subject_string.GetFlatContent(no_gc);
   if (subject_content.IsOneByte()) {
     base::Vector<const uint8_t> subject_vector =
@@ -1094,8 +1092,7 @@ IrregexpInterpreter::Result IrregexpInterpreter::MatchInternal(
                     call_origin, backtrack_limit);
   } else {
     DCHECK(subject_content.IsTwoByte());
-    base::Vector<const base::uc16> subject_vector =
-        subject_content.ToUC16Vector();
+    base::Vector<const uc16> subject_vector = subject_content.ToUC16Vector();
     if (start_position != 0) previous_char = subject_vector[start_position - 1];
     return RawMatch(isolate, code_array, subject_string, subject_vector,
                     output_registers, output_register_count,
diff --git a/src/regexp/regexp-macro-assembler-tracer.cc b/src/regexp/regexp-macro-assembler-tracer.cc
index af148eb47a..73d85d9526 100644
--- a/src/regexp/regexp-macro-assembler-tracer.cc
+++ b/src/regexp/regexp-macro-assembler-tracer.cc
@@ -174,7 +174,7 @@ void RegExpMacroAssemblerTracer::LoadCurrentCharacterImpl(
 
 class PrintablePrinter {
  public:
-  explicit PrintablePrinter(base::uc16 character) : character_(character) {}
+  explicit PrintablePrinter(uc16 character) : character_(character) { }
 
   const char* operator*() {
     if (character_ >= ' ' && character_ <= '~') {
@@ -189,12 +189,12 @@ class PrintablePrinter {
   }
 
  private:
-  base::uc16 character_;
+  uc16 character_;
   char buffer_[4];
 };
 
-void RegExpMacroAssemblerTracer::CheckCharacterLT(base::uc16 limit,
-                                                  Label* on_less) {
+
+void RegExpMacroAssemblerTracer::CheckCharacterLT(uc16 limit, Label* on_less) {
   PrintablePrinter printable(limit);
   PrintF(" CheckCharacterLT(c=0x%04x%s, label[%08x]);\n",
          limit,
@@ -203,7 +203,8 @@ void RegExpMacroAssemblerTracer::CheckCharacterLT(base::uc16 limit,
   assembler_->CheckCharacterLT(limit, on_less);
 }
 
-void RegExpMacroAssemblerTracer::CheckCharacterGT(base::uc16 limit,
+
+void RegExpMacroAssemblerTracer::CheckCharacterGT(uc16 limit,
                                                   Label* on_greater) {
   PrintablePrinter printable(limit);
   PrintF(" CheckCharacterGT(c=0x%04x%s, label[%08x]);\n",
@@ -213,6 +214,7 @@ void RegExpMacroAssemblerTracer::CheckCharacterGT(base::uc16 limit,
   assembler_->CheckCharacterGT(limit, on_greater);
 }
 
+
 void RegExpMacroAssemblerTracer::CheckCharacter(unsigned c, Label* on_equal) {
   PrintablePrinter printable(c);
   PrintF(" CheckCharacter(c=0x%04x%s, label[%08x]);\n",
@@ -275,8 +277,12 @@ void RegExpMacroAssemblerTracer::CheckNotCharacterAfterAnd(
   assembler_->CheckNotCharacterAfterAnd(c, mask, on_not_equal);
 }
 
+
 void RegExpMacroAssemblerTracer::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c,
+    uc16 minus,
+    uc16 mask,
+    Label* on_not_equal) {
   PrintF(" CheckNotCharacterAfterMinusAnd(c=0x%04x, minus=%04x, mask=0x%04x, "
              "label[%08x]);\n",
          c,
@@ -286,9 +292,11 @@ void RegExpMacroAssemblerTracer::CheckNotCharacterAfterMinusAnd(
   assembler_->CheckNotCharacterAfterMinusAnd(c, minus, mask, on_not_equal);
 }
 
-void RegExpMacroAssemblerTracer::CheckCharacterInRange(base::uc16 from,
-                                                       base::uc16 to,
-                                                       Label* on_not_in_range) {
+
+void RegExpMacroAssemblerTracer::CheckCharacterInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_not_in_range) {
   PrintablePrinter printable_from(from);
   PrintablePrinter printable_to(to);
   PrintF(" CheckCharacterInRange(from=0x%04x%s, to=0x%04x%s, label[%08x]);\n",
@@ -300,9 +308,11 @@ void RegExpMacroAssemblerTracer::CheckCharacterInRange(base::uc16 from,
   assembler_->CheckCharacterInRange(from, to, on_not_in_range);
 }
 
-void RegExpMacroAssemblerTracer::CheckCharacterNotInRange(base::uc16 from,
-                                                          base::uc16 to,
-                                                          Label* on_in_range) {
+
+void RegExpMacroAssemblerTracer::CheckCharacterNotInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_in_range) {
   PrintablePrinter printable_from(from);
   PrintablePrinter printable_to(to);
   PrintF(
@@ -315,6 +325,7 @@ void RegExpMacroAssemblerTracer::CheckCharacterNotInRange(base::uc16 from,
   assembler_->CheckCharacterNotInRange(from, to, on_in_range);
 }
 
+
 void RegExpMacroAssemblerTracer::CheckBitInTable(
     Handle<ByteArray> table, Label* on_bit_set) {
   PrintF(" CheckBitInTable(label[%08x] ", LabelToInt(on_bit_set));
@@ -353,8 +364,10 @@ void RegExpMacroAssemblerTracer::CheckPosition(int cp_offset,
   assembler_->CheckPosition(cp_offset, on_outside_input);
 }
 
+
 bool RegExpMacroAssemblerTracer::CheckSpecialCharacterClass(
-    base::uc16 type, Label* on_no_match) {
+    uc16 type,
+    Label* on_no_match) {
   bool supported = assembler_->CheckSpecialCharacterClass(type,
                                                           on_no_match);
   PrintF(" CheckSpecialCharacterClass(type='%c', label[%08x]): %s;\n",
@@ -364,6 +377,7 @@ bool RegExpMacroAssemblerTracer::CheckSpecialCharacterClass(
   return supported;
 }
 
+
 void RegExpMacroAssemblerTracer::IfRegisterLT(int register_index,
                                               int comparand, Label* if_lt) {
   PrintF(" IfRegisterLT(register=%d, number=%d, label[%08x]);\n",
diff --git a/src/regexp/regexp-macro-assembler-tracer.h b/src/regexp/regexp-macro-assembler-tracer.h
index 8d8a90be49..2a44146e73 100644
--- a/src/regexp/regexp-macro-assembler-tracer.h
+++ b/src/regexp/regexp-macro-assembler-tracer.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_REGEXP_MACRO_ASSEMBLER_TRACER_H_
 #define V8_REGEXP_REGEXP_MACRO_ASSEMBLER_TRACER_H_
 
-#include "src/base/strings.h"
 #include "src/regexp/regexp-macro-assembler.h"
 
 namespace v8 {
@@ -26,8 +25,8 @@ class RegExpMacroAssemblerTracer: public RegExpMacroAssembler {
   void CheckCharacter(unsigned c, Label* on_equal) override;
   void CheckCharacterAfterAnd(unsigned c, unsigned and_with,
                               Label* on_equal) override;
-  void CheckCharacterGT(base::uc16 limit, Label* on_greater) override;
-  void CheckCharacterLT(base::uc16 limit, Label* on_less) override;
+  void CheckCharacterGT(uc16 limit, Label* on_greater) override;
+  void CheckCharacterLT(uc16 limit, Label* on_less) override;
   void CheckGreedyLoop(Label* on_tos_equals_current_position) override;
   void CheckAtStart(int cp_offset, Label* on_at_start) override;
   void CheckNotAtStart(int cp_offset, Label* on_not_at_start) override;
@@ -39,16 +38,14 @@ class RegExpMacroAssemblerTracer: public RegExpMacroAssembler {
   void CheckNotCharacter(unsigned c, Label* on_not_equal) override;
   void CheckNotCharacterAfterAnd(unsigned c, unsigned and_with,
                                  Label* on_not_equal) override;
-  void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                      base::uc16 and_with,
+  void CheckNotCharacterAfterMinusAnd(uc16 c, uc16 minus, uc16 and_with,
                                       Label* on_not_equal) override;
-  void CheckCharacterInRange(base::uc16 from, base::uc16 to,
-                             Label* on_in_range) override;
-  void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  void CheckCharacterInRange(uc16 from, uc16 to, Label* on_in_range) override;
+  void CheckCharacterNotInRange(uc16 from, uc16 to,
                                 Label* on_not_in_range) override;
   void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set) override;
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match) override;
+  bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/regexp/regexp-macro-assembler.cc b/src/regexp/regexp-macro-assembler.cc
index 5457398f39..234b80797c 100644
--- a/src/regexp/regexp-macro-assembler.cc
+++ b/src/regexp/regexp-macro-assembler.cc
@@ -39,8 +39,8 @@ int RegExpMacroAssembler::CaseInsensitiveCompareNonUnicode(Address byte_offset1,
   DisallowGarbageCollection no_gc;
   DCHECK_EQ(0, byte_length % 2);
   size_t length = byte_length / 2;
-  base::uc16* substring1 = reinterpret_cast<base::uc16*>(byte_offset1);
-  base::uc16* substring2 = reinterpret_cast<base::uc16*>(byte_offset2);
+  uc16* substring1 = reinterpret_cast<uc16*>(byte_offset1);
+  uc16* substring2 = reinterpret_cast<uc16*>(byte_offset2);
 
   for (size_t i = 0; i < length; i++) {
     UChar32 c1 = RegExpCaseFolding::Canonicalize(substring1[i]);
@@ -73,8 +73,8 @@ int RegExpMacroAssembler::CaseInsensitiveCompareUnicode(Address byte_offset1,
   return uni_str_1.caseCompare(reinterpret_cast<const char16_t*>(byte_offset2),
                                length, U_FOLD_CASE_DEFAULT) == 0;
 #else
-  base::uc16* substring1 = reinterpret_cast<base::uc16*>(byte_offset1);
-  base::uc16* substring2 = reinterpret_cast<base::uc16*>(byte_offset2);
+  uc16* substring1 = reinterpret_cast<uc16*>(byte_offset1);
+  uc16* substring2 = reinterpret_cast<uc16*>(byte_offset2);
   size_t length = byte_length >> 1;
   DCHECK_NOT_NULL(isolate);
   unibrow::Mapping<unibrow::Ecma262Canonicalize>* canonicalize =
@@ -129,7 +129,7 @@ void RegExpMacroAssembler::LoadCurrentCharacter(int cp_offset,
                            eats_at_least);
 }
 
-bool RegExpMacroAssembler::CheckSpecialCharacterClass(base::uc16 type,
+bool RegExpMacroAssembler::CheckSpecialCharacterClass(uc16 type,
                                                       Label* on_no_match) {
   return false;
 }
diff --git a/src/regexp/regexp-macro-assembler.h b/src/regexp/regexp-macro-assembler.h
index 31e8b1a370..789624299b 100644
--- a/src/regexp/regexp-macro-assembler.h
+++ b/src/regexp/regexp-macro-assembler.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_REGEXP_MACRO_ASSEMBLER_H_
 #define V8_REGEXP_REGEXP_MACRO_ASSEMBLER_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/label.h"
 #include "src/regexp/regexp-ast.h"
 #include "src/regexp/regexp.h"
@@ -13,12 +12,12 @@
 namespace v8 {
 namespace internal {
 
-static const base::uc32 kLeadSurrogateStart = 0xd800;
-static const base::uc32 kLeadSurrogateEnd = 0xdbff;
-static const base::uc32 kTrailSurrogateStart = 0xdc00;
-static const base::uc32 kTrailSurrogateEnd = 0xdfff;
-static const base::uc32 kNonBmpStart = 0x10000;
-static const base::uc32 kNonBmpEnd = 0x10ffff;
+static const uc32 kLeadSurrogateStart = 0xd800;
+static const uc32 kLeadSurrogateEnd = 0xdbff;
+static const uc32 kTrailSurrogateStart = 0xdc00;
+static const uc32 kTrailSurrogateEnd = 0xdfff;
+static const uc32 kNonBmpStart = 0x10000;
+static const uc32 kNonBmpEnd = 0x10ffff;
 
 struct DisjunctDecisionRow {
   RegExpCharacterClass cc;
@@ -96,8 +95,8 @@ class RegExpMacroAssembler {
   virtual void CheckCharacterAfterAnd(unsigned c,
                                       unsigned and_with,
                                       Label* on_equal) = 0;
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater) = 0;
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less) = 0;
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater) = 0;
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less) = 0;
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position) = 0;
   virtual void CheckAtStart(int cp_offset, Label* on_at_start) = 0;
   virtual void CheckNotAtStart(int cp_offset, Label* on_not_at_start) = 0;
@@ -116,14 +115,15 @@ class RegExpMacroAssembler {
                                          Label* on_not_equal) = 0;
   // Subtract a constant from the current character, then and with the given
   // constant and then check for a match with c.
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 and_with,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c,
+                                              uc16 minus,
+                                              uc16 and_with,
                                               Label* on_not_equal) = 0;
-  virtual void CheckCharacterInRange(base::uc16 from,
-                                     base::uc16 to,  // Both inclusive.
+  virtual void CheckCharacterInRange(uc16 from,
+                                     uc16 to,  // Both inclusive.
                                      Label* on_in_range) = 0;
-  virtual void CheckCharacterNotInRange(base::uc16 from,
-                                        base::uc16 to,  // Both inclusive.
+  virtual void CheckCharacterNotInRange(uc16 from,
+                                        uc16 to,  // Both inclusive.
                                         Label* on_not_in_range) = 0;
 
   // The current character (modulus the kTableSize) is looked up in the byte
@@ -137,7 +137,7 @@ class RegExpMacroAssembler {
   // character. Returns false if the type of special character class does
   // not have custom support.
   // May clobber the current loaded character.
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match);
 
   // Control-flow integrity:
   // Define a jump target and bind a label.
diff --git a/src/regexp/regexp-parser.cc b/src/regexp/regexp-parser.cc
index aaa7b9cf8b..7d1d247877 100644
--- a/src/regexp/regexp-parser.cc
+++ b/src/regexp/regexp-parser.cc
@@ -47,17 +47,16 @@ RegExpParser::RegExpParser(FlatStringReader* in, JSRegExp::Flags flags,
 }
 
 template <bool update_position>
-inline base::uc32 RegExpParser::ReadNext() {
+inline uc32 RegExpParser::ReadNext() {
   int position = next_pos_;
-  base::uc32 c0 = in()->Get(position);
+  uc32 c0 = in()->Get(position);
   position++;
   // Read the whole surrogate pair in case of unicode flag, if possible.
   if (unicode() && position < in()->length() &&
-      unibrow::Utf16::IsLeadSurrogate(static_cast<base::uc16>(c0))) {
-    base::uc16 c1 = in()->Get(position);
+      unibrow::Utf16::IsLeadSurrogate(static_cast<uc16>(c0))) {
+    uc16 c1 = in()->Get(position);
     if (unibrow::Utf16::IsTrailSurrogate(c1)) {
-      c0 =
-          unibrow::Utf16::CombineSurrogatePair(static_cast<base::uc16>(c0), c1);
+      c0 = unibrow::Utf16::CombineSurrogatePair(static_cast<uc16>(c0), c1);
       position++;
     }
   }
@@ -65,7 +64,8 @@ inline base::uc32 RegExpParser::ReadNext() {
   return c0;
 }
 
-base::uc32 RegExpParser::Next() {
+
+uc32 RegExpParser::Next() {
   if (has_next()) {
     return ReadNext<false>();
   } else {
@@ -113,7 +113,7 @@ void RegExpParser::Advance(int dist) {
 
 bool RegExpParser::simple() { return simple_; }
 
-bool RegExpParser::IsSyntaxCharacterOrSlash(base::uc32 c) {
+bool RegExpParser::IsSyntaxCharacterOrSlash(uc32 c) {
   switch (c) {
     case '^':
     case '$':
@@ -324,7 +324,7 @@ RegExpTree* RegExpParser::ParseDisjunction() {
           case 'S':
           case 'w':
           case 'W': {
-            base::uc32 c = Next();
+            uc32 c = Next();
             Advance(2);
             ZoneList<CharacterRange>* ranges =
                 zone()->New<ZoneList<CharacterRange>>(2, zone());
@@ -337,7 +337,7 @@ RegExpTree* RegExpParser::ParseDisjunction() {
           }
           case 'p':
           case 'P': {
-            base::uc32 p = Next();
+            uc32 p = Next();
             Advance(2);
             if (unicode()) {
               ZoneList<CharacterRange>* ranges =
@@ -397,7 +397,7 @@ RegExpTree* RegExpParser::ParseDisjunction() {
             if (unicode()) {
               return ReportError(RegExpError::kInvalidEscape);
             }
-            base::uc32 first_digit = Next();
+            uc32 first_digit = Next();
             if (first_digit == '8' || first_digit == '9') {
               builder->AddCharacter(first_digit);
               Advance(2);
@@ -411,7 +411,7 @@ RegExpTree* RegExpParser::ParseDisjunction() {
               // With /u, decimal escape with leading 0 are not parsed as octal.
               return ReportError(RegExpError::kInvalidDecimalEscape);
             }
-            base::uc32 octal = ParseOctalLiteral();
+            uc32 octal = ParseOctalLiteral();
             builder->AddCharacter(octal);
             break;
           }
@@ -439,10 +439,10 @@ RegExpTree* RegExpParser::ParseDisjunction() {
             break;
           case 'c': {
             Advance();
-            base::uc32 controlLetter = Next();
+            uc32 controlLetter = Next();
             // Special case if it is an ASCII letter.
             // Convert lower case letters to uppercase.
-            base::uc32 letter = controlLetter & ~('a' ^ 'A');
+            uc32 letter = controlLetter & ~('a' ^ 'A');
             if (letter < 'A' || 'Z' < letter) {
               // controlLetter is not in range 'A'-'Z' or 'a'-'z'.
               // Read the backslash as a literal character instead of as
@@ -461,7 +461,7 @@ RegExpTree* RegExpParser::ParseDisjunction() {
           }
           case 'x': {
             Advance(2);
-            base::uc32 value;
+            uc32 value;
             if (ParseHexEscape(2, &value)) {
               builder->AddCharacter(value);
             } else if (!unicode()) {
@@ -474,7 +474,7 @@ RegExpTree* RegExpParser::ParseDisjunction() {
           }
           case 'u': {
             Advance(2);
-            base::uc32 value;
+            uc32 value;
             if (ParseUnicodeEscape(&value)) {
               builder->AddEscapedUnicodeCharacter(value);
             } else if (!unicode()) {
@@ -586,7 +586,7 @@ RegExpParser::RegExpParserState* RegExpParser::ParseOpenParenthesis(
   bool is_named_capture = false;
   JSRegExp::Flags switch_on = JSRegExp::kNone;
   JSRegExp::Flags switch_off = JSRegExp::kNone;
-  const ZoneVector<base::uc16>* capture_name = nullptr;
+  const ZoneVector<uc16>* capture_name = nullptr;
   SubexpressionType subexpr_type = CAPTURE;
   Advance();
   if (current() == '?') {
@@ -709,7 +709,7 @@ RegExpParser::RegExpParserState* RegExpParser::ParseOpenParenthesis(
 
 #ifdef DEBUG
 // Currently only used in an DCHECK.
-static bool IsSpecialClassEscape(base::uc32 c) {
+static bool IsSpecialClassEscape(uc32 c) {
   switch (c) {
     case 'd':
     case 'D':
@@ -795,7 +795,7 @@ bool RegExpParser::ParseBackReferenceIndex(int* index_out) {
   int value = Next() - '0';
   Advance(2);
   while (true) {
-    base::uc32 c = current();
+    uc32 c = current();
     if (IsDecimalDigit(c)) {
       value = 10 * value + (c - '0');
       if (value > JSRegExp::kMaxCaptures) {
@@ -818,7 +818,7 @@ bool RegExpParser::ParseBackReferenceIndex(int* index_out) {
   return true;
 }
 
-static void push_code_unit(ZoneVector<base::uc16>* v, uint32_t code_unit) {
+static void push_code_unit(ZoneVector<uc16>* v, uint32_t code_unit) {
   if (code_unit <= unibrow::Utf16::kMaxNonSurrogateCharCode) {
     v->push_back(code_unit);
   } else {
@@ -827,12 +827,12 @@ static void push_code_unit(ZoneVector<base::uc16>* v, uint32_t code_unit) {
   }
 }
 
-const ZoneVector<base::uc16>* RegExpParser::ParseCaptureGroupName() {
-  ZoneVector<base::uc16>* name = zone()->New<ZoneVector<base::uc16>>(zone());
+const ZoneVector<uc16>* RegExpParser::ParseCaptureGroupName() {
+  ZoneVector<uc16>* name = zone()->New<ZoneVector<uc16>>(zone());
 
   bool at_start = true;
   while (true) {
-    base::uc32 c = current();
+    uc32 c = current();
     Advance();
 
     // Convert unicode escapes.
@@ -872,7 +872,7 @@ const ZoneVector<base::uc16>* RegExpParser::ParseCaptureGroupName() {
   return name;
 }
 
-bool RegExpParser::CreateNamedCaptureAtIndex(const ZoneVector<base::uc16>* name,
+bool RegExpParser::CreateNamedCaptureAtIndex(const ZoneVector<uc16>* name,
                                              int index) {
   DCHECK(0 < index && index <= captures_started_);
   DCHECK_NOT_NULL(name);
@@ -909,7 +909,7 @@ bool RegExpParser::ParseNamedBackReference(RegExpBuilder* builder,
   }
 
   Advance();
-  const ZoneVector<base::uc16>* name = ParseCaptureGroupName();
+  const ZoneVector<uc16>* name = ParseCaptureGroupName();
   if (name == nullptr) {
     return false;
   }
@@ -1014,8 +1014,8 @@ Handle<FixedArray> RegExpParser::CreateCaptureNameMap() {
 
   int i = 0;
   for (const auto& capture : sorted_named_captures) {
-    base::Vector<const base::uc16> capture_name(capture->name()->data(),
-                                                capture->name()->size());
+    base::Vector<const uc16> capture_name(capture->name()->data(),
+                                          capture->name()->size());
     // CSA code in ConstructNewResultFromMatchInfo requires these strings to be
     // internalized so they can be used as property names in the 'exec' results.
     Handle<String> name = factory->InternalizeString(capture_name);
@@ -1051,7 +1051,7 @@ bool RegExpParser::RegExpParserState::IsInsideCaptureGroup(int index) {
 }
 
 bool RegExpParser::RegExpParserState::IsInsideCaptureGroup(
-    const ZoneVector<base::uc16>* name) {
+    const ZoneVector<uc16>* name) {
   DCHECK_NOT_NULL(name);
   for (RegExpParserState* s = this; s != nullptr; s = s->previous_state()) {
     if (s->capture_name() == nullptr) continue;
@@ -1126,12 +1126,13 @@ bool RegExpParser::ParseIntervalQuantifier(int* min_out, int* max_out) {
   return true;
 }
 
-base::uc32 RegExpParser::ParseOctalLiteral() {
+
+uc32 RegExpParser::ParseOctalLiteral() {
   DCHECK(('0' <= current() && current() <= '7') || current() == kEndMarker);
   // For compatibility with some other browsers (not all), we parse
   // up to three octal digits with a value below 256.
   // ES#prod-annexB-LegacyOctalEscapeSequence
-  base::uc32 value = current() - '0';
+  uc32 value = current() - '0';
   Advance();
   if ('0' <= current() && current() <= '7') {
     value = value * 8 + current() - '0';
@@ -1144,12 +1145,13 @@ base::uc32 RegExpParser::ParseOctalLiteral() {
   return value;
 }
 
-bool RegExpParser::ParseHexEscape(int length, base::uc32* value) {
+
+bool RegExpParser::ParseHexEscape(int length, uc32* value) {
   int start = position();
-  base::uc32 val = 0;
+  uc32 val = 0;
   for (int i = 0; i < length; ++i) {
-    base::uc32 c = current();
-    int d = base::HexValue(c);
+    uc32 c = current();
+    int d = HexValue(c);
     if (d < 0) {
       Reset(start);
       return false;
@@ -1162,7 +1164,7 @@ bool RegExpParser::ParseHexEscape(int length, base::uc32* value) {
 }
 
 // This parses RegExpUnicodeEscapeSequence as described in ECMA262.
-bool RegExpParser::ParseUnicodeEscape(base::uc32* value) {
+bool RegExpParser::ParseUnicodeEscape(uc32* value) {
   // Accept both \uxxxx and \u{xxxxxx} (if harmony unicode escapes are
   // allowed). In the latter case, the number of hex digits between { } is
   // arbitrary. \ and u have already been read.
@@ -1186,11 +1188,11 @@ bool RegExpParser::ParseUnicodeEscape(base::uc32* value) {
     int start = position();
     if (Next() == 'u') {
       Advance(2);
-      base::uc32 trail;
+      uc32 trail;
       if (ParseHexEscape(4, &trail) &&
           unibrow::Utf16::IsTrailSurrogate(trail)) {
-        *value = unibrow::Utf16::CombineSurrogatePair(
-            static_cast<base::uc16>(*value), static_cast<base::uc16>(trail));
+        *value = unibrow::Utf16::CombineSurrogatePair(static_cast<uc16>(*value),
+                                                      static_cast<uc16>(trail));
         return true;
       }
     }
@@ -1458,7 +1460,7 @@ bool RegExpParser::AddPropertyClassRange(ZoneList<CharacterRange>* add_to,
 RegExpTree* RegExpParser::GetPropertySequence(const ZoneVector<char>& name_1) {
   if (!FLAG_harmony_regexp_sequence) return nullptr;
   const char* name = name_1.data();
-  const base::uc32* sequence_list = nullptr;
+  const uc32* sequence_list = nullptr;
   JSRegExp::Flags flags = JSRegExp::kUnicode;
   if (NameEquals(name, "Emoji_Flag_Sequence")) {
     sequence_list = UnicodePropertySequences::kEmojiFlagSequences;
@@ -1539,26 +1541,26 @@ RegExpTree* RegExpParser::GetPropertySequence(const ZoneVector<char>& name) {
 
 #endif  // V8_INTL_SUPPORT
 
-bool RegExpParser::ParseUnlimitedLengthHexNumber(int max_value,
-                                                 base::uc32* value) {
-  base::uc32 x = 0;
-  int d = base::HexValue(current());
+bool RegExpParser::ParseUnlimitedLengthHexNumber(int max_value, uc32* value) {
+  uc32 x = 0;
+  int d = HexValue(current());
   if (d < 0) {
     return false;
   }
   while (d >= 0) {
     x = x * 16 + d;
-    if (x > static_cast<base::uc32>(max_value)) {
+    if (x > static_cast<uc32>(max_value)) {
       return false;
     }
     Advance();
-    d = base::HexValue(current());
+    d = HexValue(current());
   }
   *value = x;
   return true;
 }
 
-base::uc32 RegExpParser::ParseClassCharacterEscape() {
+
+uc32 RegExpParser::ParseClassCharacterEscape() {
   DCHECK_EQ('\\', current());
   DCHECK(has_next() && !IsSpecialClassEscape(Next()));
   Advance();
@@ -1584,8 +1586,8 @@ base::uc32 RegExpParser::ParseClassCharacterEscape() {
       Advance();
       return '\v';
     case 'c': {
-      base::uc32 controlLetter = Next();
-      base::uc32 letter = controlLetter & ~('A' ^ 'a');
+      uc32 controlLetter = Next();
+      uc32 letter = controlLetter & ~('A' ^ 'a');
       // Inside a character class, we also accept digits and underscore as
       // control characters, unless with /u. See Annex B:
       // ES#prod-annexB-ClassControlLetter
@@ -1636,7 +1638,7 @@ base::uc32 RegExpParser::ParseClassCharacterEscape() {
       return ParseOctalLiteral();
     case 'x': {
       Advance();
-      base::uc32 value;
+      uc32 value;
       if (ParseHexEscape(2, &value)) return value;
       if (unicode()) {
         // With /u, invalid escapes are not treated as identity escapes.
@@ -1649,7 +1651,7 @@ base::uc32 RegExpParser::ParseClassCharacterEscape() {
     }
     case 'u': {
       Advance();
-      base::uc32 value;
+      uc32 value;
       if (ParseUnicodeEscape(&value)) return value;
       if (unicode()) {
         // With /u, invalid escapes are not treated as identity escapes.
@@ -1661,7 +1663,7 @@ base::uc32 RegExpParser::ParseClassCharacterEscape() {
       return 'u';
     }
     default: {
-      base::uc32 result = current();
+      uc32 result = current();
       // With /u, no identity escapes except for syntax characters and '-' are
       // allowed. Otherwise, all identity escapes are allowed.
       if (!unicode() || IsSyntaxCharacterOrSlash(result) || result == '-') {
@@ -1678,9 +1680,8 @@ base::uc32 RegExpParser::ParseClassCharacterEscape() {
 void RegExpParser::ParseClassEscape(ZoneList<CharacterRange>* ranges,
                                     Zone* zone,
                                     bool add_unicode_case_equivalents,
-                                    base::uc32* char_out,
-                                    bool* is_class_escape) {
-  base::uc32 current_char = current();
+                                    uc32* char_out, bool* is_class_escape) {
+  uc32 current_char = current();
   if (current_char == '\\') {
     switch (Next()) {
       case 'w':
@@ -1737,7 +1738,7 @@ RegExpTree* RegExpParser::ParseCharacterClass(const RegExpBuilder* builder) {
       zone()->New<ZoneList<CharacterRange>>(2, zone());
   bool add_unicode_case_equivalents = unicode() && builder->ignore_case();
   while (has_more() && current() != ']') {
-    base::uc32 char_1, char_2;
+    uc32 char_1, char_2;
     bool is_class_1, is_class_2;
     ParseClassEscape(ranges, zone(), add_unicode_case_equivalents, &char_1,
                      &is_class_1 CHECK_FAILED);
@@ -1852,25 +1853,27 @@ RegExpBuilder::RegExpBuilder(Zone* zone, JSRegExp::Flags flags)
 {
 }
 
-void RegExpBuilder::AddLeadSurrogate(base::uc16 lead_surrogate) {
+
+void RegExpBuilder::AddLeadSurrogate(uc16 lead_surrogate) {
   DCHECK(unibrow::Utf16::IsLeadSurrogate(lead_surrogate));
   FlushPendingSurrogate();
   // Hold onto the lead surrogate, waiting for a trail surrogate to follow.
   pending_surrogate_ = lead_surrogate;
 }
 
-void RegExpBuilder::AddTrailSurrogate(base::uc16 trail_surrogate) {
+
+void RegExpBuilder::AddTrailSurrogate(uc16 trail_surrogate) {
   DCHECK(unibrow::Utf16::IsTrailSurrogate(trail_surrogate));
   if (pending_surrogate_ != kNoPendingSurrogate) {
-    base::uc16 lead_surrogate = pending_surrogate_;
+    uc16 lead_surrogate = pending_surrogate_;
     pending_surrogate_ = kNoPendingSurrogate;
     DCHECK(unibrow::Utf16::IsLeadSurrogate(lead_surrogate));
-    base::uc32 combined =
+    uc32 combined =
         unibrow::Utf16::CombineSurrogatePair(lead_surrogate, trail_surrogate);
     if (NeedsDesugaringForIgnoreCase(combined)) {
       AddCharacterClassForDesugaring(combined);
     } else {
-      ZoneList<base::uc16> surrogate_pair(2, zone());
+      ZoneList<uc16> surrogate_pair(2, zone());
       surrogate_pair.Add(lead_surrogate, zone());
       surrogate_pair.Add(trail_surrogate, zone());
       RegExpAtom* atom =
@@ -1883,10 +1886,11 @@ void RegExpBuilder::AddTrailSurrogate(base::uc16 trail_surrogate) {
   }
 }
 
+
 void RegExpBuilder::FlushPendingSurrogate() {
   if (pending_surrogate_ != kNoPendingSurrogate) {
     DCHECK(unicode());
-    base::uc32 c = pending_surrogate_;
+    uc32 c = pending_surrogate_;
     pending_surrogate_ = kNoPendingSurrogate;
     AddCharacterClassForDesugaring(c);
   }
@@ -1921,22 +1925,24 @@ void RegExpBuilder::FlushText() {
   text_.Clear();
 }
 
-void RegExpBuilder::AddCharacter(base::uc16 c) {
+
+void RegExpBuilder::AddCharacter(uc16 c) {
   FlushPendingSurrogate();
   pending_empty_ = false;
   if (NeedsDesugaringForIgnoreCase(c)) {
     AddCharacterClassForDesugaring(c);
   } else {
     if (characters_ == nullptr) {
-      characters_ = zone()->New<ZoneList<base::uc16>>(4, zone());
+      characters_ = zone()->New<ZoneList<uc16>>(4, zone());
     }
     characters_->Add(c, zone());
     LAST(ADD_CHAR);
   }
 }
 
-void RegExpBuilder::AddUnicodeCharacter(base::uc32 c) {
-  if (c > static_cast<base::uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
+
+void RegExpBuilder::AddUnicodeCharacter(uc32 c) {
+  if (c > static_cast<uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
     DCHECK(unicode());
     AddLeadSurrogate(unibrow::Utf16::LeadSurrogate(c));
     AddTrailSurrogate(unibrow::Utf16::TrailSurrogate(c));
@@ -1945,11 +1951,11 @@ void RegExpBuilder::AddUnicodeCharacter(base::uc32 c) {
   } else if (unicode() && unibrow::Utf16::IsTrailSurrogate(c)) {
     AddTrailSurrogate(c);
   } else {
-    AddCharacter(static_cast<base::uc16>(c));
+    AddCharacter(static_cast<uc16>(c));
   }
 }
 
-void RegExpBuilder::AddEscapedUnicodeCharacter(base::uc32 character) {
+void RegExpBuilder::AddEscapedUnicodeCharacter(uc32 character) {
   // A lead or trail surrogate parsed via escape sequence will not
   // pair up with any preceding lead or following trail surrogate.
   FlushPendingSurrogate();
@@ -1970,12 +1976,13 @@ void RegExpBuilder::AddCharacterClass(RegExpCharacterClass* cc) {
   }
 }
 
-void RegExpBuilder::AddCharacterClassForDesugaring(base::uc32 c) {
+void RegExpBuilder::AddCharacterClassForDesugaring(uc32 c) {
   AddTerm(zone()->New<RegExpCharacterClass>(
       zone(), CharacterRange::List(zone(), CharacterRange::Singleton(c)),
       flags_));
 }
 
+
 void RegExpBuilder::AddAtom(RegExpTree* term) {
   if (term->IsEmpty()) {
     AddEmpty();
@@ -2035,8 +2042,8 @@ bool RegExpBuilder::NeedsDesugaringForUnicode(RegExpCharacterClass* cc) {
   ZoneList<CharacterRange>* ranges = cc->ranges(zone());
   CharacterRange::Canonicalize(ranges);
   for (int i = ranges->length() - 1; i >= 0; i--) {
-    base::uc32 from = ranges->at(i).from();
-    base::uc32 to = ranges->at(i).to();
+    uc32 from = ranges->at(i).from();
+    uc32 to = ranges->at(i).to();
     // Check for non-BMP characters.
     if (to >= kNonBmpStart) return true;
     // Check for lone surrogates.
@@ -2045,7 +2052,8 @@ bool RegExpBuilder::NeedsDesugaringForUnicode(RegExpCharacterClass* cc) {
   return false;
 }
 
-bool RegExpBuilder::NeedsDesugaringForIgnoreCase(base::uc32 c) {
+
+bool RegExpBuilder::NeedsDesugaringForIgnoreCase(uc32 c) {
 #ifdef V8_INTL_SUPPORT
   if (unicode() && ignore_case()) {
     icu::UnicodeSet set(c, c);
@@ -2059,6 +2067,7 @@ bool RegExpBuilder::NeedsDesugaringForIgnoreCase(base::uc32 c) {
   return false;
 }
 
+
 RegExpTree* RegExpBuilder::ToRegExp() {
   FlushTerms();
   int num_alternatives = alternatives_.length();
@@ -2078,11 +2087,10 @@ bool RegExpBuilder::AddQuantifierToAtom(
   if (characters_ != nullptr) {
     DCHECK(last_added_ == ADD_CHAR);
     // Last atom was character.
-    base::Vector<const base::uc16> char_vector = characters_->ToConstVector();
+    base::Vector<const uc16> char_vector = characters_->ToConstVector();
     int num_chars = char_vector.length();
     if (num_chars > 1) {
-      base::Vector<const base::uc16> prefix =
-          char_vector.SubVector(0, num_chars - 1);
+      base::Vector<const uc16> prefix = char_vector.SubVector(0, num_chars - 1);
       text_.Add(zone()->New<RegExpAtom>(prefix, flags_), zone());
       char_vector = char_vector.SubVector(num_chars - 1, num_chars);
     }
diff --git a/src/regexp/regexp-parser.h b/src/regexp/regexp-parser.h
index 3766d43fb5..c33a5d8115 100644
--- a/src/regexp/regexp-parser.h
+++ b/src/regexp/regexp-parser.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_REGEXP_PARSER_H_
 #define V8_REGEXP_REGEXP_PARSER_H_
 
-#include "src/base/strings.h"
 #include "src/objects/js-regexp.h"
 #include "src/objects/objects.h"
 #include "src/regexp/regexp-ast.h"
@@ -102,14 +101,14 @@ class BufferedZoneList {
 class RegExpBuilder : public ZoneObject {
  public:
   RegExpBuilder(Zone* zone, JSRegExp::Flags flags);
-  void AddCharacter(base::uc16 character);
-  void AddUnicodeCharacter(base::uc32 character);
-  void AddEscapedUnicodeCharacter(base::uc32 character);
+  void AddCharacter(uc16 character);
+  void AddUnicodeCharacter(uc32 character);
+  void AddEscapedUnicodeCharacter(uc32 character);
   // "Adds" an empty expression. Does nothing except consume a
   // following quantifier
   void AddEmpty();
   void AddCharacterClass(RegExpCharacterClass* cc);
-  void AddCharacterClassForDesugaring(base::uc32 c);
+  void AddCharacterClassForDesugaring(uc32 c);
   void AddAtom(RegExpTree* tree);
   void AddTerm(RegExpTree* tree);
   void AddAssertion(RegExpTree* tree);
@@ -126,22 +125,22 @@ class RegExpBuilder : public ZoneObject {
   bool dotall() const { return (flags_ & JSRegExp::kDotAll) != 0; }
 
  private:
-  static const base::uc16 kNoPendingSurrogate = 0;
-  void AddLeadSurrogate(base::uc16 lead_surrogate);
-  void AddTrailSurrogate(base::uc16 trail_surrogate);
+  static const uc16 kNoPendingSurrogate = 0;
+  void AddLeadSurrogate(uc16 lead_surrogate);
+  void AddTrailSurrogate(uc16 trail_surrogate);
   void FlushPendingSurrogate();
   void FlushCharacters();
   void FlushTerms();
   bool NeedsDesugaringForUnicode(RegExpCharacterClass* cc);
-  bool NeedsDesugaringForIgnoreCase(base::uc32 c);
+  bool NeedsDesugaringForIgnoreCase(uc32 c);
   Zone* zone() const { return zone_; }
   bool unicode() const { return (flags_ & JSRegExp::kUnicode) != 0; }
 
   Zone* zone_;
   bool pending_empty_;
   JSRegExp::Flags flags_;
-  ZoneList<base::uc16>* characters_;
-  base::uc16 pending_surrogate_;
+  ZoneList<uc16>* characters_;
+  uc16 pending_surrogate_;
   BufferedZoneList<RegExpTree, 2> terms_;
   BufferedZoneList<RegExpTree, 2> text_;
   BufferedZoneList<RegExpTree, 2> alternatives_;
@@ -180,13 +179,13 @@ class V8_EXPORT_PRIVATE RegExpParser {
 
   // Parses and returns a single escaped character.  The character
   // must not be 'b' or 'B' since they are usually handle specially.
-  base::uc32 ParseClassCharacterEscape();
+  uc32 ParseClassCharacterEscape();
 
   // Checks whether the following is a length-digit hexadecimal number,
   // and sets the value if it is.
-  bool ParseHexEscape(int length, base::uc32* value);
-  bool ParseUnicodeEscape(base::uc32* value);
-  bool ParseUnlimitedLengthHexNumber(int max_value, base::uc32* value);
+  bool ParseHexEscape(int length, uc32* value);
+  bool ParseUnicodeEscape(uc32* value);
+  bool ParseUnlimitedLengthHexNumber(int max_value, uc32* value);
 
   bool ParsePropertyClassName(ZoneVector<char>* name_1,
                               ZoneVector<char>* name_2);
@@ -197,7 +196,7 @@ class V8_EXPORT_PRIVATE RegExpParser {
   RegExpTree* GetPropertySequence(const ZoneVector<char>& name_1);
   RegExpTree* ParseCharacterClass(const RegExpBuilder* state);
 
-  base::uc32 ParseOctalLiteral();
+  uc32 ParseOctalLiteral();
 
   // Tries to parse the input as a back reference.  If successful it
   // stores the result in the output parameter and returns true.  If
@@ -208,7 +207,7 @@ class V8_EXPORT_PRIVATE RegExpParser {
   // Parse inside a class. Either add escaped class to the range, or return
   // false and pass parsed single character through |char_out|.
   void ParseClassEscape(ZoneList<CharacterRange>* ranges, Zone* zone,
-                        bool add_unicode_case_equivalents, base::uc32* char_out,
+                        bool add_unicode_case_equivalents, uc32* char_out,
                         bool* is_class_escape);
 
   char ParseClassEscape();
@@ -230,9 +229,9 @@ class V8_EXPORT_PRIVATE RegExpParser {
   // just read the initial flag value here.
   bool unicode() const { return (top_level_flags_ & JSRegExp::kUnicode) != 0; }
 
-  static bool IsSyntaxCharacterOrSlash(base::uc32 c);
+  static bool IsSyntaxCharacterOrSlash(uc32 c);
 
-  static const base::uc32 kEndMarker = (1 << 21);
+  static const uc32 kEndMarker = (1 << 21);
 
  private:
   enum SubexpressionType {
@@ -250,7 +249,7 @@ class V8_EXPORT_PRIVATE RegExpParser {
                       SubexpressionType group_type,
                       RegExpLookaround::Type lookaround_type,
                       int disjunction_capture_index,
-                      const ZoneVector<base::uc16>* capture_name,
+                      const ZoneVector<uc16>* capture_name,
                       JSRegExp::Flags flags, Zone* zone)
         : previous_state_(previous_state),
           builder_(zone->New<RegExpBuilder>(zone, flags)),
@@ -273,14 +272,14 @@ class V8_EXPORT_PRIVATE RegExpParser {
     int capture_index() const { return disjunction_capture_index_; }
     // The name of the current sub-expression, if group_type is CAPTURE. Only
     // used for named captures.
-    const ZoneVector<base::uc16>* capture_name() const { return capture_name_; }
+    const ZoneVector<uc16>* capture_name() const { return capture_name_; }
 
     bool IsNamedCapture() const { return capture_name_ != nullptr; }
 
     // Check whether the parser is inside a capture group with the given index.
     bool IsInsideCaptureGroup(int index);
     // Check whether the parser is inside a capture group with the given name.
-    bool IsInsideCaptureGroup(const ZoneVector<base::uc16>* name);
+    bool IsInsideCaptureGroup(const ZoneVector<uc16>* name);
 
    private:
     // Linked list implementation of stack of states.
@@ -294,7 +293,7 @@ class V8_EXPORT_PRIVATE RegExpParser {
     // Stored disjunction's capture index (if any).
     const int disjunction_capture_index_;
     // Stored capture name (if any).
-    const ZoneVector<base::uc16>* const capture_name_;
+    const ZoneVector<uc16>* const capture_name_;
   };
 
   // Return the 1-indexed RegExpCapture object, allocate if necessary.
@@ -303,11 +302,11 @@ class V8_EXPORT_PRIVATE RegExpParser {
   // Creates a new named capture at the specified index. Must be called exactly
   // once for each named capture. Fails if a capture with the same name is
   // encountered.
-  bool CreateNamedCaptureAtIndex(const ZoneVector<base::uc16>* name, int index);
+  bool CreateNamedCaptureAtIndex(const ZoneVector<uc16>* name, int index);
 
   // Parses the name of a capture group (?<name>pattern). The name must adhere
   // to IdentifierName in the ECMAScript standard.
-  const ZoneVector<base::uc16>* ParseCaptureGroupName();
+  const ZoneVector<uc16>* ParseCaptureGroupName();
 
   bool ParseNamedBackReference(RegExpBuilder* builder,
                                RegExpParserState* state);
@@ -327,12 +326,12 @@ class V8_EXPORT_PRIVATE RegExpParser {
   Isolate* isolate() { return isolate_; }
   Zone* zone() const { return zone_; }
 
-  base::uc32 current() { return current_; }
+  uc32 current() { return current_; }
   bool has_more() { return has_more_; }
   bool has_next() { return next_pos_ < in()->length(); }
-  base::uc32 Next();
+  uc32 Next();
   template <bool update_position>
-  base::uc32 ReadNext();
+  uc32 ReadNext();
   FlatStringReader* in() { return in_; }
   void ScanForCaptures();
 
@@ -352,7 +351,7 @@ class V8_EXPORT_PRIVATE RegExpParser {
   ZoneSet<RegExpCapture*, RegExpCaptureNameLess>* named_captures_;
   ZoneList<RegExpBackReference*>* named_back_references_;
   FlatStringReader* in_;
-  base::uc32 current_;
+  uc32 current_;
   // These are the flags specified outside the regexp syntax ie after the
   // terminating '/' or in the second argument to the constructor.  The current
   // flags are stored on the RegExpBuilder.
diff --git a/src/regexp/regexp.cc b/src/regexp/regexp.cc
index d2e5f1a1f9..16485203d2 100644
--- a/src/regexp/regexp.cc
+++ b/src/regexp/regexp.cc
@@ -4,7 +4,6 @@
 
 #include "src/regexp/regexp.h"
 
-#include "src/base/strings.h"
 #include "src/codegen/compilation-cache.h"
 #include "src/diagnostics/code-tracer.h"
 #include "src/execution/interrupts-scope.h"
@@ -220,7 +219,7 @@ MaybeHandle<Object> RegExp::Compile(Isolate* isolate, Handle<JSRegExp> re,
     RegExpAtom* atom = parse_result.tree->AsAtom();
     // The pattern source might (?) contain escape sequences, but they're
     // resolved in atom_string.
-    base::Vector<const base::uc16> atom_pattern = atom->data();
+    base::Vector<const uc16> atom_pattern = atom->data();
     Handle<String> atom_string;
     ASSIGN_RETURN_ON_EXCEPTION(
         isolate, atom_string,
@@ -613,8 +612,8 @@ int RegExpImpl::IrregexpExecRaw(Isolate* isolate, Handle<JSRegExp> regexp,
       // must restart from scratch.
       // In this case, it means we must make sure we are prepared to handle
       // the, potentially, different subject (the string can switch between
-      // being internal and external, and even between being Latin1 and
-      // UC16, but the characters are always the same).
+      // being internal and external, and even between being Latin1 and UC16,
+      // but the characters are always the same).
       is_one_byte = String::IsOneByteRepresentationUnderneath(*subject);
     } while (true);
     UNREACHABLE();
diff --git a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
index 3269779efa..932e045848 100644
--- a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
+++ b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
@@ -185,7 +185,7 @@ void RegExpMacroAssemblerRISCV::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(on_equal, eq, current_character(), Operand(c));
 }
 
-void RegExpMacroAssemblerRISCV::CheckCharacterGT(base::uc16 limit,
+void RegExpMacroAssemblerRISCV::CheckCharacterGT(uc16 limit,
                                                  Label* on_greater) {
   BranchOrBacktrack(on_greater, gt, current_character(), Operand(limit));
 }
@@ -206,8 +206,7 @@ void RegExpMacroAssemblerRISCV::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(on_not_at_start, ne, a0, Operand(a1));
 }
 
-void RegExpMacroAssemblerRISCV::CheckCharacterLT(base::uc16 limit,
-                                                 Label* on_less) {
+void RegExpMacroAssemblerRISCV::CheckCharacterLT(uc16 limit, Label* on_less) {
   BranchOrBacktrack(on_less, lt, current_character(), Operand(limit));
 }
 
@@ -445,15 +444,14 @@ void RegExpMacroAssemblerRISCV::CheckNotCharacterAfterAnd(uint32_t c,
 }
 
 void RegExpMacroAssemblerRISCV::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c, uc16 minus, uc16 mask, Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ Sub64(a0, current_character(), Operand(minus));
   __ And(a0, a0, Operand(mask));
   BranchOrBacktrack(on_not_equal, ne, a0, Operand(c));
 }
 
-void RegExpMacroAssemblerRISCV::CheckCharacterInRange(base::uc16 from,
-                                                      base::uc16 to,
+void RegExpMacroAssemblerRISCV::CheckCharacterInRange(uc16 from, uc16 to,
                                                       Label* on_in_range) {
   __ Sub64(a0, current_character(), Operand(from));
   // Unsigned lower-or-same condition.
@@ -461,7 +459,7 @@ void RegExpMacroAssemblerRISCV::CheckCharacterInRange(base::uc16 from,
 }
 
 void RegExpMacroAssemblerRISCV::CheckCharacterNotInRange(
-    base::uc16 from, base::uc16 to, Label* on_not_in_range) {
+    uc16 from, uc16 to, Label* on_not_in_range) {
   __ Sub64(a0, current_character(), Operand(from));
   // Unsigned higher condition.
   BranchOrBacktrack(on_not_in_range, Ugreater, a0, Operand(to - from));
@@ -481,7 +479,7 @@ void RegExpMacroAssemblerRISCV::CheckBitInTable(Handle<ByteArray> table,
   BranchOrBacktrack(on_bit_set, ne, a0, Operand(zero_reg));
 }
 
-bool RegExpMacroAssemblerRISCV::CheckSpecialCharacterClass(base::uc16 type,
+bool RegExpMacroAssemblerRISCV::CheckSpecialCharacterClass(uc16 type,
                                                            Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check.
diff --git a/src/regexp/riscv64/regexp-macro-assembler-riscv64.h b/src/regexp/riscv64/regexp-macro-assembler-riscv64.h
index a5d5bb529e..8e49ff9381 100644
--- a/src/regexp/riscv64/regexp-macro-assembler-riscv64.h
+++ b/src/regexp/riscv64/regexp-macro-assembler-riscv64.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_RISCV64_REGEXP_MACRO_ASSEMBLER_RISCV64_H_
 #define V8_REGEXP_RISCV64_REGEXP_MACRO_ASSEMBLER_RISCV64_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/riscv64/assembler-riscv64.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -28,8 +27,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerRISCV
   virtual void CheckCharacter(uint32_t c, Label* on_equal);
   virtual void CheckCharacterAfterAnd(uint32_t c, uint32_t mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -42,19 +41,17 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerRISCV
   virtual void CheckNotCharacter(uint32_t c, Label* on_not_equal);
   virtual void CheckNotCharacterAfterAnd(uint32_t c, uint32_t mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c, uc16 minus, uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
-                                     Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from, uc16 to, Label* on_in_range);
+  virtual void CheckCharacterNotInRange(uc16 from, uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
   virtual void GoTo(Label* label);
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.cc b/src/regexp/s390/regexp-macro-assembler-s390.cc
index 83092e5336..61a5e6e642 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.cc
+++ b/src/regexp/s390/regexp-macro-assembler-s390.cc
@@ -198,8 +198,7 @@ void RegExpMacroAssemblerS390::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(eq, on_equal);
 }
 
-void RegExpMacroAssemblerS390::CheckCharacterGT(base::uc16 limit,
-                                                Label* on_greater) {
+void RegExpMacroAssemblerS390::CheckCharacterGT(uc16 limit, Label* on_greater) {
   __ CmpU64(current_character(), Operand(limit));
   BranchOrBacktrack(gt, on_greater);
 }
@@ -221,8 +220,7 @@ void RegExpMacroAssemblerS390::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(ne, on_not_at_start);
 }
 
-void RegExpMacroAssemblerS390::CheckCharacterLT(base::uc16 limit,
-                                                Label* on_less) {
+void RegExpMacroAssemblerS390::CheckCharacterLT(uc16 limit, Label* on_less) {
   __ CmpU64(current_character(), Operand(limit));
   BranchOrBacktrack(lt, on_less);
 }
@@ -468,7 +466,7 @@ void RegExpMacroAssemblerS390::CheckNotCharacterAfterAnd(unsigned c,
 }
 
 void RegExpMacroAssemblerS390::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c, uc16 minus, uc16 mask, Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ lay(r2, MemOperand(current_character(), -minus));
   __ And(r2, Operand(mask));
@@ -478,8 +476,7 @@ void RegExpMacroAssemblerS390::CheckNotCharacterAfterMinusAnd(
   BranchOrBacktrack(ne, on_not_equal);
 }
 
-void RegExpMacroAssemblerS390::CheckCharacterInRange(base::uc16 from,
-                                                     base::uc16 to,
+void RegExpMacroAssemblerS390::CheckCharacterInRange(uc16 from, uc16 to,
                                                      Label* on_in_range) {
   __ lay(r2, MemOperand(current_character(), -from));
   __ CmpU64(r2, Operand(to - from));
@@ -487,7 +484,7 @@ void RegExpMacroAssemblerS390::CheckCharacterInRange(base::uc16 from,
 }
 
 void RegExpMacroAssemblerS390::CheckCharacterNotInRange(
-    base::uc16 from, base::uc16 to, Label* on_not_in_range) {
+    uc16 from, uc16 to, Label* on_not_in_range) {
   __ lay(r2, MemOperand(current_character(), -from));
   __ CmpU64(r2, Operand(to - from));
   BranchOrBacktrack(gt, on_not_in_range);  // Unsigned higher condition.
@@ -507,7 +504,7 @@ void RegExpMacroAssemblerS390::CheckBitInTable(Handle<ByteArray> table,
   BranchOrBacktrack(ne, on_bit_set);
 }
 
-bool RegExpMacroAssemblerS390::CheckSpecialCharacterClass(base::uc16 type,
+bool RegExpMacroAssemblerS390::CheckSpecialCharacterClass(uc16 type,
                                                           Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check
diff --git a/src/regexp/s390/regexp-macro-assembler-s390.h b/src/regexp/s390/regexp-macro-assembler-s390.h
index 8e8601fc7c..a01d409279 100644
--- a/src/regexp/s390/regexp-macro-assembler-s390.h
+++ b/src/regexp/s390/regexp-macro-assembler-s390.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_S390_REGEXP_MACRO_ASSEMBLER_S390_H_
 #define V8_REGEXP_S390_REGEXP_MACRO_ASSEMBLER_S390_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/s390/assembler-s390.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -28,8 +27,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerS390
   virtual void CheckCharacter(unsigned c, Label* on_equal);
   virtual void CheckCharacterAfterAnd(unsigned c, unsigned mask,
                                       Label* on_equal);
-  virtual void CheckCharacterGT(base::uc16 limit, Label* on_greater);
-  virtual void CheckCharacterLT(base::uc16 limit, Label* on_less);
+  virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
+  virtual void CheckCharacterLT(uc16 limit, Label* on_less);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
@@ -42,19 +41,17 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerS390
   virtual void CheckNotCharacter(unsigned c, Label* on_not_equal);
   virtual void CheckNotCharacterAfterAnd(unsigned c, unsigned mask,
                                          Label* on_not_equal);
-  virtual void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                              base::uc16 mask,
+  virtual void CheckNotCharacterAfterMinusAnd(uc16 c, uc16 minus, uc16 mask,
                                               Label* on_not_equal);
-  virtual void CheckCharacterInRange(base::uc16 from, base::uc16 to,
-                                     Label* on_in_range);
-  virtual void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  virtual void CheckCharacterInRange(uc16 from, uc16 to, Label* on_in_range);
+  virtual void CheckCharacterNotInRange(uc16 from, uc16 to,
                                         Label* on_not_in_range);
   virtual void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set);
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   virtual void CheckPosition(int cp_offset, Label* on_outside_input);
-  virtual bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match);
+  virtual bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match);
   virtual void Fail();
   virtual Handle<HeapObject> GetCode(Handle<String> source);
   virtual void GoTo(Label* label);
diff --git a/src/regexp/x64/regexp-macro-assembler-x64.cc b/src/regexp/x64/regexp-macro-assembler-x64.cc
index 6f0cb53e8f..27c5cb3b97 100644
--- a/src/regexp/x64/regexp-macro-assembler-x64.cc
+++ b/src/regexp/x64/regexp-macro-assembler-x64.cc
@@ -185,8 +185,8 @@ void RegExpMacroAssemblerX64::CheckCharacter(uint32_t c, Label* on_equal) {
   BranchOrBacktrack(equal, on_equal);
 }
 
-void RegExpMacroAssemblerX64::CheckCharacterGT(base::uc16 limit,
-                                               Label* on_greater) {
+
+void RegExpMacroAssemblerX64::CheckCharacterGT(uc16 limit, Label* on_greater) {
   __ cmpl(current_character(), Immediate(limit));
   BranchOrBacktrack(greater, on_greater);
 }
@@ -204,12 +204,13 @@ void RegExpMacroAssemblerX64::CheckNotAtStart(int cp_offset,
   BranchOrBacktrack(not_equal, on_not_at_start);
 }
 
-void RegExpMacroAssemblerX64::CheckCharacterLT(base::uc16 limit,
-                                               Label* on_less) {
+
+void RegExpMacroAssemblerX64::CheckCharacterLT(uc16 limit, Label* on_less) {
   __ cmpl(current_character(), Immediate(limit));
   BranchOrBacktrack(less, on_less);
 }
 
+
 void RegExpMacroAssemblerX64::CheckGreedyLoop(Label* on_equal) {
   Label fallthrough;
   __ cmpl(rdi, Operand(backtrack_stackpointer(), 0));
@@ -496,8 +497,12 @@ void RegExpMacroAssemblerX64::CheckNotCharacterAfterAnd(uint32_t c,
   BranchOrBacktrack(not_equal, on_not_equal);
 }
 
+
 void RegExpMacroAssemblerX64::CheckNotCharacterAfterMinusAnd(
-    base::uc16 c, base::uc16 minus, base::uc16 mask, Label* on_not_equal) {
+    uc16 c,
+    uc16 minus,
+    uc16 mask,
+    Label* on_not_equal) {
   DCHECK_GT(String::kMaxUtf16CodeUnit, minus);
   __ leal(rax, Operand(current_character(), -minus));
   __ andl(rax, Immediate(mask));
@@ -505,22 +510,27 @@ void RegExpMacroAssemblerX64::CheckNotCharacterAfterMinusAnd(
   BranchOrBacktrack(not_equal, on_not_equal);
 }
 
-void RegExpMacroAssemblerX64::CheckCharacterInRange(base::uc16 from,
-                                                    base::uc16 to,
-                                                    Label* on_in_range) {
+
+void RegExpMacroAssemblerX64::CheckCharacterInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_in_range) {
   __ leal(rax, Operand(current_character(), -from));
   __ cmpl(rax, Immediate(to - from));
   BranchOrBacktrack(below_equal, on_in_range);
 }
 
-void RegExpMacroAssemblerX64::CheckCharacterNotInRange(base::uc16 from,
-                                                       base::uc16 to,
-                                                       Label* on_not_in_range) {
+
+void RegExpMacroAssemblerX64::CheckCharacterNotInRange(
+    uc16 from,
+    uc16 to,
+    Label* on_not_in_range) {
   __ leal(rax, Operand(current_character(), -from));
   __ cmpl(rax, Immediate(to - from));
   BranchOrBacktrack(above, on_not_in_range);
 }
 
+
 void RegExpMacroAssemblerX64::CheckBitInTable(
     Handle<ByteArray> table,
     Label* on_bit_set) {
@@ -536,7 +546,8 @@ void RegExpMacroAssemblerX64::CheckBitInTable(
   BranchOrBacktrack(not_equal, on_bit_set);
 }
 
-bool RegExpMacroAssemblerX64::CheckSpecialCharacterClass(base::uc16 type,
+
+bool RegExpMacroAssemblerX64::CheckSpecialCharacterClass(uc16 type,
                                                          Label* on_no_match) {
   // Range checks (c in min..max) are generally implemented by an unsigned
   // (c - min) <= (max - min) check, using the sequence:
@@ -656,6 +667,7 @@ bool RegExpMacroAssemblerX64::CheckSpecialCharacterClass(base::uc16 type,
   }
 }
 
+
 void RegExpMacroAssemblerX64::Fail() {
   STATIC_ASSERT(FAILURE == 0);  // Return value for failure is zero.
   if (!global()) {
@@ -1354,11 +1366,11 @@ void RegExpMacroAssemblerX64::LoadCurrentCharacterUnchecked(int cp_offset,
     DCHECK(mode_ == UC16);
     if (characters == 2) {
       __ movl(current_character(),
-              Operand(rsi, rdi, times_1, cp_offset * sizeof(base::uc16)));
+              Operand(rsi, rdi, times_1, cp_offset * sizeof(uc16)));
     } else {
       DCHECK_EQ(1, characters);
       __ movzxwl(current_character(),
-                 Operand(rsi, rdi, times_1, cp_offset * sizeof(base::uc16)));
+                 Operand(rsi, rdi, times_1, cp_offset * sizeof(uc16)));
     }
   }
 }
diff --git a/src/regexp/x64/regexp-macro-assembler-x64.h b/src/regexp/x64/regexp-macro-assembler-x64.h
index c3a3cb90f2..517a05d939 100644
--- a/src/regexp/x64/regexp-macro-assembler-x64.h
+++ b/src/regexp/x64/regexp-macro-assembler-x64.h
@@ -5,7 +5,6 @@
 #ifndef V8_REGEXP_X64_REGEXP_MACRO_ASSEMBLER_X64_H_
 #define V8_REGEXP_X64_REGEXP_MACRO_ASSEMBLER_X64_H_
 
-#include "src/base/strings.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/x64/assembler-x64.h"
 #include "src/regexp/regexp-macro-assembler.h"
@@ -29,8 +28,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerX64
   void CheckCharacter(uint32_t c, Label* on_equal) override;
   void CheckCharacterAfterAnd(uint32_t c, uint32_t mask,
                               Label* on_equal) override;
-  void CheckCharacterGT(base::uc16 limit, Label* on_greater) override;
-  void CheckCharacterLT(base::uc16 limit, Label* on_less) override;
+  void CheckCharacterGT(uc16 limit, Label* on_greater) override;
+  void CheckCharacterLT(uc16 limit, Label* on_less) override;
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   void CheckGreedyLoop(Label* on_tos_equals_current_position) override;
@@ -43,19 +42,17 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerX64
   void CheckNotCharacter(uint32_t c, Label* on_not_equal) override;
   void CheckNotCharacterAfterAnd(uint32_t c, uint32_t mask,
                                  Label* on_not_equal) override;
-  void CheckNotCharacterAfterMinusAnd(base::uc16 c, base::uc16 minus,
-                                      base::uc16 mask,
+  void CheckNotCharacterAfterMinusAnd(uc16 c, uc16 minus, uc16 mask,
                                       Label* on_not_equal) override;
-  void CheckCharacterInRange(base::uc16 from, base::uc16 to,
-                             Label* on_in_range) override;
-  void CheckCharacterNotInRange(base::uc16 from, base::uc16 to,
+  void CheckCharacterInRange(uc16 from, uc16 to, Label* on_in_range) override;
+  void CheckCharacterNotInRange(uc16 from, uc16 to,
                                 Label* on_not_in_range) override;
   void CheckBitInTable(Handle<ByteArray> table, Label* on_bit_set) override;
 
   // Checks whether the given offset from the current position is before
   // the end of the string.
   void CheckPosition(int cp_offset, Label* on_outside_input) override;
-  bool CheckSpecialCharacterClass(base::uc16 type, Label* on_no_match) override;
+  bool CheckSpecialCharacterClass(uc16 type, Label* on_no_match) override;
   void Fail() override;
   Handle<HeapObject> GetCode(Handle<String> source) override;
   void GoTo(Label* label) override;
diff --git a/src/runtime/runtime-regexp.cc b/src/runtime/runtime-regexp.cc
index 5fc2b2bd23..61a4fb3202 100644
--- a/src/runtime/runtime-regexp.cc
+++ b/src/runtime/runtime-regexp.cc
@@ -5,7 +5,6 @@
 #include <functional>
 
 #include "src/base/small-vector.h"
-#include "src/base/strings.h"
 #include "src/common/message-template.h"
 #include "src/execution/arguments-inl.h"
 #include "src/execution/isolate-inl.h"
@@ -430,14 +429,13 @@ void FindOneByteStringIndices(base::Vector<const uint8_t> subject,
   }
 }
 
-void FindTwoByteStringIndices(const base::Vector<const base::uc16> subject,
-                              base::uc16 pattern, std::vector<int>* indices,
+void FindTwoByteStringIndices(const base::Vector<const uc16> subject,
+                              uc16 pattern, std::vector<int>* indices,
                               unsigned int limit) {
   DCHECK_LT(0, limit);
-  const base::uc16* subject_start = subject.begin();
-  const base::uc16* subject_end = subject_start + subject.length();
-  for (const base::uc16* pos = subject_start; pos < subject_end && limit > 0;
-       pos++) {
+  const uc16* subject_start = subject.begin();
+  const uc16* subject_end = subject_start + subject.length();
+  for (const uc16* pos = subject_start; pos < subject_end && limit > 0; pos++) {
     if (*pos == pattern) {
       indices->push_back(static_cast<int>(pos - subject_start));
       limit--;
@@ -491,8 +489,7 @@ void FindStringIndicesDispatch(Isolate* isolate, String subject, String pattern,
                           pattern_content.ToUC16Vector(), indices, limit);
       }
     } else {
-      base::Vector<const base::uc16> subject_vector =
-          subject_content.ToUC16Vector();
+      base::Vector<const uc16> subject_vector = subject_content.ToUC16Vector();
       if (pattern_content.IsOneByte()) {
         base::Vector<const uint8_t> pattern_vector =
             pattern_content.ToOneByteVector();
@@ -504,7 +501,7 @@ void FindStringIndicesDispatch(Isolate* isolate, String subject, String pattern,
                             limit);
         }
       } else {
-        base::Vector<const base::uc16> pattern_vector =
+        base::Vector<const uc16> pattern_vector =
             pattern_content.ToUC16Vector();
         if (pattern_vector.length() == 1) {
           FindTwoByteStringIndices(subject_vector, pattern_vector[0], indices,
diff --git a/src/runtime/runtime-test.cc b/src/runtime/runtime-test.cc
index f0e7cbb95e..5b150f4d9d 100644
--- a/src/runtime/runtime-test.cc
+++ b/src/runtime/runtime-test.cc
@@ -3,7 +3,6 @@
 // found in the LICENSE file.
 
 #include "src/api/api-inl.h"
-#include "src/base/numbers/double.h"
 #include "src/base/platform/mutex.h"
 #include "src/baseline/baseline-osr-inl.h"
 #include "src/codegen/assembler-inl.h"
@@ -82,7 +81,7 @@ RUNTIME_FUNCTION(Runtime_ConstructDouble) {
   CONVERT_NUMBER_CHECKED(uint32_t, hi, Uint32, args[0]);
   CONVERT_NUMBER_CHECKED(uint32_t, lo, Uint32, args[1]);
   uint64_t result = (static_cast<uint64_t>(hi) << 32) | lo;
-  return *isolate->factory()->NewNumber(base::uint64_to_double(result));
+  return *isolate->factory()->NewNumber(uint64_to_double(result));
 }
 
 RUNTIME_FUNCTION(Runtime_ConstructConsString) {
diff --git a/src/strings/char-predicates-inl.h b/src/strings/char-predicates-inl.h
index 243681bac4..4c43172ff4 100644
--- a/src/strings/char-predicates-inl.h
+++ b/src/strings/char-predicates-inl.h
@@ -15,61 +15,61 @@ namespace internal {
 // If c is in 'A'-'Z' or 'a'-'z', return its lower-case.
 // Else, return something outside of 'A'-'Z' and 'a'-'z'.
 // Note: it ignores LOCALE.
-inline constexpr int AsciiAlphaToLower(base::uc32 c) { return c | 0x20; }
+inline constexpr int AsciiAlphaToLower(uc32 c) { return c | 0x20; }
 
-inline constexpr bool IsCarriageReturn(base::uc32 c) { return c == 0x000D; }
+inline constexpr bool IsCarriageReturn(uc32 c) { return c == 0x000D; }
 
-inline constexpr bool IsLineFeed(base::uc32 c) { return c == 0x000A; }
+inline constexpr bool IsLineFeed(uc32 c) { return c == 0x000A; }
 
-inline constexpr bool IsAsciiIdentifier(base::uc32 c) {
+inline constexpr bool IsAsciiIdentifier(uc32 c) {
   return IsAlphaNumeric(c) || c == '$' || c == '_';
 }
 
-inline constexpr bool IsAlphaNumeric(base::uc32 c) {
+inline constexpr bool IsAlphaNumeric(uc32 c) {
   return base::IsInRange(AsciiAlphaToLower(c), 'a', 'z') || IsDecimalDigit(c);
 }
 
-inline constexpr bool IsDecimalDigit(base::uc32 c) {
+inline constexpr bool IsDecimalDigit(uc32 c) {
   // ECMA-262, 3rd, 7.8.3 (p 16)
   return base::IsInRange(c, '0', '9');
 }
 
-inline constexpr bool IsHexDigit(base::uc32 c) {
+inline constexpr bool IsHexDigit(uc32 c) {
   // ECMA-262, 3rd, 7.6 (p 15)
   return IsDecimalDigit(c) || base::IsInRange(AsciiAlphaToLower(c), 'a', 'f');
 }
 
-inline constexpr bool IsOctalDigit(base::uc32 c) {
+inline constexpr bool IsOctalDigit(uc32 c) {
   // ECMA-262, 6th, 7.8.3
   return base::IsInRange(c, '0', '7');
 }
 
-inline constexpr bool IsNonOctalDecimalDigit(base::uc32 c) {
+inline constexpr bool IsNonOctalDecimalDigit(uc32 c) {
   return base::IsInRange(c, '8', '9');
 }
 
-inline constexpr bool IsBinaryDigit(base::uc32 c) {
+inline constexpr bool IsBinaryDigit(uc32 c) {
   // ECMA-262, 6th, 7.8.3
   return c == '0' || c == '1';
 }
 
-inline constexpr bool IsAsciiLower(base::uc32 c) {
+inline constexpr bool IsAsciiLower(uc32 c) {
   return base::IsInRange(c, 'a', 'z');
 }
 
-inline constexpr bool IsAsciiUpper(base::uc32 c) {
+inline constexpr bool IsAsciiUpper(uc32 c) {
   return base::IsInRange(c, 'A', 'Z');
 }
 
-inline constexpr base::uc32 ToAsciiUpper(base::uc32 c) {
+inline constexpr uc32 ToAsciiUpper(uc32 c) {
   return c & ~(IsAsciiLower(c) << 5);
 }
 
-inline constexpr base::uc32 ToAsciiLower(base::uc32 c) {
+inline constexpr uc32 ToAsciiLower(uc32 c) {
   return c | (IsAsciiUpper(c) << 5);
 }
 
-inline constexpr bool IsRegExpWord(base::uc32 c) {
+inline constexpr bool IsRegExpWord(uc32 c) {
   return IsAlphaNumeric(c) || c == '_';
 }
 
@@ -84,7 +84,7 @@ enum OneByteCharFlags {
 
 // See http://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt
 // ID_Start. Additionally includes '_' and '$'.
-constexpr bool IsOneByteIDStart(base::uc32 c) {
+constexpr bool IsOneByteIDStart(uc32 c) {
   return c == 0x0024 || (c >= 0x0041 && c <= 0x005A) || c == 0x005F ||
          (c >= 0x0061 && c <= 0x007A) || c == 0x00AA || c == 0x00B5 ||
          c == 0x00BA || (c >= 0x00C0 && c <= 0x00D6) ||
@@ -93,7 +93,7 @@ constexpr bool IsOneByteIDStart(base::uc32 c) {
 
 // See http://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt
 // ID_Continue. Additionally includes '_' and '$'.
-constexpr bool IsOneByteIDContinue(base::uc32 c) {
+constexpr bool IsOneByteIDContinue(uc32 c) {
   return c == 0x0024 || (c >= 0x0030 && c <= 0x0039) || c == 0x005F ||
          (c >= 0x0041 && c <= 0x005A) || (c >= 0x0061 && c <= 0x007A) ||
          c == 0x00AA || c == 0x00B5 || c == 0x00B7 || c == 0x00BA ||
@@ -101,11 +101,11 @@ constexpr bool IsOneByteIDContinue(base::uc32 c) {
          (c >= 0x00F8 && c <= 0x00FF);
 }
 
-constexpr bool IsOneByteWhitespace(base::uc32 c) {
+constexpr bool IsOneByteWhitespace(uc32 c) {
   return c == '\t' || c == '\v' || c == '\f' || c == ' ' || c == u'\xa0';
 }
 
-constexpr uint8_t BuildOneByteCharFlags(base::uc32 c) {
+constexpr uint8_t BuildOneByteCharFlags(uc32 c) {
   uint8_t result = 0;
   if (IsOneByteIDStart(c) || c == '\\') result |= kIsIdentifierStart;
   if (IsOneByteIDContinue(c) || c == '\\') result |= kIsIdentifierPart;
@@ -130,28 +130,28 @@ const constexpr uint8_t kOneByteCharFlags[256] = {
 #undef BUILD_CHAR_FLAGS
 };
 
-bool IsIdentifierStart(base::uc32 c) {
+bool IsIdentifierStart(uc32 c) {
   if (!base::IsInRange(c, 0, 255)) return IsIdentifierStartSlow(c);
   DCHECK_EQ(IsIdentifierStartSlow(c),
             static_cast<bool>(kOneByteCharFlags[c] & kIsIdentifierStart));
   return kOneByteCharFlags[c] & kIsIdentifierStart;
 }
 
-bool IsIdentifierPart(base::uc32 c) {
+bool IsIdentifierPart(uc32 c) {
   if (!base::IsInRange(c, 0, 255)) return IsIdentifierPartSlow(c);
   DCHECK_EQ(IsIdentifierPartSlow(c),
             static_cast<bool>(kOneByteCharFlags[c] & kIsIdentifierPart));
   return kOneByteCharFlags[c] & kIsIdentifierPart;
 }
 
-bool IsWhiteSpace(base::uc32 c) {
+bool IsWhiteSpace(uc32 c) {
   if (!base::IsInRange(c, 0, 255)) return IsWhiteSpaceSlow(c);
   DCHECK_EQ(IsWhiteSpaceSlow(c),
             static_cast<bool>(kOneByteCharFlags[c] & kIsWhiteSpace));
   return kOneByteCharFlags[c] & kIsWhiteSpace;
 }
 
-bool IsWhiteSpaceOrLineTerminator(base::uc32 c) {
+bool IsWhiteSpaceOrLineTerminator(uc32 c) {
   if (!base::IsInRange(c, 0, 255)) return IsWhiteSpaceOrLineTerminatorSlow(c);
   DCHECK_EQ(
       IsWhiteSpaceOrLineTerminatorSlow(c),
@@ -159,7 +159,7 @@ bool IsWhiteSpaceOrLineTerminator(base::uc32 c) {
   return kOneByteCharFlags[c] & kIsWhiteSpaceOrLineTerminator;
 }
 
-bool IsLineTerminatorSequence(base::uc32 c, base::uc32 next) {
+bool IsLineTerminatorSequence(uc32 c, uc32 next) {
   if (kOneByteCharFlags[static_cast<uint8_t>(c)] & kMaybeLineEnd) {
     if (c == '\n') return true;
     if (c == '\r') return next != '\n';
diff --git a/src/strings/char-predicates.cc b/src/strings/char-predicates.cc
index 4d0676481c..0133a03517 100644
--- a/src/strings/char-predicates.cc
+++ b/src/strings/char-predicates.cc
@@ -16,7 +16,7 @@ namespace internal {
 
 // ES#sec-names-and-keywords Names and Keywords
 // UnicodeIDStart, '$', '_' and '\'
-bool IsIdentifierStartSlow(base::uc32 c) {
+bool IsIdentifierStartSlow(uc32 c) {
   // cannot use u_isIDStart because it does not work for
   // Other_ID_Start characters.
   return u_hasBinaryProperty(c, UCHAR_ID_START) ||
@@ -25,7 +25,7 @@ bool IsIdentifierStartSlow(base::uc32 c) {
 
 // ES#sec-names-and-keywords Names and Keywords
 // UnicodeIDContinue, '$', '_', '\', ZWJ, and ZWNJ
-bool IsIdentifierPartSlow(base::uc32 c) {
+bool IsIdentifierPartSlow(uc32 c) {
   // Can't use u_isIDPart because it does not work for
   // Other_ID_Continue characters.
   return u_hasBinaryProperty(c, UCHAR_ID_CONTINUE) ||
@@ -35,7 +35,7 @@ bool IsIdentifierPartSlow(base::uc32 c) {
 
 // ES#sec-white-space White Space
 // gC=Zs, U+0009, U+000B, U+000C, U+FEFF
-bool IsWhiteSpaceSlow(base::uc32 c) {
+bool IsWhiteSpaceSlow(uc32 c) {
   return (u_charType(c) == U_SPACE_SEPARATOR) ||
          (c < 0x0D && (c == 0x09 || c == 0x0B || c == 0x0C)) || c == 0xFEFF;
 }
diff --git a/src/strings/char-predicates.h b/src/strings/char-predicates.h
index b23c5ef2a2..1df20e072a 100644
--- a/src/strings/char-predicates.h
+++ b/src/strings/char-predicates.h
@@ -5,7 +5,6 @@
 #ifndef V8_STRINGS_CHAR_PREDICATES_H_
 #define V8_STRINGS_CHAR_PREDICATES_H_
 
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 #include "src/strings/unicode.h"
 
@@ -15,33 +14,33 @@ namespace internal {
 // Unicode character predicates as defined by ECMA-262, 3rd,
 // used for lexical analysis.
 
-inline constexpr int AsciiAlphaToLower(base::uc32 c);
-inline constexpr bool IsCarriageReturn(base::uc32 c);
-inline constexpr bool IsLineFeed(base::uc32 c);
-inline constexpr bool IsAsciiIdentifier(base::uc32 c);
-inline constexpr bool IsAlphaNumeric(base::uc32 c);
-inline constexpr bool IsDecimalDigit(base::uc32 c);
-inline constexpr bool IsHexDigit(base::uc32 c);
-inline constexpr bool IsOctalDigit(base::uc32 c);
-inline constexpr bool IsBinaryDigit(base::uc32 c);
-inline constexpr bool IsRegExpWord(base::uc32 c);
+inline constexpr int AsciiAlphaToLower(uc32 c);
+inline constexpr bool IsCarriageReturn(uc32 c);
+inline constexpr bool IsLineFeed(uc32 c);
+inline constexpr bool IsAsciiIdentifier(uc32 c);
+inline constexpr bool IsAlphaNumeric(uc32 c);
+inline constexpr bool IsDecimalDigit(uc32 c);
+inline constexpr bool IsHexDigit(uc32 c);
+inline constexpr bool IsOctalDigit(uc32 c);
+inline constexpr bool IsBinaryDigit(uc32 c);
+inline constexpr bool IsRegExpWord(uc32 c);
 
-inline constexpr bool IsAsciiLower(base::uc32 ch);
-inline constexpr bool IsAsciiUpper(base::uc32 ch);
+inline constexpr bool IsAsciiLower(uc32 ch);
+inline constexpr bool IsAsciiUpper(uc32 ch);
 
-inline constexpr base::uc32 ToAsciiUpper(base::uc32 ch);
-inline constexpr base::uc32 ToAsciiLower(base::uc32 ch);
+inline constexpr uc32 ToAsciiUpper(uc32 ch);
+inline constexpr uc32 ToAsciiLower(uc32 ch);
 
 // ES#sec-names-and-keywords
 // This includes '_', '$' and '\', and ID_Start according to
 // http://www.unicode.org/reports/tr31/, which consists of categories
 // 'Lu', 'Ll', 'Lt', 'Lm', 'Lo', 'Nl', but excluding properties
 // 'Pattern_Syntax' or 'Pattern_White_Space'.
-inline bool IsIdentifierStart(base::uc32 c);
+inline bool IsIdentifierStart(uc32 c);
 #ifdef V8_INTL_SUPPORT
-V8_EXPORT_PRIVATE bool IsIdentifierStartSlow(base::uc32 c);
+V8_EXPORT_PRIVATE bool IsIdentifierStartSlow(uc32 c);
 #else
-inline bool IsIdentifierStartSlow(base::uc32 c) {
+inline bool IsIdentifierStartSlow(uc32 c) {
   // Non-BMP characters are not supported without I18N.
   return (c <= 0xFFFF) ? unibrow::ID_Start::Is(c) : false;
 }
@@ -52,11 +51,11 @@ inline bool IsIdentifierStartSlow(base::uc32 c) {
 // http://www.unicode.org/reports/tr31/, which consists of ID_Start,
 // the categories 'Mn', 'Mc', 'Nd', 'Pc', but excluding properties
 // 'Pattern_Syntax' or 'Pattern_White_Space'.
-inline bool IsIdentifierPart(base::uc32 c);
+inline bool IsIdentifierPart(uc32 c);
 #ifdef V8_INTL_SUPPORT
-V8_EXPORT_PRIVATE bool IsIdentifierPartSlow(base::uc32 c);
+V8_EXPORT_PRIVATE bool IsIdentifierPartSlow(uc32 c);
 #else
-inline bool IsIdentifierPartSlow(base::uc32 c) {
+inline bool IsIdentifierPartSlow(uc32 c) {
   // Non-BMP charaacters are not supported without I18N.
   if (c <= 0xFFFF) {
     return unibrow::ID_Start::Is(c) || unibrow::ID_Continue::Is(c);
@@ -68,24 +67,22 @@ inline bool IsIdentifierPartSlow(base::uc32 c) {
 // ES6 draft section 11.2
 // This includes all code points of Unicode category 'Zs'.
 // Further included are \u0009, \u000b, \u000c, and \ufeff.
-inline bool IsWhiteSpace(base::uc32 c);
+inline bool IsWhiteSpace(uc32 c);
 #ifdef V8_INTL_SUPPORT
-V8_EXPORT_PRIVATE bool IsWhiteSpaceSlow(base::uc32 c);
+V8_EXPORT_PRIVATE bool IsWhiteSpaceSlow(uc32 c);
 #else
-inline bool IsWhiteSpaceSlow(base::uc32 c) {
-  return unibrow::WhiteSpace::Is(c);
-}
+inline bool IsWhiteSpaceSlow(uc32 c) { return unibrow::WhiteSpace::Is(c); }
 #endif
 
 // WhiteSpace and LineTerminator according to ES6 draft section 11.2 and 11.3
 // This includes all the characters with Unicode category 'Z' (= Zs+Zl+Zp)
 // as well as \u0009 - \u000d and \ufeff.
-inline bool IsWhiteSpaceOrLineTerminator(base::uc32 c);
-inline bool IsWhiteSpaceOrLineTerminatorSlow(base::uc32 c) {
+inline bool IsWhiteSpaceOrLineTerminator(uc32 c);
+inline bool IsWhiteSpaceOrLineTerminatorSlow(uc32 c) {
   return IsWhiteSpaceSlow(c) || unibrow::IsLineTerminator(c);
 }
 
-inline bool IsLineTerminatorSequence(base::uc32 c, base::uc32 next);
+inline bool IsLineTerminatorSequence(uc32 c, uc32 next);
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/strings/string-builder-inl.h b/src/strings/string-builder-inl.h
index e2b8b0b441..d37b96b554 100644
--- a/src/strings/string-builder-inl.h
+++ b/src/strings/string-builder-inl.h
@@ -126,7 +126,7 @@ class IncrementalStringBuilder {
     if (encoding_ == String::ONE_BYTE_ENCODING) {
       Append<uint8_t, uint8_t>(c);
     } else {
-      Append<uint8_t, base::uc16>(c);
+      Append<uint8_t, uc16>(c);
     }
   }
 
@@ -135,15 +135,15 @@ class IncrementalStringBuilder {
     if (encoding_ == String::ONE_BYTE_ENCODING) {
       while (*u != '\0') Append<uint8_t, uint8_t>(*(u++));
     } else {
-      while (*u != '\0') Append<uint8_t, base::uc16>(*(u++));
+      while (*u != '\0') Append<uint8_t, uc16>(*(u++));
     }
   }
 
-  V8_INLINE void AppendCString(const base::uc16* s) {
+  V8_INLINE void AppendCString(const uc16* s) {
     if (encoding_ == String::ONE_BYTE_ENCODING) {
-      while (*s != '\0') Append<base::uc16, uint8_t>(*(s++));
+      while (*s != '\0') Append<uc16, uint8_t>(*(s++));
     } else {
-      while (*s != '\0') Append<base::uc16, base::uc16>(*(s++));
+      while (*s != '\0') Append<uc16, uc16>(*(s++));
     }
   }
 
diff --git a/src/strings/string-builder.cc b/src/strings/string-builder.cc
index 71534d635f..5faf8aff4d 100644
--- a/src/strings/string-builder.cc
+++ b/src/strings/string-builder.cc
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/strings.h"
+#include "src/strings/string-builder-inl.h"
+
 #include "src/execution/isolate-inl.h"
 #include "src/objects/fixed-array-inl.h"
 #include "src/objects/js-array-inl.h"
-#include "src/strings/string-builder-inl.h"
 
 namespace v8 {
 namespace internal {
@@ -49,10 +49,9 @@ template void StringBuilderConcatHelper<uint8_t>(String special, uint8_t* sink,
                                                  FixedArray fixed_array,
                                                  int array_length);
 
-template void StringBuilderConcatHelper<base::uc16>(String special,
-                                                    base::uc16* sink,
-                                                    FixedArray fixed_array,
-                                                    int array_length);
+template void StringBuilderConcatHelper<uc16>(String special, uc16* sink,
+                                              FixedArray fixed_array,
+                                              int array_length);
 
 int StringBuilderConcatLength(int special_length, FixedArray fixed_array,
                               int array_length, bool* one_byte) {
@@ -214,7 +213,7 @@ MaybeHandle<String> ReplacementStringBuilder::ToString() {
         String);
 
     DisallowGarbageCollection no_gc;
-    base::uc16* char_buffer = seq->GetChars(no_gc);
+    uc16* char_buffer = seq->GetChars(no_gc);
     StringBuilderConcatHelper(*subject_, char_buffer, *array_builder_.array(),
                               array_builder_.length());
     joined_string = Handle<String>::cast(seq);
diff --git a/src/strings/string-search.h b/src/strings/string-search.h
index 529501dd31..f922489d23 100644
--- a/src/strings/string-search.h
+++ b/src/strings/string-search.h
@@ -5,7 +5,6 @@
 #ifndef V8_STRINGS_STRING_SEARCH_H_
 #define V8_STRINGS_STRING_SEARCH_H_
 
-#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/execution/isolate.h"
 
@@ -45,7 +44,7 @@ class StringSearchBase {
     return true;
   }
 
-  static inline bool IsOneByteString(base::Vector<const base::uc16> string) {
+  static inline bool IsOneByteString(base::Vector<const uc16> string) {
     return String::IsOneByte(string.begin(), string.length());
   }
 
@@ -142,8 +141,7 @@ class StringSearch : private StringSearchBase {
       }
       return bad_char_occurrence[static_cast<unsigned int>(char_code)];
     }
-    // Both pattern and subject are UC16. Reduce character to equivalence
-    // class.
+    // Both pattern and subject are UC16. Reduce character to equivalence class.
     int equiv_class = char_code % kUC16AlphabetSize;
     return bad_char_occurrence[equiv_class];
   }
@@ -187,7 +185,7 @@ inline T AlignDown(T value, U alignment) {
       (reinterpret_cast<uintptr_t>(value) & ~(alignment - 1)));
 }
 
-inline uint8_t GetHighestValueByte(base::uc16 character) {
+inline uint8_t GetHighestValueByte(uc16 character) {
   return std::max(static_cast<uint8_t>(character & 0xFF),
                   static_cast<uint8_t>(character >> 8));
 }
diff --git a/src/strings/string-stream.cc b/src/strings/string-stream.cc
index 67e361963d..44af1ddcfe 100644
--- a/src/strings/string-stream.cc
+++ b/src/strings/string-stream.cc
@@ -120,7 +120,7 @@ void StringStream::Add(base::Vector<const char> format,
       }
       case 'w': {
         DCHECK_EQ(FmtElm::LC_STR, current.type_);
-        base::Vector<const base::uc16> value = *current.data_.u_lc_str_;
+        base::Vector<const uc16> value = *current.data_.u_lc_str_;
         for (int i = 0; i < value.length(); i++)
           Put(static_cast<char>(value[i]));
         break;
diff --git a/src/strings/string-stream.h b/src/strings/string-stream.h
index 65fab8be1c..9a470267bf 100644
--- a/src/strings/string-stream.h
+++ b/src/strings/string-stream.h
@@ -8,7 +8,6 @@
 #include <memory>
 
 #include "src/base/small-vector.h"
-#include "src/base/strings.h"
 #include "src/base/vector.h"
 #include "src/handles/handles.h"
 #include "src/objects/heap-object.h"
@@ -99,8 +98,7 @@ class StringStream final {
     FmtElm(const char* value) : FmtElm(C_STR) {  // NOLINT
       data_.u_c_str_ = value;
     }
-    FmtElm(const base::Vector<const base::uc16>& value)  // NOLINT
-        : FmtElm(LC_STR) {
+    FmtElm(const base::Vector<const uc16>& value) : FmtElm(LC_STR) {  // NOLINT
       data_.u_lc_str_ = &value;
     }
     FmtElm(Object value) : FmtElm(OBJ) {  // NOLINT
@@ -128,7 +126,7 @@ class StringStream final {
       int u_int_;
       double u_double_;
       const char* u_c_str_;
-      const base::Vector<const base::uc16>* u_lc_str_;
+      const base::Vector<const uc16>* u_lc_str_;
       Address u_obj_;
       Address* u_handle_;
       void* u_pointer_;
diff --git a/src/strings/uri.cc b/src/strings/uri.cc
index 460ca586b9..befecc308b 100644
--- a/src/strings/uri.cc
+++ b/src/strings/uri.cc
@@ -15,7 +15,7 @@ namespace v8 {
 namespace internal {
 
 namespace {  // anonymous namespace for DecodeURI helper functions
-bool IsReservedPredicate(base::uc16 c) {
+bool IsReservedPredicate(uc16 c) {
   switch (c) {
     case '#':
     case '$':
@@ -45,16 +45,15 @@ bool IsReplacementCharacter(const uint8_t* octets, int length) {
 }
 
 bool DecodeOctets(const uint8_t* octets, int length,
-                  std::vector<base::uc16>* buffer) {
+                  std::vector<uc16>* buffer) {
   size_t cursor = 0;
-  base::uc32 value = unibrow::Utf8::ValueOf(octets, length, &cursor);
+  uc32 value = unibrow::Utf8::ValueOf(octets, length, &cursor);
   if (value == unibrow::Utf8::kBadChar &&
       !IsReplacementCharacter(octets, length)) {
     return false;
   }
 
-  if (value <=
-      static_cast<base::uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
+  if (value <= static_cast<uc32>(unibrow::Utf16::kMaxNonSurrogateCharCode)) {
     buffer->push_back(value);
   } else {
     buffer->push_back(unibrow::Utf16::LeadSurrogate(value));
@@ -63,23 +62,23 @@ bool DecodeOctets(const uint8_t* octets, int length,
   return true;
 }
 
-int TwoDigitHex(base::uc16 character1, base::uc16 character2) {
+int TwoDigitHex(uc16 character1, uc16 character2) {
   if (character1 > 'f') return -1;
-  int high = base::HexValue(character1);
+  int high = HexValue(character1);
   if (high == -1) return -1;
   if (character2 > 'f') return -1;
-  int low = base::HexValue(character2);
+  int low = HexValue(character2);
   if (low == -1) return -1;
   return (high << 4) + low;
 }
 
 template <typename T>
-void AddToBuffer(base::uc16 decoded, String::FlatContent* uri_content,
-                 int index, bool is_uri, std::vector<T>* buffer) {
+void AddToBuffer(uc16 decoded, String::FlatContent* uri_content, int index,
+                 bool is_uri, std::vector<T>* buffer) {
   if (is_uri && IsReservedPredicate(decoded)) {
     buffer->push_back('%');
-    base::uc16 first = uri_content->Get(index + 1);
-    base::uc16 second = uri_content->Get(index + 2);
+    uc16 first = uri_content->Get(index + 1);
+    uc16 second = uri_content->Get(index + 2);
     DCHECK_GT(std::numeric_limits<T>::max(), first);
     DCHECK_GT(std::numeric_limits<T>::max(), second);
 
@@ -91,10 +90,9 @@ void AddToBuffer(base::uc16 decoded, String::FlatContent* uri_content,
 }
 
 bool IntoTwoByte(int index, bool is_uri, int uri_length,
-                 String::FlatContent* uri_content,
-                 std::vector<base::uc16>* buffer) {
+                 String::FlatContent* uri_content, std::vector<uc16>* buffer) {
   for (int k = index; k < uri_length; k++) {
-    base::uc16 code = uri_content->Get(k);
+    uc16 code = uri_content->Get(k);
     if (code == '%') {
       int two_digits;
       if (k + 2 >= uri_length ||
@@ -103,7 +101,7 @@ bool IntoTwoByte(int index, bool is_uri, int uri_length,
         return false;
       }
       k += 2;
-      base::uc16 decoded = static_cast<base::uc16>(two_digits);
+      uc16 decoded = static_cast<uc16>(two_digits);
       if (decoded > unibrow::Utf8::kMaxOneByteChar) {
         uint8_t octets[unibrow::Utf8::kMaxEncodedSize];
         octets[0] = decoded;
@@ -119,7 +117,7 @@ bool IntoTwoByte(int index, bool is_uri, int uri_length,
             return false;
           }
           k += 2;
-          base::uc16 continuation_byte = static_cast<base::uc16>(two_digits);
+          uc16 continuation_byte = static_cast<uc16>(two_digits);
           octets[number_of_continuation_bytes] = continuation_byte;
         }
 
@@ -138,13 +136,13 @@ bool IntoTwoByte(int index, bool is_uri, int uri_length,
 
 bool IntoOneAndTwoByte(Handle<String> uri, bool is_uri,
                        std::vector<uint8_t>* one_byte_buffer,
-                       std::vector<base::uc16>* two_byte_buffer) {
+                       std::vector<uc16>* two_byte_buffer) {
   DisallowGarbageCollection no_gc;
   String::FlatContent uri_content = uri->GetFlatContent(no_gc);
 
   int uri_length = uri->length();
   for (int k = 0; k < uri_length; k++) {
-    base::uc16 code = uri_content.Get(k);
+    uc16 code = uri_content.Get(k);
     if (code == '%') {
       int two_digits;
       if (k + 2 >= uri_length ||
@@ -153,7 +151,7 @@ bool IntoOneAndTwoByte(Handle<String> uri, bool is_uri,
         return false;
       }
 
-      base::uc16 decoded = static_cast<base::uc16>(two_digits);
+      uc16 decoded = static_cast<uc16>(two_digits);
       if (decoded > unibrow::Utf8::kMaxOneByteChar) {
         return IntoTwoByte(k, is_uri, uri_length, &uri_content,
                            two_byte_buffer);
@@ -178,7 +176,7 @@ MaybeHandle<String> Uri::Decode(Isolate* isolate, Handle<String> uri,
                                 bool is_uri) {
   uri = String::Flatten(isolate, uri);
   std::vector<uint8_t> one_byte_buffer;
-  std::vector<base::uc16> two_byte_buffer;
+  std::vector<uc16> two_byte_buffer;
 
   if (!IntoOneAndTwoByte(uri, is_uri, &one_byte_buffer, &two_byte_buffer)) {
     THROW_NEW_ERROR(isolate, NewURIError(), String);
@@ -197,7 +195,7 @@ MaybeHandle<String> Uri::Decode(Isolate* isolate, Handle<String> uri,
       String);
 
   DisallowGarbageCollection no_gc;
-  base::uc16* chars = result->GetChars(no_gc);
+  uc16* chars = result->GetChars(no_gc);
   if (!one_byte_buffer.empty()) {
     CopyChars(chars, one_byte_buffer.data(), one_byte_buffer.size());
     chars += one_byte_buffer.size();
@@ -210,7 +208,7 @@ MaybeHandle<String> Uri::Decode(Isolate* isolate, Handle<String> uri,
 }
 
 namespace {  // anonymous namespace for EncodeURI helper functions
-bool IsUnescapePredicateInUriComponent(base::uc16 c) {
+bool IsUnescapePredicateInUriComponent(uc16 c) {
   if (IsAlphaNumeric(c)) {
     return true;
   }
@@ -231,7 +229,7 @@ bool IsUnescapePredicateInUriComponent(base::uc16 c) {
   }
 }
 
-bool IsUriSeparator(base::uc16 c) {
+bool IsUriSeparator(uc16 c) {
   switch (c) {
     case '#':
     case ':':
@@ -252,11 +250,11 @@ bool IsUriSeparator(base::uc16 c) {
 
 void AddEncodedOctetToBuffer(uint8_t octet, std::vector<uint8_t>* buffer) {
   buffer->push_back('%');
-  buffer->push_back(base::HexCharOfValue(octet >> 4));
-  buffer->push_back(base::HexCharOfValue(octet & 0x0F));
+  buffer->push_back(HexCharOfValue(octet >> 4));
+  buffer->push_back(HexCharOfValue(octet & 0x0F));
 }
 
-void EncodeSingle(base::uc16 c, std::vector<uint8_t>* buffer) {
+void EncodeSingle(uc16 c, std::vector<uint8_t>* buffer) {
   char s[4] = {};
   int number_of_bytes;
   number_of_bytes =
@@ -266,7 +264,7 @@ void EncodeSingle(base::uc16 c, std::vector<uint8_t>* buffer) {
   }
 }
 
-void EncodePair(base::uc16 cc1, base::uc16 cc2, std::vector<uint8_t>* buffer) {
+void EncodePair(uc16 cc1, uc16 cc2, std::vector<uint8_t>* buffer) {
   char s[4] = {};
   int number_of_bytes =
       unibrow::Utf8::Encode(s, unibrow::Utf16::CombineSurrogatePair(cc1, cc2),
@@ -290,11 +288,11 @@ MaybeHandle<String> Uri::Encode(Isolate* isolate, Handle<String> uri,
     String::FlatContent uri_content = uri->GetFlatContent(no_gc);
 
     for (int k = 0; k < uri_length; k++) {
-      base::uc16 cc1 = uri_content.Get(k);
+      uc16 cc1 = uri_content.Get(k);
       if (unibrow::Utf16::IsLeadSurrogate(cc1)) {
         k++;
         if (k < uri_length) {
-          base::uc16 cc2 = uri->Get(k);
+          uc16 cc2 = uri->Get(k);
           if (unibrow::Utf16::IsTrailSurrogate(cc2)) {
             EncodePair(cc1, cc2, &buffer);
             continue;
@@ -473,24 +471,20 @@ static MaybeHandle<String> EscapePrivate(Isolate* isolate,
       if (c >= 256) {
         dest->SeqOneByteStringSet(dest_position, '%');
         dest->SeqOneByteStringSet(dest_position + 1, 'u');
-        dest->SeqOneByteStringSet(dest_position + 2,
-                                  base::HexCharOfValue(c >> 12));
+        dest->SeqOneByteStringSet(dest_position + 2, HexCharOfValue(c >> 12));
         dest->SeqOneByteStringSet(dest_position + 3,
-                                  base::HexCharOfValue((c >> 8) & 0xF));
+                                  HexCharOfValue((c >> 8) & 0xF));
         dest->SeqOneByteStringSet(dest_position + 4,
-                                  base::HexCharOfValue((c >> 4) & 0xF));
-        dest->SeqOneByteStringSet(dest_position + 5,
-                                  base::HexCharOfValue(c & 0xF));
+                                  HexCharOfValue((c >> 4) & 0xF));
+        dest->SeqOneByteStringSet(dest_position + 5, HexCharOfValue(c & 0xF));
         dest_position += 6;
       } else if (IsNotEscaped(c)) {
         dest->SeqOneByteStringSet(dest_position, c);
         dest_position++;
       } else {
         dest->SeqOneByteStringSet(dest_position, '%');
-        dest->SeqOneByteStringSet(dest_position + 1,
-                                  base::HexCharOfValue(c >> 4));
-        dest->SeqOneByteStringSet(dest_position + 2,
-                                  base::HexCharOfValue(c & 0xF));
+        dest->SeqOneByteStringSet(dest_position + 1, HexCharOfValue(c >> 4));
+        dest->SeqOneByteStringSet(dest_position + 2, HexCharOfValue(c & 0xF));
         dest_position += 3;
       }
     }
@@ -506,7 +500,7 @@ MaybeHandle<String> Uri::Escape(Isolate* isolate, Handle<String> string) {
   string = String::Flatten(isolate, string);
   return String::IsOneByteRepresentationUnderneath(*string)
              ? EscapePrivate<uint8_t>(isolate, string)
-             : EscapePrivate<base::uc16>(isolate, string);
+             : EscapePrivate<uc16>(isolate, string);
 }
 
 MaybeHandle<String> Uri::Unescape(Isolate* isolate, Handle<String> string) {
@@ -514,7 +508,7 @@ MaybeHandle<String> Uri::Unescape(Isolate* isolate, Handle<String> string) {
   string = String::Flatten(isolate, string);
   return String::IsOneByteRepresentationUnderneath(*string)
              ? UnescapePrivate<uint8_t>(isolate, string)
-             : UnescapePrivate<base::uc16>(isolate, string);
+             : UnescapePrivate<uc16>(isolate, string);
 }
 
 }  // namespace internal
diff --git a/src/utils/ostreams.h b/src/utils/ostreams.h
index 01966869af..2dfedb5fd9 100644
--- a/src/utils/ostreams.h
+++ b/src/utils/ostreams.h
@@ -14,7 +14,6 @@
 #include "include/v8config.h"
 #include "src/base/macros.h"
 #include "src/base/platform/mutex.h"
-#include "src/base/strings.h"
 #include "src/common/globals.h"
 
 namespace v8 {
@@ -99,7 +98,7 @@ class StdoutStream : public OFStream {
 };
 #endif
 
-// Wrappers to disambiguate uint16_t and base::uc16.
+// Wrappers to disambiguate uint16_t and uc16.
 struct AsUC16 {
   explicit AsUC16(uint16_t v) : value(v) {}
   uint16_t value;
diff --git a/src/utils/utils.h b/src/utils/utils.h
index 5238062e05..d19551def2 100644
--- a/src/utils/utils.h
+++ b/src/utils/utils.h
@@ -38,6 +38,22 @@ namespace internal {
 // ----------------------------------------------------------------------------
 // General helper functions
 
+// Returns the value (0 .. 15) of a hexadecimal character c.
+// If c is not a legal hexadecimal character, returns a value < 0.
+inline int HexValue(uc32 c) {
+  c -= '0';
+  if (static_cast<unsigned>(c) <= 9) return c;
+  c = (c | 0x20) - ('a' - '0');  // detect 0x11..0x16 and 0x31..0x36.
+  if (static_cast<unsigned>(c) <= 5) return c + 10;
+  return -1;
+}
+
+inline char HexCharOfValue(int value) {
+  DCHECK(0 <= value && value <= 16);
+  if (value < 10) return value + '0';
+  return value - 10 + 'A';
+}
+
 template <typename T>
 static T ArithmeticShiftRight(T x, int shift) {
   DCHECK_LE(0, shift);
diff --git a/src/wasm/baseline/arm/liftoff-assembler-arm.h b/src/wasm/baseline/arm/liftoff-assembler-arm.h
index 7f0b784b65..6fc741d442 100644
--- a/src/wasm/baseline/arm/liftoff-assembler-arm.h
+++ b/src/wasm/baseline/arm/liftoff-assembler-arm.h
@@ -566,8 +566,7 @@ void LiftoffAssembler::LoadConstant(LiftoffRegister reg, WasmValue value,
       break;
     case kF64: {
       Register extra_scratch = GetUnusedRegister(kGpReg, {}).gp();
-      vmov(reg.fp(), base::Double(value.to_f64_boxed().get_bits()),
-           extra_scratch);
+      vmov(reg.fp(), Double(value.to_f64_boxed().get_bits()), extra_scratch);
       break;
     }
     default:
@@ -2033,11 +2032,11 @@ bool LiftoffAssembler::emit_type_conversion(WasmOpcode opcode,
       vmov(dst.gp(), scratch_f);
       // Check underflow and NaN.
       DwVfpRegister scratch_d = temps.AcquireD();
-      vmov(scratch_d, base::Double(static_cast<double>(INT32_MIN - 1.0)));
+      vmov(scratch_d, Double(static_cast<double>(INT32_MIN - 1.0)));
       VFPCompareAndSetFlags(src.fp(), scratch_d);
       b(trap, le);
       // Check overflow.
-      vmov(scratch_d, base::Double(static_cast<double>(INT32_MAX + 1.0)));
+      vmov(scratch_d, Double(static_cast<double>(INT32_MAX + 1.0)));
       VFPCompareAndSetFlags(src.fp(), scratch_d);
       b(trap, ge);
       return true;
@@ -2049,11 +2048,11 @@ bool LiftoffAssembler::emit_type_conversion(WasmOpcode opcode,
       vmov(dst.gp(), scratch_f);
       // Check underflow and NaN.
       DwVfpRegister scratch_d = temps.AcquireD();
-      vmov(scratch_d, base::Double(static_cast<double>(-1.0)));
+      vmov(scratch_d, Double(static_cast<double>(-1.0)));
       VFPCompareAndSetFlags(src.fp(), scratch_d);
       b(trap, le);
       // Check overflow.
-      vmov(scratch_d, base::Double(static_cast<double>(UINT32_MAX + 1.0)));
+      vmov(scratch_d, Double(static_cast<double>(UINT32_MAX + 1.0)));
       VFPCompareAndSetFlags(src.fp(), scratch_d);
       b(trap, ge);
       return true;
@@ -3042,8 +3041,8 @@ void LiftoffAssembler::emit_i32x4_bitmask(LiftoffRegister dst,
   vshr(NeonS32, tmp, liftoff::GetSimd128Register(src), 31);
   // Set i-th bit of each lane i. When AND with tmp, the lanes that
   // are signed will have i-th bit set, unsigned will be 0.
-  vmov(mask.low(), base::Double((uint64_t)0x0000'0002'0000'0001));
-  vmov(mask.high(), base::Double((uint64_t)0x0000'0008'0000'0004));
+  vmov(mask.low(), Double((uint64_t)0x0000'0002'0000'0001));
+  vmov(mask.high(), Double((uint64_t)0x0000'0008'0000'0004));
   vand(tmp, mask, tmp);
   vpadd(Neon32, tmp.low(), tmp.low(), tmp.high());
   vpadd(Neon32, tmp.low(), tmp.low(), kDoubleRegZero);
@@ -3227,8 +3226,8 @@ void LiftoffAssembler::emit_i16x8_bitmask(LiftoffRegister dst,
   vshr(NeonS16, tmp, liftoff::GetSimd128Register(src), 15);
   // Set i-th bit of each lane i. When AND with tmp, the lanes that
   // are signed will have i-th bit set, unsigned will be 0.
-  vmov(mask.low(), base::Double((uint64_t)0x0008'0004'0002'0001));
-  vmov(mask.high(), base::Double((uint64_t)0x0080'0040'0020'0010));
+  vmov(mask.low(), Double((uint64_t)0x0008'0004'0002'0001));
+  vmov(mask.high(), Double((uint64_t)0x0080'0040'0020'0010));
   vand(tmp, mask, tmp);
   vpadd(Neon16, tmp.low(), tmp.low(), tmp.high());
   vpadd(Neon16, tmp.low(), tmp.low(), tmp.low());
@@ -3537,8 +3536,8 @@ void LiftoffAssembler::emit_i8x16_bitmask(LiftoffRegister dst,
   vshr(NeonS8, tmp, liftoff::GetSimd128Register(src), 7);
   // Set i-th bit of each lane i. When AND with tmp, the lanes that
   // are signed will have i-th bit set, unsigned will be 0.
-  vmov(mask.low(), base::Double((uint64_t)0x8040'2010'0804'0201));
-  vmov(mask.high(), base::Double((uint64_t)0x8040'2010'0804'0201));
+  vmov(mask.low(), Double((uint64_t)0x8040'2010'0804'0201));
+  vmov(mask.high(), Double((uint64_t)0x8040'2010'0804'0201));
   vand(tmp, mask, tmp);
   vext(mask, tmp, tmp, 8);
   vzip(Neon8, mask, tmp);
@@ -3833,8 +3832,8 @@ void LiftoffAssembler::emit_s128_const(LiftoffRegister dst,
                                        const uint8_t imms[16]) {
   uint64_t vals[2];
   memcpy(vals, imms, sizeof(vals));
-  vmov(dst.low_fp(), base::Double(vals[0]));
-  vmov(dst.high_fp(), base::Double(vals[1]));
+  vmov(dst.low_fp(), Double(vals[0]));
+  vmov(dst.high_fp(), Double(vals[1]));
 }
 
 void LiftoffAssembler::emit_s128_not(LiftoffRegister dst, LiftoffRegister src) {
diff --git a/test/cctest/gay-fixed.cc b/test/cctest/gay-fixed.cc
index 38e9f4b2e5..fb10779611 100644
--- a/test/cctest/gay-fixed.cc
+++ b/test/cctest/gay-fixed.cc
@@ -34,7 +34,7 @@
 #include "test/cctest/gay-fixed.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 static const PrecomputedFixed kFixedTestNumbers[] = {
   {3.3831671815188012695312500e+12, 2, "33831671815188", 13},
@@ -100039,10 +100039,11 @@ static const PrecomputedFixed kFixedTestNumbers[] = {
   {1.8209753351049137115478516e+09, 16, "18209753351049137115478516", 10}
 };
 
-Vector<const PrecomputedFixed> PrecomputedFixedRepresentations() {
+base::Vector<const PrecomputedFixed> PrecomputedFixedRepresentations() {
   int number_elements = sizeof(kFixedTestNumbers) / sizeof(PrecomputedFixed);
-  return Vector<const PrecomputedFixed>(kFixedTestNumbers, number_elements);
+  return base::Vector<const PrecomputedFixed>(kFixedTestNumbers,
+                                              number_elements);
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/gay-fixed.h b/test/cctest/gay-fixed.h
index 6c231e1883..63278f85c0 100644
--- a/test/cctest/gay-fixed.h
+++ b/test/cctest/gay-fixed.h
@@ -31,7 +31,7 @@
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 struct PrecomputedFixed {
   double v;
@@ -42,9 +42,9 @@ struct PrecomputedFixed {
 
 // Returns precomputed values of dtoa. The strings have been generated using
 // Gay's dtoa in mode "fixed".
-Vector<const PrecomputedFixed> PrecomputedFixedRepresentations();
+base::Vector<const PrecomputedFixed> PrecomputedFixedRepresentations();
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
 #endif  // GAY_FIXED_H_
diff --git a/test/cctest/gay-precision.cc b/test/cctest/gay-precision.cc
index 3daf41833b..4030963135 100644
--- a/test/cctest/gay-precision.cc
+++ b/test/cctest/gay-precision.cc
@@ -34,7 +34,7 @@
 #include "test/cctest/gay-precision.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 static const PrecomputedPrecision kPrecisionTestNumbers[] = {
   {2.3024669636324308799278094e-83, 2, "23", -82},
@@ -100039,12 +100039,12 @@ static const PrecomputedPrecision kPrecisionTestNumbers[] = {
   {5.9485998555293638609297584e+88, 2, "59", 89},
 };
 
-Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations() {
+base::Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations() {
   int number_elements =
       sizeof(kPrecisionTestNumbers) / sizeof(PrecomputedPrecision);
-  return Vector<const PrecomputedPrecision>(kPrecisionTestNumbers,
-                                            number_elements);
+  return base::Vector<const PrecomputedPrecision>(kPrecisionTestNumbers,
+                                                  number_elements);
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/gay-precision.h b/test/cctest/gay-precision.h
index 5afc6e4524..5115e3c0b0 100644
--- a/test/cctest/gay-precision.h
+++ b/test/cctest/gay-precision.h
@@ -31,7 +31,7 @@
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 struct PrecomputedPrecision {
   double v;
@@ -42,9 +42,9 @@ struct PrecomputedPrecision {
 
 // Returns precomputed values of dtoa. The strings have been generated using
 // Gay's dtoa in mode "precision".
-Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations();
+base::Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations();
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
 #endif  // GAY_PRECISION_H_
diff --git a/test/cctest/gay-shortest.cc b/test/cctest/gay-shortest.cc
index fb01727414..d6010498dd 100644
--- a/test/cctest/gay-shortest.cc
+++ b/test/cctest/gay-shortest.cc
@@ -34,7 +34,7 @@
 #include "test/cctest/gay-shortest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 static const PrecomputedShortest kShortestTestNumbers[] = {
   {1.3252057186783201350530603e-106, "13252057186783201", -105},
@@ -100039,12 +100039,12 @@ static const PrecomputedShortest kShortestTestNumbers[] = {
   {8.1205022656023800444116331e-271, "812050226560238", -270}
 };
 
-Vector<const PrecomputedShortest> PrecomputedShortestRepresentations() {
+base::Vector<const PrecomputedShortest> PrecomputedShortestRepresentations() {
   int number_elements =
       sizeof(kShortestTestNumbers) / sizeof(PrecomputedShortest);
-  return Vector<const PrecomputedShortest>(kShortestTestNumbers,
-                                           number_elements);
+  return base::Vector<const PrecomputedShortest>(kShortestTestNumbers,
+                                                 number_elements);
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/gay-shortest.h b/test/cctest/gay-shortest.h
index 247b5a3221..730e7e0ad0 100644
--- a/test/cctest/gay-shortest.h
+++ b/test/cctest/gay-shortest.h
@@ -31,7 +31,7 @@
 #include "src/base/vector.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 struct PrecomputedShortest {
   double v;
@@ -41,7 +41,7 @@ struct PrecomputedShortest {
 
 base::Vector<const PrecomputedShortest> PrecomputedShortestRepresentations();
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
 
 #endif  // GAY_SHORTEST_H_
diff --git a/test/cctest/parsing/test-scanner-streams.cc b/test/cctest/parsing/test-scanner-streams.cc
index c2f462a27a..4e3469e93f 100644
--- a/test/cctest/parsing/test-scanner-streams.cc
+++ b/test/cctest/parsing/test-scanner-streams.cc
@@ -2,7 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/base/strings.h"
 #include "src/heap/factory-inl.h"
 #include "src/objects/objects-inl.h"
 #include "src/parsing/scanner-character-streams.h"
@@ -161,7 +160,7 @@ TEST(Utf8StreamAsciiOnly) {
           &chunk_source, v8::ScriptCompiler::StreamedSource::UTF8));
 
   // Read the data without dying.
-  v8::base::uc32 c;
+  v8::internal::uc32 c;
   do {
     c = stream->Advance();
   } while (c != v8::internal::Utf16CharacterStream::kEndOfInput);
@@ -492,12 +491,12 @@ void TestCharacterStreams(const char* one_byte_source, unsigned length,
   i::Factory* factory = isolate->factory();
 
   // 2-byte external string
-  std::unique_ptr<v8::base::uc16[]> uc16_buffer(new v8::base::uc16[length]);
-  v8::base::Vector<const v8::base::uc16> two_byte_vector(
-      uc16_buffer.get(), static_cast<int>(length));
+  std::unique_ptr<i::uc16[]> uc16_buffer(new i::uc16[length]);
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(),
+                                                  static_cast<int>(length));
   {
     for (unsigned i = 0; i < length; i++) {
-      uc16_buffer[i] = static_cast<v8::base::uc16>(one_byte_source[i]);
+      uc16_buffer[i] = static_cast<i::uc16>(one_byte_source[i]);
     }
     TestExternalResource resource(uc16_buffer.get(), length);
     i::Handle<i::String> uc16_string(
@@ -756,12 +755,11 @@ TEST(RelocatingCharacterStream) {
 
   const char* string = "abcd";
   int length = static_cast<int>(strlen(string));
-  std::unique_ptr<v8::base::uc16[]> uc16_buffer(new v8::base::uc16[length]);
+  std::unique_ptr<i::uc16[]> uc16_buffer(new i::uc16[length]);
   for (int i = 0; i < length; i++) {
     uc16_buffer[i] = string[i];
   }
-  v8::base::Vector<const v8::base::uc16> two_byte_vector(uc16_buffer.get(),
-                                                         length);
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(), length);
   i::Handle<i::String> two_byte_string =
       i_isolate->factory()
           ->NewStringFromTwoByte(two_byte_vector, i::AllocationType::kYoung)
@@ -790,12 +788,11 @@ TEST(RelocatingUnbufferedCharacterStream) {
 
   const char16_t* string = u"abc\u2603";
   int length = static_cast<int>(std::char_traits<char16_t>::length(string));
-  std::unique_ptr<v8::base::uc16[]> uc16_buffer(new v8::base::uc16[length]);
+  std::unique_ptr<i::uc16[]> uc16_buffer(new i::uc16[length]);
   for (int i = 0; i < length; i++) {
     uc16_buffer[i] = string[i];
   }
-  v8::base::Vector<const v8::base::uc16> two_byte_vector(uc16_buffer.get(),
-                                                         length);
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(), length);
   i::Handle<i::String> two_byte_string =
       i_isolate->factory()
           ->NewStringFromTwoByte(two_byte_vector, i::AllocationType::kYoung)
@@ -834,12 +831,12 @@ TEST(CloneCharacterStreams) {
   // Check that cloning a character stream does not update
 
   // 2-byte external string
-  std::unique_ptr<v8::base::uc16[]> uc16_buffer(new v8::base::uc16[length]);
-  v8::base::Vector<const v8::base::uc16> two_byte_vector(
-      uc16_buffer.get(), static_cast<int>(length));
+  std::unique_ptr<i::uc16[]> uc16_buffer(new i::uc16[length]);
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(),
+                                                  static_cast<int>(length));
   {
     for (unsigned i = 0; i < length; i++) {
-      uc16_buffer[i] = static_cast<v8::base::uc16>(one_byte_source[i]);
+      uc16_buffer[i] = static_cast<i::uc16>(one_byte_source[i]);
     }
     TestExternalResource resource(uc16_buffer.get(), length);
     i::Handle<i::String> uc16_string(
diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
index eefc6df86f..11f623a9ee 100644
--- a/test/cctest/test-api.cc
+++ b/test/cctest/test-api.cc
@@ -42,7 +42,6 @@
 #include "src/api/api-inl.h"
 #include "src/base/overflowing-math.h"
 #include "src/base/platform/platform.h"
-#include "src/base/strings.h"
 #include "src/codegen/compilation-cache.h"
 #include "src/debug/debug.h"
 #include "src/execution/arguments.h"
@@ -14754,15 +14753,15 @@ class OneByteVectorResource : public v8::String::ExternalOneByteStringResource {
 
 class UC16VectorResource : public v8::String::ExternalStringResource {
  public:
-  explicit UC16VectorResource(v8::base::Vector<const v8::base::uc16> vector)
+  explicit UC16VectorResource(v8::base::Vector<const i::uc16> vector)
       : data_(vector) {}
   ~UC16VectorResource() override = default;
   size_t length() const override { return data_.length(); }
-  const v8::base::uc16* data() const override { return data_.begin(); }
+  const i::uc16* data() const override { return data_.begin(); }
   void Dispose() override {}
 
  private:
-  v8::base::Vector<const v8::base::uc16> data_;
+  v8::base::Vector<const i::uc16> data_;
 };
 
 static void MorphAString(i::String string,
@@ -21488,9 +21487,8 @@ STATIC_ASSERT(arraysize(kOneByteSubjectString) ==
 
 OneByteVectorResource one_byte_string_resource(v8::base::Vector<const char>(
     &kOneByteSubjectString[0], kSubjectStringLength));
-UC16VectorResource two_byte_string_resource(
-    v8::base::Vector<const v8::base::uc16>(&kTwoByteSubjectString[0],
-                                           kSubjectStringLength));
+UC16VectorResource two_byte_string_resource(v8::base::Vector<const i::uc16>(
+    &kTwoByteSubjectString[0], kSubjectStringLength));
 
 class RegExpInterruptTest {
  public:
diff --git a/test/cctest/test-assembler-arm.cc b/test/cctest/test-assembler-arm.cc
index 38fdbba447..475fe71e92 100644
--- a/test/cctest/test-assembler-arm.cc
+++ b/test/cctest/test-assembler-arm.cc
@@ -27,7 +27,6 @@
 
 #include <iostream>
 
-#include "src/base/numbers/double.h"
 #include "src/base/utils/random-number-generator.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
@@ -35,6 +34,7 @@
 #include "src/execution/simulator.h"
 #include "src/heap/factory.h"
 #include "src/init/v8.h"
+#include "src/numbers/double.h"
 #include "src/utils/ostreams.h"
 #include "test/cctest/assembler-helper-arm.h"
 #include "test/cctest/cctest.h"
@@ -266,16 +266,16 @@ TEST(4) {
     __ vstr(s1, r4, offsetof(T, y));
 
     // Move a literal into a register that can be encoded in the instruction.
-    __ vmov(d4, base::Double(1.0));
+    __ vmov(d4, Double(1.0));
     __ vstr(d4, r4, offsetof(T, e));
 
     // Move a literal into a register that requires 64 bits to encode.
     // 0x3FF0000010000000 = 1.000000059604644775390625
-    __ vmov(d4, base::Double(1.000000059604644775390625));
+    __ vmov(d4, Double(1.000000059604644775390625));
     __ vstr(d4, r4, offsetof(T, d));
 
     // Convert from floating point to integer.
-    __ vmov(d4, base::Double(2.0));
+    __ vmov(d4, Double(2.0));
     __ vcvt_s32_f64(s1, d4);
     __ vstr(s1, r4, offsetof(T, i));
 
@@ -447,7 +447,7 @@ static void TestRoundingMode(VCVTTypes types,
   __ vmsr(r2);
 
   // Load value, convert, and move back result to r0 if everything went well.
-  __ vmov(d1, base::Double(value));
+  __ vmov(d1, Double(value));
   switch (types) {
     case s32_f64:
       __ vcvt_s32_f64(s0, d1, kFPSCRRounding);
@@ -1074,8 +1074,8 @@ TEST(13) {
     __ vstm(ia_w, r4, d29, d31);
 
     // Move constants into d20, d21, d22 and store into i, j, k.
-    __ vmov(d20, base::Double(14.7610017472335499));
-    __ vmov(d21, base::Double(16.0));
+    __ vmov(d20, Double(14.7610017472335499));
+    __ vmov(d21, Double(16.0));
     __ mov(r1, Operand(372106121));
     __ mov(r2, Operand(1079146608));
     __ vmov(NeonS32, d22, 0, r1);
@@ -1364,12 +1364,12 @@ TEST(15) {
 
     // ARM core register to scalar.
     __ mov(r4, Operand(0xFFFFFFF8));
-    __ vmov(d0, base::Double(0.0));
+    __ vmov(d0, Double(0.0));
     __ vmov(NeonS8, d0, 1, r4);
     __ vmov(NeonS16, d0, 1, r4);
     __ vmov(NeonS32, d0, 1, r4);
     __ vstr(d0, r0, offsetof(T, vmov_to_scalar1));
-    __ vmov(d0, base::Double(0.0));
+    __ vmov(d0, Double(0.0));
     __ vmov(NeonS8, d0, 3, r4);
     __ vmov(NeonS16, d0, 3, r4);
     __ vstr(d0, r0, offsetof(T, vmov_to_scalar2));
@@ -3285,8 +3285,8 @@ TEST(ARMv8_vsel) {
     __ vsel(vc, s0, s1, s2);
     __ vstr(s0, r1, offsetof(ResultsF32, vselvc_));
 
-    __ vmov(d1, base::Double(kResultPass));
-    __ vmov(d2, base::Double(kResultFail));
+    __ vmov(d1, Double(kResultPass));
+    __ vmov(d2, Double(kResultFail));
 
     __ vsel(eq, d0, d1, d2);
     __ vstr(d0, r2, offsetof(ResultsF64, vseleq_));
diff --git a/test/cctest/test-assembler-ia32.cc b/test/cctest/test-assembler-ia32.cc
index 5fb548b991..423bf88dbf 100644
--- a/test/cctest/test-assembler-ia32.cc
+++ b/test/cctest/test-assembler-ia32.cc
@@ -501,9 +501,9 @@ TEST(AssemblerIa32Extractps) {
 
   F4 f = FUNCTION_CAST<F4>(code->entry());
   uint64_t value1 = 0x1234'5678'8765'4321;
-  CHECK_EQ(0x12345678, f(base::uint64_to_double(value1)));
+  CHECK_EQ(0x12345678, f(uint64_to_double(value1)));
   uint64_t value2 = 0x8765'4321'1234'5678;
-  CHECK_EQ(static_cast<int>(0x87654321), f(base::uint64_to_double(value2)));
+  CHECK_EQ(static_cast<int>(0x87654321), f(uint64_to_double(value2)));
 }
 
 using F8 = int (*)(float x, float y);
diff --git a/test/cctest/test-assembler-x64.cc b/test/cctest/test-assembler-x64.cc
index dc50bea651..2ee56bc95e 100644
--- a/test/cctest/test-assembler-x64.cc
+++ b/test/cctest/test-assembler-x64.cc
@@ -28,15 +28,16 @@
 #include <cstdlib>
 #include <iostream>
 
-#include "src/base/numbers/double.h"
+#include "src/init/v8.h"
+
 #include "src/base/platform/platform.h"
 #include "src/base/utils/random-number-generator.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/execution/simulator.h"
 #include "src/heap/factory.h"
-#include "src/init/v8.h"
-#include "src/objects/objects-inl.h"
+#include "src/numbers/double.h"
 #include "src/utils/ostreams.h"
+#include "src/objects/objects-inl.h"
 #include "test/cctest/cctest.h"
 #include "test/common/assembler-tester.h"
 
@@ -873,9 +874,9 @@ TEST(AssemblerX64Extractps) {
 
   auto f = GeneratedCode<F3>::FromCode(*code);
   uint64_t value1 = 0x1234'5678'8765'4321;
-  CHECK_EQ(0x12345678u, f.Call(base::uint64_to_double(value1)));
+  CHECK_EQ(0x12345678u, f.Call(uint64_to_double(value1)));
   uint64_t value2 = 0x8765'4321'1234'5678;
-  CHECK_EQ(0x87654321u, f.Call(base::uint64_to_double(value2)));
+  CHECK_EQ(0x87654321u, f.Call(uint64_to_double(value2)));
 }
 
 using F6 = int(float x, float y);
diff --git a/test/cctest/test-bignum-dtoa.cc b/test/cctest/test-bignum-dtoa.cc
index f646806c72..8a4946a280 100644
--- a/test/cctest/test-bignum-dtoa.cc
+++ b/test/cctest/test-bignum-dtoa.cc
@@ -27,17 +27,19 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/bignum-dtoa.h"
-#include "src/base/numbers/double.h"
-#include "src/base/platform/platform.h"
 #include "src/init/v8.h"
+
+#include "src/numbers/bignum-dtoa.h"
+
+#include "src/base/platform/platform.h"
+#include "src/numbers/double.h"
 #include "test/cctest/cctest.h"
 #include "test/cctest/gay-fixed.h"
 #include "test/cctest/gay-precision.h"
 #include "test/cctest/gay-shortest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 namespace test_bignum_dtoa {
 
 // Removes trailing '0' digits (modifies {representation}). Can create an empty
@@ -53,7 +55,7 @@ static const int kBufferSize = 100;
 
 TEST(BignumDtoaVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
@@ -251,11 +253,11 @@ TEST(BignumDtoaVariousDoubles) {
 
 TEST(BignumDtoaGayShortest) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
-  Vector<const PrecomputedShortest> precomputed =
+  base::Vector<const PrecomputedShortest> precomputed =
       PrecomputedShortestRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedShortest current_test = precomputed[i];
@@ -269,11 +271,11 @@ TEST(BignumDtoaGayShortest) {
 
 TEST(BignumDtoaGayFixed) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
-  Vector<const PrecomputedFixed> precomputed =
+  base::Vector<const PrecomputedFixed> precomputed =
       PrecomputedFixedRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedFixed current_test = precomputed[i];
@@ -290,11 +292,11 @@ TEST(BignumDtoaGayFixed) {
 
 TEST(BignumDtoaGayPrecision) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
-  Vector<const PrecomputedPrecision> precomputed =
+  base::Vector<const PrecomputedPrecision> precomputed =
       PrecomputedPrecisionRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedPrecision current_test = precomputed[i];
@@ -310,5 +312,5 @@ TEST(BignumDtoaGayPrecision) {
 }
 
 }  // namespace test_bignum_dtoa
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-bignum.cc b/test/cctest/test-bignum.cc
index 5fcc1a5450..50a5d041fe 100644
--- a/test/cctest/test-bignum.cc
+++ b/test/cctest/test-bignum.cc
@@ -27,23 +27,24 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/bignum.h"
-#include "src/base/platform/platform.h"
 #include "src/init/v8.h"
+
+#include "src/base/platform/platform.h"
+#include "src/numbers/bignum.h"
 #include "test/cctest/cctest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 namespace test_bignum {
 
 static const int kBufferSize = 1024;
 
 static void AssignHexString(Bignum* bignum, const char* str) {
-  bignum->AssignHexString(CStrVector(str));
+  bignum->AssignHexString(base::CStrVector(str));
 }
 
 static void AssignDecimalString(Bignum* bignum, const char* str) {
-  bignum->AssignDecimalString(CStrVector(str));
+  bignum->AssignDecimalString(base::CStrVector(str));
 }
 
 TEST(Assign) {
@@ -1540,5 +1541,5 @@ TEST(AssignPowerUInt16) {
 }
 
 }  // namespace test_bignum
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-code-stub-assembler.cc b/test/cctest/test-code-stub-assembler.cc
index 5a393184bd..4801cd3b21 100644
--- a/test/cctest/test-code-stub-assembler.cc
+++ b/test/cctest/test-code-stub-assembler.cc
@@ -5,7 +5,6 @@
 #include <cmath>
 
 #include "src/api/api-inl.h"
-#include "src/base/strings.h"
 #include "src/base/utils/random-number-generator.h"
 #include "src/builtins/builtins-promise-gen.h"
 #include "src/builtins/builtins-promise.h"
@@ -778,7 +777,7 @@ TEST(TryToName) {
 
   {
     // TryToName(<thin two-byte string>) => internalized version.
-    base::uc16 array1[] = {2001, 2002, 2003};
+    uc16 array1[] = {2001, 2002, 2003};
     Handle<String> s = isolate->factory()
                            ->NewStringFromTwoByte(base::ArrayVector(array1))
                            .ToHandleChecked();
@@ -2197,7 +2196,7 @@ TEST(OneToTwoByteStringCopy) {
   m.Return(m.SmiConstant(Smi::FromInt(0)));
 
   Handle<String> string1 = isolate->factory()->InternalizeUtf8String("abcde");
-  base::uc16 array[] = {1000, 1001, 1002, 1003, 1004};
+  uc16 array[] = {1000, 1001, 1002, 1003, 1004};
   Handle<String> string2 = isolate->factory()
                                ->NewStringFromTwoByte(base::ArrayVector(array))
                                .ToHandleChecked();
@@ -2292,11 +2291,11 @@ TEST(TwoToTwoByteStringCopy) {
                                  String::TWO_BYTE_ENCODING);
   m.Return(m.SmiConstant(Smi::FromInt(0)));
 
-  base::uc16 array1[] = {2000, 2001, 2002, 2003, 2004};
+  uc16 array1[] = {2000, 2001, 2002, 2003, 2004};
   Handle<String> string1 = isolate->factory()
                                ->NewStringFromTwoByte(base::ArrayVector(array1))
                                .ToHandleChecked();
-  base::uc16 array2[] = {1000, 1001, 1002, 1003, 1004};
+  uc16 array2[] = {1000, 1001, 1002, 1003, 1004};
   Handle<String> string2 = isolate->factory()
                                ->NewStringFromTwoByte(base::ArrayVector(array2))
                                .ToHandleChecked();
@@ -3314,7 +3313,7 @@ TEST(IsWhiteSpaceOrLineTerminator) {
   Handle<Object> true_value = ft.true_value();
   Handle<Object> false_value = ft.false_value();
 
-  for (base::uc16 c = 0; c < 0xFFFF; c++) {
+  for (uc16 c = 0; c < 0xFFFF; c++) {
     Handle<Object> expected_value =
         IsWhiteSpaceOrLineTerminator(c) ? true_value : false_value;
     ft.CheckCall(expected_value, handle(Smi::FromInt(c), isolate));
diff --git a/test/cctest/test-disasm-arm.cc b/test/cctest/test-disasm-arm.cc
index 2d35d4464a..07a12f3500 100644
--- a/test/cctest/test-disasm-arm.cc
+++ b/test/cctest/test-disasm-arm.cc
@@ -33,7 +33,6 @@
 // former isn't available in V8.
 #include <regex>  // NOLINT(build/c++11)
 
-#include "src/base/numbers/double.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/debug/debug.h"
@@ -41,6 +40,7 @@
 #include "src/diagnostics/disassembler.h"
 #include "src/execution/frames-inl.h"
 #include "src/init/v8.h"
+#include "src/numbers/double.h"
 #include "src/objects/objects-inl.h"
 #include "src/utils/boxed-float.h"
 #include "test/cctest/cctest.h"
@@ -667,9 +667,9 @@ TEST(Vfp) {
     COMPARE(vsqrt(s2, s3, ne),
             "1eb11ae1       vsqrtne.f32 s2, s3");
 
-    COMPARE(vmov(d0, base::Double(1.0)),
+    COMPARE(vmov(d0, Double(1.0)),
             "eeb70b00       vmov.f64 d0, #1");
-    COMPARE(vmov(d2, base::Double(-13.0)),
+    COMPARE(vmov(d2, Double(-13.0)),
             "eeba2b0a       vmov.f64 d2, #-13");
 
     COMPARE(vmov(s1, Float32(-1.0f)),
@@ -835,7 +835,7 @@ TEST(Vfp) {
       COMPARE(vsqrt(d16, d17),
               "eef10be1       vsqrt.f64 d16, d17");
 
-      COMPARE(vmov(d30, base::Double(16.0)),
+      COMPARE(vmov(d30, Double(16.0)),
               "eef3eb00       vmov.f64 d30, #16");
 
       COMPARE(vmov(NeonS32, d31, 0, r7),
diff --git a/test/cctest/test-diy-fp.cc b/test/cctest/test-diy-fp.cc
index 3d94fab38b..91e84712fa 100644
--- a/test/cctest/test-diy-fp.cc
+++ b/test/cctest/test-diy-fp.cc
@@ -27,13 +27,14 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/diy-fp.h"
-#include "src/base/platform/platform.h"
 #include "src/init/v8.h"
+
+#include "src/base/platform/platform.h"
+#include "src/numbers/diy-fp.h"
 #include "test/cctest/cctest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 TEST(Subtract) {
   DiyFp diy_fp1 = DiyFp(3, 0);
@@ -89,5 +90,5 @@ TEST(Multiply) {
   CHECK_EQ(11 + 13 + 64, product.e());
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-double.cc b/test/cctest/test-double.cc
index e369565910..8e78b63af5 100644
--- a/test/cctest/test-double.cc
+++ b/test/cctest/test-double.cc
@@ -27,14 +27,15 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/diy-fp.h"
-#include "src/base/numbers/double.h"
-#include "src/base/platform/platform.h"
 #include "src/init/v8.h"
+
+#include "src/base/platform/platform.h"
+#include "src/numbers/diy-fp.h"
+#include "src/numbers/double.h"
 #include "test/cctest/cctest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 TEST(Uint64Conversions) {
   // Start by checking the byte-order.
@@ -224,5 +225,5 @@ TEST(NextDouble) {
   CHECK_EQ(V8_INFINITY, Double(uint64_t{0x7FEF'FFFF'FFFF'FFFF}).NextDouble());
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-dtoa.cc b/test/cctest/test-dtoa.cc
index 2bf76b4ffd..5d2679f4f9 100644
--- a/test/cctest/test-dtoa.cc
+++ b/test/cctest/test-dtoa.cc
@@ -27,17 +27,19 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/double.h"
-#include "src/base/numbers/dtoa.h"
-#include "src/base/platform/platform.h"
 #include "src/init/v8.h"
+
+#include "src/numbers/dtoa.h"
+
+#include "src/base/platform/platform.h"
+#include "src/numbers/double.h"
 #include "test/cctest/cctest.h"
 #include "test/cctest/gay-fixed.h"
 #include "test/cctest/gay-precision.h"
 #include "test/cctest/gay-shortest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 namespace test_dtoa {
 
 // Removes trailing '0' digits (modifies {representation}). Can create an empty
@@ -326,5 +328,5 @@ TEST(DtoaGayPrecision) {
 }
 
 }  // namespace test_dtoa
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-fast-dtoa.cc b/test/cctest/test-fast-dtoa.cc
index 6382bd3764..13dd67c1d2 100644
--- a/test/cctest/test-fast-dtoa.cc
+++ b/test/cctest/test-fast-dtoa.cc
@@ -27,17 +27,18 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/diy-fp.h"
-#include "src/base/numbers/double.h"
-#include "src/base/numbers/fast-dtoa.h"
-#include "src/base/platform/platform.h"
 #include "src/init/v8.h"
+
+#include "src/base/platform/platform.h"
+#include "src/numbers/diy-fp.h"
+#include "src/numbers/double.h"
+#include "src/numbers/fast-dtoa.h"
 #include "test/cctest/cctest.h"
 #include "test/cctest/gay-precision.h"
 #include "test/cctest/gay-shortest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 namespace test_fast_dtoa {
 
 static const int kBufferSize = 100;
@@ -52,7 +53,7 @@ static void TrimRepresentation(char* representation) {
 
 TEST(FastDtoaShortestVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
   int status;
@@ -122,7 +123,7 @@ TEST(FastDtoaShortestVariousDoubles) {
 
 TEST(FastDtoaPrecisionVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
   int status;
@@ -223,7 +224,7 @@ TEST(FastDtoaPrecisionVariousDoubles) {
 
 TEST(FastDtoaGayShortest) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   bool status;
   int length;
   int point;
@@ -231,7 +232,7 @@ TEST(FastDtoaGayShortest) {
   int total = 0;
   bool needed_max_length = false;
 
-  Vector<const PrecomputedShortest> precomputed =
+  base::Vector<const PrecomputedShortest> precomputed =
       PrecomputedShortestRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedShortest current_test = precomputed[i];
@@ -252,7 +253,7 @@ TEST(FastDtoaGayShortest) {
 
 TEST(FastDtoaGayPrecision) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   bool status;
   int length;
   int point;
@@ -262,7 +263,7 @@ TEST(FastDtoaGayPrecision) {
   int succeeded_15 = 0;
   int total_15 = 0;
 
-  Vector<const PrecomputedPrecision> precomputed =
+  base::Vector<const PrecomputedPrecision> precomputed =
       PrecomputedPrecisionRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedPrecision current_test = precomputed[i];
@@ -290,5 +291,5 @@ TEST(FastDtoaGayPrecision) {
 }
 
 }  // namespace test_fast_dtoa
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-fixed-dtoa.cc b/test/cctest/test-fixed-dtoa.cc
index c4d6ff0c63..e50f5a29ae 100644
--- a/test/cctest/test-fixed-dtoa.cc
+++ b/test/cctest/test-fixed-dtoa.cc
@@ -27,21 +27,22 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/double.h"
-#include "src/base/numbers/fixed-dtoa.h"
-#include "src/base/platform/platform.h"
 #include "src/init/v8.h"
+
+#include "src/base/platform/platform.h"
+#include "src/numbers/double.h"
+#include "src/numbers/fixed-dtoa.h"
 #include "test/cctest/cctest.h"
 #include "test/cctest/gay-fixed.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 
 static const int kBufferSize = 500;
 
 TEST(FastFixedVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
@@ -491,12 +492,12 @@ TEST(FastFixedVariousDoubles) {
 
 TEST(FastFixedDtoaGayFixed) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   bool status;
   int length;
   int point;
 
-  Vector<const PrecomputedFixed> precomputed =
+  base::Vector<const PrecomputedFixed> precomputed =
       PrecomputedFixedRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedFixed current_test = precomputed[i];
@@ -511,5 +512,5 @@ TEST(FastFixedDtoaGayFixed) {
   }
 }
 
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-regexp.cc b/test/cctest/test-regexp.cc
index aa24fe3dd2..be9607da0c 100644
--- a/test/cctest/test-regexp.cc
+++ b/test/cctest/test-regexp.cc
@@ -32,7 +32,6 @@
 #include "include/v8.h"
 #include "src/api/api-inl.h"
 #include "src/ast/ast.h"
-#include "src/base/strings.h"
 #include "src/codegen/assembler-arch.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/init/v8.h"
@@ -487,32 +486,30 @@ TEST(Errors) {
   ExpectError("\\ka", kInvalidNamedReference, true);
 }
 
-static bool IsDigit(base::uc32 c) { return ('0' <= c && c <= '9'); }
+static bool IsDigit(uc32 c) { return ('0' <= c && c <= '9'); }
 
-static bool NotDigit(base::uc32 c) { return !IsDigit(c); }
+static bool NotDigit(uc32 c) { return !IsDigit(c); }
 
-static bool IsWhiteSpaceOrLineTerminator(base::uc32 c) {
+static bool IsWhiteSpaceOrLineTerminator(uc32 c) {
   // According to ECMA 5.1, 15.10.2.12 the CharacterClassEscape \s includes
   // WhiteSpace (7.2) and LineTerminator (7.3) values.
   return v8::internal::IsWhiteSpaceOrLineTerminator(c);
 }
 
-static bool NotWhiteSpaceNorLineTermiantor(base::uc32 c) {
+static bool NotWhiteSpaceNorLineTermiantor(uc32 c) {
   return !IsWhiteSpaceOrLineTerminator(c);
 }
 
-static bool NotWord(base::uc32 c) { return !IsRegExpWord(c); }
+static bool NotWord(uc32 c) { return !IsRegExpWord(c); }
 
-static bool NotLineTerminator(base::uc32 c) {
-  return !unibrow::IsLineTerminator(c);
-}
+static bool NotLineTerminator(uc32 c) { return !unibrow::IsLineTerminator(c); }
 
-static void TestCharacterClassEscapes(base::uc32 c, bool(pred)(base::uc32 c)) {
+static void TestCharacterClassEscapes(uc32 c, bool(pred)(uc32 c)) {
   Zone zone(CcTest::i_isolate()->allocator(), ZONE_NAME);
   ZoneList<CharacterRange>* ranges =
       zone.New<ZoneList<CharacterRange>>(2, &zone);
   CharacterRange::AddClassEscape(c, ranges, &zone);
-  for (base::uc32 i = 0; i < (1 << 16); i++) {
+  for (uc32 i = 0; i < (1 << 16); i++) {
     bool in_class = false;
     for (int j = 0; !in_class && j < ranges->length(); j++) {
       CharacterRange& range = ranges->at(j);
@@ -789,11 +786,10 @@ TEST(MacroAssemblerNativeSimpleUC16) {
   Handle<JSRegExp> regexp = CreateJSRegExp(source, code, true);
 
   int captures[4] = {42, 37, 87, 117};
-  const base::uc16 input_data[6] = {'f', 'o', 'o',
-                                    'f', 'o', static_cast<base::uc16>(0x2603)};
+  const uc16 input_data[6] = {'f', 'o', 'o',
+                              'f', 'o', static_cast<uc16>(0x2603)};
   Handle<String> input =
-      factory
-          ->NewStringFromTwoByte(base::Vector<const base::uc16>(input_data, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(input_data, 6))
           .ToHandleChecked();
   Handle<SeqTwoByteString> seq_input = Handle<SeqTwoByteString>::cast(input);
   Address start_adr = seq_input->GetCharsAddress();
@@ -807,11 +803,10 @@ TEST(MacroAssemblerNativeSimpleUC16) {
   CHECK_EQ(-1, captures[2]);
   CHECK_EQ(-1, captures[3]);
 
-  const base::uc16 input_data2[9] = {
-      'b', 'a', 'r', 'b', 'a', 'r', 'b', 'a', static_cast<base::uc16>(0x2603)};
+  const uc16 input_data2[9] = {
+      'b', 'a', 'r', 'b', 'a', 'r', 'b', 'a', static_cast<uc16>(0x2603)};
   input =
-      factory
-          ->NewStringFromTwoByte(base::Vector<const base::uc16>(input_data2, 9))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(input_data2, 9))
           .ToHandleChecked();
   seq_input = Handle<SeqTwoByteString>::cast(input);
   start_adr = seq_input->GetCharsAddress();
@@ -933,10 +928,9 @@ TEST(MacroAssemblerNativeBackReferenceUC16) {
   Handle<Code> code = Handle<Code>::cast(code_object);
   Handle<JSRegExp> regexp = CreateJSRegExp(source, code, true);
 
-  const base::uc16 input_data[6] = {'f', 0x2028, 'o', 'o', 'f', 0x2028};
+  const uc16 input_data[6] = {'f', 0x2028, 'o', 'o', 'f', 0x2028};
   Handle<String> input =
-      factory
-          ->NewStringFromTwoByte(base::Vector<const base::uc16>(input_data, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(input_data, 6))
           .ToHandleChecked();
   Handle<SeqTwoByteString> seq_input = Handle<SeqTwoByteString>::cast(input);
   Address start_adr = seq_input->GetCharsAddress();
@@ -1066,8 +1060,8 @@ TEST(MacroAssemblerNativeRegisters) {
   ArchRegExpMacroAssembler m(isolate, &zone, NativeRegExpMacroAssembler::LATIN1,
                              6);
 
-  base::uc16 foo_chars[3] = {'f', 'o', 'o'};
-  base::Vector<const base::uc16> foo(foo_chars, 3);
+  uc16 foo_chars[3] = {'f', 'o', 'o'};
+  base::Vector<const uc16> foo(foo_chars, 3);
 
   enum registers { out1, out2, out3, out4, out5, out6, sp, loop_cnt };
   Label fail;
@@ -1275,9 +1269,9 @@ TEST(MacroAssembler) {
   int captures[5];
   std::memset(captures, 0, sizeof(captures));
 
-  const base::uc16 str1[] = {'f', 'o', 'o', 'b', 'a', 'r'};
+  const uc16 str1[] = {'f', 'o', 'o', 'b', 'a', 'r'};
   Handle<String> f1_16 =
-      factory->NewStringFromTwoByte(base::Vector<const base::uc16>(str1, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(str1, 6))
           .ToHandleChecked();
 
   CHECK_EQ(IrregexpInterpreter::SUCCESS,
@@ -1290,9 +1284,9 @@ TEST(MacroAssembler) {
   CHECK_EQ(2, captures[3]);
   CHECK_EQ(84, captures[4]);
 
-  const base::uc16 str2[] = {'b', 'a', 'r', 'f', 'o', 'o'};
+  const uc16 str2[] = {'b', 'a', 'r', 'f', 'o', 'o'};
   Handle<String> f2_16 =
-      factory->NewStringFromTwoByte(base::Vector<const base::uc16>(str2, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(str2, 6))
           .ToHandleChecked();
 
   std::memset(captures, 0, sizeof(captures));
@@ -1309,7 +1303,7 @@ TEST(MacroAssembler) {
 }
 
 #ifndef V8_INTL_SUPPORT
-static base::uc32 canonicalize(base::uc32 c) {
+static uc32 canonicalize(uc32 c) {
   unibrow::uchar canon[unibrow::Ecma262Canonicalize::kMaxWidth];
   int count = unibrow::Ecma262Canonicalize::Convert(c, '\0', canon, nullptr);
   if (count == 0) {
@@ -1331,23 +1325,23 @@ TEST(LatinCanonicalize) {
     CHECK_EQ(upper, uncanon[0]);
     CHECK_EQ(lower, uncanon[1]);
   }
-  for (base::uc32 c = 128; c < (1 << 21); c++) CHECK_GE(canonicalize(c), 128);
+  for (uc32 c = 128; c < (1 << 21); c++) CHECK_GE(canonicalize(c), 128);
   unibrow::Mapping<unibrow::ToUppercase> to_upper;
   // Canonicalization is only defined for the Basic Multilingual Plane.
-  for (base::uc32 c = 0; c < (1 << 16); c++) {
+  for (uc32 c = 0; c < (1 << 16); c++) {
     unibrow::uchar upper[unibrow::ToUppercase::kMaxWidth];
     int length = to_upper.get(c, '\0', upper);
     if (length == 0) {
       length = 1;
       upper[0] = c;
     }
-    base::uc32 u = upper[0];
+    uc32 u = upper[0];
     if (length > 1 || (c >= 128 && u < 128)) u = c;
     CHECK_EQ(u, canonicalize(c));
   }
 }
 
-static base::uc32 CanonRangeEnd(base::uc32 c) {
+static uc32 CanonRangeEnd(uc32 c) {
   unibrow::uchar canon[unibrow::CanonicalizationRange::kMaxWidth];
   int count = unibrow::CanonicalizationRange::Convert(c, '\0', canon, nullptr);
   if (count == 0) {
@@ -1365,7 +1359,7 @@ TEST(RangeCanonicalization) {
   unibrow::Mapping<unibrow::Ecma262UnCanonicalize> un_canonicalize;
   int block_start = 0;
   while (block_start <= 0xFFFF) {
-    base::uc32 block_end = CanonRangeEnd(block_start);
+    uc32 block_end = CanonRangeEnd(block_start);
     unsigned block_length = block_end - block_start + 1;
     if (block_length > 1) {
       unibrow::uchar first[unibrow::Ecma262UnCanonicalize::kMaxWidth];
@@ -1463,7 +1457,7 @@ TEST(CharacterRangeCaseIndependence) {
 #endif  // !V8_INTL_SUPPORT
 }
 
-static bool InClass(base::uc32 c,
+static bool InClass(uc32 c,
                     const UnicodeRangeSplitter::CharacterRangeVector* ranges) {
   if (ranges == nullptr) return false;
   for (size_t i = 0; i < ranges->size(); i++) {
@@ -1479,35 +1473,35 @@ TEST(UnicodeRangeSplitter) {
   base->Add(CharacterRange::Everything(), &zone);
   UnicodeRangeSplitter splitter(base);
   // BMP
-  for (base::uc32 c = 0; c < 0xD800; c++) {
+  for (uc32 c = 0; c < 0xD800; c++) {
     CHECK(InClass(c, splitter.bmp()));
     CHECK(!InClass(c, splitter.lead_surrogates()));
     CHECK(!InClass(c, splitter.trail_surrogates()));
     CHECK(!InClass(c, splitter.non_bmp()));
   }
   // Lead surrogates
-  for (base::uc32 c = 0xD800; c < 0xDBFF; c++) {
+  for (uc32 c = 0xD800; c < 0xDBFF; c++) {
     CHECK(!InClass(c, splitter.bmp()));
     CHECK(InClass(c, splitter.lead_surrogates()));
     CHECK(!InClass(c, splitter.trail_surrogates()));
     CHECK(!InClass(c, splitter.non_bmp()));
   }
   // Trail surrogates
-  for (base::uc32 c = 0xDC00; c < 0xDFFF; c++) {
+  for (uc32 c = 0xDC00; c < 0xDFFF; c++) {
     CHECK(!InClass(c, splitter.bmp()));
     CHECK(!InClass(c, splitter.lead_surrogates()));
     CHECK(InClass(c, splitter.trail_surrogates()));
     CHECK(!InClass(c, splitter.non_bmp()));
   }
   // BMP
-  for (base::uc32 c = 0xE000; c < 0xFFFF; c++) {
+  for (uc32 c = 0xE000; c < 0xFFFF; c++) {
     CHECK(InClass(c, splitter.bmp()));
     CHECK(!InClass(c, splitter.lead_surrogates()));
     CHECK(!InClass(c, splitter.trail_surrogates()));
     CHECK(!InClass(c, splitter.non_bmp()));
   }
   // Non-BMP
-  for (base::uc32 c = 0x10000; c < 0x10FFFF; c++) {
+  for (uc32 c = 0x10000; c < 0x10FFFF; c++) {
     CHECK(!InClass(c, splitter.bmp()));
     CHECK(!InClass(c, splitter.lead_surrogates()));
     CHECK(!InClass(c, splitter.trail_surrogates()));
diff --git a/test/cctest/test-strings.cc b/test/cctest/test-strings.cc
index 2655897ee0..7e484eb4ab 100644
--- a/test/cctest/test-strings.cc
+++ b/test/cctest/test-strings.cc
@@ -34,7 +34,6 @@
 
 #include "src/api/api-inl.h"
 #include "src/base/platform/elapsed-timer.h"
-#include "src/base/strings.h"
 #include "src/execution/messages.h"
 #include "src/heap/factory.h"
 #include "src/heap/heap-inl.h"
@@ -101,14 +100,13 @@ static const int SUPER_DEEP_DEPTH = 80 * 1024;
 
 class Resource : public v8::String::ExternalStringResource {
  public:
-  Resource(const base::uc16* data, size_t length)
-      : data_(data), length_(length) {}
+  Resource(const uc16* data, size_t length) : data_(data), length_(length) {}
   ~Resource() override { i::DeleteArray(data_); }
   const uint16_t* data() const override { return data_; }
   size_t length() const override { return length_; }
 
  private:
-  const base::uc16* data_;
+  const uc16* data_;
   size_t length_;
 };
 
@@ -158,14 +156,13 @@ static void InitializeBuildingBlocks(Handle<String>* building_blocks,
     len += slice_length;
     switch (rng->next(4)) {
       case 0: {
-        base::uc16 buf[2000];
+        uc16 buf[2000];
         for (int j = 0; j < len; j++) {
           buf[j] = rng->next(0x10000);
         }
         building_blocks[i] =
             factory
-                ->NewStringFromTwoByte(
-                    v8::base::Vector<const base::uc16>(buf, len))
+                ->NewStringFromTwoByte(v8::base::Vector<const uc16>(buf, len))
                 .ToHandleChecked();
         for (int j = 0; j < len; j++) {
           CHECK_EQ(buf[j], building_blocks[i]->Get(j));
@@ -186,7 +183,7 @@ static void InitializeBuildingBlocks(Handle<String>* building_blocks,
         break;
       }
       case 2: {
-        base::uc16* buf = NewArray<base::uc16>(len);
+        uc16* buf = NewArray<uc16>(len);
         for (int j = 0; j < len; j++) {
           buf[j] = rng->next(0x10000);
         }
@@ -1054,7 +1051,7 @@ TEST(ExternalShortStringAdd) {
         ->Set(context.local(), v8::Integer::New(CcTest::isolate(), i),
               one_byte_external_string)
         .FromJust();
-    base::uc16* non_one_byte = NewArray<base::uc16>(i + 1);
+    uc16* non_one_byte = NewArray<uc16>(i + 1);
     for (int j = 0; j < i; j++) {
       non_one_byte[j] = 0x1234;
     }
@@ -1177,7 +1174,7 @@ TEST(JSONStringifySliceMadeExternal) {
   CHECK(v8::Utils::OpenHandle(*underlying)->IsSeqOneByteString());
 
   int length = underlying->Length();
-  base::uc16* two_byte = NewArray<base::uc16>(length + 1);
+  uc16* two_byte = NewArray<uc16>(length + 1);
   underlying->Write(CcTest::isolate(), two_byte);
   Resource* resource = new Resource(two_byte, length);
   CHECK(underlying->MakeExternal(resource));
@@ -1564,7 +1561,7 @@ TEST(StringReplaceAtomTwoByteResult) {
 
 TEST(IsAscii) {
   CHECK(String::IsAscii(static_cast<char*>(nullptr), 0));
-  CHECK(String::IsOneByte(static_cast<base::uc16*>(nullptr), 0));
+  CHECK(String::IsOneByte(static_cast<uc16*>(nullptr), 0));
 }
 
 template <typename Op, bool return_first>
@@ -1933,7 +1930,7 @@ TEST(Regress876759) {
   HandleScope handle_scope(isolate);
 
   const int kLength = 30;
-  base::uc16 two_byte_buf[kLength];
+  uc16 two_byte_buf[kLength];
   char* external_one_byte_buf = new char[kLength];
   for (int j = 0; j < kLength; j++) {
     char c = '0' + (j % 10);
diff --git a/test/cctest/test-strtod.cc b/test/cctest/test-strtod.cc
index e0a85d555e..740815df77 100644
--- a/test/cctest/test-strtod.cc
+++ b/test/cctest/test-strtod.cc
@@ -27,33 +27,34 @@
 
 #include <stdlib.h>
 
-#include "src/base/numbers/bignum.h"
-#include "src/base/numbers/diy-fp.h"
-#include "src/base/numbers/double.h"
-#include "src/base/numbers/strtod.h"
-#include "src/base/utils/random-number-generator.h"
 #include "src/init/v8.h"
+
+#include "src/base/utils/random-number-generator.h"
+#include "src/numbers/bignum.h"
+#include "src/numbers/diy-fp.h"
+#include "src/numbers/double.h"
+#include "src/numbers/strtod.h"
 #include "test/cctest/cctest.h"
 
 namespace v8 {
-namespace base {
+namespace internal {
 namespace test_strtod {
 
 static double StrtodChar(const char* str, int exponent) {
-  return Strtod(CStrVector(str), exponent);
+  return Strtod(base::CStrVector(str), exponent);
 }
 
 TEST(Strtod) {
-  Vector<const char> vector;
+  base::Vector<const char> vector;
 
-  vector = CStrVector("0");
+  vector = base::CStrVector("0");
   CHECK_EQ(0.0, Strtod(vector, 1));
   CHECK_EQ(0.0, Strtod(vector, 2));
   CHECK_EQ(0.0, Strtod(vector, -2));
   CHECK_EQ(0.0, Strtod(vector, -999));
   CHECK_EQ(0.0, Strtod(vector, +999));
 
-  vector = CStrVector("1");
+  vector = base::CStrVector("1");
   CHECK_EQ(1.0, Strtod(vector, 0));
   CHECK_EQ(10.0, Strtod(vector, 1));
   CHECK_EQ(100.0, Strtod(vector, 2));
@@ -72,7 +73,7 @@ TEST(Strtod) {
   CHECK_EQ(1e-25, Strtod(vector, -25));
   CHECK_EQ(1e-39, Strtod(vector, -39));
 
-  vector = CStrVector("2");
+  vector = base::CStrVector("2");
   CHECK_EQ(2.0, Strtod(vector, 0));
   CHECK_EQ(20.0, Strtod(vector, 1));
   CHECK_EQ(200.0, Strtod(vector, 2));
@@ -91,7 +92,7 @@ TEST(Strtod) {
   CHECK_EQ(2e-25, Strtod(vector, -25));
   CHECK_EQ(2e-39, Strtod(vector, -39));
 
-  vector = CStrVector("9");
+  vector = base::CStrVector("9");
   CHECK_EQ(9.0, Strtod(vector, 0));
   CHECK_EQ(90.0, Strtod(vector, 1));
   CHECK_EQ(900.0, Strtod(vector, 2));
@@ -110,7 +111,7 @@ TEST(Strtod) {
   CHECK_EQ(9e-25, Strtod(vector, -25));
   CHECK_EQ(9e-39, Strtod(vector, -39));
 
-  vector = CStrVector("12345");
+  vector = base::CStrVector("12345");
   CHECK_EQ(12345.0, Strtod(vector, 0));
   CHECK_EQ(123450.0, Strtod(vector, 1));
   CHECK_EQ(1234500.0, Strtod(vector, 2));
@@ -132,7 +133,7 @@ TEST(Strtod) {
   CHECK_EQ(12345e-25, Strtod(vector, -25));
   CHECK_EQ(12345e-39, Strtod(vector, -39));
 
-  vector = CStrVector("12345678901234");
+  vector = base::CStrVector("12345678901234");
   CHECK_EQ(12345678901234.0, Strtod(vector, 0));
   CHECK_EQ(123456789012340.0, Strtod(vector, 1));
   CHECK_EQ(1234567890123400.0, Strtod(vector, 2));
@@ -154,7 +155,7 @@ TEST(Strtod) {
   CHECK_EQ(12345678901234e-25, Strtod(vector, -25));
   CHECK_EQ(12345678901234e-39, Strtod(vector, -39));
 
-  vector = CStrVector("123456789012345");
+  vector = base::CStrVector("123456789012345");
   CHECK_EQ(123456789012345.0, Strtod(vector, 0));
   CHECK_EQ(1234567890123450.0, Strtod(vector, 1));
   CHECK_EQ(12345678901234500.0, Strtod(vector, 2));
@@ -387,7 +388,7 @@ static int CompareBignumToDiyFp(const Bignum& bignum_digits,
   return Bignum::Compare(bignum, other);
 }
 
-static bool CheckDouble(Vector<const char> buffer, int exponent,
+static bool CheckDouble(base::Vector<const char> buffer, int exponent,
                         double to_check) {
   DiyFp lower_boundary;
   DiyFp upper_boundary;
@@ -441,7 +442,7 @@ static const int kShortStrtodRandomCount = 2;
 static const int kLargeStrtodRandomCount = 2;
 
 TEST(RandomStrtod) {
-  base::RandomNumberGenerator rng;
+  v8::base::RandomNumberGenerator rng;
   char buffer[kBufferSize];
   for (int length = 1; length < 15; length++) {
     for (int i = 0; i < kShortStrtodRandomCount; ++i) {
@@ -451,7 +452,7 @@ TEST(RandomStrtod) {
       }
       int exponent = DeterministicRandom() % (25*2 + 1) - 25 - length;
       buffer[pos] = '\0';
-      Vector<const char> vector(buffer, pos);
+      base::Vector<const char> vector(buffer, pos);
       double strtod_result = Strtod(vector, exponent);
       CHECK(CheckDouble(vector, exponent, strtod_result));
     }
@@ -464,7 +465,7 @@ TEST(RandomStrtod) {
       }
       int exponent = DeterministicRandom() % (308*2 + 1) - 308 - length;
       buffer[pos] = '\0';
-      Vector<const char> vector(buffer, pos);
+      base::Vector<const char> vector(buffer, pos);
       double strtod_result = Strtod(vector, exponent);
       CHECK(CheckDouble(vector, exponent, strtod_result));
     }
@@ -472,5 +473,5 @@ TEST(RandomStrtod) {
 }
 
 }  // namespace test_strtod
-}  // namespace base
+}  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/test-types.cc b/test/cctest/test-types.cc
index 4a2f6803ca..848b8ebb63 100644
--- a/test/cctest/test-types.cc
+++ b/test/cctest/test-types.cc
@@ -4,7 +4,6 @@
 
 #include <vector>
 
-#include "src/base/strings.h"
 #include "src/compiler/types.h"
 #include "src/execution/isolate.h"
 #include "src/heap/factory-inl.h"
@@ -277,9 +276,9 @@ struct Tests {
     // Typing of Strings
     Handle<String> s1 = fac->NewStringFromAsciiChecked("a");
     CHECK(T.Constant(s1).Is(T.InternalizedString));
-    const base::uc16 two_byte[1] = {0x2603};
+    const uc16 two_byte[1] = {0x2603};
     Handle<String> s2 = fac->NewTwoByteInternalizedString(
-        base::Vector<const base::uc16>(two_byte, 1), 1);
+        base::Vector<const uc16>(two_byte, 1), 1);
     CHECK(T.Constant(s2).Is(T.InternalizedString));
 
     // Typing of special constants
diff --git a/test/fuzzer/regexp.cc b/test/fuzzer/regexp.cc
index 2f56475df9..3b8750c6aa 100644
--- a/test/fuzzer/regexp.cc
+++ b/test/fuzzer/regexp.cc
@@ -2,16 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "src/regexp/regexp.h"
-
 #include <limits.h>
 #include <stddef.h>
 #include <stdint.h>
 
 #include "include/v8.h"
-#include "src/base/strings.h"
 #include "src/heap/factory.h"
 #include "src/objects/objects-inl.h"
+#include "src/regexp/regexp.h"
 #include "test/fuzzer/fuzzer-support.h"
 
 namespace i = v8::internal;
@@ -53,8 +51,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
                                i::JSRegExp::kUnicode | i::JSRegExp::kDotAll;
 
   const uint8_t one_byte_array[6] = {'f', 'o', 'o', 'b', 'a', 'r'};
-  const v8::base::uc16 two_byte_array[6] = {'f', 0xD83D, 0xDCA9,
-                                            'b', 'a',    0x2603};
+  const i::uc16 two_byte_array[6] = {'f', 0xD83D, 0xDCA9, 'b', 'a', 0x2603};
 
   CHECK(!i_isolate->has_pending_exception());
   i::Handle<i::RegExpMatchInfo> results_array = factory->NewRegExpMatchInfo();
@@ -66,7 +63,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   i::Handle<i::String> two_byte =
       factory
           ->NewStringFromTwoByte(
-              v8::base::Vector<const v8::base::uc16>(two_byte_array, 6))
+              v8::base::Vector<const i::uc16>(two_byte_array, 6))
           .ToHandleChecked();
 
   i::Handle<i::JSRegExp> regexp;
diff --git a/test/unittests/compiler/machine-operator-reducer-unittest.cc b/test/unittests/compiler/machine-operator-reducer-unittest.cc
index 4a33aff77d..d54e927e83 100644
--- a/test/unittests/compiler/machine-operator-reducer-unittest.cc
+++ b/test/unittests/compiler/machine-operator-reducer-unittest.cc
@@ -2315,8 +2315,7 @@ TEST_F(MachineOperatorReducerTest, Float64DivWithMinusOne) {
 TEST_F(MachineOperatorReducerTest, Float64DivWithPowerOfTwo) {
   Node* const p0 = Parameter(0);
   TRACED_FORRANGE(uint64_t, exponent, 1, 0x7FE) {
-    base::Double divisor =
-        base::Double(exponent << base::Double::kPhysicalSignificandSize);
+    Double divisor = Double(exponent << Double::kPhysicalSignificandSize);
     if (divisor.value() == 1.0) continue;  // Skip x / 1.0 => x.
     Reduction r = Reduce(graph()->NewNode(machine()->Float64Div(), p0,
                                           Float64Constant(divisor.value())));
-- 
2.35.1


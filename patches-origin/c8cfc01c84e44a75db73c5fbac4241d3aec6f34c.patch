From c8cfc01c84e44a75db73c5fbac4241d3aec6f34c Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Thu, 11 May 2023 15:56:03 +0200
Subject: [PATCH] [execution] Use uint8_t instead of byte

Byte is an alias for the standard uint8_t type (defined in
src/common/globals.h).
For readability, avoid the alias and use the uint8_t directly.

R=jkummerow@chromium.org

Change-Id: Icf875df86a538ef1ed911b1f1b375b889d8131cd
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4523173
Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#87621}
---
 src/execution/arm/simulator-arm.cc         | 25 +++++++-------
 src/execution/arm64/simulator-arm64.cc     |  4 +--
 src/execution/interrupts-scope.h           |  2 +-
 src/execution/loong64/simulator-loong64.cc | 27 +++++++--------
 src/execution/mips64/simulator-mips64.cc   | 27 +++++++--------
 src/execution/ppc/simulator-ppc.cc         | 21 ++++++------
 src/execution/riscv/simulator-riscv.cc     | 39 +++++++++++-----------
 src/execution/s390/simulator-s390.cc       | 31 ++++++++---------
 src/execution/simulator.h                  |  2 +-
 9 files changed, 92 insertions(+), 86 deletions(-)

diff --git a/src/execution/arm/simulator-arm.cc b/src/execution/arm/simulator-arm.cc
index 9dafdc7d3c3..36556c748bb 100644
--- a/src/execution/arm/simulator-arm.cc
+++ b/src/execution/arm/simulator-arm.cc
@@ -203,7 +203,8 @@ void ArmDebugger::Debug() {
       disasm::Disassembler dasm(converter);
       // use a reasonably large buffer
       v8::base::EmbeddedVector<char, 256> buffer;
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
+      dasm.InstructionDecode(buffer,
+                             reinterpret_cast<uint8_t*>(sim_->get_pc()));
       PrintF("  0x%08x  %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
     }
@@ -377,12 +378,12 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
     // use a reasonably large buffer
     v8::base::EmbeddedVector<char, 256> buffer;
 
-    byte* prev = nullptr;
-    byte* cur = nullptr;
-    byte* end = nullptr;
+    uint8_t* prev = nullptr;
+    uint8_t* cur = nullptr;
+    uint8_t* end = nullptr;
 
     if (argc == 1) {
-      cur = reinterpret_cast<byte*>(sim_->get_pc());
+      cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
       end = cur + (10 * kInstrSize);
     } else if (argc == 2) {
       int regnum = Registers::Number(arg1);
@@ -390,7 +391,7 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
         // The argument is an address or a register name.
         int32_t value;
         if (GetValue(arg1, &value)) {
-          cur = reinterpret_cast<byte*>(value);
+          cur = reinterpret_cast<uint8_t*>(value);
           // Disassemble 10 instructions at <arg1>.
           end = cur + (10 * kInstrSize);
         }
@@ -398,7 +399,7 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
         // The argument is the number of instructions.
         int32_t value;
         if (GetValue(arg1, &value)) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           // Disassemble <arg1> instructions.
           end = cur + (value * kInstrSize);
         }
@@ -407,7 +408,7 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
       int32_t value1;
       int32_t value2;
       if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-        cur = reinterpret_cast<byte*>(value1);
+        cur = reinterpret_cast<uint8_t*>(value1);
         end = cur + (value2 * kInstrSize);
       }
     }
@@ -2652,10 +2653,10 @@ void Simulator::DecodeType2(Instruction* instr) {
   }
   if (instr->HasB()) {
     if (instr->HasL()) {
-      byte val = ReadBU(addr);
+      uint8_t val = ReadBU(addr);
       set_register(rd, val);
     } else {
-      byte val = get_register(rd);
+      uint8_t val = get_register(rd);
       WriteB(addr, val);
     }
   } else {
@@ -4072,7 +4073,7 @@ uint16_t Multiply(uint16_t a, uint16_t b) {
 }
 
 void VmovImmediate(Simulator* simulator, Instruction* instr) {
-  byte cmode = instr->Bits(11, 8);
+  uint8_t cmode = instr->Bits(11, 8);
   int vd = instr->VFPDRegValue(kDoublePrecision);
   int q = instr->Bit(6);
   int regs = q ? 2 : 1;
@@ -6117,7 +6118,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     disasm::Disassembler dasm(converter);
     // use a reasonably large buffer
     v8::base::EmbeddedVector<char, 256> buffer;
-    dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
+    dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(instr));
     PrintF("  0x%08" V8PRIxPTR "  %s\n", reinterpret_cast<intptr_t>(instr),
            buffer.begin());
   }
diff --git a/src/execution/arm64/simulator-arm64.cc b/src/execution/arm64/simulator-arm64.cc
index 6a02823d141..16cec5b8865 100644
--- a/src/execution/arm64/simulator-arm64.cc
+++ b/src/execution/arm64/simulator-arm64.cc
@@ -358,7 +358,7 @@ void Simulator::Init(FILE* stream) {
 
   // Allocate and setup the simulator stack.
   stack_size_ = (v8_flags.sim_stack_size * KB) + (2 * stack_protection_size_);
-  stack_ = reinterpret_cast<uintptr_t>(new byte[stack_size_]);
+  stack_ = reinterpret_cast<uintptr_t>(new uint8_t[stack_size_]);
   stack_limit_ = stack_ + stack_protection_size_;
   uintptr_t tos = stack_ + stack_size_ - stack_protection_size_;
   // The stack pointer must be 16-byte aligned.
@@ -399,7 +399,7 @@ void Simulator::ResetState() {
 
 Simulator::~Simulator() {
   GlobalMonitor::Get()->RemoveProcessor(&global_monitor_processor_);
-  delete[] reinterpret_cast<byte*>(stack_);
+  delete[] reinterpret_cast<uint8_t*>(stack_);
   delete disassembler_decoder_;
   delete print_disasm_;
   delete decoder_;
diff --git a/src/execution/interrupts-scope.h b/src/execution/interrupts-scope.h
index 29de448ad6c..8be3ce989aa 100644
--- a/src/execution/interrupts-scope.h
+++ b/src/execution/interrupts-scope.h
@@ -17,7 +17,7 @@ class Isolate;
 // not affect other interrupts.
 class V8_NODISCARD InterruptsScope {
  public:
-  enum Mode : byte { kPostponeInterrupts, kRunInterrupts, kNoop };
+  enum Mode : uint8_t { kPostponeInterrupts, kRunInterrupts, kNoop };
 
   V8_EXPORT_PRIVATE InterruptsScope(Isolate* isolate, uint32_t intercept_mask,
                                     Mode mode)
diff --git a/src/execution/loong64/simulator-loong64.cc b/src/execution/loong64/simulator-loong64.cc
index 977f7c4aed7..24fa20dd338 100644
--- a/src/execution/loong64/simulator-loong64.cc
+++ b/src/execution/loong64/simulator-loong64.cc
@@ -317,7 +317,8 @@ void Loong64Debugger::Debug() {
       disasm::Disassembler dasm(converter);
       // Use a reasonably large buffer.
       v8::base::EmbeddedVector<char, 256> buffer;
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
+      dasm.InstructionDecode(buffer,
+                             reinterpret_cast<uint8_t*>(sim_->get_pc()));
       PrintF("  0x%016" PRIx64 "   %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
     }
@@ -479,11 +480,11 @@ void Loong64Debugger::Debug() {
         // Use a reasonably large buffer.
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* cur = nullptr;
-        byte* end = nullptr;
+        uint8_t* cur = nullptr;
+        uint8_t* end = nullptr;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           end = cur + (10 * kInstrSize);
         } else if (argc == 2) {
           int regnum = Registers::Number(arg1);
@@ -491,7 +492,7 @@ void Loong64Debugger::Debug() {
             // The argument is an address or a register name.
             int64_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(value);
+              cur = reinterpret_cast<uint8_t*>(value);
               // Disassemble 10 instructions at <arg1>.
               end = cur + (10 * kInstrSize);
             }
@@ -499,7 +500,7 @@ void Loong64Debugger::Debug() {
             // The argument is the number of instructions.
             int64_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(sim_->get_pc());
+              cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
               // Disassemble <arg1> instructions.
               end = cur + (value * kInstrSize);
             }
@@ -508,7 +509,7 @@ void Loong64Debugger::Debug() {
           int64_t value1;
           int64_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             end = cur + (value2 * kInstrSize);
           }
         }
@@ -608,16 +609,16 @@ void Loong64Debugger::Debug() {
         // Use a reasonably large buffer.
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* cur = nullptr;
-        byte* end = nullptr;
+        uint8_t* cur = nullptr;
+        uint8_t* end = nullptr;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           end = cur + (10 * kInstrSize);
         } else if (argc == 2) {
           int64_t value;
           if (GetValue(arg1, &value)) {
-            cur = reinterpret_cast<byte*>(value);
+            cur = reinterpret_cast<uint8_t*>(value);
             // no length parameter passed, assume 10 instructions
             end = cur + (10 * kInstrSize);
           }
@@ -625,7 +626,7 @@ void Loong64Debugger::Debug() {
           int64_t value1;
           int64_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             end = cur + (value2 * kInstrSize);
           }
         }
@@ -5277,7 +5278,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // Use a reasonably large buffer.
-    dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
+    dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(instr));
   }
 
   static int instr_count = 0;
diff --git a/src/execution/mips64/simulator-mips64.cc b/src/execution/mips64/simulator-mips64.cc
index e3e1c9f3f5e..d012ba5d444 100644
--- a/src/execution/mips64/simulator-mips64.cc
+++ b/src/execution/mips64/simulator-mips64.cc
@@ -304,7 +304,8 @@ void MipsDebugger::Debug() {
       disasm::Disassembler dasm(converter);
       // Use a reasonably large buffer.
       v8::base::EmbeddedVector<char, 256> buffer;
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
+      dasm.InstructionDecode(buffer,
+                             reinterpret_cast<uint8_t*>(sim_->get_pc()));
       PrintF("  0x%016" PRIx64 "   %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
     }
@@ -466,11 +467,11 @@ void MipsDebugger::Debug() {
         // Use a reasonably large buffer.
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* cur = nullptr;
-        byte* end = nullptr;
+        uint8_t* cur = nullptr;
+        uint8_t* end = nullptr;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           end = cur + (10 * kInstrSize);
         } else if (argc == 2) {
           int regnum = Registers::Number(arg1);
@@ -478,7 +479,7 @@ void MipsDebugger::Debug() {
             // The argument is an address or a register name.
             int64_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(value);
+              cur = reinterpret_cast<uint8_t*>(value);
               // Disassemble 10 instructions at <arg1>.
               end = cur + (10 * kInstrSize);
             }
@@ -486,7 +487,7 @@ void MipsDebugger::Debug() {
             // The argument is the number of instructions.
             int64_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(sim_->get_pc());
+              cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
               // Disassemble <arg1> instructions.
               end = cur + (value * kInstrSize);
             }
@@ -495,7 +496,7 @@ void MipsDebugger::Debug() {
           int64_t value1;
           int64_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             end = cur + (value2 * kInstrSize);
           }
         }
@@ -595,16 +596,16 @@ void MipsDebugger::Debug() {
         // Use a reasonably large buffer.
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* cur = nullptr;
-        byte* end = nullptr;
+        uint8_t* cur = nullptr;
+        uint8_t* end = nullptr;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           end = cur + (10 * kInstrSize);
         } else if (argc == 2) {
           int64_t value;
           if (GetValue(arg1, &value)) {
-            cur = reinterpret_cast<byte*>(value);
+            cur = reinterpret_cast<uint8_t*>(value);
             // no length parameter passed, assume 10 instructions
             end = cur + (10 * kInstrSize);
           }
@@ -612,7 +613,7 @@ void MipsDebugger::Debug() {
           int64_t value1;
           int64_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             end = cur + (value2 * kInstrSize);
           }
         }
@@ -7471,7 +7472,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // Use a reasonably large buffer.
-    dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
+    dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(instr));
   }
 
   instr_ = instr;
diff --git a/src/execution/ppc/simulator-ppc.cc b/src/execution/ppc/simulator-ppc.cc
index 8ab0afe17dd..223f2c0a004 100644
--- a/src/execution/ppc/simulator-ppc.cc
+++ b/src/execution/ppc/simulator-ppc.cc
@@ -192,7 +192,8 @@ void PPCDebugger::Debug() {
       disasm::Disassembler dasm(converter);
       // use a reasonably large buffer
       v8::base::EmbeddedVector<char, 256> buffer;
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
+      dasm.InstructionDecode(buffer,
+                             reinterpret_cast<uint8_t*>(sim_->get_pc()));
       PrintF("  0x%08" V8PRIxPTR "  %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
     }
@@ -233,7 +234,7 @@ void PPCDebugger::Debug() {
             // use a reasonably large buffer
             v8::base::EmbeddedVector<char, 256> buffer;
             dasm.InstructionDecode(buffer,
-                                   reinterpret_cast<byte*>(sim_->get_pc()));
+                                   reinterpret_cast<uint8_t*>(sim_->get_pc()));
             PrintF("  0x%08" V8PRIxPTR "  %s\n", sim_->get_pc(),
                    buffer.begin());
             sim_->ExecuteInstruction(
@@ -414,12 +415,12 @@ void PPCDebugger::Debug() {
         // use a reasonably large buffer
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* prev = nullptr;
-        byte* cur = nullptr;
-        byte* end = nullptr;
+        uint8_t* prev = nullptr;
+        uint8_t* cur = nullptr;
+        uint8_t* end = nullptr;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           end = cur + (10 * kInstrSize);
         } else if (argc == 2) {
           int regnum = Registers::Number(arg1);
@@ -427,7 +428,7 @@ void PPCDebugger::Debug() {
             // The argument is an address or a register name.
             intptr_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(value);
+              cur = reinterpret_cast<uint8_t*>(value);
               // Disassemble 10 instructions at <arg1>.
               end = cur + (10 * kInstrSize);
             }
@@ -435,7 +436,7 @@ void PPCDebugger::Debug() {
             // The argument is the number of instructions.
             intptr_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(sim_->get_pc());
+              cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
               // Disassemble <arg1> instructions.
               end = cur + (value * kInstrSize);
             }
@@ -444,7 +445,7 @@ void PPCDebugger::Debug() {
           intptr_t value1;
           intptr_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             end = cur + (value2 * kInstrSize);
           }
         }
@@ -5422,7 +5423,7 @@ void Simulator::Trace(Instruction* instr) {
   disasm::Disassembler dasm(converter);
   // use a reasonably large buffer
   v8::base::EmbeddedVector<char, 256> buffer;
-  dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
+  dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(instr));
   PrintF("%05d  %08" V8PRIxPTR "  %s\n", icount_,
          reinterpret_cast<intptr_t>(instr), buffer.begin());
 }
diff --git a/src/execution/riscv/simulator-riscv.cc b/src/execution/riscv/simulator-riscv.cc
index 9da1321a18d..7e43f92cf47 100644
--- a/src/execution/riscv/simulator-riscv.cc
+++ b/src/execution/riscv/simulator-riscv.cc
@@ -1544,7 +1544,7 @@ uint32_t get_fcsr_condition_bit(uint32_t cc) {
 // field of a subsequent LUI instruction; otherwise returns -1
 static inline int32_t get_ebreak_code(Instruction* instr) {
   DCHECK(instr->InstructionBits() == kBreakInstr);
-  byte* cur = reinterpret_cast<byte*>(instr);
+  uint8_t* cur = reinterpret_cast<uint8_t*>(instr);
   Instruction* next_instr = reinterpret_cast<Instruction*>(cur + kInstrSize);
   if (next_instr->BaseOpcodeFieldRaw() == LUI)
     return (next_instr->Imm20UValue());
@@ -1589,7 +1589,7 @@ class RiscvDebugger {
   v8::base::EmbeddedVector<char, 256> buffer;                          \
   disasm::NameConverter converter;                                     \
   disasm::Disassembler dasm(converter);                                \
-  dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(&instr_));    \
+  dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(&instr_)); \
   printf("Sim: Unsupported inst. Func:%s Line:%d PC:0x%" REGIx_FORMAT, \
          __FUNCTION__, __LINE__, get_pc());                            \
   PrintF(" %-44s\n", buffer.begin());                                  \
@@ -1755,7 +1755,8 @@ void RiscvDebugger::Debug() {
       if (name != nullptr) {
         PrintF("Call builtin:  %s\n", name);
       }
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
+      dasm.InstructionDecode(buffer,
+                             reinterpret_cast<uint8_t*>(sim_->get_pc()));
       PrintF("  0x%016" REGIx_FORMAT "   %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
     }
@@ -1974,11 +1975,11 @@ void RiscvDebugger::Debug() {
         // Use a reasonably large buffer.
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* cur = nullptr;
-        byte* end = nullptr;
+        uint8_t* cur = nullptr;
+        uint8_t* end = nullptr;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           end = cur + (10 * kInstrSize);
         } else if (argc == 2) {
           int regnum = Registers::Number(arg1);
@@ -1986,7 +1987,7 @@ void RiscvDebugger::Debug() {
             // The argument is an address or a register name.
             sreg_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(value);
+              cur = reinterpret_cast<uint8_t*>(value);
               // Disassemble 10 instructions at <arg1>.
               end = cur + (10 * kInstrSize);
             }
@@ -1994,7 +1995,7 @@ void RiscvDebugger::Debug() {
             // The argument is the number of instructions.
             sreg_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(sim_->get_pc());
+              cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
               // Disassemble <arg1> instructions.
               end = cur + (value * kInstrSize);
             }
@@ -2003,7 +2004,7 @@ void RiscvDebugger::Debug() {
           sreg_t value1;
           sreg_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             end = cur + (value2 * kInstrSize);
           }
         }
@@ -2095,16 +2096,16 @@ void RiscvDebugger::Debug() {
         // Use a reasonably large buffer.
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* cur = nullptr;
-        byte* end = nullptr;
+        uint8_t* cur = nullptr;
+        uint8_t* end = nullptr;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
           end = cur + (10 * kInstrSize);
         } else if (argc == 2) {
           sreg_t value;
           if (GetValue(arg1, &value)) {
-            cur = reinterpret_cast<byte*>(value);
+            cur = reinterpret_cast<uint8_t*>(value);
             // no length parameter passed, assume 10 instructions
             end = cur + (10 * kInstrSize);
           }
@@ -2112,7 +2113,7 @@ void RiscvDebugger::Debug() {
           sreg_t value1;
           sreg_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             end = cur + (value2 * kInstrSize);
           }
         }
@@ -5769,7 +5770,7 @@ void Simulator::DecodeRvvIVV() {
       // disasm::NameConverter converter;
       // disasm::Disassembler dasm(converter);
       // // Use a reasonably large buffer.
-      // dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(&instr_));
+      // dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(&instr_));
 
       // PrintF("EXECUTING  0x%08" PRIxPTR "   %-44s\n",
       //        reinterpret_cast<intptr_t>(&instr_), buffer.begin());
@@ -6344,7 +6345,7 @@ void Simulator::DecodeRvvMVV() {
         v8::base::EmbeddedVector<char, 256> buffer;
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
-        dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(&instr_));
+        dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(&instr_));
         PrintF("EXECUTING  0x%08" PRIxPTR "   %-44s\n",
                reinterpret_cast<intptr_t>(&instr_), buffer.begin());
         UNIMPLEMENTED_RISCV();
@@ -6440,7 +6441,7 @@ void Simulator::DecodeRvvMVV() {
       v8::base::EmbeddedVector<char, 256> buffer;
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(&instr_));
+      dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(&instr_));
       PrintF("EXECUTING  0x%08" PRIxPTR "   %-44s\n",
              reinterpret_cast<intptr_t>(&instr_), buffer.begin());
       UNIMPLEMENTED_RISCV();
@@ -6548,7 +6549,7 @@ void Simulator::DecodeRvvMVX() {
       v8::base::EmbeddedVector<char, 256> buffer;
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(&instr_));
+      dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(&instr_));
       PrintF("EXECUTING  0x%08" PRIxPTR "   %-44s\n",
              reinterpret_cast<intptr_t>(&instr_), buffer.begin());
       UNIMPLEMENTED_RISCV();
@@ -7516,7 +7517,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // Use a reasonably large buffer.
-    dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
+    dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(instr));
 
     // PrintF("EXECUTING  0x%08" PRIxPTR "   %-44s\n",
     //        reinterpret_cast<intptr_t>(instr), buffer.begin());
diff --git a/src/execution/s390/simulator-s390.cc b/src/execution/s390/simulator-s390.cc
index 38d0012f103..82ae73e0e2c 100644
--- a/src/execution/s390/simulator-s390.cc
+++ b/src/execution/s390/simulator-s390.cc
@@ -202,7 +202,8 @@ void S390Debugger::Debug() {
       disasm::Disassembler dasm(converter);
       // use a reasonably large buffer
       v8::base::EmbeddedVector<char, 256> buffer;
-      dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
+      dasm.InstructionDecode(buffer,
+                             reinterpret_cast<uint8_t*>(sim_->get_pc()));
       PrintF("  0x%08" V8PRIxPTR "  %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
     }
@@ -246,8 +247,8 @@ void S390Debugger::Debug() {
             // Interpret a numeric argument as the number of instructions to
             // step past.
             for (int i = 1; (!sim_->has_bad_pc()) && i < value; i++) {
-              dasm.InstructionDecode(buffer,
-                                     reinterpret_cast<byte*>(sim_->get_pc()));
+              dasm.InstructionDecode(
+                  buffer, reinterpret_cast<uint8_t*>(sim_->get_pc()));
               PrintF("  0x%08" V8PRIxPTR "  %s\n", sim_->get_pc(),
                      buffer.begin());
               sim_->ExecuteInstruction(
@@ -257,8 +258,8 @@ void S390Debugger::Debug() {
             // Otherwise treat it as the mnemonic of the opcode to stop at.
             char mnemonic[256];
             while (!sim_->has_bad_pc()) {
-              dasm.InstructionDecode(buffer,
-                                     reinterpret_cast<byte*>(sim_->get_pc()));
+              dasm.InstructionDecode(
+                  buffer, reinterpret_cast<uint8_t*>(sim_->get_pc()));
               char* mnemonicStart = buffer.begin();
               while (*mnemonicStart != 0 && *mnemonicStart != ' ')
                 mnemonicStart++;
@@ -443,26 +444,26 @@ void S390Debugger::Debug() {
         // use a reasonably large buffer
         v8::base::EmbeddedVector<char, 256> buffer;
 
-        byte* prev = nullptr;
-        byte* cur = nullptr;
+        uint8_t* prev = nullptr;
+        uint8_t* cur = nullptr;
         // Default number of instructions to disassemble.
         int32_t numInstructions = 10;
 
         if (argc == 1) {
-          cur = reinterpret_cast<byte*>(sim_->get_pc());
+          cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
         } else if (argc == 2) {
           int regnum = Registers::Number(arg1);
           if (regnum != kNoRegister || strncmp(arg1, "0x", 2) == 0) {
             // The argument is an address or a register name.
             intptr_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(value);
+              cur = reinterpret_cast<uint8_t*>(value);
             }
           } else {
             // The argument is the number of instructions.
             intptr_t value;
             if (GetValue(arg1, &value)) {
-              cur = reinterpret_cast<byte*>(sim_->get_pc());
+              cur = reinterpret_cast<uint8_t*>(sim_->get_pc());
               // Disassemble <arg1> instructions.
               numInstructions = static_cast<int32_t>(value);
             }
@@ -471,7 +472,7 @@ void S390Debugger::Debug() {
           intptr_t value1;
           intptr_t value2;
           if (GetValue(arg1, &value1) && GetValue(arg2, &value2)) {
-            cur = reinterpret_cast<byte*>(value1);
+            cur = reinterpret_cast<uint8_t*>(value1);
             // Disassemble <arg2> instructions.
             numInstructions = static_cast<int32_t>(value2);
           }
@@ -2445,7 +2446,7 @@ void Simulator::ExecuteInstruction(Instruction* instr, bool auto_incr_pc) {
     disasm::Disassembler dasm(converter);
     // use a reasonably large buffer
     v8::base::EmbeddedVector<char, 256> buffer;
-    dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
+    dasm.InstructionDecode(buffer, reinterpret_cast<uint8_t*>(instr));
     PrintF("%05" PRId64 "  %08" V8PRIxPTR "  %s\n", icount_,
            reinterpret_cast<intptr_t>(instr), buffer.begin());
 
@@ -5294,16 +5295,16 @@ EVALUATE(EX) {
   int32_t r1_val = get_low_register<int32_t>(r1);
 
   SixByteInstr the_instr = Instruction::InstructionBits(
-      reinterpret_cast<const byte*>(b2_val + x2_val + d2_val));
+      reinterpret_cast<const uint8_t*>(b2_val + x2_val + d2_val));
   int inst_length = Instruction::InstructionLength(
-      reinterpret_cast<const byte*>(b2_val + x2_val + d2_val));
+      reinterpret_cast<const uint8_t*>(b2_val + x2_val + d2_val));
 
   char new_instr_buf[8];
   char* addr = reinterpret_cast<char*>(&new_instr_buf[0]);
   the_instr |= static_cast<SixByteInstr>(r1_val & 0xFF)
                << (8 * inst_length - 16);
   Instruction::SetInstructionBits<SixByteInstr>(
-      reinterpret_cast<byte*>(addr), static_cast<SixByteInstr>(the_instr));
+      reinterpret_cast<uint8_t*>(addr), static_cast<SixByteInstr>(the_instr));
   ExecuteInstruction(reinterpret_cast<Instruction*>(addr), false);
   return length;
 }
diff --git a/src/execution/simulator.h b/src/execution/simulator.h
index 84708083cd6..1d176f412a0 100644
--- a/src/execution/simulator.h
+++ b/src/execution/simulator.h
@@ -106,7 +106,7 @@ class GeneratedCode {
     return GeneratedCode(isolate, reinterpret_cast<Signature*>(addr));
   }
 
-  static GeneratedCode FromBuffer(Isolate* isolate, byte* buffer) {
+  static GeneratedCode FromBuffer(Isolate* isolate, uint8_t* buffer) {
     return GeneratedCode(isolate, reinterpret_cast<Signature*>(buffer));
   }
 
-- 
2.35.1


From 407317a284d872957395f7d4229bc3b20589e18b Mon Sep 17 00:00:00 2001
From: Camillo Bruni <cbruni@chromium.org>
Date: Mon, 14 Jun 2021 11:18:22 +0200
Subject: [PATCH] [runtime] Rename Builtins::Name to Builtin 2/2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Convert Builtin to enum class
- Change int-based builtin_index methods to use Builtin
- Change Builtins::builtin to Builtins::code

Change-Id: Id9e3bb83da97e8894ca7ca78e1e852da60675619
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2949104
Commit-Queue: Camillo Bruni <cbruni@chromium.org>
Reviewed-by: Igor Sheludko <ishell@chromium.org>
Reviewed-by: Mythri Alle <mythria@chromium.org>
Reviewed-by: Dominik Inf√ºhr <dinfuehr@chromium.org>
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Reviewed-by: Jakob Gruber <jgruber@chromium.org>
Cr-Commit-Position: refs/heads/master@{#75127}
---
 src/api/api.cc                                |   2 +-
 src/asmjs/asm-js.cc                           |   2 +-
 src/builtins/arm/builtins-arm.cc              |   6 +-
 src/builtins/arm64/builtins-arm64.cc          |   6 +-
 src/builtins/builtins-console.cc              |   6 +-
 src/builtins/builtins-constructor-gen.cc      |   2 +-
 src/builtins/builtins-intl.cc                 |   6 +-
 src/builtins/builtins-regexp-gen.cc           |   6 +-
 src/builtins/builtins.cc                      | 148 +++++++++---------
 src/builtins/builtins.h                       |  63 +++++---
 src/builtins/constants-table-builder.cc       |   2 +-
 src/builtins/ia32/builtins-ia32.cc            |   6 +-
 src/builtins/mips/builtins-mips.cc            |   6 +-
 src/builtins/mips64/builtins-mips64.cc        |   6 +-
 src/builtins/ppc/builtins-ppc.cc              |   6 +-
 src/builtins/riscv64/builtins-riscv64.cc      |   6 +-
 src/builtins/s390/builtins-s390.cc            |   6 +-
 src/builtins/setup-builtins-internal.cc       | 142 +++++++++--------
 src/builtins/x64/builtins-x64.cc              |   6 +-
 src/codegen/arm/macro-assembler-arm.cc        |  45 +++---
 src/codegen/arm/macro-assembler-arm.h         |   8 +-
 src/codegen/arm64/macro-assembler-arm64.cc    |  53 +++----
 src/codegen/arm64/macro-assembler-arm64.h     |  22 +--
 src/codegen/code-factory.cc                   |  41 +++--
 src/codegen/external-reference.cc             |   3 +-
 src/codegen/ia32/macro-assembler-ia32.cc      |  50 +++---
 src/codegen/ia32/macro-assembler-ia32.h       |   4 +-
 src/codegen/mips/macro-assembler-mips.cc      |  22 +--
 src/codegen/mips64/macro-assembler-mips64.cc  |   4 +-
 src/codegen/optimized-compilation-info.h      |   6 +-
 src/codegen/ppc/macro-assembler-ppc.cc        |   8 +-
 src/codegen/reloc-info.cc                     |  12 +-
 .../riscv64/macro-assembler-riscv64.cc        |   8 +-
 src/codegen/s390/macro-assembler-s390.cc      |   4 +-
 src/codegen/turbo-assembler.cc                |  15 +-
 src/codegen/turbo-assembler.h                 |  10 +-
 src/codegen/x64/macro-assembler-x64.cc        |  54 +++----
 src/codegen/x64/macro-assembler-x64.h         |  12 +-
 .../backend/arm/code-generator-arm.cc         |   2 +-
 .../backend/arm64/code-generator-arm64.cc     |   2 +-
 src/compiler/backend/code-generator.cc        |  11 +-
 src/compiler/backend/code-generator.h         |   2 +-
 .../backend/ia32/code-generator-ia32.cc       |   2 +-
 .../backend/mips/code-generator-mips.cc       |   2 +-
 .../backend/mips64/code-generator-mips64.cc   |   2 +-
 .../backend/ppc/code-generator-ppc.cc         |   2 +-
 .../backend/riscv64/code-generator-riscv64.cc |   2 +-
 .../backend/s390/code-generator-s390.cc       |   2 +-
 .../backend/x64/code-generator-x64.cc         |   2 +-
 src/compiler/bytecode-graph-builder.cc        |   2 +-
 src/compiler/code-assembler.cc                |  23 ++-
 src/compiler/code-assembler.h                 |   8 +-
 src/compiler/heap-refs.cc                     |   6 +-
 src/compiler/heap-refs.h                      |   2 +-
 src/compiler/js-call-reducer.cc               |  26 +--
 src/compiler/js-generic-lowering.cc           |  16 +-
 src/compiler/js-typed-lowering.cc             |  12 +-
 src/compiler/pipeline.cc                      |   6 +-
 src/compiler/pipeline.h                       |   2 +-
 .../serializer-for-background-compilation.cc  |  34 ++--
 src/compiler/wasm-compiler.cc                 |   8 +-
 src/debug/debug-evaluate.cc                   |  17 +-
 src/debug/debug-interface.cc                  |   8 +-
 src/debug/debug.cc                            |  10 +-
 src/deoptimizer/deoptimizer.cc                |  29 ++--
 src/diagnostics/disassembler.cc               |   9 +-
 src/diagnostics/objects-debug.cc              |   8 +-
 src/diagnostics/objects-printer.cc            |   6 +-
 src/execution/frames.cc                       |  18 +--
 src/execution/isolate-data.h                  |   9 +-
 src/execution/isolate.cc                      |  25 +--
 src/execution/isolate.h                       |   2 +-
 src/heap/factory-base.cc                      |   8 +-
 src/heap/factory-base.h                       |   3 +-
 src/heap/factory.cc                           |  12 +-
 src/heap/factory.h                            |  10 +-
 src/heap/heap.cc                              |  31 ++--
 src/heap/heap.h                               |   6 +-
 src/heap/setup-heap-internal.cc               |   4 +-
 src/ic/stub-cache.cc                          |   4 +-
 src/init/bootstrapper.cc                      |  38 ++---
 src/init/setup-isolate.h                      |   3 +-
 src/interpreter/interpreter-generator.cc      |   4 +-
 src/interpreter/interpreter-generator.h       |   5 +-
 src/interpreter/interpreter.cc                |  19 +--
 src/logging/log.cc                            |   6 +-
 src/objects/code-inl.h                        |  49 +++---
 src/objects/code.cc                           |  22 +--
 src/objects/code.h                            |   7 +-
 src/objects/feedback-vector.cc                |  18 +--
 src/objects/js-function-inl.h                 |   6 +-
 src/objects/js-function.cc                    |   2 +-
 src/objects/objects.cc                        |   2 +-
 src/objects/shared-function-info-inl.h        |  12 +-
 src/objects/shared-function-info.cc           |  10 +-
 src/objects/shared-function-info.h            |   7 +-
 src/profiler/cpu-profiler-inl.h               |   8 +-
 src/profiler/cpu-profiler.cc                  |   8 +-
 src/profiler/cpu-profiler.h                   |   2 +-
 src/profiler/profile-generator-inl.h          |   2 +-
 src/profiler/profile-generator.cc             |   2 +-
 src/profiler/profile-generator.h              |   6 +-
 src/profiler/symbolizer.cc                    |   4 +-
 src/runtime/runtime-compiler.cc               |   4 +-
 src/runtime/runtime-test-wasm.cc              |   2 +-
 src/snapshot/deserializer.cc                  |   5 +-
 src/snapshot/embedded/embedded-data.cc        |  95 ++++++-----
 src/snapshot/embedded/embedded-data.h         |  12 +-
 .../embedded/embedded-file-writer-interface.h |   2 +-
 src/snapshot/embedded/embedded-file-writer.cc |  29 ++--
 src/snapshot/embedded/embedded-file-writer.h  |   8 +-
 .../platform-embedded-file-writer-win.cc      |  13 +-
 src/snapshot/serializer.cc                    |   2 +-
 src/snapshot/startup-serializer.cc            |   2 +-
 src/wasm/function-compiler.cc                 |   3 +-
 src/wasm/wasm-objects.cc                      |   6 +-
 test/cctest/heap/test-alloc.cc                |   2 +-
 test/cctest/interpreter/test-interpreter.cc   |   8 +-
 test/cctest/test-debug.cc                     |   9 +-
 test/cctest/test-log.cc                       |   2 +-
 test/cctest/test-swiss-name-dictionary-csa.cc |   6 +-
 test/cctest/test-unwinder-code-pages.cc       |   4 +-
 test/cctest/wasm/test-run-wasm-wrappers.cc    |   2 +-
 123 files changed, 850 insertions(+), 817 deletions(-)

diff --git a/src/api/api.cc b/src/api/api.cc
index c7f9959cfd9..d7c12d669c8 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -6117,7 +6117,7 @@ Local<Context> NewContext(
   // TODO(jkummerow): This is for crbug.com/713699. Remove it if it doesn't
   // fail.
   // Sanity-check that the isolate is initialized and usable.
-  CHECK(isolate->builtins()->builtin(i::Builtin::kIllegal).IsCode());
+  CHECK(isolate->builtins()->code(i::Builtin::kIllegal).IsCode());
 
   TRACE_EVENT_CALL_STATS_SCOPED(isolate, "v8", "V8.NewContext");
   LOG_API(isolate, Context, New);
diff --git a/src/asmjs/asm-js.cc b/src/asmjs/asm-js.cc
index 4ee94c05f2d..a4ececfa6eb 100644
--- a/src/asmjs/asm-js.cc
+++ b/src/asmjs/asm-js.cc
@@ -78,7 +78,7 @@ bool AreStdlibMembersValid(Isolate* isolate, Handle<JSReceiver> stdlib,
       return false;                                                        \
     }                                                                      \
     DCHECK_EQ(shared.GetCode(),                                            \
-              isolate->builtins()->builtin(Builtin::kMath##FName));        \
+              isolate->builtins()->code(Builtin::kMath##FName));           \
   }
   STDLIB_MATH_FUNCTION_LIST(STDLIB_MATH_FUNC)
 #undef STDLIB_MATH_FUNC
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index a6ddae40240..66aca724e0c 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -611,7 +611,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // Invoke the function by calling through JS entry trampoline builtin and
   // pop the faked function when we return.
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   DCHECK_EQ(kPushedStackSpace, pushed_stack_space);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
@@ -3672,14 +3672,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index dcd85f74d2f..ced6177fe47 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -759,7 +759,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // Invoke the function by calling through JS entry trampoline builtin and
   // pop the faked function when we return.
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
   // Pop the stack handler and unlink this frame from the handler chain.
@@ -4197,14 +4197,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ Bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/builtins-console.cc b/src/builtins/builtins-console.cc
index 83e2ef08913..21841e382ca 100644
--- a/src/builtins/builtins-console.cc
+++ b/src/builtins/builtins-console.cc
@@ -125,8 +125,8 @@ BUILTIN(ConsoleTimeStamp) {
 namespace {
 
 void InstallContextFunction(Isolate* isolate, Handle<JSObject> target,
-                            const char* name, Builtin builtin_id,
-                            int context_id, Handle<Object> context_name) {
+                            const char* name, Builtin builtin, int context_id,
+                            Handle<Object> context_name) {
   Factory* const factory = isolate->factory();
 
   Handle<NativeContext> context(isolate->native_context());
@@ -136,7 +136,7 @@ void InstallContextFunction(Isolate* isolate, Handle<JSObject> target,
       Name::ToFunctionName(isolate, factory->InternalizeUtf8String(name))
           .ToHandleChecked();
   Handle<SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name_string, builtin_id);
+      factory->NewSharedFunctionInfoForBuiltin(name_string, builtin);
   info->set_language_mode(LanguageMode::kSloppy);
 
   Handle<JSFunction> fun =
diff --git a/src/builtins/builtins-constructor-gen.cc b/src/builtins/builtins-constructor-gen.cc
index 29b3bc31254..9d2723f4d3d 100644
--- a/src/builtins/builtins-constructor-gen.cc
+++ b/src/builtins/builtins-constructor-gen.cc
@@ -255,7 +255,7 @@ TF_BUILTIN(FastNewClosure, ConstructorBuiltinsAssembler) {
                                  shared_function_info);
   StoreObjectFieldNoWriteBarrier(result, JSFunction::kContextOffset, context);
   Handle<Code> lazy_builtin_handle =
-      isolate()->builtins()->builtin_handle(Builtin::kCompileLazy);
+      isolate()->builtins()->code_handle(Builtin::kCompileLazy);
   TNode<Code> lazy_builtin = HeapConstant(lazy_builtin_handle);
   StoreObjectFieldNoWriteBarrier(result, JSFunction::kCodeOffset, lazy_builtin);
   Return(result);
diff --git a/src/builtins/builtins-intl.cc b/src/builtins/builtins-intl.cc
index 8e56a93b950..c3711898c30 100644
--- a/src/builtins/builtins-intl.cc
+++ b/src/builtins/builtins-intl.cc
@@ -222,8 +222,8 @@ BUILTIN(DateTimeFormatPrototypeFormatRangeToParts) {
 namespace {
 
 Handle<JSFunction> CreateBoundFunction(Isolate* isolate,
-                                       Handle<JSObject> object,
-                                       Builtin builtin_id, int len) {
+                                       Handle<JSObject> object, Builtin builtin,
+                                       int len) {
   Handle<NativeContext> native_context(isolate->context().native_context(),
                                        isolate);
   Handle<Context> context = isolate->factory()->NewBuiltinContext(
@@ -235,7 +235,7 @@ Handle<JSFunction> CreateBoundFunction(Isolate* isolate,
 
   Handle<SharedFunctionInfo> info =
       isolate->factory()->NewSharedFunctionInfoForBuiltin(
-          isolate->factory()->empty_string(), builtin_id, kNormalFunction);
+          isolate->factory()->empty_string(), builtin, kNormalFunction);
   info->set_internal_formal_parameter_count(len);
   info->set_length(len);
 
diff --git a/src/builtins/builtins-regexp-gen.cc b/src/builtins/builtins-regexp-gen.cc
index 638ff2ccb5b..d5337323a26 100644
--- a/src/builtins/builtins-regexp-gen.cc
+++ b/src/builtins/builtins-regexp-gen.cc
@@ -53,8 +53,10 @@ TNode<RawPtrT> RegExpBuiltinsAssembler::LoadCodeObjectEntry(TNode<Code> code) {
   TNode<Int32T> builtin_index =
       LoadObjectField<Int32T>(code, Code::kBuiltinIndexOffset);
   {
-    GotoIfNot(Word32Equal(builtin_index, Int32Constant(Builtin::kNoBuiltinId)),
-              &if_code_is_off_heap);
+    GotoIfNot(
+        Word32Equal(builtin_index,
+                    Int32Constant(static_cast<int>(Builtin::kNoBuiltinId))),
+        &if_code_is_off_heap);
     var_result = ReinterpretCast<RawPtrT>(
         IntPtrAdd(BitcastTaggedToWord(code),
                   IntPtrConstant(Code::kHeaderSize - kHeapObjectTag)));
diff --git a/src/builtins/builtins.cc b/src/builtins/builtins.cc
index 88b584f5a63..b7dc5523385 100644
--- a/src/builtins/builtins.cc
+++ b/src/builtins/builtins.cc
@@ -91,15 +91,16 @@ const BuiltinMetadata builtin_metadata[] = {BUILTIN_LIST(
 BytecodeOffset Builtins::GetContinuationBytecodeOffset(Builtin builtin) {
   DCHECK(Builtins::KindOf(builtin) == TFJ || Builtins::KindOf(builtin) == TFC ||
          Builtins::KindOf(builtin) == TFS);
-  return BytecodeOffset(BytecodeOffset::kFirstBuiltinContinuationId + builtin);
+  return BytecodeOffset(BytecodeOffset::kFirstBuiltinContinuationId +
+                        static_cast<int>(builtin));
 }
 
 Builtin Builtins::GetBuiltinFromBytecodeOffset(BytecodeOffset id) {
-  int builtin_index = id.ToInt() - BytecodeOffset::kFirstBuiltinContinuationId;
-  DCHECK(Builtins::KindOf(builtin_index) == TFJ ||
-         Builtins::KindOf(builtin_index) == TFC ||
-         Builtins::KindOf(builtin_index) == TFS);
-  return static_cast<Builtin>(builtin_index);
+  Builtin builtin = Builtins::FromInt(
+      id.ToInt() - BytecodeOffset::kFirstBuiltinContinuationId);
+  DCHECK(Builtins::KindOf(builtin) == TFJ || Builtins::KindOf(builtin) == TFC ||
+         Builtins::KindOf(builtin) == TFS);
+  return builtin;
 }
 
 void Builtins::TearDown() { initialized_ = false; }
@@ -110,10 +111,10 @@ const char* Builtins::Lookup(Address pc) {
   if (Builtins::IsBuiltinId(builtin)) return name(builtin);
 
   // May be called during initialization (disassembler).
-  if (initialized_) {
-    for (int i = 0; i < kBuiltinCount; i++) {
-      if (isolate_->heap()->builtin(i).contains(isolate_, pc)) return name(i);
-    }
+  if (!initialized_) return nullptr;
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    if (code(builtin).contains(isolate_, pc)) return name(builtin);
   }
   return nullptr;
 }
@@ -121,11 +122,11 @@ const char* Builtins::Lookup(Address pc) {
 Handle<Code> Builtins::CallFunction(ConvertReceiverMode mode) {
   switch (mode) {
     case ConvertReceiverMode::kNullOrUndefined:
-      return builtin_handle(kCallFunction_ReceiverIsNullOrUndefined);
+      return code_handle(Builtin::kCallFunction_ReceiverIsNullOrUndefined);
     case ConvertReceiverMode::kNotNullOrUndefined:
-      return builtin_handle(kCallFunction_ReceiverIsNotNullOrUndefined);
+      return code_handle(Builtin::kCallFunction_ReceiverIsNotNullOrUndefined);
     case ConvertReceiverMode::kAny:
-      return builtin_handle(kCallFunction_ReceiverIsAny);
+      return code_handle(Builtin::kCallFunction_ReceiverIsAny);
   }
   UNREACHABLE();
 }
@@ -133,11 +134,11 @@ Handle<Code> Builtins::CallFunction(ConvertReceiverMode mode) {
 Handle<Code> Builtins::Call(ConvertReceiverMode mode) {
   switch (mode) {
     case ConvertReceiverMode::kNullOrUndefined:
-      return builtin_handle(kCall_ReceiverIsNullOrUndefined);
+      return code_handle(Builtin::kCall_ReceiverIsNullOrUndefined);
     case ConvertReceiverMode::kNotNullOrUndefined:
-      return builtin_handle(kCall_ReceiverIsNotNullOrUndefined);
+      return code_handle(Builtin::kCall_ReceiverIsNotNullOrUndefined);
     case ConvertReceiverMode::kAny:
-      return builtin_handle(kCall_ReceiverIsAny);
+      return code_handle(Builtin::kCall_ReceiverIsAny);
   }
   UNREACHABLE();
 }
@@ -145,11 +146,11 @@ Handle<Code> Builtins::Call(ConvertReceiverMode mode) {
 Handle<Code> Builtins::NonPrimitiveToPrimitive(ToPrimitiveHint hint) {
   switch (hint) {
     case ToPrimitiveHint::kDefault:
-      return builtin_handle(kNonPrimitiveToPrimitive_Default);
+      return code_handle(Builtin::kNonPrimitiveToPrimitive_Default);
     case ToPrimitiveHint::kNumber:
-      return builtin_handle(kNonPrimitiveToPrimitive_Number);
+      return code_handle(Builtin::kNonPrimitiveToPrimitive_Number);
     case ToPrimitiveHint::kString:
-      return builtin_handle(kNonPrimitiveToPrimitive_String);
+      return code_handle(Builtin::kNonPrimitiveToPrimitive_String);
   }
   UNREACHABLE();
 }
@@ -157,23 +158,25 @@ Handle<Code> Builtins::NonPrimitiveToPrimitive(ToPrimitiveHint hint) {
 Handle<Code> Builtins::OrdinaryToPrimitive(OrdinaryToPrimitiveHint hint) {
   switch (hint) {
     case OrdinaryToPrimitiveHint::kNumber:
-      return builtin_handle(kOrdinaryToPrimitive_Number);
+      return code_handle(Builtin::kOrdinaryToPrimitive_Number);
     case OrdinaryToPrimitiveHint::kString:
-      return builtin_handle(kOrdinaryToPrimitive_String);
+      return code_handle(Builtin::kOrdinaryToPrimitive_String);
   }
   UNREACHABLE();
 }
 
-void Builtins::set_builtin(int index, Code builtin) {
-  isolate_->heap()->set_builtin(index, builtin);
+void Builtins::set_code(Builtin builtin, Code code) {
+  DCHECK_EQ(builtin, code.builtin_id());
+  isolate_->heap()->set_builtin(builtin, code);
 }
 
-Code Builtins::builtin(int index) { return isolate_->heap()->builtin(index); }
+Code Builtins::code(Builtin builtin_enum) {
+  return isolate_->heap()->builtin(builtin_enum);
+}
 
-Handle<Code> Builtins::builtin_handle(int index) {
-  DCHECK(IsBuiltinId(index));
+Handle<Code> Builtins::code_handle(Builtin builtin) {
   return Handle<Code>(
-      reinterpret_cast<Address*>(isolate_->heap()->builtin_address(index)));
+      reinterpret_cast<Address*>(isolate_->heap()->builtin_address(builtin)));
 }
 
 // static
@@ -209,19 +212,19 @@ CallInterfaceDescriptor Builtins::CallInterfaceDescriptorFor(Builtin builtin) {
 
 // static
 Callable Builtins::CallableFor(Isolate* isolate, Builtin builtin) {
-  Handle<Code> code = isolate->builtins()->builtin_handle(builtin);
+  Handle<Code> code = isolate->builtins()->code_handle(builtin);
   return Callable{code, CallInterfaceDescriptorFor(builtin)};
 }
 
 // static
-bool Builtins::HasJSLinkage(int builtin_index) {
-  Builtin index = static_cast<Builtin>(builtin_index);
-  DCHECK_NE(BCH, Builtins::KindOf(index));
-  return CallInterfaceDescriptorFor(index) == JSTrampolineDescriptor{};
+bool Builtins::HasJSLinkage(Builtin builtin) {
+  DCHECK_NE(BCH, Builtins::KindOf(builtin));
+  return CallInterfaceDescriptorFor(builtin) == JSTrampolineDescriptor{};
 }
 
 // static
-const char* Builtins::name(int index) {
+const char* Builtins::name(Builtin builtin) {
+  int index = static_cast<int>(builtin);
   DCHECK(IsBuiltinId(index));
   return builtin_metadata[index].name;
 }
@@ -229,9 +232,10 @@ const char* Builtins::name(int index) {
 void Builtins::PrintBuiltinCode() {
   DCHECK(FLAG_print_builtin_code);
 #ifdef ENABLE_DISASSEMBLER
-  for (int i = 0; i < kBuiltinCount; i++) {
-    const char* builtin_name = name(i);
-    Handle<Code> code = builtin_handle(i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    const char* builtin_name = name(builtin);
+    Handle<Code> code = code_handle(builtin);
     if (PassesFilter(CStrVector(builtin_name),
                      CStrVector(FLAG_print_builtin_code_filter))) {
       CodeTracer::Scope trace_scope(isolate_->GetCodeTracer());
@@ -245,56 +249,61 @@ void Builtins::PrintBuiltinCode() {
 
 void Builtins::PrintBuiltinSize() {
   DCHECK(FLAG_print_builtin_size);
-  for (int i = 0; i < kBuiltinCount; i++) {
-    const char* builtin_name = name(i);
-    const char* kind = KindNameOf(i);
-    Code code = builtin(i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    const char* builtin_name = name(builtin);
+    const char* kind = KindNameOf(builtin);
+    Code code = Builtins::code(builtin);
     PrintF(stdout, "%s Builtin, %s, %d\n", kind, builtin_name,
            code.InstructionSize());
   }
 }
 
 // static
-Address Builtins::CppEntryOf(int index) {
-  DCHECK(Builtins::IsCpp(index));
-  return builtin_metadata[index].data.cpp_entry;
+Address Builtins::CppEntryOf(Builtin builtin) {
+  DCHECK(Builtins::IsCpp(builtin));
+  return builtin_metadata[static_cast<int>(builtin)].data.cpp_entry;
 }
 
 // static
 bool Builtins::IsBuiltin(const Code code) {
-  return Builtins::IsBuiltinId(code.builtin_index());
+  return Builtins::IsBuiltinId(code.builtin_id());
 }
 
 bool Builtins::IsBuiltinHandle(Handle<HeapObject> maybe_code,
-                               int* index) const {
+                               Builtin* builtin) const {
   Heap* heap = isolate_->heap();
   Address handle_location = maybe_code.address();
-  Address start = heap->builtin_address(0);
-  Address end = heap->builtin_address(Builtins::kBuiltinCount);
+  Address end =
+      heap->builtin_address(static_cast<Builtin>(Builtins::kBuiltinCount));
   if (handle_location >= end) return false;
+  Address start = heap->builtin_address(static_cast<Builtin>(0));
   if (handle_location < start) return false;
-  *index = static_cast<int>(handle_location - start) >> kSystemPointerSizeLog2;
-  DCHECK(Builtins::IsBuiltinId(*index));
+  *builtin = FromInt(static_cast<int>(handle_location - start) >>
+                     kSystemPointerSizeLog2);
   return true;
 }
 
 // static
 bool Builtins::IsIsolateIndependentBuiltin(const Code code) {
-  const int builtin_index = code.builtin_index();
-  return Builtins::IsBuiltinId(builtin_index) &&
-         Builtins::IsIsolateIndependent(builtin_index);
+  const Builtin builtin = code.builtin_id();
+  return Builtins::IsBuiltinId(builtin) &&
+         Builtins::IsIsolateIndependent(builtin);
 }
 
 // static
 void Builtins::InitializeBuiltinEntryTable(Isolate* isolate) {
   EmbeddedData d = EmbeddedData::FromBlob(isolate);
   Address* builtin_entry_table = isolate->builtin_entry_table();
-  for (int i = 0; i < kBuiltinCount; i++) {
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
     // TODO(jgruber,chromium:1020986): Remove the CHECK once the linked issue is
     // resolved.
-    CHECK(Builtins::IsBuiltinId(isolate->heap()->builtin(i).builtin_index()));
-    DCHECK(isolate->heap()->builtin(i).is_off_heap_trampoline());
-    builtin_entry_table[i] = d.InstructionStartOfBuiltin(i);
+    CHECK(
+        Builtins::IsBuiltinId(isolate->heap()->builtin(builtin).builtin_id()));
+    DCHECK(isolate->heap()->builtin(builtin).is_off_heap_trampoline());
+    builtin_entry_table[static_cast<int>(builtin)] =
+        d.InstructionStartOfBuiltin(builtin);
   }
 }
 
@@ -308,10 +317,10 @@ void Builtins::EmitCodeCreateEvents(Isolate* isolate) {
   Address* builtins = isolate->builtins_table();
   int i = 0;
   HandleScope scope(isolate);
-  for (; i < kFirstBytecodeHandler; i++) {
+  for (; i < static_cast<int>(Builtin::kFirstBytecodeHandler); i++) {
     Handle<AbstractCode> code(AbstractCode::cast(Object(builtins[i])), isolate);
     PROFILE(isolate, CodeCreateEvent(CodeEventListener::BUILTIN_TAG, code,
-                                     Builtins::name(i)));
+                                     Builtins::name(FromInt(i))));
   }
 
   STATIC_ASSERT(kLastBytecodeHandlerPlusOne == kBuiltinCount);
@@ -409,18 +418,13 @@ Handle<ByteArray> Builtins::GenerateOffHeapTrampolineRelocInfo(
 }
 
 Builtins::Kind Builtins::KindOf(Builtin builtin) {
-  return KindOf(static_cast<int>(builtin));
+  DCHECK(IsBuiltinId(builtin));
+  return builtin_metadata[static_cast<int>(builtin)].kind;
 }
 
 // static
-Builtins::Kind Builtins::KindOf(int index) {
-  DCHECK(IsBuiltinId(index));
-  return builtin_metadata[index].kind;
-}
-
-// static
-const char* Builtins::KindNameOf(int index) {
-  Kind kind = Builtins::KindOf(index);
+const char* Builtins::KindNameOf(Builtin builtin) {
+  Kind kind = Builtins::KindOf(builtin);
   // clang-format off
   switch (kind) {
     case CPP: return "CPP";
@@ -436,7 +440,9 @@ const char* Builtins::KindNameOf(int index) {
 }
 
 // static
-bool Builtins::IsCpp(int index) { return Builtins::KindOf(index) == CPP; }
+bool Builtins::IsCpp(Builtin builtin) {
+  return Builtins::KindOf(builtin) == CPP;
+}
 
 // static
 bool Builtins::AllowDynamicFunction(Isolate* isolate, Handle<JSFunction> target,
@@ -453,7 +459,7 @@ bool Builtins::AllowDynamicFunction(Isolate* isolate, Handle<JSFunction> target,
 }
 
 // static
-bool Builtins::CodeObjectIsExecutable(int builtin_index) {
+bool Builtins::CodeObjectIsExecutable(Builtin builtin) {
   // If the runtime/optimized code always knows when executing a given builtin
   // that it is a builtin, then that builtin does not need an executable Code
   // object. Such Code objects can go in read_only_space (and can even be
@@ -467,7 +473,7 @@ bool Builtins::CodeObjectIsExecutable(int builtin_index) {
   // TODO(delphick): This is probably too loose but for now Wasm can call any JS
   // linkage builtin via its Code object. Once Wasm is fixed this can either be
   // tighted or removed completely.
-  if (Builtins::KindOf(builtin_index) != BCH && HasJSLinkage(builtin_index)) {
+  if (Builtins::KindOf(builtin) != BCH && HasJSLinkage(builtin)) {
     return true;
   }
 
@@ -476,7 +482,7 @@ bool Builtins::CodeObjectIsExecutable(int builtin_index) {
   // TODO(delphick): Some of these builtins do not fit with the above, but
   // currently cause problems if they're not executable. This list should be
   // pared down as much as possible.
-  switch (builtin_index) {
+  switch (builtin) {
     case Builtin::kInterpreterEntryTrampoline:
     case Builtin::kCompileLazy:
     case Builtin::kCompileLazyDeoptimizedCode:
diff --git a/src/builtins/builtins.h b/src/builtins/builtins.h
index f7b00b5c1ef..2f72e1aabe5 100644
--- a/src/builtins/builtins.h
+++ b/src/builtins/builtins.h
@@ -34,9 +34,9 @@ static constexpr T FirstFromVarArgs(T x, ...) noexcept {
 
 // Convenience macro to avoid generating named accessors for all builtins.
 #define BUILTIN_CODE(isolate, name) \
-  (isolate)->builtins()->builtin_handle(Builtin::k##name)
+  (isolate)->builtins()->code_handle(Builtin::k##name)
 
-enum Builtin : int32_t {
+enum class Builtin : int32_t {
   kNoBuiltinId = -1,
 #define DEF_ENUM(Name, ...) k##Name,
   BUILTIN_LIST(DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM,
@@ -49,6 +49,16 @@ enum Builtin : int32_t {
 #undef EXTRACT_NAME
 };
 
+V8_INLINE constexpr bool operator<(Builtin a, Builtin b) {
+  using type = typename std::underlying_type<Builtin>::type;
+  return static_cast<type>(a) < static_cast<type>(b);
+}
+
+V8_INLINE Builtin operator++(Builtin& builtin) {
+  using type = typename std::underlying_type<Builtin>::type;
+  return builtin = static_cast<Builtin>(static_cast<type>(builtin) + 1);
+}
+
 class Builtins {
  public:
   explicit Builtins(Isolate* isolate) : isolate_(isolate) {}
@@ -66,20 +76,32 @@ class Builtins {
       ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE);
 #undef ADD_ONE
 
+  static constexpr Builtin kFirst = static_cast<Builtin>(0);
+  static constexpr Builtin kLast = static_cast<Builtin>(kBuiltinCount - 1);
+
   static constexpr int kFirstWideBytecodeHandler =
-      Builtin::kFirstBytecodeHandler + kNumberOfBytecodeHandlers;
+      static_cast<int>(Builtin::kFirstBytecodeHandler) +
+      kNumberOfBytecodeHandlers;
   static constexpr int kFirstExtraWideBytecodeHandler =
       kFirstWideBytecodeHandler + kNumberOfWideBytecodeHandlers;
   static constexpr int kLastBytecodeHandlerPlusOne =
       kFirstExtraWideBytecodeHandler + kNumberOfWideBytecodeHandlers;
   STATIC_ASSERT(kLastBytecodeHandlerPlusOne == kBuiltinCount);
 
+  static constexpr bool IsBuiltinId(Builtin builtin) {
+    return builtin != Builtin::kNoBuiltinId;
+  }
   static constexpr bool IsBuiltinId(int maybe_id) {
-    STATIC_ASSERT(kNoBuiltinId == -1);
+    STATIC_ASSERT(static_cast<int>(Builtin::kNoBuiltinId) == -1);
     return static_cast<uint32_t>(maybe_id) <
            static_cast<uint32_t>(kBuiltinCount);
   }
 
+  static constexpr Builtin FromInt(int id) {
+    DCHECK(IsBuiltinId(id));
+    return static_cast<Builtin>(id);
+  }
+
   // The different builtin kinds are documented in builtins-definitions.h.
   enum Kind { CPP, TFJ, TFC, TFS, TFH, BCH, ASM };
 
@@ -147,19 +169,19 @@ class Builtins {
   Handle<Code> JSConstructStubGeneric();
 
   // Used by CreateOffHeapTrampolines in isolate.cc.
-  void set_builtin(int index, Code builtin);
+  void set_code(Builtin builtin, Code code);
 
-  V8_EXPORT_PRIVATE Code builtin(int index);
-  V8_EXPORT_PRIVATE Handle<Code> builtin_handle(int index);
+  V8_EXPORT_PRIVATE Code code(Builtin builtin);
+  V8_EXPORT_PRIVATE Handle<Code> code_handle(Builtin builtin);
 
   static CallInterfaceDescriptor CallInterfaceDescriptorFor(Builtin builtin);
   V8_EXPORT_PRIVATE static Callable CallableFor(Isolate* isolate,
                                                 Builtin builtin);
-  static bool HasJSLinkage(int index);
+  static bool HasJSLinkage(Builtin builtin);
 
   static int GetStackParameterCount(Builtin builtin);
 
-  static const char* name(int index);
+  static const char* name(Builtin builtin);
 
   // Support for --print-builtin-size and --print-builtin-code.
   void PrintBuiltinCode();
@@ -167,13 +189,12 @@ class Builtins {
 
   // Returns the C++ entry point for builtins implemented in C++, and the null
   // Address otherwise.
-  static Address CppEntryOf(int index);
+  static Address CppEntryOf(Builtin builtin);
 
-  static Kind KindOf(int index);
   static Kind KindOf(Builtin builtin);
-  static const char* KindNameOf(int index);
+  static const char* KindNameOf(Builtin builtin);
 
-  static bool IsCpp(int index);
+  static bool IsCpp(Builtin builtin);
 
   // True, iff the given code object is a builtin. Note that this does not
   // necessarily mean that its kind is Code::BUILTIN.
@@ -181,7 +202,7 @@ class Builtins {
 
   // As above, but safe to access off the main thread since the check is done
   // by handle location. Similar to Heap::IsRootHandle.
-  bool IsBuiltinHandle(Handle<HeapObject> maybe_code, int* index) const;
+  bool IsBuiltinHandle(Handle<HeapObject> maybe_code, Builtin* index) const;
 
   // True, iff the given code object is a builtin with off-heap embedded code.
   static bool IsIsolateIndependentBuiltin(const Code code);
@@ -192,7 +213,7 @@ class Builtins {
   static constexpr bool AllBuiltinsAreIsolateIndependent() {
     return kAllBuiltinsAreIsolateIndependent;
   }
-  static constexpr bool IsIsolateIndependent(int index) {
+  static constexpr bool IsIsolateIndependent(Builtin builtin) {
     STATIC_ASSERT(kAllBuiltinsAreIsolateIndependent);
     return kAllBuiltinsAreIsolateIndependent;
   }
@@ -242,13 +263,13 @@ class Builtins {
   // Only builtins with JS linkage should ever need to be called via their
   // trampoline Code object. The remaining builtins have non-executable Code
   // objects.
-  static bool CodeObjectIsExecutable(int builtin_index);
+  static bool CodeObjectIsExecutable(Builtin builtin);
 
-  static bool IsJSEntryVariant(int builtin_index) {
-    switch (builtin_index) {
-      case kJSEntry:
-      case kJSConstructEntry:
-      case kJSRunMicrotasksEntry:
+  static bool IsJSEntryVariant(Builtin builtin) {
+    switch (builtin) {
+      case Builtin::kJSEntry:
+      case Builtin::kJSConstructEntry:
+      case Builtin::kJSRunMicrotasksEntry:
         return true;
       default:
         return false;
diff --git a/src/builtins/constants-table-builder.cc b/src/builtins/constants-table-builder.cc
index 25fa878634d..49002a9c31a 100644
--- a/src/builtins/constants-table-builder.cc
+++ b/src/builtins/constants-table-builder.cc
@@ -120,7 +120,7 @@ void BuiltinsConstantsTableBuilder::Finalize() {
       // See also: SetupIsolateDelegate::PopulateWithPlaceholders.
       // TODO(jgruber): Deduplicate placeholders and their corresponding
       // builtin.
-      value = builtins->builtin(Code::cast(value).builtin_index());
+      value = builtins->code(Code::cast(value).builtin_id());
     }
     DCHECK(value.IsHeapObject());
     table->set(index, value);
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 08392ff8fc9..fc997a58cbb 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -420,7 +420,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // Invoke the function by calling through JS entry trampoline builtin and
   // pop the faked function when we return.
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
   // Unlink this frame from the handler chain.
@@ -4290,14 +4290,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/mips/builtins-mips.cc b/src/builtins/mips/builtins-mips.cc
index 5ca364a7e94..9c6f1b03066 100644
--- a/src/builtins/mips/builtins-mips.cc
+++ b/src/builtins/mips/builtins-mips.cc
@@ -462,7 +462,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // Invoke the function by calling through JS entry trampoline builtin and
   // pop the faked function when we return.
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   DCHECK_EQ(kPushedStackSpace, pushed_stack_space);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
@@ -4123,14 +4123,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/mips64/builtins-mips64.cc b/src/builtins/mips64/builtins-mips64.cc
index 93a8db7c1a1..8983d829e33 100644
--- a/src/builtins/mips64/builtins-mips64.cc
+++ b/src/builtins/mips64/builtins-mips64.cc
@@ -634,7 +634,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // pop the faked function when we return.
 
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
   // Unlink this frame from the handler chain.
@@ -3717,14 +3717,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/ppc/builtins-ppc.cc b/src/builtins/ppc/builtins-ppc.cc
index 71617c229fc..21f727a814b 100644
--- a/src/builtins/ppc/builtins-ppc.cc
+++ b/src/builtins/ppc/builtins-ppc.cc
@@ -628,7 +628,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // Invoke the function by calling through JS entry trampoline builtin and
   // pop the faked function when we return.
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
   // Unlink this frame from the handler chain.
@@ -3514,14 +3514,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/riscv64/builtins-riscv64.cc b/src/builtins/riscv64/builtins-riscv64.cc
index a3b5abd87ce..6324d30b88e 100644
--- a/src/builtins/riscv64/builtins-riscv64.cc
+++ b/src/builtins/riscv64/builtins-riscv64.cc
@@ -660,7 +660,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // pop the faked function when we return.
 
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
   // Unlink this frame from the handler chain.
@@ -3789,14 +3789,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/s390/builtins-s390.cc b/src/builtins/s390/builtins-s390.cc
index 1daaf57bbf9..a70d8086570 100644
--- a/src/builtins/s390/builtins-s390.cc
+++ b/src/builtins/s390/builtins-s390.cc
@@ -647,7 +647,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // Invoke the function by calling through JS entry trampoline builtin and
   // pop the faked function when we return.
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   DCHECK_EQ(kPushedStackSpace, pushed_stack_space);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
@@ -3503,14 +3503,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/builtins/setup-builtins-internal.cc b/src/builtins/setup-builtins-internal.cc
index ce6c4808e2c..e2c1a9922f0 100644
--- a/src/builtins/setup-builtins-internal.cc
+++ b/src/builtins/setup-builtins-internal.cc
@@ -31,8 +31,7 @@ BUILTIN_LIST_C(FORWARD_DECLARE)
 
 namespace {
 
-AssemblerOptions BuiltinAssemblerOptions(Isolate* isolate,
-                                         int32_t builtin_index) {
+AssemblerOptions BuiltinAssemblerOptions(Isolate* isolate, Builtin builtin) {
   AssemblerOptions options = AssemblerOptions::Default(isolate);
   CHECK(!options.isolate_independent_code);
   CHECK(!options.use_pc_relative_calls_and_jumps);
@@ -58,7 +57,7 @@ AssemblerOptions BuiltinAssemblerOptions(Isolate* isolate,
 using MacroAssemblerGenerator = void (*)(MacroAssembler*);
 using CodeAssemblerGenerator = void (*)(compiler::CodeAssemblerState*);
 
-Handle<Code> BuildPlaceholder(Isolate* isolate, int32_t builtin_index) {
+Handle<Code> BuildPlaceholder(Isolate* isolate, Builtin builtin) {
   HandleScope scope(isolate);
   constexpr int kBufferSize = 1 * KB;
   byte buffer[kBufferSize];
@@ -76,12 +75,12 @@ Handle<Code> BuildPlaceholder(Isolate* isolate, int32_t builtin_index) {
   masm.GetCode(isolate, &desc);
   Handle<Code> code = Factory::CodeBuilder(isolate, desc, CodeKind::BUILTIN)
                           .set_self_reference(masm.CodeObject())
-                          .set_builtin_index(builtin_index)
+                          .set_builtin(builtin)
                           .Build();
   return scope.CloseAndEscape(code);
 }
 
-Code BuildWithMacroAssembler(Isolate* isolate, int32_t builtin_index,
+Code BuildWithMacroAssembler(Isolate* isolate, Builtin builtin,
                              MacroAssemblerGenerator generator,
                              const char* s_name) {
   HandleScope scope(isolate);
@@ -91,10 +90,10 @@ Code BuildWithMacroAssembler(Isolate* isolate, int32_t builtin_index,
   constexpr int kBufferSize = 32 * KB;
   byte buffer[kBufferSize];
 
-  MacroAssembler masm(isolate, BuiltinAssemblerOptions(isolate, builtin_index),
+  MacroAssembler masm(isolate, BuiltinAssemblerOptions(isolate, builtin),
                       CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, kBufferSize));
-  masm.set_builtin_index(builtin_index);
+  masm.set_builtin(builtin);
   DCHECK(!masm.has_frame());
   masm.CodeEntry();
   generator(&masm);
@@ -105,7 +104,7 @@ Code BuildWithMacroAssembler(Isolate* isolate, int32_t builtin_index,
   DCHECK_EQ(Builtins::KindOf(Builtin::kJSEntry), Builtins::ASM);
   DCHECK_EQ(Builtins::KindOf(Builtin::kJSConstructEntry), Builtins::ASM);
   DCHECK_EQ(Builtins::KindOf(Builtin::kJSRunMicrotasksEntry), Builtins::ASM);
-  if (Builtins::IsJSEntryVariant(builtin_index)) {
+  if (Builtins::IsJSEntryVariant(builtin)) {
     handler_table_offset = HandlerTable::EmitReturnTableStart(&masm);
     HandlerTable::EmitReturnEntry(
         &masm, 0, isolate->builtins()->js_entry_handler_offset());
@@ -117,39 +116,39 @@ Code BuildWithMacroAssembler(Isolate* isolate, int32_t builtin_index,
 
   Handle<Code> code = Factory::CodeBuilder(isolate, desc, CodeKind::BUILTIN)
                           .set_self_reference(masm.CodeObject())
-                          .set_builtin_index(builtin_index)
+                          .set_builtin(builtin)
                           .Build();
 #if defined(V8_OS_WIN64)
-  isolate->SetBuiltinUnwindData(builtin_index, masm.GetUnwindInfo());
+  isolate->SetBuiltinUnwindData(builtin, masm.GetUnwindInfo());
 #endif  // V8_OS_WIN64
   return *code;
 }
 
-Code BuildAdaptor(Isolate* isolate, int32_t builtin_index,
-                  Address builtin_address, const char* name) {
+Code BuildAdaptor(Isolate* isolate, Builtin builtin, Address builtin_address,
+                  const char* name) {
   HandleScope scope(isolate);
   // Canonicalize handles, so that we can share constant pool entries pointing
   // to code targets without dereferencing their handles.
   CanonicalHandleScope canonical(isolate);
   constexpr int kBufferSize = 32 * KB;
   byte buffer[kBufferSize];
-  MacroAssembler masm(isolate, BuiltinAssemblerOptions(isolate, builtin_index),
+  MacroAssembler masm(isolate, BuiltinAssemblerOptions(isolate, builtin),
                       CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, kBufferSize));
-  masm.set_builtin_index(builtin_index);
+  masm.set_builtin(builtin);
   DCHECK(!masm.has_frame());
   Builtins::Generate_Adaptor(&masm, builtin_address);
   CodeDesc desc;
   masm.GetCode(isolate, &desc);
   Handle<Code> code = Factory::CodeBuilder(isolate, desc, CodeKind::BUILTIN)
                           .set_self_reference(masm.CodeObject())
-                          .set_builtin_index(builtin_index)
+                          .set_builtin(builtin)
                           .Build();
   return *code;
 }
 
 // Builder for builtins implemented in TurboFan with JS linkage.
-Code BuildWithCodeStubAssemblerJS(Isolate* isolate, int32_t builtin_index,
+Code BuildWithCodeStubAssemblerJS(Isolate* isolate, Builtin builtin,
                                   CodeAssemblerGenerator generator, int argc,
                                   const char* name) {
   HandleScope scope(isolate);
@@ -162,16 +161,16 @@ Code BuildWithCodeStubAssemblerJS(Isolate* isolate, int32_t builtin_index,
       (argc == kDontAdaptArgumentsSentinel) ? 0 : argc + 1;
   compiler::CodeAssemblerState state(
       isolate, &zone, argc_with_recv, CodeKind::BUILTIN, name,
-      PoisoningMitigationLevel::kDontPoison, builtin_index);
+      PoisoningMitigationLevel::kDontPoison, builtin);
   generator(&state);
   Handle<Code> code = compiler::CodeAssembler::GenerateCode(
-      &state, BuiltinAssemblerOptions(isolate, builtin_index),
+      &state, BuiltinAssemblerOptions(isolate, builtin),
       ProfileDataFromFile::TryRead(name));
   return *code;
 }
 
 // Builder for builtins implemented in TurboFan with CallStub linkage.
-Code BuildWithCodeStubAssemblerCS(Isolate* isolate, int32_t builtin_index,
+Code BuildWithCodeStubAssemblerCS(Isolate* isolate, Builtin builtin,
                                   CodeAssemblerGenerator generator,
                                   CallDescriptors::Key interface_descriptor,
                                   const char* name) {
@@ -187,10 +186,10 @@ Code BuildWithCodeStubAssemblerCS(Isolate* isolate, int32_t builtin_index,
   DCHECK_LE(0, descriptor.GetRegisterParameterCount());
   compiler::CodeAssemblerState state(
       isolate, &zone, descriptor, CodeKind::BUILTIN, name,
-      PoisoningMitigationLevel::kDontPoison, builtin_index);
+      PoisoningMitigationLevel::kDontPoison, builtin);
   generator(&state);
   Handle<Code> code = compiler::CodeAssembler::GenerateCode(
-      &state, BuiltinAssemblerOptions(isolate, builtin_index),
+      &state, BuiltinAssemblerOptions(isolate, builtin),
       ProfileDataFromFile::TryRead(name));
   return *code;
 }
@@ -198,10 +197,10 @@ Code BuildWithCodeStubAssemblerCS(Isolate* isolate, int32_t builtin_index,
 }  // anonymous namespace
 
 // static
-void SetupIsolateDelegate::AddBuiltin(Builtins* builtins, int index,
+void SetupIsolateDelegate::AddBuiltin(Builtins* builtins, Builtin builtin,
                                       Code code) {
-  DCHECK_EQ(index, code.builtin_index());
-  builtins->set_builtin(index, code);
+  DCHECK_EQ(builtin, code.builtin_id());
+  builtins->set_code(builtin, code);
 }
 
 // static
@@ -211,9 +210,10 @@ void SetupIsolateDelegate::PopulateWithPlaceholders(Isolate* isolate) {
   // support circular references between builtins.
   Builtins* builtins = isolate->builtins();
   HandleScope scope(isolate);
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Handle<Code> placeholder = BuildPlaceholder(isolate, i);
-    AddBuiltin(builtins, i, *placeholder);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Handle<Code> placeholder = BuildPlaceholder(isolate, builtin);
+    AddBuiltin(builtins, builtin, *placeholder);
   }
 }
 
@@ -228,17 +228,18 @@ void SetupIsolateDelegate::ReplacePlaceholders(Isolate* isolate) {
       RelocInfo::ModeMask(RelocInfo::FULL_EMBEDDED_OBJECT) |
       RelocInfo::ModeMask(RelocInfo::COMPRESSED_EMBEDDED_OBJECT) |
       RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET);
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Code code = builtins->builtin(i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Code code = builtins->code(builtin);
     bool flush_icache = false;
     for (RelocIterator it(code, kRelocMask); !it.done(); it.next()) {
       RelocInfo* rinfo = it.rinfo();
       if (RelocInfo::IsCodeTargetMode(rinfo->rmode())) {
         Code target = Code::GetCodeFromTargetAddress(rinfo->target_address());
         DCHECK_IMPLIES(RelocInfo::IsRelativeCodeTarget(rinfo->rmode()),
-                       Builtins::IsIsolateIndependent(target.builtin_index()));
+                       Builtins::IsIsolateIndependent(target.builtin_id()));
         if (!target.is_builtin()) continue;
-        Code new_target = builtins->builtin(target.builtin_index());
+        Code new_target = builtins->code(target.builtin_id());
         rinfo->set_target_address(new_target.raw_instruction_start(),
                                   UPDATE_WRITE_BARRIER, SKIP_ICACHE_FLUSH);
       } else {
@@ -247,7 +248,7 @@ void SetupIsolateDelegate::ReplacePlaceholders(Isolate* isolate) {
         if (!object.IsCode()) continue;
         Code target = Code::cast(object);
         if (!target.is_builtin()) continue;
-        Code new_target = builtins->builtin(target.builtin_index());
+        Code new_target = builtins->code(target.builtin_id());
         rinfo->set_target_object(isolate->heap(), new_target,
                                  UPDATE_WRITE_BARRIER, SKIP_ICACHE_FLUSH);
       }
@@ -262,13 +263,13 @@ void SetupIsolateDelegate::ReplacePlaceholders(Isolate* isolate) {
 
 namespace {
 
-Code GenerateBytecodeHandler(Isolate* isolate, int builtin_index,
+Code GenerateBytecodeHandler(Isolate* isolate, Builtin builtin,
                              interpreter::OperandScale operand_scale,
                              interpreter::Bytecode bytecode) {
   DCHECK(interpreter::Bytecodes::BytecodeHasHandler(bytecode, operand_scale));
   Handle<Code> code = interpreter::GenerateBytecodeHandler(
-      isolate, Builtins::name(builtin_index), bytecode, operand_scale,
-      builtin_index, BuiltinAssemblerOptions(isolate, builtin_index));
+      isolate, Builtins::name(builtin), bytecode, operand_scale, builtin,
+      BuiltinAssemblerOptions(isolate, builtin));
   return *code;
 }
 
@@ -286,40 +287,53 @@ void SetupIsolateDelegate::SetupBuiltinsInternal(Isolate* isolate) {
 
   int index = 0;
   Code code;
-#define BUILD_CPP(Name)                                                      \
-  code = BuildAdaptor(isolate, index, FUNCTION_ADDR(Builtin_##Name), #Name); \
-  AddBuiltin(builtins, index++, code);
-#define BUILD_TFJ(Name, Argc, ...)                              \
-  code = BuildWithCodeStubAssemblerJS(                          \
-      isolate, index, &Builtins::Generate_##Name, Argc, #Name); \
-  AddBuiltin(builtins, index++, code);
+#define BUILD_CPP(Name)                                      \
+  code = BuildAdaptor(isolate, Builtin::k##Name,             \
+                      FUNCTION_ADDR(Builtin_##Name), #Name); \
+  AddBuiltin(builtins, Builtin::k##Name, code);              \
+  index++;
+
+#define BUILD_TFJ(Name, Argc, ...)                                         \
+  code = BuildWithCodeStubAssemblerJS(                                     \
+      isolate, Builtin::k##Name, &Builtins::Generate_##Name, Argc, #Name); \
+  AddBuiltin(builtins, Builtin::k##Name, code);                            \
+  index++;
+
 #define BUILD_TFC(Name, InterfaceDescriptor)                      \
   /* Return size is from the provided CallInterfaceDescriptor. */ \
   code = BuildWithCodeStubAssemblerCS(                            \
-      isolate, index, &Builtins::Generate_##Name,                 \
+      isolate, Builtin::k##Name, &Builtins::Generate_##Name,      \
       CallDescriptors::InterfaceDescriptor, #Name);               \
-  AddBuiltin(builtins, index++, code);
-#define BUILD_TFS(Name, ...)                                                   \
-  /* Return size for generic TF builtins (stub linkage) is always 1. */        \
-  code =                                                                       \
-      BuildWithCodeStubAssemblerCS(isolate, index, &Builtins::Generate_##Name, \
-                                   CallDescriptors::Name, #Name);              \
-  AddBuiltin(builtins, index++, code);
-#define BUILD_TFH(Name, InterfaceDescriptor)              \
-  /* Return size for IC builtins/handlers is always 1. */ \
-  code = BuildWithCodeStubAssemblerCS(                    \
-      isolate, index, &Builtins::Generate_##Name,         \
-      CallDescriptors::InterfaceDescriptor, #Name);       \
-  AddBuiltin(builtins, index++, code);
+  AddBuiltin(builtins, Builtin::k##Name, code);                   \
+  index++;
+
+#define BUILD_TFS(Name, ...)                                            \
+  /* Return size for generic TF builtins (stub linkage) is always 1. */ \
+  code = BuildWithCodeStubAssemblerCS(isolate, Builtin::k##Name,        \
+                                      &Builtins::Generate_##Name,       \
+                                      CallDescriptors::Name, #Name);    \
+  AddBuiltin(builtins, Builtin::k##Name, code);                         \
+  index++;
+
+#define BUILD_TFH(Name, InterfaceDescriptor)                 \
+  /* Return size for IC builtins/handlers is always 1. */    \
+  code = BuildWithCodeStubAssemblerCS(                       \
+      isolate, Builtin::k##Name, &Builtins::Generate_##Name, \
+      CallDescriptors::InterfaceDescriptor, #Name);          \
+  AddBuiltin(builtins, Builtin::k##Name, code);              \
+  index++;
 
 #define BUILD_BCH(Name, OperandScale, Bytecode)                           \
-  code = GenerateBytecodeHandler(isolate, index, OperandScale, Bytecode); \
-  AddBuiltin(builtins, index++, code);
+  code = GenerateBytecodeHandler(isolate, Builtin::k##Name, OperandScale, \
+                                 Bytecode);                               \
+  AddBuiltin(builtins, Builtin::k##Name, code);                           \
+  index++;
 
-#define BUILD_ASM(Name, InterfaceDescriptor)                                \
-  code = BuildWithMacroAssembler(isolate, index, Builtins::Generate_##Name, \
-                                 #Name);                                    \
-  AddBuiltin(builtins, index++, code);
+#define BUILD_ASM(Name, InterfaceDescriptor)                        \
+  code = BuildWithMacroAssembler(isolate, Builtin::k##Name,         \
+                                 Builtins::Generate_##Name, #Name); \
+  AddBuiltin(builtins, Builtin::k##Name, code);                     \
+  index++;
 
   BUILTIN_LIST(BUILD_CPP, BUILD_TFJ, BUILD_TFC, BUILD_TFS, BUILD_TFH, BUILD_BCH,
                BUILD_ASM);
@@ -336,13 +350,13 @@ void SetupIsolateDelegate::SetupBuiltinsInternal(Isolate* isolate) {
   ReplacePlaceholders(isolate);
 
 #define SET_PROMISE_REJECTION_PREDICTION(Name) \
-  builtins->builtin(Builtin::k##Name).set_is_promise_rejection(true);
+  builtins->code(Builtin::k##Name).set_is_promise_rejection(true);
 
   BUILTIN_PROMISE_REJECTION_PREDICTION_LIST(SET_PROMISE_REJECTION_PREDICTION)
 #undef SET_PROMISE_REJECTION_PREDICTION
 
 #define SET_EXCEPTION_CAUGHT_PREDICTION(Name) \
-  builtins->builtin(Builtin::k##Name).set_is_exception_caught(true);
+  builtins->code(Builtin::k##Name).set_is_exception_caught(true);
 
   BUILTIN_EXCEPTION_CAUGHT_PREDICTION_LIST(SET_EXCEPTION_CAUGHT_PREDICTION)
 #undef SET_EXCEPTION_CAUGHT_PREDICTION
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index abac7c649b9..b13caf6b4db 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -449,7 +449,7 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
   // Invoke the function by calling through JS entry trampoline builtin and
   // pop the faked function when we return.
   Handle<Code> trampoline_code =
-      masm->isolate()->builtins()->builtin_handle(entry_trampoline);
+      masm->isolate()->builtins()->code_handle(entry_trampoline);
   __ Call(trampoline_code, RelocInfo::CODE_TARGET);
 
   // Unlink this frame from the handler chain.
@@ -4557,14 +4557,14 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   }
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_eager = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_eager = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kEager));
   __ Jump(deopt_eager, RelocInfo::CODE_TARGET);
 
   __ bind(&bailout);
   __ MaybeRestoreRegisters(registers);
   __ LeaveFrame(StackFrame::INTERNAL);
-  Handle<Code> deopt_bailout = masm->isolate()->builtins()->builtin_handle(
+  Handle<Code> deopt_bailout = masm->isolate()->builtins()->code_handle(
       Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind::kBailout));
   __ Jump(deopt_bailout, RelocInfo::CODE_TARGET);
 }
diff --git a/src/codegen/arm/macro-assembler-arm.cc b/src/codegen/arm/macro-assembler-arm.cc
index 01b0267e176..a99e2976346 100644
--- a/src/codegen/arm/macro-assembler-arm.cc
+++ b/src/codegen/arm/macro-assembler-arm.cc
@@ -166,9 +166,9 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().use_pc_relative_calls_and_jumps,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
-  int builtin_index = Builtin::kNoBuiltinId;
+  Builtin builtin = Builtin::kNoBuiltinId;
   bool target_is_builtin =
-      isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
+      isolate()->builtins()->IsBuiltinHandle(code, &builtin);
 
   if (options().use_pc_relative_calls_and_jumps && target_is_builtin) {
     int32_t code_target_index = AddCodeTarget(code);
@@ -180,16 +180,15 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
     // size s.t. pc-relative calls may be used.
     UseScratchRegisterScope temps(this);
     Register scratch = temps.Acquire();
-    int offset = IsolateData::builtin_entry_slot_offset(
-        static_cast<Builtin>(code->builtin_index()));
+    int offset = IsolateData::builtin_entry_slot_offset(code->builtin_id());
     ldr(scratch, MemOperand(kRootRegister, offset));
     Jump(scratch, cond);
     return;
   } else if (options().inline_offheap_trampolines && target_is_builtin) {
     // Inline the trampoline.
-    RecordCommentForOffHeapTrampoline(builtin_index);
+    RecordCommentForOffHeapTrampoline(builtin);
     EmbeddedData d = EmbeddedData::FromBlob();
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     // Use ip directly instead of using UseScratchRegisterScope, as we do not
     // preserve scratch registers across calls.
     mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -258,9 +257,9 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().use_pc_relative_calls_and_jumps,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
-  int builtin_index = Builtin::kNoBuiltinId;
+  Builtin builtin = Builtin::kNoBuiltinId;
   bool target_is_builtin =
-      isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
+      isolate()->builtins()->IsBuiltinHandle(code, &builtin);
 
   if (target_is_builtin && options().use_pc_relative_calls_and_jumps) {
     int32_t code_target_index = AddCodeTarget(code);
@@ -270,14 +269,13 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
     // This branch is taken only for specific cctests, where we force isolate
     // creation at runtime. At this point, Code space isn't restricted to a
     // size s.t. pc-relative calls may be used.
-    int offset = IsolateData::builtin_entry_slot_offset(
-        static_cast<Builtin>(code->builtin_index()));
+    int offset = IsolateData::builtin_entry_slot_offset(code->builtin_id());
     ldr(ip, MemOperand(kRootRegister, offset));
     Call(ip, cond);
     return;
   } else if (target_is_builtin && options().inline_offheap_trampolines) {
     // Inline the trampoline.
-    CallBuiltin(builtin_index);
+    CallBuiltin(builtin);
     return;
   }
 
@@ -306,22 +304,22 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
   Call(builtin_index);
 }
 
-void TurboAssembler::LoadEntryFromBuiltin(Builtin builtin_index,
+void TurboAssembler::LoadEntryFromBuiltin(Builtin builtin,
                                           Register destination) {
-  ldr(destination, EntryFromBuiltinAsOperand(builtin_index));
+  ldr(destination, EntryFromBuiltinAsOperand(builtin));
 }
 
-MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
+MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin) {
   DCHECK(root_array_available());
   return MemOperand(kRootRegister,
-                    IsolateData::builtin_entry_slot_offset(builtin_index));
+                    IsolateData::builtin_entry_slot_offset(builtin));
 }
 
-void TurboAssembler::CallBuiltin(int builtin_index, Condition cond) {
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
-  RecordCommentForOffHeapTrampoline(builtin_index);
+void TurboAssembler::CallBuiltin(Builtin builtin, Condition cond) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  RecordCommentForOffHeapTrampoline(builtin);
   EmbeddedData d = EmbeddedData::FromBlob();
-  Address entry = d.InstructionStartOfBuiltin(builtin_index);
+  Address entry = d.InstructionStartOfBuiltin(builtin);
   // Use ip directly instead of using UseScratchRegisterScope, as we do not
   // preserve scratch registers across calls.
   mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -718,7 +716,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object, Operand offset,
       WriteBarrierDescriptor::SlotAddressRegister();
   MoveObjectAndSlot(object_parameter, slot_address_parameter, object, offset);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -756,13 +754,12 @@ void TurboAssembler::CallRecordWriteStub(
   if (false) {
 #endif
   } else {
-    auto builtin_index =
+    Builtin builtin =
         Builtins::GetRecordWriteStub(remembered_set_action, fp_mode);
     if (options().inline_offheap_trampolines) {
-      CallBuiltin(builtin_index);
+      CallBuiltin(builtin);
     } else {
-      Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+      Handle<Code> code_target = isolate()->builtins()->code_handle(builtin);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
diff --git a/src/codegen/arm/macro-assembler-arm.h b/src/codegen/arm/macro-assembler-arm.h
index d2c6bc31fa0..d6671fff3fb 100644
--- a/src/codegen/arm/macro-assembler-arm.h
+++ b/src/codegen/arm/macro-assembler-arm.h
@@ -310,13 +310,13 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
             bool check_constant_pool = true);
   void Call(Label* target);
 
-  MemOperand EntryFromBuiltinAsOperand(Builtin builtin_index);
-  void LoadEntryFromBuiltin(Builtin builtin_index, Register destination);
-  // Load the builtin given by the Smi in |builtin_index| into the same
+  MemOperand EntryFromBuiltinAsOperand(Builtin builtin);
+  void LoadEntryFromBuiltin(Builtin builtin, Register destination);
+  // Load the builtin given by the Smi in |builtin| into the same
   // register.
   void LoadEntryFromBuiltinIndex(Register builtin_index);
   void CallBuiltinByIndex(Register builtin_index);
-  void CallBuiltin(int builtin_index, Condition cond = al);
+  void CallBuiltin(Builtin builtin, Condition cond = al);
 
   void LoadCodeObjectEntry(Register destination, Register code_object);
   void CallCodeObject(Register code_object);
diff --git a/src/codegen/arm64/macro-assembler-arm64.cc b/src/codegen/arm64/macro-assembler-arm64.cc
index 44a204884a1..ab9b97f47d0 100644
--- a/src/codegen/arm64/macro-assembler-arm64.cc
+++ b/src/codegen/arm64/macro-assembler-arm64.cc
@@ -1829,11 +1829,11 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtin::kNoBuiltinId;
-    if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index)) {
+    Builtin builtin = Builtin::kNoBuiltinId;
+    if (isolate()->builtins()->IsBuiltinHandle(code, &builtin)) {
       // Inline the trampoline.
       CHECK_EQ(cond, Condition::al);  // Implement if necessary.
-      TailCallBuiltin(builtin_index);
+      TailCallBuiltin(builtin);
       return;
     }
   }
@@ -1877,10 +1877,10 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode) {
   BlockPoolsScope scope(this);
 
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtin::kNoBuiltinId;
-    if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index)) {
+    Builtin builtin = Builtin::kNoBuiltinId;
+    if (isolate()->builtins()->IsBuiltinHandle(code, &builtin)) {
       // Inline the trampoline.
-      CallBuiltin(builtin_index);
+      CallBuiltin(builtin);
       return;
     }
   }
@@ -1924,15 +1924,15 @@ void TurboAssembler::LoadEntryFromBuiltinIndex(Register builtin_index) {
   }
 }
 
-void TurboAssembler::LoadEntryFromBuiltin(Builtin builtin_index,
+void TurboAssembler::LoadEntryFromBuiltin(Builtin builtin,
                                           Register destination) {
-  Ldr(destination, EntryFromBuiltinAsOperand(builtin_index));
+  Ldr(destination, EntryFromBuiltinAsOperand(builtin));
 }
 
-MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
+MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin) {
   DCHECK(root_array_available());
   return MemOperand(kRootRegister,
-                    IsolateData::builtin_entry_slot_offset(builtin_index));
+                    IsolateData::builtin_entry_slot_offset(builtin));
 }
 
 void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
@@ -1940,18 +1940,18 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
   Call(builtin_index);
 }
 
-void TurboAssembler::CallBuiltin(int builtin_index) {
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
-  RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
+void TurboAssembler::CallBuiltin(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  RecordCommentForOffHeapTrampoline(builtin);
+  CHECK_NE(builtin, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     Call(entry, RelocInfo::RUNTIME_ENTRY);
 
   } else {
     EmbeddedData d = EmbeddedData::FromBlob();
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     UseScratchRegisterScope temps(this);
     Register scratch = temps.AcquireX();
     Ldr(scratch, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -1960,18 +1960,18 @@ void TurboAssembler::CallBuiltin(int builtin_index) {
   RecordComment("]");
 }
 
-void TurboAssembler::TailCallBuiltin(int builtin_index) {
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
-  RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
+void TurboAssembler::TailCallBuiltin(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  RecordCommentForOffHeapTrampoline(builtin);
+  CHECK_NE(builtin, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     Jump(entry, RelocInfo::RUNTIME_ENTRY);
 
   } else {
     EmbeddedData d = EmbeddedData::FromBlob();
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     // The control flow integrity (CFI) feature allows us to "sign" code entry
     // points as a target for calls, jumps or both. Arm64 has special
     // instructions for this purpose, so-called "landing pads" (see
@@ -2962,7 +2962,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object, Operand offset,
                     WriteBarrierDescriptor::SlotAddressRegister(), object,
                     offset);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -3000,13 +3000,12 @@ void TurboAssembler::CallRecordWriteStub(
   if (false) {
 #endif
   } else {
-    auto builtin_index =
+    Builtin builtin =
         Builtins::GetRecordWriteStub(remembered_set_action, fp_mode);
     if (options().inline_offheap_trampolines) {
-      CallBuiltin(builtin_index);
+      CallBuiltin(builtin);
     } else {
-      Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+      Handle<Code> code_target = isolate()->builtins()->code_handle(builtin);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
diff --git a/src/codegen/arm64/macro-assembler-arm64.h b/src/codegen/arm64/macro-assembler-arm64.h
index 3a1fe3f21dd..68021575734 100644
--- a/src/codegen/arm64/macro-assembler-arm64.h
+++ b/src/codegen/arm64/macro-assembler-arm64.h
@@ -970,22 +970,14 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // Generate an indirect call (for when a direct call's range is not adequate).
   void IndirectCall(Address target, RelocInfo::Mode rmode);
 
-  // Load the builtin given by the Smi in |builtin_index| into the same
+  // Load the builtin given by the Smi in |builtin_| into the same
   // register.
-  void LoadEntryFromBuiltinIndex(Register builtin_index);
-  void LoadEntryFromBuiltin(Builtin builtin_index, Register destination);
-  MemOperand EntryFromBuiltinAsOperand(Builtin builtin_index);
-  void CallBuiltinByIndex(Register builtin_index);
-  void CallBuiltin(Builtin builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtin one.
-    return CallBuiltin(static_cast<int>(builtin));
-  }
-  void CallBuiltin(int builtin_index);
-  void TailCallBuiltin(Builtin builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtin one.
-    return TailCallBuiltin(static_cast<int>(builtin));
-  }
-  void TailCallBuiltin(int builtin_index);
+  void LoadEntryFromBuiltinIndex(Register builtin);
+  void LoadEntryFromBuiltin(Builtin builtin, Register destination);
+  MemOperand EntryFromBuiltinAsOperand(Builtin builtin);
+  void CallBuiltinByIndex(Register builtin);
+  void CallBuiltin(Builtin builtin);
+  void TailCallBuiltin(Builtin builtin);
 
   void LoadCodeObjectEntry(Register destination, Register code_object);
   void CallCodeObject(Register code_object);
diff --git a/src/codegen/code-factory.cc b/src/codegen/code-factory.cc
index 26760e8567d..fb55b002b68 100644
--- a/src/codegen/code-factory.cc
+++ b/src/codegen/code-factory.cc
@@ -109,74 +109,69 @@ Callable CodeFactory::StoreOwnICInOptimizedCode(Isolate* isolate) {
 
 Callable CodeFactory::KeyedStoreIC_SloppyArguments(Isolate* isolate,
                                                    KeyedAccessStoreMode mode) {
-  Builtin builtin_index;
+  Builtin builtin;
   switch (mode) {
     case STANDARD_STORE:
-      builtin_index = Builtin::kKeyedStoreIC_SloppyArguments_Standard;
+      builtin = Builtin::kKeyedStoreIC_SloppyArguments_Standard;
       break;
     case STORE_AND_GROW_HANDLE_COW:
-      builtin_index =
+      builtin =
           Builtin::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW;
       break;
     case STORE_IGNORE_OUT_OF_BOUNDS:
-      builtin_index =
-          Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB;
+      builtin = Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB;
       break;
     case STORE_HANDLE_COW:
-      builtin_index =
-          Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW;
+      builtin = Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW;
       break;
     default:
       UNREACHABLE();
   }
-  return isolate->builtins()->CallableFor(isolate, builtin_index);
+  return isolate->builtins()->CallableFor(isolate, builtin);
 }
 
 Callable CodeFactory::ElementsTransitionAndStore(Isolate* isolate,
                                                  KeyedAccessStoreMode mode) {
-  Builtin builtin_index;
+  Builtin builtin;
   switch (mode) {
     case STANDARD_STORE:
-      builtin_index = Builtin::kElementsTransitionAndStore_Standard;
+      builtin = Builtin::kElementsTransitionAndStore_Standard;
       break;
     case STORE_AND_GROW_HANDLE_COW:
-      builtin_index =
-          Builtin::kElementsTransitionAndStore_GrowNoTransitionHandleCOW;
+      builtin = Builtin::kElementsTransitionAndStore_GrowNoTransitionHandleCOW;
       break;
     case STORE_IGNORE_OUT_OF_BOUNDS:
-      builtin_index =
-          Builtin::kElementsTransitionAndStore_NoTransitionIgnoreOOB;
+      builtin = Builtin::kElementsTransitionAndStore_NoTransitionIgnoreOOB;
       break;
     case STORE_HANDLE_COW:
-      builtin_index =
-          Builtin::kElementsTransitionAndStore_NoTransitionHandleCOW;
+      builtin = Builtin::kElementsTransitionAndStore_NoTransitionHandleCOW;
       break;
     default:
       UNREACHABLE();
   }
-  return isolate->builtins()->CallableFor(isolate, builtin_index);
+  return isolate->builtins()->CallableFor(isolate, builtin);
 }
 
 Callable CodeFactory::StoreFastElementIC(Isolate* isolate,
                                          KeyedAccessStoreMode mode) {
-  Builtin builtin_index;
+  Builtin builtin;
   switch (mode) {
     case STANDARD_STORE:
-      builtin_index = Builtin::kStoreFastElementIC_Standard;
+      builtin = Builtin::kStoreFastElementIC_Standard;
       break;
     case STORE_AND_GROW_HANDLE_COW:
-      builtin_index = Builtin::kStoreFastElementIC_GrowNoTransitionHandleCOW;
+      builtin = Builtin::kStoreFastElementIC_GrowNoTransitionHandleCOW;
       break;
     case STORE_IGNORE_OUT_OF_BOUNDS:
-      builtin_index = Builtin::kStoreFastElementIC_NoTransitionIgnoreOOB;
+      builtin = Builtin::kStoreFastElementIC_NoTransitionIgnoreOOB;
       break;
     case STORE_HANDLE_COW:
-      builtin_index = Builtin::kStoreFastElementIC_NoTransitionHandleCOW;
+      builtin = Builtin::kStoreFastElementIC_NoTransitionHandleCOW;
       break;
     default:
       UNREACHABLE();
   }
-  return isolate->builtins()->CallableFor(isolate, builtin_index);
+  return isolate->builtins()->CallableFor(isolate, builtin);
 }
 
 // static
diff --git a/src/codegen/external-reference.cc b/src/codegen/external-reference.cc
index 1ad0bd37876..80ef463b3e2 100644
--- a/src/codegen/external-reference.cc
+++ b/src/codegen/external-reference.cc
@@ -183,7 +183,8 @@ ExternalReference ExternalReference::isolate_address(Isolate* isolate) {
 }
 
 ExternalReference ExternalReference::builtins_address(Isolate* isolate) {
-  return ExternalReference(isolate->heap()->builtin_address(0));
+  return ExternalReference(
+      isolate->heap()->builtin_address(Builtins::FromInt(0)));
 }
 
 ExternalReference ExternalReference::handle_scope_implementer_address(
diff --git a/src/codegen/ia32/macro-assembler-ia32.cc b/src/codegen/ia32/macro-assembler-ia32.cc
index 5b6f52cb250..b2a7cd9e97f 100644
--- a/src/codegen/ia32/macro-assembler-ia32.cc
+++ b/src/codegen/ia32/macro-assembler-ia32.cc
@@ -226,16 +226,15 @@ Operand TurboAssembler::ExternalReferenceAddressAsOperand(
 Operand TurboAssembler::HeapObjectAsOperand(Handle<HeapObject> object) {
   DCHECK(root_array_available());
 
-  int builtin_index;
+  Builtin builtin;
   RootIndex root_index;
   if (isolate()->roots_table().IsRootHandle(object, &root_index)) {
     return Operand(kRootRegister, RootRegisterOffsetForRootIndex(root_index));
-  } else if (isolate()->builtins()->IsBuiltinHandle(object, &builtin_index)) {
-    return Operand(kRootRegister, RootRegisterOffsetForBuiltin(builtin_index));
+  } else if (isolate()->builtins()->IsBuiltinHandle(object, &builtin)) {
+    return Operand(kRootRegister, RootRegisterOffsetForBuiltin(builtin));
   } else if (object.is_identical_to(code_object_) &&
-             Builtins::IsBuiltinId(maybe_builtin_index_)) {
-    return Operand(kRootRegister,
-                   RootRegisterOffsetForBuiltin(maybe_builtin_index_));
+             Builtins::IsBuiltinId(maybe_builtin_)) {
+    return Operand(kRootRegister, RootRegisterOffsetForBuiltin(maybe_builtin_));
   } else {
     // Objects in the constants table need an additional indirection, which
     // cannot be represented as a single Operand.
@@ -437,7 +436,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object,
   pop(slot_address_parameter);
   pop(object_parameter);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
 
@@ -486,13 +485,12 @@ void TurboAssembler::CallRecordWriteStub(
   if (false) {
 #endif
   } else {
-    auto builtin_index =
+    Builtin builtin =
         Builtins::GetRecordWriteStub(remembered_set_action, fp_mode);
     if (options().inline_offheap_trampolines) {
-      CallBuiltin(builtin_index);
+      CallBuiltin(builtin);
     } else {
-      Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+      Handle<Code> code_target = isolate()->builtins()->code_handle(builtin);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
@@ -2172,10 +2170,10 @@ void TurboAssembler::Call(Handle<Code> code_object, RelocInfo::Mode rmode) {
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtin::kNoBuiltinId;
-    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
+    Builtin builtin = Builtin::kNoBuiltinId;
+    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin)) {
       // Inline the trampoline.
-      CallBuiltin(builtin_index);
+      CallBuiltin(builtin);
       return;
     }
   }
@@ -2203,18 +2201,18 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
   call(builtin_index);
 }
 
-void TurboAssembler::CallBuiltin(int builtin_index) {
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
-  RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
+void TurboAssembler::CallBuiltin(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  RecordCommentForOffHeapTrampoline(builtin);
+  CHECK_NE(builtin, Builtin::kNoBuiltinId);
   EmbeddedData d = EmbeddedData::FromBlob();
-  Address entry = d.InstructionStartOfBuiltin(builtin_index);
+  Address entry = d.InstructionStartOfBuiltin(builtin);
   call(entry, RelocInfo::OFF_HEAP_TARGET);
 }
 
-Operand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
+Operand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin) {
   return Operand(kRootRegister,
-                 IsolateData::builtin_entry_slot_offset(builtin_index));
+                 IsolateData::builtin_entry_slot_offset(builtin));
 }
 
 void TurboAssembler::LoadCodeObjectEntry(Register destination,
@@ -2288,13 +2286,13 @@ void TurboAssembler::Jump(Handle<Code> code_object, RelocInfo::Mode rmode) {
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtin::kNoBuiltinId;
-    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
+    Builtin builtin = Builtin::kNoBuiltinId;
+    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin)) {
       // Inline the trampoline.
-      RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
+      RecordCommentForOffHeapTrampoline(builtin);
+      CHECK_NE(builtin, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
-      Address entry = d.InstructionStartOfBuiltin(builtin_index);
+      Address entry = d.InstructionStartOfBuiltin(builtin);
       jmp(entry, RelocInfo::OFF_HEAP_TARGET);
       return;
     }
diff --git a/src/codegen/ia32/macro-assembler-ia32.h b/src/codegen/ia32/macro-assembler-ia32.h
index ae47971b0d3..cfec105d870 100644
--- a/src/codegen/ia32/macro-assembler-ia32.h
+++ b/src/codegen/ia32/macro-assembler-ia32.h
@@ -139,7 +139,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
   void Move(XMMRegister dst, float src) { Move(dst, bit_cast<uint32_t>(src)); }
   void Move(XMMRegister dst, double src) { Move(dst, bit_cast<uint64_t>(src)); }
 
-  Operand EntryFromBuiltinAsOperand(Builtin builtin_index);
+  Operand EntryFromBuiltinAsOperand(Builtin builtin);
 
   void Call(Register reg) { call(reg); }
   void Call(Operand op) { call(op); }
@@ -150,7 +150,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
   // register.
   void LoadEntryFromBuiltinIndex(Register builtin_index);
   void CallBuiltinByIndex(Register builtin_index);
-  void CallBuiltin(int builtin_index);
+  void CallBuiltin(Builtin builtin);
 
   void LoadCodeObjectEntry(Register destination, Register code_object);
   void CallCodeObject(Register code_object);
diff --git a/src/codegen/mips/macro-assembler-mips.cc b/src/codegen/mips/macro-assembler-mips.cc
index 26f06873fc6..e0e981d2128 100644
--- a/src/codegen/mips/macro-assembler-mips.cc
+++ b/src/codegen/mips/macro-assembler-mips.cc
@@ -250,7 +250,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object,
   Pop(slot_address_parameter);
   Pop(object_parameter);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -310,7 +310,7 @@ void TurboAssembler::CallRecordWriteStub(
       Call(t9);
     } else {
       Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+          isolate()->builtins()->code_handle(builtin_index);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
@@ -3773,10 +3773,10 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK(RelocInfo::IsCodeTarget(rmode));
   BlockTrampolinePoolScope block_trampoline_pool(this);
 
-  int builtin_index = Builtin::kNoBuiltinId;
+  Builtin builtin = Builtin::kNoBuiltinId;
   bool target_is_isolate_independent_builtin =
-      isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
-      Builtins::IsIsolateIndependent(builtin_index);
+      isolate()->builtins()->IsBuiltinHandle(code, &builtin) &&
+      Builtins::IsIsolateIndependent(builtin);
   if (target_is_isolate_independent_builtin &&
       options().use_pc_relative_calls_and_jumps) {
     int32_t code_target_index = AddCodeTarget(code);
@@ -3915,10 +3915,10 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
                           BranchDelaySlot bd) {
   BlockTrampolinePoolScope block_trampoline_pool(this);
 
-  int builtin_index = Builtin::kNoBuiltinId;
+  Builtin builtin = Builtin::kNoBuiltinId;
   bool target_is_isolate_independent_builtin =
-      isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
-      Builtins::IsIsolateIndependent(builtin_index);
+      isolate()->builtins()->IsBuiltinHandle(code, &builtin) &&
+      Builtins::IsIsolateIndependent(builtin);
   if (target_is_isolate_independent_builtin &&
       options().use_pc_relative_calls_and_jumps) {
     int32_t code_target_index = AddCodeTarget(code);
@@ -3938,10 +3938,10 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
   } else if (target_is_isolate_independent_builtin &&
              options().inline_offheap_trampolines) {
     // Inline the trampoline.
-    RecordCommentForOffHeapTrampoline(builtin_index);
-    CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
+    RecordCommentForOffHeapTrampoline(builtin);
+    CHECK_NE(builtin, Builtin::kNoBuiltinId);
     EmbeddedData d = EmbeddedData::FromBlob();
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     li(t9, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
     Call(t9, 0, cond, rs, rt, bd);
     return;
diff --git a/src/codegen/mips64/macro-assembler-mips64.cc b/src/codegen/mips64/macro-assembler-mips64.cc
index 4881d4ad711..c14f6ff2000 100644
--- a/src/codegen/mips64/macro-assembler-mips64.cc
+++ b/src/codegen/mips64/macro-assembler-mips64.cc
@@ -248,7 +248,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object,
   Pop(slot_address_parameter);
   Pop(object_parameter);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -308,7 +308,7 @@ void TurboAssembler::CallRecordWriteStub(
       Call(t9);
     } else {
       Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+          isolate()->builtins()->code_handle(builtin_index);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
diff --git a/src/codegen/optimized-compilation-info.h b/src/codegen/optimized-compilation-info.h
index b5ad1c98162..26eb565ce0b 100644
--- a/src/codegen/optimized-compilation-info.h
+++ b/src/codegen/optimized-compilation-info.h
@@ -131,8 +131,8 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
   Handle<JSFunction> closure() const { return closure_; }
   Handle<Code> code() const { return code_; }
   CodeKind code_kind() const { return code_kind_; }
-  int32_t builtin_index() const { return builtin_index_; }
-  void set_builtin_index(int32_t index) { builtin_index_ = index; }
+  Builtin builtin() const { return builtin_; }
+  void set_builtin(Builtin builtin) { builtin_ = builtin; }
   BytecodeOffset osr_offset() const { return osr_offset_; }
   JavaScriptFrame* osr_frame() const { return osr_frame_; }
   void SetNodeObserver(compiler::NodeObserver* observer) {
@@ -273,7 +273,7 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
       PoisoningMitigationLevel::kDontPoison;
 
   const CodeKind code_kind_;
-  int32_t builtin_index_ = -1;
+  Builtin builtin_ = Builtin::kNoBuiltinId;
 
   // We retain a reference the bytecode array specifically to ensure it doesn't
   // get flushed while we are optimizing the code.
diff --git a/src/codegen/ppc/macro-assembler-ppc.cc b/src/codegen/ppc/macro-assembler-ppc.cc
index 43588cf2624..a117dead48c 100644
--- a/src/codegen/ppc/macro-assembler-ppc.cc
+++ b/src/codegen/ppc/macro-assembler-ppc.cc
@@ -183,7 +183,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   if (root_array_available_ && options().isolate_independent_code) {
     Label skip;
     Register scratch = ip;
-    int offset = code->builtin_index() * kSystemPointerSize +
+    int offset = static_cast<int>(code->builtin_id()) * kSystemPointerSize +
                  IsolateData::builtin_entry_table_offset();
     LoadU64(scratch, MemOperand(kRootRegister, offset), r0);
     if (cond != al) b(NegateCondition(cond), &skip, cr);
@@ -271,7 +271,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
 
   if (root_array_available_ && options().isolate_independent_code) {
     Label skip;
-    int offset = code->builtin_index() * kSystemPointerSize +
+    int offset = static_cast<int>(code->builtin_id()) * kSystemPointerSize +
                  IsolateData::builtin_entry_table_offset();
     LoadU64(ip, MemOperand(kRootRegister, offset));
     if (cond != al) b(NegateCondition(cond), &skip);
@@ -651,7 +651,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object,
   pop(slot_address_parameter);
   pop(object_parameter);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -711,7 +711,7 @@ void TurboAssembler::CallRecordWriteStub(
       Call(ip);
     } else {
       Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+          isolate()->builtins()->code_handle(builtin_index);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
diff --git a/src/codegen/reloc-info.cc b/src/codegen/reloc-info.cc
index 4781e7609be..d818c8d06ff 100644
--- a/src/codegen/reloc-info.cc
+++ b/src/codegen/reloc-info.cc
@@ -276,11 +276,11 @@ RelocIterator::RelocIterator(const CodeReference code_reference, int mode_mask)
 
 RelocIterator::RelocIterator(EmbeddedData* embedded_data, Code code,
                              int mode_mask)
-    : RelocIterator(
-          code, embedded_data->InstructionStartOfBuiltin(code.builtin_index()),
-          code.constant_pool(),
-          code.relocation_start() + code.relocation_size(),
-          code.relocation_start(), mode_mask) {}
+    : RelocIterator(code,
+                    embedded_data->InstructionStartOfBuiltin(code.builtin_id()),
+                    code.constant_pool(),
+                    code.relocation_start() + code.relocation_size(),
+                    code.relocation_start(), mode_mask) {}
 
 RelocIterator::RelocIterator(const CodeDesc& desc, int mode_mask)
     : RelocIterator(Code(), reinterpret_cast<Address>(desc.buffer), 0,
@@ -463,7 +463,7 @@ void RelocInfo::Print(Isolate* isolate, std::ostream& os) {
     DCHECK(code.IsCode());
     os << " (" << CodeKindToString(code.kind());
     if (Builtins::IsBuiltin(code)) {
-      os << " " << Builtins::name(code.builtin_index());
+      os << " " << Builtins::name(code.builtin_id());
     }
     os << ")  (" << reinterpret_cast<const void*>(target_address()) << ")";
   } else if (IsRuntimeEntry(rmode_)) {
diff --git a/src/codegen/riscv64/macro-assembler-riscv64.cc b/src/codegen/riscv64/macro-assembler-riscv64.cc
index 8678d122bb6..29fdccca356 100644
--- a/src/codegen/riscv64/macro-assembler-riscv64.cc
+++ b/src/codegen/riscv64/macro-assembler-riscv64.cc
@@ -251,7 +251,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object,
   Pop(slot_address_parameter);
   Pop(object_parameter);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -311,7 +311,7 @@ void TurboAssembler::CallRecordWriteStub(
       Call(scratch);
     } else {
       Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+          isolate()->builtins()->code_handle(builtin_index);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
@@ -3012,7 +3012,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
     return;
   } else if (root_array_available_ && options().isolate_independent_code &&
              target_is_isolate_independent_builtin) {
-    int offset = code->builtin_index() * kSystemPointerSize +
+    int offset = static_cast<int>(code->builtin_id()) * kSystemPointerSize +
                  IsolateData::builtin_entry_table_offset();
     Ld(t6, MemOperand(kRootRegister, offset));
     Jump(t6, cond, rs, rt);
@@ -3094,7 +3094,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
     return;
   } else if (root_array_available_ && options().isolate_independent_code &&
              target_is_isolate_independent_builtin) {
-    int offset = code->builtin_index() * kSystemPointerSize +
+    int offset = static_cast<int>(code->builtin_id()) * kSystemPointerSize +
                  IsolateData::builtin_entry_table_offset();
     LoadRootRelative(t6, offset);
     Call(t6, cond, rs, rt);
diff --git a/src/codegen/s390/macro-assembler-s390.cc b/src/codegen/s390/macro-assembler-s390.cc
index 968b92e53bc..c0da9f69856 100644
--- a/src/codegen/s390/macro-assembler-s390.cc
+++ b/src/codegen/s390/macro-assembler-s390.cc
@@ -884,7 +884,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object,
   Pop(slot_address_parameter);
   Pop(object_parameter);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -942,7 +942,7 @@ void TurboAssembler::CallRecordWriteStub(
       Call(ip);
     } else {
       Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+          isolate()->builtins()->code_handle(builtin_index);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
diff --git a/src/codegen/turbo-assembler.cc b/src/codegen/turbo-assembler.cc
index 386d1e27e58..77813511a48 100644
--- a/src/codegen/turbo-assembler.cc
+++ b/src/codegen/turbo-assembler.cc
@@ -31,20 +31,19 @@ void TurboAssemblerBase::IndirectLoadConstant(Register destination,
   // Before falling back to the (fairly slow) lookup from the constants table,
   // check if any of the fast paths can be applied.
 
-  int builtin_index;
+  Builtin builtin;
   RootIndex root_index;
   if (isolate()->roots_table().IsRootHandle(object, &root_index)) {
     // Roots are loaded relative to the root register.
     LoadRoot(destination, root_index);
-  } else if (isolate()->builtins()->IsBuiltinHandle(object, &builtin_index)) {
+  } else if (isolate()->builtins()->IsBuiltinHandle(object, &builtin)) {
     // Similar to roots, builtins may be loaded from the builtins table.
-    LoadRootRelative(destination, RootRegisterOffsetForBuiltin(builtin_index));
+    LoadRootRelative(destination, RootRegisterOffsetForBuiltin(builtin));
   } else if (object.is_identical_to(code_object_) &&
-             Builtins::IsBuiltinId(maybe_builtin_index_)) {
+             Builtins::IsBuiltinId(maybe_builtin_)) {
     // The self-reference loaded through Codevalue() may also be a builtin
     // and thus viable for a fast load.
-    LoadRootRelative(destination,
-                     RootRegisterOffsetForBuiltin(maybe_builtin_index_));
+    LoadRootRelative(destination, RootRegisterOffsetForBuiltin(maybe_builtin_));
   } else {
     CHECK(isolate()->IsGeneratingEmbeddedBuiltins());
     // Ensure the given object is in the builtins constants table and fetch its
@@ -83,8 +82,8 @@ int32_t TurboAssemblerBase::RootRegisterOffsetForRootIndex(
 }
 
 // static
-int32_t TurboAssemblerBase::RootRegisterOffsetForBuiltin(int builtin_index) {
-  return IsolateData::builtin_slot_offset(builtin_index);
+int32_t TurboAssemblerBase::RootRegisterOffsetForBuiltin(Builtin builtin) {
+  return IsolateData::builtin_slot_offset(builtin);
 }
 
 // static
diff --git a/src/codegen/turbo-assembler.h b/src/codegen/turbo-assembler.h
index e2f28b6f53c..79bf37033e8 100644
--- a/src/codegen/turbo-assembler.h
+++ b/src/codegen/turbo-assembler.h
@@ -53,7 +53,7 @@ class V8_EXPORT_PRIVATE TurboAssemblerBase : public Assembler {
   bool should_abort_hard() const { return hard_abort_; }
   void set_abort_hard(bool v) { hard_abort_ = v; }
 
-  void set_builtin_index(int i) { maybe_builtin_index_ = i; }
+  void set_builtin(Builtin builtin) { maybe_builtin_ = builtin; }
 
   void set_has_frame(bool v) { has_frame_ = v; }
   bool has_frame() const { return has_frame_; }
@@ -77,7 +77,7 @@ class V8_EXPORT_PRIVATE TurboAssemblerBase : public Assembler {
   virtual void LoadRoot(Register destination, RootIndex index) = 0;
 
   static int32_t RootRegisterOffsetForRootIndex(RootIndex root_index);
-  static int32_t RootRegisterOffsetForBuiltin(int builtin_index);
+  static int32_t RootRegisterOffsetForBuiltin(Builtin builtin);
 
   // Returns the root-relative offset to reference.address().
   static intptr_t RootRegisterOffsetForExternalReference(
@@ -99,10 +99,10 @@ class V8_EXPORT_PRIVATE TurboAssemblerBase : public Assembler {
   static constexpr int kStackPageSize = 4 * KB;
 #endif
 
-  V8_INLINE void RecordCommentForOffHeapTrampoline(int builtin_index) {
+  V8_INLINE void RecordCommentForOffHeapTrampoline(Builtin builtin) {
     if (!FLAG_code_comments) return;
     std::ostringstream str;
-    str << "[ Inlined Trampoline to " << Builtins::name(builtin_index);
+    str << "[ Inlined Trampoline to " << Builtins::name(builtin);
     RecordComment(str.str().c_str());
   }
 
@@ -124,7 +124,7 @@ class V8_EXPORT_PRIVATE TurboAssemblerBase : public Assembler {
   bool hard_abort_ = false;
 
   // May be set while generating builtins.
-  int maybe_builtin_index_ = Builtin::kNoBuiltinId;
+  Builtin maybe_builtin_ = Builtin::kNoBuiltinId;
 
   bool has_frame_ = false;
 
diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index b26d46e097e..f5c1ddc51e5 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -424,7 +424,7 @@ void TurboAssembler::CallEphemeronKeyBarrier(Register object,
       WriteBarrierDescriptor::SlotAddressRegister();
   MovePair(slot_address_parameter, slot_address, object_parameter, object);
 
-  Call(isolate()->builtins()->builtin_handle(
+  Call(isolate()->builtins()->code_handle(
            Builtins::GetEphemeronKeyBarrierStub(fp_mode)),
        RelocInfo::CODE_TARGET);
   MaybeRestoreRegisters(registers);
@@ -466,13 +466,12 @@ void TurboAssembler::CallRecordWriteStub(
   if (false) {
 #endif
   } else {
-    auto builtin_index =
+    Builtin builtin =
         Builtins::GetRecordWriteStub(remembered_set_action, fp_mode);
     if (options().inline_offheap_trampolines) {
-      CallBuiltin(builtin_index);
+      CallBuiltin(builtin);
     } else {
-      Handle<Code> code_target =
-          isolate()->builtins()->builtin_handle(builtin_index);
+      Handle<Code> code_target = isolate()->builtins()->code_handle(builtin);
       Call(code_target, RelocInfo::CODE_TARGET);
     }
   }
@@ -499,9 +498,8 @@ void TurboAssembler::CallTSANRelaxedStoreStub(Register address, Register value,
   MovePair(address_parameter, address, value_parameter, value);
 
   if (isolate()) {
-    auto builtin_index = Builtins::GetTSANRelaxedStoreStub(fp_mode, size);
-    Handle<Code> code_target =
-        isolate()->builtins()->builtin_handle(builtin_index);
+    Builtin builtin = Builtins::GetTSANRelaxedStoreStub(fp_mode, size);
+    Handle<Code> code_target = isolate()->builtins()->code_handle(builtin);
     Call(code_target, RelocInfo::CODE_TARGET);
   }
 #if V8_ENABLE_WEBASSEMBLY
@@ -1653,14 +1651,14 @@ void TurboAssembler::Jump(Handle<Code> code_object, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtin::kNoBuiltinId;
-    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
+    Builtin builtin = Builtin::kNoBuiltinId;
+    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin)) {
       Label skip;
       if (cc != always) {
         if (cc == never) return;
         j(NegateCondition(cc), &skip, Label::kNear);
       }
-      TailCallBuiltin(builtin_index);
+      TailCallBuiltin(builtin);
       bind(&skip);
       return;
     }
@@ -1696,10 +1694,10 @@ void TurboAssembler::Call(Handle<Code> code_object, RelocInfo::Mode rmode) {
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtin::kNoBuiltinId;
-    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
+    Builtin builtin = Builtin::kNoBuiltinId;
+    if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin)) {
       // Inline the trampoline.
-      CallBuiltin(builtin_index);
+      CallBuiltin(builtin);
       return;
     }
   }
@@ -1707,10 +1705,10 @@ void TurboAssembler::Call(Handle<Code> code_object, RelocInfo::Mode rmode) {
   call(code_object, rmode);
 }
 
-Operand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
+Operand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin) {
   DCHECK(root_array_available());
   return Operand(kRootRegister,
-                 IsolateData::builtin_entry_slot_offset(builtin_index));
+                 IsolateData::builtin_entry_slot_offset(builtin));
 }
 
 Operand TurboAssembler::EntryFromBuiltinIndexAsOperand(Register builtin_index) {
@@ -1734,36 +1732,36 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
   Call(EntryFromBuiltinIndexAsOperand(builtin_index));
 }
 
-void TurboAssembler::CallBuiltin(int builtin_index) {
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
-  RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
+void TurboAssembler::CallBuiltin(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  RecordCommentForOffHeapTrampoline(builtin);
+  CHECK_NE(builtin, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     call(entry, RelocInfo::RUNTIME_ENTRY);
 
   } else {
     EmbeddedData d = EmbeddedData::FromBlob();
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     Move(kScratchRegister, entry, RelocInfo::OFF_HEAP_TARGET);
     call(kScratchRegister);
   }
   RecordComment("]");
 }
 
-void TurboAssembler::TailCallBuiltin(int builtin_index) {
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
-  RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
+void TurboAssembler::TailCallBuiltin(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  RecordCommentForOffHeapTrampoline(builtin);
+  CHECK_NE(builtin, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     jmp(entry, RelocInfo::RUNTIME_ENTRY);
 
   } else {
     EmbeddedData d = EmbeddedData::FromBlob();
-    Address entry = d.InstructionStartOfBuiltin(builtin_index);
+    Address entry = d.InstructionStartOfBuiltin(builtin);
     Jump(entry, RelocInfo::OFF_HEAP_TARGET);
   }
   RecordComment("]");
diff --git a/src/codegen/x64/macro-assembler-x64.h b/src/codegen/x64/macro-assembler-x64.h
index 37e6bfdc4b0..3182da2dc4a 100644
--- a/src/codegen/x64/macro-assembler-x64.h
+++ b/src/codegen/x64/macro-assembler-x64.h
@@ -343,16 +343,8 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
   Operand EntryFromBuiltinAsOperand(Builtin builtin_index);
   Operand EntryFromBuiltinIndexAsOperand(Register builtin_index);
   void CallBuiltinByIndex(Register builtin_index);
-  void CallBuiltin(Builtin builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtin one.
-    return CallBuiltin(static_cast<int>(builtin));
-  }
-  void CallBuiltin(int builtin_index);
-  void TailCallBuiltin(Builtin builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtin one.
-    return TailCallBuiltin(static_cast<int>(builtin));
-  }
-  void TailCallBuiltin(int builtin_index);
+  void CallBuiltin(Builtin builtin);
+  void TailCallBuiltin(Builtin builtin);
 
   void LoadCodeObjectEntry(Register destination, Register code_object);
   void CallCodeObject(Register code_object);
diff --git a/src/compiler/backend/arm/code-generator-arm.cc b/src/compiler/backend/arm/code-generator-arm.cc
index 283ba8d23e5..b8a1c81937c 100644
--- a/src/compiler/backend/arm/code-generator-arm.cc
+++ b/src/compiler/backend/arm/code-generator-arm.cc
@@ -910,7 +910,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ stop();
diff --git a/src/compiler/backend/arm64/code-generator-arm64.cc b/src/compiler/backend/arm64/code-generator-arm64.cc
index 7798269156c..0e8b9cd9150 100644
--- a/src/compiler/backend/arm64/code-generator-arm64.cc
+++ b/src/compiler/backend/arm64/code-generator-arm64.cc
@@ -942,7 +942,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ Debug("kArchAbortCSAAssert", 0, BREAK);
diff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.cc
index f1ab34b47a1..85ea94f4c66 100644
--- a/src/compiler/backend/code-generator.cc
+++ b/src/compiler/backend/code-generator.cc
@@ -47,7 +47,7 @@ CodeGenerator::CodeGenerator(
     Isolate* isolate, base::Optional<OsrHelper> osr_helper,
     int start_source_position, JumpOptimizationInfo* jump_opt,
     PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options,
-    int32_t builtin_index, size_t max_unoptimized_frame_height,
+    Builtin builtin, size_t max_unoptimized_frame_height,
     size_t max_pushed_argument_count, std::unique_ptr<AssemblerBuffer> buffer,
     const char* debug_name)
     : zone_(codegen_zone),
@@ -98,7 +98,7 @@ CodeGenerator::CodeGenerator(
       code_kind == CodeKind::JS_TO_WASM_FUNCTION) {
     tasm_.set_abort_hard(true);
   }
-  tasm_.set_builtin_index(builtin_index);
+  tasm_.set_builtin(builtin);
 }
 
 bool CodeGenerator::wasm_runtime_exception_support() const {
@@ -561,9 +561,8 @@ MaybeHandle<Code> CodeGenerator::FinalizeCode() {
   tasm()->GetCode(isolate(), &desc, safepoints(), handler_table_offset_);
 
 #if defined(V8_OS_WIN64)
-  if (Builtins::IsBuiltinId(info_->builtin_index())) {
-    isolate_->SetBuiltinUnwindData(info_->builtin_index(),
-                                   tasm()->GetUnwindInfo());
+  if (Builtins::IsBuiltinId(info_->builtin())) {
+    isolate_->SetBuiltinUnwindData(info_->builtin(), tasm()->GetUnwindInfo());
   }
 #endif  // V8_OS_WIN64
 
@@ -573,7 +572,7 @@ MaybeHandle<Code> CodeGenerator::FinalizeCode() {
 
   MaybeHandle<Code> maybe_code =
       Factory::CodeBuilder(isolate(), desc, info()->code_kind())
-          .set_builtin_index(info()->builtin_index())
+          .set_builtin(info()->builtin())
           .set_inlined_bytecode_size(info()->inlined_bytecode_size())
           .set_source_position_table(source_positions)
           .set_deoptimization_data(deopt_data)
diff --git a/src/compiler/backend/code-generator.h b/src/compiler/backend/code-generator.h
index f1f7c3934f5..5c07f87a952 100644
--- a/src/compiler/backend/code-generator.h
+++ b/src/compiler/backend/code-generator.h
@@ -126,7 +126,7 @@ class V8_EXPORT_PRIVATE CodeGenerator final : public GapResolver::Assembler {
       Isolate* isolate, base::Optional<OsrHelper> osr_helper,
       int start_source_position, JumpOptimizationInfo* jump_opt,
       PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options,
-      int32_t builtin_index, size_t max_unoptimized_frame_height,
+      Builtin builtin, size_t max_unoptimized_frame_height,
       size_t max_pushed_argument_count, std::unique_ptr<AssemblerBuffer> = {},
       const char* debug_name = nullptr);
 
diff --git a/src/compiler/backend/ia32/code-generator-ia32.cc b/src/compiler/backend/ia32/code-generator-ia32.cc
index 59dcc34d613..5541f648979 100644
--- a/src/compiler/backend/ia32/code-generator-ia32.cc
+++ b/src/compiler/backend/ia32/code-generator-ia32.cc
@@ -928,7 +928,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ int3();
diff --git a/src/compiler/backend/mips/code-generator-mips.cc b/src/compiler/backend/mips/code-generator-mips.cc
index 560cd9308b6..6d7792914d6 100644
--- a/src/compiler/backend/mips/code-generator-mips.cc
+++ b/src/compiler/backend/mips/code-generator-mips.cc
@@ -851,7 +851,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ stop();
diff --git a/src/compiler/backend/mips64/code-generator-mips64.cc b/src/compiler/backend/mips64/code-generator-mips64.cc
index aa5145ea904..c732f105f91 100644
--- a/src/compiler/backend/mips64/code-generator-mips64.cc
+++ b/src/compiler/backend/mips64/code-generator-mips64.cc
@@ -813,7 +813,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ stop();
diff --git a/src/compiler/backend/ppc/code-generator-ppc.cc b/src/compiler/backend/ppc/code-generator-ppc.cc
index 86013b1bc58..f108c0e3e6b 100644
--- a/src/compiler/backend/ppc/code-generator-ppc.cc
+++ b/src/compiler/backend/ppc/code-generator-ppc.cc
@@ -1147,7 +1147,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ stop();
diff --git a/src/compiler/backend/riscv64/code-generator-riscv64.cc b/src/compiler/backend/riscv64/code-generator-riscv64.cc
index f7909efe45f..947bb2914b8 100644
--- a/src/compiler/backend/riscv64/code-generator-riscv64.cc
+++ b/src/compiler/backend/riscv64/code-generator-riscv64.cc
@@ -786,7 +786,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ stop();
diff --git a/src/compiler/backend/s390/code-generator-s390.cc b/src/compiler/backend/s390/code-generator-s390.cc
index eebc9249150..219b8928bbe 100644
--- a/src/compiler/backend/s390/code-generator-s390.cc
+++ b/src/compiler/backend/s390/code-generator-s390.cc
@@ -1297,7 +1297,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ stop();
diff --git a/src/compiler/backend/x64/code-generator-x64.cc b/src/compiler/backend/x64/code-generator-x64.cc
index 9bb8b92a688..9251ae7e742 100644
--- a/src/compiler/backend/x64/code-generator-x64.cc
+++ b/src/compiler/backend/x64/code-generator-x64.cc
@@ -1203,7 +1203,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+        __ Call(isolate()->builtins()->code_handle(Builtin::kAbortCSAAssert),
                 RelocInfo::CODE_TARGET);
       }
       __ int3();
diff --git a/src/compiler/bytecode-graph-builder.cc b/src/compiler/bytecode-graph-builder.cc
index 4621033f8d5..5aed8ab9a10 100644
--- a/src/compiler/bytecode-graph-builder.cc
+++ b/src/compiler/bytecode-graph-builder.cc
@@ -2286,7 +2286,7 @@ void BytecodeGraphBuilder::VisitCreateClosure() {
 
   const Operator* op = javascript()->CreateClosure(
       shared_info.object(),
-      jsgraph()->isolate()->builtins()->builtin_handle(Builtin::kCompileLazy),
+      jsgraph()->isolate()->builtins()->code_handle(Builtin::kCompileLazy),
       allocation);
   Node* closure = NewNode(
       op, BuildLoadFeedbackCell(bytecode_iterator().GetIndexOperand(1)));
diff --git a/src/compiler/code-assembler.cc b/src/compiler/code-assembler.cc
index 8ff1777366d..c9d4c388c94 100644
--- a/src/compiler/code-assembler.cc
+++ b/src/compiler/code-assembler.cc
@@ -47,7 +47,7 @@ static_assert(
 CodeAssemblerState::CodeAssemblerState(
     Isolate* isolate, Zone* zone, const CallInterfaceDescriptor& descriptor,
     CodeKind kind, const char* name, PoisoningMitigationLevel poisoning_level,
-    int32_t builtin_index)
+    Builtin builtin)
     // TODO(rmcilroy): Should we use Linkage::GetBytecodeDispatchDescriptor for
     // bytecode handlers?
     : CodeAssemblerState(
@@ -55,24 +55,24 @@ CodeAssemblerState::CodeAssemblerState(
           Linkage::GetStubCallDescriptor(
               zone, descriptor, descriptor.GetStackParameterCount(),
               CallDescriptor::kNoFlags, Operator::kNoProperties),
-          kind, name, poisoning_level, builtin_index) {}
+          kind, name, poisoning_level, builtin) {}
 
 CodeAssemblerState::CodeAssemblerState(Isolate* isolate, Zone* zone,
                                        int parameter_count, CodeKind kind,
                                        const char* name,
                                        PoisoningMitigationLevel poisoning_level,
-                                       int32_t builtin_index)
+                                       Builtin builtin)
     : CodeAssemblerState(
           isolate, zone,
           Linkage::GetJSCallDescriptor(zone, false, parameter_count,
                                        CallDescriptor::kCanUseRoots),
-          kind, name, poisoning_level, builtin_index) {}
+          kind, name, poisoning_level, builtin) {}
 
 CodeAssemblerState::CodeAssemblerState(Isolate* isolate, Zone* zone,
                                        CallDescriptor* call_descriptor,
                                        CodeKind kind, const char* name,
                                        PoisoningMitigationLevel poisoning_level,
-                                       int32_t builtin_index)
+                                       Builtin builtin)
     : raw_assembler_(new RawMachineAssembler(
           isolate, zone->New<Graph>(zone), call_descriptor,
           MachineType::PointerRepresentation(),
@@ -80,7 +80,7 @@ CodeAssemblerState::CodeAssemblerState(Isolate* isolate, Zone* zone,
           InstructionSelector::AlignmentRequirements(), poisoning_level)),
       kind_(kind),
       name_(name),
-      builtin_index_(builtin_index),
+      builtin_(builtin),
       code_generated_(false),
       variables_(zone),
       jsgraph_(zone->New<JSGraph>(
@@ -182,12 +182,11 @@ Handle<Code> CodeAssembler::GenerateCode(
   Handle<Code> code;
   Graph* graph = rasm->ExportForOptimization();
 
-  code =
-      Pipeline::GenerateCodeForCodeStub(
-          rasm->isolate(), rasm->call_descriptor(), graph, state->jsgraph_,
-          rasm->source_positions(), state->kind_, state->name_,
-          state->builtin_index_, rasm->poisoning_level(), options, profile_data)
-          .ToHandleChecked();
+  code = Pipeline::GenerateCodeForCodeStub(
+             rasm->isolate(), rasm->call_descriptor(), graph, state->jsgraph_,
+             rasm->source_positions(), state->kind_, state->name_,
+             state->builtin_, rasm->poisoning_level(), options, profile_data)
+             .ToHandleChecked();
 
   state->code_generated_ = true;
   return code;
diff --git a/src/compiler/code-assembler.h b/src/compiler/code-assembler.h
index d6356405dba..39e8703a118 100644
--- a/src/compiler/code-assembler.h
+++ b/src/compiler/code-assembler.h
@@ -1616,13 +1616,13 @@ class V8_EXPORT_PRIVATE CodeAssemblerState {
   CodeAssemblerState(Isolate* isolate, Zone* zone,
                      const CallInterfaceDescriptor& descriptor, CodeKind kind,
                      const char* name, PoisoningMitigationLevel poisoning_level,
-                     int32_t builtin_index = Builtin::kNoBuiltinId);
+                     Builtin builtin = Builtin::kNoBuiltinId);
 
   // Create with JSCall linkage.
   CodeAssemblerState(Isolate* isolate, Zone* zone, int parameter_count,
                      CodeKind kind, const char* name,
                      PoisoningMitigationLevel poisoning_level,
-                     int32_t builtin_index = Builtin::kNoBuiltinId);
+                     Builtin builtin = Builtin::kNoBuiltinId);
 
   ~CodeAssemblerState();
 
@@ -1649,7 +1649,7 @@ class V8_EXPORT_PRIVATE CodeAssemblerState {
   CodeAssemblerState(Isolate* isolate, Zone* zone,
                      CallDescriptor* call_descriptor, CodeKind kind,
                      const char* name, PoisoningMitigationLevel poisoning_level,
-                     int32_t builtin_index);
+                     Builtin builtin);
 
   void PushExceptionHandler(CodeAssemblerExceptionHandlerLabel* label);
   void PopExceptionHandler();
@@ -1657,7 +1657,7 @@ class V8_EXPORT_PRIVATE CodeAssemblerState {
   std::unique_ptr<RawMachineAssembler> raw_assembler_;
   CodeKind kind_;
   const char* name_;
-  int32_t builtin_index_;
+  Builtin builtin_;
   bool code_generated_;
   ZoneSet<CodeAssemblerVariable::Impl*, CodeAssemblerVariable::ImplComparator>
       variables_;
diff --git a/src/compiler/heap-refs.cc b/src/compiler/heap-refs.cc
index 388f577ae42..e951aa6686d 100644
--- a/src/compiler/heap-refs.cc
+++ b/src/compiler/heap-refs.cc
@@ -1946,7 +1946,7 @@ class SharedFunctionInfoData : public HeapObjectData {
   SharedFunctionInfoData(JSHeapBroker* broker, ObjectData** storage,
                          Handle<SharedFunctionInfo> object);
 
-  int builtin_id() const { return builtin_id_; }
+  Builtin builtin_id() const { return builtin_id_; }
   int context_header_size() const { return context_header_size_; }
   ObjectData* GetBytecodeArray() const { return GetBytecodeArray_; }
   SharedFunctionInfo::Inlineability GetInlineability() const {
@@ -1974,7 +1974,7 @@ class SharedFunctionInfoData : public HeapObjectData {
 #undef DECL_ACCESSOR
 
  private:
-  int const builtin_id_;
+  Builtin const builtin_id_;
   int const context_header_size_;
   ObjectData* const GetBytecodeArray_;
 #define DECL_MEMBER(type, name) type const name##_;
@@ -3473,7 +3473,7 @@ BIMODAL_ACCESSOR_C(ScopeInfo, bool, HasContextExtensionSlot)
 BIMODAL_ACCESSOR_C(ScopeInfo, bool, HasOuterScopeInfo)
 BIMODAL_ACCESSOR(ScopeInfo, ScopeInfo, OuterScopeInfo)
 
-BIMODAL_ACCESSOR_C(SharedFunctionInfo, int, builtin_id)
+BIMODAL_ACCESSOR_C(SharedFunctionInfo, Builtin, builtin_id)
 BytecodeArrayRef SharedFunctionInfoRef::GetBytecodeArray() const {
   if (data_->should_access_heap() || broker()->is_concurrent_inlining()) {
     BytecodeArray bytecode_array;
diff --git a/src/compiler/heap-refs.h b/src/compiler/heap-refs.h
index 1ad05d4ce7e..e2cd9fa67f9 100644
--- a/src/compiler/heap-refs.h
+++ b/src/compiler/heap-refs.h
@@ -909,7 +909,7 @@ class V8_EXPORT_PRIVATE SharedFunctionInfoRef : public HeapObjectRef {
 
   Handle<SharedFunctionInfo> object() const;
 
-  int builtin_id() const;
+  Builtin builtin_id() const;
   int context_header_size() const;
   BytecodeArrayRef GetBytecodeArray() const;
   SharedFunctionInfo::Inlineability GetInlineability() const;
diff --git a/src/compiler/js-call-reducer.cc b/src/compiler/js-call-reducer.cc
index 87bde1c5c39..5fd715887dc 100644
--- a/src/compiler/js-call-reducer.cc
+++ b/src/compiler/js-call-reducer.cc
@@ -840,8 +840,8 @@ class PromiseBuiltinReducerAssembler : public JSCallReducerAssembler {
     DCHECK(shared.HasBuiltinId());
     Handle<FeedbackCell> feedback_cell =
         isolate()->factory()->many_closures_cell();
-    Callable const callable = Builtins::CallableFor(
-        isolate(), static_cast<Builtin>(shared.builtin_id()));
+    Callable const callable =
+        Builtins::CallableFor(isolate(), shared.builtin_id());
     return AddNode<JSFunction>(graph()->NewNode(
         javascript()->CreateClosure(shared.object(), callable.code()),
         HeapConstant(feedback_cell), context, effect(), control()));
@@ -4501,9 +4501,9 @@ Reduction JSCallReducer::ReduceJSCall(Node* node,
 
   // Check for known builtin functions.
 
-  int builtin_id =
+  Builtin builtin =
       shared.HasBuiltinId() ? shared.builtin_id() : Builtin::kNoBuiltinId;
-  switch (builtin_id) {
+  switch (builtin) {
     case Builtin::kArrayConstructor:
       return ReduceArrayConstructor(node);
     case Builtin::kBooleanConstructor:
@@ -4964,10 +4964,10 @@ Reduction JSCallReducer::ReduceJSConstruct(Node* node) {
       }
 
       // Check for known builtin functions.
-      int builtin_id = function.shared().HasBuiltinId()
-                           ? function.shared().builtin_id()
-                           : Builtin::kNoBuiltinId;
-      switch (builtin_id) {
+      Builtin builtin = function.shared().HasBuiltinId()
+                            ? function.shared().builtin_id()
+                            : Builtin::kNoBuiltinId;
+      switch (builtin) {
         case Builtin::kArrayConstructor: {
           // TODO(bmeurer): Deal with Array subclasses here.
           // Turn the {node} into a {JSCreateArray} call.
@@ -5829,14 +5829,14 @@ Reduction JSCallReducer::ReduceArrayPrototypeShift(Node* node) {
       Node* vfalse1;
       {
         // Call the generic C++ implementation.
-        const int builtin_index = Builtin::kArrayShift;
+        const Builtin builtin = Builtin::kArrayShift;
         auto call_descriptor = Linkage::GetCEntryStubCallDescriptor(
             graph()->zone(), 1, BuiltinArguments::kNumExtraArgsWithReceiver,
-            Builtins::name(builtin_index), node->op()->properties(),
+            Builtins::name(builtin), node->op()->properties(),
             CallDescriptor::kNeedsFrameState);
         Node* stub_code = jsgraph()->CEntryStubConstant(
             1, SaveFPRegsMode::kIgnore, ArgvMode::kStack, true);
-        Address builtin_entry = Builtins::CppEntryOf(builtin_index);
+        Address builtin_entry = Builtins::CppEntryOf(builtin);
         Node* entry = jsgraph()->ExternalConstant(
             ExternalReference::Create(builtin_entry));
         Node* argc =
@@ -6756,8 +6756,8 @@ Node* JSCallReducer::CreateClosureFromBuiltinSharedFunctionInfo(
   DCHECK(shared.HasBuiltinId());
   Handle<FeedbackCell> feedback_cell =
       isolate()->factory()->many_closures_cell();
-  Callable const callable = Builtins::CallableFor(
-      isolate(), static_cast<Builtin>(shared.builtin_id()));
+  Callable const callable =
+      Builtins::CallableFor(isolate(), shared.builtin_id());
   return graph()->NewNode(
       javascript()->CreateClosure(shared.object(), callable.code()),
       jsgraph()->HeapConstant(feedback_cell), context, effect, control);
diff --git a/src/compiler/js-generic-lowering.cc b/src/compiler/js-generic-lowering.cc
index 4a1c5a28de4..21c8398608b 100644
--- a/src/compiler/js-generic-lowering.cc
+++ b/src/compiler/js-generic-lowering.cc
@@ -162,7 +162,7 @@ void JSGenericLowering::ReplaceBinaryOpWithBuiltinCall(
     Node* node, Builtin builtin_without_feedback,
     Builtin builtin_with_feedback) {
   DCHECK(JSOperator::IsBinaryWithFeedback(node->opcode()));
-  Builtin builtin_id;
+  Builtin builtin;
   const FeedbackParameter& p = FeedbackParameterOf(node->op());
   if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {
     Node* slot = jsgraph()->UintPtrConstant(p.feedback().slot.ToInt());
@@ -171,13 +171,13 @@ void JSGenericLowering::ReplaceBinaryOpWithBuiltinCall(
     STATIC_ASSERT(JSBinaryOpNode::FeedbackVectorIndex() == 2);
     DCHECK_EQ(node->op()->ValueInputCount(), 3);
     node->InsertInput(zone(), 2, slot);
-    builtin_id = builtin_with_feedback;
+    builtin = builtin_with_feedback;
   } else {
     node->RemoveInput(JSBinaryOpNode::FeedbackVectorIndex());
-    builtin_id = builtin_without_feedback;
+    builtin = builtin_without_feedback;
   }
 
-  ReplaceWithBuiltinCall(node, builtin_id);
+  ReplaceWithBuiltinCall(node, builtin);
 }
 
 #define DEF_BINARY_LOWERING(Name)                                    \
@@ -213,7 +213,7 @@ void JSGenericLowering::LowerJSStrictEqual(Node* node) {
   DCHECK_EQ(node->op()->ControlInputCount(), 1);
   node->RemoveInput(NodeProperties::FirstControlIndex(node));
 
-  Builtin builtin_id;
+  Builtin builtin;
   const FeedbackParameter& p = FeedbackParameterOf(node->op());
   if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {
     Node* slot = jsgraph()->UintPtrConstant(p.feedback().slot.ToInt());
@@ -222,13 +222,13 @@ void JSGenericLowering::LowerJSStrictEqual(Node* node) {
     STATIC_ASSERT(JSStrictEqualNode::FeedbackVectorIndex() == 2);
     DCHECK_EQ(node->op()->ValueInputCount(), 3);
     node->InsertInput(zone(), 2, slot);
-    builtin_id = Builtin::kStrictEqual_WithFeedback;
+    builtin = Builtin::kStrictEqual_WithFeedback;
   } else {
     node->RemoveInput(JSStrictEqualNode::FeedbackVectorIndex());
-    builtin_id = Builtin::kStrictEqual;
+    builtin = Builtin::kStrictEqual;
   }
 
-  Callable callable = Builtins::CallableFor(isolate(), builtin_id);
+  Callable callable = Builtins::CallableFor(isolate(), builtin);
   ReplaceWithBuiltinCall(node, callable, CallDescriptor::kNoFlags,
                          Operator::kEliminatable);
 }
diff --git a/src/compiler/js-typed-lowering.cc b/src/compiler/js-typed-lowering.cc
index fa8da3bd8f7..833afaf31d8 100644
--- a/src/compiler/js-typed-lowering.cc
+++ b/src/compiler/js-typed-lowering.cc
@@ -1498,7 +1498,7 @@ Reduction JSTypedLowering::ReduceJSStoreModule(Node* node) {
 
 namespace {
 
-void ReduceBuiltin(JSGraph* jsgraph, Node* node, int builtin_index, int arity,
+void ReduceBuiltin(JSGraph* jsgraph, Node* node, Builtin builtin, int arity,
                    CallDescriptor::Flags flags) {
   // Patch {node} to a direct CEntry call.
   // ----------- A r g u m e n t s -----------
@@ -1539,7 +1539,7 @@ void ReduceBuiltin(JSGraph* jsgraph, Node* node, int builtin_index, int arity,
 
   // CPP builtins are implemented in C++, and we can inline it.
   // CPP builtins create a builtin exit frame.
-  DCHECK(Builtins::IsCpp(builtin_index));
+  DCHECK(Builtins::IsCpp(builtin));
   const bool has_builtin_exit_frame = true;
 
   Node* stub = jsgraph->CEntryStubConstant(
@@ -1556,7 +1556,7 @@ void ReduceBuiltin(JSGraph* jsgraph, Node* node, int builtin_index, int arity,
   node->InsertInput(zone, 4, jsgraph->PaddingConstant());
   int cursor = arity + kStubAndReceiver + BuiltinArguments::kNumExtraArgs;
 
-  Address entry = Builtins::CppEntryOf(builtin_index);
+  Address entry = Builtins::CppEntryOf(builtin);
   ExternalReference entry_ref = ExternalReference::Create(entry);
   Node* entry_node = jsgraph->ExternalConstant(entry_ref);
 
@@ -1564,7 +1564,7 @@ void ReduceBuiltin(JSGraph* jsgraph, Node* node, int builtin_index, int arity,
   node->InsertInput(zone, cursor++, argc_node);
 
   static const int kReturnCount = 1;
-  const char* debug_name = Builtins::name(builtin_index);
+  const char* debug_name = Builtins::name(builtin);
   Operator::Properties properties = node->op()->properties();
   auto call_descriptor = Linkage::GetCEntryStubCallDescriptor(
       zone, kReturnCount, argc, debug_name, properties, flags,
@@ -1787,8 +1787,8 @@ Reduction JSTypedLowering::ReduceJSCall(Node* node) {
     } else if (shared->HasBuiltinId()) {
       DCHECK(Builtins::HasJSLinkage(shared->builtin_id()));
       // Patch {node} to a direct code object call.
-      Callable callable = Builtins::CallableFor(
-          isolate(), static_cast<Builtin>(shared->builtin_id()));
+      Callable callable =
+          Builtins::CallableFor(isolate(), shared->builtin_id());
       CallDescriptor::Flags flags = CallDescriptor::kNeedsFrameState;
 
       const CallInterfaceDescriptor& descriptor = callable.descriptor();
diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index 270af9ac026..c8543bab52a 100644
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -551,7 +551,7 @@ class PipelineData {
         codegen_zone(), frame(), linkage, sequence(), info(), isolate(),
         osr_helper_, start_source_position_, jump_optimization_info_,
         info()->GetPoisoningMitigationLevel(), assembler_options_,
-        info_->builtin_index(), max_unoptimized_frame_height(),
+        info_->builtin(), max_unoptimized_frame_height(),
         max_pushed_argument_count(), std::move(buffer),
         FLAG_trace_turbo_stack_accesses ? debug_name_.get() : nullptr);
   }
@@ -3009,11 +3009,11 @@ int HashGraphForPGO(Graph* graph) {
 MaybeHandle<Code> Pipeline::GenerateCodeForCodeStub(
     Isolate* isolate, CallDescriptor* call_descriptor, Graph* graph,
     JSGraph* jsgraph, SourcePositionTable* source_positions, CodeKind kind,
-    const char* debug_name, int32_t builtin_index,
+    const char* debug_name, Builtin builtin,
     PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options,
     const ProfileDataFromFile* profile_data) {
   OptimizedCompilationInfo info(CStrVector(debug_name), graph->zone(), kind);
-  info.set_builtin_index(builtin_index);
+  info.set_builtin(builtin);
 
   if (poisoning_level != PoisoningMitigationLevel::kDontPoison) {
     info.SetPoisoningMitigationLevel(poisoning_level);
diff --git a/src/compiler/pipeline.h b/src/compiler/pipeline.h
index d07dcb5a722..8a0aeba394f 100644
--- a/src/compiler/pipeline.h
+++ b/src/compiler/pipeline.h
@@ -79,7 +79,7 @@ class Pipeline : public AllStatic {
   static MaybeHandle<Code> GenerateCodeForCodeStub(
       Isolate* isolate, CallDescriptor* call_descriptor, Graph* graph,
       JSGraph* jsgraph, SourcePositionTable* source_positions, CodeKind kind,
-      const char* debug_name, int32_t builtin_index,
+      const char* debug_name, Builtin builtin,
       PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options,
       const ProfileDataFromFile* profile_data);
 
diff --git a/src/compiler/serializer-for-background-compilation.cc b/src/compiler/serializer-for-background-compilation.cc
index 5a798926c9c..ccf8cd9b3aa 100644
--- a/src/compiler/serializer-for-background-compilation.cc
+++ b/src/compiler/serializer-for-background-compilation.cc
@@ -1430,7 +1430,7 @@ void SerializerForBackgroundCompilation::VisitInvokeIntrinsic(
   // JSNativeContextSpecialization::ReduceJSResolvePromise.
   switch (functionId) {
     case Runtime::kInlineAsyncFunctionResolve: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncFunctionResolve));
       interpreter::Register first_reg = iterator->GetRegisterOperand(1);
       size_t reg_count = iterator->GetRegisterCountOperand(2);
@@ -1442,60 +1442,60 @@ void SerializerForBackgroundCompilation::VisitInvokeIntrinsic(
     }
     case Runtime::kInlineAsyncGeneratorReject:
     case Runtime::kAsyncGeneratorReject: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncGeneratorReject));
       break;
     }
     case Runtime::kInlineAsyncGeneratorResolve:
     case Runtime::kAsyncGeneratorResolve: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncGeneratorResolve));
       break;
     }
     case Runtime::kInlineAsyncGeneratorYield:
     case Runtime::kAsyncGeneratorYield: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncGeneratorYield));
       break;
     }
     case Runtime::kInlineAsyncGeneratorAwaitUncaught:
     case Runtime::kAsyncGeneratorAwaitUncaught: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncGeneratorAwaitUncaught));
       break;
     }
     case Runtime::kInlineAsyncGeneratorAwaitCaught:
     case Runtime::kAsyncGeneratorAwaitCaught: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncGeneratorAwaitCaught));
       break;
     }
     case Runtime::kInlineAsyncFunctionAwaitUncaught:
     case Runtime::kAsyncFunctionAwaitUncaught: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncFunctionAwaitUncaught));
       break;
     }
     case Runtime::kInlineAsyncFunctionAwaitCaught:
     case Runtime::kAsyncFunctionAwaitCaught: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncFunctionAwaitCaught));
       break;
     }
     case Runtime::kInlineAsyncFunctionReject:
     case Runtime::kAsyncFunctionReject: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncFunctionReject));
       break;
     }
     case Runtime::kAsyncFunctionResolve: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kAsyncFunctionResolve));
       break;
     }
     case Runtime::kInlineCopyDataProperties:
     case Runtime::kCopyDataProperties: {
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kCopyDataProperties));
       break;
     }
@@ -2246,7 +2246,7 @@ void SerializerForBackgroundCompilation::ProcessApiCall(
        {Builtin::kCallFunctionTemplate_CheckAccess,
         Builtin::kCallFunctionTemplate_CheckCompatibleReceiver,
         Builtin::kCallFunctionTemplate_CheckAccessAndCompatibleReceiver}) {
-    MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(b));
+    MakeRef(broker(), broker()->isolate()->builtins()->code_handle(b));
   }
   FunctionTemplateInfoRef target_template_info =
       MakeRef(broker(),
@@ -2310,10 +2310,10 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
     const HintsVector& arguments, SpeculationMode speculation_mode,
     MissingArgumentsPolicy padding, Hints* result_hints) {
   DCHECK(target->HasBuiltinId());
-  const int builtin_id = target->builtin_id();
-  const char* name = Builtins::name(builtin_id);
+  const Builtin builtin = target->builtin_id();
+  const char* name = Builtins::name(builtin);
   TRACE_BROKER(broker(), "Serializing for call to builtin " << name);
-  switch (builtin_id) {
+  switch (builtin) {
     case Builtin::kObjectCreate: {
       if (arguments.size() >= 2) {
         ProcessHintsForObjectCreate(arguments[1]);
@@ -2584,13 +2584,13 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
       }
       break;
     case Builtin::kMapIteratorPrototypeNext:
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kOrderedHashTableHealIndex));
       MakeRef<FixedArray>(
           broker(), broker()->isolate()->factory()->empty_ordered_hash_map());
       break;
     case Builtin::kSetIteratorPrototypeNext:
-      MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
+      MakeRef(broker(), broker()->isolate()->builtins()->code_handle(
                             Builtin::kOrderedHashTableHealIndex));
       MakeRef<FixedArray>(
           broker(), broker()->isolate()->factory()->empty_ordered_hash_set());
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index b12fec3ec3e..c15ee8d3a92 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -219,9 +219,9 @@ class WasmGraphAssembler : public GraphAssembler {
 #endif
   }
 
-  Node* GetBuiltinPointerTarget(Builtin builtin_id) {
+  Node* GetBuiltinPointerTarget(Builtin builtin) {
     static_assert(std::is_same<Smi, BuiltinPtr>(), "BuiltinPtr must be Smi");
-    return NumberConstant(builtin_id);
+    return NumberConstant(static_cast<int>(builtin));
   }
 
   // Sets {true_node} and {false_node} to their corresponding Branch outputs.
@@ -6073,11 +6073,11 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
   }
 
   Node* GetTargetForBuiltinCall(wasm::WasmCode::RuntimeStubId wasm_stub,
-                                Builtin builtin_id) {
+                                Builtin builtin) {
     return (stub_mode_ == StubCallMode::kCallWasmRuntimeStub)
                ? mcgraph()->RelocatableIntPtrConstant(wasm_stub,
                                                       RelocInfo::WASM_STUB_CALL)
-               : gasm_->GetBuiltinPointerTarget(builtin_id);
+               : gasm_->GetBuiltinPointerTarget(builtin);
   }
 
   Node* UndefinedValue() { return LOAD_ROOT(UndefinedValue, undefined_value); }
diff --git a/src/debug/debug-evaluate.cc b/src/debug/debug-evaluate.cc
index 9285630d48a..cd636dd1c26 100644
--- a/src/debug/debug-evaluate.cc
+++ b/src/debug/debug-evaluate.cc
@@ -959,18 +959,16 @@ DebugInfo::SideEffectState DebugEvaluate::FunctionGetSideEffectState(
                                    : DebugInfo::kHasNoSideEffect;
   } else if (info->IsApiFunction()) {
     if (info->GetCode().is_builtin()) {
-      return info->GetCode().builtin_index() == Builtin::kHandleApiCall
+      return info->GetCode().builtin_id() == Builtin::kHandleApiCall
                  ? DebugInfo::kHasNoSideEffect
                  : DebugInfo::kHasSideEffects;
     }
   } else {
     // Check built-ins against allowlist.
-    int builtin_index =
+    Builtin builtin =
         info->HasBuiltinId() ? info->builtin_id() : Builtin::kNoBuiltinId;
-    if (!Builtins::IsBuiltinId(builtin_index))
-      return DebugInfo::kHasSideEffects;
-    DebugInfo::SideEffectState state =
-        BuiltinGetSideEffectState(static_cast<Builtin>(builtin_index));
+    if (!Builtins::IsBuiltinId(builtin)) return DebugInfo::kHasSideEffects;
+    DebugInfo::SideEffectState state = BuiltinGetSideEffectState(builtin);
     return state;
   }
 
@@ -1104,11 +1102,10 @@ void DebugEvaluate::VerifyTransitiveBuiltins(Isolate* isolate) {
   // TODO(yangguo): also check runtime calls.
   bool failed = false;
   bool sanity_check = false;
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Builtin caller = static_cast<Builtin>(i);
+  for (Builtin caller = Builtins::kFirst; caller <= Builtins::kLast; ++caller) {
     DebugInfo::SideEffectState state = BuiltinGetSideEffectState(caller);
     if (state != DebugInfo::kHasNoSideEffect) continue;
-    Code code = isolate->builtins()->builtin(caller);
+    Code code = isolate->builtins()->code(caller);
     int mode = RelocInfo::ModeMask(RelocInfo::CODE_TARGET) |
                RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET);
 
@@ -1118,7 +1115,7 @@ void DebugEvaluate::VerifyTransitiveBuiltins(Isolate* isolate) {
       Code callee_code = isolate->heap()->GcSafeFindCodeForInnerPointer(
           rinfo->target_address());
       if (!callee_code.is_builtin()) continue;
-      Builtin callee = static_cast<Builtin>(callee_code.builtin_index());
+      Builtin callee = static_cast<Builtin>(callee_code.builtin_id());
       if (BuiltinGetSideEffectState(callee) == DebugInfo::kHasNoSideEffect) {
         continue;
       }
diff --git a/src/debug/debug-interface.cc b/src/debug/debug-interface.cc
index d312aa36911..16e74bdcbdc 100644
--- a/src/debug/debug-interface.cc
+++ b/src/debug/debug-interface.cc
@@ -843,19 +843,19 @@ Local<String> WasmValueObject::type() const {
 }
 #endif  // V8_ENABLE_WEBASSEMBLY
 
-Local<Function> GetBuiltin(Isolate* v8_isolate, Builtin builtin) {
+Local<Function> GetBuiltin(Isolate* v8_isolate, Builtin requested_builtin) {
   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(v8_isolate);
   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(isolate);
   i::HandleScope handle_scope(isolate);
 
-  CHECK_EQ(builtin, kStringToLowerCase);
-  i::Builtin builtin_id = i::Builtin::kStringPrototypeToLocaleLowerCase;
+  CHECK_EQ(requested_builtin, kStringToLowerCase);
+  i::Builtin builtin = i::Builtin::kStringPrototypeToLocaleLowerCase;
 
   i::Factory* factory = isolate->factory();
   i::Handle<i::String> name = isolate->factory()->empty_string();
   i::Handle<i::NativeContext> context(isolate->native_context());
   i::Handle<i::SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name, builtin_id);
+      factory->NewSharedFunctionInfoForBuiltin(name, builtin);
   info->set_language_mode(i::LanguageMode::kStrict);
   i::Handle<i::JSFunction> fun =
       i::Factory::JSFunctionBuilder{isolate, info, context}
diff --git a/src/debug/debug.cc b/src/debug/debug.cc
index 62f8fd6e3d1..fe70a83c8f1 100644
--- a/src/debug/debug.cc
+++ b/src/debug/debug.cc
@@ -1265,15 +1265,15 @@ class DiscardBaselineCodeVisitor : public ThreadVisitor {
         // we deoptimized in the debugger and are stepping into it.
         JavaScriptFrame* frame = it.frame();
         Address pc = frame->pc();
-        Builtin builtin_index = InstructionStream::TryLookupCode(isolate, pc);
-        if (builtin_index == Builtin::kBaselineEnterAtBytecode ||
-            builtin_index == Builtin::kBaselineEnterAtNextBytecode) {
+        Builtin builtin = InstructionStream::TryLookupCode(isolate, pc);
+        if (builtin == Builtin::kBaselineEnterAtBytecode ||
+            builtin == Builtin::kBaselineEnterAtNextBytecode) {
           Address* pc_addr = frame->pc_address();
-          Builtin advance = builtin_index == Builtin::kBaselineEnterAtBytecode
+          Builtin advance = builtin == Builtin::kBaselineEnterAtBytecode
                                 ? Builtin::kInterpreterEnterAtBytecode
                                 : Builtin::kInterpreterEnterAtNextBytecode;
           Address advance_pc =
-              isolate->builtins()->builtin(advance).InstructionStart();
+              isolate->builtins()->code(advance).InstructionStart();
           PointerAuthentication::ReplacePC(pc_addr, advance_pc,
                                            kSystemPointerSize);
         }
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index f47ee94a97d..fa13d3b2e28 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -1061,7 +1061,7 @@ void Deoptimizer::DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
       !goto_catch_handler;
   const bool is_baseline = shared.HasBaselineData();
   Code dispatch_builtin =
-      builtins->builtin(DispatchBuiltinFor(is_baseline, advance_bc));
+      builtins->code(DispatchBuiltinFor(is_baseline, advance_bc));
 
   if (verbose_tracing_enabled()) {
     PrintF(trace_scope()->file(), "  translating %s frame ",
@@ -1302,7 +1302,7 @@ void Deoptimizer::DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
     Register context_reg = JavaScriptFrame::context_register();
     output_frame->SetRegister(context_reg.code(), context_value);
     // Set the continuation for the topmost frame.
-    Code continuation = builtins->builtin(Builtin::kNotifyDeoptimized);
+    Code continuation = builtins->code(Builtin::kNotifyDeoptimized);
     output_frame->SetContinuation(
         static_cast<intptr_t>(continuation.InstructionStart()));
   }
@@ -1382,7 +1382,7 @@ void Deoptimizer::DoComputeConstructStubFrame(TranslatedFrame* translated_frame,
   CHECK(!is_topmost || deopt_kind_ == DeoptimizeKind::kLazy);
 
   Builtins* builtins = isolate_->builtins();
-  Code construct_stub = builtins->builtin(Builtin::kJSConstructStubGeneric);
+  Code construct_stub = builtins->code(Builtin::kJSConstructStubGeneric);
   BytecodeOffset bytecode_offset = translated_frame->bytecode_offset();
 
   const int parameters_count = translated_frame->height();
@@ -1538,7 +1538,7 @@ void Deoptimizer::DoComputeConstructStubFrame(TranslatedFrame* translated_frame,
   if (is_topmost) {
     Builtins* builtins = isolate_->builtins();
     DCHECK_EQ(DeoptimizeKind::kLazy, deopt_kind_);
-    Code continuation = builtins->builtin(Builtin::kNotifyDeoptimized);
+    Code continuation = builtins->code(Builtin::kNotifyDeoptimized);
     output_frame->SetContinuation(
         static_cast<intptr_t>(continuation.InstructionStart()));
   }
@@ -1705,10 +1705,9 @@ void Deoptimizer::DoComputeBuiltinContinuation(
   TranslatedFrame::iterator value_iterator = translated_frame->begin();
 
   const BytecodeOffset bytecode_offset = translated_frame->bytecode_offset();
-  Builtin builtin_name =
-      Builtins::GetBuiltinFromBytecodeOffset(bytecode_offset);
+  Builtin builtin = Builtins::GetBuiltinFromBytecodeOffset(bytecode_offset);
   CallInterfaceDescriptor continuation_descriptor =
-      Builtins::CallInterfaceDescriptorFor(builtin_name);
+      Builtins::CallInterfaceDescriptorFor(builtin);
 
   const RegisterConfiguration* config = RegisterConfiguration::Default();
 
@@ -1750,7 +1749,7 @@ void Deoptimizer::DoComputeBuiltinContinuation(
            "  translating BuiltinContinuation to %s,"
            " => register_param_count=%d,"
            " stack_param_count=%d, frame_size=%d\n",
-           Builtins::name(builtin_name), register_parameter_count,
+           Builtins::name(builtin), register_parameter_count,
            frame_info.stack_parameter_count(), output_frame_size);
   }
 
@@ -1779,9 +1778,9 @@ void Deoptimizer::DoComputeBuiltinContinuation(
   }
 
   if (mode == BuiltinContinuationMode::STUB) {
-    DCHECK_EQ(Builtins::CallInterfaceDescriptorFor(builtin_name)
-                  .GetStackArgumentOrder(),
-              StackArgumentOrder::kDefault);
+    DCHECK_EQ(
+        Builtins::CallInterfaceDescriptorFor(builtin).GetStackArgumentOrder(),
+        StackArgumentOrder::kDefault);
     for (uint32_t i = 0; i < frame_info.translated_stack_parameter_count();
          ++i, ++value_iterator) {
       frame_writer.PushTranslatedValue(value_iterator, "stack parameter");
@@ -1896,7 +1895,8 @@ void Deoptimizer::DoComputeBuiltinContinuation(
                                    "builtin JavaScript context\n");
 
   // The builtin to continue to.
-  frame_writer.PushRawObject(Smi::FromInt(builtin_name), "builtin index\n");
+  frame_writer.PushRawObject(Smi::FromInt(static_cast<int>(builtin)),
+                             "builtin index\n");
 
   const int allocatable_register_count =
       config->num_allocatable_general_registers();
@@ -1963,7 +1963,7 @@ void Deoptimizer::DoComputeBuiltinContinuation(
   // ContinueToCodeStubBuiltinWithResult because we don't want to overwrite the
   // return value that we have already set.
   Code continue_to_builtin =
-      isolate()->builtins()->builtin(TrampolineForBuiltinContinuation(
+      isolate()->builtins()->code(TrampolineForBuiltinContinuation(
           mode, frame_info.frame_has_result_stack_slot() &&
                     !is_js_to_wasm_builtin_continuation));
   if (is_topmost) {
@@ -1978,8 +1978,7 @@ void Deoptimizer::DoComputeBuiltinContinuation(
         static_cast<intptr_t>(continue_to_builtin.InstructionStart()));
   }
 
-  Code continuation =
-      isolate()->builtins()->builtin(Builtin::kNotifyDeoptimized);
+  Code continuation = isolate()->builtins()->code(Builtin::kNotifyDeoptimized);
   output_frame->SetContinuation(
       static_cast<intptr_t>(continuation.InstructionStart()));
 }
diff --git a/src/diagnostics/disassembler.cc b/src/diagnostics/disassembler.cc
index 6056fd5436f..18be4586978 100644
--- a/src/diagnostics/disassembler.cc
+++ b/src/diagnostics/disassembler.cc
@@ -166,10 +166,9 @@ const char* V8NameConverter::RootRelativeName(int offset) const {
              kBuiltinsTableSize) {
     uint32_t offset_in_builtins_table = (offset - kBuiltinsTableStart);
 
-    Builtin builtin_id =
-        static_cast<Builtin>(offset_in_builtins_table / kSystemPointerSize);
-
-    const char* name = Builtins::name(builtin_id);
+    Builtin builtin =
+        Builtins::FromInt(offset_in_builtins_table / kSystemPointerSize);
+    const char* name = Builtins::name(builtin);
     SNPrintF(v8_buffer_, "builtin (%s)", name);
     return v8_buffer_.begin();
 
@@ -249,7 +248,7 @@ static void PrintRelocInfo(StringBuilder* out, Isolate* isolate,
         relocinfo->target_address());
     CodeKind kind = code.kind();
     if (code.is_builtin()) {
-      out->AddFormatted(" Builtin::%s", Builtins::name(code.builtin_index()));
+      out->AddFormatted(" Builtin::%s", Builtins::name(code.builtin_id()));
     } else {
       out->AddFormatted(" %s", CodeKindToString(kind));
     }
diff --git a/src/diagnostics/objects-debug.cc b/src/diagnostics/objects-debug.cc
index 11a0107e7e7..5c746da548f 100644
--- a/src/diagnostics/objects-debug.cc
+++ b/src/diagnostics/objects-debug.cc
@@ -886,8 +886,8 @@ void SharedFunctionInfo::SharedFunctionInfoVerify(ReadOnlyRoots roots) {
   } else if (!HasBuiltinId()) {
     CHECK(!construct_as_builtin());
   } else {
-    int id = builtin_id();
-    if (id != Builtin::kCompileLazy && id != Builtin::kEmptyFunction) {
+    if (builtin_id() != Builtin::kCompileLazy &&
+        builtin_id() != Builtin::kEmptyFunction) {
       CHECK(construct_as_builtin());
     } else {
       CHECK(!construct_as_builtin());
@@ -1341,7 +1341,7 @@ void JSRegExp::JSRegExpVerify(Isolate* isolate) {
 
       bool is_compiled = latin1_code.IsCode();
       if (is_compiled) {
-        CHECK_EQ(Code::cast(latin1_code).builtin_index(),
+        CHECK_EQ(Code::cast(latin1_code).builtin_id(),
                  Builtin::kRegExpExperimentalTrampoline);
         CHECK_EQ(uc16_code, latin1_code);
 
@@ -1628,7 +1628,7 @@ void WasmExportedFunctionData::WasmExportedFunctionDataVerify(
   CHECK(wrapper_code().kind() == CodeKind::JS_TO_WASM_FUNCTION ||
         wrapper_code().kind() == CodeKind::C_WASM_ENTRY ||
         (wrapper_code().is_builtin() &&
-         wrapper_code().builtin_index() == Builtin::kGenericJSToWasmWrapper));
+         wrapper_code().builtin_id() == Builtin::kGenericJSToWasmWrapper));
 }
 
 USE_TORQUE_VERIFIER(WasmModuleObject)
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index 31ae656c707..1f1afe1af7c 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -1501,9 +1501,9 @@ void JSFunction::JSFunctionPrint(std::ostream& os) {
   os << "\n - name: " << Brief(shared().Name());
 
   // Print Builtin name for builtin functions
-  int builtin_index = code().builtin_index();
-  if (Builtins::IsBuiltinId(builtin_index)) {
-    os << "\n - builtin: " << isolate->builtins()->name(builtin_index);
+  Builtin builtin = code().builtin_id();
+  if (Builtins::IsBuiltinId(builtin)) {
+    os << "\n - builtin: " << isolate->builtins()->name(builtin);
   }
 
   os << "\n - formal_parameter_count: "
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 57f7553f2e5..5a9bf41f0bf 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -225,13 +225,13 @@ namespace {
 
 bool IsInterpreterFramePc(Isolate* isolate, Address pc,
                           StackFrame::State* state) {
-  Builtin builtin_index = InstructionStream::TryLookupCode(isolate, pc);
-  if (builtin_index != Builtin::kNoBuiltinId &&
-      (builtin_index == Builtin::kInterpreterEntryTrampoline ||
-       builtin_index == Builtin::kInterpreterEnterAtBytecode ||
-       builtin_index == Builtin::kInterpreterEnterAtNextBytecode ||
-       builtin_index == Builtin::kBaselineEnterAtBytecode ||
-       builtin_index == Builtin::kBaselineEnterAtNextBytecode)) {
+  Builtin builtin = InstructionStream::TryLookupCode(isolate, pc);
+  if (builtin != Builtin::kNoBuiltinId &&
+      (builtin == Builtin::kInterpreterEntryTrampoline ||
+       builtin == Builtin::kInterpreterEnterAtBytecode ||
+       builtin == Builtin::kInterpreterEnterAtNextBytecode ||
+       builtin == Builtin::kBaselineEnterAtBytecode ||
+       builtin == Builtin::kBaselineEnterAtNextBytecode)) {
     return true;
   } else if (FLAG_interpreted_frames_native_stack) {
     intptr_t marker = Memory<intptr_t>(
@@ -1614,7 +1614,7 @@ void OptimizedFrame::Summarize(std::vector<FrameSummary>* frames) const {
               TranslatedFrame::kJavaScriptBuiltinContinuationWithCatch) {
         code_offset = 0;
         abstract_code = handle(
-            AbstractCode::cast(isolate()->builtins()->builtin(
+            AbstractCode::cast(isolate()->builtins()->code(
                 Builtins::GetBuiltinFromBytecodeOffset(it->bytecode_offset()))),
             isolate());
       } else {
@@ -2012,7 +2012,7 @@ void JsToWasmFrame::Iterate(RootVisitor* v) const {
   //        |      ....       | <- spill_slot_base--|
   //        |- - - - - - - - -|                     |
   if (code.is_null() || !code.is_builtin() ||
-      code.builtin_index() != Builtin::kGenericJSToWasmWrapper) {
+      code.builtin_id() != Builtin::kGenericJSToWasmWrapper) {
     // If it's not the  GenericJSToWasmWrapper, then it's the TurboFan compiled
     // specific wrapper. So we have to call IterateCompiledFrame.
     IterateCompiledFrame(v);
diff --git a/src/execution/isolate-data.h b/src/execution/isolate-data.h
index 32f8dc79bec..3b667e0d5a2 100644
--- a/src/execution/isolate-data.h
+++ b/src/execution/isolate-data.h
@@ -66,9 +66,10 @@ class IsolateData final {
   static constexpr int builtin_entry_table_offset() {
     return kBuiltinEntryTableOffset - kIsolateRootBias;
   }
-  static constexpr int builtin_entry_slot_offset(Builtin builtin_index) {
-    DCHECK(Builtins::IsBuiltinId(builtin_index));
-    return builtin_entry_table_offset() + builtin_index * kSystemPointerSize;
+  static constexpr int builtin_entry_slot_offset(Builtin builtin) {
+    DCHECK(Builtins::IsBuiltinId(builtin));
+    return builtin_entry_table_offset() +
+           static_cast<int>(builtin) * kSystemPointerSize;
   }
 
   // Root-register-relative offset of the builtins table.
@@ -108,7 +109,7 @@ class IsolateData final {
 
   // Root-register-relative offset of the builtin table entry.
   static int builtin_slot_offset(Builtin id) {
-    return builtins_table_offset() + id * kSystemPointerSize;
+    return builtins_table_offset() + static_cast<int>(id) * kSystemPointerSize;
   }
 
   // The FP and PC that are saved right before TurboAssembler::CallCFunction.
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index 85c93a9d313..7ee373d9310 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -392,8 +392,9 @@ size_t Isolate::HashIsolateForEmbeddedBlob() {
   size_t hash = kSeed;
 
   // Hash data sections of builtin code objects.
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Code code = heap_.builtin(i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Code code = heap_.builtin(builtin);
 
     DCHECK(Internals::HasHeapObjectTag(code.ptr()));
     uint8_t* const code_ptr =
@@ -872,11 +873,10 @@ bool NoExtension(const v8::FunctionCallbackInfo<v8::Value>&) { return false; }
 
 namespace {
 
-bool IsBuiltinFunction(Isolate* isolate, HeapObject object,
-                       Builtin builtin_index) {
+bool IsBuiltinFunction(Isolate* isolate, HeapObject object, Builtin builtin) {
   if (!object.IsJSFunction()) return false;
   JSFunction const function = JSFunction::cast(object);
-  return function.code() == isolate->builtins()->builtin(builtin_index);
+  return function.code() == isolate->builtins()->code(builtin);
 }
 
 void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,
@@ -1914,7 +1914,7 @@ Object Isolate::UnwindAndFindHandler() {
           InterpretedFrame::cast(js_frame)->PatchBytecodeOffset(
               static_cast<int>(offset));
 
-          Code code = builtins()->builtin(Builtin::kInterpreterEnterAtBytecode);
+          Code code = builtins()->code(Builtin::kInterpreterEnterAtBytecode);
           return FoundHandler(context, code.InstructionStart(), 0,
                               code.constant_pool(), return_sp, frame->fp());
         }
@@ -3384,14 +3384,15 @@ void CreateOffHeapTrampolines(Isolate* isolate) {
   EmbeddedData d = EmbeddedData::FromBlob(isolate);
 
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Address instruction_start = d.InstructionStartOfBuiltin(i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Address instruction_start = d.InstructionStartOfBuiltin(builtin);
     Handle<Code> trampoline = isolate->factory()->NewOffHeapTrampolineFor(
-        builtins->builtin_handle(i), instruction_start);
+        builtins->code_handle(builtin), instruction_start);
 
     // From this point onwards, the old builtin code object is unreachable and
     // will be collected by the next GC.
-    builtins->set_builtin(i, *trampoline);
+    builtins->set_code(builtin, *trampoline);
   }
 }
 
@@ -4511,10 +4512,10 @@ void Isolate::PrepareBuiltinLabelInfoMap() {
 
 #if defined(V8_OS_WIN64)
 void Isolate::SetBuiltinUnwindData(
-    int builtin_index,
+    Builtin builtin,
     const win64_unwindinfo::BuiltinUnwindInfo& unwinding_info) {
   if (embedded_file_writer_ != nullptr) {
-    embedded_file_writer_->SetBuiltinUnwindData(builtin_index, unwinding_info);
+    embedded_file_writer_->SetBuiltinUnwindData(builtin, unwinding_info);
   }
 }
 #endif  // V8_OS_WIN64
diff --git a/src/execution/isolate.h b/src/execution/isolate.h
index 1b34f6f89d3..2f409e72ae2 100644
--- a/src/execution/isolate.h
+++ b/src/execution/isolate.h
@@ -1664,7 +1664,7 @@ class V8_EXPORT_PRIVATE Isolate final : private HiddenFactory {
 
 #if defined(V8_OS_WIN64)
   void SetBuiltinUnwindData(
-      int builtin_index,
+      Builtin builtin,
       const win64_unwindinfo::BuiltinUnwindInfo& unwinding_info);
 #endif  // V8_OS_WIN64
 
diff --git a/src/heap/factory-base.cc b/src/heap/factory-base.cc
index 4e645c5c59e..b780fb663ec 100644
--- a/src/heap/factory-base.cc
+++ b/src/heap/factory-base.cc
@@ -308,7 +308,7 @@ FactoryBase<Impl>::NewUncompiledDataWithPreparseData(
 template <typename Impl>
 Handle<SharedFunctionInfo> FactoryBase<Impl>::NewSharedFunctionInfo(
     MaybeHandle<String> maybe_name, MaybeHandle<HeapObject> maybe_function_data,
-    int maybe_builtin_index, FunctionKind kind) {
+    Builtin builtin, FunctionKind kind) {
   Handle<SharedFunctionInfo> shared = NewSharedFunctionInfo();
   DisallowGarbageCollection no_gc;
   SharedFunctionInfo raw = *shared;
@@ -327,12 +327,12 @@ Handle<SharedFunctionInfo> FactoryBase<Impl>::NewSharedFunctionInfo(
   if (maybe_function_data.ToHandle(&function_data)) {
     // If we pass function_data then we shouldn't pass a builtin index, and
     // the function_data should not be code with a builtin.
-    DCHECK(!Builtins::IsBuiltinId(maybe_builtin_index));
+    DCHECK(!Builtins::IsBuiltinId(builtin));
     DCHECK_IMPLIES(function_data->IsCode(),
                    !Code::cast(*function_data).is_builtin());
     raw.set_function_data(*function_data, kReleaseStore);
-  } else if (Builtins::IsBuiltinId(maybe_builtin_index)) {
-    raw.set_builtin_id(maybe_builtin_index);
+  } else if (Builtins::IsBuiltinId(builtin)) {
+    raw.set_builtin_id(builtin);
   } else {
     DCHECK(raw.HasBuiltinId());
     DCHECK_EQ(Builtin::kIllegal, raw.builtin_id());
diff --git a/src/heap/factory-base.h b/src/heap/factory-base.h
index 4e3d5efbe40..1b05335675b 100644
--- a/src/heap/factory-base.h
+++ b/src/heap/factory-base.h
@@ -35,6 +35,7 @@ class BytecodeArray;
 class CoverageInfo;
 class ClassPositions;
 struct SourceRange;
+enum class Builtin : int32_t;
 template <typename T>
 class ZoneVector;
 
@@ -254,7 +255,7 @@ class EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) FactoryBase
   Handle<SharedFunctionInfo> NewSharedFunctionInfo();
   Handle<SharedFunctionInfo> NewSharedFunctionInfo(
       MaybeHandle<String> maybe_name,
-      MaybeHandle<HeapObject> maybe_function_data, int maybe_builtin_index,
+      MaybeHandle<HeapObject> maybe_function_data, Builtin builtin,
       FunctionKind kind = kNormalFunction);
 
   Handle<String> MakeOrFindTwoCharacterString(uint16_t c1, uint16_t c2);
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index ae62f04ae38..713f66fe08a 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -168,7 +168,7 @@ MaybeHandle<Code> Factory::CodeBuilder::BuildInternal(
     raw_code.set_relocation_info(*reloc_info);
     raw_code.initialize_flags(kind_, is_turbofanned_, stack_slots_,
                               kIsNotOffHeapTrampoline);
-    raw_code.set_builtin_index(builtin_index_);
+    raw_code.set_builtin_id(builtin_);
     raw_code.set_inlined_bytecode_size(inlined_bytecode_size_);
     raw_code.set_code_data_container(*data_container, kReleaseStore);
     raw_code.set_deoptimization_data(*deoptimization_data_);
@@ -2089,7 +2089,7 @@ Handle<Code> Factory::NewOffHeapTrampolineFor(Handle<Code> code,
   CHECK(Builtins::IsIsolateIndependentBuiltin(*code));
 
   bool generate_jump_to_instruction_stream =
-      Builtins::CodeObjectIsExecutable(code->builtin_index());
+      Builtins::CodeObjectIsExecutable(code->builtin_id());
   Handle<Code> result = Builtins::GenerateOffHeapTrampolineFor(
       isolate(), off_heap_entry,
       code->code_data_container(kAcquireLoad).kind_specific_flags(),
@@ -2115,7 +2115,7 @@ Handle<Code> Factory::NewOffHeapTrampolineFor(Handle<Code> code,
         raw_code.has_safepoint_info() ? raw_code.stack_slots() : 0;
     raw_result.initialize_flags(raw_code.kind(), raw_code.is_turbofanned(),
                                 stack_slots, set_is_off_heap_trampoline);
-    raw_result.set_builtin_index(raw_code.builtin_index());
+    raw_result.set_builtin_id(raw_code.builtin_id());
     raw_result.set_handler_table_offset(raw_code.handler_table_offset());
     raw_result.set_constant_pool_offset(raw_code.constant_pool_offset());
     raw_result.set_code_comments_offset(raw_code.code_comments_offset());
@@ -2963,9 +2963,9 @@ Handle<SharedFunctionInfo> Factory::NewSharedFunctionInfoForApiFunction(
 }
 
 Handle<SharedFunctionInfo> Factory::NewSharedFunctionInfoForBuiltin(
-    MaybeHandle<String> maybe_name, int builtin_index, FunctionKind kind) {
-  Handle<SharedFunctionInfo> shared = NewSharedFunctionInfo(
-      maybe_name, MaybeHandle<Code>(), builtin_index, kind);
+    MaybeHandle<String> maybe_name, Builtin builtin, FunctionKind kind) {
+  Handle<SharedFunctionInfo> shared =
+      NewSharedFunctionInfo(maybe_name, MaybeHandle<Code>(), builtin, kind);
   return shared;
 }
 
diff --git a/src/heap/factory.h b/src/heap/factory.h
index 14dd5994d4a..86d041ae8c2 100644
--- a/src/heap/factory.h
+++ b/src/heap/factory.h
@@ -717,7 +717,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
       Handle<FunctionTemplateInfo> function_template_info, FunctionKind kind);
 
   Handle<SharedFunctionInfo> NewSharedFunctionInfoForBuiltin(
-      MaybeHandle<String> name, int builtin_index,
+      MaybeHandle<String> name, Builtin builtin,
       FunctionKind kind = kNormalFunction);
 
   static bool IsFunctionModeWithPrototype(FunctionMode function_mode) {
@@ -852,10 +852,10 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
       return *this;
     }
 
-    CodeBuilder& set_builtin_index(int32_t builtin_index) {
-      DCHECK_IMPLIES(builtin_index != Builtin::kNoBuiltinId,
+    CodeBuilder& set_builtin(Builtin builtin) {
+      DCHECK_IMPLIES(builtin != Builtin::kNoBuiltinId,
                      !CodeKindIsJSFunction(kind_));
-      builtin_index_ = builtin_index;
+      builtin_ = builtin;
       return *this;
     }
 
@@ -925,7 +925,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
     const CodeKind kind_;
 
     MaybeHandle<Object> self_reference_;
-    int32_t builtin_index_ = Builtin::kNoBuiltinId;
+    Builtin builtin_ = Builtin::kNoBuiltinId;
     uint32_t inlined_bytecode_size_ = 0;
     int32_t kind_specific_flags_ = 0;
     // Either source_position_table for non-baseline code
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index 68aedc78c44..31bce5c78dc 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -4509,22 +4509,24 @@ void Heap::ZapCodeObject(Address start_address, int size_in_bytes) {
 }
 
 // TODO(ishell): move builtin accessors out from Heap.
-Code Heap::builtin(int index) {
-  DCHECK(Builtins::IsBuiltinId(index));
-  return Code::cast(Object(isolate()->builtins_table()[index]));
+Code Heap::builtin(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  return Code::cast(
+      Object(isolate()->builtins_table()[static_cast<int>(builtin)]));
 }
 
-Address Heap::builtin_address(int index) {
-  DCHECK(Builtins::IsBuiltinId(index) || index == Builtins::kBuiltinCount);
+Address Heap::builtin_address(Builtin builtin) {
+  const int index = static_cast<int>(builtin);
+  DCHECK(Builtins::IsBuiltinId(builtin) || index == Builtins::kBuiltinCount);
   return reinterpret_cast<Address>(&isolate()->builtins_table()[index]);
 }
 
-void Heap::set_builtin(int index, Code builtin) {
-  DCHECK(Builtins::IsBuiltinId(index));
-  DCHECK(Internals::HasHeapObjectTag(builtin.ptr()));
+void Heap::set_builtin(Builtin builtin, Code code) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  DCHECK(Internals::HasHeapObjectTag(code.ptr()));
   // The given builtin may be completely uninitialized thus we cannot check its
   // type here.
-  isolate()->builtins_table()[index] = builtin.ptr();
+  isolate()->builtins_table()[static_cast<int>(builtin)] = code.ptr();
 }
 
 void Heap::IterateWeakRoots(RootVisitor* v, base::EnumSet<SkipRoot> options) {
@@ -4740,9 +4742,10 @@ void Heap::IterateWeakGlobalHandles(RootVisitor* v) {
 }
 
 void Heap::IterateBuiltins(RootVisitor* v) {
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    v->VisitRootPointer(Root::kBuiltins, Builtins::name(i),
-                        FullObjectSlot(builtin_address(i)));
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    v->VisitRootPointer(Root::kBuiltins, Builtins::name(builtin),
+                        FullObjectSlot(builtin_address(builtin)));
   }
 
   // The entry table doesn't need to be updated since all builtins are embedded.
@@ -6477,7 +6480,7 @@ void Heap::SetDetachedContexts(WeakArrayList detached_contexts) {
 }
 
 void Heap::SetInterpreterEntryTrampolineForProfiling(Code code) {
-  DCHECK_EQ(Builtin::kInterpreterEntryTrampoline, code.builtin_index());
+  DCHECK_EQ(Builtin::kInterpreterEntryTrampoline, code.builtin_id());
   set_interpreter_entry_trampoline_for_profiling(code);
 }
 
@@ -6805,7 +6808,7 @@ bool Heap::GcSafeCodeContains(Code code, Address addr) {
   DCHECK(map == ReadOnlyRoots(this).code_map());
   Builtin maybe_builtin = InstructionStream::TryLookupCode(isolate(), addr);
   if (Builtins::IsBuiltinId(maybe_builtin) &&
-      code.builtin_index() == maybe_builtin) {
+      code.builtin_id() == maybe_builtin) {
     return true;
   }
   Address start = code.address();
diff --git a/src/heap/heap.h b/src/heap/heap.h
index f71c8662eed..0aee7e674ae 100644
--- a/src/heap/heap.h
+++ b/src/heap/heap.h
@@ -1041,9 +1041,9 @@ class Heap {
   // Builtins. =================================================================
   // ===========================================================================
 
-  V8_EXPORT_PRIVATE Code builtin(int index);
-  Address builtin_address(int index);
-  void set_builtin(int index, Code builtin);
+  V8_EXPORT_PRIVATE Code builtin(Builtin builtin);
+  Address builtin_address(Builtin builtin);
+  void set_builtin(Builtin builtin, Code code);
 
   // ===========================================================================
   // Iterators. ================================================================
diff --git a/src/heap/setup-heap-internal.cc b/src/heap/setup-heap-internal.cc
index 06ebd7460ab..e4ce4712d8c 100644
--- a/src/heap/setup-heap-internal.cc
+++ b/src/heap/setup-heap-internal.cc
@@ -54,11 +54,11 @@ namespace internal {
 namespace {
 
 Handle<SharedFunctionInfo> CreateSharedFunctionInfo(
-    Isolate* isolate, Builtin builtin_id, int len,
+    Isolate* isolate, Builtin builtin, int len,
     FunctionKind kind = FunctionKind::kNormalFunction) {
   Handle<SharedFunctionInfo> shared =
       isolate->factory()->NewSharedFunctionInfoForBuiltin(
-          isolate->factory()->empty_string(), builtin_id, kind);
+          isolate->factory()->empty_string(), builtin, kind);
   shared->set_internal_formal_parameter_count(len);
   shared->set_length(len);
   return shared;
diff --git a/src/ic/stub-cache.cc b/src/ic/stub-cache.cc
index 0510f684772..8a58e7b32f6 100644
--- a/src/ic/stub-cache.cc
+++ b/src/ic/stub-cache.cc
@@ -89,7 +89,7 @@ void StubCache::Set(Name name, Map map, MaybeObject handler) {
   // If the primary entry has useful data in it, we retire it to the
   // secondary cache before overwriting it.
   if (old_handler != MaybeObject::FromObject(
-                         isolate()->builtins()->builtin(Builtin::kIllegal)) &&
+                         isolate()->builtins()->code(Builtin::kIllegal)) &&
       !primary->map.IsSmi()) {
     Map old_map =
         Map::cast(StrongTaggedValue::ToObject(isolate(), primary->map));
@@ -126,7 +126,7 @@ MaybeObject StubCache::Get(Name name, Map map) {
 
 void StubCache::Clear() {
   MaybeObject empty =
-      MaybeObject::FromObject(isolate_->builtins()->builtin(Builtin::kIllegal));
+      MaybeObject::FromObject(isolate_->builtins()->code(Builtin::kIllegal));
   Name empty_string = ReadOnlyRoots(isolate()).empty_string();
   for (int i = 0; i < kPrimaryTableSize; i++) {
     primary_[i].key = StrongTaggedValue(empty_string);
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 849bb1cbfe4..63f10a50ed1 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -382,7 +382,7 @@ void Bootstrapper::DetachGlobal(Handle<Context> env) {
 namespace {
 
 #ifdef DEBUG
-bool IsFunctionMapOrSpecialBuiltin(Handle<Map> map, Builtin builtin_id,
+bool IsFunctionMapOrSpecialBuiltin(Handle<Map> map, Builtin builtin,
                                    Handle<Context> context) {
   // During bootstrapping some of these maps could be not created yet.
   return ((*map == context->get(Context::STRICT_FUNCTION_MAP_INDEX)) ||
@@ -393,21 +393,21 @@ bool IsFunctionMapOrSpecialBuiltin(Handle<Map> map, Builtin builtin_id,
                Context::STRICT_FUNCTION_WITH_READONLY_PROTOTYPE_MAP_INDEX)) ||
           // Check if it's a creation of an empty or Proxy function during
           // bootstrapping.
-          (builtin_id == Builtin::kEmptyFunction ||
-           builtin_id == Builtin::kProxyConstructor));
+          (builtin == Builtin::kEmptyFunction ||
+           builtin == Builtin::kProxyConstructor));
 }
 #endif  // DEBUG
 
 V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltin(Isolate* isolate,
                                                         Handle<String> name,
                                                         Handle<Map> map,
-                                                        Builtin builtin_id) {
+                                                        Builtin builtin) {
   Factory* factory = isolate->factory();
   Handle<NativeContext> context(isolate->native_context());
-  DCHECK(IsFunctionMapOrSpecialBuiltin(map, builtin_id, context));
+  DCHECK(IsFunctionMapOrSpecialBuiltin(map, builtin, context));
 
   Handle<SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name, builtin_id);
+      factory->NewSharedFunctionInfoForBuiltin(name, builtin);
   info->set_language_mode(LanguageMode::kStrict);
 
   return Factory::JSFunctionBuilder{isolate, info, context}
@@ -416,7 +416,7 @@ V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltin(Isolate* isolate,
 }
 
 V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithPrototype(
-    Isolate* isolate, Handle<String> name, Builtin builtin_id,
+    Isolate* isolate, Handle<String> name, Builtin builtin,
     Handle<HeapObject> prototype, InstanceType type, int instance_size,
     int inobject_properties, MutableMode prototype_mutability) {
   Factory* factory = isolate->factory();
@@ -425,10 +425,10 @@ V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithPrototype(
       prototype_mutability == MUTABLE
           ? isolate->strict_function_map()
           : isolate->strict_function_with_readonly_prototype_map();
-  DCHECK(IsFunctionMapOrSpecialBuiltin(map, builtin_id, context));
+  DCHECK(IsFunctionMapOrSpecialBuiltin(map, builtin, context));
 
   Handle<SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name, builtin_id);
+      factory->NewSharedFunctionInfoForBuiltin(name, builtin);
   info->set_language_mode(LanguageMode::kStrict);
   info->set_expected_nof_properties(inobject_properties);
 
@@ -461,14 +461,14 @@ V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithPrototype(
 }
 
 V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithoutPrototype(
-    Isolate* isolate, Handle<String> name, Builtin builtin_id) {
+    Isolate* isolate, Handle<String> name, Builtin builtin) {
   Factory* factory = isolate->factory();
   Handle<NativeContext> context(isolate->native_context());
   Handle<Map> map = isolate->strict_function_without_prototype_map();
-  DCHECK(IsFunctionMapOrSpecialBuiltin(map, builtin_id, context));
+  DCHECK(IsFunctionMapOrSpecialBuiltin(map, builtin, context));
 
   Handle<SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name, builtin_id);
+      factory->NewSharedFunctionInfoForBuiltin(name, builtin);
   info->set_language_mode(LanguageMode::kStrict);
 
   return Factory::JSFunctionBuilder{isolate, info, context}
@@ -478,11 +478,11 @@ V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithoutPrototype(
 
 V8_NOINLINE Handle<JSFunction> CreateFunction(
     Isolate* isolate, Handle<String> name, InstanceType type, int instance_size,
-    int inobject_properties, Handle<HeapObject> prototype, Builtin builtin_id) {
-  DCHECK(Builtins::HasJSLinkage(builtin_id));
+    int inobject_properties, Handle<HeapObject> prototype, Builtin builtin) {
+  DCHECK(Builtins::HasJSLinkage(builtin));
 
   Handle<JSFunction> result = CreateFunctionForBuiltinWithPrototype(
-      isolate, name, builtin_id, prototype, type, instance_size,
+      isolate, name, builtin, prototype, type, instance_size,
       inobject_properties, IMMUTABLE);
 
   // Make the JSFunction's prototype object fast.
@@ -497,10 +497,10 @@ V8_NOINLINE Handle<JSFunction> CreateFunction(
 
 V8_NOINLINE Handle<JSFunction> CreateFunction(
     Isolate* isolate, const char* name, InstanceType type, int instance_size,
-    int inobject_properties, Handle<HeapObject> prototype, Builtin builtin_id) {
-  return CreateFunction(
-      isolate, isolate->factory()->InternalizeUtf8String(name), type,
-      instance_size, inobject_properties, prototype, builtin_id);
+    int inobject_properties, Handle<HeapObject> prototype, Builtin builtin) {
+  return CreateFunction(isolate,
+                        isolate->factory()->InternalizeUtf8String(name), type,
+                        instance_size, inobject_properties, prototype, builtin);
 }
 
 V8_NOINLINE Handle<JSFunction> InstallFunction(
diff --git a/src/init/setup-isolate.h b/src/init/setup-isolate.h
index a49e4825905..af9c614bc00 100644
--- a/src/init/setup-isolate.h
+++ b/src/init/setup-isolate.h
@@ -11,6 +11,7 @@ namespace v8 {
 namespace internal {
 
 class Builtins;
+enum class Builtin : int32_t;
 class Code;
 class Heap;
 class Isolate;
@@ -40,7 +41,7 @@ class V8_EXPORT_PRIVATE SetupIsolateDelegate {
 
  protected:
   static void SetupBuiltinsInternal(Isolate* isolate);
-  static void AddBuiltin(Builtins* builtins, int index, Code code);
+  static void AddBuiltin(Builtins* builtins, Builtin builtin, Code code);
   static void PopulateWithPlaceholders(Isolate* isolate);
   static void ReplacePlaceholders(Isolate* isolate);
 
diff --git a/src/interpreter/interpreter-generator.cc b/src/interpreter/interpreter-generator.cc
index 037485e2dd3..b37bfc37628 100644
--- a/src/interpreter/interpreter-generator.cc
+++ b/src/interpreter/interpreter-generator.cc
@@ -3062,7 +3062,7 @@ IGNITION_HANDLER(ResumeGenerator, InterpreterAssembler) {
 Handle<Code> GenerateBytecodeHandler(Isolate* isolate, const char* debug_name,
                                      Bytecode bytecode,
                                      OperandScale operand_scale,
-                                     int builtin_index,
+                                     Builtin builtin,
                                      const AssemblerOptions& options) {
   Zone zone(isolate->allocator(), ZONE_NAME, kCompressGraphZone);
   compiler::CodeAssemblerState state(
@@ -3071,7 +3071,7 @@ Handle<Code> GenerateBytecodeHandler(Isolate* isolate, const char* debug_name,
       FLAG_untrusted_code_mitigations
           ? PoisoningMitigationLevel::kPoisonCriticalOnly
           : PoisoningMitigationLevel::kDontPoison,
-      builtin_index);
+      builtin);
 
   switch (bytecode) {
 #define CALL_GENERATOR(Name, ...)                     \
diff --git a/src/interpreter/interpreter-generator.h b/src/interpreter/interpreter-generator.h
index 263f02ba39e..51d7acb785c 100644
--- a/src/interpreter/interpreter-generator.h
+++ b/src/interpreter/interpreter-generator.h
@@ -12,6 +12,7 @@ namespace v8 {
 namespace internal {
 
 struct AssemblerOptions;
+enum class Builtin;
 
 namespace interpreter {
 
@@ -19,11 +20,11 @@ extern Handle<Code> GenerateBytecodeHandler(Isolate* isolate,
                                             const char* debug_name,
                                             Bytecode bytecode,
                                             OperandScale operand_scale,
-                                            int builtin_index,
+                                            Builtin builtin,
                                             const AssemblerOptions& options);
 
 extern Handle<Code> GenerateDeserializeLazyHandler(
-    Isolate* isolate, OperandScale operand_scale, int builtin_index,
+    Isolate* isolate, OperandScale operand_scale, Builtin builtin,
     const AssemblerOptions& options);
 
 }  // namespace interpreter
diff --git a/src/interpreter/interpreter.cc b/src/interpreter/interpreter.cc
index 8dcc042637f..c5fe97650f0 100644
--- a/src/interpreter/interpreter.cc
+++ b/src/interpreter/interpreter.cc
@@ -84,7 +84,8 @@ void Interpreter::InitDispatchCounters() {
 
 namespace {
 
-int BuiltinIndexFromBytecode(Bytecode bytecode, OperandScale operand_scale) {
+Builtin BuiltinIndexFromBytecode(Bytecode bytecode,
+                                 OperandScale operand_scale) {
   int index = static_cast<int>(bytecode);
   if (operand_scale == OperandScale::kSingle) {
     if (Bytecodes::IsShortStar(bytecode)) {
@@ -106,16 +107,16 @@ int BuiltinIndexFromBytecode(Bytecode bytecode, OperandScale operand_scale) {
       }
     }
   }
-  return Builtin::kFirstBytecodeHandler + index;
+  return Builtins::FromInt(static_cast<int>(Builtin::kFirstBytecodeHandler) +
+                           index);
 }
 
 }  // namespace
 
 Code Interpreter::GetBytecodeHandler(Bytecode bytecode,
                                      OperandScale operand_scale) {
-  int builtin_index = BuiltinIndexFromBytecode(bytecode, operand_scale);
-  Builtins* builtins = isolate_->builtins();
-  return builtins->builtin(builtin_index);
+  Builtin builtin = BuiltinIndexFromBytecode(bytecode, operand_scale);
+  return isolate_->builtins()->code(builtin);
 }
 
 void Interpreter::SetBytecodeHandler(Bytecode bytecode,
@@ -347,11 +348,11 @@ void Interpreter::Initialize() {
 
   // Initialize the dispatch table.
   ForEachBytecode([=](Bytecode bytecode, OperandScale operand_scale) {
-    int builtin_id = BuiltinIndexFromBytecode(bytecode, operand_scale);
-    Code handler = builtins->builtin(builtin_id);
+    Builtin builtin = BuiltinIndexFromBytecode(bytecode, operand_scale);
+    Code handler = builtins->code(builtin);
     if (Bytecodes::BytecodeHasHandler(bytecode, operand_scale)) {
 #ifdef DEBUG
-      std::string builtin_name(Builtins::name(builtin_id));
+      std::string builtin_name(Builtins::name(builtin));
       std::string expected_name =
           (Bytecodes::IsShortStar(bytecode)
                ? "ShortStar"
@@ -372,7 +373,7 @@ bool Interpreter::IsDispatchTableInitialized() const {
 
 const char* Interpreter::LookupNameOfBytecodeHandler(const Code code) {
   if (code.kind() == CodeKind::BYTECODE_HANDLER) {
-    return Builtins::name(code.builtin_index());
+    return Builtins::name(code.builtin_id());
   }
   return nullptr;
 }
diff --git a/src/logging/log.cc b/src/logging/log.cc
index c7c386ac8d7..dd12301998b 100644
--- a/src/logging/log.cc
+++ b/src/logging/log.cc
@@ -1358,8 +1358,8 @@ void Logger::CodeCreateEvent(LogEventsAndTags tag, Handle<AbstractCode> code,
                              Handle<Name> script_name) {
   if (!is_listening_to_code_events()) return;
   if (!FLAG_log_code) return;
-  if (*code == AbstractCode::cast(
-                   isolate_->builtins()->builtin(Builtin::kCompileLazy))) {
+  if (*code ==
+      AbstractCode::cast(isolate_->builtins()->code(Builtin::kCompileLazy))) {
     return;
   }
   {
@@ -2148,7 +2148,7 @@ void ExistingCodeLogger::LogCodeObject(Object object) {
         return;
       }
       description =
-          isolate_->builtins()->name(abstract_code->GetCode().builtin_index());
+          isolate_->builtins()->name(abstract_code->GetCode().builtin_id());
       tag = CodeEventListener::BUILTIN_TAG;
       break;
     case CodeKind::WASM_FUNCTION:
diff --git a/src/objects/code-inl.h b/src/objects/code-inl.h
index b50190963b1..2ea4e6c4f56 100644
--- a/src/objects/code-inl.h
+++ b/src/objects/code-inl.h
@@ -447,30 +447,27 @@ void Code::initialize_flags(CodeKind kind, bool is_turbofanned, int stack_slots,
 inline bool Code::is_interpreter_trampoline_builtin() const {
   // Check for kNoBuiltinId first to abort early when the current Code object
   // is not a builtin.
-  const int index = builtin_index();
-  return index != Builtin::kNoBuiltinId &&
-         (index == Builtin::kInterpreterEntryTrampoline ||
-          index == Builtin::kInterpreterEnterAtBytecode ||
-          index == Builtin::kInterpreterEnterAtNextBytecode);
+  return builtin_id() != Builtin::kNoBuiltinId &&
+         (builtin_id() == Builtin::kInterpreterEntryTrampoline ||
+          builtin_id() == Builtin::kInterpreterEnterAtBytecode ||
+          builtin_id() == Builtin::kInterpreterEnterAtNextBytecode);
 }
 
 inline bool Code::is_baseline_trampoline_builtin() const {
-  const int index = builtin_index();
-  return index != Builtin::kNoBuiltinId &&
-         (index == Builtin::kBaselineOutOfLinePrologue ||
-          index == Builtin::kBaselineEnterAtBytecode ||
-          index == Builtin::kBaselineEnterAtNextBytecode);
+  return builtin_id() != Builtin::kNoBuiltinId &&
+         (builtin_id() == Builtin::kBaselineOutOfLinePrologue ||
+          builtin_id() == Builtin::kBaselineEnterAtBytecode ||
+          builtin_id() == Builtin::kBaselineEnterAtNextBytecode);
 }
 
 inline bool Code::is_baseline_leave_frame_builtin() const {
-  return builtin_index() == Builtin::kBaselineLeaveFrame;
+  return builtin_id() == Builtin::kBaselineLeaveFrame;
 }
 
 inline bool Code::checks_optimization_marker() const {
-  bool checks_marker =
-      (builtin_index() == Builtin::kCompileLazy ||
-       builtin_index() == Builtin::kInterpreterEntryTrampoline ||
-       CodeKindCanTierUp(kind()));
+  bool checks_marker = (builtin_id() == Builtin::kCompileLazy ||
+                        builtin_id() == Builtin::kInterpreterEntryTrampoline ||
+                        CodeKindCanTierUp(kind()));
   return checks_marker ||
          (CodeKindCanDeoptimize(kind()) && marked_for_deoptimization());
 }
@@ -538,20 +535,20 @@ inline HandlerTable::CatchPrediction Code::GetBuiltinCatchPrediction() {
   return HandlerTable::UNCAUGHT;
 }
 
-int Code::builtin_index() const {
+Builtin Code::builtin_id() const {
   int index = RELAXED_READ_INT_FIELD(*this, kBuiltinIndexOffset);
-  DCHECK(index == Builtin::kNoBuiltinId || Builtins::IsBuiltinId(index));
-  return index;
+  DCHECK(index == static_cast<int>(Builtin::kNoBuiltinId) ||
+         Builtins::IsBuiltinId(index));
+  return static_cast<Builtin>(index);
 }
 
-void Code::set_builtin_index(int index) {
-  DCHECK(index == Builtin::kNoBuiltinId || Builtins::IsBuiltinId(index));
-  RELAXED_WRITE_INT_FIELD(*this, kBuiltinIndexOffset, index);
+void Code::set_builtin_id(Builtin builtin) {
+  DCHECK(builtin == Builtin::kNoBuiltinId || Builtins::IsBuiltinId(builtin));
+  RELAXED_WRITE_INT_FIELD(*this, kBuiltinIndexOffset,
+                          static_cast<int>(builtin));
 }
 
-bool Code::is_builtin() const {
-  return builtin_index() != Builtin::kNoBuiltinId;
-}
+bool Code::is_builtin() const { return builtin_id() != Builtin::kNoBuiltinId; }
 
 unsigned Code::inlined_bytecode_size() const {
   unsigned size = RELAXED_READ_UINT_FIELD(*this, kInlinedBytecodeSizeOffset);
@@ -726,8 +723,8 @@ bool Code::IsWeakObjectInOptimizedCode(HeapObject object) {
 }
 
 bool Code::IsExecutable() {
-  return !Builtins::IsBuiltinId(builtin_index()) || !is_off_heap_trampoline() ||
-         Builtins::CodeObjectIsExecutable(builtin_index());
+  return !Builtins::IsBuiltinId(builtin_id()) || !is_off_heap_trampoline() ||
+         Builtins::CodeObjectIsExecutable(builtin_id());
 }
 
 // This field has to have relaxed atomic accessors because it is accessed in the
diff --git a/src/objects/code.cc b/src/objects/code.cc
index 5b4ad4406d0..7f0c8774136 100644
--- a/src/objects/code.cc
+++ b/src/objects/code.cc
@@ -142,7 +142,7 @@ int Code::OffHeapInstructionSize() const {
     return raw_instruction_size();
   }
   EmbeddedData d = EmbeddedData::FromBlob();
-  return d.InstructionSizeOfBuiltin(builtin_index());
+  return d.InstructionSizeOfBuiltin(builtin_id());
 }
 
 namespace {
@@ -181,7 +181,7 @@ Address Code::OffHeapInstructionStart() const {
 
   // TODO(11527): pass Isolate as an argument for getting the EmbeddedData.
   EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.InstructionStartOfBuiltin(builtin_index());
+  return d.InstructionStartOfBuiltin(builtin_id());
 }
 
 Address Code::OffHeapInstructionEnd() const {
@@ -192,21 +192,21 @@ Address Code::OffHeapInstructionEnd() const {
 
   // TODO(11527): pass Isolate as an argument for getting the EmbeddedData.
   EmbeddedData d = EmbeddedDataWithMaybeRemappedEmbeddedBuiltins(*this);
-  return d.InstructionStartOfBuiltin(builtin_index()) +
-         d.InstructionSizeOfBuiltin(builtin_index());
+  return d.InstructionStartOfBuiltin(builtin_id()) +
+         d.InstructionSizeOfBuiltin(builtin_id());
 }
 
 Address Code::OffHeapInstructionStart(Isolate* isolate, Address pc) const {
   DCHECK(is_off_heap_trampoline());
   EmbeddedData d = EmbeddedData::GetEmbeddedDataForPC(isolate, pc);
-  return d.InstructionStartOfBuiltin(builtin_index());
+  return d.InstructionStartOfBuiltin(builtin_id());
 }
 
 Address Code::OffHeapInstructionEnd(Isolate* isolate, Address pc) const {
   DCHECK(is_off_heap_trampoline());
   EmbeddedData d = EmbeddedData::GetEmbeddedDataForPC(isolate, pc);
-  return d.InstructionStartOfBuiltin(builtin_index()) +
-         d.InstructionSizeOfBuiltin(builtin_index());
+  return d.InstructionStartOfBuiltin(builtin_id()) +
+         d.InstructionSizeOfBuiltin(builtin_id());
 }
 
 int Code::OffHeapMetadataSize() const {
@@ -215,7 +215,7 @@ int Code::OffHeapMetadataSize() const {
     return raw_instruction_size();
   }
   EmbeddedData d = EmbeddedData::FromBlob();
-  return d.MetadataSizeOfBuiltin(builtin_index());
+  return d.MetadataSizeOfBuiltin(builtin_id());
 }
 
 Address Code::OffHeapMetadataStart() const {
@@ -224,7 +224,7 @@ Address Code::OffHeapMetadataStart() const {
     return raw_instruction_size();
   }
   EmbeddedData d = EmbeddedData::FromBlob();
-  return d.MetadataStartOfBuiltin(builtin_index());
+  return d.MetadataStartOfBuiltin(builtin_id());
 }
 
 Address Code::OffHeapMetadataEnd() const {
@@ -233,8 +233,8 @@ Address Code::OffHeapMetadataEnd() const {
     return raw_instruction_size();
   }
   EmbeddedData d = EmbeddedData::FromBlob();
-  return d.MetadataStartOfBuiltin(builtin_index()) +
-         d.MetadataSizeOfBuiltin(builtin_index());
+  return d.MetadataStartOfBuiltin(builtin_id()) +
+         d.MetadataSizeOfBuiltin(builtin_id());
 }
 
 // TODO(cbruni): Move to BytecodeArray
diff --git a/src/objects/code.h b/src/objects/code.h
index f070c6273af..90ad6cd5608 100644
--- a/src/objects/code.h
+++ b/src/objects/code.h
@@ -6,6 +6,7 @@
 #define V8_OBJECTS_CODE_H_
 
 #include "src/base/bit-field.h"
+#include "src/builtins/builtins.h"
 #include "src/codegen/handler-table.h"
 #include "src/deoptimizer/translation-array.h"
 #include "src/objects/code-kind.h"
@@ -296,11 +297,11 @@ class Code : public HeapObject {
   inline bool can_have_weak_objects() const;
   inline void set_can_have_weak_objects(bool value);
 
-  // [builtin_index]: For builtins, tells which builtin index the code object
+  // [builtin]: For builtins, tells which builtin index the code object
   // has. The builtin index is a non-negative integer for builtins, and
   // Builtin::kNoBuiltinId (-1) otherwise.
-  inline int builtin_index() const;
-  inline void set_builtin_index(int id);
+  inline Builtin builtin_id() const;
+  inline void set_builtin_id(Builtin builtin);
   inline bool is_builtin() const;
 
   inline unsigned inlined_bytecode_size() const;
diff --git a/src/objects/feedback-vector.cc b/src/objects/feedback-vector.cc
index 88035ea0dbf..d412a12ab9d 100644
--- a/src/objects/feedback-vector.cc
+++ b/src/objects/feedback-vector.cc
@@ -1171,9 +1171,9 @@ KeyedAccessLoadMode FeedbackNexus::GetKeyedAccessLoadMode() const {
 
 namespace {
 
-bool BuiltinHasKeyedAccessStoreMode(int builtin_index) {
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
-  switch (builtin_index) {
+bool BuiltinHasKeyedAccessStoreMode(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  switch (builtin) {
     case Builtin::kKeyedStoreIC_SloppyArguments_Standard:
     case Builtin::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW:
     case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB:
@@ -1193,9 +1193,9 @@ bool BuiltinHasKeyedAccessStoreMode(int builtin_index) {
   UNREACHABLE();
 }
 
-KeyedAccessStoreMode KeyedAccessStoreModeForBuiltin(int builtin_index) {
-  DCHECK(BuiltinHasKeyedAccessStoreMode(builtin_index));
-  switch (builtin_index) {
+KeyedAccessStoreMode KeyedAccessStoreModeForBuiltin(Builtin builtin) {
+  DCHECK(BuiltinHasKeyedAccessStoreMode(builtin));
+  switch (builtin) {
     case Builtin::kKeyedStoreIC_SloppyArguments_Standard:
     case Builtin::kStoreFastElementIC_Standard:
     case Builtin::kElementsTransitionAndStore_Standard:
@@ -1262,10 +1262,10 @@ KeyedAccessStoreMode FeedbackNexus::GetKeyedAccessStoreMode() const {
     }
 
     if (handler->is_builtin()) {
-      const int builtin_index = handler->builtin_index();
-      if (!BuiltinHasKeyedAccessStoreMode(builtin_index)) continue;
+      Builtin builtin = handler->builtin_id();
+      if (!BuiltinHasKeyedAccessStoreMode(builtin)) continue;
 
-      mode = KeyedAccessStoreModeForBuiltin(builtin_index);
+      mode = KeyedAccessStoreModeForBuiltin(builtin);
       break;
     }
   }
diff --git a/src/objects/js-function-inl.h b/src/objects/js-function-inl.h
index 375e3299ba2..661cb3bd07a 100644
--- a/src/objects/js-function-inl.h
+++ b/src/objects/js-function-inl.h
@@ -269,7 +269,7 @@ DEF_GETTER(JSFunction, prototype, Object) {
 }
 
 bool JSFunction::is_compiled() const {
-  return code(kAcquireLoad).builtin_index() != Builtin::kCompileLazy &&
+  return code(kAcquireLoad).builtin_id() != Builtin::kCompileLazy &&
          shared().is_compiled();
 }
 
@@ -286,7 +286,7 @@ bool JSFunction::NeedsResetDueToFlushedBytecode() {
 
   SharedFunctionInfo shared = SharedFunctionInfo::cast(maybe_shared);
   Code code = Code::cast(maybe_code);
-  return !shared.is_compiled() && code.builtin_index() != Builtin::kCompileLazy;
+  return !shared.is_compiled() && code.builtin_id() != Builtin::kCompileLazy;
 }
 
 void JSFunction::ResetIfBytecodeFlushed(
@@ -296,7 +296,7 @@ void JSFunction::ResetIfBytecodeFlushed(
   if (FLAG_flush_bytecode && NeedsResetDueToFlushedBytecode()) {
     // Bytecode was flushed and function is now uncompiled, reset JSFunction
     // by setting code to CompileLazy and clearing the feedback vector.
-    set_code(GetIsolate()->builtins()->builtin(i::Builtin::kCompileLazy));
+    set_code(GetIsolate()->builtins()->code(i::Builtin::kCompileLazy));
     raw_feedback_cell().reset_feedback_vector(gc_notify_updated_slot);
   }
 }
diff --git a/src/objects/js-function.cc b/src/objects/js-function.cc
index 5ffba6d5590..05ac6a6c93f 100644
--- a/src/objects/js-function.cc
+++ b/src/objects/js-function.cc
@@ -119,7 +119,7 @@ bool JSFunction::ActiveTierIsIgnition() const {
   DCHECK_IMPLIES(result, code.is_interpreter_trampoline_builtin() ||
                              (CodeKindIsOptimizedJSFunction(code.kind()) &&
                               code.marked_for_deoptimization()) ||
-                             (code.builtin_index() == Builtin::kCompileLazy &&
+                             (code.builtin_id() == Builtin::kCompileLazy &&
                               shared().IsInterpreted()));
 #endif  // DEBUG
   return result;
diff --git a/src/objects/objects.cc b/src/objects/objects.cc
index 177e00fb72f..d28b1696637 100644
--- a/src/objects/objects.cc
+++ b/src/objects/objects.cc
@@ -2029,7 +2029,7 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {
       Code code = Code::cast(*this);
       os << "<Code " << CodeKindToString(code.kind());
       if (code.is_builtin()) {
-        os << " " << Builtins::name(code.builtin_index());
+        os << " " << Builtins::name(code.builtin_id());
       }
       os << ">";
       break;
diff --git a/src/objects/shared-function-info-inl.h b/src/objects/shared-function-info-inl.h
index bb4b2624eb7..d86e4bc84f7 100644
--- a/src/objects/shared-function-info-inl.h
+++ b/src/objects/shared-function-info-inl.h
@@ -313,7 +313,7 @@ bool SharedFunctionInfo::construct_as_builtin() const {
 void SharedFunctionInfo::CalculateConstructAsBuiltin() {
   bool uses_builtins_construct_stub = false;
   if (HasBuiltinId()) {
-    int id = builtin_id();
+    Builtin id = builtin_id();
     if (id != Builtin::kCompileLazy && id != Builtin::kEmptyFunction) {
       uses_builtins_construct_stub = true;
     }
@@ -667,16 +667,16 @@ bool SharedFunctionInfo::HasBuiltinId() const {
   return function_data(kAcquireLoad).IsSmi();
 }
 
-int SharedFunctionInfo::builtin_id() const {
+Builtin SharedFunctionInfo::builtin_id() const {
   DCHECK(HasBuiltinId());
   int id = Smi::ToInt(function_data(kAcquireLoad));
   DCHECK(Builtins::IsBuiltinId(id));
-  return id;
+  return Builtins::FromInt(id);
 }
 
-void SharedFunctionInfo::set_builtin_id(int builtin_id) {
-  DCHECK(Builtins::IsBuiltinId(builtin_id));
-  set_function_data(Smi::FromInt(builtin_id), kReleaseStore,
+void SharedFunctionInfo::set_builtin_id(Builtin builtin) {
+  DCHECK(Builtins::IsBuiltinId(builtin));
+  set_function_data(Smi::FromInt(static_cast<int>(builtin)), kReleaseStore,
                     SKIP_WRITE_BARRIER);
 }
 
diff --git a/src/objects/shared-function-info.cc b/src/objects/shared-function-info.cc
index 6a3747232a2..ad9873578b4 100644
--- a/src/objects/shared-function-info.cc
+++ b/src/objects/shared-function-info.cc
@@ -77,12 +77,12 @@ Code SharedFunctionInfo::GetCode() const {
   if (data.IsSmi()) {
     // Holding a Smi means we are a builtin.
     DCHECK(HasBuiltinId());
-    return isolate->builtins()->builtin(builtin_id());
+    return isolate->builtins()->code(builtin_id());
   }
   if (data.IsBytecodeArray()) {
     // Having a bytecode array means we are a compiled, interpreted function.
     DCHECK(HasBytecodeArray());
-    return isolate->builtins()->builtin(Builtin::kInterpreterEntryTrampoline);
+    return isolate->builtins()->code(Builtin::kInterpreterEntryTrampoline);
   }
   if (data.IsBaselineData()) {
     // Having BaselineData means we are a compiled, baseline function.
@@ -93,7 +93,7 @@ Code SharedFunctionInfo::GetCode() const {
   if (data.IsAsmWasmData()) {
     // Having AsmWasmData means we are an asm.js/wasm function.
     DCHECK(HasAsmWasmData());
-    return isolate->builtins()->builtin(Builtin::kInstantiateAsmJs);
+    return isolate->builtins()->code(Builtin::kInstantiateAsmJs);
   }
   if (data.IsWasmExportedFunctionData()) {
     // Having a WasmExportedFunctionData means the code is in there.
@@ -110,12 +110,12 @@ Code SharedFunctionInfo::GetCode() const {
   if (data.IsUncompiledData()) {
     // Having uncompiled data (with or without scope) means we need to compile.
     DCHECK(HasUncompiledData());
-    return isolate->builtins()->builtin(Builtin::kCompileLazy);
+    return isolate->builtins()->code(Builtin::kCompileLazy);
   }
   if (data.IsFunctionTemplateInfo()) {
     // Having a function template info means we are an API function.
     DCHECK(IsApiFunction());
-    return isolate->builtins()->builtin(Builtin::kHandleApiCall);
+    return isolate->builtins()->code(Builtin::kHandleApiCall);
   }
   if (data.IsInterpreterData()) {
     Code code = InterpreterTrampoline();
diff --git a/src/objects/shared-function-info.h b/src/objects/shared-function-info.h
index fc44f52061a..459acce0f57 100644
--- a/src/objects/shared-function-info.h
+++ b/src/objects/shared-function-info.h
@@ -8,6 +8,7 @@
 #include <memory>
 
 #include "src/base/bit-field.h"
+#include "src/builtins/builtins.h"
 #include "src/codegen/bailout-reason.h"
 #include "src/objects/compressed-slots.h"
 #include "src/objects/function-kind.h"
@@ -332,10 +333,10 @@ class SharedFunctionInfo
   inline const wasm::FunctionSig* wasm_function_signature() const;
 #endif  // V8_ENABLE_WEBASSEMBLY
 
-  // builtin_id corresponds to the auto-generated Builtin id.
+  // builtin corresponds to the auto-generated Builtin enum.
   inline bool HasBuiltinId() const;
-  inline int builtin_id() const;
-  inline void set_builtin_id(int builtin_id);
+  inline Builtin builtin_id() const;
+  inline void set_builtin_id(Builtin builtin);
   inline bool HasUncompiledData() const;
   inline UncompiledData uncompiled_data() const;
   inline void set_uncompiled_data(UncompiledData data);
diff --git a/src/profiler/cpu-profiler-inl.h b/src/profiler/cpu-profiler-inl.h
index ebfc6be7f39..ea2b4487a27 100644
--- a/src/profiler/cpu-profiler-inl.h
+++ b/src/profiler/cpu-profiler-inl.h
@@ -46,15 +46,15 @@ void CodeDeoptEventRecord::UpdateCodeMap(CodeMap* code_map) {
 void ReportBuiltinEventRecord::UpdateCodeMap(CodeMap* code_map) {
   CodeEntry* entry = code_map->FindEntry(instruction_start);
   if (entry) {
-    entry->SetBuiltinId(builtin_id);
+    entry->SetBuiltinId(builtin);
     return;
   }
 #if V8_ENABLE_WEBASSEMBLY
-  if (builtin_id == Builtin::kGenericJSToWasmWrapper) {
+  if (builtin == Builtin::kGenericJSToWasmWrapper) {
     // Make sure to add the generic js-to-wasm wrapper builtin, because that
     // one is supposed to show up in profiles.
-    entry = new CodeEntry(CodeEventListener::BUILTIN_TAG,
-                          Builtins::name(builtin_id));
+    entry =
+        new CodeEntry(CodeEventListener::BUILTIN_TAG, Builtins::name(builtin));
     code_map->AddCode(instruction_start, entry, instruction_size);
   }
 #endif  // V8_ENABLE_WEBASSEMBLY
diff --git a/src/profiler/cpu-profiler.cc b/src/profiler/cpu-profiler.cc
index 7fee62b99e0..f5221d67d1e 100644
--- a/src/profiler/cpu-profiler.cc
+++ b/src/profiler/cpu-profiler.cc
@@ -395,14 +395,14 @@ void ProfilerCodeObserver::CreateEntriesForRuntimeCallStats() {
 void ProfilerCodeObserver::LogBuiltins() {
   Builtins* builtins = isolate_->builtins();
   DCHECK(builtins->is_initialized());
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
     CodeEventsContainer evt_rec(CodeEventRecord::REPORT_BUILTIN);
     ReportBuiltinEventRecord* rec = &evt_rec.ReportBuiltinEventRecord_;
-    Builtin id = static_cast<Builtin>(i);
-    Code code = builtins->builtin(id);
+    Code code = builtins->code(builtin);
     rec->instruction_start = code.InstructionStart();
     rec->instruction_size = code.InstructionSize();
-    rec->builtin_id = id;
+    rec->builtin = builtin;
     CodeEventHandlerInternal(evt_rec);
   }
 }
diff --git a/src/profiler/cpu-profiler.h b/src/profiler/cpu-profiler.h
index c8e4540337b..8ffb45c7cf3 100644
--- a/src/profiler/cpu-profiler.h
+++ b/src/profiler/cpu-profiler.h
@@ -98,7 +98,7 @@ class ReportBuiltinEventRecord : public CodeEventRecord {
  public:
   Address instruction_start;
   unsigned instruction_size;
-  Builtin builtin_id;
+  Builtin builtin;
 
   V8_INLINE void UpdateCodeMap(CodeMap* code_map);
 };
diff --git a/src/profiler/profile-generator-inl.h b/src/profiler/profile-generator-inl.h
index 1a513f694d2..da847a240b8 100644
--- a/src/profiler/profile-generator-inl.h
+++ b/src/profiler/profile-generator-inl.h
@@ -18,7 +18,7 @@ CodeEntry::CodeEntry(CodeEventListener::LogEventsAndTags tag, const char* name,
                      std::unique_ptr<SourcePositionTable> line_info,
                      bool is_shared_cross_origin, CodeType code_type)
     : bit_field_(TagField::encode(tag) |
-                 BuiltinIdField::encode(Builtin::kIllegal) |
+                 BuiltinField::encode(Builtin::kIllegal) |
                  CodeTypeField::encode(code_type) |
                  SharedCrossOriginField::encode(is_shared_cross_origin)),
       name_(name),
diff --git a/src/profiler/profile-generator.cc b/src/profiler/profile-generator.cc
index 5a5730615c8..7d51fa91651 100644
--- a/src/profiler/profile-generator.cc
+++ b/src/profiler/profile-generator.cc
@@ -159,7 +159,7 @@ bool CodeEntry::IsSameFunctionAs(const CodeEntry* entry) const {
 
 void CodeEntry::SetBuiltinId(Builtin id) {
   bit_field_ = TagField::update(bit_field_, CodeEventListener::BUILTIN_TAG);
-  bit_field_ = BuiltinIdField::update(bit_field_, id);
+  bit_field_ = BuiltinField::update(bit_field_, id);
 }
 
 int CodeEntry::GetSourceLine(int pc_offset) const {
diff --git a/src/profiler/profile-generator.h b/src/profiler/profile-generator.h
index fc355d16857..f00306acab0 100644
--- a/src/profiler/profile-generator.h
+++ b/src/profiler/profile-generator.h
@@ -131,7 +131,7 @@ class CodeEntry {
   void FillFunctionInfo(SharedFunctionInfo shared);
 
   void SetBuiltinId(Builtin id);
-  Builtin builtin_id() const { return BuiltinIdField::decode(bit_field_); }
+  Builtin builtin() const { return BuiltinField::decode(bit_field_); }
 
   bool is_shared_cross_origin() const {
     return SharedCrossOriginField::decode(bit_field_);
@@ -206,8 +206,8 @@ class CodeEntry {
   RareData* EnsureRareData();
 
   using TagField = base::BitField<CodeEventListener::LogEventsAndTags, 0, 8>;
-  using BuiltinIdField = base::BitField<Builtin, 8, 20>;
-  static_assert(Builtins::kBuiltinCount <= BuiltinIdField::kNumValues,
+  using BuiltinField = base::BitField<Builtin, 8, 20>;
+  static_assert(Builtins::kBuiltinCount <= BuiltinField::kNumValues,
                 "builtin_count exceeds size of bitfield");
   using CodeTypeField = base::BitField<CodeType, 28, 2>;
   using UsedField = base::BitField<bool, 30, 1>;
diff --git a/src/profiler/symbolizer.cc b/src/profiler/symbolizer.cc
index 295c103aa8c..61e884265d6 100644
--- a/src/profiler/symbolizer.cc
+++ b/src/profiler/symbolizer.cc
@@ -96,8 +96,8 @@ Symbolizer::SymbolizedSample Symbolizer::SymbolizeTickSample(
         src_line_not_found = false;
         stack_trace.push_back({pc_entry, src_line});
 
-        if (pc_entry->builtin_id() == Builtin::kFunctionPrototypeApply ||
-            pc_entry->builtin_id() == Builtin::kFunctionPrototypeCall) {
+        if (pc_entry->builtin() == Builtin::kFunctionPrototypeApply ||
+            pc_entry->builtin() == Builtin::kFunctionPrototypeCall) {
           // When current function is either the Function.prototype.apply or the
           // Function.prototype.call builtin the top frame is either frame of
           // the calling JS function or internal frame.
diff --git a/src/runtime/runtime-compiler.cc b/src/runtime/runtime-compiler.cc
index 874ad9e9ec8..8316df583dc 100644
--- a/src/runtime/runtime-compiler.cc
+++ b/src/runtime/runtime-compiler.cc
@@ -172,8 +172,8 @@ RUNTIME_FUNCTION(Runtime_InstantiateAsmJs) {
   shared->set_is_asm_wasm_broken(true);
 #endif
   DCHECK(function->code() ==
-         isolate->builtins()->builtin(Builtin::kInstantiateAsmJs));
-  function->set_code(isolate->builtins()->builtin(Builtin::kCompileLazy));
+         isolate->builtins()->code(Builtin::kInstantiateAsmJs));
+  function->set_code(isolate->builtins()->code(Builtin::kCompileLazy));
   DCHECK(!isolate->has_pending_exception());
   return Smi::zero();
 }
diff --git a/src/runtime/runtime-test-wasm.cc b/src/runtime/runtime-test-wasm.cc
index c4e97c86203..50903377919 100644
--- a/src/runtime/runtime-test-wasm.cc
+++ b/src/runtime/runtime-test-wasm.cc
@@ -271,7 +271,7 @@ RUNTIME_FUNCTION(Runtime_IsWasmCode) {
   bool is_js_to_wasm =
       function.code().kind() == CodeKind::JS_TO_WASM_FUNCTION ||
       (function.code().is_builtin() &&
-       function.code().builtin_index() == Builtin::kGenericJSToWasmWrapper);
+       function.code().builtin_id() == Builtin::kGenericJSToWasmWrapper);
   return isolate->heap()->ToBoolean(is_js_to_wasm);
 }
 
diff --git a/src/snapshot/deserializer.cc b/src/snapshot/deserializer.cc
index dd8a753e34f..d4f20526559 100644
--- a/src/snapshot/deserializer.cc
+++ b/src/snapshot/deserializer.cc
@@ -689,12 +689,11 @@ void Deserializer::RelocInfoVisitor::VisitOffHeapTarget(Code host,
   byte data = source().Get();
   CHECK_EQ(data, kOffHeapTarget);
 
-  int builtin_index = source().GetInt();
-  DCHECK(Builtins::IsBuiltinId(builtin_index));
+  Builtin builtin = Builtins::FromInt(source().GetInt());
 
   CHECK_NOT_NULL(isolate()->embedded_blob_code());
   EmbeddedData d = EmbeddedData::FromBlob(isolate());
-  Address address = d.InstructionStartOfBuiltin(builtin_index);
+  Address address = d.InstructionStartOfBuiltin(builtin);
   CHECK_NE(kNullAddress, address);
 
   // TODO(ishell): implement RelocInfo::set_target_off_heap_target()
diff --git a/src/snapshot/embedded/embedded-data.cc b/src/snapshot/embedded/embedded-data.cc
index 890fb34c6ef..a3f3fbcd5ba 100644
--- a/src/snapshot/embedded/embedded-data.cc
+++ b/src/snapshot/embedded/embedded-data.cc
@@ -19,7 +19,9 @@ namespace {
 Builtin TryLookupCode(const EmbeddedData& d, Address address) {
   if (!d.IsInCodeRange(address)) return Builtin::kNoBuiltinId;
 
-  if (address < d.InstructionStartOfBuiltin(0)) return Builtin::kNoBuiltinId;
+  if (address < d.InstructionStartOfBuiltin(static_cast<Builtin>(0))) {
+    return Builtin::kNoBuiltinId;
+  }
 
   // Note: Addresses within the padding section between builtins (i.e. within
   // start + size <= address < start + padded_size) are interpreted as belonging
@@ -28,15 +30,16 @@ Builtin TryLookupCode(const EmbeddedData& d, Address address) {
   int l = 0, r = Builtins::kBuiltinCount;
   while (l < r) {
     const int mid = (l + r) / 2;
-    Address start = d.InstructionStartOfBuiltin(mid);
-    Address end = start + d.PaddedInstructionSizeOfBuiltin(mid);
+    const Builtin builtin = Builtins::FromInt(mid);
+    Address start = d.InstructionStartOfBuiltin(builtin);
+    Address end = start + d.PaddedInstructionSizeOfBuiltin(builtin);
 
     if (address < start) {
       r = mid;
     } else if (address >= end) {
       l = mid + 1;
     } else {
-      return static_cast<Builtin>(mid);
+      return builtin;
     }
   }
 
@@ -169,8 +172,8 @@ void InstructionStream::FreeOffHeapInstructionStream(uint8_t* code,
 namespace {
 
 bool BuiltinAliasesOffHeapTrampolineRegister(Isolate* isolate, Code code) {
-  DCHECK(Builtins::IsIsolateIndependent(code.builtin_index()));
-  switch (Builtins::KindOf(code.builtin_index())) {
+  DCHECK(Builtins::IsIsolateIndependent(code.builtin_id()));
+  switch (Builtins::KindOf(code.builtin_id())) {
     case Builtins::CPP:
     case Builtins::TFC:
     case Builtins::TFH:
@@ -191,8 +194,7 @@ bool BuiltinAliasesOffHeapTrampolineRegister(Isolate* isolate, Code code) {
     return true;
   }
 
-  Callable callable = Builtins::CallableFor(
-      isolate, static_cast<Builtin>(code.builtin_index()));
+  Callable callable = Builtins::CallableFor(isolate, code.builtin_id());
   CallInterfaceDescriptor descriptor = callable.descriptor();
 
   for (int i = 0; i < descriptor.GetRegisterParameterCount(); i++) {
@@ -209,8 +211,9 @@ void FinalizeEmbeddedCodeTargets(Isolate* isolate, EmbeddedData* blob) {
       RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET);
 
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Code code = isolate->builtins()->builtin(i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Code code = isolate->builtins()->code(builtin);
     RelocIterator on_heap_it(code, kRelocMask);
     RelocIterator off_heap_it(blob, code, kRelocMask);
 
@@ -232,7 +235,7 @@ void FinalizeEmbeddedCodeTargets(Isolate* isolate, EmbeddedData* blob) {
 
       // Do not emit write-barrier for off-heap writes.
       off_heap_it.rinfo()->set_target_address(
-          blob->InstructionStartOfBuiltin(target.builtin_index()),
+          blob->InstructionStartOfBuiltin(target.builtin_id()),
           SKIP_WRITE_BARRIER);
 
       on_heap_it.next();
@@ -262,19 +265,21 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
   uint32_t raw_code_size = 0;
   uint32_t raw_data_size = 0;
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Code code = builtins->builtin(i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Code code = builtins->code(builtin);
 
     // Sanity-check that the given builtin is isolate-independent and does not
     // use the trampoline register in its calling convention.
     if (!code.IsIsolateIndependent(isolate)) {
       saw_unsafe_builtin = true;
-      fprintf(stderr, "%s is not isolate-independent.\n", Builtins::name(i));
+      fprintf(stderr, "%s is not isolate-independent.\n",
+              Builtins::name(builtin));
     }
     if (BuiltinAliasesOffHeapTrampolineRegister(isolate, code)) {
       saw_unsafe_builtin = true;
       fprintf(stderr, "%s aliases the off-heap trampoline register.\n",
-              Builtins::name(i));
+              Builtins::name(builtin));
     }
 
     uint32_t instruction_size =
@@ -282,10 +287,11 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
     uint32_t metadata_size = static_cast<uint32_t>(code.raw_metadata_size());
 
     DCHECK_EQ(0, raw_code_size % kCodeAlignment);
-    layout_descriptions[i].instruction_offset = raw_code_size;
-    layout_descriptions[i].instruction_length = instruction_size;
-    layout_descriptions[i].metadata_offset = raw_data_size;
-    layout_descriptions[i].metadata_length = metadata_size;
+    const int builtin_index = static_cast<int>(builtin);
+    layout_descriptions[builtin_index].instruction_offset = raw_code_size;
+    layout_descriptions[builtin_index].instruction_length = instruction_size;
+    layout_descriptions[builtin_index].metadata_offset = raw_data_size;
+    layout_descriptions[builtin_index].metadata_length = metadata_size;
 
     // Align the start of each section.
     raw_code_size += PadAndAlignCode(instruction_size);
@@ -327,9 +333,11 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
   // .. and the variable-size data section.
   uint8_t* const raw_metadata_start = blob_data + RawMetadataOffset();
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Code code = builtins->builtin(i);
-    uint32_t offset = layout_descriptions[i].metadata_offset;
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Code code = builtins->code(builtin);
+    uint32_t offset =
+        layout_descriptions[static_cast<int>(builtin)].metadata_offset;
     uint8_t* dst = raw_metadata_start + offset;
     DCHECK_LE(RawMetadataOffset() + offset + code.raw_metadata_size(),
               blob_data_size);
@@ -340,9 +348,11 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
   // .. and the variable-size code section.
   uint8_t* const raw_code_start = blob_code + RawCodeOffset();
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
-    Code code = builtins->builtin(i);
-    uint32_t offset = layout_descriptions[i].instruction_offset;
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    Code code = builtins->code(builtin);
+    uint32_t offset =
+        layout_descriptions[static_cast<int>(builtin)].instruction_offset;
     uint8_t* dst = raw_code_start + offset;
     DCHECK_LE(RawCodeOffset() + offset + code.raw_instruction_size(),
               blob_code_size);
@@ -378,32 +388,34 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
   return d;
 }
 
-Address EmbeddedData::InstructionStartOfBuiltin(int i) const {
-  DCHECK(Builtins::IsBuiltinId(i));
+Address EmbeddedData::InstructionStartOfBuiltin(Builtin builtin) const {
+  DCHECK(Builtins::IsBuiltinId(builtin));
   const struct LayoutDescription* descs = LayoutDescription();
-  const uint8_t* result = RawCode() + descs[i].instruction_offset;
+  const uint8_t* result =
+      RawCode() + descs[static_cast<int>(builtin)].instruction_offset;
   DCHECK_LT(result, code_ + code_size_);
   return reinterpret_cast<Address>(result);
 }
 
-uint32_t EmbeddedData::InstructionSizeOfBuiltin(int i) const {
-  DCHECK(Builtins::IsBuiltinId(i));
+uint32_t EmbeddedData::InstructionSizeOfBuiltin(Builtin builtin) const {
+  DCHECK(Builtins::IsBuiltinId(builtin));
   const struct LayoutDescription* descs = LayoutDescription();
-  return descs[i].instruction_length;
+  return descs[static_cast<int>(builtin)].instruction_length;
 }
 
-Address EmbeddedData::MetadataStartOfBuiltin(int i) const {
-  DCHECK(Builtins::IsBuiltinId(i));
+Address EmbeddedData::MetadataStartOfBuiltin(Builtin builtin) const {
+  DCHECK(Builtins::IsBuiltinId(builtin));
   const struct LayoutDescription* descs = LayoutDescription();
-  const uint8_t* result = RawMetadata() + descs[i].metadata_offset;
-  DCHECK_LE(descs[i].metadata_offset, data_size_);
+  const uint8_t* result =
+      RawMetadata() + descs[static_cast<int>(builtin)].metadata_offset;
+  DCHECK_LE(descs[static_cast<int>(builtin)].metadata_offset, data_size_);
   return reinterpret_cast<Address>(result);
 }
 
-uint32_t EmbeddedData::MetadataSizeOfBuiltin(int i) const {
-  DCHECK(Builtins::IsBuiltinId(i));
+uint32_t EmbeddedData::MetadataSizeOfBuiltin(Builtin builtin) const {
+  DCHECK(Builtins::IsBuiltinId(builtin));
   const struct LayoutDescription* descs = LayoutDescription();
-  return descs[i].metadata_length;
+  return descs[static_cast<int>(builtin)].metadata_length;
 }
 
 Address EmbeddedData::InstructionStartOfBytecodeHandlers() const {
@@ -411,10 +423,11 @@ Address EmbeddedData::InstructionStartOfBytecodeHandlers() const {
 }
 
 Address EmbeddedData::InstructionEndOfBytecodeHandlers() const {
-  STATIC_ASSERT(Builtin::kFirstBytecodeHandler + kNumberOfBytecodeHandlers +
+  STATIC_ASSERT(static_cast<int>(Builtin::kFirstBytecodeHandler) +
+                    kNumberOfBytecodeHandlers +
                     2 * kNumberOfWideBytecodeHandlers ==
                 Builtins::kBuiltinCount);
-  int lastBytecodeHandler = Builtins::kBuiltinCount - 1;
+  Builtin lastBytecodeHandler = Builtins::FromInt(Builtins::kBuiltinCount - 1);
   return InstructionStartOfBuiltin(lastBytecodeHandler) +
          InstructionSizeOfBuiltin(lastBytecodeHandler);
 }
@@ -445,7 +458,7 @@ void EmbeddedData::PrintStatistics() const {
   int sizes[kCount];
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
   for (int i = 0; i < kCount; i++) {
-    sizes[i] = InstructionSizeOfBuiltin(i);
+    sizes[i] = InstructionSizeOfBuiltin(Builtins::FromInt(i));
   }
 
   // Sort for percentiles.
diff --git a/src/snapshot/embedded/embedded-data.h b/src/snapshot/embedded/embedded-data.h
index 3a7d3abd38c..9ccacea24c3 100644
--- a/src/snapshot/embedded/embedded-data.h
+++ b/src/snapshot/embedded/embedded-data.h
@@ -108,14 +108,14 @@ class EmbeddedData final {
     data_ = nullptr;
   }
 
-  Address InstructionStartOfBuiltin(int i) const;
-  uint32_t InstructionSizeOfBuiltin(int i) const;
+  Address InstructionStartOfBuiltin(Builtin builtin) const;
+  uint32_t InstructionSizeOfBuiltin(Builtin builtin) const;
 
   Address InstructionStartOfBytecodeHandlers() const;
   Address InstructionEndOfBytecodeHandlers() const;
 
-  Address MetadataStartOfBuiltin(int i) const;
-  uint32_t MetadataSizeOfBuiltin(int i) const;
+  Address MetadataStartOfBuiltin(Builtin builtin) const;
+  uint32_t MetadataSizeOfBuiltin(Builtin builtin) const;
 
   uint32_t AddressForHashing(Address addr) {
     DCHECK(IsInCodeRange(addr));
@@ -125,8 +125,8 @@ class EmbeddedData final {
 
   // Padded with kCodeAlignment.
   // TODO(v8:11045): Consider removing code alignment.
-  uint32_t PaddedInstructionSizeOfBuiltin(int i) const {
-    uint32_t size = InstructionSizeOfBuiltin(i);
+  uint32_t PaddedInstructionSizeOfBuiltin(Builtin builtin) const {
+    uint32_t size = InstructionSizeOfBuiltin(builtin);
     CHECK_NE(size, 0);
     return PadAndAlignCode(size);
   }
diff --git a/src/snapshot/embedded/embedded-file-writer-interface.h b/src/snapshot/embedded/embedded-file-writer-interface.h
index 0873eecbb75..fd2b50897d2 100644
--- a/src/snapshot/embedded/embedded-file-writer-interface.h
+++ b/src/snapshot/embedded/embedded-file-writer-interface.h
@@ -45,7 +45,7 @@ class EmbeddedFileWriterInterface {
 
 #if defined(V8_OS_WIN64)
   virtual void SetBuiltinUnwindData(
-      int builtin_index,
+      Builtin builtin,
       const win64_unwindinfo::BuiltinUnwindInfo& unwinding_info) = 0;
 #endif  // V8_OS_WIN64
 };
diff --git a/src/snapshot/embedded/embedded-file-writer.cc b/src/snapshot/embedded/embedded-file-writer.cc
index 7ab92c235c7..37000683558 100644
--- a/src/snapshot/embedded/embedded-file-writer.cc
+++ b/src/snapshot/embedded/embedded-file-writer.cc
@@ -48,17 +48,17 @@ int WriteLineEndIfNeeded(PlatformEmbeddedFileWriterBase* w,
 
 void EmbeddedFileWriter::WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
                                       const i::EmbeddedData* blob,
-                                      const int builtin_id) const {
+                                      const Builtin builtin) const {
   const bool is_default_variant =
       std::strcmp(embedded_variant_, kDefaultEmbeddedVariant) == 0;
 
   i::EmbeddedVector<char, kTemporaryStringLength> builtin_symbol;
   if (is_default_variant) {
     // Create nicer symbol names for the default mode.
-    i::SNPrintF(builtin_symbol, "Builtins_%s", i::Builtins::name(builtin_id));
+    i::SNPrintF(builtin_symbol, "Builtins_%s", i::Builtins::name(builtin));
   } else {
     i::SNPrintF(builtin_symbol, "%s_Builtins_%s", embedded_variant_,
-                i::Builtins::name(builtin_id));
+                i::Builtins::name(builtin));
   }
 
   // Labels created here will show up in backtraces. We check in
@@ -66,7 +66,8 @@ void EmbeddedFileWriter::WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
   // that labels do not insert bytes into the middle of the blob byte
   // stream.
   w->DeclareFunctionBegin(builtin_symbol.begin(),
-                          blob->InstructionSizeOfBuiltin(builtin_id));
+                          blob->InstructionSizeOfBuiltin(builtin));
+  const int builtin_id = static_cast<int>(builtin);
   const std::vector<byte>& current_positions = source_positions_[builtin_id];
   // The code below interleaves bytes of assembly code for the builtin
   // function with source positions at the appropriate offsets.
@@ -85,8 +86,8 @@ void EmbeddedFileWriter::WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
   auto label = current_labels.begin();
 
   const uint8_t* data = reinterpret_cast<const uint8_t*>(
-      blob->InstructionStartOfBuiltin(builtin_id));
-  uint32_t size = blob->PaddedInstructionSizeOfBuiltin(builtin_id);
+      blob->InstructionStartOfBuiltin(builtin));
+  uint32_t size = blob->PaddedInstructionSizeOfBuiltin(builtin);
   uint32_t i = 0;
   uint32_t next_source_pos_offset =
       static_cast<uint32_t>(positions.done() ? size : positions.code_offset());
@@ -157,8 +158,9 @@ void EmbeddedFileWriter::WriteCodeSection(PlatformEmbeddedFileWriterBase* w,
   w->DeclareLabel(EmbeddedBlobCodeDataSymbol().c_str());
 
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < i::Builtins::kBuiltinCount; i++) {
-    WriteBuiltin(w, blob, i);
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
+    WriteBuiltin(w, blob, builtin);
   }
   w->Newline();
 }
@@ -283,24 +285,25 @@ int EmbeddedFileWriter::GetExternallyCompiledFilenameCount() const {
 }
 
 void EmbeddedFileWriter::PrepareBuiltinSourcePositionMap(Builtins* builtins) {
-  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
+  for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+       ++builtin) {
     // Retrieve the SourcePositionTable and copy it.
-    Code code = builtins->builtin(i);
+    Code code = builtins->code(builtin);
     // Verify that the code object is still the "real code" and not a
     // trampoline (which wouldn't have source positions).
     DCHECK(!code.is_off_heap_trampoline());
     ByteArray source_position_table = code.source_position_table();
     std::vector<unsigned char> data(source_position_table.GetDataStartAddress(),
                                     source_position_table.GetDataEndAddress());
-    source_positions_[i] = data;
+    source_positions_[static_cast<int>(builtin)] = data;
   }
 }
 
 void EmbeddedFileWriter::PrepareBuiltinLabelInfoMap(int create_offset,
                                                     int invoke_offset) {
-  label_info_[Builtin::kJSConstructStubGeneric].push_back(
+  label_info_[static_cast<int>(Builtin::kJSConstructStubGeneric)].push_back(
       {create_offset, "construct_stub_create_deopt_addr"});
-  label_info_[Builtin::kJSConstructStubGeneric].push_back(
+  label_info_[static_cast<int>(Builtin::kJSConstructStubGeneric)].push_back(
       {invoke_offset, "construct_stub_invoke_deopt_addr"});
 }
 
diff --git a/src/snapshot/embedded/embedded-file-writer.h b/src/snapshot/embedded/embedded-file-writer.h
index bf942807f1c..53048d37f56 100644
--- a/src/snapshot/embedded/embedded-file-writer.h
+++ b/src/snapshot/embedded/embedded-file-writer.h
@@ -44,10 +44,10 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
 
 #if defined(V8_OS_WIN64)
   void SetBuiltinUnwindData(
-      int builtin_index,
+      Builtin builtin,
       const win64_unwindinfo::BuiltinUnwindInfo& unwinding_info) override {
-    DCHECK_LT(builtin_index, Builtins::kBuiltinCount);
-    unwind_infos_[builtin_index] = unwinding_info;
+    DCHECK_LT(static_cast<int>(builtin), Builtins::kBuiltinCount);
+    unwind_infos_[static_cast<int>(builtin)] = unwinding_info;
   }
 #endif  // V8_OS_WIN64
 
@@ -151,7 +151,7 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
   }
 
   void WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
-                    const i::EmbeddedData* blob, const int builtin_id) const;
+                    const i::EmbeddedData* blob, const Builtin builtin) const;
 
   void WriteBuiltinLabels(PlatformEmbeddedFileWriterBase* w,
                           std::string name) const;
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-win.cc b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
index 40d8dd036a9..136a94f8691 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-win.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
@@ -111,17 +111,20 @@ void EmitUnwindData(PlatformEmbeddedFileWriterWin* w,
   {
     STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
     Address prev_builtin_end_offset = 0;
-    for (int i = 0; i < Builtins::kBuiltinCount; i++) {
+    for (Builtin builtin = Builtins::kFirst; builtin <= Builtins::kLast;
+         ++builtin) {
+      const int builtin_index = static_cast<int>(builtin);
       // Some builtins are leaf functions from the point of view of Win64 stack
       // walking: they do not move the stack pointer and do not require a PDATA
       // entry because the return address can be retrieved from [rsp].
-      if (unwind_infos[i].is_leaf_function()) continue;
+      if (unwind_infos[builtin_index].is_leaf_function()) continue;
 
-      uint64_t builtin_start_offset = blob->InstructionStartOfBuiltin(i) -
+      uint64_t builtin_start_offset = blob->InstructionStartOfBuiltin(builtin) -
                                       reinterpret_cast<Address>(blob->code());
-      uint32_t builtin_size = blob->InstructionSizeOfBuiltin(i);
+      uint32_t builtin_size = blob->InstructionSizeOfBuiltin(builtin);
 
-      const std::vector<int>& xdata_desc = unwind_infos[i].fp_offsets();
+      const std::vector<int>& xdata_desc =
+          unwind_infos[builtin_index].fp_offsets();
       if (xdata_desc.empty()) {
         // Some builtins do not have any "push rbp - mov rbp, rsp" instructions
         // to start a stack frame. We still emit a PDATA entry as if they had,
diff --git a/src/snapshot/serializer.cc b/src/snapshot/serializer.cc
index 7ace802272c..14ceb9c7d61 100644
--- a/src/snapshot/serializer.cc
+++ b/src/snapshot/serializer.cc
@@ -1008,7 +1008,7 @@ void Serializer::ObjectSerializer::VisitOffHeapTarget(Code host,
   CHECK(Builtins::IsIsolateIndependent(builtin));
 
   sink_->Put(kOffHeapTarget, "OffHeapTarget");
-  sink_->PutInt(builtin, "builtin index");
+  sink_->PutInt(static_cast<int>(builtin), "builtin index");
 }
 
 void Serializer::ObjectSerializer::VisitCodeTarget(Code host,
diff --git a/src/snapshot/startup-serializer.cc b/src/snapshot/startup-serializer.cc
index 14e471f6f4e..6506e1d1024 100644
--- a/src/snapshot/startup-serializer.cc
+++ b/src/snapshot/startup-serializer.cc
@@ -97,7 +97,7 @@ bool IsUnexpectedCodeObject(Isolate* isolate, HeapObject obj) {
   // trampoline copy stored on the root list and transitively called builtins.
   // See Heap::interpreter_entry_trampoline_for_profiling.
 
-  switch (code.builtin_index()) {
+  switch (code.builtin_id()) {
     case Builtin::kAbort:
     case Builtin::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
     case Builtin::kInterpreterEntryTrampoline:
diff --git a/src/wasm/function-compiler.cc b/src/wasm/function-compiler.cc
index 267b948a623..241ea1212ce 100644
--- a/src/wasm/function-compiler.cc
+++ b/src/wasm/function-compiler.cc
@@ -331,8 +331,7 @@ void JSToWasmWrapperCompilationUnit::Execute() {
 Handle<Code> JSToWasmWrapperCompilationUnit::Finalize() {
   Handle<Code> code;
   if (use_generic_wrapper_) {
-    code =
-        isolate_->builtins()->builtin_handle(Builtin::kGenericJSToWasmWrapper);
+    code = isolate_->builtins()->code_handle(Builtin::kGenericJSToWasmWrapper);
   } else {
     CompilationJob::Status status = job_->FinalizeJob(isolate_);
     CHECK_EQ(status, CompilationJob::SUCCEEDED);
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index f9b59cccbff..03156c24658 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1858,7 +1858,7 @@ bool WasmExportedFunction::IsWasmExportedFunction(Object object) {
   if (!object.IsJSFunction()) return false;
   JSFunction js_function = JSFunction::cast(object);
   if (CodeKind::JS_TO_WASM_FUNCTION != js_function.code().kind() &&
-      js_function.code().builtin_index() != Builtin::kGenericJSToWasmWrapper) {
+      js_function.code().builtin_id() != Builtin::kGenericJSToWasmWrapper) {
     return false;
   }
   DCHECK(js_function.shared().HasWasmExportedFunctionData());
@@ -1892,7 +1892,7 @@ Handle<WasmCapiFunction> WasmCapiFunction::New(
   Handle<WasmCapiFunctionData> fun_data =
       isolate->factory()->NewWasmCapiFunctionData(
           call_target, embedder_data,
-          isolate->builtins()->builtin_handle(Builtin::kIllegal),
+          isolate->builtins()->code_handle(Builtin::kIllegal),
           serialized_signature);
   Handle<SharedFunctionInfo> shared =
       isolate->factory()->NewSharedFunctionInfoForWasmCapiFunction(fun_data);
@@ -1914,7 +1914,7 @@ Handle<WasmExportedFunction> WasmExportedFunction::New(
     int arity, Handle<Code> export_wrapper) {
   DCHECK(CodeKind::JS_TO_WASM_FUNCTION == export_wrapper->kind() ||
          (export_wrapper->is_builtin() &&
-          export_wrapper->builtin_index() == Builtin::kGenericJSToWasmWrapper));
+          export_wrapper->builtin_id() == Builtin::kGenericJSToWasmWrapper));
   int num_imported_functions = instance->module()->num_imported_functions;
   Handle<Object> ref =
       func_index >= num_imported_functions
diff --git a/test/cctest/heap/test-alloc.cc b/test/cctest/heap/test-alloc.cc
index d1462878b52..855acd2c72b 100644
--- a/test/cctest/heap/test-alloc.cc
+++ b/test/cctest/heap/test-alloc.cc
@@ -85,7 +85,7 @@ Handle<Object> HeapTester::TestAllocateAfterFailures() {
 
   // Code space.
   heap::SimulateFullSpace(heap->code_space());
-  size = CcTest::i_isolate()->builtins()->builtin(Builtin::kIllegal).Size();
+  size = CcTest::i_isolate()->builtins()->code(Builtin::kIllegal).Size();
   obj =
       heap->AllocateRaw(size, AllocationType::kCode, AllocationOrigin::kRuntime)
           .ToObjectChecked();
diff --git a/test/cctest/interpreter/test-interpreter.cc b/test/cctest/interpreter/test-interpreter.cc
index 4112f838de7..1c726348d37 100644
--- a/test/cctest/interpreter/test-interpreter.cc
+++ b/test/cctest/interpreter/test-interpreter.cc
@@ -5087,24 +5087,24 @@ TEST(InterpreterGetBytecodeHandler) {
   Code wide_handler =
       interpreter->GetBytecodeHandler(Bytecode::kWide, OperandScale::kSingle);
 
-  CHECK_EQ(wide_handler.builtin_index(), Builtin::kWideHandler);
+  CHECK_EQ(wide_handler.builtin_id(), Builtin::kWideHandler);
 
   Code add_handler =
       interpreter->GetBytecodeHandler(Bytecode::kAdd, OperandScale::kSingle);
 
-  CHECK_EQ(add_handler.builtin_index(), Builtin::kAddHandler);
+  CHECK_EQ(add_handler.builtin_id(), Builtin::kAddHandler);
 
   // Test that double-width bytecode handlers deserializer correctly, including
   // an illegal bytecode handler since there is no Wide.Wide handler.
   Code wide_wide_handler =
       interpreter->GetBytecodeHandler(Bytecode::kWide, OperandScale::kDouble);
 
-  CHECK_EQ(wide_wide_handler.builtin_index(), Builtin::kIllegalHandler);
+  CHECK_EQ(wide_wide_handler.builtin_id(), Builtin::kIllegalHandler);
 
   Code add_wide_handler =
       interpreter->GetBytecodeHandler(Bytecode::kAdd, OperandScale::kDouble);
 
-  CHECK_EQ(add_wide_handler.builtin_index(), Builtin::kAddWideHandler);
+  CHECK_EQ(add_wide_handler.builtin_id(), Builtin::kAddWideHandler);
 }
 
 TEST(InterpreterCollectSourcePositions) {
diff --git a/test/cctest/test-debug.cc b/test/cctest/test-debug.cc
index a4f3d4d9a6b..c83c6a64ce5 100644
--- a/test/cctest/test-debug.cc
+++ b/test/cctest/test-debug.cc
@@ -4486,10 +4486,11 @@ TEST(BuiltinsExceptionPrediction) {
 
   i::Builtins* builtins = iisolate->builtins();
   bool fail = false;
-  for (int i = 0; i < i::Builtins::kBuiltinCount; i++) {
-    i::Code builtin = builtins->builtin(i);
-    if (builtin.kind() != i::CodeKind::BUILTIN) continue;
-    auto prediction = builtin.GetBuiltinCatchPrediction();
+  for (i::Builtin builtin = i::Builtins::kFirst; builtin <= i::Builtins::kLast;
+       ++builtin) {
+    i::Code code = builtins->code(builtin);
+    if (code.kind() != i::CodeKind::BUILTIN) continue;
+    auto prediction = code.GetBuiltinCatchPrediction();
     USE(prediction);
   }
   CHECK(!fail);
diff --git a/test/cctest/test-log.cc b/test/cctest/test-log.cc
index f56d65316b9..4c0c7ea8416 100644
--- a/test/cctest/test-log.cc
+++ b/test/cctest/test-log.cc
@@ -1187,7 +1187,7 @@ UNINITIALIZED_TEST(BuiltinsNotLoggedAsLazyCompile) {
     logger.LogCompiledFunctions();
     logger.StopLogging();
 
-    i::Handle<i::Code> builtin = logger.i_isolate()->builtins()->builtin_handle(
+    i::Handle<i::Code> builtin = logger.i_isolate()->builtins()->code_handle(
         i::Builtin::kBooleanConstructor);
     i::EmbeddedVector<char, 100> buffer;
 
diff --git a/test/cctest/test-swiss-name-dictionary-csa.cc b/test/cctest/test-swiss-name-dictionary-csa.cc
index bc93f4a43a7..7d59331e31c 100644
--- a/test/cctest/test-swiss-name-dictionary-csa.cc
+++ b/test/cctest/test-swiss-name-dictionary-csa.cc
@@ -266,7 +266,7 @@ Handle<Code> CSATestRunner::create_find_entry(Isolate* isolate) {
   // TODO(v8:11330): Remove once CSA implementation has a fallback for
   // non-SSSE3/AVX configurations.
   if (!IsEnabled()) {
-    return isolate->builtins()->builtin_handle(Builtin::kIllegal);
+    return isolate->builtins()->code_handle(Builtin::kIllegal);
   }
   STATIC_ASSERT(kFindEntryParams == 2);  // (table, key)
   compiler::CodeAssemblerTester asm_tester(isolate, kFindEntryParams + 1);
@@ -338,7 +338,7 @@ Handle<Code> CSATestRunner::create_delete(Isolate* isolate) {
   // TODO(v8:11330): Remove once CSA implementation has a fallback for
   // non-SSSE3/AVX configurations.
   if (!IsEnabled()) {
-    return isolate->builtins()->builtin_handle(Builtin::kIllegal);
+    return isolate->builtins()->code_handle(Builtin::kIllegal);
   }
   STATIC_ASSERT(kDeleteParams == 2);  // (table, entry)
   compiler::CodeAssemblerTester asm_tester(isolate, kDeleteParams + 1);
@@ -363,7 +363,7 @@ Handle<Code> CSATestRunner::create_add(Isolate* isolate) {
   // TODO(v8:11330): Remove once CSA implementation has a fallback for
   // non-SSSE3/AVX configurations.
   if (!IsEnabled()) {
-    return isolate->builtins()->builtin_handle(Builtin::kIllegal);
+    return isolate->builtins()->code_handle(Builtin::kIllegal);
   }
   STATIC_ASSERT(kAddParams == 4);  // (table, key, value, details)
   compiler::CodeAssemblerTester asm_tester(isolate, kAddParams + 1);
diff --git a/test/cctest/test-unwinder-code-pages.cc b/test/cctest/test-unwinder-code-pages.cc
index 9a5a4eac1fa..053756c6154 100644
--- a/test/cctest/test-unwinder-code-pages.cc
+++ b/test/cctest/test-unwinder-code-pages.cc
@@ -166,7 +166,7 @@ TEST(Unwind_BuiltinPCInMiddle_Success_CodePagesAPI) {
   register_state.fp = stack;
 
   // Put the current PC inside of a valid builtin.
-  Code builtin = i_isolate->builtins()->builtin(Builtin::kStringEqual);
+  Code builtin = i_isolate->builtins()->code(Builtin::kStringEqual);
   const uintptr_t offset = 40;
   CHECK_LT(offset, builtin.InstructionSize());
   register_state.pc =
@@ -223,7 +223,7 @@ TEST(Unwind_BuiltinPCAtStart_Success_CodePagesAPI) {
 
   // Put the current PC at the start of a valid builtin, so that we are setting
   // up the frame.
-  Code builtin = i_isolate->builtins()->builtin(Builtin::kStringEqual);
+  Code builtin = i_isolate->builtins()->code(Builtin::kStringEqual);
   register_state.pc = reinterpret_cast<void*>(builtin.InstructionStart());
 
   bool unwound = v8::Unwinder::TryUnwindV8Frames(
diff --git a/test/cctest/wasm/test-run-wasm-wrappers.cc b/test/cctest/wasm/test-run-wasm-wrappers.cc
index 3db267cc470..355cd5df723 100644
--- a/test/cctest/wasm/test-run-wasm-wrappers.cc
+++ b/test/cctest/wasm/test-run-wasm-wrappers.cc
@@ -33,7 +33,7 @@ Handle<WasmInstanceObject> CompileModule(Zone* zone, Isolate* isolate,
 
 bool IsGeneric(Code wrapper) {
   return wrapper.is_builtin() &&
-         wrapper.builtin_index() == Builtin::kGenericJSToWasmWrapper;
+         wrapper.builtin_id() == Builtin::kGenericJSToWasmWrapper;
 }
 
 bool IsSpecific(Code wrapper) {
-- 
2.35.1


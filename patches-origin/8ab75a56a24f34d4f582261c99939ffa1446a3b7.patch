From 8ab75a56a24f34d4f582261c99939ffa1446a3b7 Mon Sep 17 00:00:00 2001
From: Camillo Bruni <cbruni@chromium.org>
Date: Mon, 7 Jun 2021 17:24:12 +0200
Subject: [PATCH] [runtime] Rename Builtins::Name to Builtin 1/2
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add new Builtin enum
- Move Builtins::Name:kXXX to Builtin::kXXX
- Update existing code

Follow CLs will unify the mix of using int builtin-ids and
Builtins::Name to only use the new Builtin enum and changing it to
an enum class.

Change-Id: Ib39aa45a25696acdf147f46392901b1e051deaa4
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2905592
Commit-Queue: Camillo Bruni <cbruni@chromium.org>
Reviewed-by: Michael Stanton <mvstanton@chromium.org>
Reviewed-by: Mythri Alle <mythria@chromium.org>
Reviewed-by: Dominik Inf√ºhr <dinfuehr@chromium.org>
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Reviewed-by: Jakob Gruber <jgruber@chromium.org>
Reviewed-by: Igor Sheludko <ishell@chromium.org>
Cr-Commit-Position: refs/heads/master@{#74995}
---
 src/api/api.cc                                |   10 +-
 src/asmjs/asm-js.cc                           |    4 +-
 src/baseline/arm/baseline-assembler-arm-inl.h |    8 +-
 src/baseline/arm/baseline-compiler-arm-inl.h  |    2 +-
 .../arm64/baseline-assembler-arm64-inl.h      |    8 +-
 .../arm64/baseline-compiler-arm64-inl.h       |    2 +-
 src/baseline/baseline-assembler.h             |    4 +-
 src/baseline/baseline-compiler.cc             |  304 ++--
 src/baseline/baseline-compiler.h              |    4 +-
 .../ia32/baseline-assembler-ia32-inl.h        |    8 +-
 .../ia32/baseline-compiler-ia32-inl.h         |    2 +-
 .../riscv64/baseline-assembler-riscv64-inl.h  |    8 +-
 .../riscv64/baseline-compiler-riscv64-inl.h   |    2 +-
 src/baseline/x64/baseline-assembler-x64-inl.h |    8 +-
 src/baseline/x64/baseline-compiler-x64-inl.h  |    2 +-
 src/builtins/arm/builtins-arm.cc              |   13 +-
 src/builtins/arm64/builtins-arm64.cc          |   13 +-
 src/builtins/builtins-array-gen.cc            |   37 +-
 src/builtins/builtins-async-function-gen.cc   |    4 +-
 src/builtins/builtins-async-gen.cc            |   12 +-
 src/builtins/builtins-async-generator-gen.cc  |   31 +-
 src/builtins/builtins-async-iterator-gen.cc   |   12 +-
 src/builtins/builtins-call-gen.cc             |   26 +-
 src/builtins/builtins-call-gen.h              |    5 +-
 src/builtins/builtins-collections-gen.cc      |   27 +-
 src/builtins/builtins-console.cc              |   16 +-
 src/builtins/builtins-constructor-gen.cc      |    7 +-
 src/builtins/builtins-date-gen.cc             |    6 +-
 src/builtins/builtins-generator-gen.cc        |    6 +-
 src/builtins/builtins-global-gen.cc           |    4 +-
 src/builtins/builtins-internal-gen.cc         |   16 +-
 src/builtins/builtins-intl-gen.cc             |    4 +-
 src/builtins/builtins-intl.cc                 |   18 +-
 src/builtins/builtins-iterator-gen.cc         |   18 +-
 src/builtins/builtins-microtask-queue-gen.cc  |    6 +-
 src/builtins/builtins-object-gen.cc           |    6 +-
 src/builtins/builtins-regexp-gen.cc           |   18 +-
 src/builtins/builtins-string-gen.cc           |   27 +-
 src/builtins/builtins-trace.cc                |    2 +-
 src/builtins/builtins-typed-array-gen.cc      |    2 +-
 src/builtins/builtins-utils-gen.h             |    2 +-
 src/builtins/builtins.cc                      |   90 +-
 src/builtins/builtins.h                       |   82 +-
 src/builtins/ia32/builtins-ia32.cc            |   13 +-
 src/builtins/mips/builtins-mips.cc            |   11 +-
 src/builtins/mips64/builtins-mips64.cc        |   11 +-
 src/builtins/ppc/builtins-ppc.cc              |    9 +-
 src/builtins/riscv64/builtins-riscv64.cc      |   15 +-
 src/builtins/s390/builtins-s390.cc            |    9 +-
 src/builtins/setup-builtins-internal.cc       |   16 +-
 src/builtins/typed-array-from.tq              |   10 +-
 src/builtins/x64/builtins-x64.cc              |   13 +-
 src/codegen/arm/macro-assembler-arm.cc        |   25 +-
 src/codegen/arm/macro-assembler-arm.h         |    7 +-
 src/codegen/arm64/macro-assembler-arm64.cc    |   23 +-
 src/codegen/arm64/macro-assembler-arm64.h     |   15 +-
 src/codegen/code-factory.cc                   |  128 +-
 src/codegen/code-stub-assembler.cc            |   80 +-
 src/codegen/code-stub-assembler.h             |   12 +-
 src/codegen/ia32/macro-assembler-ia32.cc      |   22 +-
 src/codegen/ia32/macro-assembler-ia32.h       |    4 +-
 src/codegen/interface-descriptors-inl.h       |    4 +-
 src/codegen/interface-descriptors.h           |    2 +-
 src/codegen/mips/macro-assembler-mips.cc      |   16 +-
 src/codegen/mips/macro-assembler-mips.h       |    2 +-
 src/codegen/mips64/macro-assembler-mips64.cc  |   16 +-
 src/codegen/mips64/macro-assembler-mips64.h   |    2 +-
 src/codegen/ppc/macro-assembler-ppc.cc        |   10 +-
 src/codegen/ppc/macro-assembler-ppc.h         |    2 +-
 .../riscv64/macro-assembler-riscv64.cc        |   29 +-
 src/codegen/riscv64/macro-assembler-riscv64.h |   17 +-
 src/codegen/s390/macro-assembler-s390.cc      |   16 +-
 src/codegen/s390/macro-assembler-s390.h       |    2 +-
 src/codegen/turbo-assembler.cc                |    8 +-
 src/codegen/turbo-assembler.h                 |    8 +-
 src/codegen/x64/macro-assembler-x64.cc        |   19 +-
 src/codegen/x64/macro-assembler-x64.h         |   12 +-
 .../backend/arm/code-generator-arm.cc         |    5 +-
 .../backend/arm64/code-generator-arm64.cc     |   11 +-
 src/compiler/backend/code-generator.cc        |    2 +-
 .../backend/ia32/code-generator-ia32.cc       |    7 +-
 .../backend/mips/code-generator-mips.cc       |    5 +-
 .../backend/mips64/code-generator-mips64.cc   |    5 +-
 .../backend/ppc/code-generator-ppc.cc         |    5 +-
 .../backend/riscv64/code-generator-riscv64.cc |    5 +-
 .../backend/s390/code-generator-s390.cc       |    5 +-
 .../backend/x64/code-generator-x64.cc         |    7 +-
 src/compiler/bytecode-graph-builder.cc        |    4 +-
 src/compiler/code-assembler.h                 |    4 +-
 src/compiler/effect-control-linearizer.cc     |   66 +-
 src/compiler/frame-states.cc                  |   16 +-
 src/compiler/frame-states.h                   |    4 +-
 src/compiler/graph-assembler.cc               |    2 +-
 src/compiler/heap-refs.cc                     |    4 +-
 src/compiler/js-call-reducer.cc               |  422 +++--
 src/compiler/js-generic-lowering.cc           |  133 +-
 src/compiler/js-generic-lowering.h            |   10 +-
 src/compiler/js-intrinsic-lowering.cc         |   20 +-
 .../js-native-context-specialization.cc       |   10 +-
 src/compiler/js-typed-lowering.cc             |    6 +-
 src/compiler/node-properties.cc               |   11 +-
 .../serializer-for-background-compilation.cc  |   92 +-
 src/compiler/simplified-lowering.cc           |   12 +-
 src/compiler/typer.cc                         |  316 ++--
 src/compiler/wasm-compiler.cc                 |   90 +-
 src/debug/debug-evaluate.cc                   |  831 +++++-----
 src/debug/debug-interface.cc                  |    2 +-
 src/debug/debug.cc                            |   14 +-
 src/deoptimizer/deoptimizer.cc                |   54 +-
 src/deoptimizer/deoptimizer.h                 |    9 +-
 src/diagnostics/disassembler.cc               |    6 +-
 src/diagnostics/objects-debug.cc              |    6 +-
 src/execution/frames.cc                       |   24 +-
 src/execution/isolate-data.h                  |   12 +-
 src/execution/isolate.cc                      |   41 +-
 src/heap/factory-base.cc                      |    4 +-
 src/heap/factory.cc                           |   12 +-
 src/heap/factory.h                            |    4 +-
 src/heap/heap.cc                              |   11 +-
 src/heap/setup-heap-internal.cc               |   48 +-
 src/ic/accessor-assembler.cc                  |   93 +-
 src/ic/binary-op-assembler.cc                 |   18 +-
 src/ic/stub-cache.cc                          |    6 +-
 src/ic/unary-op-assembler.cc                  |    2 +-
 src/init/bootstrapper.cc                      | 1374 ++++++++---------
 src/interpreter/interpreter-assembler.cc      |    4 +-
 src/interpreter/interpreter-generator.cc      |   37 +-
 .../interpreter-intrinsics-generator.cc       |   40 +-
 src/interpreter/interpreter.cc                |    4 +-
 src/logging/log.cc                            |    2 +-
 src/objects/code-inl.h                        |   28 +-
 src/objects/code.h                            |    2 +-
 src/objects/contexts.h                        |    2 +-
 src/objects/feedback-vector.cc                |   50 +-
 src/objects/js-function-inl.h                 |    7 +-
 src/objects/js-function.cc                    |    2 +-
 src/objects/shared-function-info-inl.h        |   12 +-
 src/objects/shared-function-info.cc           |   14 +-
 src/objects/shared-function-info.h            |    2 +-
 src/profiler/cpu-profiler-inl.h               |    2 +-
 src/profiler/cpu-profiler.cc                  |    4 +-
 src/profiler/cpu-profiler.h                   |    2 +-
 src/profiler/profile-generator-inl.h          |    2 +-
 src/profiler/profile-generator.cc             |    4 +-
 src/profiler/profile-generator.h              |   10 +-
 src/profiler/symbolizer.cc                    |    4 +-
 src/regexp/arm/regexp-macro-assembler-arm.cc  |    2 +-
 .../arm64/regexp-macro-assembler-arm64.cc     |    2 +-
 .../mips/regexp-macro-assembler-mips.cc       |    4 +-
 .../mips64/regexp-macro-assembler-mips64.cc   |    4 +-
 src/regexp/ppc/regexp-macro-assembler-ppc.cc  |    2 +-
 .../riscv64/regexp-macro-assembler-riscv64.cc |    4 +-
 src/runtime/runtime-compiler.cc               |    4 +-
 src/runtime/runtime-test-wasm.cc              |    4 +-
 src/snapshot/embedded/embedded-data.cc        |   38 +-
 src/snapshot/embedded/embedded-data.h         |    4 +-
 src/snapshot/embedded/embedded-file-writer.cc |    8 +-
 src/snapshot/embedded/embedded-file-writer.h  |    8 +-
 .../platform-embedded-file-writer-win.cc      |    4 +-
 src/snapshot/serializer.cc                    |    4 +-
 src/snapshot/startup-serializer.cc            |   14 +-
 src/torque/csa-generator.cc                   |    6 +-
 src/utils/memcopy.cc                          |    6 +-
 src/wasm/function-compiler.cc                 |    2 +-
 src/wasm/wasm-code-manager.cc                 |   14 +-
 src/wasm/wasm-code-manager.h                  |    2 +-
 src/wasm/wasm-js.cc                           |    2 +-
 src/wasm/wasm-objects.cc                      |   11 +-
 src/web-snapshot/web-snapshot.cc              |    2 +-
 test/cctest/compiler/code-assembler-tester.h  |    4 +-
 test/cctest/compiler/test-code-generator.cc   |    2 +-
 test/cctest/compiler/test-linkage.cc          |    4 +-
 test/cctest/heap/test-alloc.cc                |    4 +-
 test/cctest/interpreter/test-interpreter.cc   |    8 +-
 test/cctest/test-api.cc                       |    6 +-
 test/cctest/test-assembler-ia32.cc            |    4 +-
 test/cctest/test-code-stub-assembler.cc       |   22 +-
 test/cctest/test-debug.cc                     |    2 +-
 test/cctest/test-feedback-vector.h            |    2 +-
 test/cctest/test-field-type-tracking.cc       |    4 +-
 test/cctest/test-log.cc                       |    2 +-
 test/cctest/test-macro-assembler-arm.cc       |    4 +-
 test/cctest/test-macro-assembler-arm64.cc     |    4 +-
 test/cctest/test-macro-assembler-mips.cc      |    4 +-
 test/cctest/test-macro-assembler-mips64.cc    |    4 +-
 test/cctest/test-macro-assembler-riscv64.cc   |    4 +-
 test/cctest/test-macro-assembler-x64.cc       |    4 +-
 test/cctest/test-swiss-name-dictionary-csa.cc |    6 +-
 test/cctest/test-unwinder-code-pages.cc       |    8 +-
 test/cctest/wasm/test-run-wasm-wrappers.cc    |    2 +-
 .../backend/instruction-selector-unittest.cc  |    4 +-
 .../compiler/js-call-reducer-unittest.cc      |    2 +-
 .../redundancy-elimination-unittest.cc        |    2 +-
 test/unittests/test-helpers.cc                |    2 +-
 194 files changed, 2868 insertions(+), 2955 deletions(-)

diff --git a/src/api/api.cc b/src/api/api.cc
index c6cd830d70c..02c8ca3d9da 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -6116,7 +6116,7 @@ Local<Context> NewContext(
   // TODO(jkummerow): This is for crbug.com/713699. Remove it if it doesn't
   // fail.
   // Sanity-check that the isolate is initialized and usable.
-  CHECK(isolate->builtins()->builtin(i::Builtins::kIllegal).IsCode());
+  CHECK(isolate->builtins()->builtin(i::Builtin::kIllegal).IsCode());
 
   TRACE_EVENT_CALL_STATS_SCOPED(isolate, "v8", "V8.NewContext");
   LOG_API(isolate, Context, New);
@@ -8964,10 +8964,10 @@ JSEntryStubs Isolate::GetJSEntryStubs() {
   JSEntryStubs entry_stubs;
 
   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
-  std::array<std::pair<i::Builtins::Name, JSEntryStub*>, 3> stubs = {
-      {{i::Builtins::kJSEntry, &entry_stubs.js_entry_stub},
-       {i::Builtins::kJSConstructEntry, &entry_stubs.js_construct_entry_stub},
-       {i::Builtins::kJSRunMicrotasksEntry,
+  std::array<std::pair<i::Builtin, JSEntryStub*>, 3> stubs = {
+      {{i::Builtin::kJSEntry, &entry_stubs.js_entry_stub},
+       {i::Builtin::kJSConstructEntry, &entry_stubs.js_construct_entry_stub},
+       {i::Builtin::kJSRunMicrotasksEntry,
         &entry_stubs.js_run_microtasks_entry_stub}}};
   for (auto& pair : stubs) {
     i::Code js_entry = isolate->heap()->builtin(pair.first);
diff --git a/src/asmjs/asm-js.cc b/src/asmjs/asm-js.cc
index 0e0d9ad6c9d..4ee94c05f2d 100644
--- a/src/asmjs/asm-js.cc
+++ b/src/asmjs/asm-js.cc
@@ -74,11 +74,11 @@ bool AreStdlibMembersValid(Isolate* isolate, Handle<JSReceiver> stdlib,
     if (!value->IsJSFunction()) return false;                              \
     SharedFunctionInfo shared = Handle<JSFunction>::cast(value)->shared(); \
     if (!shared.HasBuiltinId() ||                                          \
-        shared.builtin_id() != Builtins::kMath##FName) {                   \
+        shared.builtin_id() != Builtin::kMath##FName) {                    \
       return false;                                                        \
     }                                                                      \
     DCHECK_EQ(shared.GetCode(),                                            \
-              isolate->builtins()->builtin(Builtins::kMath##FName));       \
+              isolate->builtins()->builtin(Builtin::kMath##FName));        \
   }
   STDLIB_MATH_FUNCTION_LIST(STDLIB_MATH_FUNC)
 #undef STDLIB_MATH_FUNC
diff --git a/src/baseline/arm/baseline-assembler-arm-inl.h b/src/baseline/arm/baseline-assembler-arm-inl.h
index bfccef90f8f..9672bae5fef 100644
--- a/src/baseline/arm/baseline-assembler-arm-inl.h
+++ b/src/baseline/arm/baseline-assembler-arm-inl.h
@@ -117,21 +117,21 @@ void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,
   __ JumpIfNotSmi(value, target);
 }
 
-void BaselineAssembler::CallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::CallBuiltin(Builtin builtin) {
   //  __ CallBuiltin(static_cast<int>(builtin));
   __ RecordCommentForOffHeapTrampoline(builtin);
   ScratchRegisterScope temps(this);
   Register temp = temps.AcquireScratch();
-  __ LoadEntryFromBuiltinIndex(builtin, temp);
+  __ LoadEntryFromBuiltin(builtin, temp);
   __ Call(temp);
   __ RecordComment("]");
 }
 
-void BaselineAssembler::TailCallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::TailCallBuiltin(Builtin builtin) {
   __ RecordCommentForOffHeapTrampoline(builtin);
   ScratchRegisterScope temps(this);
   Register temp = temps.AcquireScratch();
-  __ LoadEntryFromBuiltinIndex(builtin, temp);
+  __ LoadEntryFromBuiltin(builtin, temp);
   __ Jump(temp);
   __ RecordComment("]");
 }
diff --git a/src/baseline/arm/baseline-compiler-arm-inl.h b/src/baseline/arm/baseline-compiler-arm-inl.h
index 3d97d888999..cc15aed398d 100644
--- a/src/baseline/arm/baseline-compiler-arm-inl.h
+++ b/src/baseline/arm/baseline-compiler-arm-inl.h
@@ -19,7 +19,7 @@ void BaselineCompiler::Prologue() {
   __ masm()->EnterFrame(StackFrame::BASELINE);
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+  CallBuiltin<Builtin::kBaselineOutOfLinePrologue>(
       kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
       max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
diff --git a/src/baseline/arm64/baseline-assembler-arm64-inl.h b/src/baseline/arm64/baseline-assembler-arm64-inl.h
index 63e90df4d62..7310e33f65e 100644
--- a/src/baseline/arm64/baseline-assembler-arm64-inl.h
+++ b/src/baseline/arm64/baseline-assembler-arm64-inl.h
@@ -115,19 +115,19 @@ void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,
   __ JumpIfNotSmi(value, target);
 }
 
-void BaselineAssembler::CallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::CallBuiltin(Builtin builtin) {
   if (masm()->options().short_builtin_calls) {
     // Generate pc-relative call.
     __ CallBuiltin(builtin);
   } else {
     ScratchRegisterScope temps(this);
     Register temp = temps.AcquireScratch();
-    __ LoadEntryFromBuiltinIndex(builtin, temp);
+    __ LoadEntryFromBuiltin(builtin, temp);
     __ Call(temp);
   }
 }
 
-void BaselineAssembler::TailCallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::TailCallBuiltin(Builtin builtin) {
   if (masm()->options().short_builtin_calls) {
     // Generate pc-relative call.
     __ TailCallBuiltin(builtin);
@@ -147,7 +147,7 @@ void BaselineAssembler::TailCallBuiltin(Builtins::Name builtin) {
     UseScratchRegisterScope temps(masm());
     temps.Exclude(temp);
 
-    __ LoadEntryFromBuiltinIndex(builtin, temp);
+    __ LoadEntryFromBuiltin(builtin, temp);
     __ Jump(temp);
   }
 }
diff --git a/src/baseline/arm64/baseline-compiler-arm64-inl.h b/src/baseline/arm64/baseline-compiler-arm64-inl.h
index ec245b072b2..13988f9a299 100644
--- a/src/baseline/arm64/baseline-compiler-arm64-inl.h
+++ b/src/baseline/arm64/baseline-compiler-arm64-inl.h
@@ -18,7 +18,7 @@ void BaselineCompiler::Prologue() {
   __ masm()->EnterFrame(StackFrame::BASELINE);
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+  CallBuiltin<Builtin::kBaselineOutOfLinePrologue>(
       kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
       max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
diff --git a/src/baseline/baseline-assembler.h b/src/baseline/baseline-assembler.h
index 7c46cd5e2c4..54070eb264c 100644
--- a/src/baseline/baseline-assembler.h
+++ b/src/baseline/baseline-assembler.h
@@ -126,8 +126,8 @@ class BaselineAssembler {
   template <typename... T>
   inline void Pop(T... registers);
 
-  inline void CallBuiltin(Builtins::Name builtin);
-  inline void TailCallBuiltin(Builtins::Name builtin);
+  inline void CallBuiltin(Builtin builtin);
+  inline void TailCallBuiltin(Builtin builtin);
   inline void CallRuntime(Runtime::FunctionId function, int nargs);
 
   inline void LoadTaggedPointerField(Register output, Register source,
diff --git a/src/baseline/baseline-compiler.cc b/src/baseline/baseline-compiler.cc
index b4ded4490c5..f34d8f98acd 100644
--- a/src/baseline/baseline-compiler.cc
+++ b/src/baseline/baseline-compiler.cc
@@ -217,7 +217,7 @@ struct ArgumentSettingHelper<Descriptor, ArgIndex, false, Arg, Args...> {
   }
 };
 
-template <Builtins::Name kBuiltin, typename... Args>
+template <Builtin kBuiltin, typename... Args>
 void MoveArgumentsForBuiltin(BaselineAssembler* masm, Args... args) {
   using Descriptor = typename CallInterfaceDescriptorFor<kBuiltin>::type;
   CheckArgs<Descriptor>(masm, args...);
@@ -585,7 +585,7 @@ Label* BaselineCompiler::BuildForwardJumpLabel() {
   return &threaded_label->label;
 }
 
-template <Builtins::Name kBuiltin, typename... Args>
+template <Builtin kBuiltin, typename... Args>
 void BaselineCompiler::CallBuiltin(Args... args) {
   __ RecordComment("[ CallBuiltin");
   detail::MoveArgumentsForBuiltin<kBuiltin>(&basm_, args...);
@@ -593,7 +593,7 @@ void BaselineCompiler::CallBuiltin(Args... args) {
   __ RecordComment("]");
 }
 
-template <Builtins::Name kBuiltin, typename... Args>
+template <Builtin kBuiltin, typename... Args>
 void BaselineCompiler::TailCallBuiltin(Args... args) {
   detail::MoveArgumentsForBuiltin<kBuiltin>(&basm_, args...);
   __ TailCallBuiltin(kBuiltin);
@@ -609,7 +609,7 @@ void BaselineCompiler::CallRuntime(Runtime::FunctionId function, Args... args) {
 // Returns into kInterpreterAccumulatorRegister
 void BaselineCompiler::JumpIfToBoolean(bool do_jump_if_true, Label* label,
                                        Label::Distance distance) {
-  CallBuiltin<Builtins::kToBooleanForBaselineJump>(
+  CallBuiltin<Builtin::kToBooleanForBaselineJump>(
       kInterpreterAccumulatorRegister);
   // ToBooleanForBaselineJump returns the ToBoolean value into return reg 1, and
   // the original value into kInterpreterAccumulatorRegister, so we don't have
@@ -654,18 +654,18 @@ void BaselineCompiler::VisitLdaConstant() {
 }
 
 void BaselineCompiler::VisitLdaGlobal() {
-  CallBuiltin<Builtins::kLoadGlobalICBaseline>(Constant<Name>(0),  // name
-                                               IndexAsTagged(1));  // slot
+  CallBuiltin<Builtin::kLoadGlobalICBaseline>(Constant<Name>(0),  // name
+                                              IndexAsTagged(1));  // slot
 }
 
 void BaselineCompiler::VisitLdaGlobalInsideTypeof() {
-  CallBuiltin<Builtins::kLoadGlobalICInsideTypeofBaseline>(
+  CallBuiltin<Builtin::kLoadGlobalICInsideTypeofBaseline>(
       Constant<Name>(0),  // name
       IndexAsTagged(1));  // slot
 }
 
 void BaselineCompiler::VisitStaGlobal() {
-  CallBuiltin<Builtins::kStoreGlobalICBaseline>(
+  CallBuiltin<Builtin::kStoreGlobalICBaseline>(
       Constant<Name>(0),                // name
       kInterpreterAccumulatorRegister,  // value
       IndexAsTagged(1));                // slot
@@ -742,12 +742,12 @@ void BaselineCompiler::VisitLdaLookupSlot() {
 }
 
 void BaselineCompiler::VisitLdaLookupContextSlot() {
-  CallBuiltin<Builtins::kLookupContextBaseline>(
+  CallBuiltin<Builtin::kLookupContextBaseline>(
       Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupGlobalSlot() {
-  CallBuiltin<Builtins::kLookupGlobalICBaseline>(
+  CallBuiltin<Builtin::kLookupGlobalICBaseline>(
       Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
@@ -756,12 +756,12 @@ void BaselineCompiler::VisitLdaLookupSlotInsideTypeof() {
 }
 
 void BaselineCompiler::VisitLdaLookupContextSlotInsideTypeof() {
-  CallBuiltin<Builtins::kLookupContextInsideTypeofBaseline>(
+  CallBuiltin<Builtin::kLookupContextInsideTypeofBaseline>(
       Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupGlobalSlotInsideTypeof() {
-  CallBuiltin<Builtins::kLookupGlobalICInsideTypeofBaseline>(
+  CallBuiltin<Builtin::kLookupGlobalICInsideTypeofBaseline>(
       Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
@@ -805,9 +805,9 @@ void BaselineCompiler::VisitMov() {
 }
 
 void BaselineCompiler::VisitLdaNamedProperty() {
-  CallBuiltin<Builtins::kLoadICBaseline>(RegisterOperand(0),  // object
-                                         Constant<Name>(1),   // name
-                                         IndexAsTagged(2));   // slot
+  CallBuiltin<Builtin::kLoadICBaseline>(RegisterOperand(0),  // object
+                                        Constant<Name>(1),   // name
+                                        IndexAsTagged(2));   // slot
 }
 
 void BaselineCompiler::VisitLdaNamedPropertyFromSuper() {
@@ -815,7 +815,7 @@ void BaselineCompiler::VisitLdaNamedPropertyFromSuper() {
       LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister(),
       kInterpreterAccumulatorRegister);
 
-  CallBuiltin<Builtins::kLoadSuperICBaseline>(
+  CallBuiltin<Builtin::kLoadSuperICBaseline>(
       RegisterOperand(0),  // object
       LoadWithReceiverAndVectorDescriptor::
           LookupStartObjectRegister(),  // lookup start
@@ -824,7 +824,7 @@ void BaselineCompiler::VisitLdaNamedPropertyFromSuper() {
 }
 
 void BaselineCompiler::VisitLdaKeyedProperty() {
-  CallBuiltin<Builtins::kKeyedLoadICBaseline>(
+  CallBuiltin<Builtin::kKeyedLoadICBaseline>(
       RegisterOperand(0),               // object
       kInterpreterAccumulatorRegister,  // key
       IndexAsTagged(1));                // slot
@@ -885,7 +885,7 @@ void BaselineCompiler::VisitStaModuleVariable() {
 }
 
 void BaselineCompiler::VisitStaNamedProperty() {
-  CallBuiltin<Builtins::kStoreICBaseline>(
+  CallBuiltin<Builtin::kStoreICBaseline>(
       RegisterOperand(0),               // object
       Constant<Name>(1),                // name
       kInterpreterAccumulatorRegister,  // value
@@ -900,7 +900,7 @@ void BaselineCompiler::VisitStaNamedOwnProperty() {
 }
 
 void BaselineCompiler::VisitStaKeyedProperty() {
-  CallBuiltin<Builtins::kKeyedStoreICBaseline>(
+  CallBuiltin<Builtin::kKeyedStoreICBaseline>(
       RegisterOperand(0),               // object
       RegisterOperand(1),               // key
       kInterpreterAccumulatorRegister,  // value
@@ -908,7 +908,7 @@ void BaselineCompiler::VisitStaKeyedProperty() {
 }
 
 void BaselineCompiler::VisitStaInArrayLiteral() {
-  CallBuiltin<Builtins::kStoreInArrayLiteralICBaseline>(
+  CallBuiltin<Builtin::kStoreInArrayLiteralICBaseline>(
       RegisterOperand(0),               // object
       RegisterOperand(1),               // name
       kInterpreterAccumulatorRegister,  // value
@@ -934,143 +934,143 @@ void BaselineCompiler::VisitCollectTypeProfile() {
 }
 
 void BaselineCompiler::VisitAdd() {
-  CallBuiltin<Builtins::kAdd_Baseline>(
+  CallBuiltin<Builtin::kAdd_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitSub() {
-  CallBuiltin<Builtins::kSubtract_Baseline>(
+  CallBuiltin<Builtin::kSubtract_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitMul() {
-  CallBuiltin<Builtins::kMultiply_Baseline>(
+  CallBuiltin<Builtin::kMultiply_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitDiv() {
-  CallBuiltin<Builtins::kDivide_Baseline>(
+  CallBuiltin<Builtin::kDivide_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitMod() {
-  CallBuiltin<Builtins::kModulus_Baseline>(
+  CallBuiltin<Builtin::kModulus_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitExp() {
-  CallBuiltin<Builtins::kExponentiate_Baseline>(
+  CallBuiltin<Builtin::kExponentiate_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseOr() {
-  CallBuiltin<Builtins::kBitwiseOr_Baseline>(
+  CallBuiltin<Builtin::kBitwiseOr_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseXor() {
-  CallBuiltin<Builtins::kBitwiseXor_Baseline>(
+  CallBuiltin<Builtin::kBitwiseXor_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseAnd() {
-  CallBuiltin<Builtins::kBitwiseAnd_Baseline>(
+  CallBuiltin<Builtin::kBitwiseAnd_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftLeft() {
-  CallBuiltin<Builtins::kShiftLeft_Baseline>(
+  CallBuiltin<Builtin::kShiftLeft_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftRight() {
-  CallBuiltin<Builtins::kShiftRight_Baseline>(
+  CallBuiltin<Builtin::kShiftRight_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftRightLogical() {
-  CallBuiltin<Builtins::kShiftRightLogical_Baseline>(
+  CallBuiltin<Builtin::kShiftRightLogical_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitAddSmi() {
-  CallBuiltin<Builtins::kAdd_Baseline>(kInterpreterAccumulatorRegister,
-                                       IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kAdd_Baseline>(kInterpreterAccumulatorRegister,
+                                      IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitSubSmi() {
-  CallBuiltin<Builtins::kSubtract_Baseline>(kInterpreterAccumulatorRegister,
-                                            IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kSubtract_Baseline>(kInterpreterAccumulatorRegister,
+                                           IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitMulSmi() {
-  CallBuiltin<Builtins::kMultiply_Baseline>(kInterpreterAccumulatorRegister,
-                                            IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kMultiply_Baseline>(kInterpreterAccumulatorRegister,
+                                           IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitDivSmi() {
-  CallBuiltin<Builtins::kDivide_Baseline>(kInterpreterAccumulatorRegister,
-                                          IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kDivide_Baseline>(kInterpreterAccumulatorRegister,
+                                         IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitModSmi() {
-  CallBuiltin<Builtins::kModulus_Baseline>(kInterpreterAccumulatorRegister,
-                                           IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kModulus_Baseline>(kInterpreterAccumulatorRegister,
+                                          IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitExpSmi() {
-  CallBuiltin<Builtins::kExponentiate_Baseline>(kInterpreterAccumulatorRegister,
-                                                IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kExponentiate_Baseline>(kInterpreterAccumulatorRegister,
+                                               IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseOrSmi() {
-  CallBuiltin<Builtins::kBitwiseOr_Baseline>(kInterpreterAccumulatorRegister,
-                                             IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kBitwiseOr_Baseline>(kInterpreterAccumulatorRegister,
+                                            IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseXorSmi() {
-  CallBuiltin<Builtins::kBitwiseXor_Baseline>(kInterpreterAccumulatorRegister,
-                                              IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kBitwiseXor_Baseline>(kInterpreterAccumulatorRegister,
+                                             IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseAndSmi() {
-  CallBuiltin<Builtins::kBitwiseAnd_Baseline>(kInterpreterAccumulatorRegister,
-                                              IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kBitwiseAnd_Baseline>(kInterpreterAccumulatorRegister,
+                                             IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitShiftLeftSmi() {
-  CallBuiltin<Builtins::kShiftLeft_Baseline>(kInterpreterAccumulatorRegister,
-                                             IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kShiftLeft_Baseline>(kInterpreterAccumulatorRegister,
+                                            IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitShiftRightSmi() {
-  CallBuiltin<Builtins::kShiftRight_Baseline>(kInterpreterAccumulatorRegister,
-                                              IntAsSmi(0), Index(1));
+  CallBuiltin<Builtin::kShiftRight_Baseline>(kInterpreterAccumulatorRegister,
+                                             IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitShiftRightLogicalSmi() {
-  CallBuiltin<Builtins::kShiftRightLogical_Baseline>(
+  CallBuiltin<Builtin::kShiftRightLogical_Baseline>(
       kInterpreterAccumulatorRegister, IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitInc() {
-  CallBuiltin<Builtins::kIncrement_Baseline>(kInterpreterAccumulatorRegister,
-                                             Index(0));
+  CallBuiltin<Builtin::kIncrement_Baseline>(kInterpreterAccumulatorRegister,
+                                            Index(0));
 }
 
 void BaselineCompiler::VisitDec() {
-  CallBuiltin<Builtins::kDecrement_Baseline>(kInterpreterAccumulatorRegister,
-                                             Index(0));
+  CallBuiltin<Builtin::kDecrement_Baseline>(kInterpreterAccumulatorRegister,
+                                            Index(0));
 }
 
 void BaselineCompiler::VisitNegate() {
-  CallBuiltin<Builtins::kNegate_Baseline>(kInterpreterAccumulatorRegister,
-                                          Index(0));
+  CallBuiltin<Builtin::kNegate_Baseline>(kInterpreterAccumulatorRegister,
+                                         Index(0));
 }
 
 void BaselineCompiler::VisitBitwiseNot() {
-  CallBuiltin<Builtins::kBitwiseNot_Baseline>(kInterpreterAccumulatorRegister,
-                                              Index(0));
+  CallBuiltin<Builtin::kBitwiseNot_Baseline>(kInterpreterAccumulatorRegister,
+                                             Index(0));
 }
 
 void BaselineCompiler::VisitToBooleanLogicalNot() {
@@ -1090,23 +1090,23 @@ void BaselineCompiler::VisitLogicalNot() {
 }
 
 void BaselineCompiler::VisitTypeOf() {
-  CallBuiltin<Builtins::kTypeof>(kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtin::kTypeof>(kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitDeletePropertyStrict() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register scratch = scratch_scope.AcquireScratch();
   __ Move(scratch, kInterpreterAccumulatorRegister);
-  CallBuiltin<Builtins::kDeleteProperty>(RegisterOperand(0), scratch,
-                                         Smi::FromEnum(LanguageMode::kStrict));
+  CallBuiltin<Builtin::kDeleteProperty>(RegisterOperand(0), scratch,
+                                        Smi::FromEnum(LanguageMode::kStrict));
 }
 
 void BaselineCompiler::VisitDeletePropertySloppy() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register scratch = scratch_scope.AcquireScratch();
   __ Move(scratch, kInterpreterAccumulatorRegister);
-  CallBuiltin<Builtins::kDeleteProperty>(RegisterOperand(0), scratch,
-                                         Smi::FromEnum(LanguageMode::kSloppy));
+  CallBuiltin<Builtin::kDeleteProperty>(RegisterOperand(0), scratch,
+                                        Smi::FromEnum(LanguageMode::kSloppy));
 }
 
 void BaselineCompiler::VisitGetSuperConstructor() {
@@ -1117,31 +1117,30 @@ void BaselineCompiler::VisitGetSuperConstructor() {
 }
 
 namespace {
-constexpr Builtins::Name ConvertReceiverModeToCompactBuiltin(
+constexpr Builtin ConvertReceiverModeToCompactBuiltin(
     ConvertReceiverMode mode) {
   switch (mode) {
     case ConvertReceiverMode::kAny:
-      return Builtins::kCall_ReceiverIsAny_Baseline_Compact;
+      return Builtin::kCall_ReceiverIsAny_Baseline_Compact;
       break;
     case ConvertReceiverMode::kNullOrUndefined:
-      return Builtins::kCall_ReceiverIsNullOrUndefined_Baseline_Compact;
+      return Builtin::kCall_ReceiverIsNullOrUndefined_Baseline_Compact;
       break;
     case ConvertReceiverMode::kNotNullOrUndefined:
-      return Builtins::kCall_ReceiverIsNotNullOrUndefined_Baseline_Compact;
+      return Builtin::kCall_ReceiverIsNotNullOrUndefined_Baseline_Compact;
       break;
   }
 }
-constexpr Builtins::Name ConvertReceiverModeToBuiltin(
-    ConvertReceiverMode mode) {
+constexpr Builtin ConvertReceiverModeToBuiltin(ConvertReceiverMode mode) {
   switch (mode) {
     case ConvertReceiverMode::kAny:
-      return Builtins::kCall_ReceiverIsAny_Baseline;
+      return Builtin::kCall_ReceiverIsAny_Baseline;
       break;
     case ConvertReceiverMode::kNullOrUndefined:
-      return Builtins::kCall_ReceiverIsNullOrUndefined_Baseline;
+      return Builtin::kCall_ReceiverIsNullOrUndefined_Baseline;
       break;
     case ConvertReceiverMode::kNotNullOrUndefined:
-      return Builtins::kCall_ReceiverIsNotNullOrUndefined_Baseline;
+      return Builtin::kCall_ReceiverIsNotNullOrUndefined_Baseline;
       break;
   }
 }
@@ -1226,7 +1225,7 @@ void BaselineCompiler::VisitCallWithSpread() {
 
   uint32_t arg_count = args.register_count() - 1;  // Remove receiver.
 
-  CallBuiltin<Builtins::kCallWithSpread_Baseline>(
+  CallBuiltin<Builtin::kCallWithSpread_Baseline>(
       RegisterOperand(0),  // kFunction
       arg_count,           // kActualArgumentsCount
       spread_register,     // kSpread
@@ -1254,7 +1253,7 @@ void BaselineCompiler::VisitCallJSRuntime() {
   __ LoadContext(kContextRegister);
   __ LoadNativeContextSlot(kJavaScriptCallTargetRegister,
                            iterator().GetNativeContextIndexOperand(0));
-  CallBuiltin<Builtins::kCall_ReceiverIsNullOrUndefined>(
+  CallBuiltin<Builtin::kCall_ReceiverIsNullOrUndefined>(
       kJavaScriptCallTargetRegister,  // kFunction
       arg_count,                      // kActualArgumentsCount
       RootIndex::kUndefinedValue,     // kReceiver
@@ -1329,25 +1328,25 @@ void BaselineCompiler::VisitIntrinsicIsSmi(interpreter::RegisterList args) {
 
 void BaselineCompiler::VisitIntrinsicCopyDataProperties(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCopyDataProperties>(args);
+  CallBuiltin<Builtin::kCopyDataProperties>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateIterResultObject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCreateIterResultObject>(args);
+  CallBuiltin<Builtin::kCreateIterResultObject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicHasProperty(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kHasProperty>(args);
+  CallBuiltin<Builtin::kHasProperty>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicToLength(interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kToLength>(args);
+  CallBuiltin<Builtin::kToLength>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicToObject(interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kToObject>(args);
+  CallBuiltin<Builtin::kToObject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicCall(interpreter::RegisterList args) {
@@ -1359,7 +1358,7 @@ void BaselineCompiler::VisitIntrinsicCall(interpreter::RegisterList args) {
   args = args.PopLeft();
 
   uint32_t arg_count = args.register_count();
-  CallBuiltin<Builtins::kCall_ReceiverIsAny>(
+  CallBuiltin<Builtin::kCall_ReceiverIsAny>(
       kJavaScriptCallTargetRegister,  // kFunction
       arg_count - 1,                  // kActualArgumentsCount
       args);
@@ -1367,12 +1366,12 @@ void BaselineCompiler::VisitIntrinsicCall(interpreter::RegisterList args) {
 
 void BaselineCompiler::VisitIntrinsicCreateAsyncFromSyncIterator(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCreateAsyncFromSyncIteratorBaseline>(args[0]);
+  CallBuiltin<Builtin::kCreateAsyncFromSyncIteratorBaseline>(args[0]);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateJSGeneratorObject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCreateGeneratorObject>(args);
+  CallBuiltin<Builtin::kCreateGeneratorObject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicGeneratorGetResumeMode(
@@ -1394,63 +1393,63 @@ void BaselineCompiler::VisitIntrinsicGeneratorClose(
 
 void BaselineCompiler::VisitIntrinsicGetImportMetaObject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kGetImportMetaObjectBaseline>();
+  CallBuiltin<Builtin::kGetImportMetaObjectBaseline>();
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionAwaitCaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionAwaitCaught>(args);
+  CallBuiltin<Builtin::kAsyncFunctionAwaitCaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionAwaitUncaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionAwaitUncaught>(args);
+  CallBuiltin<Builtin::kAsyncFunctionAwaitUncaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionEnter(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionEnter>(args);
+  CallBuiltin<Builtin::kAsyncFunctionEnter>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionReject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionReject>(args);
+  CallBuiltin<Builtin::kAsyncFunctionReject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionResolve(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionResolve>(args);
+  CallBuiltin<Builtin::kAsyncFunctionResolve>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorAwaitCaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorAwaitCaught>(args);
+  CallBuiltin<Builtin::kAsyncGeneratorAwaitCaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorAwaitUncaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorAwaitUncaught>(args);
+  CallBuiltin<Builtin::kAsyncGeneratorAwaitUncaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorReject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorReject>(args);
+  CallBuiltin<Builtin::kAsyncGeneratorReject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorResolve(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorResolve>(args);
+  CallBuiltin<Builtin::kAsyncGeneratorResolve>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorYield(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorYield>(args);
+  CallBuiltin<Builtin::kAsyncGeneratorYield>(args);
 }
 
 void BaselineCompiler::VisitConstruct() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count();
-  CallBuiltin<Builtins::kConstruct_Baseline>(
+  CallBuiltin<Builtin::kConstruct_Baseline>(
       RegisterOperand(0),               // kFunction
       kInterpreterAccumulatorRegister,  // kNewTarget
       arg_count,                        // kActualArgumentsCount
@@ -1469,12 +1468,12 @@ void BaselineCompiler::VisitConstructWithSpread() {
   uint32_t arg_count = args.register_count();
 
   using Descriptor =
-      CallInterfaceDescriptorFor<Builtins::kConstructWithSpread_Baseline>::type;
+      CallInterfaceDescriptorFor<Builtin::kConstructWithSpread_Baseline>::type;
   Register new_target =
       Descriptor::GetRegisterParameter(Descriptor::kNewTarget);
   __ Move(new_target, kInterpreterAccumulatorRegister);
 
-  CallBuiltin<Builtins::kConstructWithSpread_Baseline>(
+  CallBuiltin<Builtin::kConstructWithSpread_Baseline>(
       RegisterOperand(0),          // kFunction
       new_target,                  // kNewTarget
       arg_count,                   // kActualArgumentsCount
@@ -1485,32 +1484,32 @@ void BaselineCompiler::VisitConstructWithSpread() {
 }
 
 void BaselineCompiler::VisitTestEqual() {
-  CallBuiltin<Builtins::kEqual_Baseline>(
+  CallBuiltin<Builtin::kEqual_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestEqualStrict() {
-  CallBuiltin<Builtins::kStrictEqual_Baseline>(
+  CallBuiltin<Builtin::kStrictEqual_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestLessThan() {
-  CallBuiltin<Builtins::kLessThan_Baseline>(
+  CallBuiltin<Builtin::kLessThan_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestGreaterThan() {
-  CallBuiltin<Builtins::kGreaterThan_Baseline>(
+  CallBuiltin<Builtin::kGreaterThan_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestLessThanOrEqual() {
-  CallBuiltin<Builtins::kLessThanOrEqual_Baseline>(
+  CallBuiltin<Builtin::kLessThanOrEqual_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestGreaterThanOrEqual() {
-  CallBuiltin<Builtins::kGreaterThanOrEqual_Baseline>(
+  CallBuiltin<Builtin::kGreaterThanOrEqual_Baseline>(
       RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
@@ -1526,17 +1525,17 @@ void BaselineCompiler::VisitTestReferenceEqual() {
 
 void BaselineCompiler::VisitTestInstanceOf() {
   using Descriptor =
-      CallInterfaceDescriptorFor<Builtins::kInstanceOf_Baseline>::type;
+      CallInterfaceDescriptorFor<Builtin::kInstanceOf_Baseline>::type;
   Register callable = Descriptor::GetRegisterParameter(Descriptor::kRight);
   __ Move(callable, kInterpreterAccumulatorRegister);
 
-  CallBuiltin<Builtins::kInstanceOf_Baseline>(RegisterOperand(0),  // object
-                                              callable,            // callable
-                                              Index(1));           // slot
+  CallBuiltin<Builtin::kInstanceOf_Baseline>(RegisterOperand(0),  // object
+                                             callable,            // callable
+                                             Index(1));           // slot
 }
 
 void BaselineCompiler::VisitTestIn() {
-  CallBuiltin<Builtins::kKeyedHasICBaseline>(
+  CallBuiltin<Builtin::kKeyedHasICBaseline>(
       kInterpreterAccumulatorRegister,  // object
       RegisterOperand(0),               // name
       IndexAsTagged(1));                // slot
@@ -1750,32 +1749,32 @@ void BaselineCompiler::VisitTestTypeOf() {
 
 void BaselineCompiler::VisitToName() {
   SaveAccumulatorScope save_accumulator(&basm_);
-  CallBuiltin<Builtins::kToName>(kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtin::kToName>(kInterpreterAccumulatorRegister);
   StoreRegister(0, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitToNumber() {
-  CallBuiltin<Builtins::kToNumber_Baseline>(kInterpreterAccumulatorRegister,
-                                            Index(0));
+  CallBuiltin<Builtin::kToNumber_Baseline>(kInterpreterAccumulatorRegister,
+                                           Index(0));
 }
 
 void BaselineCompiler::VisitToNumeric() {
-  CallBuiltin<Builtins::kToNumeric_Baseline>(kInterpreterAccumulatorRegister,
-                                             Index(0));
+  CallBuiltin<Builtin::kToNumeric_Baseline>(kInterpreterAccumulatorRegister,
+                                            Index(0));
 }
 
 void BaselineCompiler::VisitToObject() {
   SaveAccumulatorScope save_accumulator(&basm_);
-  CallBuiltin<Builtins::kToObject>(kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtin::kToObject>(kInterpreterAccumulatorRegister);
   StoreRegister(0, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitToString() {
-  CallBuiltin<Builtins::kToString>(kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtin::kToString>(kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitCreateRegExpLiteral() {
-  CallBuiltin<Builtins::kCreateRegExpLiteral>(
+  CallBuiltin<Builtin::kCreateRegExpLiteral>(
       FeedbackVector(),         // feedback vector
       IndexAsTagged(1),         // slot
       Constant<HeapObject>(0),  // pattern
@@ -1788,7 +1787,7 @@ void BaselineCompiler::VisitCreateArrayLiteral() {
       interpreter::CreateArrayLiteralFlags::FlagsBits::decode(flags));
   if (flags &
       interpreter::CreateArrayLiteralFlags::FastCloneSupportedBit::kMask) {
-    CallBuiltin<Builtins::kCreateShallowArrayLiteral>(
+    CallBuiltin<Builtin::kCreateShallowArrayLiteral>(
         FeedbackVector(),          // feedback vector
         IndexAsTagged(1),          // slot
         Constant<HeapObject>(0),   // constant elements
@@ -1803,13 +1802,13 @@ void BaselineCompiler::VisitCreateArrayLiteral() {
 }
 
 void BaselineCompiler::VisitCreateArrayFromIterable() {
-  CallBuiltin<Builtins::kIterableToListWithSymbolLookup>(
+  CallBuiltin<Builtin::kIterableToListWithSymbolLookup>(
       kInterpreterAccumulatorRegister);  // iterable
 }
 
 void BaselineCompiler::VisitCreateEmptyArrayLiteral() {
-  CallBuiltin<Builtins::kCreateEmptyArrayLiteral>(FeedbackVector(),
-                                                  IndexAsTagged(0));
+  CallBuiltin<Builtin::kCreateEmptyArrayLiteral>(FeedbackVector(),
+                                                 IndexAsTagged(0));
 }
 
 void BaselineCompiler::VisitCreateObjectLiteral() {
@@ -1818,7 +1817,7 @@ void BaselineCompiler::VisitCreateObjectLiteral() {
       interpreter::CreateObjectLiteralFlags::FlagsBits::decode(flags));
   if (flags &
       interpreter::CreateObjectLiteralFlags::FastCloneSupportedBit::kMask) {
-    CallBuiltin<Builtins::kCreateShallowObjectLiteral>(
+    CallBuiltin<Builtin::kCreateShallowObjectLiteral>(
         FeedbackVector(),                           // feedback vector
         IndexAsTagged(1),                           // slot
         Constant<ObjectBoilerplateDescription>(0),  // boilerplate
@@ -1833,14 +1832,14 @@ void BaselineCompiler::VisitCreateObjectLiteral() {
 }
 
 void BaselineCompiler::VisitCreateEmptyObjectLiteral() {
-  CallBuiltin<Builtins::kCreateEmptyLiteralObject>();
+  CallBuiltin<Builtin::kCreateEmptyLiteralObject>();
 }
 
 void BaselineCompiler::VisitCloneObject() {
   uint32_t flags = Flag(1);
   int32_t raw_flags =
       interpreter::CreateObjectLiteralFlags::FlagsBits::decode(flags);
-  CallBuiltin<Builtins::kCloneObjectICBaseline>(
+  CallBuiltin<Builtin::kCloneObjectICBaseline>(
       RegisterOperand(0),       // source
       Smi::FromInt(raw_flags),  // flags
       IndexAsTagged(2));        // slot
@@ -1848,7 +1847,7 @@ void BaselineCompiler::VisitCloneObject() {
 
 void BaselineCompiler::VisitGetTemplateObject() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
-  CallBuiltin<Builtins::kGetTemplateObject>(
+  CallBuiltin<Builtin::kGetTemplateObject>(
       shared_function_info_,    // shared function info
       Constant<HeapObject>(0),  // description
       Index(1),                 // slot
@@ -1864,7 +1863,7 @@ void BaselineCompiler::VisitCreateClosure() {
 
   uint32_t flags = Flag(2);
   if (interpreter::CreateClosureFlags::FastNewClosureBit::decode(flags)) {
-    CallBuiltin<Builtins::kFastNewClosureBaseline>(
+    CallBuiltin<Builtin::kFastNewClosureBaseline>(
         Constant<SharedFunctionInfo>(0), feedback_cell);
   } else {
     Runtime::FunctionId function_id =
@@ -1891,7 +1890,7 @@ void BaselineCompiler::VisitCreateFunctionContext() {
   if (slot_count < static_cast<uint32_t>(
                        ConstructorBuiltins::MaximumFunctionContextSlots())) {
     DCHECK_EQ(info->scope_type(), ScopeType::FUNCTION_SCOPE);
-    CallBuiltin<Builtins::kFastNewFunctionContextFunction>(info, slot_count);
+    CallBuiltin<Builtin::kFastNewFunctionContextFunction>(info, slot_count);
   } else {
     CallRuntime(Runtime::kNewFunctionContext, Constant<ScopeInfo>(0));
   }
@@ -1903,7 +1902,7 @@ void BaselineCompiler::VisitCreateEvalContext() {
   if (slot_count < static_cast<uint32_t>(
                        ConstructorBuiltins::MaximumFunctionContextSlots())) {
     DCHECK_EQ(info->scope_type(), ScopeType::EVAL_SCOPE);
-    CallBuiltin<Builtins::kFastNewFunctionContextEval>(info, slot_count);
+    CallBuiltin<Builtin::kFastNewFunctionContextEval>(info, slot_count);
   } else {
     CallRuntime(Runtime::kNewFunctionContext, Constant<ScopeInfo>(0));
   }
@@ -1919,16 +1918,16 @@ void BaselineCompiler::VisitCreateMappedArguments() {
   if (shared_function_info_->has_duplicate_parameters()) {
     CallRuntime(Runtime::kNewSloppyArguments, __ FunctionOperand());
   } else {
-    CallBuiltin<Builtins::kFastNewSloppyArguments>(__ FunctionOperand());
+    CallBuiltin<Builtin::kFastNewSloppyArguments>(__ FunctionOperand());
   }
 }
 
 void BaselineCompiler::VisitCreateUnmappedArguments() {
-  CallBuiltin<Builtins::kFastNewStrictArguments>(__ FunctionOperand());
+  CallBuiltin<Builtin::kFastNewStrictArguments>(__ FunctionOperand());
 }
 
 void BaselineCompiler::VisitCreateRestParameter() {
-  CallBuiltin<Builtins::kFastNewRestArguments>(__ FunctionOperand());
+  CallBuiltin<Builtin::kFastNewRestArguments>(__ FunctionOperand());
 }
 
 void BaselineCompiler::VisitJumpLoop() {
@@ -1942,7 +1941,7 @@ void BaselineCompiler::VisitJumpLoop() {
   int loop_depth = iterator().GetImmediateOperand(1);
   __ CompareByte(osr_level, loop_depth);
   __ JumpIf(Condition::kUnsignedLessThanEqual, &osr_not_armed);
-  CallBuiltin<Builtins::kBaselineOnStackReplacement>();
+  CallBuiltin<Builtin::kBaselineOnStackReplacement>();
   __ RecordComment("]");
 
   __ Bind(&osr_not_armed);
@@ -2078,13 +2077,13 @@ void BaselineCompiler::VisitSwitchOnSmiNoFeedback() {
 }
 
 void BaselineCompiler::VisitForInEnumerate() {
-  CallBuiltin<Builtins::kForInEnumerate>(RegisterOperand(0));
+  CallBuiltin<Builtin::kForInEnumerate>(RegisterOperand(0));
 }
 
 void BaselineCompiler::VisitForInPrepare() {
   StoreRegister(0, kInterpreterAccumulatorRegister);
-  CallBuiltin<Builtins::kForInPrepare>(kInterpreterAccumulatorRegister,
-                                       IndexAsTagged(1), FeedbackVector());
+  CallBuiltin<Builtin::kForInPrepare>(kInterpreterAccumulatorRegister,
+                                      IndexAsTagged(1), FeedbackVector());
   interpreter::Register first = iterator().GetRegisterOperand(0);
   interpreter::Register second(first.index() + 1);
   interpreter::Register third(first.index() + 2);
@@ -2106,12 +2105,12 @@ void BaselineCompiler::VisitForInContinue() {
 void BaselineCompiler::VisitForInNext() {
   interpreter::Register cache_type, cache_array;
   std::tie(cache_type, cache_array) = iterator().GetRegisterPairOperand(2);
-  CallBuiltin<Builtins::kForInNext>(Index(3),            // vector slot
-                                    RegisterOperand(0),  // object
-                                    cache_array,         // cache array
-                                    cache_type,          // cache type
-                                    RegisterOperand(1),  // index
-                                    FeedbackVector());   // feedback vector
+  CallBuiltin<Builtin::kForInNext>(Index(3),            // vector slot
+                                   RegisterOperand(0),  // object
+                                   cache_array,         // cache array
+                                   cache_type,          // cache type
+                                   RegisterOperand(1),  // index
+                                   FeedbackVector());   // feedback vector
 }
 
 void BaselineCompiler::VisitForInStep() {
@@ -2151,7 +2150,7 @@ void BaselineCompiler::VisitReturn() {
   int parameter_count_without_receiver =
       parameter_count - 1;  // Exclude the receiver to simplify the
                             // computation. We'll account for it at the end.
-  TailCallBuiltin<Builtins::kBaselineLeaveFrame>(
+  TailCallBuiltin<Builtin::kBaselineLeaveFrame>(
       parameter_count_without_receiver, -profiling_weight);
   __ RecordComment("]");
 }
@@ -2255,7 +2254,7 @@ void BaselineCompiler::VisitSuspendGenerator() {
 
     int bytecode_offset =
         BytecodeArray::kHeaderSize + iterator().current_offset();
-    CallBuiltin<Builtins::kSuspendGeneratorBaseline>(
+    CallBuiltin<Builtin::kSuspendGeneratorBaseline>(
         generator_object,
         static_cast<int>(Uint(3)),  // suspend_id
         bytecode_offset,
@@ -2269,15 +2268,15 @@ void BaselineCompiler::VisitResumeGenerator() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register generator_object = scratch_scope.AcquireScratch();
   LoadRegister(generator_object, 0);
-  CallBuiltin<Builtins::kResumeGeneratorBaseline>(
+  CallBuiltin<Builtin::kResumeGeneratorBaseline>(
       generator_object,
       static_cast<int>(RegisterCount(2)));  // register_count
 }
 
 void BaselineCompiler::VisitGetIterator() {
-  CallBuiltin<Builtins::kGetIteratorBaseline>(RegisterOperand(0),  // receiver
-                                              IndexAsTagged(1),    // load_slot
-                                              IndexAsTagged(2));   // call_slot
+  CallBuiltin<Builtin::kGetIteratorBaseline>(RegisterOperand(0),  // receiver
+                                             IndexAsTagged(1),    // load_slot
+                                             IndexAsTagged(2));   // call_slot
 }
 
 void BaselineCompiler::VisitDebugger() {
@@ -2287,9 +2286,8 @@ void BaselineCompiler::VisitDebugger() {
 
 void BaselineCompiler::VisitIncBlockCounter() {
   SaveAccumulatorScope accumulator_scope(&basm_);
-  CallBuiltin<Builtins::kIncBlockCounter>(
-      __ FunctionOperand(),
-      IndexAsSmi(0));  // coverage array slot
+  CallBuiltin<Builtin::kIncBlockCounter>(__ FunctionOperand(),
+                                         IndexAsSmi(0));  // coverage array slot
 }
 
 void BaselineCompiler::VisitAbort() {
diff --git a/src/baseline/baseline-compiler.h b/src/baseline/baseline-compiler.h
index 9fc5df5e6bb..e6113b9f1a2 100644
--- a/src/baseline/baseline-compiler.h
+++ b/src/baseline/baseline-compiler.h
@@ -129,12 +129,12 @@ class BaselineCompiler {
                        Label::Distance distance = Label::kFar);
 
   // Call helpers.
-  template <Builtins::Name kBuiltin, typename... Args>
+  template <Builtin kBuiltin, typename... Args>
   void CallBuiltin(Args... args);
   template <typename... Args>
   void CallRuntime(Runtime::FunctionId function, Args... args);
 
-  template <Builtins::Name kBuiltin, typename... Args>
+  template <Builtin kBuiltin, typename... Args>
   void TailCallBuiltin(Args... args);
 
   template <ConvertReceiverMode kMode, typename... Args>
diff --git a/src/baseline/ia32/baseline-assembler-ia32-inl.h b/src/baseline/ia32/baseline-assembler-ia32-inl.h
index 8babb4a5b7b..c8468df8e01 100644
--- a/src/baseline/ia32/baseline-assembler-ia32-inl.h
+++ b/src/baseline/ia32/baseline-assembler-ia32-inl.h
@@ -119,15 +119,15 @@ void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,
   __ JumpIfNotSmi(value, target, distance);
 }
 
-void BaselineAssembler::CallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::CallBuiltin(Builtin builtin) {
   __ RecordCommentForOffHeapTrampoline(builtin);
-  __ Call(__ EntryFromBuiltinIndexAsOperand(builtin));
+  __ Call(__ EntryFromBuiltinAsOperand(builtin));
   __ RecordComment("]");
 }
 
-void BaselineAssembler::TailCallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::TailCallBuiltin(Builtin builtin) {
   __ RecordCommentForOffHeapTrampoline(builtin);
-  __ jmp(__ EntryFromBuiltinIndexAsOperand(builtin));
+  __ jmp(__ EntryFromBuiltinAsOperand(builtin));
   __ RecordComment("]");
 }
 
diff --git a/src/baseline/ia32/baseline-compiler-ia32-inl.h b/src/baseline/ia32/baseline-compiler-ia32-inl.h
index ad8d15ef94d..161e767dfc0 100644
--- a/src/baseline/ia32/baseline-compiler-ia32-inl.h
+++ b/src/baseline/ia32/baseline-compiler-ia32-inl.h
@@ -18,7 +18,7 @@ namespace baseline {
 void BaselineCompiler::Prologue() {
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+  CallBuiltin<Builtin::kBaselineOutOfLinePrologue>(
       kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
       max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
diff --git a/src/baseline/riscv64/baseline-assembler-riscv64-inl.h b/src/baseline/riscv64/baseline-assembler-riscv64-inl.h
index 741303f2674..390d20293c9 100644
--- a/src/baseline/riscv64/baseline-assembler-riscv64-inl.h
+++ b/src/baseline/riscv64/baseline-assembler-riscv64-inl.h
@@ -112,19 +112,19 @@ void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,
   __ JumpIfSmi(value, target);
 }
 
-void BaselineAssembler::CallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::CallBuiltin(Builtin builtin) {
   if (masm()->options().short_builtin_calls) {
     __ CallBuiltin(builtin);
   } else {
     __ RecordCommentForOffHeapTrampoline(builtin);
     Register temp = t6;
-    __ LoadEntryFromBuiltinIndex(builtin, temp);
+    __ LoadEntryFromBuiltin(builtin, temp);
     __ Call(temp);
     __ RecordComment("]");
   }
 }
 
-void BaselineAssembler::TailCallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::TailCallBuiltin(Builtin builtin) {
   if (masm()->options().short_builtin_calls) {
     // Generate pc-relative jump.
     __ TailCallBuiltin(builtin);
@@ -133,7 +133,7 @@ void BaselineAssembler::TailCallBuiltin(Builtins::Name builtin) {
     // t6 be used for function call in RISCV64
     // For example 'jalr t6' or 'jal t6'
     Register temp = t6;
-    __ LoadEntryFromBuiltinIndex(builtin, temp);
+    __ LoadEntryFromBuiltin(builtin, temp);
     __ Jump(temp);
     __ RecordComment("]");
   }
diff --git a/src/baseline/riscv64/baseline-compiler-riscv64-inl.h b/src/baseline/riscv64/baseline-compiler-riscv64-inl.h
index 98ca62e3034..44fab196d7f 100644
--- a/src/baseline/riscv64/baseline-compiler-riscv64-inl.h
+++ b/src/baseline/riscv64/baseline-compiler-riscv64-inl.h
@@ -18,7 +18,7 @@ void BaselineCompiler::Prologue() {
   __ masm()->EnterFrame(StackFrame::BASELINE);
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+  CallBuiltin<Builtin::kBaselineOutOfLinePrologue>(
       kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
       max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
   PrologueFillFrame();
diff --git a/src/baseline/x64/baseline-assembler-x64-inl.h b/src/baseline/x64/baseline-assembler-x64-inl.h
index 98ed29a9cae..3b3dc0ae26d 100644
--- a/src/baseline/x64/baseline-assembler-x64-inl.h
+++ b/src/baseline/x64/baseline-assembler-x64-inl.h
@@ -121,24 +121,24 @@ void BaselineAssembler::JumpIfNotSmi(Register value, Label* target,
   __ JumpIfNotSmi(value, target, distance);
 }
 
-void BaselineAssembler::CallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::CallBuiltin(Builtin builtin) {
   if (masm()->options().short_builtin_calls) {
     // Generate pc-relative call.
     __ CallBuiltin(builtin);
   } else {
     __ RecordCommentForOffHeapTrampoline(builtin);
-    __ Call(__ EntryFromBuiltinIndexAsOperand(builtin));
+    __ Call(__ EntryFromBuiltinAsOperand(builtin));
     __ RecordComment("]");
   }
 }
 
-void BaselineAssembler::TailCallBuiltin(Builtins::Name builtin) {
+void BaselineAssembler::TailCallBuiltin(Builtin builtin) {
   if (masm()->options().short_builtin_calls) {
     // Generate pc-relative jump.
     __ TailCallBuiltin(builtin);
   } else {
     __ RecordCommentForOffHeapTrampoline(builtin);
-    __ Jump(__ EntryFromBuiltinIndexAsOperand(builtin));
+    __ Jump(__ EntryFromBuiltinAsOperand(builtin));
     __ RecordComment("]");
   }
 }
diff --git a/src/baseline/x64/baseline-compiler-x64-inl.h b/src/baseline/x64/baseline-compiler-x64-inl.h
index 7dea3ddce1f..7218d403523 100644
--- a/src/baseline/x64/baseline-compiler-x64-inl.h
+++ b/src/baseline/x64/baseline-compiler-x64-inl.h
@@ -18,7 +18,7 @@ namespace baseline {
 void BaselineCompiler::Prologue() {
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+  CallBuiltin<Builtin::kBaselineOutOfLinePrologue>(
       kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
       max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index 7b3f3e7ce91..bfbaf76e8c9 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -493,7 +493,7 @@ static_assert(kPushedStackSpace == EntryFrameConstants::kDirectCallerSPOffset +
 //   using JSEntryFunction = GeneratedCode<Address(
 //       Address root_register_value, MicrotaskQueue* microtask_queue)>;
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   // The register state is either:
   //   r0:                            root_register_value
   //   r1:                            code entry
@@ -656,18 +656,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
@@ -1040,8 +1039,8 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   // Need a few extra registers
   temps.Include(r8, r9);
 
-  auto descriptor = Builtins::CallInterfaceDescriptorFor(
-      Builtins::kBaselineOutOfLinePrologue);
+  auto descriptor =
+      Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
       BaselineOutOfLinePrologueDescriptor::kClosure);
   // Load the feedback vector from the closure.
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index c8f901d4169..417eb5e559b 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -609,7 +609,7 @@ namespace {
 // Output:
 //   x0: result.
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   Label invoke, handler_entry, exit;
 
   {
@@ -812,18 +812,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 // Input:
@@ -1221,8 +1220,8 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   // Need a few extra registers
   temps.Include(x14, x15);
 
-  auto descriptor = Builtins::CallInterfaceDescriptorFor(
-      Builtins::kBaselineOutOfLinePrologue);
+  auto descriptor =
+      Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
       BaselineOutOfLinePrologueDescriptor::kClosure);
   // Load the feedback vector from the closure.
diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.cc
index 833627c7b41..332c300e5b1 100644
--- a/src/builtins/builtins-array-gen.cc
+++ b/src/builtins/builtins-array-gen.cc
@@ -305,7 +305,7 @@ TF_BUILTIN(ArrayPrototypePop, CodeStubAssembler) {
     // from the current frame here in order to reduce register pressure on the
     // fast path.
     TNode<JSFunction> target = LoadTargetFromFrame();
-    TailCallBuiltin(Builtins::kArrayPop, context, target, UndefinedConstant(),
+    TailCallBuiltin(Builtin::kArrayPop, context, target, UndefinedConstant(),
                     argc);
   }
 }
@@ -430,7 +430,7 @@ TF_BUILTIN(ArrayPrototypePush, CodeStubAssembler) {
     // from the current frame here in order to reduce register pressure on the
     // fast path.
     TNode<JSFunction> target = LoadTargetFromFrame();
-    TailCallBuiltin(Builtins::kArrayPush, context, target, UndefinedConstant(),
+    TailCallBuiltin(Builtin::kArrayPush, context, target, UndefinedConstant(),
                     argc);
   }
 }
@@ -678,12 +678,11 @@ void ArrayIncludesIndexofAssembler::Generate(SearchVariant variant,
 
   BIND(&if_smiorobjects);
   {
-    Callable callable =
-        (variant == kIncludes)
-            ? Builtins::CallableFor(isolate(),
-                                    Builtins::kArrayIncludesSmiOrObject)
-            : Builtins::CallableFor(isolate(),
-                                    Builtins::kArrayIndexOfSmiOrObject);
+    Callable callable = (variant == kIncludes)
+                            ? Builtins::CallableFor(
+                                  isolate(), Builtin::kArrayIncludesSmiOrObject)
+                            : Builtins::CallableFor(
+                                  isolate(), Builtin::kArrayIndexOfSmiOrObject);
     TNode<Object> result = CallStub(callable, context, elements, search_element,
                                     array_length, SmiTag(index_var.value()));
     args.PopAndReturn(result);
@@ -694,9 +693,9 @@ void ArrayIncludesIndexofAssembler::Generate(SearchVariant variant,
     Callable callable =
         (variant == kIncludes)
             ? Builtins::CallableFor(isolate(),
-                                    Builtins::kArrayIncludesPackedDoubles)
+                                    Builtin::kArrayIncludesPackedDoubles)
             : Builtins::CallableFor(isolate(),
-                                    Builtins::kArrayIndexOfPackedDoubles);
+                                    Builtin::kArrayIndexOfPackedDoubles);
     TNode<Object> result = CallStub(callable, context, elements, search_element,
                                     array_length, SmiTag(index_var.value()));
     args.PopAndReturn(result);
@@ -707,9 +706,9 @@ void ArrayIncludesIndexofAssembler::Generate(SearchVariant variant,
     Callable callable =
         (variant == kIncludes)
             ? Builtins::CallableFor(isolate(),
-                                    Builtins::kArrayIncludesHoleyDoubles)
+                                    Builtin::kArrayIncludesHoleyDoubles)
             : Builtins::CallableFor(isolate(),
-                                    Builtins::kArrayIndexOfHoleyDoubles);
+                                    Builtin::kArrayIndexOfHoleyDoubles);
     TNode<Object> result = CallStub(callable, context, elements, search_element,
                                     array_length, SmiTag(index_var.value()));
     args.PopAndReturn(result);
@@ -1258,7 +1257,7 @@ TF_BUILTIN(ArrayIteratorPrototypeNext, CodeStubAssembler) {
 
     // Check that the {index} is within the bounds of the {array}s "length".
     TNode<Number> length = CAST(
-        CallBuiltin(Builtins::kToLength, context,
+        CallBuiltin(Builtin::kToLength, context,
                     GetProperty(context, array, factory()->length_string())));
     GotoIfNumberGreaterThanOrEqual(index, length, &set_done);
     StoreJSArrayIteratorNextIndex(iterator, NumberInc(index));
@@ -1446,7 +1445,7 @@ class ArrayFlattenAssembler : public CodeStubAssembler {
           //                                          elementLen, targetIndex,
           //                                          depth - 1).
           var_target_index = CAST(
-              CallBuiltin(Builtins::kFlattenIntoArray, context, target, element,
+              CallBuiltin(Builtin::kFlattenIntoArray, context, target, element,
                           element_length, target_index, NumberDec(depth)));
           Goto(&next);
         }
@@ -1463,7 +1462,7 @@ class ArrayFlattenAssembler : public CodeStubAssembler {
           //                                          elementLen, targetIndex,
           //                                          depth - 1).
           var_target_index = CAST(
-              CallBuiltin(Builtins::kFlattenIntoArray, context, target, element,
+              CallBuiltin(Builtin::kFlattenIntoArray, context, target, element,
                           element_length, target_index, NumberDec(depth)));
           Goto(&next);
         }
@@ -1569,7 +1568,7 @@ TF_BUILTIN(ArrayPrototypeFlat, CodeStubAssembler) {
   const TNode<JSReceiver> a = Construct(context, constructor, SmiConstant(0));
 
   // 6. Perform ? FlattenIntoArray(A, O, sourceLen, 0, depthNum).
-  CallBuiltin(Builtins::kFlattenIntoArray, context, a, o, source_length,
+  CallBuiltin(Builtin::kFlattenIntoArray, context, a, o, source_length,
               SmiConstant(0), var_depth_num.value());
 
   // 7. Return A.
@@ -1606,7 +1605,7 @@ TF_BUILTIN(ArrayPrototypeFlatMap, CodeStubAssembler) {
   const TNode<JSReceiver> a = Construct(context, constructor, SmiConstant(0));
 
   // 6. Perform ? FlattenIntoArray(A, O, sourceLen, 0, 1, mapperFunction, T).
-  CallBuiltin(Builtins::kFlatMapIntoArray, context, a, o, source_length,
+  CallBuiltin(Builtin::kFlatMapIntoArray, context, a, o, source_length,
               SmiConstant(0), SmiConstant(1), mapper_function, t);
 
   // 7. Return A.
@@ -1631,8 +1630,8 @@ TF_BUILTIN(ArrayConstructor, ArrayBuiltinsAssembler) {
 
   // Run the native code for the Array function called as a normal function.
   TNode<Oddball> no_gc_site = UndefinedConstant();
-  TailCallBuiltin(Builtins::kArrayConstructorImpl, context, function,
-                  new_target, argc, no_gc_site);
+  TailCallBuiltin(Builtin::kArrayConstructorImpl, context, function, new_target,
+                  argc, no_gc_site);
 }
 
 void ArrayBuiltinsAssembler::TailCallArrayConstructorStub(
diff --git a/src/builtins/builtins-async-function-gen.cc b/src/builtins/builtins-async-function-gen.cc
index 1644997ed01..3894e7bc1ef 100644
--- a/src/builtins/builtins-async-function-gen.cc
+++ b/src/builtins/builtins-async-function-gen.cc
@@ -188,7 +188,7 @@ TF_BUILTIN(AsyncFunctionReject, AsyncFunctionBuiltinsAssembler) {
   // Reject the {promise} for the given {reason}, disabling the
   // additional debug event for the rejection since a debug event
   // already happend for the exception that got us here.
-  CallBuiltin(Builtins::kRejectPromise, context, promise, reason,
+  CallBuiltin(Builtin::kRejectPromise, context, promise, reason,
               FalseConstant());
 
   Label if_debugging(this, Label::kDeferred);
@@ -210,7 +210,7 @@ TF_BUILTIN(AsyncFunctionResolve, AsyncFunctionBuiltinsAssembler) {
   TNode<JSPromise> promise = LoadObjectField<JSPromise>(
       async_function_object, JSAsyncFunctionObject::kPromiseOffset);
 
-  CallBuiltin(Builtins::kResolvePromise, context, promise, value);
+  CallBuiltin(Builtin::kResolvePromise, context, promise, value);
 
   Label if_debugging(this, Label::kDeferred);
   GotoIf(HasAsyncEventDelegate(), &if_debugging);
diff --git a/src/builtins/builtins-async-gen.cc b/src/builtins/builtins-async-gen.cc
index 629f1e94fa4..bf8eaceae8f 100644
--- a/src/builtins/builtins-async-gen.cc
+++ b/src/builtins/builtins-async-gen.cc
@@ -104,10 +104,10 @@ TNode<Object> AsyncBuiltinsAssembler::AwaitOld(
                    &var_throwaway);
 
   // Perform ! Call(promiseCapability.[[Resolve]], undefined, ¬´ promise ¬ª).
-  CallBuiltin(Builtins::kResolvePromise, context, promise, value);
+  CallBuiltin(Builtin::kResolvePromise, context, promise, value);
 
-  return CallBuiltin(Builtins::kPerformPromiseThen, context, promise,
-                     on_resolve, on_reject, var_throwaway.value());
+  return CallBuiltin(Builtin::kPerformPromiseThen, context, promise, on_resolve,
+                     on_reject, var_throwaway.value());
 }
 
 TNode<Object> AsyncBuiltinsAssembler::AwaitOptimized(
@@ -165,7 +165,7 @@ TNode<Object> AsyncBuiltinsAssembler::AwaitOptimized(
                    outer_promise, on_reject, is_predicted_as_caught,
                    &var_throwaway);
 
-  return CallBuiltin(Builtins::kPerformPromiseThen, native_context, promise,
+  return CallBuiltin(Builtin::kPerformPromiseThen, native_context, promise,
                      on_resolve, on_reject, var_throwaway.value());
 }
 
@@ -194,7 +194,7 @@ void AsyncBuiltinsAssembler::InitAwaitPromise(
   // This call to NewJSPromise is to keep behaviour parity with what happens
   // in Runtime::kAwaitPromisesInit above if native hooks are set. It will
   // create a throwaway promise that will trigger an init event and will get
-  // passed into Builtins::kPerformPromiseThen below.
+  // passed into Builtin::kPerformPromiseThen below.
   Branch(IsContextPromiseHookEnabled(promiseHookFlags), &if_promise_hook,
          &do_nothing);
   BIND(&if_promise_hook);
@@ -327,7 +327,7 @@ TF_BUILTIN(AsyncIteratorValueUnwrap, AsyncBuiltinsAssembler) {
   CSA_ASSERT(this, IsBoolean(CAST(done)));
 
   const TNode<Object> unwrapped_value =
-      CallBuiltin(Builtins::kCreateIterResultObject, context, value, done);
+      CallBuiltin(Builtin::kCreateIterResultObject, context, value, done);
 
   Return(unwrapped_value);
 }
diff --git a/src/builtins/builtins-async-generator-gen.cc b/src/builtins/builtins-async-generator-gen.cc
index 0e94fd20939..9d15ba0cfd0 100644
--- a/src/builtins/builtins-async-generator-gen.cc
+++ b/src/builtins/builtins-async-generator-gen.cc
@@ -171,7 +171,7 @@ void AsyncGeneratorBuiltinsAssembler::AsyncGeneratorEnqueue(
                     SmiConstant(JSAsyncGeneratorObject::kGeneratorExecuting)),
            &done);
 
-    CallBuiltin(Builtins::kAsyncGeneratorResumeNext, context, generator);
+    CallBuiltin(Builtin::kAsyncGeneratorResumeNext, context, generator);
 
     Goto(&done);
     BIND(&done);
@@ -180,7 +180,7 @@ void AsyncGeneratorBuiltinsAssembler::AsyncGeneratorEnqueue(
 
   BIND(&if_receiverisincompatible);
   {
-    CallBuiltin(Builtins::kRejectPromise, context, promise,
+    CallBuiltin(Builtin::kRejectPromise, context, promise,
                 MakeTypeError(MessageTemplate::kIncompatibleMethodReceiver,
                               context, StringConstant(method_name), receiver),
                 TrueConstant());
@@ -225,7 +225,7 @@ void AsyncGeneratorBuiltinsAssembler::AsyncGeneratorAwaitResumeClosure(
 
   CallStub(CodeFactory::ResumeGenerator(isolate()), context, value, generator);
 
-  TailCallBuiltin(Builtins::kAsyncGeneratorResumeNext, context, generator);
+  TailCallBuiltin(Builtin::kAsyncGeneratorResumeNext, context, generator);
 }
 
 template <typename Descriptor>
@@ -438,13 +438,12 @@ TF_BUILTIN(AsyncGeneratorResumeNext, AsyncGeneratorBuiltinsAssembler) {
     // In all cases, the last step is to call AsyncGeneratorResumeNext.
     TNode<Object> is_caught = CallRuntime(
         Runtime::kAsyncGeneratorHasCatchHandlerForPC, context, generator);
-    TailCallBuiltin(Builtins::kAsyncGeneratorReturn, context, generator,
+    TailCallBuiltin(Builtin::kAsyncGeneratorReturn, context, generator,
                     next_value, is_caught);
 
     BIND(&if_throw);
     GotoIfNot(IsGeneratorStateClosed(var_state.value()), &resume_generator);
-    CallBuiltin(Builtins::kAsyncGeneratorReject, context, generator,
-                next_value);
+    CallBuiltin(Builtin::kAsyncGeneratorReject, context, generator, next_value);
     var_next = LoadFirstAsyncGeneratorRequestFromQueue(generator);
     Goto(&start);
   }
@@ -452,7 +451,7 @@ TF_BUILTIN(AsyncGeneratorResumeNext, AsyncGeneratorBuiltinsAssembler) {
   BIND(&if_normal);
   {
     GotoIfNot(IsGeneratorStateClosed(var_state.value()), &resume_generator);
-    CallBuiltin(Builtins::kAsyncGeneratorResolve, context, generator,
+    CallBuiltin(Builtin::kAsyncGeneratorResolve, context, generator,
                 UndefinedConstant(), TrueConstant());
     var_state = LoadGeneratorState(generator);
     var_next = LoadFirstAsyncGeneratorRequestFromQueue(generator);
@@ -525,14 +524,14 @@ TF_BUILTIN(AsyncGeneratorResolve, AsyncGeneratorBuiltinsAssembler) {
   {
     // Skip the "then" on {iter_result} and directly fulfill the {promise}
     // with the {iter_result}.
-    CallBuiltin(Builtins::kFulfillPromise, context, promise, iter_result);
+    CallBuiltin(Builtin::kFulfillPromise, context, promise, iter_result);
     Goto(&return_promise);
   }
 
   BIND(&if_slow);
   {
     // Perform Call(promiseCapability.[[Resolve]], undefined, ¬´iteratorResult¬ª).
-    CallBuiltin(Builtins::kResolvePromise, context, promise, iter_result);
+    CallBuiltin(Builtin::kResolvePromise, context, promise, iter_result);
     Goto(&return_promise);
   }
 
@@ -553,7 +552,7 @@ TF_BUILTIN(AsyncGeneratorReject, AsyncGeneratorBuiltinsAssembler) {
       TakeFirstAsyncGeneratorRequestFromQueue(generator);
   TNode<JSPromise> promise = LoadPromiseFromAsyncGeneratorRequest(next);
 
-  Return(CallBuiltin(Builtins::kRejectPromise, context, promise, value,
+  Return(CallBuiltin(Builtin::kRejectPromise, context, promise, value,
                      TrueConstant()));
 }
 
@@ -585,10 +584,10 @@ TF_BUILTIN(AsyncGeneratorYieldResolveClosure, AsyncGeneratorBuiltinsAssembler) {
 
   // Per proposal-async-iteration/#sec-asyncgeneratoryield step 9
   // Return ! AsyncGeneratorResolve(_F_.[[Generator]], _value_, *false*).
-  CallBuiltin(Builtins::kAsyncGeneratorResolve, context, generator, value,
+  CallBuiltin(Builtin::kAsyncGeneratorResolve, context, generator, value,
               FalseConstant());
 
-  TailCallBuiltin(Builtins::kAsyncGeneratorResumeNext, context, generator);
+  TailCallBuiltin(Builtin::kAsyncGeneratorResumeNext, context, generator);
 }
 
 TF_BUILTIN(AsyncGeneratorReturn, AsyncGeneratorBuiltinsAssembler) {
@@ -666,10 +665,10 @@ TF_BUILTIN(AsyncGeneratorReturnClosedResolveClosure,
   // https://tc39.github.io/proposal-async-iteration/
   //    #async-generator-resume-next-return-processor-fulfilled step 2:
   //  Return ! AsyncGeneratorResolve(_F_.[[Generator]], _value_, *true*).
-  CallBuiltin(Builtins::kAsyncGeneratorResolve, context, generator, value,
+  CallBuiltin(Builtin::kAsyncGeneratorResolve, context, generator, value,
               TrueConstant());
 
-  TailCallBuiltin(Builtins::kAsyncGeneratorResumeNext, context, generator);
+  TailCallBuiltin(Builtin::kAsyncGeneratorResumeNext, context, generator);
 }
 
 TF_BUILTIN(AsyncGeneratorReturnClosedRejectClosure,
@@ -684,9 +683,9 @@ TF_BUILTIN(AsyncGeneratorReturnClosedRejectClosure,
   // https://tc39.github.io/proposal-async-iteration/
   //    #async-generator-resume-next-return-processor-rejected step 2:
   // Return ! AsyncGeneratorReject(_F_.[[Generator]], _reason_).
-  CallBuiltin(Builtins::kAsyncGeneratorReject, context, generator, value);
+  CallBuiltin(Builtin::kAsyncGeneratorReject, context, generator, value);
 
-  TailCallBuiltin(Builtins::kAsyncGeneratorResumeNext, context, generator);
+  TailCallBuiltin(Builtin::kAsyncGeneratorResumeNext, context, generator);
 }
 
 }  // namespace internal
diff --git a/src/builtins/builtins-async-iterator-gen.cc b/src/builtins/builtins-async-iterator-gen.cc
index 9e6223073f2..11dd73cd4a2 100644
--- a/src/builtins/builtins-async-iterator-gen.cc
+++ b/src/builtins/builtins-async-iterator-gen.cc
@@ -168,7 +168,7 @@ void AsyncFromSyncBuiltinsAssembler::Generate_AsyncFromSyncIteratorMethod(
   TNode<Object> value_wrapper;
   {
     ScopedExceptionHandler handler(this, &reject_promise, &var_exception);
-    value_wrapper = CallBuiltin(Builtins::kPromiseResolve, native_context,
+    value_wrapper = CallBuiltin(Builtin::kPromiseResolve, native_context,
                                 promise_fun, value);
   }
 
@@ -180,14 +180,14 @@ void AsyncFromSyncBuiltinsAssembler::Generate_AsyncFromSyncIteratorMethod(
 
   // Perform ! PerformPromiseThen(valueWrapper,
   //     onFulfilled, undefined, promiseCapability).
-  args->PopAndReturn(CallBuiltin(Builtins::kPerformPromiseThen, context,
+  args->PopAndReturn(CallBuiltin(Builtin::kPerformPromiseThen, context,
                                  value_wrapper, on_fulfilled,
                                  UndefinedConstant(), promise));
 
   BIND(&reject_promise);
   {
     const TNode<Object> exception = var_exception.value();
-    CallBuiltin(Builtins::kRejectPromise, context, promise, exception,
+    CallBuiltin(Builtin::kRejectPromise, context, promise, exception,
                 TrueConstant());
     args->PopAndReturn(promise);
   }
@@ -259,7 +259,7 @@ AsyncFromSyncBuiltinsAssembler::LoadIteratorResult(
   BIND(&to_boolean);
   {
     const TNode<Object> result =
-        CallBuiltin(Builtins::kToBoolean, context, var_done.value());
+        CallBuiltin(Builtin::kToBoolean, context, var_done.value());
     var_done = result;
     Goto(&done);
   }
@@ -309,12 +309,12 @@ TF_BUILTIN(AsyncFromSyncIteratorPrototypeReturn,
     // If return is undefined, then
     // Let iterResult be ! CreateIterResultObject(value, true)
     const TNode<Object> iter_result = CallBuiltin(
-        Builtins::kCreateIterResultObject, context, value, TrueConstant());
+        Builtin::kCreateIterResultObject, context, value, TrueConstant());
 
     // Perform ! Call(promiseCapability.[[Resolve]], undefined, ¬´ iterResult ¬ª).
     // IfAbruptRejectPromise(nextDone, promiseCapability).
     // Return promiseCapability.[[Promise]].
-    CallBuiltin(Builtins::kResolvePromise, context, promise, iter_result);
+    CallBuiltin(Builtin::kResolvePromise, context, promise, iter_result);
     args.PopAndReturn(promise);
   };
 
diff --git a/src/builtins/builtins-call-gen.cc b/src/builtins/builtins-call-gen.cc
index 89bf77d0b07..54d2c748021 100644
--- a/src/builtins/builtins-call-gen.cc
+++ b/src/builtins/builtins-call-gen.cc
@@ -69,7 +69,7 @@ void Builtins::Generate_CallFunctionForwardVarargs(MacroAssembler* masm) {
 TF_BUILTIN(Call_ReceiverIsNullOrUndefined_Baseline_Compact,
            CallOrConstructBuiltinsAssembler) {
   auto receiver = UndefinedConstant();
-  CallReceiver<Descriptor>(Builtins::kCall_ReceiverIsNullOrUndefined, receiver);
+  CallReceiver<Descriptor>(Builtin::kCall_ReceiverIsNullOrUndefined, receiver);
 }
 
 TF_BUILTIN(Call_ReceiverIsNullOrUndefined_Baseline,
@@ -77,32 +77,32 @@ TF_BUILTIN(Call_ReceiverIsNullOrUndefined_Baseline,
   auto argc = UncheckedParameter<Int32T>(Descriptor::kActualArgumentsCount);
   auto slot = UncheckedParameter<UintPtrT>(Descriptor::kSlot);
   auto receiver = UndefinedConstant();
-  CallReceiver<Descriptor>(Builtins::kCall_ReceiverIsNullOrUndefined, argc,
-                           slot, receiver);
+  CallReceiver<Descriptor>(Builtin::kCall_ReceiverIsNullOrUndefined, argc, slot,
+                           receiver);
 }
 
 TF_BUILTIN(Call_ReceiverIsNotNullOrUndefined_Baseline_Compact,
            CallOrConstructBuiltinsAssembler) {
-  CallReceiver<Descriptor>(Builtins::kCall_ReceiverIsNotNullOrUndefined);
+  CallReceiver<Descriptor>(Builtin::kCall_ReceiverIsNotNullOrUndefined);
 }
 
 TF_BUILTIN(Call_ReceiverIsNotNullOrUndefined_Baseline,
            CallOrConstructBuiltinsAssembler) {
   auto argc = UncheckedParameter<Int32T>(Descriptor::kActualArgumentsCount);
   auto slot = UncheckedParameter<UintPtrT>(Descriptor::kSlot);
-  CallReceiver<Descriptor>(Builtins::kCall_ReceiverIsNotNullOrUndefined, argc,
+  CallReceiver<Descriptor>(Builtin::kCall_ReceiverIsNotNullOrUndefined, argc,
                            slot);
 }
 
 TF_BUILTIN(Call_ReceiverIsAny_Baseline_Compact,
            CallOrConstructBuiltinsAssembler) {
-  CallReceiver<Descriptor>(Builtins::kCall_ReceiverIsAny);
+  CallReceiver<Descriptor>(Builtin::kCall_ReceiverIsAny);
 }
 
 TF_BUILTIN(Call_ReceiverIsAny_Baseline, CallOrConstructBuiltinsAssembler) {
   auto argc = UncheckedParameter<Int32T>(Descriptor::kActualArgumentsCount);
   auto slot = UncheckedParameter<UintPtrT>(Descriptor::kSlot);
-  CallReceiver<Descriptor>(Builtins::kCall_ReceiverIsAny, argc, slot);
+  CallReceiver<Descriptor>(Builtin::kCall_ReceiverIsAny, argc, slot);
 }
 
 TF_BUILTIN(Call_ReceiverIsNullOrUndefined_WithFeedback,
@@ -115,7 +115,7 @@ TF_BUILTIN(Call_ReceiverIsNullOrUndefined_WithFeedback,
   auto receiver = Parameter<Object>(Descriptor::kReceiver);
   CollectCallFeedback(
       target, [=] { return receiver; }, context, feedback_vector, slot);
-  TailCallBuiltin(Builtins::kCall_ReceiverIsNullOrUndefined, context, target,
+  TailCallBuiltin(Builtin::kCall_ReceiverIsNullOrUndefined, context, target,
                   argc);
 }
 
@@ -129,7 +129,7 @@ TF_BUILTIN(Call_ReceiverIsNotNullOrUndefined_WithFeedback,
   auto receiver = Parameter<Object>(Descriptor::kReceiver);
   CollectCallFeedback(
       target, [=] { return receiver; }, context, feedback_vector, slot);
-  TailCallBuiltin(Builtins::kCall_ReceiverIsNotNullOrUndefined, context, target,
+  TailCallBuiltin(Builtin::kCall_ReceiverIsNotNullOrUndefined, context, target,
                   argc);
 }
 
@@ -142,7 +142,7 @@ TF_BUILTIN(Call_ReceiverIsAny_WithFeedback, CallOrConstructBuiltinsAssembler) {
   auto receiver = Parameter<Object>(Descriptor::kReceiver);
   CollectCallFeedback(
       target, [=] { return receiver; }, context, feedback_vector, slot);
-  TailCallBuiltin(Builtins::kCall_ReceiverIsAny, context, target, argc);
+  TailCallBuiltin(Builtin::kCall_ReceiverIsAny, context, target, argc);
 }
 
 void CallOrConstructBuiltinsAssembler::CallOrConstructWithArrayLike(
@@ -407,7 +407,7 @@ void CallOrConstructBuiltinsAssembler::CallOrConstructWithSpread(
         GetProperty(context, spread, IteratorSymbolConstant());
     GotoIfNot(TaggedIsCallable(iterator_fn), &if_iterator_fn_not_callable);
     TNode<JSArray> list =
-        CAST(CallBuiltin(Builtins::kIterableToListMayPreserveHoles, context,
+        CAST(CallBuiltin(Builtin::kIterableToListMayPreserveHoles, context,
                          spread, iterator_fn));
 
     var_js_array = list;
@@ -464,7 +464,7 @@ void CallOrConstructBuiltinsAssembler::CallOrConstructWithSpread(
 
 template <class Descriptor>
 void CallOrConstructBuiltinsAssembler::CallReceiver(
-    Builtins::Name id, base::Optional<TNode<Object>> receiver) {
+    Builtin id, base::Optional<TNode<Object>> receiver) {
   static_assert(std::is_same<Descriptor,
                              CallTrampoline_Baseline_CompactDescriptor>::value,
                 "Incompatible Descriptor");
@@ -481,7 +481,7 @@ void CallOrConstructBuiltinsAssembler::CallReceiver(
 
 template <class Descriptor>
 void CallOrConstructBuiltinsAssembler::CallReceiver(
-    Builtins::Name id, TNode<Int32T> argc, TNode<UintPtrT> slot,
+    Builtin id, TNode<Int32T> argc, TNode<UintPtrT> slot,
     base::Optional<TNode<Object>> maybe_receiver) {
   auto target = Parameter<Object>(Descriptor::kFunction);
   auto context = LoadContextFromBaseline();
diff --git a/src/builtins/builtins-call-gen.h b/src/builtins/builtins-call-gen.h
index ff4d998ff3a..268d7b3d91a 100644
--- a/src/builtins/builtins-call-gen.h
+++ b/src/builtins/builtins-call-gen.h
@@ -31,10 +31,9 @@ class CallOrConstructBuiltinsAssembler : public CodeStubAssembler {
                                  TNode<Context> context);
 
   template <class Descriptor>
-  void CallReceiver(Builtins::Name id,
-                    base::Optional<TNode<Object>> = base::nullopt);
+  void CallReceiver(Builtin id, base::Optional<TNode<Object>> = base::nullopt);
   template <class Descriptor>
-  void CallReceiver(Builtins::Name id, TNode<Int32T> argc, TNode<UintPtrT> slot,
+  void CallReceiver(Builtin id, TNode<Int32T> argc, TNode<UintPtrT> slot,
                     base::Optional<TNode<Object>> = base::nullopt);
 
   enum class CallFunctionTemplateMode : uint8_t {
diff --git a/src/builtins/builtins-collections-gen.cc b/src/builtins/builtins-collections-gen.cc
index 785a1af90a2..54b7c576163 100644
--- a/src/builtins/builtins-collections-gen.cc
+++ b/src/builtins/builtins-collections-gen.cc
@@ -1368,7 +1368,7 @@ void CollectionsBuiltinsAssembler::SameValueZeroString(
   GotoIf(TaggedIsSmi(candidate_key), if_not_same);
   GotoIfNot(IsString(CAST(candidate_key)), if_not_same);
 
-  Branch(TaggedEqual(CallBuiltin(Builtins::kStringEqual, NoContextConstant(),
+  Branch(TaggedEqual(CallBuiltin(Builtin::kStringEqual, NoContextConstant(),
                                  key_string, candidate_key),
                      TrueConstant()),
          if_same, if_not_same);
@@ -1490,7 +1490,7 @@ CollectionsBuiltinsAssembler::Transition(
 
       var_table = CAST(next_table);
       var_index = SmiUntag(
-          CAST(CallBuiltin(Builtins::kOrderedHashTableHealIndex,
+          CAST(CallBuiltin(Builtin::kOrderedHashTableHealIndex,
                            NoContextConstant(), table, SmiTag(index))));
       Goto(&loop);
     }
@@ -1568,8 +1568,8 @@ TF_BUILTIN(MapPrototypeGet, CollectionsBuiltinsAssembler) {
 
   const TNode<Object> table =
       LoadObjectField<Object>(CAST(receiver), JSMap::kTableOffset);
-  TNode<Smi> index = CAST(
-      CallBuiltin(Builtins::kFindOrderedHashMapEntry, context, table, key));
+  TNode<Smi> index =
+      CAST(CallBuiltin(Builtin::kFindOrderedHashMapEntry, context, table, key));
 
   Label if_found(this), if_not_found(this);
   Branch(SmiGreaterThanOrEqual(index, SmiConstant(0)), &if_found,
@@ -1594,8 +1594,8 @@ TF_BUILTIN(MapPrototypeHas, CollectionsBuiltinsAssembler) {
 
   const TNode<Object> table =
       LoadObjectField(CAST(receiver), JSMap::kTableOffset);
-  TNode<Smi> index = CAST(
-      CallBuiltin(Builtins::kFindOrderedHashMapEntry, context, table, key));
+  TNode<Smi> index =
+      CAST(CallBuiltin(Builtin::kFindOrderedHashMapEntry, context, table, key));
 
   Label if_found(this), if_not_found(this);
   Branch(SmiGreaterThanOrEqual(index, SmiConstant(0)), &if_found,
@@ -2744,7 +2744,7 @@ TF_BUILTIN(WeakMapGet, WeakCollectionsBuiltinsAssembler) {
 
   const TNode<EphemeronHashTable> table = LoadTable(CAST(receiver));
   const TNode<Smi> index =
-      CAST(CallBuiltin(Builtins::kWeakMapLookupHashIndex, context, table, key));
+      CAST(CallBuiltin(Builtin::kWeakMapLookupHashIndex, context, table, key));
 
   GotoIf(TaggedEqual(index, SmiConstant(-1)), &return_undefined);
 
@@ -2766,7 +2766,7 @@ TF_BUILTIN(WeakMapPrototypeHas, WeakCollectionsBuiltinsAssembler) {
 
   const TNode<EphemeronHashTable> table = LoadTable(CAST(receiver));
   const TNode<Object> index =
-      CallBuiltin(Builtins::kWeakMapLookupHashIndex, context, table, key);
+      CallBuiltin(Builtin::kWeakMapLookupHashIndex, context, table, key);
 
   GotoIf(TaggedEqual(index, SmiConstant(-1)), &return_false);
 
@@ -2866,7 +2866,7 @@ TF_BUILTIN(WeakMapPrototypeDelete, CodeStubAssembler) {
   ThrowIfNotInstanceType(context, receiver, JS_WEAK_MAP_TYPE,
                          "WeakMap.prototype.delete");
 
-  Return(CallBuiltin(Builtins::kWeakCollectionDelete, context, receiver, key));
+  Return(CallBuiltin(Builtin::kWeakCollectionDelete, context, receiver, key));
 }
 
 TF_BUILTIN(WeakMapPrototypeSet, WeakCollectionsBuiltinsAssembler) {
@@ -2882,7 +2882,7 @@ TF_BUILTIN(WeakMapPrototypeSet, WeakCollectionsBuiltinsAssembler) {
   GotoIfNotJSReceiver(key, &throw_invalid_key);
 
   Return(
-      CallBuiltin(Builtins::kWeakCollectionSet, context, receiver, key, value));
+      CallBuiltin(Builtin::kWeakCollectionSet, context, receiver, key, value));
 
   BIND(&throw_invalid_key);
   ThrowTypeError(context, MessageTemplate::kInvalidWeakMapKey, key);
@@ -2899,7 +2899,7 @@ TF_BUILTIN(WeakSetPrototypeAdd, WeakCollectionsBuiltinsAssembler) {
   Label throw_invalid_value(this);
   GotoIfNotJSReceiver(value, &throw_invalid_value);
 
-  Return(CallBuiltin(Builtins::kWeakCollectionSet, context, receiver, value,
+  Return(CallBuiltin(Builtin::kWeakCollectionSet, context, receiver, value,
                      TrueConstant()));
 
   BIND(&throw_invalid_value);
@@ -2914,8 +2914,7 @@ TF_BUILTIN(WeakSetPrototypeDelete, CodeStubAssembler) {
   ThrowIfNotInstanceType(context, receiver, JS_WEAK_SET_TYPE,
                          "WeakSet.prototype.delete");
 
-  Return(
-      CallBuiltin(Builtins::kWeakCollectionDelete, context, receiver, value));
+  Return(CallBuiltin(Builtin::kWeakCollectionDelete, context, receiver, value));
 }
 
 TF_BUILTIN(WeakSetPrototypeHas, WeakCollectionsBuiltinsAssembler) {
@@ -2930,7 +2929,7 @@ TF_BUILTIN(WeakSetPrototypeHas, WeakCollectionsBuiltinsAssembler) {
 
   const TNode<EphemeronHashTable> table = LoadTable(CAST(receiver));
   const TNode<Object> index =
-      CallBuiltin(Builtins::kWeakMapLookupHashIndex, context, table, key);
+      CallBuiltin(Builtin::kWeakMapLookupHashIndex, context, table, key);
 
   GotoIf(TaggedEqual(index, SmiConstant(-1)), &return_false);
 
diff --git a/src/builtins/builtins-console.cc b/src/builtins/builtins-console.cc
index c15f2f4393c..83e2ef08913 100644
--- a/src/builtins/builtins-console.cc
+++ b/src/builtins/builtins-console.cc
@@ -125,7 +125,7 @@ BUILTIN(ConsoleTimeStamp) {
 namespace {
 
 void InstallContextFunction(Isolate* isolate, Handle<JSObject> target,
-                            const char* name, Builtins::Name builtin_id,
+                            const char* name, Builtin builtin_id,
                             int context_id, Handle<Object> context_name) {
   Factory* const factory = isolate->factory();
 
@@ -163,7 +163,7 @@ BUILTIN(ConsoleContext) {
   Factory* const factory = isolate->factory();
   Handle<String> name = factory->InternalizeUtf8String("Context");
   Handle<SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name, Builtins::kIllegal);
+      factory->NewSharedFunctionInfoForBuiltin(name, Builtin::kIllegal);
   info->set_language_mode(LanguageMode::kSloppy);
 
   Handle<JSFunction> cons =
@@ -178,17 +178,17 @@ BUILTIN(ConsoleContext) {
   int id = isolate->last_console_context_id() + 1;
   isolate->set_last_console_context_id(id);
 
-#define CONSOLE_BUILTIN_SETUP(call, name)                                   \
-  InstallContextFunction(isolate, context, #name, Builtins::kConsole##call, \
-                         id, args.at(1));
+#define CONSOLE_BUILTIN_SETUP(call, name)                                      \
+  InstallContextFunction(isolate, context, #name, Builtin::kConsole##call, id, \
+                         args.at(1));
   CONSOLE_METHOD_LIST(CONSOLE_BUILTIN_SETUP)
 #undef CONSOLE_BUILTIN_SETUP
-  InstallContextFunction(isolate, context, "time", Builtins::kConsoleTime, id,
+  InstallContextFunction(isolate, context, "time", Builtin::kConsoleTime, id,
                          args.at(1));
-  InstallContextFunction(isolate, context, "timeEnd", Builtins::kConsoleTimeEnd,
+  InstallContextFunction(isolate, context, "timeEnd", Builtin::kConsoleTimeEnd,
                          id, args.at(1));
   InstallContextFunction(isolate, context, "timeStamp",
-                         Builtins::kConsoleTimeStamp, id, args.at(1));
+                         Builtin::kConsoleTimeStamp, id, args.at(1));
 
   return *context;
 }
diff --git a/src/builtins/builtins-constructor-gen.cc b/src/builtins/builtins-constructor-gen.cc
index 147bb44dffc..29b3bc31254 100644
--- a/src/builtins/builtins-constructor-gen.cc
+++ b/src/builtins/builtins-constructor-gen.cc
@@ -76,11 +76,10 @@ void CallOrConstructBuiltinsAssembler::BuildConstruct(
                            &if_construct_array, &allocation_site);
 
   BIND(&if_construct_generic);
-  TailCallBuiltin(Builtins::kConstruct, eager_context, target, new_target,
-                  argc);
+  TailCallBuiltin(Builtin::kConstruct, eager_context, target, new_target, argc);
 
   BIND(&if_construct_array);
-  TailCallBuiltin(Builtins::kArrayConstructorImpl, eager_context, target,
+  TailCallBuiltin(Builtin::kArrayConstructorImpl, eager_context, target,
                   new_target, argc, allocation_site.value());
 }
 
@@ -256,7 +255,7 @@ TF_BUILTIN(FastNewClosure, ConstructorBuiltinsAssembler) {
                                  shared_function_info);
   StoreObjectFieldNoWriteBarrier(result, JSFunction::kContextOffset, context);
   Handle<Code> lazy_builtin_handle =
-      isolate()->builtins()->builtin_handle(Builtins::kCompileLazy);
+      isolate()->builtins()->builtin_handle(Builtin::kCompileLazy);
   TNode<Code> lazy_builtin = HeapConstant(lazy_builtin_handle);
   StoreObjectFieldNoWriteBarrier(result, JSFunction::kCodeOffset, lazy_builtin);
   Return(result);
diff --git a/src/builtins/builtins-date-gen.cc b/src/builtins/builtins-date-gen.cc
index 6d43013501a..f8ca669d1dd 100644
--- a/src/builtins/builtins-date-gen.cc
+++ b/src/builtins/builtins-date-gen.cc
@@ -208,15 +208,15 @@ TF_BUILTIN(DatePrototypeToPrimitive, CodeStubAssembler) {
   GotoIf(TaggedIsSmi(hint), &hint_is_invalid);
   GotoIfNot(IsString(CAST(hint)), &hint_is_invalid);
   GotoIf(TaggedEqual(
-             CallBuiltin(Builtins::kStringEqual, context, hint, number_string),
+             CallBuiltin(Builtin::kStringEqual, context, hint, number_string),
              TrueConstant()),
          &hint_is_number);
   GotoIf(TaggedEqual(
-             CallBuiltin(Builtins::kStringEqual, context, hint, default_string),
+             CallBuiltin(Builtin::kStringEqual, context, hint, default_string),
              TrueConstant()),
          &hint_is_string);
   GotoIf(TaggedEqual(
-             CallBuiltin(Builtins::kStringEqual, context, hint, string_string),
+             CallBuiltin(Builtin::kStringEqual, context, hint, string_string),
              TrueConstant()),
          &hint_is_string);
   Goto(&hint_is_invalid);
diff --git a/src/builtins/builtins-generator-gen.cc b/src/builtins/builtins-generator-gen.cc
index b2d6e223e16..eb557b1ca15 100644
--- a/src/builtins/builtins-generator-gen.cc
+++ b/src/builtins/builtins-generator-gen.cc
@@ -87,7 +87,7 @@ void GeneratorBuiltinsAssembler::InnerResume(
     StoreObjectFieldNoWriteBarrier(
         receiver, JSGeneratorObject::kContinuationOffset, closed);
     // Return the wrapped result.
-    args->PopAndReturn(CallBuiltin(Builtins::kCreateIterResultObject, context,
+    args->PopAndReturn(CallBuiltin(Builtin::kCreateIterResultObject, context,
                                    result, TrueConstant()));
   }
 
@@ -97,11 +97,11 @@ void GeneratorBuiltinsAssembler::InnerResume(
     TNode<Object> result;
     switch (resume_mode) {
       case JSGeneratorObject::kNext:
-        result = CallBuiltin(Builtins::kCreateIterResultObject, context,
+        result = CallBuiltin(Builtin::kCreateIterResultObject, context,
                              UndefinedConstant(), TrueConstant());
         break;
       case JSGeneratorObject::kReturn:
-        result = CallBuiltin(Builtins::kCreateIterResultObject, context, value,
+        result = CallBuiltin(Builtin::kCreateIterResultObject, context, value,
                              TrueConstant());
         break;
       case JSGeneratorObject::kThrow:
diff --git a/src/builtins/builtins-global-gen.cc b/src/builtins/builtins-global-gen.cc
index d33fc3c37bd..1edfbbf80fa 100644
--- a/src/builtins/builtins-global-gen.cc
+++ b/src/builtins/builtins-global-gen.cc
@@ -46,7 +46,7 @@ TF_BUILTIN(GlobalIsFinite, CodeStubAssembler) {
     {
       // Need to convert {num_heap_object} to a Number first.
       var_num =
-          CallBuiltin(Builtins::kNonNumberToNumber, context, num_heap_object);
+          CallBuiltin(Builtin::kNonNumberToNumber, context, num_heap_object);
       Goto(&loop);
     }
   }
@@ -94,7 +94,7 @@ TF_BUILTIN(GlobalIsNaN, CodeStubAssembler) {
     {
       // Need to convert {num_heap_object} to a Number first.
       var_num =
-          CallBuiltin(Builtins::kNonNumberToNumber, context, num_heap_object);
+          CallBuiltin(Builtin::kNonNumberToNumber, context, num_heap_object);
       Goto(&loop);
     }
   }
diff --git a/src/builtins/builtins-internal-gen.cc b/src/builtins/builtins-internal-gen.cc
index 327ec922b1b..138779bf2ba 100644
--- a/src/builtins/builtins-internal-gen.cc
+++ b/src/builtins/builtins-internal-gen.cc
@@ -611,9 +611,9 @@ TF_BUILTIN(DeleteProperty, DeletePropertyBaseAssembler) {
 
   BIND(&if_proxy);
   {
-    TNode<Name> name = CAST(CallBuiltin(Builtins::kToName, context, key));
+    TNode<Name> name = CAST(CallBuiltin(Builtin::kToName, context, key));
     GotoIf(IsPrivateSymbol(name), &slow);
-    TailCallBuiltin(Builtins::kProxyDeleteProperty, context, receiver, name,
+    TailCallBuiltin(Builtin::kProxyDeleteProperty, context, receiver, name,
                     language_mode);
   }
 
@@ -678,7 +678,7 @@ class SetOrCopyDataPropertiesAssembler : public CodeStubAssembler {
         ForEachEnumerableOwnProperty(
             context, source_map, CAST(source), kEnumerationOrder,
             [=](TNode<Name> key, TNode<Object> value) {
-              CallBuiltin(Builtins::kSetPropertyInLiteral, context, target, key,
+              CallBuiltin(Builtin::kSetPropertyInLiteral, context, target, key,
                           value);
             },
             if_runtime);
@@ -1054,12 +1054,12 @@ TF_BUILTIN(GetProperty, CodeStubAssembler) {
   BIND(&if_proxy);
   {
     // Convert the {key} to a Name first.
-    TNode<Object> name = CallBuiltin(Builtins::kToName, context, key);
+    TNode<Object> name = CallBuiltin(Builtin::kToName, context, key);
 
     // The {object} is a JSProxy instance, look up the {name} on it, passing
     // {object} both as receiver and holder. If {name} is absent we can safely
     // return undefined from here.
-    TailCallBuiltin(Builtins::kProxyGetProperty, context, object, name, object,
+    TailCallBuiltin(Builtin::kProxyGetProperty, context, object, name, object,
                     SmiConstant(OnNonExistent::kReturnUndefined));
   }
 }
@@ -1119,7 +1119,7 @@ TF_BUILTIN(GetPropertyWithReceiver, CodeStubAssembler) {
   BIND(&if_proxy);
   {
     // Convert the {key} to a Name first.
-    TNode<Name> name = CAST(CallBuiltin(Builtins::kToName, context, key));
+    TNode<Name> name = CAST(CallBuiltin(Builtin::kToName, context, key));
 
     // Proxy cannot handle private symbol so bailout.
     GotoIf(IsPrivateSymbol(name), &if_slow);
@@ -1127,8 +1127,8 @@ TF_BUILTIN(GetPropertyWithReceiver, CodeStubAssembler) {
     // The {object} is a JSProxy instance, look up the {name} on it, passing
     // {object} both as receiver and holder. If {name} is absent we can safely
     // return undefined from here.
-    TailCallBuiltin(Builtins::kProxyGetProperty, context, object, name,
-                    receiver, on_non_existent);
+    TailCallBuiltin(Builtin::kProxyGetProperty, context, object, name, receiver,
+                    on_non_existent);
   }
 }
 
diff --git a/src/builtins/builtins-intl-gen.cc b/src/builtins/builtins-intl-gen.cc
index 42ccbebcbc9..6a9e0fbad4f 100644
--- a/src/builtins/builtins-intl-gen.cc
+++ b/src/builtins/builtins-intl-gen.cc
@@ -142,7 +142,7 @@ TF_BUILTIN(StringPrototypeToLowerCaseIntl, IntlBuiltinsAssembler) {
   TNode<String> string =
       ToThisString(context, maybe_string, "String.prototype.toLowerCase");
 
-  Return(CallBuiltin(Builtins::kStringToLowerCaseIntl, context, string));
+  Return(CallBuiltin(Builtin::kStringToLowerCaseIntl, context, string));
 }
 
 void IntlBuiltinsAssembler::ListFormatCommon(TNode<Context> context,
@@ -165,7 +165,7 @@ void IntlBuiltinsAssembler::ListFormatCommon(TNode<Context> context,
   {
     // 4. Let stringList be ? StringListFromIterable(list).
     TNode<Object> string_list =
-        CallBuiltin(Builtins::kStringListFromIterable, context, list);
+        CallBuiltin(Builtin::kStringListFromIterable, context, list);
 
     // 6. Return ? FormatList(lf, stringList).
     args.PopAndReturn(
diff --git a/src/builtins/builtins-intl.cc b/src/builtins/builtins-intl.cc
index 6febc81c3a5..8e56a93b950 100644
--- a/src/builtins/builtins-intl.cc
+++ b/src/builtins/builtins-intl.cc
@@ -223,7 +223,7 @@ namespace {
 
 Handle<JSFunction> CreateBoundFunction(Isolate* isolate,
                                        Handle<JSObject> object,
-                                       Builtins::Name builtin_id, int len) {
+                                       Builtin builtin_id, int len) {
   Handle<NativeContext> native_context(isolate->context().native_context(),
                                        isolate);
   Handle<Context> context = isolate->factory()->NewBuiltinContext(
@@ -469,7 +469,7 @@ BUILTIN(NumberFormatPrototypeFormatNumber) {
   }
 
   Handle<JSFunction> new_bound_format_function = CreateBoundFunction(
-      isolate, number_format, Builtins::kNumberFormatInternalFormatNumber, 1);
+      isolate, number_format, Builtin::kNumberFormatInternalFormatNumber, 1);
 
   // 4. c. Set nf.[[BoundFormat]] to F.
   number_format->set_bound_format(*new_bound_format_function);
@@ -541,7 +541,7 @@ BUILTIN(DateTimeFormatPrototypeFormat) {
   }
 
   Handle<JSFunction> new_bound_format_function = CreateBoundFunction(
-      isolate, format, Builtins::kDateTimeFormatInternalFormat, 1);
+      isolate, format, Builtin::kDateTimeFormatInternalFormat, 1);
 
   // 4.c. Set dtf.[[BoundFormat]] to F.
   format->set_bound_format(*new_bound_format_function);
@@ -964,7 +964,7 @@ BUILTIN(CollatorPrototypeCompare) {
   }
 
   Handle<JSFunction> new_bound_compare_function = CreateBoundFunction(
-      isolate, collator, Builtins::kCollatorInternalCompare, 2);
+      isolate, collator, Builtin::kCollatorInternalCompare, 2);
 
   // 4.c. Set collator.[[BoundCompare]] to F.
   collator->set_bound_compare(*new_bound_compare_function);
@@ -1113,7 +1113,7 @@ BUILTIN(V8BreakIteratorPrototypeAdoptText) {
   }
 
   Handle<JSFunction> new_bound_adopt_text_function = CreateBoundFunction(
-      isolate, break_iterator, Builtins::kV8BreakIteratorInternalAdoptText, 1);
+      isolate, break_iterator, Builtin::kV8BreakIteratorInternalAdoptText, 1);
   break_iterator->set_bound_adopt_text(*new_bound_adopt_text_function);
   return *new_bound_adopt_text_function;
 }
@@ -1149,7 +1149,7 @@ BUILTIN(V8BreakIteratorPrototypeFirst) {
   }
 
   Handle<JSFunction> new_bound_first_function = CreateBoundFunction(
-      isolate, break_iterator, Builtins::kV8BreakIteratorInternalFirst, 0);
+      isolate, break_iterator, Builtin::kV8BreakIteratorInternalFirst, 0);
   break_iterator->set_bound_first(*new_bound_first_function);
   return *new_bound_first_function;
 }
@@ -1179,7 +1179,7 @@ BUILTIN(V8BreakIteratorPrototypeNext) {
   }
 
   Handle<JSFunction> new_bound_next_function = CreateBoundFunction(
-      isolate, break_iterator, Builtins::kV8BreakIteratorInternalNext, 0);
+      isolate, break_iterator, Builtin::kV8BreakIteratorInternalNext, 0);
   break_iterator->set_bound_next(*new_bound_next_function);
   return *new_bound_next_function;
 }
@@ -1208,7 +1208,7 @@ BUILTIN(V8BreakIteratorPrototypeCurrent) {
   }
 
   Handle<JSFunction> new_bound_current_function = CreateBoundFunction(
-      isolate, break_iterator, Builtins::kV8BreakIteratorInternalCurrent, 0);
+      isolate, break_iterator, Builtin::kV8BreakIteratorInternalCurrent, 0);
   break_iterator->set_bound_current(*new_bound_current_function);
   return *new_bound_current_function;
 }
@@ -1237,7 +1237,7 @@ BUILTIN(V8BreakIteratorPrototypeBreakType) {
   }
 
   Handle<JSFunction> new_bound_break_type_function = CreateBoundFunction(
-      isolate, break_iterator, Builtins::kV8BreakIteratorInternalBreakType, 0);
+      isolate, break_iterator, Builtin::kV8BreakIteratorInternalBreakType, 0);
   break_iterator->set_bound_break_type(*new_bound_break_type_function);
   return *new_bound_break_type_function;
 }
diff --git a/src/builtins/builtins-iterator-gen.cc b/src/builtins/builtins-iterator-gen.cc
index 94be522c58b..d16474feaeb 100644
--- a/src/builtins/builtins-iterator-gen.cc
+++ b/src/builtins/builtins-iterator-gen.cc
@@ -305,10 +305,10 @@ TF_BUILTIN(IterableToListMayPreserveHoles, IteratorBuiltinsAssembler) {
   GotoIfNot(IsFastJSArrayWithNoCustomIteration(context, iterable), &slow_path);
 
   // The fast path will copy holes to the new array.
-  TailCallBuiltin(Builtins::kCloneFastJSArray, context, iterable);
+  TailCallBuiltin(Builtin::kCloneFastJSArray, context, iterable);
 
   BIND(&slow_path);
-  TailCallBuiltin(Builtins::kIterableToList, context, iterable, iterator_fn);
+  TailCallBuiltin(Builtin::kIterableToList, context, iterable, iterator_fn);
 }
 
 void IteratorBuiltinsAssembler::FastIterableToList(
@@ -323,7 +323,7 @@ void IteratorBuiltinsAssembler::FastIterableToList(
 
   // Fast path for fast JSArray.
   *var_result = CAST(
-      CallBuiltin(Builtins::kCloneFastJSArrayFillingHoles, context, iterable));
+      CallBuiltin(Builtin::kCloneFastJSArrayFillingHoles, context, iterable));
   Goto(&done);
 
   BIND(&check_string);
@@ -339,7 +339,7 @@ void IteratorBuiltinsAssembler::FastIterableToList(
     GotoIf(
         IntPtrGreaterThan(length, IntPtrConstant(JSArray::kMaxFastArrayLength)),
         slow);
-    *var_result = CAST(CallBuiltin(Builtins::kStringToList, context, iterable));
+    *var_result = CAST(CallBuiltin(Builtin::kStringToList, context, iterable));
     Goto(&done);
   }
 
@@ -351,7 +351,7 @@ void IteratorBuiltinsAssembler::FastIterableToList(
 
     BIND(&map_fast_call);
     *var_result =
-        CAST(CallBuiltin(Builtins::kMapIteratorToList, context, iterable));
+        CAST(CallBuiltin(Builtin::kMapIteratorToList, context, iterable));
     Goto(&done);
   }
 
@@ -363,7 +363,7 @@ void IteratorBuiltinsAssembler::FastIterableToList(
 
     BIND(&set_fast_call);
     *var_result =
-        CAST(CallBuiltin(Builtins::kSetOrSetIteratorToList, context, iterable));
+        CAST(CallBuiltin(Builtin::kSetOrSetIteratorToList, context, iterable));
     Goto(&done);
   }
 
@@ -403,7 +403,7 @@ TF_BUILTIN(IterableToListWithSymbolLookup, IteratorBuiltinsAssembler) {
   BIND(&slow_path);
   {
     TNode<Object> iterator_fn = GetIteratorMethod(context, iterable);
-    TailCallBuiltin(Builtins::kIterableToList, context, iterable, iterator_fn);
+    TailCallBuiltin(Builtin::kIterableToList, context, iterable, iterator_fn);
   }
 }
 
@@ -418,7 +418,7 @@ TF_BUILTIN(GetIteratorWithFeedbackLazyDeoptContinuation,
 
   // Note, that the builtin also expects the call_slot as a Smi.
   TNode<Object> result =
-      CallBuiltin(Builtins::kCallIteratorWithFeedback, context, receiver,
+      CallBuiltin(Builtin::kCallIteratorWithFeedback, context, receiver,
                   iterator_method, call_slot_smi, feedback);
   Return(result);
 }
@@ -431,7 +431,7 @@ TF_BUILTIN(IterableToFixedArrayWithSymbolLookupSlow,
   auto iterable = Parameter<Object>(Descriptor::kIterable);
 
   TNode<Object> iterator_fn = GetIteratorMethod(context, iterable);
-  TailCallBuiltin(Builtins::kIterableToFixedArray, context, iterable,
+  TailCallBuiltin(Builtin::kIterableToFixedArray, context, iterable,
                   iterator_fn);
 }
 
diff --git a/src/builtins/builtins-microtask-queue-gen.cc b/src/builtins/builtins-microtask-queue-gen.cc
index 281e9234dc7..64dd15bd1e4 100644
--- a/src/builtins/builtins-microtask-queue-gen.cc
+++ b/src/builtins/builtins-microtask-queue-gen.cc
@@ -207,7 +207,7 @@ void MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask(
 
     {
       ScopedExceptionHandler handler(this, &if_exception, &var_exception);
-      CallBuiltin(Builtins::kPromiseResolveThenableJob, native_context,
+      CallBuiltin(Builtin::kPromiseResolveThenableJob, native_context,
                   promise_to_resolve, thenable, then);
     }
 
@@ -251,7 +251,7 @@ void MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask(
 
     {
       ScopedExceptionHandler handler(this, &if_exception, &var_exception);
-      CallBuiltin(Builtins::kPromiseFulfillReactionJob, microtask_context,
+      CallBuiltin(Builtin::kPromiseFulfillReactionJob, microtask_context,
                   argument, job_handler, promise_or_capability);
     }
 
@@ -304,7 +304,7 @@ void MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask(
 
     {
       ScopedExceptionHandler handler(this, &if_exception, &var_exception);
-      CallBuiltin(Builtins::kPromiseRejectReactionJob, microtask_context,
+      CallBuiltin(Builtin::kPromiseRejectReactionJob, microtask_context,
                   argument, job_handler, promise_or_capability);
     }
 
diff --git a/src/builtins/builtins-object-gen.cc b/src/builtins/builtins-object-gen.cc
index 0030e01b94e..68112e5bffd 100644
--- a/src/builtins/builtins-object-gen.cc
+++ b/src/builtins/builtins-object-gen.cc
@@ -443,7 +443,7 @@ TF_BUILTIN(ObjectAssign, ObjectBuiltinsAssembler) {
   // 4. For each element nextSource of sources, in ascending index order,
   args.ForEach(
       [=](TNode<Object> next_source) {
-        CallBuiltin(Builtins::kSetDataProperties, context, to, next_source);
+        CallBuiltin(Builtin::kSetDataProperties, context, to, next_source);
       },
       IntPtrConstant(1));
   Goto(&done);
@@ -569,7 +569,7 @@ TF_BUILTIN(ObjectHasOwn, ObjectBuiltinsAssembler) {
   ThrowTypeError(context, MessageTemplate::kUndefinedOrNullToObject);
 
   BIND(&not_undefined_nor_null);
-  Return(CallBuiltin(Builtins::kObjectPrototypeHasOwnProperty, context, target,
+  Return(CallBuiltin(Builtin::kObjectPrototypeHasOwnProperty, context, target,
                      new_target, Int32Constant(2), object, key));
 }
 
@@ -1303,7 +1303,7 @@ TF_BUILTIN(ObjectGetOwnPropertyDescriptor, ObjectBuiltinsAssembler) {
   TNode<JSReceiver> object = ToObject_Inline(context, object_input);
 
   // 2. Let key be ? ToPropertyKey(P).
-  key = CallBuiltin(Builtins::kToName, context, key);
+  key = CallBuiltin(Builtin::kToName, context, key);
 
   // 3. Let desc be ? obj.[[GetOwnProperty]](key).
   Label if_keyisindex(this), if_iskeyunique(this),
diff --git a/src/builtins/builtins-regexp-gen.cc b/src/builtins/builtins-regexp-gen.cc
index e59d2a00ac3..638ff2ccb5b 100644
--- a/src/builtins/builtins-regexp-gen.cc
+++ b/src/builtins/builtins-regexp-gen.cc
@@ -53,7 +53,7 @@ TNode<RawPtrT> RegExpBuiltinsAssembler::LoadCodeObjectEntry(TNode<Code> code) {
   TNode<Int32T> builtin_index =
       LoadObjectField<Int32T>(code, Code::kBuiltinIndexOffset);
   {
-    GotoIfNot(Word32Equal(builtin_index, Int32Constant(Builtins::kNoBuiltinId)),
+    GotoIfNot(Word32Equal(builtin_index, Int32Constant(Builtin::kNoBuiltinId)),
               &if_code_is_off_heap);
     var_result = ReinterpretCast<RawPtrT>(
         IntPtrAdd(BitcastTaggedToWord(code),
@@ -226,7 +226,7 @@ TNode<JSRegExpResult> RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(
   // to avoid an unnecessary write barrier storing the first result.
 
   TNode<String> first =
-      CAST(CallBuiltin(Builtins::kSubString, context, string, start, end));
+      CAST(CallBuiltin(Builtin::kSubString, context, string, start, end));
 
   // Load flags and check if the result object needs to have indices.
   const TNode<Smi> flags =
@@ -269,7 +269,7 @@ TNode<JSRegExpResult> RegExpBuiltinsAssembler::ConstructNewResultFromMatchInfo(
         CAST(UnsafeLoadFixedArrayElement(match_info, from_cursor_plus1));
 
     TNode<String> capture =
-        CAST(CallBuiltin(Builtins::kSubString, context, string, start, end));
+        CAST(CallBuiltin(Builtin::kSubString, context, string, start, end));
     UnsafeStoreFixedArrayElement(result_elements, to_cursor, capture);
     Goto(&next_iter);
 
@@ -765,7 +765,7 @@ TNode<HeapObject> RegExpBuiltinsAssembler::RegExpExecInternal(
   {
     // TODO(jgruber): A call with 4 args stresses register allocation, this
     // should probably just be inlined.
-    var_result = CAST(CallBuiltin(Builtins::kRegExpExecAtom, context, regexp,
+    var_result = CAST(CallBuiltin(Builtin::kRegExpExecAtom, context, regexp,
                                   string, last_index, match_info));
     Goto(&out);
   }
@@ -961,7 +961,7 @@ TF_BUILTIN(RegExpExecAtom, RegExpBuiltinsAssembler) {
                                      IntPtrConstant(0)));
 
   const TNode<Smi> match_from =
-      CAST(CallBuiltin(Builtins::kStringIndexOf, context, subject_string,
+      CAST(CallBuiltin(Builtin::kStringIndexOf, context, subject_string,
                        needle_string, last_index));
 
   Label if_failure(this), if_success(this);
@@ -1588,7 +1588,7 @@ TNode<JSArray> RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(
           native_context, Context::REGEXP_LAST_MATCH_INFO_INDEX);
 
       const TNode<Object> match_indices =
-          CallBuiltin(Builtins::kRegExpExecInternal, context, regexp, string,
+          CallBuiltin(Builtin::kRegExpExecInternal, context, regexp, string,
                       SmiZero(), last_match_info);
 
       Label return_singleton_array(this);
@@ -1682,7 +1682,7 @@ TNode<JSArray> RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(
     {
       const TNode<Smi> from = last_matched_until;
       const TNode<Smi> to = match_from;
-      array.Push(CallBuiltin(Builtins::kSubString, context, string, from, to));
+      array.Push(CallBuiltin(Builtin::kSubString, context, string, from, to));
       GotoIf(WordEqual(array.length(), int_limit), &out);
     }
 
@@ -1718,7 +1718,7 @@ TNode<JSArray> RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(
         BIND(&select_capture);
         {
           var_value =
-              CallBuiltin(Builtins::kSubString, context, string, from, to);
+              CallBuiltin(Builtin::kSubString, context, string, from, to);
           Goto(&store_value);
         }
 
@@ -1753,7 +1753,7 @@ TNode<JSArray> RegExpBuiltinsAssembler::RegExpPrototypeSplitBody(
   {
     const TNode<Smi> from = var_last_matched_until.value();
     const TNode<Smi> to = string_length;
-    array.Push(CallBuiltin(Builtins::kSubString, context, string, from, to));
+    array.Push(CallBuiltin(Builtin::kSubString, context, string, from, to));
     Goto(&out);
   }
 
diff --git a/src/builtins/builtins-string-gen.cc b/src/builtins/builtins-string-gen.cc
index dc3a4ac364e..d0b480a98c8 100644
--- a/src/builtins/builtins-string-gen.cc
+++ b/src/builtins/builtins-string-gen.cc
@@ -955,9 +955,8 @@ const TNode<Smi> StringBuiltinsAssembler::IndexOfDollarChar(
     const TNode<Context> context, const TNode<String> string) {
   const TNode<String> dollar_string = HeapConstant(
       isolate()->factory()->LookupSingleCharacterStringFromCode('$'));
-  const TNode<Smi> dollar_ix =
-      CAST(CallBuiltin(Builtins::kStringIndexOf, context, string, dollar_string,
-                       SmiConstant(0)));
+  const TNode<Smi> dollar_ix = CAST(CallBuiltin(
+      Builtin::kStringIndexOf, context, string, dollar_string, SmiConstant(0)));
   return dollar_ix;
 }
 
@@ -987,7 +986,7 @@ TNode<String> StringBuiltinsAssembler::GetSubstitution(
     CSA_ASSERT(this, TaggedIsPositiveSmi(dollar_index));
 
     const TNode<Object> matched =
-        CallBuiltin(Builtins::kStringSubstring, context, subject_string,
+        CallBuiltin(Builtin::kStringSubstring, context, subject_string,
                     SmiUntag(match_start_index), SmiUntag(match_end_index));
     const TNode<String> replacement_string = CAST(
         CallRuntime(Runtime::kGetSubstitution, context, matched, subject_string,
@@ -1022,7 +1021,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
                                RootIndex::kreplace_symbol,
                                Context::REGEXP_REPLACE_FUNCTION_INDEX},
       [=]() {
-        Return(CallBuiltin(Builtins::kRegExpReplace, context, search, receiver,
+        Return(CallBuiltin(Builtin::kRegExpReplace, context, search, receiver,
                            replace));
       },
       [=](TNode<Object> fn) {
@@ -1071,7 +1070,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
   // (2-byte).
 
   const TNode<Smi> match_start_index =
-      CAST(CallBuiltin(Builtins::kStringIndexOf, context, subject_string,
+      CAST(CallBuiltin(Builtin::kStringIndexOf, context, subject_string,
                        search_string, smi_zero));
 
   // Early exit if no match found.
@@ -1109,7 +1108,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
 
     GotoIf(SmiEqual(match_start_index, smi_zero), &next);
     const TNode<String> prefix =
-        CAST(CallBuiltin(Builtins::kStringSubstring, context, subject_string,
+        CAST(CallBuiltin(Builtin::kStringSubstring, context, subject_string,
                          IntPtrConstant(0), SmiUntag(match_start_index)));
     var_result = prefix;
 
@@ -1131,7 +1130,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
              match_start_index, subject_string);
     const TNode<String> replacement_string =
         ToString_Inline(context, replacement);
-    var_result = CAST(CallBuiltin(Builtins::kStringAdd_CheckNone, context,
+    var_result = CAST(CallBuiltin(Builtin::kStringAdd_CheckNone, context,
                                   var_result.value(), replacement_string));
     Goto(&out);
   }
@@ -1142,7 +1141,7 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
     const TNode<Object> replacement =
         GetSubstitution(context, subject_string, match_start_index,
                         match_end_index, replace_string);
-    var_result = CAST(CallBuiltin(Builtins::kStringAdd_CheckNone, context,
+    var_result = CAST(CallBuiltin(Builtin::kStringAdd_CheckNone, context,
                                   var_result.value(), replacement));
     Goto(&out);
   }
@@ -1150,10 +1149,10 @@ TF_BUILTIN(StringPrototypeReplace, StringBuiltinsAssembler) {
   BIND(&out);
   {
     const TNode<Object> suffix =
-        CallBuiltin(Builtins::kStringSubstring, context, subject_string,
+        CallBuiltin(Builtin::kStringSubstring, context, subject_string,
                     SmiUntag(match_end_index), subject_length);
     const TNode<Object> result = CallBuiltin(
-        Builtins::kStringAdd_CheckNone, context, var_result.value(), suffix);
+        Builtin::kStringAdd_CheckNone, context, var_result.value(), suffix);
     Return(result);
   }
 }
@@ -1208,7 +1207,7 @@ TF_BUILTIN(StringPrototypeMatchAll, StringBuiltinsAssembler) {
       TNode<String> flags_string = ToString_Inline(context, flags);
       TNode<String> global_char_string = StringConstant("g");
       TNode<Smi> global_ix =
-          CAST(CallBuiltin(Builtins::kStringIndexOf, context, flags_string,
+          CAST(CallBuiltin(Builtin::kStringIndexOf, context, flags_string,
                            global_char_string, SmiConstant(0)));
       Branch(SmiEqual(global_ix, SmiConstant(-1)), &throw_exception, &next);
     }
@@ -1364,8 +1363,8 @@ TF_BUILTIN(StringPrototypeSplit, StringBuiltinsAssembler) {
                                RootIndex::ksplit_symbol,
                                Context::REGEXP_SPLIT_FUNCTION_INDEX},
       [&]() {
-        args.PopAndReturn(CallBuiltin(Builtins::kRegExpSplit, context,
-                                      separator, receiver, limit));
+        args.PopAndReturn(CallBuiltin(Builtin::kRegExpSplit, context, separator,
+                                      receiver, limit));
       },
       [&](TNode<Object> fn) {
         args.PopAndReturn(Call(context, fn, separator, receiver, limit));
diff --git a/src/builtins/builtins-trace.cc b/src/builtins/builtins-trace.cc
index 24baf59522b..9a5fc35a22d 100644
--- a/src/builtins/builtins-trace.cc
+++ b/src/builtins/builtins-trace.cc
@@ -123,7 +123,7 @@ BUILTIN(IsTraceCategoryEnabled) {
   return isolate->heap()->ToBoolean(enabled);
 }
 
-// Builtins::kTrace(phase, category, name, id, data) : bool
+// Builtin::kTrace(phase, category, name, id, data) : bool
 BUILTIN(Trace) {
   HandleScope handle_scope(isolate);
 
diff --git a/src/builtins/builtins-typed-array-gen.cc b/src/builtins/builtins-typed-array-gen.cc
index 9e12c55f9fd..15bbad23dd6 100644
--- a/src/builtins/builtins-typed-array-gen.cc
+++ b/src/builtins/builtins-typed-array-gen.cc
@@ -102,7 +102,7 @@ TF_BUILTIN(TypedArrayConstructor, TypedArrayBuiltinsAssembler) {
   Label throwtypeerror(this, Label::kDeferred);
   GotoIf(IsUndefined(new_target), &throwtypeerror);
 
-  TNode<Object> result = CallBuiltin(Builtins::kCreateTypedArray, context,
+  TNode<Object> result = CallBuiltin(Builtin::kCreateTypedArray, context,
                                      target, new_target, arg1, arg2, arg3);
   args.PopAndReturn(result);
 
diff --git a/src/builtins/builtins-utils-gen.h b/src/builtins/builtins-utils-gen.h
index 3a812b62b83..a274562c041 100644
--- a/src/builtins/builtins-utils-gen.h
+++ b/src/builtins/builtins-utils-gen.h
@@ -51,7 +51,7 @@ class CodeAssemblerState;
   void Builtins::Generate_##Name(compiler::CodeAssemblerState* state) {     \
     Name##Assembler assembler(state);                                       \
     state->SetInitialDebugInformation(#Name, __FILE__, __LINE__);           \
-    if (Builtins::KindOf(Builtins::k##Name) == Builtins::TFJ) {             \
+    if (Builtins::KindOf(Builtin::k##Name) == Builtins::TFJ) {              \
       assembler.PerformStackCheck(assembler.GetJSContextParameter());       \
     }                                                                       \
     assembler.Generate##Name##Impl();                                       \
diff --git a/src/builtins/builtins.cc b/src/builtins/builtins.cc
index 73302ba75cc..88b584f5a63 100644
--- a/src/builtins/builtins.cc
+++ b/src/builtins/builtins.cc
@@ -88,30 +88,30 @@ const BuiltinMetadata builtin_metadata[] = {BUILTIN_LIST(
 
 }  // namespace
 
-BytecodeOffset Builtins::GetContinuationBytecodeOffset(Name name) {
-  DCHECK(Builtins::KindOf(name) == TFJ || Builtins::KindOf(name) == TFC ||
-         Builtins::KindOf(name) == TFS);
-  return BytecodeOffset(BytecodeOffset::kFirstBuiltinContinuationId + name);
+BytecodeOffset Builtins::GetContinuationBytecodeOffset(Builtin builtin) {
+  DCHECK(Builtins::KindOf(builtin) == TFJ || Builtins::KindOf(builtin) == TFC ||
+         Builtins::KindOf(builtin) == TFS);
+  return BytecodeOffset(BytecodeOffset::kFirstBuiltinContinuationId + builtin);
 }
 
-Builtins::Name Builtins::GetBuiltinFromBytecodeOffset(BytecodeOffset id) {
+Builtin Builtins::GetBuiltinFromBytecodeOffset(BytecodeOffset id) {
   int builtin_index = id.ToInt() - BytecodeOffset::kFirstBuiltinContinuationId;
   DCHECK(Builtins::KindOf(builtin_index) == TFJ ||
          Builtins::KindOf(builtin_index) == TFC ||
          Builtins::KindOf(builtin_index) == TFS);
-  return static_cast<Name>(builtin_index);
+  return static_cast<Builtin>(builtin_index);
 }
 
 void Builtins::TearDown() { initialized_ = false; }
 
 const char* Builtins::Lookup(Address pc) {
   // Off-heap pc's can be looked up through binary search.
-  Builtins::Name builtin = InstructionStream::TryLookupCode(isolate_, pc);
+  Builtin builtin = InstructionStream::TryLookupCode(isolate_, pc);
   if (Builtins::IsBuiltinId(builtin)) return name(builtin);
 
   // May be called during initialization (disassembler).
   if (initialized_) {
-    for (int i = 0; i < builtin_count; i++) {
+    for (int i = 0; i < kBuiltinCount; i++) {
       if (isolate_->heap()->builtin(i).contains(isolate_, pc)) return name(i);
     }
   }
@@ -177,19 +177,19 @@ Handle<Code> Builtins::builtin_handle(int index) {
 }
 
 // static
-int Builtins::GetStackParameterCount(Name name) {
-  DCHECK(Builtins::KindOf(name) == TFJ);
-  return builtin_metadata[name].data.parameter_count;
+int Builtins::GetStackParameterCount(Builtin builtin) {
+  DCHECK(Builtins::KindOf(builtin) == TFJ);
+  return builtin_metadata[static_cast<int>(builtin)].data.parameter_count;
 }
 
 // static
-CallInterfaceDescriptor Builtins::CallInterfaceDescriptorFor(Name name) {
+CallInterfaceDescriptor Builtins::CallInterfaceDescriptorFor(Builtin builtin) {
   CallDescriptors::Key key;
-  switch (name) {
+  switch (builtin) {
 // This macro is deliberately crafted so as to emit very little code,
 // in order to keep binary size of this function under control.
 #define CASE_OTHER(Name, ...)                          \
-  case k##Name: {                                      \
+  case Builtin::k##Name: {                             \
     key = Builtin_##Name##_InterfaceDescriptor::key(); \
     break;                                             \
   }
@@ -197,7 +197,7 @@ CallInterfaceDescriptor Builtins::CallInterfaceDescriptorFor(Name name) {
                  CASE_OTHER, IGNORE_BUILTIN, CASE_OTHER)
 #undef CASE_OTHER
     default:
-      Builtins::Kind kind = Builtins::KindOf(name);
+      Builtins::Kind kind = Builtins::KindOf(builtin);
       DCHECK_NE(BCH, kind);
       if (kind == TFJ || kind == CPP) {
         return JSTrampolineDescriptor{};
@@ -208,16 +208,16 @@ CallInterfaceDescriptor Builtins::CallInterfaceDescriptorFor(Name name) {
 }
 
 // static
-Callable Builtins::CallableFor(Isolate* isolate, Name name) {
-  Handle<Code> code = isolate->builtins()->builtin_handle(name);
-  return Callable{code, CallInterfaceDescriptorFor(name)};
+Callable Builtins::CallableFor(Isolate* isolate, Builtin builtin) {
+  Handle<Code> code = isolate->builtins()->builtin_handle(builtin);
+  return Callable{code, CallInterfaceDescriptorFor(builtin)};
 }
 
 // static
 bool Builtins::HasJSLinkage(int builtin_index) {
-  Name name = static_cast<Name>(builtin_index);
-  DCHECK_NE(BCH, Builtins::KindOf(name));
-  return CallInterfaceDescriptorFor(name) == JSTrampolineDescriptor{};
+  Builtin index = static_cast<Builtin>(builtin_index);
+  DCHECK_NE(BCH, Builtins::KindOf(index));
+  return CallInterfaceDescriptorFor(index) == JSTrampolineDescriptor{};
 }
 
 // static
@@ -229,7 +229,7 @@ const char* Builtins::name(int index) {
 void Builtins::PrintBuiltinCode() {
   DCHECK(FLAG_print_builtin_code);
 #ifdef ENABLE_DISASSEMBLER
-  for (int i = 0; i < builtin_count; i++) {
+  for (int i = 0; i < kBuiltinCount; i++) {
     const char* builtin_name = name(i);
     Handle<Code> code = builtin_handle(i);
     if (PassesFilter(CStrVector(builtin_name),
@@ -245,7 +245,7 @@ void Builtins::PrintBuiltinCode() {
 
 void Builtins::PrintBuiltinSize() {
   DCHECK(FLAG_print_builtin_size);
-  for (int i = 0; i < builtin_count; i++) {
+  for (int i = 0; i < kBuiltinCount; i++) {
     const char* builtin_name = name(i);
     const char* kind = KindNameOf(i);
     Code code = builtin(i);
@@ -270,7 +270,7 @@ bool Builtins::IsBuiltinHandle(Handle<HeapObject> maybe_code,
   Heap* heap = isolate_->heap();
   Address handle_location = maybe_code.address();
   Address start = heap->builtin_address(0);
-  Address end = heap->builtin_address(Builtins::builtin_count);
+  Address end = heap->builtin_address(Builtins::kBuiltinCount);
   if (handle_location >= end) return false;
   if (handle_location < start) return false;
   *index = static_cast<int>(handle_location - start) >> kSystemPointerSizeLog2;
@@ -289,7 +289,7 @@ bool Builtins::IsIsolateIndependentBuiltin(const Code code) {
 void Builtins::InitializeBuiltinEntryTable(Isolate* isolate) {
   EmbeddedData d = EmbeddedData::FromBlob(isolate);
   Address* builtin_entry_table = isolate->builtin_entry_table();
-  for (int i = 0; i < builtin_count; i++) {
+  for (int i = 0; i < kBuiltinCount; i++) {
     // TODO(jgruber,chromium:1020986): Remove the CHECK once the linked issue is
     // resolved.
     CHECK(Builtins::IsBuiltinId(isolate->heap()->builtin(i).builtin_index()));
@@ -314,8 +314,8 @@ void Builtins::EmitCodeCreateEvents(Isolate* isolate) {
                                      Builtins::name(i)));
   }
 
-  STATIC_ASSERT(kLastBytecodeHandlerPlusOne == builtin_count);
-  for (; i < builtin_count; i++) {
+  STATIC_ASSERT(kLastBytecodeHandlerPlusOne == kBuiltinCount);
+  for (; i < kBuiltinCount; i++) {
     Handle<AbstractCode> code(AbstractCode::cast(Object(builtins[i])), isolate);
     interpreter::Bytecode bytecode =
         builtin_metadata[i].data.bytecode_and_scale.bytecode;
@@ -408,6 +408,10 @@ Handle<ByteArray> Builtins::GenerateOffHeapTrampolineRelocInfo(
   return reloc_info;
 }
 
+Builtins::Kind Builtins::KindOf(Builtin builtin) {
+  return KindOf(static_cast<int>(builtin));
+}
+
 // static
 Builtins::Kind Builtins::KindOf(int index) {
   DCHECK(IsBuiltinId(index));
@@ -473,25 +477,25 @@ bool Builtins::CodeObjectIsExecutable(int builtin_index) {
   // currently cause problems if they're not executable. This list should be
   // pared down as much as possible.
   switch (builtin_index) {
-    case Builtins::kInterpreterEntryTrampoline:
-    case Builtins::kCompileLazy:
-    case Builtins::kCompileLazyDeoptimizedCode:
-    case Builtins::kCallFunction_ReceiverIsNullOrUndefined:
-    case Builtins::kCallFunction_ReceiverIsNotNullOrUndefined:
-    case Builtins::kCallFunction_ReceiverIsAny:
-    case Builtins::kCallBoundFunction:
-    case Builtins::kCall_ReceiverIsNullOrUndefined:
-    case Builtins::kCall_ReceiverIsNotNullOrUndefined:
-    case Builtins::kCall_ReceiverIsAny:
-    case Builtins::kHandleApiCall:
-    case Builtins::kInstantiateAsmJs:
+    case Builtin::kInterpreterEntryTrampoline:
+    case Builtin::kCompileLazy:
+    case Builtin::kCompileLazyDeoptimizedCode:
+    case Builtin::kCallFunction_ReceiverIsNullOrUndefined:
+    case Builtin::kCallFunction_ReceiverIsNotNullOrUndefined:
+    case Builtin::kCallFunction_ReceiverIsAny:
+    case Builtin::kCallBoundFunction:
+    case Builtin::kCall_ReceiverIsNullOrUndefined:
+    case Builtin::kCall_ReceiverIsNotNullOrUndefined:
+    case Builtin::kCall_ReceiverIsAny:
+    case Builtin::kHandleApiCall:
+    case Builtin::kInstantiateAsmJs:
 #if V8_ENABLE_WEBASSEMBLY
-    case Builtins::kGenericJSToWasmWrapper:
+    case Builtin::kGenericJSToWasmWrapper:
 #endif  // V8_ENABLE_WEBASSEMBLY
 
     // TODO(delphick): Remove this when calls to it have the trampoline inlined
     // or are converted to use kCallBuiltinPointer.
-    case Builtins::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
+    case Builtin::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
       return true;
     default:
 #if V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64
@@ -505,12 +509,12 @@ bool Builtins::CodeObjectIsExecutable(int builtin_index) {
   }
 }
 
-Builtins::Name ExampleBuiltinForTorqueFunctionPointerType(
+Builtin ExampleBuiltinForTorqueFunctionPointerType(
     size_t function_pointer_type_id) {
   switch (function_pointer_type_id) {
 #define FUNCTION_POINTER_ID_CASE(id, name) \
   case id:                                 \
-    return Builtins::k##name;
+    return Builtin::k##name;
     TORQUE_FUNCTION_POINTER_TYPE_TO_BUILTIN_MAP(FUNCTION_POINTER_ID_CASE)
 #undef FUNCTION_POINTER_ID_CASE
     default:
diff --git a/src/builtins/builtins.h b/src/builtins/builtins.h
index bfd8d104710..f521e14449b 100644
--- a/src/builtins/builtins.h
+++ b/src/builtins/builtins.h
@@ -34,7 +34,20 @@ static constexpr T FirstFromVarArgs(T x, ...) noexcept {
 
 // Convenience macro to avoid generating named accessors for all builtins.
 #define BUILTIN_CODE(isolate, name) \
-  (isolate)->builtins()->builtin_handle(Builtins::k##name)
+  (isolate)->builtins()->builtin_handle(Builtin::k##name)
+
+enum Builtin : int32_t {
+  kNoBuiltinId = -1,
+#define DEF_ENUM(Name, ...) k##Name,
+  BUILTIN_LIST(DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM,
+               DEF_ENUM)
+#undef DEF_ENUM
+#define EXTRACT_NAME(Name, ...) k##Name,
+  // Define kFirstBytecodeHandler,
+  kFirstBytecodeHandler =
+      FirstFromVarArgs(BUILTIN_LIST_BYTECODE_HANDLERS(EXTRACT_NAME) 0)
+#undef EXTRACT_NAME
+};
 
 class Builtins {
  public:
@@ -48,82 +61,71 @@ class Builtins {
   // Disassembler support.
   const char* Lookup(Address pc);
 
-  enum Name : int32_t {
-    kNoBuiltinId = -1,
-#define DEF_ENUM(Name, ...) k##Name,
-    BUILTIN_LIST(DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM, DEF_ENUM,
-                 DEF_ENUM)
-#undef DEF_ENUM
-        builtin_count,
-
-#define EXTRACT_NAME(Name, ...) k##Name,
-    // Define kFirstBytecodeHandler,
-    kFirstBytecodeHandler =
-        FirstFromVarArgs(BUILTIN_LIST_BYTECODE_HANDLERS(EXTRACT_NAME) 0)
-#undef EXTRACT_NAME
-  };
+#define ADD_ONE(Name, ...) +1
+  static constexpr int kBuiltinCount = 0 BUILTIN_LIST(
+      ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE, ADD_ONE);
+#undef ADD_ONE
 
   static constexpr int kFirstWideBytecodeHandler =
-      kFirstBytecodeHandler + kNumberOfBytecodeHandlers;
+      Builtin::kFirstBytecodeHandler + kNumberOfBytecodeHandlers;
   static constexpr int kFirstExtraWideBytecodeHandler =
       kFirstWideBytecodeHandler + kNumberOfWideBytecodeHandlers;
   static constexpr int kLastBytecodeHandlerPlusOne =
       kFirstExtraWideBytecodeHandler + kNumberOfWideBytecodeHandlers;
-  STATIC_ASSERT(kLastBytecodeHandlerPlusOne == builtin_count);
+  STATIC_ASSERT(kLastBytecodeHandlerPlusOne == kBuiltinCount);
 
   static constexpr bool IsBuiltinId(int maybe_id) {
     STATIC_ASSERT(kNoBuiltinId == -1);
     return static_cast<uint32_t>(maybe_id) <
-           static_cast<uint32_t>(builtin_count);
+           static_cast<uint32_t>(kBuiltinCount);
   }
 
   // The different builtin kinds are documented in builtins-definitions.h.
   enum Kind { CPP, TFJ, TFC, TFS, TFH, BCH, ASM };
 
-  static BytecodeOffset GetContinuationBytecodeOffset(Name name);
-  static Name GetBuiltinFromBytecodeOffset(BytecodeOffset);
+  static BytecodeOffset GetContinuationBytecodeOffset(Builtin builtin);
+  static Builtin GetBuiltinFromBytecodeOffset(BytecodeOffset);
 
-  static Name GetRecordWriteStub(RememberedSetAction remembered_set_action,
-                                 SaveFPRegsMode fp_mode) {
+  static constexpr Builtin GetRecordWriteStub(
+      RememberedSetAction remembered_set_action, SaveFPRegsMode fp_mode) {
     switch (remembered_set_action) {
       case RememberedSetAction::kEmit:
         switch (fp_mode) {
           case SaveFPRegsMode::kIgnore:
-            return Builtins::kRecordWriteEmitRememberedSetIgnoreFP;
+            return Builtin::kRecordWriteEmitRememberedSetIgnoreFP;
           case SaveFPRegsMode::kSave:
-            return Builtins::kRecordWriteEmitRememberedSetSaveFP;
+            return Builtin::kRecordWriteEmitRememberedSetSaveFP;
         }
       case RememberedSetAction::kOmit:
         switch (fp_mode) {
           case SaveFPRegsMode::kIgnore:
-            return Builtins::kRecordWriteOmitRememberedSetIgnoreFP;
+            return Builtin::kRecordWriteOmitRememberedSetIgnoreFP;
           case SaveFPRegsMode::kSave:
-            return Builtins::kRecordWriteOmitRememberedSetSaveFP;
+            return Builtin::kRecordWriteOmitRememberedSetSaveFP;
         }
     }
-    UNREACHABLE();
   }
 
-  static constexpr Name GetEphemeronKeyBarrierStub(SaveFPRegsMode fp_mode) {
+  static constexpr Builtin GetEphemeronKeyBarrierStub(SaveFPRegsMode fp_mode) {
     switch (fp_mode) {
       case SaveFPRegsMode::kIgnore:
-        return Builtins::kEphemeronKeyBarrierIgnoreFP;
+        return Builtin::kEphemeronKeyBarrierIgnoreFP;
       case SaveFPRegsMode::kSave:
-        return Builtins::kEphemeronKeyBarrierSaveFP;
+        return Builtin::kEphemeronKeyBarrierSaveFP;
     }
   }
 
 #ifdef V8_IS_TSAN
-  static Name GetTSANRelaxedStoreStub(SaveFPRegsMode fp_mode, int size) {
+  static Builtin GetTSANRelaxedStoreStub(SaveFPRegsMode fp_mode, int size) {
     if (size == kInt32Size) {
       return fp_mode == SaveFPRegsMode::kIgnore
-                 ? Builtins::kTSANRelaxedStore32IgnoreFP
-                 : Builtins::kTSANRelaxedStore32SaveFP;
+                 ? Builtin::kTSANRelaxedStore32IgnoreFP
+                 : Builtin::kTSANRelaxedStore32SaveFP;
     } else {
       CHECK_EQ(size, kInt64Size);
       return fp_mode == SaveFPRegsMode::kIgnore
-                 ? Builtins::kTSANRelaxedStore64IgnoreFP
-                 : Builtins::kTSANRelaxedStore64SaveFP;
+                 ? Builtin::kTSANRelaxedStore64IgnoreFP
+                 : Builtin::kTSANRelaxedStore64SaveFP;
     }
   }
 #endif  // V8_IS_TSAN
@@ -142,11 +144,12 @@ class Builtins {
   V8_EXPORT_PRIVATE Code builtin(int index);
   V8_EXPORT_PRIVATE Handle<Code> builtin_handle(int index);
 
-  static CallInterfaceDescriptor CallInterfaceDescriptorFor(Name name);
-  V8_EXPORT_PRIVATE static Callable CallableFor(Isolate* isolate, Name name);
+  static CallInterfaceDescriptor CallInterfaceDescriptorFor(Builtin builtin);
+  V8_EXPORT_PRIVATE static Callable CallableFor(Isolate* isolate,
+                                                Builtin builtin);
   static bool HasJSLinkage(int index);
 
-  static int GetStackParameterCount(Name name);
+  static int GetStackParameterCount(Builtin builtin);
 
   static const char* name(int index);
 
@@ -159,6 +162,7 @@ class Builtins {
   static Address CppEntryOf(int index);
 
   static Kind KindOf(int index);
+  static Kind KindOf(Builtin builtin);
   static const char* KindNameOf(int index);
 
   static bool IsCpp(int index);
@@ -301,7 +305,7 @@ class Builtins {
   friend class SetupIsolateDelegate;
 };
 
-Builtins::Name ExampleBuiltinForTorqueFunctionPointerType(
+Builtin ExampleBuiltinForTorqueFunctionPointerType(
     size_t function_pointer_type_id);
 
 }  // namespace internal
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 6a01c61df15..f94395247e7 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -340,7 +340,7 @@ namespace {
 //   using JSEntryFunction = GeneratedCode<Address(
 //       Address root_register_value, MicrotaskQueue* microtask_queue)>;
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   Label invoke, handler_entry, exit;
   Label not_outermost_js, not_outermost_js_2;
 
@@ -452,18 +452,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
@@ -1641,8 +1640,8 @@ void Builtins::Generate_InterpreterEnterAtBytecode(MacroAssembler* masm) {
 }
 // static
 void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
-  auto descriptor = Builtins::CallInterfaceDescriptorFor(
-      Builtins::kBaselineOutOfLinePrologue);
+  auto descriptor =
+      Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register arg_count = descriptor.GetRegisterParameter(
       BaselineOutOfLinePrologueDescriptor::kJavaScriptCallArgCount);
   Register frame_size = descriptor.GetRegisterParameter(
diff --git a/src/builtins/mips/builtins-mips.cc b/src/builtins/mips/builtins-mips.cc
index 0b44a55c88a..d850e6516f4 100644
--- a/src/builtins/mips/builtins-mips.cc
+++ b/src/builtins/mips/builtins-mips.cc
@@ -348,7 +348,7 @@ constexpr int kPushedStackSpace =
 //
 // Passes through a0, a1, a2, a3 and stack to JSEntryTrampoline.
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   Label invoke, handler_entry, exit;
 
   int pushed_stack_space = kCArgsSlotsSize;
@@ -500,18 +500,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
@@ -1508,7 +1507,7 @@ void Generate_ContinueToBuiltinHelper(MacroAssembler* masm,
   __ Addu(sp, sp,
           Operand(BuiltinContinuationFrameConstants::kFixedFrameSizeFromFp));
   __ Pop(ra);
-  __ LoadEntryFromBuiltinIndex(t0);
+  __ LoadEntryFromBuiltin(t0);
   __ Jump(t0);
 }
 }  // namespace
diff --git a/src/builtins/mips64/builtins-mips64.cc b/src/builtins/mips64/builtins-mips64.cc
index eb2fdc5b5fa..08c9726fe34 100644
--- a/src/builtins/mips64/builtins-mips64.cc
+++ b/src/builtins/mips64/builtins-mips64.cc
@@ -481,7 +481,7 @@ namespace {
 //   using JSEntryFunction = GeneratedCode<Address(
 //       Address root_register_value, MicrotaskQueue* microtask_queue)>;
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   Label invoke, handler_entry, exit;
 
   {
@@ -665,18 +665,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
@@ -1526,7 +1525,7 @@ void Generate_ContinueToBuiltinHelper(MacroAssembler* masm,
   __ Daddu(sp, sp,
            Operand(BuiltinContinuationFrameConstants::kFixedFrameSizeFromFp));
   __ Pop(ra);
-  __ LoadEntryFromBuiltinIndex(t0);
+  __ LoadEntryFromBuiltin(t0);
   __ Jump(t0);
 }
 }  // namespace
diff --git a/src/builtins/ppc/builtins-ppc.cc b/src/builtins/ppc/builtins-ppc.cc
index 84078342b24..4f4036d853a 100644
--- a/src/builtins/ppc/builtins-ppc.cc
+++ b/src/builtins/ppc/builtins-ppc.cc
@@ -499,7 +499,7 @@ namespace {
 //   using JSEntryFunction = GeneratedCode<Address(
 //       Address root_register_value, MicrotaskQueue* microtask_queue)>;
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   // The register state is either:
   //   r3: root_register_value
   //   r4: code entry
@@ -669,18 +669,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
diff --git a/src/builtins/riscv64/builtins-riscv64.cc b/src/builtins/riscv64/builtins-riscv64.cc
index 5014c231c80..2a6e70dde96 100644
--- a/src/builtins/riscv64/builtins-riscv64.cc
+++ b/src/builtins/riscv64/builtins-riscv64.cc
@@ -520,7 +520,7 @@ namespace {
 //   using JSEntryFunction = GeneratedCode<Address(
 //       Address root_register_value, MicrotaskQueue* microtask_queue)>;
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   Label invoke, handler_entry, exit;
 
   {
@@ -697,18 +697,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
@@ -1065,8 +1064,8 @@ static void MaybeOptimizeCodeOrTailCallOptimizedCodeSlot(
 void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   UseScratchRegisterScope temps(masm);
   temps.Include(kScratchReg.bit() | kScratchReg2.bit());
-  auto descriptor = Builtins::CallInterfaceDescriptorFor(
-      Builtins::kBaselineOutOfLinePrologue);
+  auto descriptor =
+      Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
       BaselineOutOfLinePrologueDescriptor::kClosure);
   // Load the feedback vector from the closure.
@@ -1804,7 +1803,7 @@ void Generate_ContinueToBuiltinHelper(MacroAssembler* masm,
   __ Add64(sp, sp,
            Operand(BuiltinContinuationFrameConstants::kFixedFrameSizeFromFp));
   __ Pop(ra);
-  __ LoadEntryFromBuiltinIndex(t6);
+  __ LoadEntryFromBuiltin(t6);
   __ Jump(t6);
 }
 }  // namespace
diff --git a/src/builtins/s390/builtins-s390.cc b/src/builtins/s390/builtins-s390.cc
index 779779868f7..cbda1dd1849 100644
--- a/src/builtins/s390/builtins-s390.cc
+++ b/src/builtins/s390/builtins-s390.cc
@@ -496,7 +496,7 @@ constexpr int kPushedStackSpace =
 //   using JSEntryFunction = GeneratedCode<Address(
 //       Address root_register_value, MicrotaskQueue* microtask_queue)>;
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   // The register state is either:
   //   r2:                             root register value
   //   r3:                             code entry
@@ -704,18 +704,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
diff --git a/src/builtins/setup-builtins-internal.cc b/src/builtins/setup-builtins-internal.cc
index fbcfab56f43..a491eb700d7 100644
--- a/src/builtins/setup-builtins-internal.cc
+++ b/src/builtins/setup-builtins-internal.cc
@@ -101,9 +101,9 @@ Code BuildWithMacroAssembler(Isolate* isolate, int32_t builtin_index,
   int handler_table_offset = 0;
 
   // JSEntry builtins are a special case and need to generate a handler table.
-  DCHECK_EQ(Builtins::KindOf(Builtins::kJSEntry), Builtins::ASM);
-  DCHECK_EQ(Builtins::KindOf(Builtins::kJSConstructEntry), Builtins::ASM);
-  DCHECK_EQ(Builtins::KindOf(Builtins::kJSRunMicrotasksEntry), Builtins::ASM);
+  DCHECK_EQ(Builtins::KindOf(Builtin::kJSEntry), Builtins::ASM);
+  DCHECK_EQ(Builtins::KindOf(Builtin::kJSConstructEntry), Builtins::ASM);
+  DCHECK_EQ(Builtins::KindOf(Builtin::kJSRunMicrotasksEntry), Builtins::ASM);
   if (Builtins::IsJSEntryVariant(builtin_index)) {
     handler_table_offset = HandlerTable::EmitReturnTableStart(&masm);
     HandlerTable::EmitReturnEntry(
@@ -210,7 +210,7 @@ void SetupIsolateDelegate::PopulateWithPlaceholders(Isolate* isolate) {
   // support circular references between builtins.
   Builtins* builtins = isolate->builtins();
   HandleScope scope(isolate);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Handle<Code> placeholder = BuildPlaceholder(isolate, i);
     AddBuiltin(builtins, i, *placeholder);
   }
@@ -227,7 +227,7 @@ void SetupIsolateDelegate::ReplacePlaceholders(Isolate* isolate) {
       RelocInfo::ModeMask(RelocInfo::FULL_EMBEDDED_OBJECT) |
       RelocInfo::ModeMask(RelocInfo::COMPRESSED_EMBEDDED_OBJECT) |
       RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Code code = builtins->builtin(i);
     bool flush_icache = false;
     for (RelocIterator it(code, kRelocMask); !it.done(); it.next()) {
@@ -330,18 +330,18 @@ void SetupIsolateDelegate::SetupBuiltinsInternal(Isolate* isolate) {
 #undef BUILD_TFH
 #undef BUILD_BCH
 #undef BUILD_ASM
-  CHECK_EQ(Builtins::builtin_count, index);
+  CHECK_EQ(Builtins::kBuiltinCount, index);
 
   ReplacePlaceholders(isolate);
 
 #define SET_PROMISE_REJECTION_PREDICTION(Name) \
-  builtins->builtin(Builtins::k##Name).set_is_promise_rejection(true);
+  builtins->builtin(Builtin::k##Name).set_is_promise_rejection(true);
 
   BUILTIN_PROMISE_REJECTION_PREDICTION_LIST(SET_PROMISE_REJECTION_PREDICTION)
 #undef SET_PROMISE_REJECTION_PREDICTION
 
 #define SET_EXCEPTION_CAUGHT_PREDICTION(Name) \
-  builtins->builtin(Builtins::k##Name).set_is_exception_caught(true);
+  builtins->builtin(Builtin::k##Name).set_is_exception_caught(true);
 
   BUILTIN_EXCEPTION_CAUGHT_PREDICTION_LIST(SET_EXCEPTION_CAUGHT_PREDICTION)
 #undef SET_EXCEPTION_CAUGHT_PREDICTION
diff --git a/src/builtins/typed-array-from.tq b/src/builtins/typed-array-from.tq
index df9ebbf3b47..2b722a3a677 100644
--- a/src/builtins/typed-array-from.tq
+++ b/src/builtins/typed-array-from.tq
@@ -7,11 +7,11 @@
 namespace typed_array {
 const kBuiltinNameFrom: constexpr string = '%TypedArray%.from';
 
-type BuiltinsName extends int31 constexpr 'Builtins::Name';
+type BuiltinsName extends int31 constexpr 'Builtin';
 const kTypedArrayPrototypeValues: constexpr BuiltinsName
-    generates 'Builtins::kTypedArrayPrototypeValues';
+    generates 'Builtin::kTypedArrayPrototypeValues';
 const kArrayPrototypeValues: constexpr BuiltinsName
-    generates 'Builtins::kArrayPrototypeValues';
+    generates 'Builtin::kArrayPrototypeValues';
 
 extern builtin IterableToList(implicit context: Context)(JSAny, JSAny): JSArray;
 
@@ -90,7 +90,7 @@ TypedArrayFrom(js-implicit context: NativeContext, receiver: JSAny)(
         typeswitch (source) {
           case (sourceArray: JSArray): {
             // Check that the iterator function is exactly
-            // Builtins::kArrayPrototypeValues.
+            // Builtin::kArrayPrototypeValues.
             if (!TaggedEqual(
                     iteratorFn.shared_function_info.function_data,
                     SmiConstant(kArrayPrototypeValues))) {
@@ -108,7 +108,7 @@ TypedArrayFrom(js-implicit context: NativeContext, receiver: JSAny)(
             if (IsDetachedBuffer(sourceBuffer)) goto UseUserProvidedIterator;
 
             // Check that the iterator function is exactly
-            // Builtins::kTypedArrayPrototypeValues.
+            // Builtin::kTypedArrayPrototypeValues.
             if (!TaggedEqual(
                     iteratorFn.shared_function_info.function_data,
                     SmiConstant(kTypedArrayPrototypeValues)))
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index e031a50848b..fa2742f36a3 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -333,7 +333,7 @@ namespace {
 //   using JSEntryFunction = GeneratedCode<Address(
 //       Address root_register_value, MicrotaskQueue* microtask_queue)>;
 void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
-                             Builtins::Name entry_trampoline) {
+                             Builtin entry_trampoline) {
   Label invoke, handler_entry, exit;
   Label not_outermost_js, not_outermost_js_2;
 
@@ -506,18 +506,17 @@ void Generate_JSEntryVariant(MacroAssembler* masm, StackFrame::Type type,
 }  // namespace
 
 void Builtins::Generate_JSEntry(MacroAssembler* masm) {
-  Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kJSEntryTrampoline);
+  Generate_JSEntryVariant(masm, StackFrame::ENTRY, Builtin::kJSEntryTrampoline);
 }
 
 void Builtins::Generate_JSConstructEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::CONSTRUCT_ENTRY,
-                          Builtins::kJSConstructEntryTrampoline);
+                          Builtin::kJSConstructEntryTrampoline);
 }
 
 void Builtins::Generate_JSRunMicrotasksEntry(MacroAssembler* masm) {
   Generate_JSEntryVariant(masm, StackFrame::ENTRY,
-                          Builtins::kRunMicrotasksTrampoline);
+                          Builtin::kRunMicrotasksTrampoline);
 }
 
 static void Generate_JSEntryTrampolineHelper(MacroAssembler* masm,
@@ -1634,8 +1633,8 @@ void Builtins::Generate_BaselineOutOfLinePrologue(MacroAssembler* masm) {
   }
 #endif
 
-  auto descriptor = Builtins::CallInterfaceDescriptorFor(
-      Builtins::kBaselineOutOfLinePrologue);
+  auto descriptor =
+      Builtins::CallInterfaceDescriptorFor(Builtin::kBaselineOutOfLinePrologue);
   Register closure = descriptor.GetRegisterParameter(
       BaselineOutOfLinePrologueDescriptor::kClosure);
   // Load the feedback vector from the closure.
diff --git a/src/codegen/arm/macro-assembler-arm.cc b/src/codegen/arm/macro-assembler-arm.cc
index f3dea03d92f..98a718bb460 100644
--- a/src/codegen/arm/macro-assembler-arm.cc
+++ b/src/codegen/arm/macro-assembler-arm.cc
@@ -166,7 +166,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().use_pc_relative_calls_and_jumps,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
 
@@ -181,7 +181,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
     UseScratchRegisterScope temps(this);
     Register scratch = temps.Acquire();
     int offset = IsolateData::builtin_entry_slot_offset(
-        static_cast<Builtins::Name>(code->builtin_index()));
+        static_cast<Builtin>(code->builtin_index()));
     ldr(scratch, MemOperand(kRootRegister, offset));
     Jump(scratch, cond);
     return;
@@ -258,7 +258,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().use_pc_relative_calls_and_jumps,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
 
@@ -271,7 +271,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
     // creation at runtime. At this point, Code space isn't restricted to a
     // size s.t. pc-relative calls may be used.
     int offset = IsolateData::builtin_entry_slot_offset(
-        static_cast<Builtins::Name>(code->builtin_index()));
+        static_cast<Builtin>(code->builtin_index()));
     ldr(ip, MemOperand(kRootRegister, offset));
     Call(ip, cond);
     return;
@@ -306,13 +306,12 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
   Call(builtin_index);
 }
 
-void TurboAssembler::LoadEntryFromBuiltinIndex(Builtins::Name builtin_index,
-                                               Register destination) {
-  ldr(destination, EntryFromBuiltinIndexAsOperand(builtin_index));
+void TurboAssembler::LoadEntryFromBuiltin(Builtin builtin_index,
+                                          Register destination) {
+  ldr(destination, EntryFromBuiltinAsOperand(builtin_index));
 }
 
-MemOperand TurboAssembler::EntryFromBuiltinIndexAsOperand(
-    Builtins::Name builtin_index) {
+MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
   DCHECK(root_array_available());
   return MemOperand(kRootRegister,
                     IsolateData::builtin_entry_slot_offset(builtin_index));
@@ -1917,7 +1916,7 @@ void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,
   if (false) {
 #endif  // V8_ENABLE_WEBASSEMBLY
   } else if (options().inline_offheap_trampolines) {
-    CallBuiltin(Builtins::kDoubleToI);
+    CallBuiltin(Builtin::kDoubleToI);
   } else {
     Call(BUILTIN_CODE(isolate, DoubleToI), RelocInfo::CODE_TARGET);
   }
@@ -2609,9 +2608,9 @@ void TurboAssembler::ResetSpeculationPoisonRegister() {
   mov(kSpeculationPoisonRegister, Operand(-1));
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   BlockConstPoolScope block_const_pool(this);
   ldr(ip, MemOperand(kRootRegister,
                      IsolateData::builtin_entry_slot_offset(target)));
diff --git a/src/codegen/arm/macro-assembler-arm.h b/src/codegen/arm/macro-assembler-arm.h
index 7363c47f235..7aab2a476c4 100644
--- a/src/codegen/arm/macro-assembler-arm.h
+++ b/src/codegen/arm/macro-assembler-arm.h
@@ -310,9 +310,8 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
             bool check_constant_pool = true);
   void Call(Label* target);
 
-  MemOperand EntryFromBuiltinIndexAsOperand(Builtins::Name builtin_index);
-  void LoadEntryFromBuiltinIndex(Builtins::Name builtin_index,
-                                 Register destination);
+  MemOperand EntryFromBuiltinAsOperand(Builtin builtin_index);
+  void LoadEntryFromBuiltin(Builtin builtin_index, Register destination);
   // Load the builtin given by the Smi in |builtin_index| into the same
   // register.
   void LoadEntryFromBuiltinIndex(Register builtin_index);
@@ -329,7 +328,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // The return address on the stack is used by frame iteration.
   void StoreReturnAddressAndCall(Register target);
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/arm64/macro-assembler-arm64.cc b/src/codegen/arm64/macro-assembler-arm64.cc
index 8ccc47c3566..57c1e531c60 100644
--- a/src/codegen/arm64/macro-assembler-arm64.cc
+++ b/src/codegen/arm64/macro-assembler-arm64.cc
@@ -1829,7 +1829,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index)) {
       // Inline the trampoline.
       CHECK_EQ(cond, Condition::al);  // Implement if necessary.
@@ -1877,7 +1877,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode) {
   BlockPoolsScope scope(this);
 
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index)) {
       // Inline the trampoline.
       CallBuiltin(builtin_index);
@@ -1924,13 +1924,12 @@ void TurboAssembler::LoadEntryFromBuiltinIndex(Register builtin_index) {
   }
 }
 
-void TurboAssembler::LoadEntryFromBuiltinIndex(Builtins::Name builtin_index,
-                                               Register destination) {
-  Ldr(destination, EntryFromBuiltinIndexAsOperand(builtin_index));
+void TurboAssembler::LoadEntryFromBuiltin(Builtin builtin_index,
+                                          Register destination) {
+  Ldr(destination, EntryFromBuiltinAsOperand(builtin_index));
 }
 
-MemOperand TurboAssembler::EntryFromBuiltinIndexAsOperand(
-    Builtins::Name builtin_index) {
+MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
   DCHECK(root_array_available());
   return MemOperand(kRootRegister,
                     IsolateData::builtin_entry_slot_offset(builtin_index));
@@ -1944,7 +1943,7 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
 void TurboAssembler::CallBuiltin(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
@@ -1964,7 +1963,7 @@ void TurboAssembler::CallBuiltin(int builtin_index) {
 void TurboAssembler::TailCallBuiltin(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
@@ -2100,8 +2099,8 @@ bool TurboAssembler::IsNearCallOffset(int64_t offset) {
 }
 
 void TurboAssembler::CallForDeoptimization(
-    Builtins::Name target, int deopt_id, Label* exit, DeoptimizeKind kind,
-    Label* ret, Label* jump_deoptimization_entry_label) {
+    Builtin target, int deopt_id, Label* exit, DeoptimizeKind kind, Label* ret,
+    Label* jump_deoptimization_entry_label) {
   BlockPoolsScope scope(this);
   bl(jump_deoptimization_entry_label);
   DCHECK_EQ(SizeOfCodeGeneratedSince(exit),
@@ -2496,7 +2495,7 @@ void TurboAssembler::TruncateDoubleToI(Isolate* isolate, Zone* zone,
   if (false) {
 #endif  // V8_ENABLE_WEBASSEMBLY
   } else if (options().inline_offheap_trampolines) {
-    CallBuiltin(Builtins::kDoubleToI);
+    CallBuiltin(Builtin::kDoubleToI);
   } else {
     Call(BUILTIN_CODE(isolate, DoubleToI), RelocInfo::CODE_TARGET);
   }
diff --git a/src/codegen/arm64/macro-assembler-arm64.h b/src/codegen/arm64/macro-assembler-arm64.h
index df5814ba15c..9cf2b5318a7 100644
--- a/src/codegen/arm64/macro-assembler-arm64.h
+++ b/src/codegen/arm64/macro-assembler-arm64.h
@@ -973,17 +973,16 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // Load the builtin given by the Smi in |builtin_index| into the same
   // register.
   void LoadEntryFromBuiltinIndex(Register builtin_index);
-  void LoadEntryFromBuiltinIndex(Builtins::Name builtin_index,
-                                 Register destination);
-  MemOperand EntryFromBuiltinIndexAsOperand(Builtins::Name builtin_index);
+  void LoadEntryFromBuiltin(Builtin builtin_index, Register destination);
+  MemOperand EntryFromBuiltinAsOperand(Builtin builtin_index);
   void CallBuiltinByIndex(Register builtin_index);
-  void CallBuiltin(Builtins::Name builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtins::Name one.
+  void CallBuiltin(Builtin builtin) {
+    // TODO(11527): drop the int overload in favour of the Builtin one.
     return CallBuiltin(static_cast<int>(builtin));
   }
   void CallBuiltin(int builtin_index);
-  void TailCallBuiltin(Builtins::Name builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtins::Name one.
+  void TailCallBuiltin(Builtin builtin) {
+    // TODO(11527): drop the int overload in favour of the Builtin one.
     return TailCallBuiltin(static_cast<int>(builtin));
   }
   void TailCallBuiltin(int builtin_index);
@@ -998,7 +997,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // The return address on the stack is used by frame iteration.
   void StoreReturnAddressAndCall(Register target);
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/code-factory.cc b/src/codegen/code-factory.cc
index 854969f8cb4..26760e8567d 100644
--- a/src/codegen/code-factory.cc
+++ b/src/codegen/code-factory.cc
@@ -70,61 +70,61 @@ Handle<Code> CodeFactory::CEntry(Isolate* isolate, int result_size,
 
 // static
 Callable CodeFactory::ApiGetter(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kCallApiGetter);
+  return Builtins::CallableFor(isolate, Builtin::kCallApiGetter);
 }
 
 // static
 Callable CodeFactory::CallApiCallback(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kCallApiCallback);
+  return Builtins::CallableFor(isolate, Builtin::kCallApiCallback);
 }
 
 // static
 Callable CodeFactory::LoadGlobalIC(Isolate* isolate, TypeofMode typeof_mode) {
   return typeof_mode == TypeofMode::kNotInside
-             ? Builtins::CallableFor(isolate, Builtins::kLoadGlobalICTrampoline)
+             ? Builtins::CallableFor(isolate, Builtin::kLoadGlobalICTrampoline)
              : Builtins::CallableFor(
-                   isolate, Builtins::kLoadGlobalICInsideTypeofTrampoline);
+                   isolate, Builtin::kLoadGlobalICInsideTypeofTrampoline);
 }
 
 // static
 Callable CodeFactory::LoadGlobalICInOptimizedCode(Isolate* isolate,
                                                   TypeofMode typeof_mode) {
   return typeof_mode == TypeofMode::kNotInside
-             ? Builtins::CallableFor(isolate, Builtins::kLoadGlobalIC)
+             ? Builtins::CallableFor(isolate, Builtin::kLoadGlobalIC)
              : Builtins::CallableFor(isolate,
-                                     Builtins::kLoadGlobalICInsideTypeof);
+                                     Builtin::kLoadGlobalICInsideTypeof);
 }
 
 Callable CodeFactory::StoreOwnIC(Isolate* isolate) {
   // TODO(ishell): Currently we use StoreOwnIC only for storing properties that
   // already exist in the boilerplate therefore we can use StoreIC.
-  return Builtins::CallableFor(isolate, Builtins::kStoreICTrampoline);
+  return Builtins::CallableFor(isolate, Builtin::kStoreICTrampoline);
 }
 
 Callable CodeFactory::StoreOwnICInOptimizedCode(Isolate* isolate) {
   // TODO(ishell): Currently we use StoreOwnIC only for storing properties that
   // already exist in the boilerplate therefore we can use StoreIC.
-  return Builtins::CallableFor(isolate, Builtins::kStoreIC);
+  return Builtins::CallableFor(isolate, Builtin::kStoreIC);
 }
 
 Callable CodeFactory::KeyedStoreIC_SloppyArguments(Isolate* isolate,
                                                    KeyedAccessStoreMode mode) {
-  Builtins::Name builtin_index;
+  Builtin builtin_index;
   switch (mode) {
     case STANDARD_STORE:
-      builtin_index = Builtins::kKeyedStoreIC_SloppyArguments_Standard;
+      builtin_index = Builtin::kKeyedStoreIC_SloppyArguments_Standard;
       break;
     case STORE_AND_GROW_HANDLE_COW:
       builtin_index =
-          Builtins::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW;
+          Builtin::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW;
       break;
     case STORE_IGNORE_OUT_OF_BOUNDS:
       builtin_index =
-          Builtins::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB;
+          Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB;
       break;
     case STORE_HANDLE_COW:
       builtin_index =
-          Builtins::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW;
+          Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW;
       break;
     default:
       UNREACHABLE();
@@ -134,22 +134,22 @@ Callable CodeFactory::KeyedStoreIC_SloppyArguments(Isolate* isolate,
 
 Callable CodeFactory::ElementsTransitionAndStore(Isolate* isolate,
                                                  KeyedAccessStoreMode mode) {
-  Builtins::Name builtin_index;
+  Builtin builtin_index;
   switch (mode) {
     case STANDARD_STORE:
-      builtin_index = Builtins::kElementsTransitionAndStore_Standard;
+      builtin_index = Builtin::kElementsTransitionAndStore_Standard;
       break;
     case STORE_AND_GROW_HANDLE_COW:
       builtin_index =
-          Builtins::kElementsTransitionAndStore_GrowNoTransitionHandleCOW;
+          Builtin::kElementsTransitionAndStore_GrowNoTransitionHandleCOW;
       break;
     case STORE_IGNORE_OUT_OF_BOUNDS:
       builtin_index =
-          Builtins::kElementsTransitionAndStore_NoTransitionIgnoreOOB;
+          Builtin::kElementsTransitionAndStore_NoTransitionIgnoreOOB;
       break;
     case STORE_HANDLE_COW:
       builtin_index =
-          Builtins::kElementsTransitionAndStore_NoTransitionHandleCOW;
+          Builtin::kElementsTransitionAndStore_NoTransitionHandleCOW;
       break;
     default:
       UNREACHABLE();
@@ -159,19 +159,19 @@ Callable CodeFactory::ElementsTransitionAndStore(Isolate* isolate,
 
 Callable CodeFactory::StoreFastElementIC(Isolate* isolate,
                                          KeyedAccessStoreMode mode) {
-  Builtins::Name builtin_index;
+  Builtin builtin_index;
   switch (mode) {
     case STANDARD_STORE:
-      builtin_index = Builtins::kStoreFastElementIC_Standard;
+      builtin_index = Builtin::kStoreFastElementIC_Standard;
       break;
     case STORE_AND_GROW_HANDLE_COW:
-      builtin_index = Builtins::kStoreFastElementIC_GrowNoTransitionHandleCOW;
+      builtin_index = Builtin::kStoreFastElementIC_GrowNoTransitionHandleCOW;
       break;
     case STORE_IGNORE_OUT_OF_BOUNDS:
-      builtin_index = Builtins::kStoreFastElementIC_NoTransitionIgnoreOOB;
+      builtin_index = Builtin::kStoreFastElementIC_NoTransitionIgnoreOOB;
       break;
     case STORE_HANDLE_COW:
-      builtin_index = Builtins::kStoreFastElementIC_NoTransitionHandleCOW;
+      builtin_index = Builtin::kStoreFastElementIC_NoTransitionHandleCOW;
       break;
     default:
       UNREACHABLE();
@@ -183,27 +183,27 @@ Callable CodeFactory::StoreFastElementIC(Isolate* isolate,
 Callable CodeFactory::BinaryOperation(Isolate* isolate, Operation op) {
   switch (op) {
     case Operation::kShiftRight:
-      return Builtins::CallableFor(isolate, Builtins::kShiftRight);
+      return Builtins::CallableFor(isolate, Builtin::kShiftRight);
     case Operation::kShiftLeft:
-      return Builtins::CallableFor(isolate, Builtins::kShiftLeft);
+      return Builtins::CallableFor(isolate, Builtin::kShiftLeft);
     case Operation::kShiftRightLogical:
-      return Builtins::CallableFor(isolate, Builtins::kShiftRightLogical);
+      return Builtins::CallableFor(isolate, Builtin::kShiftRightLogical);
     case Operation::kAdd:
-      return Builtins::CallableFor(isolate, Builtins::kAdd);
+      return Builtins::CallableFor(isolate, Builtin::kAdd);
     case Operation::kSubtract:
-      return Builtins::CallableFor(isolate, Builtins::kSubtract);
+      return Builtins::CallableFor(isolate, Builtin::kSubtract);
     case Operation::kMultiply:
-      return Builtins::CallableFor(isolate, Builtins::kMultiply);
+      return Builtins::CallableFor(isolate, Builtin::kMultiply);
     case Operation::kDivide:
-      return Builtins::CallableFor(isolate, Builtins::kDivide);
+      return Builtins::CallableFor(isolate, Builtin::kDivide);
     case Operation::kModulus:
-      return Builtins::CallableFor(isolate, Builtins::kModulus);
+      return Builtins::CallableFor(isolate, Builtin::kModulus);
     case Operation::kBitwiseOr:
-      return Builtins::CallableFor(isolate, Builtins::kBitwiseOr);
+      return Builtins::CallableFor(isolate, Builtin::kBitwiseOr);
     case Operation::kBitwiseAnd:
-      return Builtins::CallableFor(isolate, Builtins::kBitwiseAnd);
+      return Builtins::CallableFor(isolate, Builtin::kBitwiseAnd);
     case Operation::kBitwiseXor:
-      return Builtins::CallableFor(isolate, Builtins::kBitwiseXor);
+      return Builtins::CallableFor(isolate, Builtin::kBitwiseXor);
     default:
       break;
   }
@@ -228,18 +228,18 @@ Callable CodeFactory::OrdinaryToPrimitive(Isolate* isolate,
 Callable CodeFactory::StringAdd(Isolate* isolate, StringAddFlags flags) {
   switch (flags) {
     case STRING_ADD_CHECK_NONE:
-      return Builtins::CallableFor(isolate, Builtins::kStringAdd_CheckNone);
+      return Builtins::CallableFor(isolate, Builtin::kStringAdd_CheckNone);
     case STRING_ADD_CONVERT_LEFT:
-      return Builtins::CallableFor(isolate, Builtins::kStringAddConvertLeft);
+      return Builtins::CallableFor(isolate, Builtin::kStringAddConvertLeft);
     case STRING_ADD_CONVERT_RIGHT:
-      return Builtins::CallableFor(isolate, Builtins::kStringAddConvertRight);
+      return Builtins::CallableFor(isolate, Builtin::kStringAddConvertRight);
   }
   UNREACHABLE();
 }
 
 // static
 Callable CodeFactory::ResumeGenerator(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kResumeGeneratorTrampoline);
+  return Builtins::CallableFor(isolate, Builtin::kResumeGeneratorTrampoline);
 }
 
 // static
@@ -248,10 +248,10 @@ Callable CodeFactory::FastNewFunctionContext(Isolate* isolate,
   switch (scope_type) {
     case ScopeType::EVAL_SCOPE:
       return Builtins::CallableFor(isolate,
-                                   Builtins::kFastNewFunctionContextEval);
+                                   Builtin::kFastNewFunctionContextEval);
     case ScopeType::FUNCTION_SCOPE:
       return Builtins::CallableFor(isolate,
-                                   Builtins::kFastNewFunctionContextFunction);
+                                   Builtin::kFastNewFunctionContextFunction);
     default:
       UNREACHABLE();
   }
@@ -268,25 +268,25 @@ Callable CodeFactory::Call_WithFeedback(Isolate* isolate,
   switch (mode) {
     case ConvertReceiverMode::kNullOrUndefined:
       return Builtins::CallableFor(
-          isolate, Builtins::kCall_ReceiverIsNullOrUndefined_WithFeedback);
+          isolate, Builtin::kCall_ReceiverIsNullOrUndefined_WithFeedback);
     case ConvertReceiverMode::kNotNullOrUndefined:
       return Builtins::CallableFor(
-          isolate, Builtins::kCall_ReceiverIsNotNullOrUndefined_WithFeedback);
+          isolate, Builtin::kCall_ReceiverIsNotNullOrUndefined_WithFeedback);
     case ConvertReceiverMode::kAny:
       return Builtins::CallableFor(isolate,
-                                   Builtins::kCall_ReceiverIsAny_WithFeedback);
+                                   Builtin::kCall_ReceiverIsAny_WithFeedback);
   }
   UNREACHABLE();
 }
 
 // static
 Callable CodeFactory::CallWithArrayLike(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kCallWithArrayLike);
+  return Builtins::CallableFor(isolate, Builtin::kCallWithArrayLike);
 }
 
 // static
 Callable CodeFactory::CallWithSpread(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kCallWithSpread);
+  return Builtins::CallableFor(isolate, Builtin::kCallWithSpread);
 }
 
 // static
@@ -297,48 +297,48 @@ Callable CodeFactory::CallFunction(Isolate* isolate, ConvertReceiverMode mode) {
 
 // static
 Callable CodeFactory::CallVarargs(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kCallVarargs);
+  return Builtins::CallableFor(isolate, Builtin::kCallVarargs);
 }
 
 // static
 Callable CodeFactory::CallForwardVarargs(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kCallForwardVarargs);
+  return Builtins::CallableFor(isolate, Builtin::kCallForwardVarargs);
 }
 
 // static
 Callable CodeFactory::CallFunctionForwardVarargs(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kCallFunctionForwardVarargs);
+  return Builtins::CallableFor(isolate, Builtin::kCallFunctionForwardVarargs);
 }
 
 // static
 Callable CodeFactory::Construct(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kConstruct);
+  return Builtins::CallableFor(isolate, Builtin::kConstruct);
 }
 
 // static
 Callable CodeFactory::ConstructWithSpread(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kConstructWithSpread);
+  return Builtins::CallableFor(isolate, Builtin::kConstructWithSpread);
 }
 
 // static
 Callable CodeFactory::ConstructFunction(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kConstructFunction);
+  return Builtins::CallableFor(isolate, Builtin::kConstructFunction);
 }
 
 // static
 Callable CodeFactory::ConstructVarargs(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kConstructVarargs);
+  return Builtins::CallableFor(isolate, Builtin::kConstructVarargs);
 }
 
 // static
 Callable CodeFactory::ConstructForwardVarargs(Isolate* isolate) {
-  return Builtins::CallableFor(isolate, Builtins::kConstructForwardVarargs);
+  return Builtins::CallableFor(isolate, Builtin::kConstructForwardVarargs);
 }
 
 // static
 Callable CodeFactory::ConstructFunctionForwardVarargs(Isolate* isolate) {
   return Builtins::CallableFor(isolate,
-                               Builtins::kConstructFunctionForwardVarargs);
+                               Builtin::kConstructFunctionForwardVarargs);
 }
 
 // static
@@ -352,16 +352,16 @@ Callable CodeFactory::InterpreterPushArgsThenCall(
       UNREACHABLE();
     case InterpreterPushArgsMode::kWithFinalSpread:
       return Builtins::CallableFor(
-          isolate, Builtins::kInterpreterPushArgsThenCallWithFinalSpread);
+          isolate, Builtin::kInterpreterPushArgsThenCallWithFinalSpread);
     case InterpreterPushArgsMode::kOther:
       switch (receiver_mode) {
         case ConvertReceiverMode::kNullOrUndefined:
           return Builtins::CallableFor(
-              isolate, Builtins::kInterpreterPushUndefinedAndArgsThenCall);
+              isolate, Builtin::kInterpreterPushUndefinedAndArgsThenCall);
         case ConvertReceiverMode::kNotNullOrUndefined:
         case ConvertReceiverMode::kAny:
           return Builtins::CallableFor(isolate,
-                                       Builtins::kInterpreterPushArgsThenCall);
+                                       Builtin::kInterpreterPushArgsThenCall);
       }
   }
   UNREACHABLE();
@@ -373,13 +373,13 @@ Callable CodeFactory::InterpreterPushArgsThenConstruct(
   switch (mode) {
     case InterpreterPushArgsMode::kArrayFunction:
       return Builtins::CallableFor(
-          isolate, Builtins::kInterpreterPushArgsThenConstructArrayFunction);
+          isolate, Builtin::kInterpreterPushArgsThenConstructArrayFunction);
     case InterpreterPushArgsMode::kWithFinalSpread:
       return Builtins::CallableFor(
-          isolate, Builtins::kInterpreterPushArgsThenConstructWithFinalSpread);
+          isolate, Builtin::kInterpreterPushArgsThenConstructWithFinalSpread);
     case InterpreterPushArgsMode::kOther:
       return Builtins::CallableFor(isolate,
-                                   Builtins::kInterpreterPushArgsThenConstruct);
+                                   Builtin::kInterpreterPushArgsThenConstruct);
   }
   UNREACHABLE();
 }
@@ -401,14 +401,14 @@ Callable CodeFactory::InterpreterCEntry(Isolate* isolate, int result_size) {
 // static
 Callable CodeFactory::InterpreterOnStackReplacement(Isolate* isolate) {
   return Builtins::CallableFor(isolate,
-                               Builtins::kInterpreterOnStackReplacement);
+                               Builtin::kInterpreterOnStackReplacement);
 }
 
 // static
 Callable CodeFactory::InterpreterOnStackReplacement_ToBaseline(
     Isolate* isolate) {
   return Builtins::CallableFor(
-      isolate, Builtins::kInterpreterOnStackReplacement_ToBaseline);
+      isolate, Builtin::kInterpreterOnStackReplacement_ToBaseline);
 }
 
 // static
@@ -419,7 +419,7 @@ Callable CodeFactory::ArrayNoArgumentConstructor(
   case kind_caps:                               \
     return Builtins::CallableFor(               \
         isolate,                                \
-        Builtins::kArrayNoArgumentConstructor_##kind_camel##_##mode_camel);
+        Builtin::kArrayNoArgumentConstructor_##kind_camel##_##mode_camel);
   if (override_mode == DONT_OVERRIDE && AllocationSite::ShouldTrack(kind)) {
     DCHECK(IsSmiElementsKind(kind));
     switch (kind) {
@@ -453,7 +453,7 @@ Callable CodeFactory::ArraySingleArgumentConstructor(
   case kind_caps:                               \
     return Builtins::CallableFor(               \
         isolate,                                \
-        Builtins::kArraySingleArgumentConstructor_##kind_camel##_##mode_camel)
+        Builtin::kArraySingleArgumentConstructor_##kind_camel##_##mode_camel)
   if (override_mode == DONT_OVERRIDE && AllocationSite::ShouldTrack(kind)) {
     DCHECK(IsSmiElementsKind(kind));
     switch (kind) {
diff --git a/src/codegen/code-stub-assembler.cc b/src/codegen/code-stub-assembler.cc
index ae05ce52675..d20264032ca 100644
--- a/src/codegen/code-stub-assembler.cc
+++ b/src/codegen/code-stub-assembler.cc
@@ -5400,7 +5400,7 @@ TNode<Float64T> CodeStubAssembler::TruncateTaggedToFloat64(
     BIND(&if_valueisnotnumber);
     {
       // Convert the {value} to a Number first.
-      var_value = CallBuiltin(Builtins::kNonNumberToNumber, context, value);
+      var_value = CallBuiltin(Builtin::kNonNumberToNumber, context, value);
       Goto(&loop);
     }
   }
@@ -5485,8 +5485,8 @@ void CodeStubAssembler::TaggedToWord32OrBigIntImpl(
       GotoIf(InstanceTypeEqual(instance_type, ODDBALL_TYPE), &is_oddball);
       // Not an oddball either -> convert.
       auto builtin = conversion == Object::Conversion::kToNumeric
-                         ? Builtins::kNonNumberToNumeric
-                         : Builtins::kNonNumberToNumber;
+                         ? Builtin::kNonNumberToNumeric
+                         : Builtin::kNonNumberToNumber;
       var_value = CallBuiltin(builtin, context, value);
       OverwriteFeedback(var_feedback, BinaryOperationFeedback::kAny);
       Goto(&loop);
@@ -5751,7 +5751,7 @@ TNode<String> CodeStubAssembler::ToThisString(TNode<Context> context,
       Label if_valueisnullorundefined(this, Label::kDeferred);
       GotoIf(IsNullOrUndefined(value), &if_valueisnullorundefined);
       // Convert the {value} to a String.
-      var_value = CallBuiltin(Builtins::kToString, context, value);
+      var_value = CallBuiltin(Builtin::kToString, context, value);
       Goto(&if_valueisstring);
 
       BIND(&if_valueisnullorundefined);
@@ -5765,7 +5765,7 @@ TNode<String> CodeStubAssembler::ToThisString(TNode<Context> context,
   BIND(&if_valueissmi);
   {
     // The {value} is a Smi, convert it to a String.
-    var_value = CallBuiltin(Builtins::kNumberToString, context, value);
+    var_value = CallBuiltin(Builtin::kNumberToString, context, value);
     Goto(&if_valueisstring);
   }
   BIND(&if_valueisstring);
@@ -5817,7 +5817,7 @@ TNode<Int32T> CodeStubAssembler::ChangeTaggedNonSmiToInt32(
       },
       [=] {
         return TruncateNumberToWord32(
-            CAST(CallBuiltin(Builtins::kNonNumberToNumber, context, input)));
+            CAST(CallBuiltin(Builtin::kNonNumberToNumber, context, input)));
       });
 }
 
@@ -5836,7 +5836,7 @@ TNode<Float64T> CodeStubAssembler::ChangeTaggedToFloat64(TNode<Context> context,
       [=] { return LoadHeapNumberValue(CAST(input)); },
       [=] {
         return ChangeNumberToFloat64(
-            CAST(CallBuiltin(Builtins::kNonNumberToNumber, context, input)));
+            CAST(CallBuiltin(Builtin::kNonNumberToNumber, context, input)));
       });
   Goto(&end);
 
@@ -7404,8 +7404,7 @@ TNode<Number> CodeStubAssembler::ToNumber_Inline(TNode<Context> context,
     var_result = Select<Number>(
         IsHeapNumber(CAST(input)), [=] { return CAST(input); },
         [=] {
-          return CAST(
-              CallBuiltin(Builtins::kNonNumberToNumber, context, input));
+          return CAST(CallBuiltin(Builtin::kNonNumberToNumber, context, input));
         });
     Goto(&end);
   }
@@ -7552,7 +7551,7 @@ void CodeStubAssembler::TaggedToNumeric(TNode<Context> context,
   // {heap_object_value} is not a Numeric yet.
   GotoIf(Word32Equal(instance_type, Int32Constant(ODDBALL_TYPE)), &if_oddball);
   *var_numeric = CAST(
-      CallBuiltin(Builtins::kNonNumberToNumeric, context, heap_object_value));
+      CallBuiltin(Builtin::kNonNumberToNumeric, context, heap_object_value));
   OverwriteFeedback(var_feedback, BinaryOperationFeedback::kAny);
   Goto(&done);
 
@@ -7693,7 +7692,7 @@ TNode<String> CodeStubAssembler::ToString_Inline(TNode<Context> context,
   Branch(IsString(CAST(input)), &out, &stub_call);
 
   BIND(&stub_call);
-  var_result = CallBuiltin(Builtins::kToString, context, input);
+  var_result = CallBuiltin(Builtin::kToString, context, input);
   Goto(&out);
 
   BIND(&out);
@@ -7702,7 +7701,7 @@ TNode<String> CodeStubAssembler::ToString_Inline(TNode<Context> context,
 
 TNode<JSReceiver> CodeStubAssembler::ToObject(TNode<Context> context,
                                               TNode<Object> input) {
-  return CAST(CallBuiltin(Builtins::kToObject, context, input));
+  return CAST(CallBuiltin(Builtin::kToObject, context, input));
 }
 
 TNode<JSReceiver> CodeStubAssembler::ToObject_Inline(TNode<Context> context,
@@ -7734,7 +7733,7 @@ TNode<Number> CodeStubAssembler::ToLength_Inline(TNode<Context> context,
   TNode<Smi> smi_zero = SmiConstant(0);
   return Select<Number>(
       TaggedIsSmi(input), [=] { return SmiMax(CAST(input), smi_zero); },
-      [=] { return CAST(CallBuiltin(Builtins::kToLength, context, input)); });
+      [=] { return CAST(CallBuiltin(Builtin::kToLength, context, input)); });
 }
 
 TNode<Object> CodeStubAssembler::OrdinaryToPrimitive(
@@ -9458,7 +9457,7 @@ TNode<Object> CodeStubAssembler::CallGetterIfAccessor(
         TNode<NativeContext> creation_context =
             GetCreationContext(CAST(holder), if_bailout);
         var_value = CallBuiltin(
-            Builtins::kCallFunctionTemplate_CheckAccessAndCompatibleReceiver,
+            Builtin::kCallFunctionTemplate_CheckAccessAndCompatibleReceiver,
             creation_context, getter, IntPtrConstant(0), receiver);
         Goto(&done);
 
@@ -10629,7 +10628,7 @@ TNode<Word32T> CodeStubAssembler::PrepareValueForWriteToTypedArray<Word32T>(
 
   BIND(&convert);
   {
-    var_input = CallBuiltin(Builtins::kNonNumberToNumber, context, input);
+    var_input = CallBuiltin(Builtin::kNonNumberToNumber, context, input);
     Goto(&loop);
   }
 
@@ -10677,7 +10676,7 @@ TNode<Float32T> CodeStubAssembler::PrepareValueForWriteToTypedArray<Float32T>(
 
   BIND(&convert);
   {
-    var_input = CallBuiltin(Builtins::kNonNumberToNumber, context, input);
+    var_input = CallBuiltin(Builtin::kNonNumberToNumber, context, input);
     Goto(&loop);
   }
 
@@ -10724,7 +10723,7 @@ TNode<Float64T> CodeStubAssembler::PrepareValueForWriteToTypedArray<Float64T>(
 
   BIND(&convert);
   {
-    var_input = CallBuiltin(Builtins::kNonNumberToNumber, context, input);
+    var_input = CallBuiltin(Builtin::kNonNumberToNumber, context, input);
     Goto(&loop);
   }
 
@@ -11725,8 +11724,7 @@ TNode<Oddball> CodeStubAssembler::RelationalComparison(
         // dedicated ToPrimitive(right, hint Number) operation, as the
         // ToNumeric(right) will by itself already invoke ToPrimitive with
         // a Number hint.
-        var_right =
-            CallBuiltin(Builtins::kNonNumberToNumeric, context(), right);
+        var_right = CallBuiltin(Builtin::kNonNumberToNumeric, context(), right);
         Goto(&loop);
       }
     }
@@ -11771,8 +11769,7 @@ TNode<Oddball> CodeStubAssembler::RelationalComparison(
           // dedicated ToPrimitive(left, hint Number) operation, as the
           // ToNumeric(left) will by itself already invoke ToPrimitive with
           // a Number hint.
-          var_left =
-              CallBuiltin(Builtins::kNonNumberToNumeric, context(), left);
+          var_left = CallBuiltin(Builtin::kNonNumberToNumeric, context(), left);
           Goto(&loop);
         }
       }
@@ -11828,7 +11825,7 @@ TNode<Oddball> CodeStubAssembler::RelationalComparison(
             // ToNumeric(right) will by itself already invoke ToPrimitive with
             // a Number hint.
             var_right =
-                CallBuiltin(Builtins::kNonNumberToNumeric, context(), right);
+                CallBuiltin(Builtin::kNonNumberToNumeric, context(), right);
             Goto(&loop);
           }
         }
@@ -11883,7 +11880,7 @@ TNode<Oddball> CodeStubAssembler::RelationalComparison(
             // ToNumeric(right) will by itself already invoke ToPrimitive with
             // a Number hint.
             var_right =
-                CallBuiltin(Builtins::kNonNumberToNumeric, context(), right);
+                CallBuiltin(Builtin::kNonNumberToNumeric, context(), right);
             Goto(&loop);
           }
         }
@@ -11898,19 +11895,19 @@ TNode<Oddball> CodeStubAssembler::RelationalComparison(
 
           // Both {left} and {right} are strings.
           CombineFeedback(var_type_feedback, CompareOperationFeedback::kString);
-          Builtins::Name builtin;
+          Builtin builtin;
           switch (op) {
             case Operation::kLessThan:
-              builtin = Builtins::kStringLessThan;
+              builtin = Builtin::kStringLessThan;
               break;
             case Operation::kLessThanOrEqual:
-              builtin = Builtins::kStringLessThanOrEqual;
+              builtin = Builtin::kStringLessThanOrEqual;
               break;
             case Operation::kGreaterThan:
-              builtin = Builtins::kStringGreaterThan;
+              builtin = Builtin::kStringGreaterThan;
               break;
             case Operation::kGreaterThanOrEqual:
-              builtin = Builtins::kStringGreaterThanOrEqual;
+              builtin = Builtin::kStringGreaterThanOrEqual;
               break;
             default:
               UNREACHABLE();
@@ -11934,8 +11931,8 @@ TNode<Oddball> CodeStubAssembler::RelationalComparison(
                    &if_right_receiver);
 
             var_left =
-                CallBuiltin(Builtins::kNonNumberToNumeric, context(), left);
-            var_right = CallBuiltin(Builtins::kToNumeric, context(), right);
+                CallBuiltin(Builtin::kNonNumberToNumeric, context(), left);
+            var_right = CallBuiltin(Builtin::kToNumeric, context(), right);
             Goto(&loop);
 
             BIND(&if_right_bigint);
@@ -11998,9 +11995,8 @@ TNode<Oddball> CodeStubAssembler::RelationalComparison(
           GotoIf(IsJSReceiverInstanceType(left_instance_type),
                  &if_left_receiver);
 
-          var_right = CallBuiltin(Builtins::kToNumeric, context(), right);
-          var_left =
-              CallBuiltin(Builtins::kNonNumberToNumeric, context(), left);
+          var_right = CallBuiltin(Builtin::kToNumeric, context(), right);
+          var_left = CallBuiltin(Builtin::kNonNumberToNumeric, context(), left);
           Goto(&loop);
 
           BIND(&if_left_receiver);
@@ -12309,7 +12305,7 @@ TNode<Oddball> CodeStubAssembler::Equal(TNode<Object> left, TNode<Object> right,
       {
         GotoIfNot(IsStringInstanceType(right_type), &use_symmetry);
         result =
-            CAST(CallBuiltin(Builtins::kStringEqual, context(), left, right));
+            CAST(CallBuiltin(Builtin::kStringEqual, context(), left, right));
         CombineFeedback(var_type_feedback,
                         SmiOr(CollectFeedbackForString(left_type),
                               CollectFeedbackForString(right_type)));
@@ -12569,7 +12565,7 @@ TNode<Oddball> CodeStubAssembler::Equal(TNode<Object> left, TNode<Object> right,
         CombineFeedback(var_type_feedback,
                         CollectFeedbackForString(right_type));
       }
-      var_right = CallBuiltin(Builtins::kStringToNumber, context(), right);
+      var_right = CallBuiltin(Builtin::kStringToNumber, context(), right);
       Goto(&loop);
     }
 
@@ -12774,7 +12770,7 @@ TNode<Oddball> CodeStubAssembler::StrictEqual(
                     CollectFeedbackForString(rhs_instance_type);
                 *var_type_feedback = SmiOr(lhs_feedback, rhs_feedback);
               }
-              result = CAST(CallBuiltin(Builtins::kStringEqual,
+              result = CAST(CallBuiltin(Builtin::kStringEqual,
                                         NoContextConstant(), lhs, rhs));
               Goto(&end);
             }
@@ -13051,7 +13047,7 @@ void CodeStubAssembler::BranchIfSameValue(TNode<Object> lhs, TNode<Object> rhs,
               // with the same sequence of characters.
               GotoIfNot(IsString(CAST(rhs)), if_false);
               const TNode<Object> result = CallBuiltin(
-                  Builtins::kStringEqual, NoContextConstant(), lhs, rhs);
+                  Builtin::kStringEqual, NoContextConstant(), lhs, rhs);
               Branch(IsTrue(result), if_true, if_false);
             }
 
@@ -13136,13 +13132,13 @@ TNode<Oddball> CodeStubAssembler::HasProperty(TNode<Context> context,
 
   BIND(&if_proxy);
   {
-    TNode<Name> name = CAST(CallBuiltin(Builtins::kToName, context, key));
+    TNode<Name> name = CAST(CallBuiltin(Builtin::kToName, context, key));
     switch (mode) {
       case kHasProperty:
         GotoIf(IsPrivateSymbol(name), &return_false);
 
         result = CAST(
-            CallBuiltin(Builtins::kProxyHasProperty, context, object, name));
+            CallBuiltin(Builtin::kProxyHasProperty, context, object, name));
         Goto(&end);
         break;
       case kForInHasProperty:
@@ -13433,7 +13429,7 @@ TNode<Oddball> CodeStubAssembler::InstanceOf(TNode<Object> object,
 
     // Use the OrdinaryHasInstance algorithm.
     var_result = CAST(
-        CallBuiltin(Builtins::kOrdinaryHasInstance, context, callable, object));
+        CallBuiltin(Builtin::kOrdinaryHasInstance, context, callable, object));
     Goto(&return_result);
   }
 
@@ -14132,7 +14128,7 @@ TNode<BoolT> CodeStubAssembler::NeedsAnyPromiseHooks(TNode<Uint32T> flags) {
 }
 
 TNode<Code> CodeStubAssembler::LoadBuiltin(TNode<Smi> builtin_id) {
-  CSA_ASSERT(this, SmiBelow(builtin_id, SmiConstant(Builtins::builtin_count)));
+  CSA_ASSERT(this, SmiBelow(builtin_id, SmiConstant(Builtins::kBuiltinCount)));
 
   TNode<IntPtrT> offset =
       ElementOffsetFromIndex(SmiToBInt(builtin_id), SYSTEM_POINTER_ELEMENTS);
@@ -14159,7 +14155,7 @@ TNode<Code> CodeStubAssembler::GetSharedFunctionInfoCode(
     *data_type_out = Uint16Constant(0);
   }
   if (if_compile_lazy) {
-    GotoIf(SmiEqual(CAST(sfi_data), SmiConstant(Builtins::kCompileLazy)),
+    GotoIf(SmiEqual(CAST(sfi_data), SmiConstant(Builtin::kCompileLazy)),
            if_compile_lazy);
   }
   sfi_code = LoadBuiltin(CAST(sfi_data));
diff --git a/src/codegen/code-stub-assembler.h b/src/codegen/code-stub-assembler.h
index 9b54b5014e3..69c78b9f6f9 100644
--- a/src/codegen/code-stub-assembler.h
+++ b/src/codegen/code-stub-assembler.h
@@ -3025,19 +3025,19 @@ class V8_EXPORT_PRIVATE CodeStubAssembler
 
   TNode<Object> GetProperty(TNode<Context> context, TNode<Object> receiver,
                             TNode<Object> name) {
-    return CallBuiltin(Builtins::kGetProperty, context, receiver, name);
+    return CallBuiltin(Builtin::kGetProperty, context, receiver, name);
   }
 
   TNode<Object> SetPropertyStrict(TNode<Context> context,
                                   TNode<Object> receiver, TNode<Object> key,
                                   TNode<Object> value) {
-    return CallBuiltin(Builtins::kSetProperty, context, receiver, key, value);
+    return CallBuiltin(Builtin::kSetProperty, context, receiver, key, value);
   }
 
   TNode<Object> SetPropertyInLiteral(TNode<Context> context,
                                      TNode<JSObject> receiver,
                                      TNode<Object> key, TNode<Object> value) {
-    return CallBuiltin(Builtins::kSetPropertyInLiteral, context, receiver, key,
+    return CallBuiltin(Builtin::kSetPropertyInLiteral, context, receiver, key,
                        value);
   }
 
@@ -3052,15 +3052,13 @@ class V8_EXPORT_PRIVATE CodeStubAssembler
                                             TNode<Object> sync_iterator);
 
   template <class... TArgs>
-  TNode<Object> CallBuiltin(Builtins::Name id, TNode<Object> context,
-                            TArgs... args) {
+  TNode<Object> CallBuiltin(Builtin id, TNode<Object> context, TArgs... args) {
     return CallStub<Object>(Builtins::CallableFor(isolate(), id), context,
                             args...);
   }
 
   template <class... TArgs>
-  void TailCallBuiltin(Builtins::Name id, TNode<Object> context,
-                       TArgs... args) {
+  void TailCallBuiltin(Builtin id, TNode<Object> context, TArgs... args) {
     return TailCallStub(Builtins::CallableFor(isolate(), id), context, args...);
   }
 
diff --git a/src/codegen/ia32/macro-assembler-ia32.cc b/src/codegen/ia32/macro-assembler-ia32.cc
index 0e058b0a06c..26908f7a00b 100644
--- a/src/codegen/ia32/macro-assembler-ia32.cc
+++ b/src/codegen/ia32/macro-assembler-ia32.cc
@@ -231,12 +231,11 @@ Operand TurboAssembler::HeapObjectAsOperand(Handle<HeapObject> object) {
   if (isolate()->roots_table().IsRootHandle(object, &root_index)) {
     return Operand(kRootRegister, RootRegisterOffsetForRootIndex(root_index));
   } else if (isolate()->builtins()->IsBuiltinHandle(object, &builtin_index)) {
-    return Operand(kRootRegister,
-                   RootRegisterOffsetForBuiltinIndex(builtin_index));
+    return Operand(kRootRegister, RootRegisterOffsetForBuiltin(builtin_index));
   } else if (object.is_identical_to(code_object_) &&
              Builtins::IsBuiltinId(maybe_builtin_index_)) {
     return Operand(kRootRegister,
-                   RootRegisterOffsetForBuiltinIndex(maybe_builtin_index_));
+                   RootRegisterOffsetForBuiltin(maybe_builtin_index_));
   } else {
     // Objects in the constants table need an additional indirection, which
     // cannot be represented as a single Operand.
@@ -2173,7 +2172,7 @@ void TurboAssembler::Call(Handle<Code> code_object, RelocInfo::Mode rmode) {
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
       // Inline the trampoline.
       CallBuiltin(builtin_index);
@@ -2207,14 +2206,13 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
 void TurboAssembler::CallBuiltin(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
   EmbeddedData d = EmbeddedData::FromBlob();
   Address entry = d.InstructionStartOfBuiltin(builtin_index);
   call(entry, RelocInfo::OFF_HEAP_TARGET);
 }
 
-Operand TurboAssembler::EntryFromBuiltinIndexAsOperand(
-    Builtins::Name builtin_index) {
+Operand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
   return Operand(kRootRegister,
                  IsolateData::builtin_entry_slot_offset(builtin_index));
 }
@@ -2290,11 +2288,11 @@ void TurboAssembler::Jump(Handle<Code> code_object, RelocInfo::Mode rmode) {
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
       // Inline the trampoline.
       RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
       Address entry = d.InstructionStartOfBuiltin(builtin_index);
       jmp(entry, RelocInfo::OFF_HEAP_TARGET);
@@ -2391,9 +2389,9 @@ void TurboAssembler::ComputeCodeStartAddress(Register dst) {
   }
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   CallBuiltin(target);
   DCHECK_EQ(SizeOfCodeGeneratedSince(exit),
             (kind == DeoptimizeKind::kLazy)
diff --git a/src/codegen/ia32/macro-assembler-ia32.h b/src/codegen/ia32/macro-assembler-ia32.h
index e4929e7873e..7e710547b0b 100644
--- a/src/codegen/ia32/macro-assembler-ia32.h
+++ b/src/codegen/ia32/macro-assembler-ia32.h
@@ -139,7 +139,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
   void Move(XMMRegister dst, float src) { Move(dst, bit_cast<uint32_t>(src)); }
   void Move(XMMRegister dst, double src) { Move(dst, bit_cast<uint64_t>(src)); }
 
-  Operand EntryFromBuiltinIndexAsOperand(Builtins::Name builtin_index);
+  Operand EntryFromBuiltinAsOperand(Builtin builtin_index);
 
   void Call(Register reg) { call(reg); }
   void Call(Operand op) { call(op); }
@@ -170,7 +170,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
   void Trap();
   void DebugBreak();
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/interface-descriptors-inl.h b/src/codegen/interface-descriptors-inl.h
index abaf1ced44d..80ab7a73193 100644
--- a/src/codegen/interface-descriptors-inl.h
+++ b/src/codegen/interface-descriptors-inl.h
@@ -505,7 +505,7 @@ constexpr Register RunMicrotasksDescriptor::MicrotaskQueueRegister() {
 
 #define DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER(Name, DescriptorName) \
   template <>                                                         \
-  struct CallInterfaceDescriptorFor<Builtins::k##Name> {              \
+  struct CallInterfaceDescriptorFor<Builtin::k##Name> {               \
     using type = DescriptorName##Descriptor;                          \
   };
 BUILTIN_LIST(IGNORE_BUILTIN, IGNORE_BUILTIN,
@@ -515,7 +515,7 @@ BUILTIN_LIST(IGNORE_BUILTIN, IGNORE_BUILTIN,
 #undef DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER
 #define DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER(Name, ...) \
   template <>                                              \
-  struct CallInterfaceDescriptorFor<Builtins::k##Name> {   \
+  struct CallInterfaceDescriptorFor<Builtin::k##Name> {    \
     using type = Name##Descriptor;                         \
   };
 BUILTIN_LIST_TFS(DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER)
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index 9d6004477e4..470202e2459 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -502,7 +502,7 @@ class StaticJSCallInterfaceDescriptor
       Descriptor>::StaticCallInterfaceDescriptor;
 };
 
-template <Builtins::Name kBuiltin>
+template <Builtin kBuiltin>
 struct CallInterfaceDescriptorFor;
 
 // Stub class replacing std::array<Register, 0>, as a workaround for MSVC's
diff --git a/src/codegen/mips/macro-assembler-mips.cc b/src/codegen/mips/macro-assembler-mips.cc
index 8a8b32f1058..e7ddc271ad1 100644
--- a/src/codegen/mips/macro-assembler-mips.cc
+++ b/src/codegen/mips/macro-assembler-mips.cc
@@ -303,7 +303,7 @@ void TurboAssembler::CallRecordWriteStub(
       // Inline the trampoline.
       DCHECK(Builtins::IsBuiltinId(builtin_index));
       RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
       Address entry = d.InstructionStartOfBuiltin(builtin_index);
       li(t9, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -3773,7 +3773,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK(RelocInfo::IsCodeTarget(rmode));
   BlockTrampolinePoolScope block_trampoline_pool(this);
 
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_isolate_independent_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
       Builtins::IsIsolateIndependent(builtin_index);
@@ -3799,7 +3799,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
              options().inline_offheap_trampolines) {
     // Inline the trampoline.
     RecordCommentForOffHeapTrampoline(builtin_index);
-    CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+    CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
     EmbeddedData d = EmbeddedData::FromBlob();
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
     li(t9, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -3915,7 +3915,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
                           BranchDelaySlot bd) {
   BlockTrampolinePoolScope block_trampoline_pool(this);
 
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_isolate_independent_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
       Builtins::IsIsolateIndependent(builtin_index);
@@ -3939,7 +3939,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
              options().inline_offheap_trampolines) {
     // Inline the trampoline.
     RecordCommentForOffHeapTrampoline(builtin_index);
-    CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+    CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
     EmbeddedData d = EmbeddedData::FromBlob();
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
     li(t9, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -5540,9 +5540,9 @@ void TurboAssembler::ResetSpeculationPoisonRegister() {
   li(kSpeculationPoisonRegister, -1);
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   BlockTrampolinePoolScope block_trampoline_pool(this);
   Lw(t9,
      MemOperand(kRootRegister, IsolateData::builtin_entry_slot_offset(target)));
diff --git a/src/codegen/mips/macro-assembler-mips.h b/src/codegen/mips/macro-assembler-mips.h
index a25b34d5bed..71db7907bc3 100644
--- a/src/codegen/mips/macro-assembler-mips.h
+++ b/src/codegen/mips/macro-assembler-mips.h
@@ -241,7 +241,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // The return address on the stack is used by frame iteration.
   void StoreReturnAddressAndCall(Register target);
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/mips64/macro-assembler-mips64.cc b/src/codegen/mips64/macro-assembler-mips64.cc
index 4aed4f438db..71be0b079b0 100644
--- a/src/codegen/mips64/macro-assembler-mips64.cc
+++ b/src/codegen/mips64/macro-assembler-mips64.cc
@@ -301,7 +301,7 @@ void TurboAssembler::CallRecordWriteStub(
       // Inline the trampoline.
       DCHECK(Builtins::IsBuiltinId(builtin_index));
       RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
       Address entry = d.InstructionStartOfBuiltin(builtin_index);
       li(t9, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -4344,12 +4344,12 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
     Jump(t9, cond, rs, rt, bd);
     return;
   } else if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
         Builtins::IsIsolateIndependent(builtin_index)) {
       // Inline the trampoline.
       RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
       Address entry = d.InstructionStartOfBuiltin(builtin_index);
       li(t9, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -4423,12 +4423,12 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
     Call(t9, cond, rs, rt, bd);
     return;
   } else if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
         Builtins::IsIsolateIndependent(builtin_index)) {
       // Inline the trampoline.
       RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
       Address entry = d.InstructionStartOfBuiltin(builtin_index);
       li(t9, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -6070,9 +6070,9 @@ void TurboAssembler::ResetSpeculationPoisonRegister() {
   li(kSpeculationPoisonRegister, -1);
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   BlockTrampolinePoolScope block_trampoline_pool(this);
   Ld(t9,
      MemOperand(kRootRegister, IsolateData::builtin_entry_slot_offset(target)));
diff --git a/src/codegen/mips64/macro-assembler-mips64.h b/src/codegen/mips64/macro-assembler-mips64.h
index 64821ffd267..06dbc8c00d6 100644
--- a/src/codegen/mips64/macro-assembler-mips64.h
+++ b/src/codegen/mips64/macro-assembler-mips64.h
@@ -265,7 +265,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // The return address on the stack is used by frame iteration.
   void StoreReturnAddressAndCall(Register target);
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/ppc/macro-assembler-ppc.cc b/src/codegen/ppc/macro-assembler-ppc.cc
index 6226c3861b7..b2112a5dd90 100644
--- a/src/codegen/ppc/macro-assembler-ppc.cc
+++ b/src/codegen/ppc/macro-assembler-ppc.cc
@@ -176,7 +176,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
 
@@ -265,7 +265,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().use_pc_relative_calls_and_jumps,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
 
@@ -3265,9 +3265,9 @@ void TurboAssembler::StoreReturnAddressAndCall(Register target) {
             SizeOfCodeGeneratedSince(&start_call));
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   BlockTrampolinePoolScope block_trampoline_pool(this);
   LoadU64(ip, MemOperand(kRootRegister,
                          IsolateData::builtin_entry_slot_offset(target)));
diff --git a/src/codegen/ppc/macro-assembler-ppc.h b/src/codegen/ppc/macro-assembler-ppc.h
index 97de5e05e65..8acc5e160fb 100644
--- a/src/codegen/ppc/macro-assembler-ppc.h
+++ b/src/codegen/ppc/macro-assembler-ppc.h
@@ -435,7 +435,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
                       JumpMode jump_mode = JumpMode::kJump);
 
   void CallBuiltinByIndex(Register builtin_index);
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/riscv64/macro-assembler-riscv64.cc b/src/codegen/riscv64/macro-assembler-riscv64.cc
index 4442f00b75f..2db8dd14f2f 100644
--- a/src/codegen/riscv64/macro-assembler-riscv64.cc
+++ b/src/codegen/riscv64/macro-assembler-riscv64.cc
@@ -300,7 +300,7 @@ void TurboAssembler::CallRecordWriteStub(
       // Inline the trampoline. //qj
       DCHECK(Builtins::IsBuiltinId(builtin_index));
       RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
       Address entry = d.InstructionStartOfBuiltin(builtin_index);
 
@@ -2994,7 +2994,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK(RelocInfo::IsCodeTarget(rmode));
 
   BlockTrampolinePoolScope block_trampoline_pool(this);
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_isolate_independent_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
       Builtins::IsIsolateIndependent(builtin_index);
@@ -3021,7 +3021,7 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
              target_is_isolate_independent_builtin) {
     // Inline the trampoline.
     RecordCommentForOffHeapTrampoline(builtin_index);
-    CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+    CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
     EmbeddedData d = EmbeddedData::FromBlob();
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
     li(t6, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -3074,7 +3074,7 @@ void TurboAssembler::Call(Address target, RelocInfo::Mode rmode, Condition cond,
 
 void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
                           Condition cond, Register rs, const Operand& rt) {
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_isolate_independent_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index) &&
       Builtins::IsIsolateIndependent(builtin_index);
@@ -3103,7 +3103,7 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
              target_is_isolate_independent_builtin) {
     // Inline the trampoline.
     RecordCommentForOffHeapTrampoline(builtin_index);
-    CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+    CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
     EmbeddedData d = EmbeddedData::FromBlob();
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
     li(t6, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -3138,7 +3138,7 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
 void TurboAssembler::CallBuiltin(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
   EmbeddedData d = EmbeddedData::FromBlob(isolate());
   Address entry = d.InstructionStartOfBuiltin(builtin_index);
   if (options().short_builtin_calls) {
@@ -3152,7 +3152,7 @@ void TurboAssembler::CallBuiltin(int builtin_index) {
 void TurboAssembler::TailCallBuiltin(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
   EmbeddedData d = EmbeddedData::FromBlob(isolate());
   Address entry = d.InstructionStartOfBuiltin(builtin_index);
   if (options().short_builtin_calls) {
@@ -3163,13 +3163,12 @@ void TurboAssembler::TailCallBuiltin(int builtin_index) {
   RecordComment("]");
 }
 
-void TurboAssembler::LoadEntryFromBuiltinIndex(Builtins::Name builtin_index,
-                                               Register destination) {
+void TurboAssembler::LoadEntryFromBuiltin(Builtin builtin_index,
+                                          Register destination) {
   Ld(destination, EntryFromBuiltinIndexAsOperand(builtin_index));
 }
 
-MemOperand TurboAssembler::EntryFromBuiltinIndexAsOperand(
-    Builtins::Name builtin_index) {
+MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
   DCHECK(root_array_available());
   return MemOperand(kRootRegister,
                     IsolateData::builtin_entry_slot_offset(builtin_index));
@@ -4627,9 +4626,9 @@ void TurboAssembler::ResetSpeculationPoisonRegister() {
   li(kSpeculationPoisonRegister, -1);
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   BlockTrampolinePoolScope block_trampoline_pool(this);
   Ld(t6,
      MemOperand(kRootRegister, IsolateData::builtin_entry_slot_offset(target)));
@@ -4681,7 +4680,7 @@ void TurboAssembler::LoadCodeObjectEntry(Register destination,
     bind(&if_code_is_off_heap);
     Lw(scratch, FieldMemOperand(code_object, Code::kBuiltinIndexOffset));
     // TODO(RISCV): https://github.com/v8-riscv/v8/issues/373
-    Branch(&no_builtin_index, eq, scratch, Operand(Builtins::kNoBuiltinId));
+    Branch(&no_builtin_index, eq, scratch, Operand(Builtin::kNoBuiltinId));
     slli(destination, scratch, kSystemPointerSizeLog2);
     Add64(destination, destination, kRootRegister);
     Ld(destination,
diff --git a/src/codegen/riscv64/macro-assembler-riscv64.h b/src/codegen/riscv64/macro-assembler-riscv64.h
index 3a2b33d09bd..35c6c974539 100644
--- a/src/codegen/riscv64/macro-assembler-riscv64.h
+++ b/src/codegen/riscv64/macro-assembler-riscv64.h
@@ -231,18 +231,17 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
 
   // Load the builtin given by the Smi in |builtin_index| into the same
   // register.
-  void LoadEntryFromBuiltinIndex(Register builtin_index);
-  void LoadEntryFromBuiltinIndex(Builtins::Name builtin_index,
-                                 Register destination);
-  MemOperand EntryFromBuiltinIndexAsOperand(Builtins::Name builtin_index);
+  void LoadEntryFromBuiltin(Register builtin_index);
+  void LoadEntryFromBuiltin(Builtin builtin_index, Register destination);
+  MemOperand EntryFromBuiltinAsOperand(Builtin builtin_index);
   void CallBuiltinByIndex(Register builtin_index);
-  void CallBuiltin(Builtins::Name builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtins::Name one.
+  void CallBuiltin(Builtin builtin) {
+    // TODO(11527): drop the int overload in favour of the Builtin one.
     return CallBuiltin(static_cast<int>(builtin));
   }
   void CallBuiltin(int builtin_index);
-  void TailCallBuiltin(Builtins::Name builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtins::Name one.
+  void TailCallBuiltin(Builtin builtin) {
+    // TODO(11527): drop the int overload in favour of the Builtin one.
     return TailCallBuiltin(static_cast<int>(builtin));
   }
   void TailCallBuiltin(int builtin_index);
@@ -257,7 +256,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   // The return address on the stack is used by frame iteration.
   void StoreReturnAddressAndCall(Register target);
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/s390/macro-assembler-s390.cc b/src/codegen/s390/macro-assembler-s390.cc
index 24104388eee..0d1aca51cd5 100644
--- a/src/codegen/s390/macro-assembler-s390.cc
+++ b/src/codegen/s390/macro-assembler-s390.cc
@@ -401,14 +401,14 @@ void TurboAssembler::Jump(Handle<Code> code, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code));
 
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
 
   if (options().inline_offheap_trampolines && target_is_builtin) {
     // Inline the trampoline.
     RecordCommentForOffHeapTrampoline(builtin_index);
-    CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+    CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
     EmbeddedData d = EmbeddedData::FromBlob();
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
     mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -462,14 +462,14 @@ void TurboAssembler::Call(Handle<Code> code, RelocInfo::Mode rmode,
 
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code));
-  int builtin_index = Builtins::kNoBuiltinId;
+  int builtin_index = Builtin::kNoBuiltinId;
   bool target_is_builtin =
       isolate()->builtins()->IsBuiltinHandle(code, &builtin_index);
 
   if (target_is_builtin && options().inline_offheap_trampolines) {
     // Inline the trampoline.
     RecordCommentForOffHeapTrampoline(builtin_index);
-    CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+    CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
     EmbeddedData d = EmbeddedData::FromBlob();
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
     mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -935,7 +935,7 @@ void TurboAssembler::CallRecordWriteStub(
         Builtins::GetRecordWriteStub(remembered_set_action, fp_mode);
     if (options().inline_offheap_trampolines) {
       RecordCommentForOffHeapTrampoline(builtin_index);
-      CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+      CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
       EmbeddedData d = EmbeddedData::FromBlob();
       Address entry = d.InstructionStartOfBuiltin(builtin_index);
       mov(ip, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
@@ -4723,9 +4723,9 @@ void TurboAssembler::StoreReturnAddressAndCall(Register target) {
   bind(&return_label);
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   LoadU64(ip, MemOperand(kRootRegister,
                          IsolateData::builtin_entry_slot_offset(target)));
   Call(ip);
diff --git a/src/codegen/s390/macro-assembler-s390.h b/src/codegen/s390/macro-assembler-s390.h
index f0db49d5e29..118b5b9768b 100644
--- a/src/codegen/s390/macro-assembler-s390.h
+++ b/src/codegen/s390/macro-assembler-s390.h
@@ -103,7 +103,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   void Ret() { b(r14); }
   void Ret(Condition cond) { b(cond, r14); }
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/codegen/turbo-assembler.cc b/src/codegen/turbo-assembler.cc
index a9f9e08ead6..386d1e27e58 100644
--- a/src/codegen/turbo-assembler.cc
+++ b/src/codegen/turbo-assembler.cc
@@ -38,14 +38,13 @@ void TurboAssemblerBase::IndirectLoadConstant(Register destination,
     LoadRoot(destination, root_index);
   } else if (isolate()->builtins()->IsBuiltinHandle(object, &builtin_index)) {
     // Similar to roots, builtins may be loaded from the builtins table.
-    LoadRootRelative(destination,
-                     RootRegisterOffsetForBuiltinIndex(builtin_index));
+    LoadRootRelative(destination, RootRegisterOffsetForBuiltin(builtin_index));
   } else if (object.is_identical_to(code_object_) &&
              Builtins::IsBuiltinId(maybe_builtin_index_)) {
     // The self-reference loaded through Codevalue() may also be a builtin
     // and thus viable for a fast load.
     LoadRootRelative(destination,
-                     RootRegisterOffsetForBuiltinIndex(maybe_builtin_index_));
+                     RootRegisterOffsetForBuiltin(maybe_builtin_index_));
   } else {
     CHECK(isolate()->IsGeneratingEmbeddedBuiltins());
     // Ensure the given object is in the builtins constants table and fetch its
@@ -84,8 +83,7 @@ int32_t TurboAssemblerBase::RootRegisterOffsetForRootIndex(
 }
 
 // static
-int32_t TurboAssemblerBase::RootRegisterOffsetForBuiltinIndex(
-    int builtin_index) {
+int32_t TurboAssemblerBase::RootRegisterOffsetForBuiltin(int builtin_index) {
   return IsolateData::builtin_slot_offset(builtin_index);
 }
 
diff --git a/src/codegen/turbo-assembler.h b/src/codegen/turbo-assembler.h
index b4715cedc76..e2f28b6f53c 100644
--- a/src/codegen/turbo-assembler.h
+++ b/src/codegen/turbo-assembler.h
@@ -77,7 +77,7 @@ class V8_EXPORT_PRIVATE TurboAssemblerBase : public Assembler {
   virtual void LoadRoot(Register destination, RootIndex index) = 0;
 
   static int32_t RootRegisterOffsetForRootIndex(RootIndex root_index);
-  static int32_t RootRegisterOffsetForBuiltinIndex(int builtin_index);
+  static int32_t RootRegisterOffsetForBuiltin(int builtin_index);
 
   // Returns the root-relative offset to reference.address().
   static intptr_t RootRegisterOffsetForExternalReference(
@@ -124,15 +124,15 @@ class V8_EXPORT_PRIVATE TurboAssemblerBase : public Assembler {
   bool hard_abort_ = false;
 
   // May be set while generating builtins.
-  int maybe_builtin_index_ = Builtins::kNoBuiltinId;
+  int maybe_builtin_index_ = Builtin::kNoBuiltinId;
 
   bool has_frame_ = false;
 
   DISALLOW_IMPLICIT_CONSTRUCTORS(TurboAssemblerBase);
 };
 
-// Avoids emitting calls to the {Builtins::kAbort} builtin when emitting debug
-// code during the lifetime of this scope object.
+// Avoids emitting calls to the {Builtin::kAbort} builtin when emitting
+// debug code during the lifetime of this scope object.
 class V8_NODISCARD HardAbortScope {
  public:
   explicit HardAbortScope(TurboAssemblerBase* assembler)
diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index 9f685c89953..30f3a276813 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -1640,7 +1640,7 @@ void TurboAssembler::Jump(Handle<Code> code_object, RelocInfo::Mode rmode,
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
       Label skip;
       if (cc != always) {
@@ -1683,7 +1683,7 @@ void TurboAssembler::Call(Handle<Code> code_object, RelocInfo::Mode rmode) {
   DCHECK_IMPLIES(options().isolate_independent_code,
                  Builtins::IsIsolateIndependentBuiltin(*code_object));
   if (options().inline_offheap_trampolines) {
-    int builtin_index = Builtins::kNoBuiltinId;
+    int builtin_index = Builtin::kNoBuiltinId;
     if (isolate()->builtins()->IsBuiltinHandle(code_object, &builtin_index)) {
       // Inline the trampoline.
       CallBuiltin(builtin_index);
@@ -1694,8 +1694,7 @@ void TurboAssembler::Call(Handle<Code> code_object, RelocInfo::Mode rmode) {
   call(code_object, rmode);
 }
 
-Operand TurboAssembler::EntryFromBuiltinIndexAsOperand(
-    Builtins::Name builtin_index) {
+Operand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin_index) {
   DCHECK(root_array_available());
   return Operand(kRootRegister,
                  IsolateData::builtin_entry_slot_offset(builtin_index));
@@ -1725,7 +1724,7 @@ void TurboAssembler::CallBuiltinByIndex(Register builtin_index) {
 void TurboAssembler::CallBuiltin(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
@@ -1743,7 +1742,7 @@ void TurboAssembler::CallBuiltin(int builtin_index) {
 void TurboAssembler::TailCallBuiltin(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   RecordCommentForOffHeapTrampoline(builtin_index);
-  CHECK_NE(builtin_index, Builtins::kNoBuiltinId);
+  CHECK_NE(builtin_index, Builtin::kNoBuiltinId);
   if (options().short_builtin_calls) {
     EmbeddedData d = EmbeddedData::FromBlob(isolate());
     Address entry = d.InstructionStartOfBuiltin(builtin_index);
@@ -3359,13 +3358,13 @@ void TurboAssembler::ResetSpeculationPoisonRegister() {
   Move(kSpeculationPoisonRegister, -1);
 }
 
-void TurboAssembler::CallForDeoptimization(Builtins::Name target, int,
-                                           Label* exit, DeoptimizeKind kind,
-                                           Label* ret, Label*) {
+void TurboAssembler::CallForDeoptimization(Builtin target, int, Label* exit,
+                                           DeoptimizeKind kind, Label* ret,
+                                           Label*) {
   // Note: Assembler::call is used here on purpose to guarantee fixed-size
   // exits even on Atom CPUs; see TurboAssembler::Call for Atom-specific
   // performance tuning which emits a different instruction sequence.
-  call(EntryFromBuiltinIndexAsOperand(target));
+  call(EntryFromBuiltinAsOperand(target));
   DCHECK_EQ(SizeOfCodeGeneratedSince(exit),
             (kind == DeoptimizeKind::kLazy)
                 ? Deoptimizer::kLazyDeoptExitSize
diff --git a/src/codegen/x64/macro-assembler-x64.h b/src/codegen/x64/macro-assembler-x64.h
index 485f1283da6..98627f27f0b 100644
--- a/src/codegen/x64/macro-assembler-x64.h
+++ b/src/codegen/x64/macro-assembler-x64.h
@@ -340,16 +340,16 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
   void Call(ExternalReference ext);
   void Call(Label* target) { call(target); }
 
-  Operand EntryFromBuiltinIndexAsOperand(Builtins::Name builtin_index);
+  Operand EntryFromBuiltinAsOperand(Builtin builtin_index);
   Operand EntryFromBuiltinIndexAsOperand(Register builtin_index);
   void CallBuiltinByIndex(Register builtin_index);
-  void CallBuiltin(Builtins::Name builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtins::Name one.
+  void CallBuiltin(Builtin builtin) {
+    // TODO(11527): drop the int overload in favour of the Builtin one.
     return CallBuiltin(static_cast<int>(builtin));
   }
   void CallBuiltin(int builtin_index);
-  void TailCallBuiltin(Builtins::Name builtin) {
-    // TODO(11527): drop the int overload in favour of the Builtins::Name one.
+  void TailCallBuiltin(Builtin builtin) {
+    // TODO(11527): drop the int overload in favour of the Builtin one.
     return TailCallBuiltin(static_cast<int>(builtin));
   }
   void TailCallBuiltin(int builtin_index);
@@ -370,7 +370,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public SharedTurboAssembler {
 
   void RetpolineJump(Register reg);
 
-  void CallForDeoptimization(Builtins::Name target, int deopt_id, Label* exit,
+  void CallForDeoptimization(Builtin target, int deopt_id, Label* exit,
                              DeoptimizeKind kind, Label* ret,
                              Label* jump_deoptimization_entry_label);
 
diff --git a/src/compiler/backend/arm/code-generator-arm.cc b/src/compiler/backend/arm/code-generator-arm.cc
index a749e008cc3..283ba8d23e5 100644
--- a/src/compiler/backend/arm/code-generator-arm.cc
+++ b/src/compiler/backend/arm/code-generator-arm.cc
@@ -910,9 +910,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ stop();
       unwinding_info_writer_.MarkBlockWillExit();
diff --git a/src/compiler/backend/arm64/code-generator-arm64.cc b/src/compiler/backend/arm64/code-generator-arm64.cc
index 173b9c22d57..0b75838e12c 100644
--- a/src/compiler/backend/arm64/code-generator-arm64.cc
+++ b/src/compiler/backend/arm64/code-generator-arm64.cc
@@ -942,9 +942,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ Debug("kArchAbortCSAAssert", 0, BREAK);
       unwinding_info_writer_.MarkBlockWillExit();
@@ -3388,12 +3387,12 @@ void CodeGenerator::PrepareForDeoptimizationExits(
     __ bind(&jump_deoptimization_entry_labels_[i]);
     DeoptimizeKind kind = static_cast<DeoptimizeKind>(i);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      __ LoadEntryFromBuiltinIndex(
+      __ LoadEntryFromBuiltin(
           Deoptimizer::GetDeoptWithResumeBuiltin(eager_with_resume_reason),
           scratch);
     } else {
-      __ LoadEntryFromBuiltinIndex(Deoptimizer::GetDeoptimizationEntry(kind),
-                                   scratch);
+      __ LoadEntryFromBuiltin(Deoptimizer::GetDeoptimizationEntry(kind),
+                              scratch);
     }
     __ Jump(scratch);
   }
diff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.cc
index 62e57fe2267..f1ab34b47a1 100644
--- a/src/compiler/backend/code-generator.cc
+++ b/src/compiler/backend/code-generator.cc
@@ -228,7 +228,7 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleDeoptimizerCall(
     }
     tasm()->bind(exit->label());
   }
-  Builtins::Name target =
+  Builtin target =
       deopt_kind == DeoptimizeKind::kEagerWithResume
           ? Deoptimizer::GetDeoptWithResumeBuiltin(deoptimization_reason)
           : Deoptimizer::GetDeoptimizationEntry(deopt_kind);
diff --git a/src/compiler/backend/ia32/code-generator-ia32.cc b/src/compiler/backend/ia32/code-generator-ia32.cc
index 74e2cd64831..5ca2b97b1c3 100644
--- a/src/compiler/backend/ia32/code-generator-ia32.cc
+++ b/src/compiler/backend/ia32/code-generator-ia32.cc
@@ -283,7 +283,7 @@ class OutOfLineTruncateDoubleToI final : public OutOfLineCode {
     if (false) {
 #endif  // V8_ENABLE_WEBASSEMBLY
     } else if (tasm()->options().inline_offheap_trampolines) {
-      __ CallBuiltin(Builtins::kDoubleToI);
+      __ CallBuiltin(Builtin::kDoubleToI);
     } else {
       __ Call(BUILTIN_CODE(isolate_, DoubleToI), RelocInfo::CODE_TARGET);
     }
@@ -928,9 +928,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ int3();
       break;
diff --git a/src/compiler/backend/mips/code-generator-mips.cc b/src/compiler/backend/mips/code-generator-mips.cc
index 74c06db65a8..560cd9308b6 100644
--- a/src/compiler/backend/mips/code-generator-mips.cc
+++ b/src/compiler/backend/mips/code-generator-mips.cc
@@ -851,9 +851,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ stop();
       break;
diff --git a/src/compiler/backend/mips64/code-generator-mips64.cc b/src/compiler/backend/mips64/code-generator-mips64.cc
index 9db650eebc1..aa5145ea904 100644
--- a/src/compiler/backend/mips64/code-generator-mips64.cc
+++ b/src/compiler/backend/mips64/code-generator-mips64.cc
@@ -813,9 +813,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ stop();
       break;
diff --git a/src/compiler/backend/ppc/code-generator-ppc.cc b/src/compiler/backend/ppc/code-generator-ppc.cc
index 363f1f8013b..82877c2e0e0 100644
--- a/src/compiler/backend/ppc/code-generator-ppc.cc
+++ b/src/compiler/backend/ppc/code-generator-ppc.cc
@@ -1121,9 +1121,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ stop();
       break;
diff --git a/src/compiler/backend/riscv64/code-generator-riscv64.cc b/src/compiler/backend/riscv64/code-generator-riscv64.cc
index feb886cfaa8..ab226bf4e03 100644
--- a/src/compiler/backend/riscv64/code-generator-riscv64.cc
+++ b/src/compiler/backend/riscv64/code-generator-riscv64.cc
@@ -786,9 +786,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ stop();
       break;
diff --git a/src/compiler/backend/s390/code-generator-s390.cc b/src/compiler/backend/s390/code-generator-s390.cc
index 9afc24f43f5..62b08be89d9 100644
--- a/src/compiler/backend/s390/code-generator-s390.cc
+++ b/src/compiler/backend/s390/code-generator-s390.cc
@@ -1297,9 +1297,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ stop();
       break;
diff --git a/src/compiler/backend/x64/code-generator-x64.cc b/src/compiler/backend/x64/code-generator-x64.cc
index 4f430ea615c..8305fe85a7d 100644
--- a/src/compiler/backend/x64/code-generator-x64.cc
+++ b/src/compiler/backend/x64/code-generator-x64.cc
@@ -237,7 +237,7 @@ class OutOfLineTruncateDoubleToI final : public OutOfLineCode {
     } else if (tasm()->options().inline_offheap_trampolines) {
       // With embedded builtins we do not need the isolate here. This allows
       // the call to be generated asynchronously.
-      __ CallBuiltin(Builtins::kDoubleToI);
+      __ CallBuiltin(Builtin::kDoubleToI);
     } else {
       __ Call(BUILTIN_CODE(isolate_, DoubleToI), RelocInfo::CODE_TARGET);
     }
@@ -1188,9 +1188,8 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleArchInstruction(
         // We don't actually want to generate a pile of code for this, so just
         // claim there is a stack frame, without generating one.
         FrameScope scope(tasm(), StackFrame::NONE);
-        __ Call(
-            isolate()->builtins()->builtin_handle(Builtins::kAbortCSAAssert),
-            RelocInfo::CODE_TARGET);
+        __ Call(isolate()->builtins()->builtin_handle(Builtin::kAbortCSAAssert),
+                RelocInfo::CODE_TARGET);
       }
       __ int3();
       unwinding_info_writer_.MarkBlockWillExit();
diff --git a/src/compiler/bytecode-graph-builder.cc b/src/compiler/bytecode-graph-builder.cc
index 3a2af883547..5e51c8bd8ab 100644
--- a/src/compiler/bytecode-graph-builder.cc
+++ b/src/compiler/bytecode-graph-builder.cc
@@ -2286,7 +2286,7 @@ void BytecodeGraphBuilder::VisitCreateClosure() {
 
   const Operator* op = javascript()->CreateClosure(
       shared_info.object(),
-      jsgraph()->isolate()->builtins()->builtin_handle(Builtins::kCompileLazy),
+      jsgraph()->isolate()->builtins()->builtin_handle(Builtin::kCompileLazy),
       allocation);
   Node* closure = NewNode(
       op, BuildLoadFeedbackCell(bytecode_iterator().GetIndexOperand(1)));
@@ -3661,7 +3661,7 @@ void BytecodeGraphBuilder::VisitIncBlockCounter() {
   Node* coverage_array_slot =
       jsgraph()->Constant(bytecode_iterator().GetIndexOperand(0));
 
-  // Lowered by js-intrinsic-lowering to call Builtins::kIncBlockCounter.
+  // Lowered by js-intrinsic-lowering to call Builtin::kIncBlockCounter.
   const Operator* op =
       javascript()->CallRuntime(Runtime::kInlineIncBlockCounter);
 
diff --git a/src/compiler/code-assembler.h b/src/compiler/code-assembler.h
index 75cb1a95838..d6356405dba 100644
--- a/src/compiler/code-assembler.h
+++ b/src/compiler/code-assembler.h
@@ -1616,13 +1616,13 @@ class V8_EXPORT_PRIVATE CodeAssemblerState {
   CodeAssemblerState(Isolate* isolate, Zone* zone,
                      const CallInterfaceDescriptor& descriptor, CodeKind kind,
                      const char* name, PoisoningMitigationLevel poisoning_level,
-                     int32_t builtin_index = Builtins::kNoBuiltinId);
+                     int32_t builtin_index = Builtin::kNoBuiltinId);
 
   // Create with JSCall linkage.
   CodeAssemblerState(Isolate* isolate, Zone* zone, int parameter_count,
                      CodeKind kind, const char* name,
                      PoisoningMitigationLevel poisoning_level,
-                     int32_t builtin_index = Builtins::kNoBuiltinId);
+                     int32_t builtin_index = Builtin::kNoBuiltinId);
 
   ~CodeAssemblerState();
 
diff --git a/src/compiler/effect-control-linearizer.cc b/src/compiler/effect-control-linearizer.cc
index 9799691ce63..1857dc7fdb5 100644
--- a/src/compiler/effect-control-linearizer.cc
+++ b/src/compiler/effect-control-linearizer.cc
@@ -251,8 +251,7 @@ class EffectControlLinearizer {
   Node* BuildTypedArrayDataPointer(Node* base, Node* external);
 
   template <typename... Args>
-  Node* CallBuiltin(Builtins::Name builtin, Operator::Properties properties,
-                    Args...);
+  Node* CallBuiltin(Builtin builtin, Operator::Properties properties, Args...);
 
   Node* ChangeBitToTagged(Node* value);
   Node* ChangeFloat64ToTagged(Node* value, CheckForMinusZeroMode mode);
@@ -3075,7 +3074,7 @@ Node* EffectControlLinearizer::LowerNumberToString(Node* node) {
   Node* argument = node->InputAt(0);
 
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kNumberToString);
+      Builtins::CallableFor(isolate(), Builtin::kNumberToString);
   Operator::Properties properties = Operator::kEliminatable;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -3571,7 +3570,7 @@ Node* EffectControlLinearizer::LowerObjectIsUndetectable(Node* node) {
 
 Node* EffectControlLinearizer::LowerTypeOf(Node* node) {
   Node* obj = node->InputAt(0);
-  Callable const callable = Builtins::CallableFor(isolate(), Builtins::kTypeof);
+  Callable const callable = Builtins::CallableFor(isolate(), Builtin::kTypeof);
   Operator::Properties const properties = Operator::kEliminatable;
   CallDescriptor::Flags const flags = CallDescriptor::kNoAllocate;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -3652,7 +3651,7 @@ void EffectControlLinearizer::LowerUpdateInterruptBudget(Node* node) {
               &if_budget_exhausted, &next);
 
     __ Bind(&if_budget_exhausted);
-    CallBuiltin(Builtins::kBytecodeBudgetInterruptFromCode,
+    CallBuiltin(Builtin::kBytecodeBudgetInterruptFromCode,
                 node->op()->properties(), feedback_cell);
     __ Goto(&next);
 
@@ -3663,7 +3662,7 @@ void EffectControlLinearizer::LowerUpdateInterruptBudget(Node* node) {
 Node* EffectControlLinearizer::LowerToBoolean(Node* node) {
   Node* obj = node->InputAt(0);
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kToBoolean);
+      Builtins::CallableFor(isolate(), Builtin::kToBoolean);
   Operator::Properties const properties = Operator::kEliminatable;
   CallDescriptor::Flags const flags = CallDescriptor::kNoAllocate;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -3799,16 +3798,16 @@ Node* EffectControlLinearizer::LowerNewArgumentsElements(Node* node) {
   CallDescriptor::Flags const flags = CallDescriptor::kNoFlags;
   Node* frame = __ LoadFramePointer();
   Node* arguments_count = NodeProperties::GetValueInput(node, 0);
-  Builtins::Name builtin_name;
+  Builtin builtin_name;
   switch (type) {
     case CreateArgumentsType::kMappedArguments:
-      builtin_name = Builtins::kNewSloppyArgumentsElements;
+      builtin_name = Builtin::kNewSloppyArgumentsElements;
       break;
     case CreateArgumentsType::kUnmappedArguments:
-      builtin_name = Builtins::kNewStrictArgumentsElements;
+      builtin_name = Builtin::kNewStrictArgumentsElements;
       break;
     case CreateArgumentsType::kRestParameter:
-      builtin_name = Builtins::kNewRestArgumentsElements;
+      builtin_name = Builtin::kNewRestArgumentsElements;
       break;
   }
   Callable const callable = Builtins::CallableFor(isolate(), builtin_name);
@@ -3871,7 +3870,7 @@ Node* EffectControlLinearizer::LowerSameValue(Node* node) {
   Node* rhs = node->InputAt(1);
 
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kSameValue);
+      Builtins::CallableFor(isolate(), Builtin::kSameValue);
   Operator::Properties properties = Operator::kEliminatable;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -3886,7 +3885,7 @@ Node* EffectControlLinearizer::LowerSameValueNumbersOnly(Node* node) {
   Node* rhs = node->InputAt(1);
 
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kSameValueNumbersOnly);
+      Builtins::CallableFor(isolate(), Builtin::kSameValueNumbersOnly);
   Operator::Properties properties = Operator::kEliminatable;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -3938,7 +3937,7 @@ Node* EffectControlLinearizer::LowerStringToNumber(Node* node) {
   Node* string = node->InputAt(0);
 
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kStringToNumber);
+      Builtins::CallableFor(isolate(), Builtin::kStringToNumber);
   Operator::Properties properties = Operator::kEliminatable;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -4102,7 +4101,7 @@ Node* EffectControlLinearizer::LowerStringCodePointAt(Node* node) {
   Node* position = node->InputAt(1);
 
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kStringCodePointAt);
+      Builtins::CallableFor(isolate(), Builtin::kStringCodePointAt);
   Operator::Properties properties = Operator::kNoThrow | Operator::kNoWrite;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -4215,7 +4214,7 @@ Node* EffectControlLinearizer::LowerStringToLowerCaseIntl(Node* node) {
   Node* receiver = node->InputAt(0);
 
   Callable callable =
-      Builtins::CallableFor(isolate(), Builtins::kStringToLowerCaseIntl);
+      Builtins::CallableFor(isolate(), Builtin::kStringToLowerCaseIntl);
   Operator::Properties properties = Operator::kNoDeopt | Operator::kNoThrow;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -4380,8 +4379,7 @@ Node* EffectControlLinearizer::LowerStringIndexOf(Node* node) {
   Node* search_string = node->InputAt(1);
   Node* position = node->InputAt(2);
 
-  Callable callable =
-      Builtins::CallableFor(isolate(), Builtins::kStringIndexOf);
+  Callable callable = Builtins::CallableFor(isolate(), Builtin::kStringIndexOf);
   Operator::Properties properties = Operator::kEliminatable;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -4396,7 +4394,7 @@ Node* EffectControlLinearizer::LowerStringFromCodePointAt(Node* node) {
   Node* index = node->InputAt(1);
 
   Callable callable =
-      Builtins::CallableFor(isolate(), Builtins::kStringFromCodePointAt);
+      Builtins::CallableFor(isolate(), Builtin::kStringFromCodePointAt);
   Operator::Properties properties = Operator::kEliminatable;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -4432,7 +4430,7 @@ Node* EffectControlLinearizer::LowerStringSubstring(Node* node) {
   Node* end = ChangeInt32ToIntPtr(node->InputAt(2));
 
   Callable callable =
-      Builtins::CallableFor(isolate(), Builtins::kStringSubstring);
+      Builtins::CallableFor(isolate(), Builtin::kStringSubstring);
   Operator::Properties properties = Operator::kEliminatable;
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -4444,17 +4442,17 @@ Node* EffectControlLinearizer::LowerStringSubstring(Node* node) {
 
 Node* EffectControlLinearizer::LowerStringEqual(Node* node) {
   return LowerStringComparison(
-      Builtins::CallableFor(isolate(), Builtins::kStringEqual), node);
+      Builtins::CallableFor(isolate(), Builtin::kStringEqual), node);
 }
 
 Node* EffectControlLinearizer::LowerStringLessThan(Node* node) {
   return LowerStringComparison(
-      Builtins::CallableFor(isolate(), Builtins::kStringLessThan), node);
+      Builtins::CallableFor(isolate(), Builtin::kStringLessThan), node);
 }
 
 Node* EffectControlLinearizer::LowerStringLessThanOrEqual(Node* node) {
   return LowerStringComparison(
-      Builtins::CallableFor(isolate(), Builtins::kStringLessThanOrEqual), node);
+      Builtins::CallableFor(isolate(), Builtin::kStringLessThanOrEqual), node);
 }
 
 Node* EffectControlLinearizer::LowerBigIntAdd(Node* node, Node* frame_state) {
@@ -4462,7 +4460,7 @@ Node* EffectControlLinearizer::LowerBigIntAdd(Node* node, Node* frame_state) {
   Node* rhs = node->InputAt(1);
 
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kBigIntAddNoThrow);
+      Builtins::CallableFor(isolate(), Builtin::kBigIntAddNoThrow);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       graph()->zone(), callable.descriptor(),
       callable.descriptor().GetStackParameterCount(), CallDescriptor::kNoFlags,
@@ -4483,7 +4481,7 @@ Node* EffectControlLinearizer::LowerBigIntSubtract(Node* node,
   Node* rhs = node->InputAt(1);
 
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kBigIntSubtractNoThrow);
+      Builtins::CallableFor(isolate(), Builtin::kBigIntSubtractNoThrow);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       graph()->zone(), callable.descriptor(),
       callable.descriptor().GetStackParameterCount(), CallDescriptor::kNoFlags,
@@ -4500,7 +4498,7 @@ Node* EffectControlLinearizer::LowerBigIntSubtract(Node* node,
 
 Node* EffectControlLinearizer::LowerBigIntNegate(Node* node) {
   Callable const callable =
-      Builtins::CallableFor(isolate(), Builtins::kBigIntUnaryMinus);
+      Builtins::CallableFor(isolate(), Builtin::kBigIntUnaryMinus);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       graph()->zone(), callable.descriptor(),
       callable.descriptor().GetStackParameterCount(), CallDescriptor::kNoFlags,
@@ -4849,7 +4847,7 @@ Node* EffectControlLinearizer::LowerEnsureWritableFastElements(Node* node) {
   // We need to take a copy of the {elements} and set them up for {object}.
   Operator::Properties properties = Operator::kEliminatable;
   Callable callable =
-      Builtins::CallableFor(isolate(), Builtins::kCopyFastSmiOrObjectElements);
+      Builtins::CallableFor(isolate(), Builtin::kCopyFastSmiOrObjectElements);
   CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       graph()->zone(), callable.descriptor(),
@@ -4884,9 +4882,9 @@ Node* EffectControlLinearizer::LowerMaybeGrowFastElements(Node* node,
   Operator::Properties properties = Operator::kEliminatable;
   Callable callable =
       (params.mode() == GrowFastElementsMode::kDoubleElements)
-          ? Builtins::CallableFor(isolate(), Builtins::kGrowFastDoubleElements)
+          ? Builtins::CallableFor(isolate(), Builtin::kGrowFastDoubleElements)
           : Builtins::CallableFor(isolate(),
-                                  Builtins::kGrowFastSmiOrObjectElements);
+                                  Builtin::kGrowFastSmiOrObjectElements);
   CallDescriptor::Flags call_flags = CallDescriptor::kNoFlags;
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       graph()->zone(), callable.descriptor(),
@@ -5852,7 +5850,7 @@ void EffectControlLinearizer::LowerRuntimeAbort(Node* node) {
 }
 
 template <typename... Args>
-Node* EffectControlLinearizer::CallBuiltin(Builtins::Name builtin,
+Node* EffectControlLinearizer::CallBuiltin(Builtin builtin,
                                            Operator::Properties properties,
                                            Args... args) {
   Callable const callable = Builtins::CallableFor(isolate(), builtin);
@@ -5871,7 +5869,7 @@ Node* EffectControlLinearizer::LowerAssertType(Node* node) {
   Node* const input = node->InputAt(0);
   Node* const min = __ NumberConstant(type.Min());
   Node* const max = __ NumberConstant(type.Max());
-  CallBuiltin(Builtins::kCheckNumberInRange, node->op()->properties(), input,
+  CallBuiltin(Builtin::kCheckNumberInRange, node->op()->properties(), input,
               min, max, __ SmiConstant(node->id()));
   return input;
 }
@@ -5880,7 +5878,7 @@ Node* EffectControlLinearizer::LowerFoldConstant(Node* node) {
   DCHECK_EQ(node->opcode(), IrOpcode::kFoldConstant);
   Node* original = node->InputAt(0);
   Node* constant = node->InputAt(1);
-  CallBuiltin(Builtins::kCheckSameObject, node->op()->properties(), original,
+  CallBuiltin(Builtin::kCheckSameObject, node->op()->properties(), original,
               constant);
   return constant;
 }
@@ -5912,7 +5910,7 @@ Node* EffectControlLinearizer::LowerConvertReceiver(Node* node) {
       // Wrap the primitive {value} into a JSPrimitiveWrapper.
       __ Bind(&convert_to_object);
       Operator::Properties properties = Operator::kEliminatable;
-      Callable callable = Builtins::CallableFor(isolate(), Builtins::kToObject);
+      Callable callable = Builtins::CallableFor(isolate(), Builtin::kToObject);
       CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
       auto call_descriptor = Linkage::GetStubCallDescriptor(
           graph()->zone(), callable.descriptor(),
@@ -5949,7 +5947,7 @@ Node* EffectControlLinearizer::LowerConvertReceiver(Node* node) {
       __ GotoIf(__ TaggedEqual(value, __ NullConstant()),
                 &convert_global_proxy);
       Operator::Properties properties = Operator::kEliminatable;
-      Callable callable = Builtins::CallableFor(isolate(), Builtins::kToObject);
+      Callable callable = Builtins::CallableFor(isolate(), Builtin::kToObject);
       CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
       auto call_descriptor = Linkage::GetStubCallDescriptor(
           graph()->zone(), callable.descriptor(),
@@ -6310,7 +6308,7 @@ Node* EffectControlLinearizer::LowerFindOrderedHashMapEntry(Node* node) {
 
   {
     Callable const callable =
-        Builtins::CallableFor(isolate(), Builtins::kFindOrderedHashMapEntry);
+        Builtins::CallableFor(isolate(), Builtin::kFindOrderedHashMapEntry);
     Operator::Properties const properties = node->op()->properties();
     CallDescriptor::Flags const flags = CallDescriptor::kNoFlags;
     auto call_descriptor = Linkage::GetStubCallDescriptor(
diff --git a/src/compiler/frame-states.cc b/src/compiler/frame-states.cc
index 8e630778adc..bbc2049ae5d 100644
--- a/src/compiler/frame-states.cc
+++ b/src/compiler/frame-states.cc
@@ -111,8 +111,8 @@ uint8_t DeoptimizerParameterCountFor(ContinuationFrameStateMode mode) {
 }
 
 FrameState CreateBuiltinContinuationFrameStateCommon(
-    JSGraph* jsgraph, FrameStateType frame_type, Builtins::Name name,
-    Node* closure, Node* context, Node** parameters, int parameter_count,
+    JSGraph* jsgraph, FrameStateType frame_type, Builtin name, Node* closure,
+    Node* context, Node** parameters, int parameter_count,
     Node* outer_frame_state,
     Handle<SharedFunctionInfo> shared = Handle<SharedFunctionInfo>(),
     const wasm::FunctionSig* signature = nullptr) {
@@ -147,8 +147,8 @@ FrameState CreateBuiltinContinuationFrameStateCommon(
 }  // namespace
 
 FrameState CreateStubBuiltinContinuationFrameState(
-    JSGraph* jsgraph, Builtins::Name name, Node* context,
-    Node* const* parameters, int parameter_count, Node* outer_frame_state,
+    JSGraph* jsgraph, Builtin name, Node* context, Node* const* parameters,
+    int parameter_count, Node* outer_frame_state,
     ContinuationFrameStateMode mode, const wasm::FunctionSig* signature) {
   Callable callable = Builtins::CallableFor(jsgraph->isolate(), name);
   CallInterfaceDescriptor descriptor = callable.descriptor();
@@ -180,7 +180,7 @@ FrameState CreateStubBuiltinContinuationFrameState(
 
   FrameStateType frame_state_type = FrameStateType::kBuiltinContinuation;
 #if V8_ENABLE_WEBASSEMBLY
-  if (name == Builtins::kJSToWasmLazyDeoptContinuation) {
+  if (name == Builtin::kJSToWasmLazyDeoptContinuation) {
     CHECK_NOT_NULL(signature);
     frame_state_type = FrameStateType::kJSToWasmBuiltinContinuation;
   }
@@ -201,14 +201,14 @@ FrameState CreateJSWasmCallBuiltinContinuationFrameState(
       jsgraph->SmiConstant(wasm_return_kind ? wasm_return_kind.value() : -1);
   Node* lazy_deopt_parameters[] = {node_return_type};
   return CreateStubBuiltinContinuationFrameState(
-      jsgraph, Builtins::kJSToWasmLazyDeoptContinuation, context,
+      jsgraph, Builtin::kJSToWasmLazyDeoptContinuation, context,
       lazy_deopt_parameters, arraysize(lazy_deopt_parameters),
       outer_frame_state, ContinuationFrameStateMode::LAZY, signature);
 }
 #endif  // V8_ENABLE_WEBASSEMBLY
 
 FrameState CreateJavaScriptBuiltinContinuationFrameState(
-    JSGraph* jsgraph, const SharedFunctionInfoRef& shared, Builtins::Name name,
+    JSGraph* jsgraph, const SharedFunctionInfoRef& shared, Builtin name,
     Node* target, Node* context, Node* const* stack_parameters,
     int stack_parameter_count, Node* outer_frame_state,
     ContinuationFrameStateMode mode) {
@@ -252,7 +252,7 @@ FrameState CreateGenericLazyDeoptContinuationFrameState(
   Node* stack_parameters[]{receiver};
   const int stack_parameter_count = arraysize(stack_parameters);
   return CreateJavaScriptBuiltinContinuationFrameState(
-      graph, shared, Builtins::kGenericLazyDeoptContinuation, target, context,
+      graph, shared, Builtin::kGenericLazyDeoptContinuation, target, context,
       stack_parameters, stack_parameter_count, outer_frame_state,
       ContinuationFrameStateMode::LAZY);
 }
diff --git a/src/compiler/frame-states.h b/src/compiler/frame-states.h
index e6d5416cc9f..6f0213e19bd 100644
--- a/src/compiler/frame-states.h
+++ b/src/compiler/frame-states.h
@@ -174,7 +174,7 @@ enum class ContinuationFrameStateMode { EAGER, LAZY, LAZY_WITH_CATCH };
 class FrameState;
 
 FrameState CreateStubBuiltinContinuationFrameState(
-    JSGraph* graph, Builtins::Name name, Node* context, Node* const* parameters,
+    JSGraph* graph, Builtin name, Node* context, Node* const* parameters,
     int parameter_count, Node* outer_frame_state,
     ContinuationFrameStateMode mode,
     const wasm::FunctionSig* signature = nullptr);
@@ -186,7 +186,7 @@ FrameState CreateJSWasmCallBuiltinContinuationFrameState(
 #endif  // V8_ENABLE_WEBASSEMBLY
 
 FrameState CreateJavaScriptBuiltinContinuationFrameState(
-    JSGraph* graph, const SharedFunctionInfoRef& shared, Builtins::Name name,
+    JSGraph* graph, const SharedFunctionInfoRef& shared, Builtin name,
     Node* target, Node* context, Node* const* stack_parameters,
     int stack_parameter_count, Node* outer_frame_state,
     ContinuationFrameStateMode mode);
diff --git a/src/compiler/graph-assembler.cc b/src/compiler/graph-assembler.cc
index 73938a5fb97..64f5d0c5844 100644
--- a/src/compiler/graph-assembler.cc
+++ b/src/compiler/graph-assembler.cc
@@ -1062,7 +1062,7 @@ void GraphAssembler::InitializeEffectControl(Node* effect, Node* control) {
 Operator const* JSGraphAssembler::PlainPrimitiveToNumberOperator() {
   if (!to_number_operator_.is_set()) {
     Callable callable =
-        Builtins::CallableFor(isolate(), Builtins::kPlainPrimitiveToNumber);
+        Builtins::CallableFor(isolate(), Builtin::kPlainPrimitiveToNumber);
     CallDescriptor::Flags flags = CallDescriptor::kNoFlags;
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         graph()->zone(), callable.descriptor(),
diff --git a/src/compiler/heap-refs.cc b/src/compiler/heap-refs.cc
index 50f424b6dfb..3dde6f4a462 100644
--- a/src/compiler/heap-refs.cc
+++ b/src/compiler/heap-refs.cc
@@ -2007,7 +2007,7 @@ SharedFunctionInfoData::SharedFunctionInfoData(
     Handle<SharedFunctionInfo> object)
     : HeapObjectData(broker, storage, object),
       builtin_id_(object->HasBuiltinId() ? object->builtin_id()
-                                         : Builtins::kNoBuiltinId),
+                                         : Builtin::kNoBuiltinId),
       context_header_size_(object->scope_info().ContextHeaderLength()),
       GetBytecodeArray_(object->HasBytecodeArray()
                             ? broker->GetOrCreateData(
@@ -2021,7 +2021,7 @@ SharedFunctionInfoData::SharedFunctionInfoData(
       function_template_info_(nullptr),
       template_objects_(broker->zone()),
       scope_info_(nullptr) {
-  DCHECK_EQ(HasBuiltinId_, builtin_id_ != Builtins::kNoBuiltinId);
+  DCHECK_EQ(HasBuiltinId_, builtin_id_ != Builtin::kNoBuiltinId);
   DCHECK_EQ(HasBytecodeArray_, GetBytecodeArray_ != nullptr);
 }
 
diff --git a/src/compiler/js-call-reducer.cc b/src/compiler/js-call-reducer.cc
index 2ffc19fa697..87bde1c5c39 100644
--- a/src/compiler/js-call-reducer.cc
+++ b/src/compiler/js-call-reducer.cc
@@ -841,7 +841,7 @@ class PromiseBuiltinReducerAssembler : public JSCallReducerAssembler {
     Handle<FeedbackCell> feedback_cell =
         isolate()->factory()->many_closures_cell();
     Callable const callable = Builtins::CallableFor(
-        isolate(), static_cast<Builtins::Name>(shared.builtin_id()));
+        isolate(), static_cast<Builtin>(shared.builtin_id()));
     return AddNode<JSFunction>(graph()->NewNode(
         javascript()->CreateClosure(shared.object(), callable.code()),
         HeapConstant(feedback_cell), context, effect(), control()));
@@ -1237,7 +1237,7 @@ struct ForEachFrameStateParams {
 
 FrameState ForEachLoopLazyFrameState(const ForEachFrameStateParams& params,
                                      TNode<Object> k) {
-  Builtins::Name builtin = Builtins::kArrayForEachLoopLazyDeoptContinuation;
+  Builtin builtin = Builtin::kArrayForEachLoopLazyDeoptContinuation;
   Node* checkpoint_params[] = {params.receiver, params.callback,
                                params.this_arg, k, params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
@@ -1248,7 +1248,7 @@ FrameState ForEachLoopLazyFrameState(const ForEachFrameStateParams& params,
 
 FrameState ForEachLoopEagerFrameState(const ForEachFrameStateParams& params,
                                       TNode<Object> k) {
-  Builtins::Name builtin = Builtins::kArrayForEachLoopEagerDeoptContinuation;
+  Builtin builtin = Builtin::kArrayForEachLoopEagerDeoptContinuation;
   Node* checkpoint_params[] = {params.receiver, params.callback,
                                params.this_arg, k, params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
@@ -1317,10 +1317,9 @@ FrameState ReducePreLoopLazyFrameState(const ReduceFrameStateParams& params,
                                        TNode<Object> receiver,
                                        TNode<Object> callback, TNode<Object> k,
                                        TNode<Number> original_length) {
-  Builtins::Name builtin =
-      (params.direction == ArrayReduceDirection::kLeft)
-          ? Builtins::kArrayReduceLoopLazyDeoptContinuation
-          : Builtins::kArrayReduceRightLoopLazyDeoptContinuation;
+  Builtin builtin = (params.direction == ArrayReduceDirection::kLeft)
+                        ? Builtin::kArrayReduceLoopLazyDeoptContinuation
+                        : Builtin::kArrayReduceRightLoopLazyDeoptContinuation;
   Node* checkpoint_params[] = {receiver, callback, k, original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared, builtin, params.target, params.context,
@@ -1332,10 +1331,10 @@ FrameState ReducePreLoopEagerFrameState(const ReduceFrameStateParams& params,
                                         TNode<Object> receiver,
                                         TNode<Object> callback,
                                         TNode<Number> original_length) {
-  Builtins::Name builtin =
+  Builtin builtin =
       (params.direction == ArrayReduceDirection::kLeft)
-          ? Builtins::kArrayReducePreLoopEagerDeoptContinuation
-          : Builtins::kArrayReduceRightPreLoopEagerDeoptContinuation;
+          ? Builtin::kArrayReducePreLoopEagerDeoptContinuation
+          : Builtin::kArrayReduceRightPreLoopEagerDeoptContinuation;
   Node* checkpoint_params[] = {receiver, callback, original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared, builtin, params.target, params.context,
@@ -1347,10 +1346,9 @@ FrameState ReduceLoopLazyFrameState(const ReduceFrameStateParams& params,
                                     TNode<Object> receiver,
                                     TNode<Object> callback, TNode<Object> k,
                                     TNode<Number> original_length) {
-  Builtins::Name builtin =
-      (params.direction == ArrayReduceDirection::kLeft)
-          ? Builtins::kArrayReduceLoopLazyDeoptContinuation
-          : Builtins::kArrayReduceRightLoopLazyDeoptContinuation;
+  Builtin builtin = (params.direction == ArrayReduceDirection::kLeft)
+                        ? Builtin::kArrayReduceLoopLazyDeoptContinuation
+                        : Builtin::kArrayReduceRightLoopLazyDeoptContinuation;
   Node* checkpoint_params[] = {receiver, callback, k, original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared, builtin, params.target, params.context,
@@ -1363,10 +1361,9 @@ FrameState ReduceLoopEagerFrameState(const ReduceFrameStateParams& params,
                                      TNode<Object> callback, TNode<Object> k,
                                      TNode<Number> original_length,
                                      TNode<Object> accumulator) {
-  Builtins::Name builtin =
-      (params.direction == ArrayReduceDirection::kLeft)
-          ? Builtins::kArrayReduceLoopEagerDeoptContinuation
-          : Builtins::kArrayReduceRightLoopEagerDeoptContinuation;
+  Builtin builtin = (params.direction == ArrayReduceDirection::kLeft)
+                        ? Builtin::kArrayReduceLoopEagerDeoptContinuation
+                        : Builtin::kArrayReduceRightLoopEagerDeoptContinuation;
   Node* checkpoint_params[] = {receiver, callback, k, original_length,
                                accumulator};
   return CreateJavaScriptBuiltinContinuationFrameState(
@@ -1501,7 +1498,7 @@ FrameState MapPreLoopLazyFrameState(const MapFrameStateParams& params) {
                                params.this_arg, params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared,
-      Builtins::kArrayMapPreLoopLazyDeoptContinuation, params.target,
+      Builtin::kArrayMapPreLoopLazyDeoptContinuation, params.target,
       params.context, checkpoint_params, arraysize(checkpoint_params),
       params.outer_frame_state, ContinuationFrameStateMode::LAZY);
 }
@@ -1513,7 +1510,7 @@ FrameState MapLoopLazyFrameState(const MapFrameStateParams& params,
       params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared,
-      Builtins::kArrayMapLoopLazyDeoptContinuation, params.target,
+      Builtin::kArrayMapLoopLazyDeoptContinuation, params.target,
       params.context, checkpoint_params, arraysize(checkpoint_params),
       params.outer_frame_state, ContinuationFrameStateMode::LAZY);
 }
@@ -1525,7 +1522,7 @@ FrameState MapLoopEagerFrameState(const MapFrameStateParams& params,
       params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared,
-      Builtins::kArrayMapLoopEagerDeoptContinuation, params.target,
+      Builtin::kArrayMapLoopEagerDeoptContinuation, params.target,
       params.context, checkpoint_params, arraysize(checkpoint_params),
       params.outer_frame_state, ContinuationFrameStateMode::EAGER);
 }
@@ -1625,7 +1622,7 @@ FrameState FilterLoopLazyFrameState(const FilterFrameStateParams& params,
                                to};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared,
-      Builtins::kArrayFilterLoopLazyDeoptContinuation, params.target,
+      Builtin::kArrayFilterLoopLazyDeoptContinuation, params.target,
       params.context, checkpoint_params, arraysize(checkpoint_params),
       params.outer_frame_state, ContinuationFrameStateMode::LAZY);
 }
@@ -1634,9 +1631,9 @@ FrameState FilterLoopEagerPostCallbackFrameState(
     const FilterFrameStateParams& params, TNode<Number> k, TNode<Number> to,
     TNode<Object> element, TNode<Object> callback_value) {
   // Note that we are intentionally reusing the
-  // Builtins::kArrayFilterLoopLazyDeoptContinuation as an *eager* entry point
-  // in this case. This is safe, because re-evaluating a [ToBoolean] coercion is
-  // safe.
+  // Builtin::kArrayFilterLoopLazyDeoptContinuation as an *eager* entry
+  // point in this case. This is safe, because re-evaluating a [ToBoolean]
+  // coercion is safe.
   Node* checkpoint_params[] = {params.receiver,
                                params.callback,
                                params.this_arg,
@@ -1648,7 +1645,7 @@ FrameState FilterLoopEagerPostCallbackFrameState(
                                callback_value};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared,
-      Builtins::kArrayFilterLoopLazyDeoptContinuation, params.target,
+      Builtin::kArrayFilterLoopLazyDeoptContinuation, params.target,
       params.context, checkpoint_params, arraysize(checkpoint_params),
       params.outer_frame_state, ContinuationFrameStateMode::EAGER);
 }
@@ -1664,7 +1661,7 @@ FrameState FilterLoopEagerFrameState(const FilterFrameStateParams& params,
                                to};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared,
-      Builtins::kArrayFilterLoopEagerDeoptContinuation, params.target,
+      Builtin::kArrayFilterLoopEagerDeoptContinuation, params.target,
       params.context, checkpoint_params, arraysize(checkpoint_params),
       params.outer_frame_state, ContinuationFrameStateMode::EAGER);
 }
@@ -1766,10 +1763,9 @@ struct FindFrameStateParams {
 
 FrameState FindLoopLazyFrameState(const FindFrameStateParams& params,
                                   TNode<Number> k, ArrayFindVariant variant) {
-  Builtins::Name builtin =
-      (variant == ArrayFindVariant::kFind)
-          ? Builtins::kArrayFindLoopLazyDeoptContinuation
-          : Builtins::kArrayFindIndexLoopLazyDeoptContinuation;
+  Builtin builtin = (variant == ArrayFindVariant::kFind)
+                        ? Builtin::kArrayFindLoopLazyDeoptContinuation
+                        : Builtin::kArrayFindIndexLoopLazyDeoptContinuation;
   Node* checkpoint_params[] = {params.receiver, params.callback,
                                params.this_arg, k, params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
@@ -1780,10 +1776,9 @@ FrameState FindLoopLazyFrameState(const FindFrameStateParams& params,
 
 FrameState FindLoopEagerFrameState(const FindFrameStateParams& params,
                                    TNode<Number> k, ArrayFindVariant variant) {
-  Builtins::Name builtin =
-      (variant == ArrayFindVariant::kFind)
-          ? Builtins::kArrayFindLoopEagerDeoptContinuation
-          : Builtins::kArrayFindIndexLoopEagerDeoptContinuation;
+  Builtin builtin = (variant == ArrayFindVariant::kFind)
+                        ? Builtin::kArrayFindLoopEagerDeoptContinuation
+                        : Builtin::kArrayFindIndexLoopEagerDeoptContinuation;
   Node* checkpoint_params[] = {params.receiver, params.callback,
                                params.this_arg, k, params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
@@ -1795,10 +1790,10 @@ FrameState FindLoopEagerFrameState(const FindFrameStateParams& params,
 FrameState FindLoopAfterCallbackLazyFrameState(
     const FindFrameStateParams& params, TNode<Number> next_k,
     TNode<Object> if_found_value, ArrayFindVariant variant) {
-  Builtins::Name builtin =
+  Builtin builtin =
       (variant == ArrayFindVariant::kFind)
-          ? Builtins::kArrayFindLoopAfterCallbackLazyDeoptContinuation
-          : Builtins::kArrayFindIndexLoopAfterCallbackLazyDeoptContinuation;
+          ? Builtin::kArrayFindLoopAfterCallbackLazyDeoptContinuation
+          : Builtin::kArrayFindIndexLoopAfterCallbackLazyDeoptContinuation;
   Node* checkpoint_params[] = {params.receiver,        params.callback,
                                params.this_arg,        next_k,
                                params.original_length, if_found_value};
@@ -1884,9 +1879,9 @@ struct EverySomeFrameStateParams {
 FrameState EverySomeLoopLazyFrameState(const EverySomeFrameStateParams& params,
                                        TNode<Number> k,
                                        ArrayEverySomeVariant variant) {
-  Builtins::Name builtin = (variant == ArrayEverySomeVariant::kEvery)
-                               ? Builtins::kArrayEveryLoopLazyDeoptContinuation
-                               : Builtins::kArraySomeLoopLazyDeoptContinuation;
+  Builtin builtin = (variant == ArrayEverySomeVariant::kEvery)
+                        ? Builtin::kArrayEveryLoopLazyDeoptContinuation
+                        : Builtin::kArraySomeLoopLazyDeoptContinuation;
   Node* checkpoint_params[] = {params.receiver, params.callback,
                                params.this_arg, k, params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
@@ -1898,9 +1893,9 @@ FrameState EverySomeLoopLazyFrameState(const EverySomeFrameStateParams& params,
 FrameState EverySomeLoopEagerFrameState(const EverySomeFrameStateParams& params,
                                         TNode<Number> k,
                                         ArrayEverySomeVariant variant) {
-  Builtins::Name builtin = (variant == ArrayEverySomeVariant::kEvery)
-                               ? Builtins::kArrayEveryLoopEagerDeoptContinuation
-                               : Builtins::kArraySomeLoopEagerDeoptContinuation;
+  Builtin builtin = (variant == ArrayEverySomeVariant::kEvery)
+                        ? Builtin::kArrayEveryLoopEagerDeoptContinuation
+                        : Builtin::kArraySomeLoopEagerDeoptContinuation;
   Node* checkpoint_params[] = {params.receiver, params.callback,
                                params.this_arg, k, params.original_length};
   return CreateJavaScriptBuiltinContinuationFrameState(
@@ -1978,14 +1973,14 @@ Callable GetCallableForArrayIndexOfIncludes(ArrayIndexOfIncludesVariant variant,
       case PACKED_ELEMENTS:
       case HOLEY_ELEMENTS:
         return Builtins::CallableFor(isolate,
-                                     Builtins::kArrayIndexOfSmiOrObject);
+                                     Builtin::kArrayIndexOfSmiOrObject);
       case PACKED_DOUBLE_ELEMENTS:
         return Builtins::CallableFor(isolate,
-                                     Builtins::kArrayIndexOfPackedDoubles);
+                                     Builtin::kArrayIndexOfPackedDoubles);
       default:
         DCHECK_EQ(HOLEY_DOUBLE_ELEMENTS, elements_kind);
         return Builtins::CallableFor(isolate,
-                                     Builtins::kArrayIndexOfHoleyDoubles);
+                                     Builtin::kArrayIndexOfHoleyDoubles);
     }
   } else {
     DCHECK_EQ(variant, ArrayIndexOfIncludesVariant::kIncludes);
@@ -1995,14 +1990,14 @@ Callable GetCallableForArrayIndexOfIncludes(ArrayIndexOfIncludesVariant variant,
       case PACKED_ELEMENTS:
       case HOLEY_ELEMENTS:
         return Builtins::CallableFor(isolate,
-                                     Builtins::kArrayIncludesSmiOrObject);
+                                     Builtin::kArrayIncludesSmiOrObject);
       case PACKED_DOUBLE_ELEMENTS:
         return Builtins::CallableFor(isolate,
-                                     Builtins::kArrayIncludesPackedDoubles);
+                                     Builtin::kArrayIncludesPackedDoubles);
       default:
         DCHECK_EQ(HOLEY_DOUBLE_ELEMENTS, elements_kind);
         return Builtins::CallableFor(isolate,
-                                     Builtins::kArrayIncludesHoleyDoubles);
+                                     Builtin::kArrayIncludesHoleyDoubles);
     }
   }
   UNREACHABLE();
@@ -2116,10 +2111,10 @@ FrameState PromiseConstructorLazyFrameState(
       jsgraph->TheHoleConstant()    /* exception */
   };
   return CreateJavaScriptBuiltinContinuationFrameState(
-      jsgraph, params.shared,
-      Builtins::kPromiseConstructorLazyDeoptContinuation, params.target,
-      params.context, checkpoint_params, arraysize(checkpoint_params),
-      constructor_frame_state, ContinuationFrameStateMode::LAZY);
+      jsgraph, params.shared, Builtin::kPromiseConstructorLazyDeoptContinuation,
+      params.target, params.context, checkpoint_params,
+      arraysize(checkpoint_params), constructor_frame_state,
+      ContinuationFrameStateMode::LAZY);
 }
 
 FrameState PromiseConstructorLazyWithCatchFrameState(
@@ -2133,7 +2128,7 @@ FrameState PromiseConstructorLazyWithCatchFrameState(
       promise, reject};
   return CreateJavaScriptBuiltinContinuationFrameState(
       params.jsgraph, params.shared,
-      Builtins::kPromiseConstructorLazyDeoptContinuation, params.target,
+      Builtin::kPromiseConstructorLazyDeoptContinuation, params.target,
       params.context, checkpoint_params, arraysize(checkpoint_params),
       constructor_frame_state, ContinuationFrameStateMode::LAZY_WITH_CATCH);
 }
@@ -3073,8 +3068,7 @@ Reduction JSCallReducer::ReduceReflectGet(Node* node) {
   Node* etrue = effect;
   Node* vtrue;
   {
-    Callable callable =
-        Builtins::CallableFor(isolate(), Builtins::kGetProperty);
+    Callable callable = Builtins::CallableFor(isolate(), Builtin::kGetProperty);
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         graph()->zone(), callable.descriptor(),
         callable.descriptor().GetStackParameterCount(),
@@ -3737,14 +3731,14 @@ Reduction JSCallReducer::ReduceCallApiFunction(
       // and/or the compatible receiver check, so use the generic builtin
       // that does those checks dynamically. This is still significantly
       // faster than the generic call sequence.
-      Builtins::Name builtin_name;
+      Builtin builtin_name;
       if (function_template_info.accept_any_receiver()) {
-        builtin_name = Builtins::kCallFunctionTemplate_CheckCompatibleReceiver;
+        builtin_name = Builtin::kCallFunctionTemplate_CheckCompatibleReceiver;
       } else if (function_template_info.is_signature_undefined()) {
-        builtin_name = Builtins::kCallFunctionTemplate_CheckAccess;
+        builtin_name = Builtin::kCallFunctionTemplate_CheckAccess;
       } else {
         builtin_name =
-            Builtins::kCallFunctionTemplate_CheckAccessAndCompatibleReceiver;
+            Builtin::kCallFunctionTemplate_CheckAccessAndCompatibleReceiver;
       }
 
       // The CallFunctionTemplate builtin requires the {receiver} to be
@@ -4508,333 +4502,333 @@ Reduction JSCallReducer::ReduceJSCall(Node* node,
   // Check for known builtin functions.
 
   int builtin_id =
-      shared.HasBuiltinId() ? shared.builtin_id() : Builtins::kNoBuiltinId;
+      shared.HasBuiltinId() ? shared.builtin_id() : Builtin::kNoBuiltinId;
   switch (builtin_id) {
-    case Builtins::kArrayConstructor:
+    case Builtin::kArrayConstructor:
       return ReduceArrayConstructor(node);
-    case Builtins::kBooleanConstructor:
+    case Builtin::kBooleanConstructor:
       return ReduceBooleanConstructor(node);
-    case Builtins::kFunctionPrototypeApply:
+    case Builtin::kFunctionPrototypeApply:
       return ReduceFunctionPrototypeApply(node);
-    case Builtins::kFastFunctionPrototypeBind:
+    case Builtin::kFastFunctionPrototypeBind:
       return ReduceFunctionPrototypeBind(node);
-    case Builtins::kFunctionPrototypeCall:
+    case Builtin::kFunctionPrototypeCall:
       return ReduceFunctionPrototypeCall(node);
-    case Builtins::kFunctionPrototypeHasInstance:
+    case Builtin::kFunctionPrototypeHasInstance:
       return ReduceFunctionPrototypeHasInstance(node);
-    case Builtins::kObjectConstructor:
+    case Builtin::kObjectConstructor:
       return ReduceObjectConstructor(node);
-    case Builtins::kObjectCreate:
+    case Builtin::kObjectCreate:
       return ReduceObjectCreate(node);
-    case Builtins::kObjectGetPrototypeOf:
+    case Builtin::kObjectGetPrototypeOf:
       return ReduceObjectGetPrototypeOf(node);
-    case Builtins::kObjectIs:
+    case Builtin::kObjectIs:
       return ReduceObjectIs(node);
-    case Builtins::kObjectPrototypeGetProto:
+    case Builtin::kObjectPrototypeGetProto:
       return ReduceObjectPrototypeGetProto(node);
-    case Builtins::kObjectPrototypeHasOwnProperty:
+    case Builtin::kObjectPrototypeHasOwnProperty:
       return ReduceObjectPrototypeHasOwnProperty(node);
-    case Builtins::kObjectPrototypeIsPrototypeOf:
+    case Builtin::kObjectPrototypeIsPrototypeOf:
       return ReduceObjectPrototypeIsPrototypeOf(node);
-    case Builtins::kReflectApply:
+    case Builtin::kReflectApply:
       return ReduceReflectApply(node);
-    case Builtins::kReflectConstruct:
+    case Builtin::kReflectConstruct:
       return ReduceReflectConstruct(node);
-    case Builtins::kReflectGet:
+    case Builtin::kReflectGet:
       return ReduceReflectGet(node);
-    case Builtins::kReflectGetPrototypeOf:
+    case Builtin::kReflectGetPrototypeOf:
       return ReduceReflectGetPrototypeOf(node);
-    case Builtins::kReflectHas:
+    case Builtin::kReflectHas:
       return ReduceReflectHas(node);
-    case Builtins::kArrayForEach:
+    case Builtin::kArrayForEach:
       return ReduceArrayForEach(node, shared);
-    case Builtins::kArrayMap:
+    case Builtin::kArrayMap:
       return ReduceArrayMap(node, shared);
-    case Builtins::kArrayFilter:
+    case Builtin::kArrayFilter:
       return ReduceArrayFilter(node, shared);
-    case Builtins::kArrayReduce:
+    case Builtin::kArrayReduce:
       return ReduceArrayReduce(node, shared);
-    case Builtins::kArrayReduceRight:
+    case Builtin::kArrayReduceRight:
       return ReduceArrayReduceRight(node, shared);
-    case Builtins::kArrayPrototypeFind:
+    case Builtin::kArrayPrototypeFind:
       return ReduceArrayFind(node, shared);
-    case Builtins::kArrayPrototypeFindIndex:
+    case Builtin::kArrayPrototypeFindIndex:
       return ReduceArrayFindIndex(node, shared);
-    case Builtins::kArrayEvery:
+    case Builtin::kArrayEvery:
       return ReduceArrayEvery(node, shared);
-    case Builtins::kArrayIndexOf:
+    case Builtin::kArrayIndexOf:
       return ReduceArrayIndexOf(node);
-    case Builtins::kArrayIncludes:
+    case Builtin::kArrayIncludes:
       return ReduceArrayIncludes(node);
-    case Builtins::kArraySome:
+    case Builtin::kArraySome:
       return ReduceArraySome(node, shared);
-    case Builtins::kArrayPrototypePush:
+    case Builtin::kArrayPrototypePush:
       return ReduceArrayPrototypePush(node);
-    case Builtins::kArrayPrototypePop:
+    case Builtin::kArrayPrototypePop:
       return ReduceArrayPrototypePop(node);
-    case Builtins::kArrayPrototypeShift:
+    case Builtin::kArrayPrototypeShift:
       return ReduceArrayPrototypeShift(node);
-    case Builtins::kArrayPrototypeSlice:
+    case Builtin::kArrayPrototypeSlice:
       return ReduceArrayPrototypeSlice(node);
-    case Builtins::kArrayPrototypeEntries:
+    case Builtin::kArrayPrototypeEntries:
       return ReduceArrayIterator(node, ArrayIteratorKind::kArrayLike,
                                  IterationKind::kEntries);
-    case Builtins::kArrayPrototypeKeys:
+    case Builtin::kArrayPrototypeKeys:
       return ReduceArrayIterator(node, ArrayIteratorKind::kArrayLike,
                                  IterationKind::kKeys);
-    case Builtins::kArrayPrototypeValues:
+    case Builtin::kArrayPrototypeValues:
       return ReduceArrayIterator(node, ArrayIteratorKind::kArrayLike,
                                  IterationKind::kValues);
-    case Builtins::kArrayIteratorPrototypeNext:
+    case Builtin::kArrayIteratorPrototypeNext:
       return ReduceArrayIteratorPrototypeNext(node);
-    case Builtins::kArrayIsArray:
+    case Builtin::kArrayIsArray:
       return ReduceArrayIsArray(node);
-    case Builtins::kArrayBufferIsView:
+    case Builtin::kArrayBufferIsView:
       return ReduceArrayBufferIsView(node);
-    case Builtins::kDataViewPrototypeGetByteLength:
+    case Builtin::kDataViewPrototypeGetByteLength:
       return ReduceArrayBufferViewAccessor(
           node, JS_DATA_VIEW_TYPE,
           AccessBuilder::ForJSArrayBufferViewByteLength());
-    case Builtins::kDataViewPrototypeGetByteOffset:
+    case Builtin::kDataViewPrototypeGetByteOffset:
       return ReduceArrayBufferViewAccessor(
           node, JS_DATA_VIEW_TYPE,
           AccessBuilder::ForJSArrayBufferViewByteOffset());
-    case Builtins::kDataViewPrototypeGetUint8:
+    case Builtin::kDataViewPrototypeGetUint8:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalUint8Array);
-    case Builtins::kDataViewPrototypeGetInt8:
+    case Builtin::kDataViewPrototypeGetInt8:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalInt8Array);
-    case Builtins::kDataViewPrototypeGetUint16:
+    case Builtin::kDataViewPrototypeGetUint16:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalUint16Array);
-    case Builtins::kDataViewPrototypeGetInt16:
+    case Builtin::kDataViewPrototypeGetInt16:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalInt16Array);
-    case Builtins::kDataViewPrototypeGetUint32:
+    case Builtin::kDataViewPrototypeGetUint32:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalUint32Array);
-    case Builtins::kDataViewPrototypeGetInt32:
+    case Builtin::kDataViewPrototypeGetInt32:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalInt32Array);
-    case Builtins::kDataViewPrototypeGetFloat32:
+    case Builtin::kDataViewPrototypeGetFloat32:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalFloat32Array);
-    case Builtins::kDataViewPrototypeGetFloat64:
+    case Builtin::kDataViewPrototypeGetFloat64:
       return ReduceDataViewAccess(node, DataViewAccess::kGet,
                                   ExternalArrayType::kExternalFloat64Array);
-    case Builtins::kDataViewPrototypeSetUint8:
+    case Builtin::kDataViewPrototypeSetUint8:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalUint8Array);
-    case Builtins::kDataViewPrototypeSetInt8:
+    case Builtin::kDataViewPrototypeSetInt8:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalInt8Array);
-    case Builtins::kDataViewPrototypeSetUint16:
+    case Builtin::kDataViewPrototypeSetUint16:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalUint16Array);
-    case Builtins::kDataViewPrototypeSetInt16:
+    case Builtin::kDataViewPrototypeSetInt16:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalInt16Array);
-    case Builtins::kDataViewPrototypeSetUint32:
+    case Builtin::kDataViewPrototypeSetUint32:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalUint32Array);
-    case Builtins::kDataViewPrototypeSetInt32:
+    case Builtin::kDataViewPrototypeSetInt32:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalInt32Array);
-    case Builtins::kDataViewPrototypeSetFloat32:
+    case Builtin::kDataViewPrototypeSetFloat32:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalFloat32Array);
-    case Builtins::kDataViewPrototypeSetFloat64:
+    case Builtin::kDataViewPrototypeSetFloat64:
       return ReduceDataViewAccess(node, DataViewAccess::kSet,
                                   ExternalArrayType::kExternalFloat64Array);
-    case Builtins::kTypedArrayPrototypeByteLength:
+    case Builtin::kTypedArrayPrototypeByteLength:
       return ReduceArrayBufferViewAccessor(
           node, JS_TYPED_ARRAY_TYPE,
           AccessBuilder::ForJSArrayBufferViewByteLength());
-    case Builtins::kTypedArrayPrototypeByteOffset:
+    case Builtin::kTypedArrayPrototypeByteOffset:
       return ReduceArrayBufferViewAccessor(
           node, JS_TYPED_ARRAY_TYPE,
           AccessBuilder::ForJSArrayBufferViewByteOffset());
-    case Builtins::kTypedArrayPrototypeLength:
+    case Builtin::kTypedArrayPrototypeLength:
       return ReduceArrayBufferViewAccessor(
           node, JS_TYPED_ARRAY_TYPE, AccessBuilder::ForJSTypedArrayLength());
-    case Builtins::kTypedArrayPrototypeToStringTag:
+    case Builtin::kTypedArrayPrototypeToStringTag:
       return ReduceTypedArrayPrototypeToStringTag(node);
-    case Builtins::kMathAbs:
+    case Builtin::kMathAbs:
       return ReduceMathUnary(node, simplified()->NumberAbs());
-    case Builtins::kMathAcos:
+    case Builtin::kMathAcos:
       return ReduceMathUnary(node, simplified()->NumberAcos());
-    case Builtins::kMathAcosh:
+    case Builtin::kMathAcosh:
       return ReduceMathUnary(node, simplified()->NumberAcosh());
-    case Builtins::kMathAsin:
+    case Builtin::kMathAsin:
       return ReduceMathUnary(node, simplified()->NumberAsin());
-    case Builtins::kMathAsinh:
+    case Builtin::kMathAsinh:
       return ReduceMathUnary(node, simplified()->NumberAsinh());
-    case Builtins::kMathAtan:
+    case Builtin::kMathAtan:
       return ReduceMathUnary(node, simplified()->NumberAtan());
-    case Builtins::kMathAtanh:
+    case Builtin::kMathAtanh:
       return ReduceMathUnary(node, simplified()->NumberAtanh());
-    case Builtins::kMathCbrt:
+    case Builtin::kMathCbrt:
       return ReduceMathUnary(node, simplified()->NumberCbrt());
-    case Builtins::kMathCeil:
+    case Builtin::kMathCeil:
       return ReduceMathUnary(node, simplified()->NumberCeil());
-    case Builtins::kMathCos:
+    case Builtin::kMathCos:
       return ReduceMathUnary(node, simplified()->NumberCos());
-    case Builtins::kMathCosh:
+    case Builtin::kMathCosh:
       return ReduceMathUnary(node, simplified()->NumberCosh());
-    case Builtins::kMathExp:
+    case Builtin::kMathExp:
       return ReduceMathUnary(node, simplified()->NumberExp());
-    case Builtins::kMathExpm1:
+    case Builtin::kMathExpm1:
       return ReduceMathUnary(node, simplified()->NumberExpm1());
-    case Builtins::kMathFloor:
+    case Builtin::kMathFloor:
       return ReduceMathUnary(node, simplified()->NumberFloor());
-    case Builtins::kMathFround:
+    case Builtin::kMathFround:
       return ReduceMathUnary(node, simplified()->NumberFround());
-    case Builtins::kMathLog:
+    case Builtin::kMathLog:
       return ReduceMathUnary(node, simplified()->NumberLog());
-    case Builtins::kMathLog1p:
+    case Builtin::kMathLog1p:
       return ReduceMathUnary(node, simplified()->NumberLog1p());
-    case Builtins::kMathLog10:
+    case Builtin::kMathLog10:
       return ReduceMathUnary(node, simplified()->NumberLog10());
-    case Builtins::kMathLog2:
+    case Builtin::kMathLog2:
       return ReduceMathUnary(node, simplified()->NumberLog2());
-    case Builtins::kMathRound:
+    case Builtin::kMathRound:
       return ReduceMathUnary(node, simplified()->NumberRound());
-    case Builtins::kMathSign:
+    case Builtin::kMathSign:
       return ReduceMathUnary(node, simplified()->NumberSign());
-    case Builtins::kMathSin:
+    case Builtin::kMathSin:
       return ReduceMathUnary(node, simplified()->NumberSin());
-    case Builtins::kMathSinh:
+    case Builtin::kMathSinh:
       return ReduceMathUnary(node, simplified()->NumberSinh());
-    case Builtins::kMathSqrt:
+    case Builtin::kMathSqrt:
       return ReduceMathUnary(node, simplified()->NumberSqrt());
-    case Builtins::kMathTan:
+    case Builtin::kMathTan:
       return ReduceMathUnary(node, simplified()->NumberTan());
-    case Builtins::kMathTanh:
+    case Builtin::kMathTanh:
       return ReduceMathUnary(node, simplified()->NumberTanh());
-    case Builtins::kMathTrunc:
+    case Builtin::kMathTrunc:
       return ReduceMathUnary(node, simplified()->NumberTrunc());
-    case Builtins::kMathAtan2:
+    case Builtin::kMathAtan2:
       return ReduceMathBinary(node, simplified()->NumberAtan2());
-    case Builtins::kMathPow:
+    case Builtin::kMathPow:
       return ReduceMathBinary(node, simplified()->NumberPow());
-    case Builtins::kMathClz32:
+    case Builtin::kMathClz32:
       return ReduceMathClz32(node);
-    case Builtins::kMathImul:
+    case Builtin::kMathImul:
       return ReduceMathImul(node);
-    case Builtins::kMathMax:
+    case Builtin::kMathMax:
       return ReduceMathMinMax(node, simplified()->NumberMax(),
                               jsgraph()->Constant(-V8_INFINITY));
-    case Builtins::kMathMin:
+    case Builtin::kMathMin:
       return ReduceMathMinMax(node, simplified()->NumberMin(),
                               jsgraph()->Constant(V8_INFINITY));
-    case Builtins::kNumberIsFinite:
+    case Builtin::kNumberIsFinite:
       return ReduceNumberIsFinite(node);
-    case Builtins::kNumberIsInteger:
+    case Builtin::kNumberIsInteger:
       return ReduceNumberIsInteger(node);
-    case Builtins::kNumberIsSafeInteger:
+    case Builtin::kNumberIsSafeInteger:
       return ReduceNumberIsSafeInteger(node);
-    case Builtins::kNumberIsNaN:
+    case Builtin::kNumberIsNaN:
       return ReduceNumberIsNaN(node);
-    case Builtins::kNumberParseInt:
+    case Builtin::kNumberParseInt:
       return ReduceNumberParseInt(node);
-    case Builtins::kGlobalIsFinite:
+    case Builtin::kGlobalIsFinite:
       return ReduceGlobalIsFinite(node);
-    case Builtins::kGlobalIsNaN:
+    case Builtin::kGlobalIsNaN:
       return ReduceGlobalIsNaN(node);
-    case Builtins::kMapPrototypeGet:
+    case Builtin::kMapPrototypeGet:
       return ReduceMapPrototypeGet(node);
-    case Builtins::kMapPrototypeHas:
+    case Builtin::kMapPrototypeHas:
       return ReduceMapPrototypeHas(node);
-    case Builtins::kRegExpPrototypeTest:
+    case Builtin::kRegExpPrototypeTest:
       return ReduceRegExpPrototypeTest(node);
-    case Builtins::kReturnReceiver:
+    case Builtin::kReturnReceiver:
       return ReduceReturnReceiver(node);
-    case Builtins::kStringPrototypeIndexOf:
+    case Builtin::kStringPrototypeIndexOf:
       return ReduceStringPrototypeIndexOf(node);
-    case Builtins::kStringPrototypeCharAt:
+    case Builtin::kStringPrototypeCharAt:
       return ReduceStringPrototypeCharAt(node);
-    case Builtins::kStringPrototypeCharCodeAt:
+    case Builtin::kStringPrototypeCharCodeAt:
       return ReduceStringPrototypeStringAt(simplified()->StringCharCodeAt(),
                                            node);
-    case Builtins::kStringPrototypeCodePointAt:
+    case Builtin::kStringPrototypeCodePointAt:
       return ReduceStringPrototypeStringAt(simplified()->StringCodePointAt(),
                                            node);
-    case Builtins::kStringPrototypeSubstring:
+    case Builtin::kStringPrototypeSubstring:
       return ReduceStringPrototypeSubstring(node);
-    case Builtins::kStringPrototypeSlice:
+    case Builtin::kStringPrototypeSlice:
       return ReduceStringPrototypeSlice(node);
-    case Builtins::kStringPrototypeSubstr:
+    case Builtin::kStringPrototypeSubstr:
       return ReduceStringPrototypeSubstr(node);
-    case Builtins::kStringPrototypeStartsWith:
+    case Builtin::kStringPrototypeStartsWith:
       return ReduceStringPrototypeStartsWith(node);
 #ifdef V8_INTL_SUPPORT
-    case Builtins::kStringPrototypeToLowerCaseIntl:
+    case Builtin::kStringPrototypeToLowerCaseIntl:
       return ReduceStringPrototypeToLowerCaseIntl(node);
-    case Builtins::kStringPrototypeToUpperCaseIntl:
+    case Builtin::kStringPrototypeToUpperCaseIntl:
       return ReduceStringPrototypeToUpperCaseIntl(node);
 #endif  // V8_INTL_SUPPORT
-    case Builtins::kStringFromCharCode:
+    case Builtin::kStringFromCharCode:
       return ReduceStringFromCharCode(node);
-    case Builtins::kStringFromCodePoint:
+    case Builtin::kStringFromCodePoint:
       return ReduceStringFromCodePoint(node);
-    case Builtins::kStringPrototypeIterator:
+    case Builtin::kStringPrototypeIterator:
       return ReduceStringPrototypeIterator(node);
-    case Builtins::kStringIteratorPrototypeNext:
+    case Builtin::kStringIteratorPrototypeNext:
       return ReduceStringIteratorPrototypeNext(node);
-    case Builtins::kStringPrototypeConcat:
+    case Builtin::kStringPrototypeConcat:
       return ReduceStringPrototypeConcat(node);
-    case Builtins::kTypedArrayPrototypeEntries:
+    case Builtin::kTypedArrayPrototypeEntries:
       return ReduceArrayIterator(node, ArrayIteratorKind::kTypedArray,
                                  IterationKind::kEntries);
-    case Builtins::kTypedArrayPrototypeKeys:
+    case Builtin::kTypedArrayPrototypeKeys:
       return ReduceArrayIterator(node, ArrayIteratorKind::kTypedArray,
                                  IterationKind::kKeys);
-    case Builtins::kTypedArrayPrototypeValues:
+    case Builtin::kTypedArrayPrototypeValues:
       return ReduceArrayIterator(node, ArrayIteratorKind::kTypedArray,
                                  IterationKind::kValues);
-    case Builtins::kPromisePrototypeCatch:
+    case Builtin::kPromisePrototypeCatch:
       return ReducePromisePrototypeCatch(node);
-    case Builtins::kPromisePrototypeFinally:
+    case Builtin::kPromisePrototypeFinally:
       return ReducePromisePrototypeFinally(node);
-    case Builtins::kPromisePrototypeThen:
+    case Builtin::kPromisePrototypeThen:
       return ReducePromisePrototypeThen(node);
-    case Builtins::kPromiseResolveTrampoline:
+    case Builtin::kPromiseResolveTrampoline:
       return ReducePromiseResolveTrampoline(node);
-    case Builtins::kMapPrototypeEntries:
+    case Builtin::kMapPrototypeEntries:
       return ReduceCollectionIteration(node, CollectionKind::kMap,
                                        IterationKind::kEntries);
-    case Builtins::kMapPrototypeKeys:
+    case Builtin::kMapPrototypeKeys:
       return ReduceCollectionIteration(node, CollectionKind::kMap,
                                        IterationKind::kKeys);
-    case Builtins::kMapPrototypeGetSize:
+    case Builtin::kMapPrototypeGetSize:
       return ReduceCollectionPrototypeSize(node, CollectionKind::kMap);
-    case Builtins::kMapPrototypeValues:
+    case Builtin::kMapPrototypeValues:
       return ReduceCollectionIteration(node, CollectionKind::kMap,
                                        IterationKind::kValues);
-    case Builtins::kMapIteratorPrototypeNext:
+    case Builtin::kMapIteratorPrototypeNext:
       return ReduceCollectionIteratorPrototypeNext(
           node, OrderedHashMap::kEntrySize, factory()->empty_ordered_hash_map(),
           FIRST_JS_MAP_ITERATOR_TYPE, LAST_JS_MAP_ITERATOR_TYPE);
-    case Builtins::kSetPrototypeEntries:
+    case Builtin::kSetPrototypeEntries:
       return ReduceCollectionIteration(node, CollectionKind::kSet,
                                        IterationKind::kEntries);
-    case Builtins::kSetPrototypeGetSize:
+    case Builtin::kSetPrototypeGetSize:
       return ReduceCollectionPrototypeSize(node, CollectionKind::kSet);
-    case Builtins::kSetPrototypeValues:
+    case Builtin::kSetPrototypeValues:
       return ReduceCollectionIteration(node, CollectionKind::kSet,
                                        IterationKind::kValues);
-    case Builtins::kSetIteratorPrototypeNext:
+    case Builtin::kSetIteratorPrototypeNext:
       return ReduceCollectionIteratorPrototypeNext(
           node, OrderedHashSet::kEntrySize, factory()->empty_ordered_hash_set(),
           FIRST_JS_SET_ITERATOR_TYPE, LAST_JS_SET_ITERATOR_TYPE);
-    case Builtins::kDatePrototypeGetTime:
+    case Builtin::kDatePrototypeGetTime:
       return ReduceDatePrototypeGetTime(node);
-    case Builtins::kDateNow:
+    case Builtin::kDateNow:
       return ReduceDateNow(node);
-    case Builtins::kNumberConstructor:
+    case Builtin::kNumberConstructor:
       return ReduceNumberConstructor(node);
-    case Builtins::kBigIntAsUintN:
+    case Builtin::kBigIntAsUintN:
       return ReduceBigIntAsUintN(node);
     default:
       break;
@@ -4972,9 +4966,9 @@ Reduction JSCallReducer::ReduceJSConstruct(Node* node) {
       // Check for known builtin functions.
       int builtin_id = function.shared().HasBuiltinId()
                            ? function.shared().builtin_id()
-                           : Builtins::kNoBuiltinId;
+                           : Builtin::kNoBuiltinId;
       switch (builtin_id) {
-        case Builtins::kArrayConstructor: {
+        case Builtin::kArrayConstructor: {
           // TODO(bmeurer): Deal with Array subclasses here.
           // Turn the {node} into a {JSCreateArray} call.
           STATIC_ASSERT(JSConstructNode::NewTargetIndex() == 1);
@@ -4984,7 +4978,7 @@ Reduction JSCallReducer::ReduceJSConstruct(Node* node) {
               node, javascript()->CreateArray(arity, Handle<AllocationSite>()));
           return Changed(node);
         }
-        case Builtins::kObjectConstructor: {
+        case Builtin::kObjectConstructor: {
           // If no value is passed, we can immediately lower to a simple
           // JSCreate and don't need to do any massaging of the {node}.
           if (arity == 0) {
@@ -5009,9 +5003,9 @@ Reduction JSCallReducer::ReduceJSConstruct(Node* node) {
           }
           break;
         }
-        case Builtins::kPromiseConstructor:
+        case Builtin::kPromiseConstructor:
           return ReducePromiseConstructor(node);
-        case Builtins::kTypedArrayConstructor:
+        case Builtin::kTypedArrayConstructor:
           return ReduceTypedArrayConstructor(node, function.shared());
         default:
           break;
@@ -5835,7 +5829,7 @@ Reduction JSCallReducer::ReduceArrayPrototypeShift(Node* node) {
       Node* vfalse1;
       {
         // Call the generic C++ implementation.
-        const int builtin_index = Builtins::kArrayShift;
+        const int builtin_index = Builtin::kArrayShift;
         auto call_descriptor = Linkage::GetCEntryStubCallDescriptor(
             graph()->zone(), 1, BuiltinArguments::kNumExtraArgsWithReceiver,
             Builtins::name(builtin_index), node->op()->properties(),
@@ -5955,13 +5949,13 @@ Reduction JSCallReducer::ReduceArrayPrototypeSlice(Node* node) {
   // allocation in here. That way we'd even get escape analysis and scalar
   // replacement to help in some cases.
   Callable callable =
-      Builtins::CallableFor(isolate(), Builtins::kCloneFastJSArray);
+      Builtins::CallableFor(isolate(), Builtin::kCloneFastJSArray);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       graph()->zone(), callable.descriptor(),
       callable.descriptor().GetStackParameterCount(), CallDescriptor::kNoFlags,
       Operator::kNoThrow | Operator::kNoDeopt);
 
-  // Calls to Builtins::kCloneFastJSArray produce COW arrays
+  // Calls to Builtin::kCloneFastJSArray produce COW arrays
   // if the original array is COW
   Node* clone = effect = graph()->NewNode(
       common()->Call(call_descriptor), jsgraph()->HeapConstant(callable.code()),
@@ -6763,7 +6757,7 @@ Node* JSCallReducer::CreateClosureFromBuiltinSharedFunctionInfo(
   Handle<FeedbackCell> feedback_cell =
       isolate()->factory()->many_closures_cell();
   Callable const callable = Builtins::CallableFor(
-      isolate(), static_cast<Builtins::Name>(shared.builtin_id()));
+      isolate(), static_cast<Builtin>(shared.builtin_id()));
   return graph()->NewNode(
       javascript()->CreateClosure(shared.object(), callable.code()),
       jsgraph()->HeapConstant(feedback_cell), context, effect, control);
@@ -7007,7 +7001,7 @@ Reduction JSCallReducer::ReduceTypedArrayConstructor(
   Node* const parameters[] = {jsgraph()->TheHoleConstant()};
   int const num_parameters = static_cast<int>(arraysize(parameters));
   frame_state = CreateJavaScriptBuiltinContinuationFrameState(
-      jsgraph(), shared, Builtins::kGenericLazyDeoptContinuation, target,
+      jsgraph(), shared, Builtin::kGenericLazyDeoptContinuation, target,
       context, parameters, num_parameters, frame_state,
       ContinuationFrameStateMode::LAZY);
 
@@ -7364,7 +7358,7 @@ Reduction JSCallReducer::ReduceCollectionIteratorPrototypeNext(
         simplified()->LoadField(AccessBuilder::ForJSCollectionIteratorIndex()),
         receiver, effect, control);
     Callable const callable =
-        Builtins::CallableFor(isolate(), Builtins::kOrderedHashTableHealIndex);
+        Builtins::CallableFor(isolate(), Builtin::kOrderedHashTableHealIndex);
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         graph()->zone(), callable.descriptor(),
         callable.descriptor().GetStackParameterCount(),
@@ -8011,7 +8005,7 @@ Reduction JSCallReducer::ReduceNumberConstructor(Node* node) {
   int stack_parameter_count = arraysize(stack_parameters);
   Node* continuation_frame_state =
       CreateJavaScriptBuiltinContinuationFrameState(
-          jsgraph(), shared_info, Builtins::kGenericLazyDeoptContinuation,
+          jsgraph(), shared_info, Builtin::kGenericLazyDeoptContinuation,
           target, context, stack_parameters, stack_parameter_count, frame_state,
           ContinuationFrameStateMode::LAZY);
 
diff --git a/src/compiler/js-generic-lowering.cc b/src/compiler/js-generic-lowering.cc
index 935581b3462..4a1c5a28de4 100644
--- a/src/compiler/js-generic-lowering.cc
+++ b/src/compiler/js-generic-lowering.cc
@@ -61,7 +61,7 @@ Reduction JSGenericLowering::Reduce(Node* node) {
 
 #define REPLACE_STUB_CALL(Name)                       \
   void JSGenericLowering::LowerJS##Name(Node* node) { \
-    ReplaceWithBuiltinCall(node, Builtins::k##Name);  \
+    ReplaceWithBuiltinCall(node, Builtin::k##Name);   \
   }
 REPLACE_STUB_CALL(ToLength)
 REPLACE_STUB_CALL(ToNumber)
@@ -81,8 +81,7 @@ REPLACE_STUB_CALL(RejectPromise)
 REPLACE_STUB_CALL(ResolvePromise)
 #undef REPLACE_STUB_CALL
 
-void JSGenericLowering::ReplaceWithBuiltinCall(Node* node,
-                                               Builtins::Name builtin) {
+void JSGenericLowering::ReplaceWithBuiltinCall(Node* node, Builtin builtin) {
   CallDescriptor::Flags flags = FrameStateFlagForCall(node);
   Callable callable = Builtins::CallableFor(isolate(), builtin);
   ReplaceWithBuiltinCall(node, callable, flags);
@@ -123,8 +122,8 @@ void JSGenericLowering::ReplaceWithRuntimeCall(Node* node,
 }
 
 void JSGenericLowering::ReplaceUnaryOpWithBuiltinCall(
-    Node* node, Builtins::Name builtin_without_feedback,
-    Builtins::Name builtin_with_feedback) {
+    Node* node, Builtin builtin_without_feedback,
+    Builtin builtin_with_feedback) {
   DCHECK(JSOperator::IsUnaryWithFeedback(node->opcode()));
   const FeedbackParameter& p = FeedbackParameterOf(node->op());
   if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {
@@ -148,10 +147,10 @@ void JSGenericLowering::ReplaceUnaryOpWithBuiltinCall(
   }
 }
 
-#define DEF_UNARY_LOWERING(Name)                                     \
-  void JSGenericLowering::LowerJS##Name(Node* node) {                \
-    ReplaceUnaryOpWithBuiltinCall(node, Builtins::k##Name,           \
-                                  Builtins::k##Name##_WithFeedback); \
+#define DEF_UNARY_LOWERING(Name)                                    \
+  void JSGenericLowering::LowerJS##Name(Node* node) {               \
+    ReplaceUnaryOpWithBuiltinCall(node, Builtin::k##Name,           \
+                                  Builtin::k##Name##_WithFeedback); \
   }
 DEF_UNARY_LOWERING(BitwiseNot)
 DEF_UNARY_LOWERING(Decrement)
@@ -160,10 +159,10 @@ DEF_UNARY_LOWERING(Negate)
 #undef DEF_UNARY_LOWERING
 
 void JSGenericLowering::ReplaceBinaryOpWithBuiltinCall(
-    Node* node, Builtins::Name builtin_without_feedback,
-    Builtins::Name builtin_with_feedback) {
+    Node* node, Builtin builtin_without_feedback,
+    Builtin builtin_with_feedback) {
   DCHECK(JSOperator::IsBinaryWithFeedback(node->opcode()));
-  Builtins::Name builtin_id;
+  Builtin builtin_id;
   const FeedbackParameter& p = FeedbackParameterOf(node->op());
   if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {
     Node* slot = jsgraph()->UintPtrConstant(p.feedback().slot.ToInt());
@@ -181,10 +180,10 @@ void JSGenericLowering::ReplaceBinaryOpWithBuiltinCall(
   ReplaceWithBuiltinCall(node, builtin_id);
 }
 
-#define DEF_BINARY_LOWERING(Name)                                     \
-  void JSGenericLowering::LowerJS##Name(Node* node) {                 \
-    ReplaceBinaryOpWithBuiltinCall(node, Builtins::k##Name,           \
-                                   Builtins::k##Name##_WithFeedback); \
+#define DEF_BINARY_LOWERING(Name)                                    \
+  void JSGenericLowering::LowerJS##Name(Node* node) {                \
+    ReplaceBinaryOpWithBuiltinCall(node, Builtin::k##Name,           \
+                                   Builtin::k##Name##_WithFeedback); \
   }
 // Binary ops.
 DEF_BINARY_LOWERING(Add)
@@ -214,7 +213,7 @@ void JSGenericLowering::LowerJSStrictEqual(Node* node) {
   DCHECK_EQ(node->op()->ControlInputCount(), 1);
   node->RemoveInput(NodeProperties::FirstControlIndex(node));
 
-  Builtins::Name builtin_id;
+  Builtin builtin_id;
   const FeedbackParameter& p = FeedbackParameterOf(node->op());
   if (CollectFeedbackInGenericLowering() && p.feedback().IsValid()) {
     Node* slot = jsgraph()->UintPtrConstant(p.feedback().slot.ToInt());
@@ -223,10 +222,10 @@ void JSGenericLowering::LowerJSStrictEqual(Node* node) {
     STATIC_ASSERT(JSStrictEqualNode::FeedbackVectorIndex() == 2);
     DCHECK_EQ(node->op()->ValueInputCount(), 3);
     node->InsertInput(zone(), 2, slot);
-    builtin_id = Builtins::kStrictEqual_WithFeedback;
+    builtin_id = Builtin::kStrictEqual_WithFeedback;
   } else {
     node->RemoveInput(JSStrictEqualNode::FeedbackVectorIndex());
-    builtin_id = Builtins::kStrictEqual;
+    builtin_id = Builtin::kStrictEqual;
   }
 
   Callable callable = Builtins::CallableFor(isolate(), builtin_id);
@@ -266,12 +265,12 @@ void JSGenericLowering::LowerJSHasProperty(Node* node) {
   const PropertyAccess& p = n.Parameters();
   if (!p.feedback().IsValid()) {
     node->RemoveInput(JSHasPropertyNode::FeedbackVectorIndex());
-    ReplaceWithBuiltinCall(node, Builtins::kHasProperty);
+    ReplaceWithBuiltinCall(node, Builtin::kHasProperty);
   } else {
     STATIC_ASSERT(n.FeedbackVectorIndex() == 2);
     n->InsertInput(zone(), 2,
                    jsgraph()->TaggedIndexConstant(p.feedback().index()));
-    ReplaceWithBuiltinCall(node, Builtins::kKeyedHasIC);
+    ReplaceWithBuiltinCall(node, Builtin::kKeyedHasIC);
   }
 }
 
@@ -287,15 +286,15 @@ void JSGenericLowering::LowerJSLoadProperty(Node* node) {
                    jsgraph()->TaggedIndexConstant(p.feedback().index()));
     ReplaceWithBuiltinCall(
         node, ShouldUseMegamorphicLoadBuiltin(p.feedback(), broker())
-                  ? Builtins::kKeyedLoadICTrampoline_Megamorphic
-                  : Builtins::kKeyedLoadICTrampoline);
+                  ? Builtin::kKeyedLoadICTrampoline_Megamorphic
+                  : Builtin::kKeyedLoadICTrampoline);
   } else {
     n->InsertInput(zone(), 2,
                    jsgraph()->TaggedIndexConstant(p.feedback().index()));
     ReplaceWithBuiltinCall(
         node, ShouldUseMegamorphicLoadBuiltin(p.feedback(), broker())
-                  ? Builtins::kKeyedLoadIC_Megamorphic
-                  : Builtins::kKeyedLoadIC);
+                  ? Builtin::kKeyedLoadIC_Megamorphic
+                  : Builtin::kKeyedLoadIC);
   }
 }
 
@@ -308,7 +307,7 @@ void JSGenericLowering::LowerJSLoadNamed(Node* node) {
   if (!p.feedback().IsValid()) {
     n->RemoveInput(n.FeedbackVectorIndex());
     node->InsertInput(zone(), 1, jsgraph()->HeapConstant(p.name()));
-    ReplaceWithBuiltinCall(node, Builtins::kGetProperty);
+    ReplaceWithBuiltinCall(node, Builtin::kGetProperty);
   } else if (outer_state->opcode() != IrOpcode::kFrameState) {
     n->RemoveInput(n.FeedbackVectorIndex());
     node->InsertInput(zone(), 1, jsgraph()->HeapConstant(p.name()));
@@ -316,16 +315,16 @@ void JSGenericLowering::LowerJSLoadNamed(Node* node) {
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
     ReplaceWithBuiltinCall(
         node, ShouldUseMegamorphicLoadBuiltin(p.feedback(), broker())
-                  ? Builtins::kLoadICTrampoline_Megamorphic
-                  : Builtins::kLoadICTrampoline);
+                  ? Builtin::kLoadICTrampoline_Megamorphic
+                  : Builtin::kLoadICTrampoline);
   } else {
     node->InsertInput(zone(), 1, jsgraph()->HeapConstant(p.name()));
     node->InsertInput(zone(), 2,
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
     ReplaceWithBuiltinCall(
         node, ShouldUseMegamorphicLoadBuiltin(p.feedback(), broker())
-                  ? Builtins::kLoadIC_Megamorphic
-                  : Builtins::kLoadIC);
+                  ? Builtin::kLoadIC_Megamorphic
+                  : Builtin::kLoadIC);
   }
 }
 
@@ -353,7 +352,7 @@ void JSGenericLowering::LowerJSLoadNamedFromSuper(Node* node) {
   node->InsertInput(zone(), 2, jsgraph()->HeapConstant(p.name()));
   node->InsertInput(zone(), 3,
                     jsgraph()->TaggedIndexConstant(p.feedback().index()));
-  ReplaceWithBuiltinCall(node, Builtins::kLoadSuperIC);
+  ReplaceWithBuiltinCall(node, Builtin::kLoadSuperIC);
 }
 
 void JSGenericLowering::LowerJSLoadGlobal(Node* node) {
@@ -401,7 +400,7 @@ void JSGenericLowering::LowerJSGetIterator(Node* node) {
   node->InsertInput(zone(), 1, load_slot);
   node->InsertInput(zone(), 2, call_slot);
 
-  ReplaceWithBuiltinCall(node, Builtins::kGetIteratorWithFeedback);
+  ReplaceWithBuiltinCall(node, Builtin::kGetIteratorWithFeedback);
 }
 
 void JSGenericLowering::LowerJSStoreProperty(Node* node) {
@@ -414,11 +413,11 @@ void JSGenericLowering::LowerJSStoreProperty(Node* node) {
     n->RemoveInput(n.FeedbackVectorIndex());
     node->InsertInput(zone(), 3,
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
-    ReplaceWithBuiltinCall(node, Builtins::kKeyedStoreICTrampoline);
+    ReplaceWithBuiltinCall(node, Builtin::kKeyedStoreICTrampoline);
   } else {
     node->InsertInput(zone(), 3,
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
-    ReplaceWithBuiltinCall(node, Builtins::kKeyedStoreIC);
+    ReplaceWithBuiltinCall(node, Builtin::kKeyedStoreIC);
   }
 }
 
@@ -437,12 +436,12 @@ void JSGenericLowering::LowerJSStoreNamed(Node* node) {
     node->InsertInput(zone(), 1, jsgraph()->HeapConstant(p.name()));
     node->InsertInput(zone(), 3,
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
-    ReplaceWithBuiltinCall(node, Builtins::kStoreICTrampoline);
+    ReplaceWithBuiltinCall(node, Builtin::kStoreICTrampoline);
   } else {
     node->InsertInput(zone(), 1, jsgraph()->HeapConstant(p.name()));
     node->InsertInput(zone(), 3,
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
-    ReplaceWithBuiltinCall(node, Builtins::kStoreIC);
+    ReplaceWithBuiltinCall(node, Builtin::kStoreIC);
   }
 }
 
@@ -480,12 +479,12 @@ void JSGenericLowering::LowerJSStoreGlobal(Node* node) {
     node->InsertInput(zone(), 0, jsgraph()->HeapConstant(p.name()));
     node->InsertInput(zone(), 2,
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
-    ReplaceWithBuiltinCall(node, Builtins::kStoreGlobalICTrampoline);
+    ReplaceWithBuiltinCall(node, Builtin::kStoreGlobalICTrampoline);
   } else {
     node->InsertInput(zone(), 0, jsgraph()->HeapConstant(p.name()));
     node->InsertInput(zone(), 2,
                       jsgraph()->TaggedIndexConstant(p.feedback().index()));
-    ReplaceWithBuiltinCall(node, Builtins::kStoreGlobalIC);
+    ReplaceWithBuiltinCall(node, Builtin::kStoreGlobalIC);
   }
 }
 
@@ -506,11 +505,11 @@ void JSGenericLowering::LowerJSStoreInArrayLiteral(Node* node) {
   RelaxControls(node);
   node->InsertInput(zone(), 3,
                     jsgraph()->TaggedIndexConstant(p.feedback().index()));
-  ReplaceWithBuiltinCall(node, Builtins::kStoreInArrayLiteralIC);
+  ReplaceWithBuiltinCall(node, Builtin::kStoreInArrayLiteralIC);
 }
 
 void JSGenericLowering::LowerJSDeleteProperty(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kDeleteProperty);
+  ReplaceWithBuiltinCall(node, Builtin::kDeleteProperty);
 }
 
 void JSGenericLowering::LowerJSGetSuperConstructor(Node* node) {
@@ -536,7 +535,7 @@ void JSGenericLowering::LowerJSHasInPrototypeChain(Node* node) {
 }
 
 void JSGenericLowering::LowerJSOrdinaryHasInstance(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kOrdinaryHasInstance);
+  ReplaceWithBuiltinCall(node, Builtin::kOrdinaryHasInstance);
 }
 
 void JSGenericLowering::LowerJSHasContextExtension(Node* node) {
@@ -554,7 +553,7 @@ void JSGenericLowering::LowerJSStoreContext(Node* node) {
 
 
 void JSGenericLowering::LowerJSCreate(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kFastNewObject);
+  ReplaceWithBuiltinCall(node, Builtin::kFastNewObject);
 }
 
 
@@ -622,15 +621,15 @@ void JSGenericLowering::LowerJSObjectIsArray(Node* node) {
 }
 
 void JSGenericLowering::LowerJSCreateObject(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kCreateObjectWithoutProperties);
+  ReplaceWithBuiltinCall(node, Builtin::kCreateObjectWithoutProperties);
 }
 
 void JSGenericLowering::LowerJSParseInt(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kParseInt);
+  ReplaceWithBuiltinCall(node, Builtin::kParseInt);
 }
 
 void JSGenericLowering::LowerJSRegExpTest(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kRegExpPrototypeTestFast);
+  ReplaceWithBuiltinCall(node, Builtin::kRegExpPrototypeTestFast);
 }
 
 void JSGenericLowering::LowerJSCreateClosure(Node* node) {
@@ -643,7 +642,7 @@ void JSGenericLowering::LowerJSCreateClosure(Node* node) {
 
   // Use the FastNewClosure builtin only for functions allocated in new space.
   if (p.allocation() == AllocationType::kYoung) {
-    ReplaceWithBuiltinCall(node, Builtins::kFastNewClosure);
+    ReplaceWithBuiltinCall(node, Builtin::kFastNewClosure);
   } else {
     ReplaceWithRuntimeCall(node, Runtime::kNewClosure_Tenured);
   }
@@ -671,11 +670,11 @@ void JSGenericLowering::LowerJSCreateFunctionContext(Node* node) {
 
 void JSGenericLowering::LowerJSCreateGeneratorObject(Node* node) {
   node->RemoveInput(4);  // control
-  ReplaceWithBuiltinCall(node, Builtins::kCreateGeneratorObject);
+  ReplaceWithBuiltinCall(node, Builtin::kCreateGeneratorObject);
 }
 
 void JSGenericLowering::LowerJSCreateIterResultObject(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kCreateIterResultObject);
+  ReplaceWithBuiltinCall(node, Builtin::kCreateIterResultObject);
 }
 
 void JSGenericLowering::LowerJSCreateStringIterator(Node* node) {
@@ -691,7 +690,7 @@ void JSGenericLowering::LowerJSCreatePromise(Node* node) {
 }
 
 void JSGenericLowering::LowerJSCreateTypedArray(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kCreateTypedArray);
+  ReplaceWithBuiltinCall(node, Builtin::kCreateTypedArray);
 }
 
 void JSGenericLowering::LowerJSCreateLiteralArray(Node* node) {
@@ -707,7 +706,7 @@ void JSGenericLowering::LowerJSCreateLiteralArray(Node* node) {
   // without properties up to the number of elements that the stubs can handle.
   if ((p.flags() & AggregateLiteral::kIsShallow) != 0 &&
       p.length() < ConstructorBuiltins::kMaximumClonedShallowArrayElements) {
-    ReplaceWithBuiltinCall(node, Builtins::kCreateShallowArrayLiteral);
+    ReplaceWithBuiltinCall(node, Builtin::kCreateShallowArrayLiteral);
   } else {
     ReplaceWithRuntimeCall(node, Runtime::kCreateArrayLiteral);
   }
@@ -728,7 +727,7 @@ void JSGenericLowering::LowerJSGetTemplateObject(Node* node) {
   node->InsertInput(zone(), 2,
                     jsgraph()->UintPtrConstant(p.feedback().index()));
 
-  ReplaceWithBuiltinCall(node, Builtins::kGetTemplateObject);
+  ReplaceWithBuiltinCall(node, Builtin::kGetTemplateObject);
 }
 
 void JSGenericLowering::LowerJSCreateEmptyLiteralArray(Node* node) {
@@ -738,11 +737,11 @@ void JSGenericLowering::LowerJSCreateEmptyLiteralArray(Node* node) {
   node->InsertInput(zone(), 1,
                     jsgraph()->TaggedIndexConstant(p.feedback().index()));
   node->RemoveInput(4);  // control
-  ReplaceWithBuiltinCall(node, Builtins::kCreateEmptyArrayLiteral);
+  ReplaceWithBuiltinCall(node, Builtin::kCreateEmptyArrayLiteral);
 }
 
 void JSGenericLowering::LowerJSCreateArrayFromIterable(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kIterableToListWithSymbolLookup);
+  ReplaceWithBuiltinCall(node, Builtin::kIterableToListWithSymbolLookup);
 }
 
 void JSGenericLowering::LowerJSCreateLiteralObject(Node* node) {
@@ -759,7 +758,7 @@ void JSGenericLowering::LowerJSCreateLiteralObject(Node* node) {
   if ((p.flags() & AggregateLiteral::kIsShallow) != 0 &&
       p.length() <=
           ConstructorBuiltins::kMaximumClonedShallowObjectProperties) {
-    ReplaceWithBuiltinCall(node, Builtins::kCreateShallowObjectLiteral);
+    ReplaceWithBuiltinCall(node, Builtin::kCreateShallowObjectLiteral);
   } else {
     ReplaceWithRuntimeCall(node, Runtime::kCreateObjectLiteral);
   }
@@ -772,11 +771,11 @@ void JSGenericLowering::LowerJSCloneObject(Node* node) {
   node->InsertInput(zone(), 1, jsgraph()->SmiConstant(p.flags()));
   node->InsertInput(zone(), 2,
                     jsgraph()->TaggedIndexConstant(p.feedback().index()));
-  ReplaceWithBuiltinCall(node, Builtins::kCloneObjectIC);
+  ReplaceWithBuiltinCall(node, Builtin::kCloneObjectIC);
 }
 
 void JSGenericLowering::LowerJSCreateEmptyLiteralObject(Node* node) {
-  ReplaceWithBuiltinCall(node, Builtins::kCreateEmptyLiteralObject);
+  ReplaceWithBuiltinCall(node, Builtin::kCreateEmptyLiteralObject);
 }
 
 void JSGenericLowering::LowerJSCreateLiteralRegExp(Node* node) {
@@ -787,7 +786,7 @@ void JSGenericLowering::LowerJSCreateLiteralRegExp(Node* node) {
                     jsgraph()->TaggedIndexConstant(p.feedback().index()));
   node->InsertInput(zone(), 2, jsgraph()->HeapConstant(p.constant()));
   node->InsertInput(zone(), 3, jsgraph()->SmiConstant(p.flags()));
-  ReplaceWithBuiltinCall(node, Builtins::kCreateRegExpLiteral);
+  ReplaceWithBuiltinCall(node, Builtin::kCreateRegExpLiteral);
 }
 
 
@@ -864,7 +863,7 @@ void JSGenericLowering::LowerJSConstruct(Node* node) {
     const int stack_argument_count =
         arg_count + kReceiver + kMaybeFeedbackVector;
     Callable callable =
-        Builtins::CallableFor(isolate(), Builtins::kConstruct_WithFeedback);
+        Builtins::CallableFor(isolate(), Builtin::kConstruct_WithFeedback);
     // If this fails, we might need to update the parameter reordering code
     // to ensure that the additional arguments passed via stack are pushed
     // between top of stack and JS arguments.
@@ -893,7 +892,7 @@ void JSGenericLowering::LowerJSConstruct(Node* node) {
     NodeProperties::ChangeOp(node, common()->Call(call_descriptor));
   } else {
     const int stack_argument_count = arg_count + kReceiver;
-    Callable callable = Builtins::CallableFor(isolate(), Builtins::kConstruct);
+    Callable callable = Builtins::CallableFor(isolate(), Builtin::kConstruct);
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         zone(), callable.descriptor(), stack_argument_count, flags);
     Node* stub_code = jsgraph()->HeapConstant(callable.code());
@@ -926,7 +925,7 @@ void JSGenericLowering::LowerJSConstructWithArrayLike(Node* node) {
     const int stack_argument_count =
         arg_count - kArgumentList + kReceiver + kMaybeFeedbackVector;
     Callable callable = Builtins::CallableFor(
-        isolate(), Builtins::kConstructWithArrayLike_WithFeedback);
+        isolate(), Builtin::kConstructWithArrayLike_WithFeedback);
     // If this fails, we might need to update the parameter reordering code
     // to ensure that the additional arguments passed via stack are pushed
     // between top of stack and JS arguments.
@@ -954,7 +953,7 @@ void JSGenericLowering::LowerJSConstructWithArrayLike(Node* node) {
   } else {
     const int stack_argument_count = arg_count - kArgumentList + kReceiver;
     Callable callable =
-        Builtins::CallableFor(isolate(), Builtins::kConstructWithArrayLike);
+        Builtins::CallableFor(isolate(), Builtin::kConstructWithArrayLike);
     // If this fails, we might need to update the parameter reordering code
     // to ensure that the additional arguments passed via stack are pushed
     // between top of stack and JS arguments.
@@ -989,7 +988,7 @@ void JSGenericLowering::LowerJSConstructWithSpread(Node* node) {
     const int stack_argument_count =
         arg_count + kReceiver + kMaybeFeedbackVector;
     Callable callable = Builtins::CallableFor(
-        isolate(), Builtins::kConstructWithSpread_WithFeedback);
+        isolate(), Builtin::kConstructWithSpread_WithFeedback);
     // If this fails, we might need to update the parameter reordering code
     // to ensure that the additional arguments passed via stack are pushed
     // between top of stack and JS arguments.
@@ -1122,7 +1121,7 @@ void JSGenericLowering::LowerJSCallWithArrayLike(Node* node) {
       CollectCallAndConstructFeedback(broker()) && p.feedback().IsValid()) {
     const int stack_argument_count = arg_count - kArgumentsList + kReceiver;
     Callable callable = Builtins::CallableFor(
-        isolate(), Builtins::kCallWithArrayLike_WithFeedback);
+        isolate(), Builtin::kCallWithArrayLike_WithFeedback);
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         zone(), callable.descriptor(), stack_argument_count, flags);
     Node* stub_code = jsgraph()->HeapConstant(callable.code());
@@ -1184,8 +1183,8 @@ void JSGenericLowering::LowerJSCallWithSpread(Node* node) {
       CollectCallAndConstructFeedback(broker()) && p.feedback().IsValid()) {
     const int stack_argument_count =
         arg_count - kTheSpread + kReceiver + kMaybeFeedbackVector;
-    Callable callable = Builtins::CallableFor(
-        isolate(), Builtins::kCallWithSpread_WithFeedback);
+    Callable callable =
+        Builtins::CallableFor(isolate(), Builtin::kCallWithSpread_WithFeedback);
     // If this fails, we might need to update the parameter reordering code
     // to ensure that the additional arguments passed via stack are pushed
     // between top of stack and JS arguments.
@@ -1321,7 +1320,7 @@ void JSGenericLowering::LowerJSForInPrepare(Node* node) {
   // thus must not have any control uses. Any previously existing control
   // outputs have been replaced by the graph rewrite above.
   node->InsertInput(zone(), n.FeedbackVectorIndex(), slot);
-  ReplaceWithBuiltinCall(node, Builtins::kForInPrepare);
+  ReplaceWithBuiltinCall(node, Builtin::kForInPrepare);
 }
 
 void JSGenericLowering::LowerJSForInNext(Node* node) {
@@ -1329,7 +1328,7 @@ void JSGenericLowering::LowerJSForInNext(Node* node) {
   node->InsertInput(
       zone(), 0,
       jsgraph()->UintPtrConstant(n.Parameters().feedback().slot.ToInt()));
-  ReplaceWithBuiltinCall(node, Builtins::kForInNext);
+  ReplaceWithBuiltinCall(node, Builtin::kForInNext);
 }
 
 void JSGenericLowering::LowerJSLoadMessage(Node* node) {
diff --git a/src/compiler/js-generic-lowering.h b/src/compiler/js-generic-lowering.h
index 2addadffab1..f96f3695257 100644
--- a/src/compiler/js-generic-lowering.h
+++ b/src/compiler/js-generic-lowering.h
@@ -37,7 +37,7 @@ class JSGenericLowering final : public AdvancedReducer {
 #undef DECLARE_LOWER
 
   // Helpers to replace existing nodes with a generic call.
-  void ReplaceWithBuiltinCall(Node* node, Builtins::Name builtin);
+  void ReplaceWithBuiltinCall(Node* node, Builtin builtin);
   void ReplaceWithBuiltinCall(Node* node, Callable c,
                               CallDescriptor::Flags flags);
   void ReplaceWithBuiltinCall(Node* node, Callable c,
@@ -46,11 +46,11 @@ class JSGenericLowering final : public AdvancedReducer {
   void ReplaceWithRuntimeCall(Node* node, Runtime::FunctionId f, int args = -1);
 
   void ReplaceUnaryOpWithBuiltinCall(Node* node,
-                                     Builtins::Name builtin_without_feedback,
-                                     Builtins::Name builtin_with_feedback);
+                                     Builtin builtin_without_feedback,
+                                     Builtin builtin_with_feedback);
   void ReplaceBinaryOpWithBuiltinCall(Node* node,
-                                      Builtins::Name builtin_without_feedback,
-                                      Builtins::Name builtin_with_feedback);
+                                      Builtin builtin_without_feedback,
+                                      Builtin builtin_with_feedback);
 
   Zone* zone() const;
   Isolate* isolate() const;
diff --git a/src/compiler/js-intrinsic-lowering.cc b/src/compiler/js-intrinsic-lowering.cc
index 803d55cc271..700200d8301 100644
--- a/src/compiler/js-intrinsic-lowering.cc
+++ b/src/compiler/js-intrinsic-lowering.cc
@@ -98,7 +98,7 @@ Reduction JSIntrinsicLowering::Reduce(Node* node) {
 
 Reduction JSIntrinsicLowering::ReduceCopyDataProperties(Node* node) {
   return Change(
-      node, Builtins::CallableFor(isolate(), Builtins::kCopyDataProperties), 0);
+      node, Builtins::CallableFor(isolate(), Builtin::kCopyDataProperties), 0);
 }
 
 Reduction JSIntrinsicLowering::ReduceCreateIterResultObject(Node* node) {
@@ -158,13 +158,13 @@ Reduction JSIntrinsicLowering::ReduceGeneratorClose(Node* node) {
 Reduction JSIntrinsicLowering::ReduceAsyncFunctionAwaitCaught(Node* node) {
   return Change(
       node,
-      Builtins::CallableFor(isolate(), Builtins::kAsyncFunctionAwaitCaught), 0);
+      Builtins::CallableFor(isolate(), Builtin::kAsyncFunctionAwaitCaught), 0);
 }
 
 Reduction JSIntrinsicLowering::ReduceAsyncFunctionAwaitUncaught(Node* node) {
   return Change(
       node,
-      Builtins::CallableFor(isolate(), Builtins::kAsyncFunctionAwaitUncaught),
+      Builtins::CallableFor(isolate(), Builtin::kAsyncFunctionAwaitUncaught),
       0);
 }
 
@@ -188,33 +188,31 @@ Reduction JSIntrinsicLowering::ReduceAsyncFunctionResolve(Node* node) {
 Reduction JSIntrinsicLowering::ReduceAsyncGeneratorAwaitCaught(Node* node) {
   return Change(
       node,
-      Builtins::CallableFor(isolate(), Builtins::kAsyncGeneratorAwaitCaught),
-      0);
+      Builtins::CallableFor(isolate(), Builtin::kAsyncGeneratorAwaitCaught), 0);
 }
 
 Reduction JSIntrinsicLowering::ReduceAsyncGeneratorAwaitUncaught(Node* node) {
   return Change(
       node,
-      Builtins::CallableFor(isolate(), Builtins::kAsyncGeneratorAwaitUncaught),
+      Builtins::CallableFor(isolate(), Builtin::kAsyncGeneratorAwaitUncaught),
       0);
 }
 
 Reduction JSIntrinsicLowering::ReduceAsyncGeneratorReject(Node* node) {
   return Change(
-      node, Builtins::CallableFor(isolate(), Builtins::kAsyncGeneratorReject),
+      node, Builtins::CallableFor(isolate(), Builtin::kAsyncGeneratorReject),
       0);
 }
 
 Reduction JSIntrinsicLowering::ReduceAsyncGeneratorResolve(Node* node) {
   return Change(
-      node, Builtins::CallableFor(isolate(), Builtins::kAsyncGeneratorResolve),
+      node, Builtins::CallableFor(isolate(), Builtin::kAsyncGeneratorResolve),
       0);
 }
 
 Reduction JSIntrinsicLowering::ReduceAsyncGeneratorYield(Node* node) {
   return Change(
-      node, Builtins::CallableFor(isolate(), Builtins::kAsyncGeneratorYield),
-      0);
+      node, Builtins::CallableFor(isolate(), Builtin::kAsyncGeneratorYield), 0);
 }
 
 Reduction JSIntrinsicLowering::ReduceGeneratorGetResumeMode(Node* node) {
@@ -353,7 +351,7 @@ Reduction JSIntrinsicLowering::ReduceIncBlockCounter(Node* node) {
   DCHECK(!Linkage::NeedsFrameStateInput(Runtime::kIncBlockCounter));
   DCHECK(!Linkage::NeedsFrameStateInput(Runtime::kInlineIncBlockCounter));
   return Change(node,
-                Builtins::CallableFor(isolate(), Builtins::kIncBlockCounter), 0,
+                Builtins::CallableFor(isolate(), Builtin::kIncBlockCounter), 0,
                 kDoesNotNeedFrameState);
 }
 
diff --git a/src/compiler/js-native-context-specialization.cc b/src/compiler/js-native-context-specialization.cc
index db3f600ae0a..46179ed5c52 100644
--- a/src/compiler/js-native-context-specialization.cc
+++ b/src/compiler/js-native-context-specialization.cc
@@ -269,7 +269,7 @@ Reduction JSNativeContextSpecialization::ReduceJSAsyncFunctionReject(
   // JSRejectPromise operation (which yields undefined).
   Node* parameters[] = {promise};
   frame_state = CreateStubBuiltinContinuationFrameState(
-      jsgraph(), Builtins::kAsyncFunctionLazyDeoptContinuation, context,
+      jsgraph(), Builtin::kAsyncFunctionLazyDeoptContinuation, context,
       parameters, arraysize(parameters), frame_state,
       ContinuationFrameStateMode::LAZY);
 
@@ -305,7 +305,7 @@ Reduction JSNativeContextSpecialization::ReduceJSAsyncFunctionResolve(
   // JSResolvePromise operation (which yields undefined).
   Node* parameters[] = {promise};
   frame_state = CreateStubBuiltinContinuationFrameState(
-      jsgraph(), Builtins::kAsyncFunctionLazyDeoptContinuation, context,
+      jsgraph(), Builtin::kAsyncFunctionLazyDeoptContinuation, context,
       parameters, arraysize(parameters), frame_state,
       ContinuationFrameStateMode::LAZY);
 
@@ -486,7 +486,7 @@ Reduction JSNativeContextSpecialization::ReduceJSInstanceOf(Node* node) {
     // ToBoolean stub that finishes the remaining work of instanceof and returns
     // to the caller without duplicating side-effects upon a lazy deopt.
     Node* continuation_frame_state = CreateStubBuiltinContinuationFrameState(
-        jsgraph(), Builtins::kToBooleanLazyDeoptContinuation, context, nullptr,
+        jsgraph(), Builtin::kToBooleanLazyDeoptContinuation, context, nullptr,
         0, frame_state, ContinuationFrameStateMode::LAZY);
 
     // Call the @@hasInstance handler.
@@ -1530,7 +1530,7 @@ Reduction JSNativeContextSpecialization::ReduceJSGetIterator(Node* node) {
   Node* call_feedback = jsgraph()->HeapConstant(p.callFeedback().vector);
   Node* lazy_deopt_parameters[] = {receiver, call_slot, call_feedback};
   Node* lazy_deopt_frame_state = CreateStubBuiltinContinuationFrameState(
-      jsgraph(), Builtins::kGetIteratorWithFeedbackLazyDeoptContinuation,
+      jsgraph(), Builtin::kGetIteratorWithFeedbackLazyDeoptContinuation,
       context, lazy_deopt_parameters, arraysize(lazy_deopt_parameters),
       frame_state, ContinuationFrameStateMode::LAZY);
   Node* load_property =
@@ -1570,7 +1570,7 @@ Reduction JSNativeContextSpecialization::ReduceJSGetIterator(Node* node) {
   // Eager deopt of call iterator property
   Node* parameters[] = {receiver, load_property, call_slot, call_feedback};
   Node* eager_deopt_frame_state = CreateStubBuiltinContinuationFrameState(
-      jsgraph(), Builtins::kCallIteratorWithFeedback, context, parameters,
+      jsgraph(), Builtin::kCallIteratorWithFeedback, context, parameters,
       arraysize(parameters), frame_state, ContinuationFrameStateMode::EAGER);
   Node* deopt_checkpoint = graph()->NewNode(
       common()->Checkpoint(), eager_deopt_frame_state, effect, control);
diff --git a/src/compiler/js-typed-lowering.cc b/src/compiler/js-typed-lowering.cc
index ebd839acabd..fa8da3bd8f7 100644
--- a/src/compiler/js-typed-lowering.cc
+++ b/src/compiler/js-typed-lowering.cc
@@ -1131,7 +1131,7 @@ Reduction JSTypedLowering::ReduceJSToObject(Node* node) {
   Node* rfalse;
   {
     // Convert {receiver} using the ToObjectStub.
-    Callable callable = Builtins::CallableFor(isolate(), Builtins::kToObject);
+    Callable callable = Builtins::CallableFor(isolate(), Builtin::kToObject);
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         graph()->zone(), callable.descriptor(),
         callable.descriptor().GetStackParameterCount(),
@@ -1788,7 +1788,7 @@ Reduction JSTypedLowering::ReduceJSCall(Node* node) {
       DCHECK(Builtins::HasJSLinkage(shared->builtin_id()));
       // Patch {node} to a direct code object call.
       Callable callable = Builtins::CallableFor(
-          isolate(), static_cast<Builtins::Name>(shared->builtin_id()));
+          isolate(), static_cast<Builtin>(shared->builtin_id()));
       CallDescriptor::Flags flags = CallDescriptor::kNeedsFrameState;
 
       const CallInterfaceDescriptor& descriptor = callable.descriptor();
@@ -1913,7 +1913,7 @@ Reduction JSTypedLowering::ReduceJSForInNext(Node* node) {
         // Filter the {key} to check if it's still a valid property of the
         // {receiver} (does the ToName conversion implicitly).
         Callable const callable =
-            Builtins::CallableFor(isolate(), Builtins::kForInFilter);
+            Builtins::CallableFor(isolate(), Builtin::kForInFilter);
         auto call_descriptor = Linkage::GetStubCallDescriptor(
             graph()->zone(), callable.descriptor(),
             callable.descriptor().GetStackParameterCount(),
diff --git a/src/compiler/node-properties.cc b/src/compiler/node-properties.cc
index 206b32e0d7a..ab756eba206 100644
--- a/src/compiler/node-properties.cc
+++ b/src/compiler/node-properties.cc
@@ -597,15 +597,14 @@ bool NodeProperties::IsFreshObject(Node* node) {
     }
     NumberMatcher matcher(node->InputAt(0));
     if (matcher.HasResolvedValue()) {
-      Builtins::Name callee =
-          static_cast<Builtins::Name>(matcher.ResolvedValue());
+      Builtin callee = static_cast<Builtin>(matcher.ResolvedValue());
       // Note: Make sure to only add builtins which are guaranteed to return a
       // fresh object. E.g. kWasmAllocateFixedArray may return the canonical
       // empty array, and kWasmAllocateRtt may return a cached rtt.
-      return callee == Builtins::kWasmAllocateArrayWithRtt ||
-             callee == Builtins::kWasmAllocateStructWithRtt ||
-             callee == Builtins::kWasmAllocateObjectWrapper ||
-             callee == Builtins::kWasmAllocatePair;
+      return callee == Builtin::kWasmAllocateArrayWithRtt ||
+             callee == Builtin::kWasmAllocateStructWithRtt ||
+             callee == Builtin::kWasmAllocateObjectWrapper ||
+             callee == Builtin::kWasmAllocatePair;
     }
   }
 #endif  // V8_ENABLE_WEBASSEMBLY
diff --git a/src/compiler/serializer-for-background-compilation.cc b/src/compiler/serializer-for-background-compilation.cc
index 6a9df305155..56783dbb54c 100644
--- a/src/compiler/serializer-for-background-compilation.cc
+++ b/src/compiler/serializer-for-background-compilation.cc
@@ -1431,7 +1431,7 @@ void SerializerForBackgroundCompilation::VisitInvokeIntrinsic(
   switch (functionId) {
     case Runtime::kInlineAsyncFunctionResolve: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncFunctionResolve));
+                            Builtin::kAsyncFunctionResolve));
       interpreter::Register first_reg = iterator->GetRegisterOperand(1);
       size_t reg_count = iterator->GetRegisterCountOperand(2);
       CHECK_EQ(reg_count, 3);
@@ -1443,60 +1443,60 @@ void SerializerForBackgroundCompilation::VisitInvokeIntrinsic(
     case Runtime::kInlineAsyncGeneratorReject:
     case Runtime::kAsyncGeneratorReject: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncGeneratorReject));
+                            Builtin::kAsyncGeneratorReject));
       break;
     }
     case Runtime::kInlineAsyncGeneratorResolve:
     case Runtime::kAsyncGeneratorResolve: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncGeneratorResolve));
+                            Builtin::kAsyncGeneratorResolve));
       break;
     }
     case Runtime::kInlineAsyncGeneratorYield:
     case Runtime::kAsyncGeneratorYield: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncGeneratorYield));
+                            Builtin::kAsyncGeneratorYield));
       break;
     }
     case Runtime::kInlineAsyncGeneratorAwaitUncaught:
     case Runtime::kAsyncGeneratorAwaitUncaught: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncGeneratorAwaitUncaught));
+                            Builtin::kAsyncGeneratorAwaitUncaught));
       break;
     }
     case Runtime::kInlineAsyncGeneratorAwaitCaught:
     case Runtime::kAsyncGeneratorAwaitCaught: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncGeneratorAwaitCaught));
+                            Builtin::kAsyncGeneratorAwaitCaught));
       break;
     }
     case Runtime::kInlineAsyncFunctionAwaitUncaught:
     case Runtime::kAsyncFunctionAwaitUncaught: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncFunctionAwaitUncaught));
+                            Builtin::kAsyncFunctionAwaitUncaught));
       break;
     }
     case Runtime::kInlineAsyncFunctionAwaitCaught:
     case Runtime::kAsyncFunctionAwaitCaught: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncFunctionAwaitCaught));
+                            Builtin::kAsyncFunctionAwaitCaught));
       break;
     }
     case Runtime::kInlineAsyncFunctionReject:
     case Runtime::kAsyncFunctionReject: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncFunctionReject));
+                            Builtin::kAsyncFunctionReject));
       break;
     }
     case Runtime::kAsyncFunctionResolve: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kAsyncFunctionResolve));
+                            Builtin::kAsyncFunctionResolve));
       break;
     }
     case Runtime::kInlineCopyDataProperties:
     case Runtime::kCopyDataProperties: {
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kCopyDataProperties));
+                            Builtin::kCopyDataProperties));
       break;
     }
     case Runtime::kInlineGetImportMetaObject: {
@@ -2243,9 +2243,9 @@ void SerializerForBackgroundCompilation::ProcessCallVarArgs(
 void SerializerForBackgroundCompilation::ProcessApiCall(
     Handle<SharedFunctionInfo> target, const HintsVector& arguments) {
   for (const auto b :
-       {Builtins::kCallFunctionTemplate_CheckAccess,
-        Builtins::kCallFunctionTemplate_CheckCompatibleReceiver,
-        Builtins::kCallFunctionTemplate_CheckAccessAndCompatibleReceiver}) {
+       {Builtin::kCallFunctionTemplate_CheckAccess,
+        Builtin::kCallFunctionTemplate_CheckCompatibleReceiver,
+        Builtin::kCallFunctionTemplate_CheckAccessAndCompatibleReceiver}) {
     MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(b));
   }
   FunctionTemplateInfoRef target_template_info =
@@ -2314,7 +2314,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
   const char* name = Builtins::name(builtin_id);
   TRACE_BROKER(broker(), "Serializing for call to builtin " << name);
   switch (builtin_id) {
-    case Builtins::kObjectCreate: {
+    case Builtin::kObjectCreate: {
       if (arguments.size() >= 2) {
         ProcessHintsForObjectCreate(arguments[1]);
       } else {
@@ -2323,7 +2323,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
       }
       break;
     }
-    case Builtins::kPromisePrototypeCatch: {
+    case Builtin::kPromisePrototypeCatch: {
       // For JSCallReducer::ReducePromisePrototypeCatch.
       if (speculation_mode != SpeculationMode::kDisallowSpeculation) {
         if (arguments.size() >= 1) {
@@ -2332,7 +2332,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
       }
       break;
     }
-    case Builtins::kPromisePrototypeFinally: {
+    case Builtin::kPromisePrototypeFinally: {
       // For JSCallReducer::ReducePromisePrototypeFinally.
       if (speculation_mode != SpeculationMode::kDisallowSpeculation) {
         if (arguments.size() >= 1) {
@@ -2347,7 +2347,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
       }
       break;
     }
-    case Builtins::kPromisePrototypeThen: {
+    case Builtin::kPromisePrototypeThen: {
       // For JSCallReducer::ReducePromisePrototypeThen.
       if (speculation_mode != SpeculationMode::kDisallowSpeculation) {
         if (arguments.size() >= 1) {
@@ -2356,7 +2356,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
       }
       break;
     }
-    case Builtins::kPromiseResolveTrampoline:
+    case Builtin::kPromiseResolveTrampoline:
       // For JSCallReducer::ReducePromiseInternalResolve and
       // JSNativeContextSpecialization::ReduceJSResolvePromise.
       if (arguments.size() >= 1) {
@@ -2369,8 +2369,8 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         ProcessHintsForPromiseResolve(resolution_hints);
       }
       break;
-    case Builtins::kRegExpPrototypeTest:
-    case Builtins::kRegExpPrototypeTestFast:
+    case Builtin::kRegExpPrototypeTest:
+    case Builtin::kRegExpPrototypeTestFast:
       // For JSCallReducer::ReduceRegExpPrototypeTest.
       if (arguments.size() >= 1 &&
           speculation_mode != SpeculationMode::kDisallowSpeculation) {
@@ -2378,13 +2378,13 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         ProcessHintsForRegExpTest(regexp_hints);
       }
       break;
-    case Builtins::kArrayEvery:
-    case Builtins::kArrayFilter:
-    case Builtins::kArrayForEach:
-    case Builtins::kArrayPrototypeFind:
-    case Builtins::kArrayPrototypeFindIndex:
-    case Builtins::kArrayMap:
-    case Builtins::kArraySome:
+    case Builtin::kArrayEvery:
+    case Builtin::kArrayFilter:
+    case Builtin::kArrayForEach:
+    case Builtin::kArrayPrototypeFind:
+    case Builtin::kArrayPrototypeFindIndex:
+    case Builtin::kArrayMap:
+    case Builtin::kArraySome:
       if (arguments.size() >= 2 &&
           speculation_mode != SpeculationMode::kDisallowSpeculation) {
         Hints const& callback = arguments[1];
@@ -2410,8 +2410,8 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         }
       }
       break;
-    case Builtins::kArrayReduce:
-    case Builtins::kArrayReduceRight:
+    case Builtin::kArrayReduce:
+    case Builtin::kArrayReduceRight:
       if (arguments.size() >= 2 &&
           speculation_mode != SpeculationMode::kDisallowSpeculation) {
         Hints const& callback = arguments[1];
@@ -2435,7 +2435,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         }
       }
       break;
-    case Builtins::kFunctionPrototypeApply:
+    case Builtin::kFunctionPrototypeApply:
       if (arguments.size() >= 1) {
         // Drop hints for all arguments except the user-given receiver.
         Hints const new_receiver =
@@ -2457,7 +2457,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         }
       }
       break;
-    case Builtins::kPromiseConstructor:
+    case Builtin::kPromiseConstructor:
       if (arguments.size() >= 1) {
         // "Call(executor, undefined, ¬´ resolvingFunctions.[[Resolve]],
         //                              resolvingFunctions.[[Reject]] ¬ª)"
@@ -2488,7 +2488,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
                             ->promise_capability_default_resolve_shared_fun());
 
       break;
-    case Builtins::kFunctionPrototypeCall:
+    case Builtin::kFunctionPrototypeCall:
       if (arguments.size() >= 1) {
         HintsVector new_arguments(arguments.begin() + 1, arguments.end(),
                                   zone());
@@ -2504,7 +2504,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         }
       }
       break;
-    case Builtins::kReflectApply:
+    case Builtin::kReflectApply:
       if (arguments.size() >= 2) {
         // Drop hints for all arguments except the user-given receiver.
         Hints const new_receiver =
@@ -2527,7 +2527,7 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
       }
       break;
 
-    case Builtins::kReflectConstruct:
+    case Builtin::kReflectConstruct:
       if (arguments.size() >= 2) {
         for (auto constant : arguments[1].constants()) {
           if (constant->IsJSFunction()) {
@@ -2536,18 +2536,18 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         }
       }
       break;
-    case Builtins::kObjectPrototypeIsPrototypeOf:
+    case Builtin::kObjectPrototypeIsPrototypeOf:
       if (arguments.size() >= 2) {
         ProcessHintsForHasInPrototypeChain(arguments[1]);
       }
       break;
-    case Builtins::kFunctionPrototypeHasInstance:
+    case Builtin::kFunctionPrototypeHasInstance:
       // For JSCallReducer::ReduceFunctionPrototypeHasInstance.
       if (arguments.size() >= 2) {
         ProcessHintsForOrdinaryHasInstance(arguments[0], arguments[1]);
       }
       break;
-    case Builtins::kFastFunctionPrototypeBind:
+    case Builtin::kFastFunctionPrototypeBind:
       if (arguments.size() >= 1 &&
           speculation_mode != SpeculationMode::kDisallowSpeculation) {
         Hints const& bound_target = arguments[0];
@@ -2559,8 +2559,8 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
             broker());
       }
       break;
-    case Builtins::kObjectGetPrototypeOf:
-    case Builtins::kReflectGetPrototypeOf:
+    case Builtin::kObjectGetPrototypeOf:
+    case Builtin::kReflectGetPrototypeOf:
       if (arguments.size() >= 2) {
         ProcessHintsForObjectGetPrototype(arguments[1]);
       } else {
@@ -2569,20 +2569,20 @@ void SerializerForBackgroundCompilation::ProcessBuiltinCall(
         ProcessHintsForObjectGetPrototype(undefined_hint);
       }
       break;
-    case Builtins::kObjectPrototypeGetProto:
+    case Builtin::kObjectPrototypeGetProto:
       if (arguments.size() >= 1) {
         ProcessHintsForObjectGetPrototype(arguments[0]);
       }
       break;
-    case Builtins::kMapIteratorPrototypeNext:
+    case Builtin::kMapIteratorPrototypeNext:
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kOrderedHashTableHealIndex));
+                            Builtin::kOrderedHashTableHealIndex));
       MakeRef<FixedArray>(
           broker(), broker()->isolate()->factory()->empty_ordered_hash_map());
       break;
-    case Builtins::kSetIteratorPrototypeNext:
+    case Builtin::kSetIteratorPrototypeNext:
       MakeRef(broker(), broker()->isolate()->builtins()->builtin_handle(
-                            Builtins::kOrderedHashTableHealIndex));
+                            Builtin::kOrderedHashTableHealIndex));
       MakeRef<FixedArray>(
           broker(), broker()->isolate()->factory()->empty_ordered_hash_set());
       break;
@@ -3457,7 +3457,7 @@ void SerializerForBackgroundCompilation::ProcessConstantForInstanceOf(
       function.Serialize();
       if (function.shared().HasBuiltinId() &&
           function.shared().builtin_id() ==
-              Builtins::kFunctionPrototypeHasInstance) {
+              Builtin::kFunctionPrototypeHasInstance) {
         // For JSCallReducer::ReduceFunctionPrototypeHasInstance.
         ProcessConstantForOrdinaryHasInstance(constructor_heap_object,
                                               walk_prototypes);
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index be599beacad..3d179fd5ec7 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -4849,7 +4849,7 @@ void SimplifiedLowering::DoUnsigned32ToUint8Clamped(Node* node) {
 
 Node* SimplifiedLowering::ToNumberCode() {
   if (!to_number_code_.is_set()) {
-    Callable callable = Builtins::CallableFor(isolate(), Builtins::kToNumber);
+    Callable callable = Builtins::CallableFor(isolate(), Builtin::kToNumber);
     to_number_code_.set(jsgraph()->HeapConstant(callable.code()));
   }
   return to_number_code_.get();
@@ -4858,7 +4858,7 @@ Node* SimplifiedLowering::ToNumberCode() {
 Node* SimplifiedLowering::ToNumberConvertBigIntCode() {
   if (!to_number_convert_big_int_code_.is_set()) {
     Callable callable =
-        Builtins::CallableFor(isolate(), Builtins::kToNumberConvertBigInt);
+        Builtins::CallableFor(isolate(), Builtin::kToNumberConvertBigInt);
     to_number_convert_big_int_code_.set(
         jsgraph()->HeapConstant(callable.code()));
   }
@@ -4867,7 +4867,7 @@ Node* SimplifiedLowering::ToNumberConvertBigIntCode() {
 
 Node* SimplifiedLowering::ToNumericCode() {
   if (!to_numeric_code_.is_set()) {
-    Callable callable = Builtins::CallableFor(isolate(), Builtins::kToNumeric);
+    Callable callable = Builtins::CallableFor(isolate(), Builtin::kToNumeric);
     to_numeric_code_.set(jsgraph()->HeapConstant(callable.code()));
   }
   return to_numeric_code_.get();
@@ -4875,7 +4875,7 @@ Node* SimplifiedLowering::ToNumericCode() {
 
 Operator const* SimplifiedLowering::ToNumberOperator() {
   if (!to_number_operator_.is_set()) {
-    Callable callable = Builtins::CallableFor(isolate(), Builtins::kToNumber);
+    Callable callable = Builtins::CallableFor(isolate(), Builtin::kToNumber);
     CallDescriptor::Flags flags = CallDescriptor::kNeedsFrameState;
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         graph()->zone(), callable.descriptor(),
@@ -4889,7 +4889,7 @@ Operator const* SimplifiedLowering::ToNumberOperator() {
 Operator const* SimplifiedLowering::ToNumberConvertBigIntOperator() {
   if (!to_number_convert_big_int_operator_.is_set()) {
     Callable callable =
-        Builtins::CallableFor(isolate(), Builtins::kToNumberConvertBigInt);
+        Builtins::CallableFor(isolate(), Builtin::kToNumberConvertBigInt);
     CallDescriptor::Flags flags = CallDescriptor::kNeedsFrameState;
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         graph()->zone(), callable.descriptor(),
@@ -4902,7 +4902,7 @@ Operator const* SimplifiedLowering::ToNumberConvertBigIntOperator() {
 
 Operator const* SimplifiedLowering::ToNumericOperator() {
   if (!to_numeric_operator_.is_set()) {
-    Callable callable = Builtins::CallableFor(isolate(), Builtins::kToNumeric);
+    Callable callable = Builtins::CallableFor(isolate(), Builtin::kToNumeric);
     CallDescriptor::Flags flags = CallDescriptor::kNeedsFrameState;
     auto call_descriptor = Linkage::GetStubCallDescriptor(
         graph()->zone(), callable.descriptor(),
diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc
index 5a918652524..c30a291079d 100644
--- a/src/compiler/typer.cc
+++ b/src/compiler/typer.cc
@@ -1517,288 +1517,288 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) {
     return Type::NonInternal();
   }
   switch (function.shared().builtin_id()) {
-    case Builtins::kMathRandom:
+    case Builtin::kMathRandom:
       return Type::PlainNumber();
-    case Builtins::kMathFloor:
-    case Builtins::kMathCeil:
-    case Builtins::kMathRound:
-    case Builtins::kMathTrunc:
+    case Builtin::kMathFloor:
+    case Builtin::kMathCeil:
+    case Builtin::kMathRound:
+    case Builtin::kMathTrunc:
       return t->cache_->kIntegerOrMinusZeroOrNaN;
     // Unary math functions.
-    case Builtins::kMathAbs:
-    case Builtins::kMathExp:
+    case Builtin::kMathAbs:
+    case Builtin::kMathExp:
       return Type::Union(Type::PlainNumber(), Type::NaN(), t->zone());
-    case Builtins::kMathAcos:
-    case Builtins::kMathAcosh:
-    case Builtins::kMathAsin:
-    case Builtins::kMathAsinh:
-    case Builtins::kMathAtan:
-    case Builtins::kMathAtanh:
-    case Builtins::kMathCbrt:
-    case Builtins::kMathCos:
-    case Builtins::kMathExpm1:
-    case Builtins::kMathFround:
-    case Builtins::kMathLog:
-    case Builtins::kMathLog1p:
-    case Builtins::kMathLog10:
-    case Builtins::kMathLog2:
-    case Builtins::kMathSin:
-    case Builtins::kMathSqrt:
-    case Builtins::kMathTan:
+    case Builtin::kMathAcos:
+    case Builtin::kMathAcosh:
+    case Builtin::kMathAsin:
+    case Builtin::kMathAsinh:
+    case Builtin::kMathAtan:
+    case Builtin::kMathAtanh:
+    case Builtin::kMathCbrt:
+    case Builtin::kMathCos:
+    case Builtin::kMathExpm1:
+    case Builtin::kMathFround:
+    case Builtin::kMathLog:
+    case Builtin::kMathLog1p:
+    case Builtin::kMathLog10:
+    case Builtin::kMathLog2:
+    case Builtin::kMathSin:
+    case Builtin::kMathSqrt:
+    case Builtin::kMathTan:
       return Type::Number();
-    case Builtins::kMathSign:
+    case Builtin::kMathSign:
       return t->cache_->kMinusOneToOneOrMinusZeroOrNaN;
     // Binary math functions.
-    case Builtins::kMathAtan2:
-    case Builtins::kMathPow:
-    case Builtins::kMathMax:
-    case Builtins::kMathMin:
-    case Builtins::kMathHypot:
+    case Builtin::kMathAtan2:
+    case Builtin::kMathPow:
+    case Builtin::kMathMax:
+    case Builtin::kMathMin:
+    case Builtin::kMathHypot:
       return Type::Number();
-    case Builtins::kMathImul:
+    case Builtin::kMathImul:
       return Type::Signed32();
-    case Builtins::kMathClz32:
+    case Builtin::kMathClz32:
       return t->cache_->kZeroToThirtyTwo;
     // Date functions.
-    case Builtins::kDateNow:
+    case Builtin::kDateNow:
       return t->cache_->kTimeValueType;
-    case Builtins::kDatePrototypeGetDate:
+    case Builtin::kDatePrototypeGetDate:
       return t->cache_->kJSDateDayType;
-    case Builtins::kDatePrototypeGetDay:
+    case Builtin::kDatePrototypeGetDay:
       return t->cache_->kJSDateWeekdayType;
-    case Builtins::kDatePrototypeGetFullYear:
+    case Builtin::kDatePrototypeGetFullYear:
       return t->cache_->kJSDateYearType;
-    case Builtins::kDatePrototypeGetHours:
+    case Builtin::kDatePrototypeGetHours:
       return t->cache_->kJSDateHourType;
-    case Builtins::kDatePrototypeGetMilliseconds:
+    case Builtin::kDatePrototypeGetMilliseconds:
       return Type::Union(Type::Range(0.0, 999.0, t->zone()), Type::NaN(),
                          t->zone());
-    case Builtins::kDatePrototypeGetMinutes:
+    case Builtin::kDatePrototypeGetMinutes:
       return t->cache_->kJSDateMinuteType;
-    case Builtins::kDatePrototypeGetMonth:
+    case Builtin::kDatePrototypeGetMonth:
       return t->cache_->kJSDateMonthType;
-    case Builtins::kDatePrototypeGetSeconds:
+    case Builtin::kDatePrototypeGetSeconds:
       return t->cache_->kJSDateSecondType;
-    case Builtins::kDatePrototypeGetTime:
+    case Builtin::kDatePrototypeGetTime:
       return t->cache_->kJSDateValueType;
 
     // Symbol functions.
-    case Builtins::kSymbolConstructor:
+    case Builtin::kSymbolConstructor:
       return Type::Symbol();
-    case Builtins::kSymbolPrototypeToString:
+    case Builtin::kSymbolPrototypeToString:
       return Type::String();
-    case Builtins::kSymbolPrototypeValueOf:
+    case Builtin::kSymbolPrototypeValueOf:
       return Type::Symbol();
 
     // BigInt functions.
-    case Builtins::kBigIntConstructor:
+    case Builtin::kBigIntConstructor:
       return Type::BigInt();
 
     // Number functions.
-    case Builtins::kNumberConstructor:
+    case Builtin::kNumberConstructor:
       return Type::Number();
-    case Builtins::kNumberIsFinite:
-    case Builtins::kNumberIsInteger:
-    case Builtins::kNumberIsNaN:
-    case Builtins::kNumberIsSafeInteger:
+    case Builtin::kNumberIsFinite:
+    case Builtin::kNumberIsInteger:
+    case Builtin::kNumberIsNaN:
+    case Builtin::kNumberIsSafeInteger:
       return Type::Boolean();
-    case Builtins::kNumberParseFloat:
+    case Builtin::kNumberParseFloat:
       return Type::Number();
-    case Builtins::kNumberParseInt:
+    case Builtin::kNumberParseInt:
       return t->cache_->kIntegerOrMinusZeroOrNaN;
-    case Builtins::kNumberToString:
+    case Builtin::kNumberToString:
       return Type::String();
 
     // String functions.
-    case Builtins::kStringConstructor:
+    case Builtin::kStringConstructor:
       return Type::String();
-    case Builtins::kStringPrototypeCharCodeAt:
+    case Builtin::kStringPrototypeCharCodeAt:
       return Type::Union(Type::Range(0, kMaxUInt16, t->zone()), Type::NaN(),
                          t->zone());
-    case Builtins::kStringCharAt:
+    case Builtin::kStringCharAt:
       return Type::String();
-    case Builtins::kStringPrototypeCodePointAt:
+    case Builtin::kStringPrototypeCodePointAt:
       return Type::Union(Type::Range(0.0, String::kMaxCodePoint, t->zone()),
                          Type::Undefined(), t->zone());
-    case Builtins::kStringPrototypeConcat:
-    case Builtins::kStringFromCharCode:
-    case Builtins::kStringFromCodePoint:
+    case Builtin::kStringPrototypeConcat:
+    case Builtin::kStringFromCharCode:
+    case Builtin::kStringFromCodePoint:
       return Type::String();
-    case Builtins::kStringPrototypeIndexOf:
-    case Builtins::kStringPrototypeLastIndexOf:
+    case Builtin::kStringPrototypeIndexOf:
+    case Builtin::kStringPrototypeLastIndexOf:
       return Type::Range(-1.0, String::kMaxLength, t->zone());
-    case Builtins::kStringPrototypeEndsWith:
-    case Builtins::kStringPrototypeIncludes:
+    case Builtin::kStringPrototypeEndsWith:
+    case Builtin::kStringPrototypeIncludes:
       return Type::Boolean();
-    case Builtins::kStringRaw:
-    case Builtins::kStringRepeat:
-    case Builtins::kStringPrototypeSlice:
+    case Builtin::kStringRaw:
+    case Builtin::kStringRepeat:
+    case Builtin::kStringPrototypeSlice:
       return Type::String();
-    case Builtins::kStringPrototypeStartsWith:
+    case Builtin::kStringPrototypeStartsWith:
       return Type::Boolean();
-    case Builtins::kStringPrototypeSubstr:
-    case Builtins::kStringSubstring:
-    case Builtins::kStringPrototypeToString:
+    case Builtin::kStringPrototypeSubstr:
+    case Builtin::kStringSubstring:
+    case Builtin::kStringPrototypeToString:
 #ifdef V8_INTL_SUPPORT
-    case Builtins::kStringPrototypeToLowerCaseIntl:
-    case Builtins::kStringPrototypeToUpperCaseIntl:
+    case Builtin::kStringPrototypeToLowerCaseIntl:
+    case Builtin::kStringPrototypeToUpperCaseIntl:
 #else
-    case Builtins::kStringPrototypeToLowerCase:
-    case Builtins::kStringPrototypeToUpperCase:
+    case Builtin::kStringPrototypeToLowerCase:
+    case Builtin::kStringPrototypeToUpperCase:
 #endif
-    case Builtins::kStringPrototypeTrim:
-    case Builtins::kStringPrototypeTrimEnd:
-    case Builtins::kStringPrototypeTrimStart:
-    case Builtins::kStringPrototypeValueOf:
+    case Builtin::kStringPrototypeTrim:
+    case Builtin::kStringPrototypeTrimEnd:
+    case Builtin::kStringPrototypeTrimStart:
+    case Builtin::kStringPrototypeValueOf:
       return Type::String();
 
-    case Builtins::kStringPrototypeIterator:
-    case Builtins::kStringIteratorPrototypeNext:
+    case Builtin::kStringPrototypeIterator:
+    case Builtin::kStringIteratorPrototypeNext:
       return Type::OtherObject();
 
-    case Builtins::kArrayPrototypeEntries:
-    case Builtins::kArrayPrototypeKeys:
-    case Builtins::kArrayPrototypeValues:
-    case Builtins::kTypedArrayPrototypeEntries:
-    case Builtins::kTypedArrayPrototypeKeys:
-    case Builtins::kTypedArrayPrototypeValues:
-    case Builtins::kArrayIteratorPrototypeNext:
-    case Builtins::kMapIteratorPrototypeNext:
-    case Builtins::kSetIteratorPrototypeNext:
+    case Builtin::kArrayPrototypeEntries:
+    case Builtin::kArrayPrototypeKeys:
+    case Builtin::kArrayPrototypeValues:
+    case Builtin::kTypedArrayPrototypeEntries:
+    case Builtin::kTypedArrayPrototypeKeys:
+    case Builtin::kTypedArrayPrototypeValues:
+    case Builtin::kArrayIteratorPrototypeNext:
+    case Builtin::kMapIteratorPrototypeNext:
+    case Builtin::kSetIteratorPrototypeNext:
       return Type::OtherObject();
-    case Builtins::kTypedArrayPrototypeToStringTag:
+    case Builtin::kTypedArrayPrototypeToStringTag:
       return Type::Union(Type::InternalizedString(), Type::Undefined(),
                          t->zone());
 
     // Array functions.
-    case Builtins::kArrayIsArray:
+    case Builtin::kArrayIsArray:
       return Type::Boolean();
-    case Builtins::kArrayConcat:
+    case Builtin::kArrayConcat:
       return Type::Receiver();
-    case Builtins::kArrayEvery:
+    case Builtin::kArrayEvery:
       return Type::Boolean();
-    case Builtins::kArrayPrototypeFill:
-    case Builtins::kArrayFilter:
+    case Builtin::kArrayPrototypeFill:
+    case Builtin::kArrayFilter:
       return Type::Receiver();
-    case Builtins::kArrayPrototypeFindIndex:
+    case Builtin::kArrayPrototypeFindIndex:
       return Type::Range(-1, kMaxSafeInteger, t->zone());
-    case Builtins::kArrayForEach:
+    case Builtin::kArrayForEach:
       return Type::Undefined();
-    case Builtins::kArrayIncludes:
+    case Builtin::kArrayIncludes:
       return Type::Boolean();
-    case Builtins::kArrayIndexOf:
+    case Builtin::kArrayIndexOf:
       return Type::Range(-1, kMaxSafeInteger, t->zone());
-    case Builtins::kArrayPrototypeJoin:
+    case Builtin::kArrayPrototypeJoin:
       return Type::String();
-    case Builtins::kArrayPrototypeLastIndexOf:
+    case Builtin::kArrayPrototypeLastIndexOf:
       return Type::Range(-1, kMaxSafeInteger, t->zone());
-    case Builtins::kArrayMap:
+    case Builtin::kArrayMap:
       return Type::Receiver();
-    case Builtins::kArrayPush:
+    case Builtin::kArrayPush:
       return t->cache_->kPositiveSafeInteger;
-    case Builtins::kArrayPrototypeReverse:
-    case Builtins::kArrayPrototypeSlice:
+    case Builtin::kArrayPrototypeReverse:
+    case Builtin::kArrayPrototypeSlice:
       return Type::Receiver();
-    case Builtins::kArraySome:
+    case Builtin::kArraySome:
       return Type::Boolean();
-    case Builtins::kArrayPrototypeSplice:
+    case Builtin::kArrayPrototypeSplice:
       return Type::Receiver();
-    case Builtins::kArrayUnshift:
+    case Builtin::kArrayUnshift:
       return t->cache_->kPositiveSafeInteger;
 
     // ArrayBuffer functions.
-    case Builtins::kArrayBufferIsView:
+    case Builtin::kArrayBufferIsView:
       return Type::Boolean();
 
     // Object functions.
-    case Builtins::kObjectAssign:
+    case Builtin::kObjectAssign:
       return Type::Receiver();
-    case Builtins::kObjectCreate:
+    case Builtin::kObjectCreate:
       return Type::OtherObject();
-    case Builtins::kObjectIs:
-    case Builtins::kObjectHasOwn:
-    case Builtins::kObjectPrototypeHasOwnProperty:
-    case Builtins::kObjectPrototypeIsPrototypeOf:
+    case Builtin::kObjectIs:
+    case Builtin::kObjectHasOwn:
+    case Builtin::kObjectPrototypeHasOwnProperty:
+    case Builtin::kObjectPrototypeIsPrototypeOf:
       return Type::Boolean();
-    case Builtins::kObjectToString:
+    case Builtin::kObjectToString:
       return Type::String();
 
-    case Builtins::kPromiseAll:
+    case Builtin::kPromiseAll:
       return Type::Receiver();
-    case Builtins::kPromisePrototypeThen:
+    case Builtin::kPromisePrototypeThen:
       return Type::Receiver();
-    case Builtins::kPromiseRace:
+    case Builtin::kPromiseRace:
       return Type::Receiver();
-    case Builtins::kPromiseReject:
+    case Builtin::kPromiseReject:
       return Type::Receiver();
-    case Builtins::kPromiseResolveTrampoline:
+    case Builtin::kPromiseResolveTrampoline:
       return Type::Receiver();
 
     // RegExp functions.
-    case Builtins::kRegExpPrototypeCompile:
+    case Builtin::kRegExpPrototypeCompile:
       return Type::OtherObject();
-    case Builtins::kRegExpPrototypeExec:
+    case Builtin::kRegExpPrototypeExec:
       return Type::Union(Type::Array(), Type::Null(), t->zone());
-    case Builtins::kRegExpPrototypeTest:
+    case Builtin::kRegExpPrototypeTest:
       return Type::Boolean();
-    case Builtins::kRegExpPrototypeToString:
+    case Builtin::kRegExpPrototypeToString:
       return Type::String();
 
     // Function functions.
-    case Builtins::kFunctionPrototypeBind:
+    case Builtin::kFunctionPrototypeBind:
       return Type::BoundFunction();
-    case Builtins::kFunctionPrototypeHasInstance:
+    case Builtin::kFunctionPrototypeHasInstance:
       return Type::Boolean();
 
     // Global functions.
-    case Builtins::kGlobalDecodeURI:
-    case Builtins::kGlobalDecodeURIComponent:
-    case Builtins::kGlobalEncodeURI:
-    case Builtins::kGlobalEncodeURIComponent:
-    case Builtins::kGlobalEscape:
-    case Builtins::kGlobalUnescape:
+    case Builtin::kGlobalDecodeURI:
+    case Builtin::kGlobalDecodeURIComponent:
+    case Builtin::kGlobalEncodeURI:
+    case Builtin::kGlobalEncodeURIComponent:
+    case Builtin::kGlobalEscape:
+    case Builtin::kGlobalUnescape:
       return Type::String();
-    case Builtins::kGlobalIsFinite:
-    case Builtins::kGlobalIsNaN:
+    case Builtin::kGlobalIsFinite:
+    case Builtin::kGlobalIsNaN:
       return Type::Boolean();
 
     // Map functions.
-    case Builtins::kMapPrototypeClear:
-    case Builtins::kMapPrototypeForEach:
+    case Builtin::kMapPrototypeClear:
+    case Builtin::kMapPrototypeForEach:
       return Type::Undefined();
-    case Builtins::kMapPrototypeDelete:
-    case Builtins::kMapPrototypeHas:
+    case Builtin::kMapPrototypeDelete:
+    case Builtin::kMapPrototypeHas:
       return Type::Boolean();
-    case Builtins::kMapPrototypeEntries:
-    case Builtins::kMapPrototypeKeys:
-    case Builtins::kMapPrototypeSet:
-    case Builtins::kMapPrototypeValues:
+    case Builtin::kMapPrototypeEntries:
+    case Builtin::kMapPrototypeKeys:
+    case Builtin::kMapPrototypeSet:
+    case Builtin::kMapPrototypeValues:
       return Type::OtherObject();
 
     // Set functions.
-    case Builtins::kSetPrototypeAdd:
-    case Builtins::kSetPrototypeEntries:
-    case Builtins::kSetPrototypeValues:
+    case Builtin::kSetPrototypeAdd:
+    case Builtin::kSetPrototypeEntries:
+    case Builtin::kSetPrototypeValues:
       return Type::OtherObject();
-    case Builtins::kSetPrototypeClear:
-    case Builtins::kSetPrototypeForEach:
+    case Builtin::kSetPrototypeClear:
+    case Builtin::kSetPrototypeForEach:
       return Type::Undefined();
-    case Builtins::kSetPrototypeDelete:
-    case Builtins::kSetPrototypeHas:
+    case Builtin::kSetPrototypeDelete:
+    case Builtin::kSetPrototypeHas:
       return Type::Boolean();
 
     // WeakMap functions.
-    case Builtins::kWeakMapPrototypeDelete:
-    case Builtins::kWeakMapPrototypeHas:
+    case Builtin::kWeakMapPrototypeDelete:
+    case Builtin::kWeakMapPrototypeHas:
       return Type::Boolean();
-    case Builtins::kWeakMapPrototypeSet:
+    case Builtin::kWeakMapPrototypeSet:
       return Type::OtherObject();
 
     // WeakSet functions.
-    case Builtins::kWeakSetPrototypeAdd:
+    case Builtin::kWeakSetPrototypeAdd:
       return Type::OtherObject();
-    case Builtins::kWeakSetPrototypeDelete:
-    case Builtins::kWeakSetPrototypeHas:
+    case Builtin::kWeakSetPrototypeDelete:
+    case Builtin::kWeakSetPrototypeHas:
       return Type::Boolean();
     default:
       return Type::NonInternal();
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 2a785967d4f..5f03f1b55bc 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -119,12 +119,12 @@ bool ContainsInt64(const wasm::FunctionSig* sig) {
   return false;
 }
 
-constexpr Builtins::Name WasmRuntimeStubIdToBuiltinName(
+constexpr Builtin WasmRuntimeStubIdToBuiltinName(
     wasm::WasmCode::RuntimeStubId runtime_stub_id) {
   switch (runtime_stub_id) {
 #define DEF_CASE(name)          \
   case wasm::WasmCode::k##name: \
-    return Builtins::k##name;
+    return Builtin::k##name;
 #define DEF_TRAP_CASE(name) DEF_CASE(ThrowWasm##name)
     WASM_RUNTIME_STUB_LIST(DEF_CASE, DEF_TRAP_CASE)
 #undef DEF_CASE
@@ -135,7 +135,7 @@ constexpr Builtins::Name WasmRuntimeStubIdToBuiltinName(
 }
 
 CallDescriptor* GetBuiltinCallDescriptor(
-    Builtins::Name name, Zone* zone, StubCallMode stub_mode,
+    Builtin name, Zone* zone, StubCallMode stub_mode,
     bool needs_frame_state = false,
     Operator::Properties properties = Operator::kNoProperties) {
   CallInterfaceDescriptor interface_descriptor =
@@ -187,7 +187,7 @@ class WasmGraphAssembler : public GraphAssembler {
   }
 
   template <typename... Args>
-  Node* CallBuiltin(Builtins::Name name, Operator::Properties properties,
+  Node* CallBuiltin(Builtin name, Operator::Properties properties,
                     Args*... args) {
     auto* call_descriptor = GetBuiltinCallDescriptor(
         name, temp_zone(), StubCallMode::kCallBuiltinPointer, false,
@@ -219,7 +219,7 @@ class WasmGraphAssembler : public GraphAssembler {
 #endif
   }
 
-  Node* GetBuiltinPointerTarget(Builtins::Name builtin_id) {
+  Node* GetBuiltinPointerTarget(Builtin builtin_id) {
     static_assert(std::is_same<Smi, BuiltinPtr>(), "BuiltinPtr must be Smi");
     return NumberConstant(builtin_id);
   }
@@ -2481,7 +2481,7 @@ Node* WasmGraphBuilder::LoadExceptionTagFromTable(uint32_t exception_index) {
 
 Node* WasmGraphBuilder::GetExceptionTag(Node* except_obj) {
   return gasm_->CallBuiltin(
-      Builtins::kWasmGetOwnProperty, Operator::kEliminatable, except_obj,
+      Builtin::kWasmGetOwnProperty, Operator::kEliminatable, except_obj,
       LOAD_ROOT(wasm_exception_tag_symbol, wasm_exception_tag_symbol),
       LOAD_INSTANCE_FIELD(NativeContext, MachineType::TaggedPointer()));
 }
@@ -2490,7 +2490,7 @@ Node* WasmGraphBuilder::GetExceptionValues(Node* except_obj,
                                            const wasm::WasmException* exception,
                                            Vector<Node*> values) {
   Node* values_array = gasm_->CallBuiltin(
-      Builtins::kWasmGetOwnProperty, Operator::kEliminatable, except_obj,
+      Builtin::kWasmGetOwnProperty, Operator::kEliminatable, except_obj,
       LOAD_ROOT(wasm_exception_values_symbol, wasm_exception_values_symbol),
       LOAD_INSTANCE_FIELD(NativeContext, MachineType::TaggedPointer()));
   uint32_t index = 0;
@@ -3594,7 +3594,7 @@ Node* WasmGraphBuilder::BuildCallToRuntimeWithContext(Runtime::FunctionId f,
   Node* isolate_root = BuildLoadIsolateRoot();
   DCHECK_EQ(1, fun->result_size);
   auto centry_id =
-      Builtins::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit;
+      Builtin::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit;
   Node* centry_stub =
       gasm_->LoadFromObject(MachineType::Pointer(), isolate_root,
                             IsolateData::builtin_slot_offset(centry_id));
@@ -4486,13 +4486,12 @@ void WasmGraphBuilder::AddInt64LoweringReplacement(
 CallDescriptor* WasmGraphBuilder::GetI32AtomicWaitCallDescriptor() {
   if (i32_atomic_wait_descriptor_) return i32_atomic_wait_descriptor_;
 
-  i32_atomic_wait_descriptor_ =
-      GetBuiltinCallDescriptor(Builtins::kWasmI32AtomicWait64, zone_,
-                               StubCallMode::kCallWasmRuntimeStub);
+  i32_atomic_wait_descriptor_ = GetBuiltinCallDescriptor(
+      Builtin::kWasmI32AtomicWait64, zone_, StubCallMode::kCallWasmRuntimeStub);
 
   AddInt64LoweringReplacement(
       i32_atomic_wait_descriptor_,
-      GetBuiltinCallDescriptor(Builtins::kWasmI32AtomicWait32, zone_,
+      GetBuiltinCallDescriptor(Builtin::kWasmI32AtomicWait32, zone_,
                                StubCallMode::kCallWasmRuntimeStub));
 
   return i32_atomic_wait_descriptor_;
@@ -4501,13 +4500,12 @@ CallDescriptor* WasmGraphBuilder::GetI32AtomicWaitCallDescriptor() {
 CallDescriptor* WasmGraphBuilder::GetI64AtomicWaitCallDescriptor() {
   if (i64_atomic_wait_descriptor_) return i64_atomic_wait_descriptor_;
 
-  i64_atomic_wait_descriptor_ =
-      GetBuiltinCallDescriptor(Builtins::kWasmI64AtomicWait64, zone_,
-                               StubCallMode::kCallWasmRuntimeStub);
+  i64_atomic_wait_descriptor_ = GetBuiltinCallDescriptor(
+      Builtin::kWasmI64AtomicWait64, zone_, StubCallMode::kCallWasmRuntimeStub);
 
   AddInt64LoweringReplacement(
       i64_atomic_wait_descriptor_,
-      GetBuiltinCallDescriptor(Builtins::kWasmI64AtomicWait32, zone_,
+      GetBuiltinCallDescriptor(Builtin::kWasmI64AtomicWait32, zone_,
                                StubCallMode::kCallWasmRuntimeStub));
 
   return i64_atomic_wait_descriptor_;
@@ -5554,7 +5552,7 @@ void WasmGraphBuilder::TableFill(uint32_t table_index, Node* start, Node* value,
 Node* WasmGraphBuilder::StructNewWithRtt(uint32_t struct_index,
                                          const wasm::StructType* type,
                                          Node* rtt, Vector<Node*> fields) {
-  Node* s = gasm_->CallBuiltin(Builtins::kWasmAllocateStructWithRtt,
+  Node* s = gasm_->CallBuiltin(Builtin::kWasmAllocateStructWithRtt,
                                Operator::kEliminatable, rtt);
   for (uint32_t i = 0; i < type->field_count(); i++) {
     gasm_->StoreStructField(s, type, i, fields[i]);
@@ -5578,7 +5576,7 @@ Node* WasmGraphBuilder::ArrayNewWithRtt(uint32_t array_index,
               position);
   wasm::ValueType element_type = type->element_type();
   Node* a = gasm_->CallBuiltin(
-      Builtins::kWasmAllocateArrayWithRtt, Operator::kEliminatable, rtt, length,
+      Builtin::kWasmAllocateArrayWithRtt, Operator::kEliminatable, rtt, length,
       Int32Constant(element_type.element_size_bytes()));
   auto loop = gasm_->MakeLoopLabel(MachineRepresentation::kWord32);
   auto done = gasm_->MakeLabel();
@@ -5612,9 +5610,9 @@ Node* WasmGraphBuilder::RttCanon(uint32_t type_index) {
 
 Node* WasmGraphBuilder::RttSub(uint32_t type_index, Node* parent_rtt,
                                WasmRttSubMode mode) {
-  Builtins::Name target = mode == WasmRttSubMode::kCanonicalize
-                              ? Builtins::kWasmAllocateRtt
-                              : Builtins::kWasmAllocateFreshRtt;
+  Builtin target = mode == WasmRttSubMode::kCanonicalize
+                       ? Builtin::kWasmAllocateRtt
+                       : Builtin::kWasmAllocateFreshRtt;
   return gasm_->CallBuiltin(target, Operator::kEliminatable,
                             Int32Constant(type_index), parent_rtt);
 }
@@ -5976,7 +5974,7 @@ void WasmGraphBuilder::ArrayCopy(Node* dst_array, Node* dst_index,
   Operator::Properties copy_properties =
       Operator::kIdempotent | Operator::kNoThrow | Operator::kNoDeopt;
   // The builtin needs the int parameters first.
-  gasm_->CallBuiltin(Builtins::kWasmArrayCopy, copy_properties, dst_index,
+  gasm_->CallBuiltin(Builtin::kWasmArrayCopy, copy_properties, dst_index,
                      src_index, length, dst_array, src_array);
 }
 
@@ -6061,12 +6059,11 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     if (i64_to_bigint_descriptor_) return i64_to_bigint_descriptor_;
 
     i64_to_bigint_descriptor_ =
-        GetBuiltinCallDescriptor(Builtins::kI64ToBigInt, zone_, stub_mode_);
+        GetBuiltinCallDescriptor(Builtin::kI64ToBigInt, zone_, stub_mode_);
 
     AddInt64LoweringReplacement(
         i64_to_bigint_descriptor_,
-        GetBuiltinCallDescriptor(Builtins::kI32PairToBigInt, zone_,
-                                 stub_mode_));
+        GetBuiltinCallDescriptor(Builtin::kI32PairToBigInt, zone_, stub_mode_));
     return i64_to_bigint_descriptor_;
   }
 
@@ -6074,17 +6071,16 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     if (bigint_to_i64_descriptor_) return bigint_to_i64_descriptor_;
 
     bigint_to_i64_descriptor_ = GetBuiltinCallDescriptor(
-        Builtins::kBigIntToI64, zone_, stub_mode_, needs_frame_state);
+        Builtin::kBigIntToI64, zone_, stub_mode_, needs_frame_state);
 
     AddInt64LoweringReplacement(
         bigint_to_i64_descriptor_,
-        GetBuiltinCallDescriptor(Builtins::kBigIntToI32Pair, zone_,
-                                 stub_mode_));
+        GetBuiltinCallDescriptor(Builtin::kBigIntToI32Pair, zone_, stub_mode_));
     return bigint_to_i64_descriptor_;
   }
 
   Node* GetTargetForBuiltinCall(wasm::WasmCode::RuntimeStubId wasm_stub,
-                                Builtins::Name builtin_id) {
+                                Builtin builtin_id) {
     return (stub_mode_ == StubCallMode::kCallWasmRuntimeStub)
                ? mcgraph()->RelocatableIntPtrConstant(wasm_stub,
                                                       RelocInfo::WASM_STUB_CALL)
@@ -6118,7 +6114,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     CommonOperatorBuilder* common = mcgraph()->common();
     Node* target =
         GetTargetForBuiltinCall(wasm::WasmCode::kWasmInt32ToHeapNumber,
-                                Builtins::kWasmInt32ToHeapNumber);
+                                Builtin::kWasmInt32ToHeapNumber);
     if (!int32_to_heapnumber_operator_.is_set()) {
       auto call_descriptor = Linkage::GetStubCallDescriptor(
           mcgraph()->zone(), WasmInt32ToHeapNumberDescriptor(), 0,
@@ -6150,7 +6146,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     CommonOperatorBuilder* common = mcgraph()->common();
     Node* target =
         GetTargetForBuiltinCall(wasm::WasmCode::kWasmTaggedNonSmiToInt32,
-                                Builtins::kWasmTaggedNonSmiToInt32);
+                                Builtin::kWasmTaggedNonSmiToInt32);
     if (!tagged_non_smi_to_int32_operator_.is_set()) {
       auto call_descriptor = Linkage::GetStubCallDescriptor(
           mcgraph()->zone(), WasmTaggedNonSmiToInt32Descriptor(), 0,
@@ -6173,7 +6169,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
   Node* BuildChangeFloat32ToNumber(Node* value) {
     CommonOperatorBuilder* common = mcgraph()->common();
     Node* target = GetTargetForBuiltinCall(wasm::WasmCode::kWasmFloat32ToNumber,
-                                           Builtins::kWasmFloat32ToNumber);
+                                           Builtin::kWasmFloat32ToNumber);
     if (!float32_to_number_operator_.is_set()) {
       auto call_descriptor = Linkage::GetStubCallDescriptor(
           mcgraph()->zone(), WasmFloat32ToNumberDescriptor(), 0,
@@ -6186,7 +6182,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
   Node* BuildChangeFloat64ToNumber(Node* value) {
     CommonOperatorBuilder* common = mcgraph()->common();
     Node* target = GetTargetForBuiltinCall(wasm::WasmCode::kWasmFloat64ToNumber,
-                                           Builtins::kWasmFloat64ToNumber);
+                                           Builtin::kWasmFloat64ToNumber);
     if (!float64_to_number_operator_.is_set()) {
       auto call_descriptor = Linkage::GetStubCallDescriptor(
           mcgraph()->zone(), WasmFloat64ToNumberDescriptor(), 0,
@@ -6200,7 +6196,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
                                    Node* frame_state) {
     CommonOperatorBuilder* common = mcgraph()->common();
     Node* target = GetTargetForBuiltinCall(wasm::WasmCode::kWasmTaggedToFloat64,
-                                           Builtins::kWasmTaggedToFloat64);
+                                           Builtin::kWasmTaggedToFloat64);
     bool needs_frame_state = frame_state != nullptr;
     if (!tagged_to_float64_operator_.is_set()) {
       auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -6304,7 +6300,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
   Node* BuildAllocateObjectWrapper(Node* input) {
     if (FLAG_wasm_gc_js_interop) return input;
     return gasm_->CallBuiltin(
-        Builtins::kWasmAllocateObjectWrapper, Operator::kEliminatable, input,
+        Builtin::kWasmAllocateObjectWrapper, Operator::kEliminatable, input,
         LOAD_INSTANCE_FIELD(NativeContext, MachineType::TaggedPointer()));
   }
 
@@ -6315,7 +6311,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
   Node* BuildUnpackObjectWrapper(Node* input) {
     if (FLAG_wasm_gc_js_interop) return input;
     Node* obj = gasm_->CallBuiltin(
-        Builtins::kWasmGetOwnProperty, Operator::kEliminatable, input,
+        Builtin::kWasmGetOwnProperty, Operator::kEliminatable, input,
         LOAD_ROOT(wasm_wrapped_object_symbol, wasm_wrapped_object_symbol),
         LOAD_INSTANCE_FIELD(NativeContext, MachineType::TaggedPointer()));
     // Invalid object wrappers (i.e. any other JS object that doesn't have the
@@ -6333,14 +6329,14 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     Node* target;
     if (mcgraph()->machine()->Is64()) {
       target = GetTargetForBuiltinCall(wasm::WasmCode::kI64ToBigInt,
-                                       Builtins::kI64ToBigInt);
+                                       Builtin::kI64ToBigInt);
     } else {
       DCHECK(mcgraph()->machine()->Is32());
       // On 32-bit platforms we already set the target to the
       // I32PairToBigInt builtin here, so that we don't have to replace the
       // target in the int64-lowering.
       target = GetTargetForBuiltinCall(wasm::WasmCode::kI32PairToBigInt,
-                                       Builtins::kI32PairToBigInt);
+                                       Builtin::kI32PairToBigInt);
     }
     return gasm_->Call(GetI64ToBigIntCallDescriptor(), target, input);
   }
@@ -6350,14 +6346,14 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     Node* target;
     if (mcgraph()->machine()->Is64()) {
       target = GetTargetForBuiltinCall(wasm::WasmCode::kBigIntToI64,
-                                       Builtins::kBigIntToI64);
+                                       Builtin::kBigIntToI64);
     } else {
       DCHECK(mcgraph()->machine()->Is32());
       // On 32-bit platforms we already set the target to the
       // BigIntToI32Pair builtin here, so that we don't have to replace the
       // target in the int64-lowering.
       target = GetTargetForBuiltinCall(wasm::WasmCode::kBigIntToI32Pair,
-                                       Builtins::kBigIntToI32Pair);
+                                       Builtin::kBigIntToI32Pair);
     }
 
     return frame_state ? gasm_->Call(GetBigIntToI64CallDescriptor(true), target,
@@ -6577,7 +6573,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
                                                Node* iterable, Node* context) {
     Node* length = BuildChangeUint31ToSmi(
         mcgraph()->Uint32Constant(static_cast<uint32_t>(sig->return_count())));
-    return gasm_->CallBuiltin(Builtins::kIterableToFixedArrayForWasm,
+    return gasm_->CallBuiltin(Builtin::kIterableToFixedArrayForWasm,
                               Operator::kEliminatable, iterable, length,
                               context);
   }
@@ -6588,7 +6584,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     // we make sure this is true based on statically known limits.
     STATIC_ASSERT(wasm::kV8MaxWasmFunctionReturns <=
                   JSArray::kInitialMaxFastElementArray);
-    return gasm_->CallBuiltin(Builtins::kWasmAllocateJSArray,
+    return gasm_->CallBuiltin(Builtin::kWasmAllocateJSArray,
                               Operator::kEliminatable, array_length, context);
   }
 
@@ -6933,7 +6929,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
         base::SmallVector<Node*, 16> args(wasm_count + 7);
         int pos = 0;
         args[pos++] =
-            gasm_->GetBuiltinPointerTarget(Builtins::kCall_ReceiverIsAny);
+            gasm_->GetBuiltinPointerTarget(Builtin::kCall_ReceiverIsAny);
         args[pos++] = callable_node;
         args[pos++] = Int32Constant(wasm_count);             // argument count
         args[pos++] = undefined_node;                        // receiver
@@ -7114,7 +7110,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     // Call the underlying closure.
     base::SmallVector<Node*, 16> args(wasm_count + 7);
     int pos = 0;
-    args[pos++] = gasm_->GetBuiltinPointerTarget(Builtins::kCall_ReceiverIsAny);
+    args[pos++] = gasm_->GetBuiltinPointerTarget(Builtin::kCall_ReceiverIsAny);
     args[pos++] = callable;
     args[pos++] = Int32Constant(wasm_count);  // argument count
     args[pos++] = UndefinedValue();           // receiver
@@ -7368,11 +7364,11 @@ std::pair<WasmImportCallKind, Handle<JSReceiver>> ResolveWasmImportCall(
     }                                                                     \
   }
 #define COMPARE_SIG_FOR_BUILTIN_F64(name) \
-  case Builtins::kMath##name:             \
+  case Builtin::kMath##name:              \
     COMPARE_SIG_FOR_BUILTIN(F64##name);   \
     break;
 #define COMPARE_SIG_FOR_BUILTIN_F32_F64(name) \
-  case Builtins::kMath##name:                 \
+  case Builtin::kMath##name:                  \
     COMPARE_SIG_FOR_BUILTIN(F64##name);       \
     COMPARE_SIG_FOR_BUILTIN(F32##name);       \
     break;
@@ -7395,7 +7391,7 @@ std::pair<WasmImportCallKind, Handle<JSReceiver>> ResolveWasmImportCall(
         COMPARE_SIG_FOR_BUILTIN_F32_F64(Ceil);
         COMPARE_SIG_FOR_BUILTIN_F32_F64(Floor);
         COMPARE_SIG_FOR_BUILTIN_F32_F64(Sqrt);
-        case Builtins::kMathFround:
+        case Builtin::kMathFround:
           COMPARE_SIG_FOR_BUILTIN(F32ConvertF64);
           break;
         default:
diff --git a/src/debug/debug-evaluate.cc b/src/debug/debug-evaluate.cc
index 9b25a2c523a..0472caf71da 100644
--- a/src/debug/debug-evaluate.cc
+++ b/src/debug/debug-evaluate.cc
@@ -530,359 +530,359 @@ bool BytecodeHasNoSideEffect(interpreter::Bytecode bytecode) {
   }
 }
 
-DebugInfo::SideEffectState BuiltinGetSideEffectState(Builtins::Name id) {
+DebugInfo::SideEffectState BuiltinGetSideEffectState(Builtin id) {
   switch (id) {
     // Allowlist for builtins.
     // Object builtins.
-    case Builtins::kObjectConstructor:
-    case Builtins::kObjectCreate:
-    case Builtins::kObjectEntries:
-    case Builtins::kObjectGetOwnPropertyDescriptor:
-    case Builtins::kObjectGetOwnPropertyDescriptors:
-    case Builtins::kObjectGetOwnPropertyNames:
-    case Builtins::kObjectGetOwnPropertySymbols:
-    case Builtins::kObjectGetPrototypeOf:
-    case Builtins::kObjectHasOwn:
-    case Builtins::kObjectIs:
-    case Builtins::kObjectIsExtensible:
-    case Builtins::kObjectIsFrozen:
-    case Builtins::kObjectIsSealed:
-    case Builtins::kObjectKeys:
-    case Builtins::kObjectPrototypeValueOf:
-    case Builtins::kObjectValues:
-    case Builtins::kObjectPrototypeHasOwnProperty:
-    case Builtins::kObjectPrototypeIsPrototypeOf:
-    case Builtins::kObjectPrototypePropertyIsEnumerable:
-    case Builtins::kObjectPrototypeToString:
-    case Builtins::kObjectPrototypeToLocaleString:
+    case Builtin::kObjectConstructor:
+    case Builtin::kObjectCreate:
+    case Builtin::kObjectEntries:
+    case Builtin::kObjectGetOwnPropertyDescriptor:
+    case Builtin::kObjectGetOwnPropertyDescriptors:
+    case Builtin::kObjectGetOwnPropertyNames:
+    case Builtin::kObjectGetOwnPropertySymbols:
+    case Builtin::kObjectGetPrototypeOf:
+    case Builtin::kObjectHasOwn:
+    case Builtin::kObjectIs:
+    case Builtin::kObjectIsExtensible:
+    case Builtin::kObjectIsFrozen:
+    case Builtin::kObjectIsSealed:
+    case Builtin::kObjectKeys:
+    case Builtin::kObjectPrototypeValueOf:
+    case Builtin::kObjectValues:
+    case Builtin::kObjectPrototypeHasOwnProperty:
+    case Builtin::kObjectPrototypeIsPrototypeOf:
+    case Builtin::kObjectPrototypePropertyIsEnumerable:
+    case Builtin::kObjectPrototypeToString:
+    case Builtin::kObjectPrototypeToLocaleString:
     // Array builtins.
-    case Builtins::kArrayIsArray:
-    case Builtins::kArrayConstructor:
-    case Builtins::kArrayIndexOf:
-    case Builtins::kArrayPrototypeValues:
-    case Builtins::kArrayIncludes:
-    case Builtins::kArrayPrototypeAt:
-    case Builtins::kArrayPrototypeEntries:
-    case Builtins::kArrayPrototypeFill:
-    case Builtins::kArrayPrototypeFind:
-    case Builtins::kArrayPrototypeFindIndex:
-    case Builtins::kArrayPrototypeFlat:
-    case Builtins::kArrayPrototypeFlatMap:
-    case Builtins::kArrayPrototypeJoin:
-    case Builtins::kArrayPrototypeKeys:
-    case Builtins::kArrayPrototypeLastIndexOf:
-    case Builtins::kArrayPrototypeSlice:
-    case Builtins::kArrayPrototypeToLocaleString:
-    case Builtins::kArrayPrototypeToString:
-    case Builtins::kArrayForEach:
-    case Builtins::kArrayEvery:
-    case Builtins::kArraySome:
-    case Builtins::kArrayConcat:
-    case Builtins::kArrayFilter:
-    case Builtins::kArrayMap:
-    case Builtins::kArrayReduce:
-    case Builtins::kArrayReduceRight:
+    case Builtin::kArrayIsArray:
+    case Builtin::kArrayConstructor:
+    case Builtin::kArrayIndexOf:
+    case Builtin::kArrayPrototypeValues:
+    case Builtin::kArrayIncludes:
+    case Builtin::kArrayPrototypeAt:
+    case Builtin::kArrayPrototypeEntries:
+    case Builtin::kArrayPrototypeFill:
+    case Builtin::kArrayPrototypeFind:
+    case Builtin::kArrayPrototypeFindIndex:
+    case Builtin::kArrayPrototypeFlat:
+    case Builtin::kArrayPrototypeFlatMap:
+    case Builtin::kArrayPrototypeJoin:
+    case Builtin::kArrayPrototypeKeys:
+    case Builtin::kArrayPrototypeLastIndexOf:
+    case Builtin::kArrayPrototypeSlice:
+    case Builtin::kArrayPrototypeToLocaleString:
+    case Builtin::kArrayPrototypeToString:
+    case Builtin::kArrayForEach:
+    case Builtin::kArrayEvery:
+    case Builtin::kArraySome:
+    case Builtin::kArrayConcat:
+    case Builtin::kArrayFilter:
+    case Builtin::kArrayMap:
+    case Builtin::kArrayReduce:
+    case Builtin::kArrayReduceRight:
     // Trace builtins.
-    case Builtins::kIsTraceCategoryEnabled:
-    case Builtins::kTrace:
+    case Builtin::kIsTraceCategoryEnabled:
+    case Builtin::kTrace:
     // TypedArray builtins.
-    case Builtins::kTypedArrayConstructor:
-    case Builtins::kTypedArrayOf:
-    case Builtins::kTypedArrayPrototypeAt:
-    case Builtins::kTypedArrayPrototypeBuffer:
-    case Builtins::kTypedArrayPrototypeByteLength:
-    case Builtins::kTypedArrayPrototypeByteOffset:
-    case Builtins::kTypedArrayPrototypeLength:
-    case Builtins::kTypedArrayPrototypeEntries:
-    case Builtins::kTypedArrayPrototypeKeys:
-    case Builtins::kTypedArrayPrototypeValues:
-    case Builtins::kTypedArrayPrototypeFind:
-    case Builtins::kTypedArrayPrototypeFindIndex:
-    case Builtins::kTypedArrayPrototypeIncludes:
-    case Builtins::kTypedArrayPrototypeJoin:
-    case Builtins::kTypedArrayPrototypeIndexOf:
-    case Builtins::kTypedArrayPrototypeLastIndexOf:
-    case Builtins::kTypedArrayPrototypeSlice:
-    case Builtins::kTypedArrayPrototypeSubArray:
-    case Builtins::kTypedArrayPrototypeEvery:
-    case Builtins::kTypedArrayPrototypeSome:
-    case Builtins::kTypedArrayPrototypeToLocaleString:
-    case Builtins::kTypedArrayPrototypeFilter:
-    case Builtins::kTypedArrayPrototypeMap:
-    case Builtins::kTypedArrayPrototypeReduce:
-    case Builtins::kTypedArrayPrototypeReduceRight:
-    case Builtins::kTypedArrayPrototypeForEach:
+    case Builtin::kTypedArrayConstructor:
+    case Builtin::kTypedArrayOf:
+    case Builtin::kTypedArrayPrototypeAt:
+    case Builtin::kTypedArrayPrototypeBuffer:
+    case Builtin::kTypedArrayPrototypeByteLength:
+    case Builtin::kTypedArrayPrototypeByteOffset:
+    case Builtin::kTypedArrayPrototypeLength:
+    case Builtin::kTypedArrayPrototypeEntries:
+    case Builtin::kTypedArrayPrototypeKeys:
+    case Builtin::kTypedArrayPrototypeValues:
+    case Builtin::kTypedArrayPrototypeFind:
+    case Builtin::kTypedArrayPrototypeFindIndex:
+    case Builtin::kTypedArrayPrototypeIncludes:
+    case Builtin::kTypedArrayPrototypeJoin:
+    case Builtin::kTypedArrayPrototypeIndexOf:
+    case Builtin::kTypedArrayPrototypeLastIndexOf:
+    case Builtin::kTypedArrayPrototypeSlice:
+    case Builtin::kTypedArrayPrototypeSubArray:
+    case Builtin::kTypedArrayPrototypeEvery:
+    case Builtin::kTypedArrayPrototypeSome:
+    case Builtin::kTypedArrayPrototypeToLocaleString:
+    case Builtin::kTypedArrayPrototypeFilter:
+    case Builtin::kTypedArrayPrototypeMap:
+    case Builtin::kTypedArrayPrototypeReduce:
+    case Builtin::kTypedArrayPrototypeReduceRight:
+    case Builtin::kTypedArrayPrototypeForEach:
     // ArrayBuffer builtins.
-    case Builtins::kArrayBufferConstructor:
-    case Builtins::kArrayBufferPrototypeGetByteLength:
-    case Builtins::kArrayBufferIsView:
-    case Builtins::kArrayBufferPrototypeSlice:
-    case Builtins::kReturnReceiver:
+    case Builtin::kArrayBufferConstructor:
+    case Builtin::kArrayBufferPrototypeGetByteLength:
+    case Builtin::kArrayBufferIsView:
+    case Builtin::kArrayBufferPrototypeSlice:
+    case Builtin::kReturnReceiver:
     // DataView builtins.
-    case Builtins::kDataViewConstructor:
-    case Builtins::kDataViewPrototypeGetBuffer:
-    case Builtins::kDataViewPrototypeGetByteLength:
-    case Builtins::kDataViewPrototypeGetByteOffset:
-    case Builtins::kDataViewPrototypeGetInt8:
-    case Builtins::kDataViewPrototypeGetUint8:
-    case Builtins::kDataViewPrototypeGetInt16:
-    case Builtins::kDataViewPrototypeGetUint16:
-    case Builtins::kDataViewPrototypeGetInt32:
-    case Builtins::kDataViewPrototypeGetUint32:
-    case Builtins::kDataViewPrototypeGetFloat32:
-    case Builtins::kDataViewPrototypeGetFloat64:
-    case Builtins::kDataViewPrototypeGetBigInt64:
-    case Builtins::kDataViewPrototypeGetBigUint64:
+    case Builtin::kDataViewConstructor:
+    case Builtin::kDataViewPrototypeGetBuffer:
+    case Builtin::kDataViewPrototypeGetByteLength:
+    case Builtin::kDataViewPrototypeGetByteOffset:
+    case Builtin::kDataViewPrototypeGetInt8:
+    case Builtin::kDataViewPrototypeGetUint8:
+    case Builtin::kDataViewPrototypeGetInt16:
+    case Builtin::kDataViewPrototypeGetUint16:
+    case Builtin::kDataViewPrototypeGetInt32:
+    case Builtin::kDataViewPrototypeGetUint32:
+    case Builtin::kDataViewPrototypeGetFloat32:
+    case Builtin::kDataViewPrototypeGetFloat64:
+    case Builtin::kDataViewPrototypeGetBigInt64:
+    case Builtin::kDataViewPrototypeGetBigUint64:
     // Boolean bulitins.
-    case Builtins::kBooleanConstructor:
-    case Builtins::kBooleanPrototypeToString:
-    case Builtins::kBooleanPrototypeValueOf:
+    case Builtin::kBooleanConstructor:
+    case Builtin::kBooleanPrototypeToString:
+    case Builtin::kBooleanPrototypeValueOf:
     // Date builtins.
-    case Builtins::kDateConstructor:
-    case Builtins::kDateNow:
-    case Builtins::kDateParse:
-    case Builtins::kDatePrototypeGetDate:
-    case Builtins::kDatePrototypeGetDay:
-    case Builtins::kDatePrototypeGetFullYear:
-    case Builtins::kDatePrototypeGetHours:
-    case Builtins::kDatePrototypeGetMilliseconds:
-    case Builtins::kDatePrototypeGetMinutes:
-    case Builtins::kDatePrototypeGetMonth:
-    case Builtins::kDatePrototypeGetSeconds:
-    case Builtins::kDatePrototypeGetTime:
-    case Builtins::kDatePrototypeGetTimezoneOffset:
-    case Builtins::kDatePrototypeGetUTCDate:
-    case Builtins::kDatePrototypeGetUTCDay:
-    case Builtins::kDatePrototypeGetUTCFullYear:
-    case Builtins::kDatePrototypeGetUTCHours:
-    case Builtins::kDatePrototypeGetUTCMilliseconds:
-    case Builtins::kDatePrototypeGetUTCMinutes:
-    case Builtins::kDatePrototypeGetUTCMonth:
-    case Builtins::kDatePrototypeGetUTCSeconds:
-    case Builtins::kDatePrototypeGetYear:
-    case Builtins::kDatePrototypeToDateString:
-    case Builtins::kDatePrototypeToISOString:
-    case Builtins::kDatePrototypeToUTCString:
-    case Builtins::kDatePrototypeToString:
+    case Builtin::kDateConstructor:
+    case Builtin::kDateNow:
+    case Builtin::kDateParse:
+    case Builtin::kDatePrototypeGetDate:
+    case Builtin::kDatePrototypeGetDay:
+    case Builtin::kDatePrototypeGetFullYear:
+    case Builtin::kDatePrototypeGetHours:
+    case Builtin::kDatePrototypeGetMilliseconds:
+    case Builtin::kDatePrototypeGetMinutes:
+    case Builtin::kDatePrototypeGetMonth:
+    case Builtin::kDatePrototypeGetSeconds:
+    case Builtin::kDatePrototypeGetTime:
+    case Builtin::kDatePrototypeGetTimezoneOffset:
+    case Builtin::kDatePrototypeGetUTCDate:
+    case Builtin::kDatePrototypeGetUTCDay:
+    case Builtin::kDatePrototypeGetUTCFullYear:
+    case Builtin::kDatePrototypeGetUTCHours:
+    case Builtin::kDatePrototypeGetUTCMilliseconds:
+    case Builtin::kDatePrototypeGetUTCMinutes:
+    case Builtin::kDatePrototypeGetUTCMonth:
+    case Builtin::kDatePrototypeGetUTCSeconds:
+    case Builtin::kDatePrototypeGetYear:
+    case Builtin::kDatePrototypeToDateString:
+    case Builtin::kDatePrototypeToISOString:
+    case Builtin::kDatePrototypeToUTCString:
+    case Builtin::kDatePrototypeToString:
 #ifdef V8_INTL_SUPPORT
-    case Builtins::kDatePrototypeToLocaleString:
-    case Builtins::kDatePrototypeToLocaleDateString:
-    case Builtins::kDatePrototypeToLocaleTimeString:
+    case Builtin::kDatePrototypeToLocaleString:
+    case Builtin::kDatePrototypeToLocaleDateString:
+    case Builtin::kDatePrototypeToLocaleTimeString:
 #endif
-    case Builtins::kDatePrototypeToTimeString:
-    case Builtins::kDatePrototypeToJson:
-    case Builtins::kDatePrototypeToPrimitive:
-    case Builtins::kDatePrototypeValueOf:
+    case Builtin::kDatePrototypeToTimeString:
+    case Builtin::kDatePrototypeToJson:
+    case Builtin::kDatePrototypeToPrimitive:
+    case Builtin::kDatePrototypeValueOf:
     // Map builtins.
-    case Builtins::kMapConstructor:
-    case Builtins::kMapPrototypeForEach:
-    case Builtins::kMapPrototypeGet:
-    case Builtins::kMapPrototypeHas:
-    case Builtins::kMapPrototypeEntries:
-    case Builtins::kMapPrototypeGetSize:
-    case Builtins::kMapPrototypeKeys:
-    case Builtins::kMapPrototypeValues:
+    case Builtin::kMapConstructor:
+    case Builtin::kMapPrototypeForEach:
+    case Builtin::kMapPrototypeGet:
+    case Builtin::kMapPrototypeHas:
+    case Builtin::kMapPrototypeEntries:
+    case Builtin::kMapPrototypeGetSize:
+    case Builtin::kMapPrototypeKeys:
+    case Builtin::kMapPrototypeValues:
     // WeakMap builtins.
-    case Builtins::kWeakMapConstructor:
-    case Builtins::kWeakMapGet:
-    case Builtins::kWeakMapPrototypeHas:
+    case Builtin::kWeakMapConstructor:
+    case Builtin::kWeakMapGet:
+    case Builtin::kWeakMapPrototypeHas:
     // Math builtins.
-    case Builtins::kMathAbs:
-    case Builtins::kMathAcos:
-    case Builtins::kMathAcosh:
-    case Builtins::kMathAsin:
-    case Builtins::kMathAsinh:
-    case Builtins::kMathAtan:
-    case Builtins::kMathAtanh:
-    case Builtins::kMathAtan2:
-    case Builtins::kMathCeil:
-    case Builtins::kMathCbrt:
-    case Builtins::kMathExpm1:
-    case Builtins::kMathClz32:
-    case Builtins::kMathCos:
-    case Builtins::kMathCosh:
-    case Builtins::kMathExp:
-    case Builtins::kMathFloor:
-    case Builtins::kMathFround:
-    case Builtins::kMathHypot:
-    case Builtins::kMathImul:
-    case Builtins::kMathLog:
-    case Builtins::kMathLog1p:
-    case Builtins::kMathLog2:
-    case Builtins::kMathLog10:
-    case Builtins::kMathMax:
-    case Builtins::kMathMin:
-    case Builtins::kMathPow:
-    case Builtins::kMathRound:
-    case Builtins::kMathSign:
-    case Builtins::kMathSin:
-    case Builtins::kMathSinh:
-    case Builtins::kMathSqrt:
-    case Builtins::kMathTan:
-    case Builtins::kMathTanh:
-    case Builtins::kMathTrunc:
+    case Builtin::kMathAbs:
+    case Builtin::kMathAcos:
+    case Builtin::kMathAcosh:
+    case Builtin::kMathAsin:
+    case Builtin::kMathAsinh:
+    case Builtin::kMathAtan:
+    case Builtin::kMathAtanh:
+    case Builtin::kMathAtan2:
+    case Builtin::kMathCeil:
+    case Builtin::kMathCbrt:
+    case Builtin::kMathExpm1:
+    case Builtin::kMathClz32:
+    case Builtin::kMathCos:
+    case Builtin::kMathCosh:
+    case Builtin::kMathExp:
+    case Builtin::kMathFloor:
+    case Builtin::kMathFround:
+    case Builtin::kMathHypot:
+    case Builtin::kMathImul:
+    case Builtin::kMathLog:
+    case Builtin::kMathLog1p:
+    case Builtin::kMathLog2:
+    case Builtin::kMathLog10:
+    case Builtin::kMathMax:
+    case Builtin::kMathMin:
+    case Builtin::kMathPow:
+    case Builtin::kMathRound:
+    case Builtin::kMathSign:
+    case Builtin::kMathSin:
+    case Builtin::kMathSinh:
+    case Builtin::kMathSqrt:
+    case Builtin::kMathTan:
+    case Builtin::kMathTanh:
+    case Builtin::kMathTrunc:
     // Number builtins.
-    case Builtins::kNumberConstructor:
-    case Builtins::kNumberIsFinite:
-    case Builtins::kNumberIsInteger:
-    case Builtins::kNumberIsNaN:
-    case Builtins::kNumberIsSafeInteger:
-    case Builtins::kNumberParseFloat:
-    case Builtins::kNumberParseInt:
-    case Builtins::kNumberPrototypeToExponential:
-    case Builtins::kNumberPrototypeToFixed:
-    case Builtins::kNumberPrototypeToPrecision:
-    case Builtins::kNumberPrototypeToString:
-    case Builtins::kNumberPrototypeToLocaleString:
-    case Builtins::kNumberPrototypeValueOf:
+    case Builtin::kNumberConstructor:
+    case Builtin::kNumberIsFinite:
+    case Builtin::kNumberIsInteger:
+    case Builtin::kNumberIsNaN:
+    case Builtin::kNumberIsSafeInteger:
+    case Builtin::kNumberParseFloat:
+    case Builtin::kNumberParseInt:
+    case Builtin::kNumberPrototypeToExponential:
+    case Builtin::kNumberPrototypeToFixed:
+    case Builtin::kNumberPrototypeToPrecision:
+    case Builtin::kNumberPrototypeToString:
+    case Builtin::kNumberPrototypeToLocaleString:
+    case Builtin::kNumberPrototypeValueOf:
     // BigInt builtins.
-    case Builtins::kBigIntConstructor:
-    case Builtins::kBigIntAsIntN:
-    case Builtins::kBigIntAsUintN:
-    case Builtins::kBigIntPrototypeToString:
-    case Builtins::kBigIntPrototypeValueOf:
+    case Builtin::kBigIntConstructor:
+    case Builtin::kBigIntAsIntN:
+    case Builtin::kBigIntAsUintN:
+    case Builtin::kBigIntPrototypeToString:
+    case Builtin::kBigIntPrototypeValueOf:
     // Set builtins.
-    case Builtins::kSetConstructor:
-    case Builtins::kSetPrototypeEntries:
-    case Builtins::kSetPrototypeForEach:
-    case Builtins::kSetPrototypeGetSize:
-    case Builtins::kSetPrototypeHas:
-    case Builtins::kSetPrototypeValues:
+    case Builtin::kSetConstructor:
+    case Builtin::kSetPrototypeEntries:
+    case Builtin::kSetPrototypeForEach:
+    case Builtin::kSetPrototypeGetSize:
+    case Builtin::kSetPrototypeHas:
+    case Builtin::kSetPrototypeValues:
     // WeakSet builtins.
-    case Builtins::kWeakSetConstructor:
-    case Builtins::kWeakSetPrototypeHas:
+    case Builtin::kWeakSetConstructor:
+    case Builtin::kWeakSetPrototypeHas:
     // String builtins. Strings are immutable.
-    case Builtins::kStringFromCharCode:
-    case Builtins::kStringFromCodePoint:
-    case Builtins::kStringConstructor:
-    case Builtins::kStringPrototypeAnchor:
-    case Builtins::kStringPrototypeAt:
-    case Builtins::kStringPrototypeBig:
-    case Builtins::kStringPrototypeBlink:
-    case Builtins::kStringPrototypeBold:
-    case Builtins::kStringPrototypeCharAt:
-    case Builtins::kStringPrototypeCharCodeAt:
-    case Builtins::kStringPrototypeCodePointAt:
-    case Builtins::kStringPrototypeConcat:
-    case Builtins::kStringPrototypeEndsWith:
-    case Builtins::kStringPrototypeFixed:
-    case Builtins::kStringPrototypeFontcolor:
-    case Builtins::kStringPrototypeFontsize:
-    case Builtins::kStringPrototypeIncludes:
-    case Builtins::kStringPrototypeIndexOf:
-    case Builtins::kStringPrototypeItalics:
-    case Builtins::kStringPrototypeLastIndexOf:
-    case Builtins::kStringPrototypeLink:
-    case Builtins::kStringPrototypeMatchAll:
-    case Builtins::kStringPrototypePadEnd:
-    case Builtins::kStringPrototypePadStart:
-    case Builtins::kStringPrototypeRepeat:
-    case Builtins::kStringPrototypeSlice:
-    case Builtins::kStringPrototypeSmall:
-    case Builtins::kStringPrototypeStartsWith:
-    case Builtins::kStringSlowFlatten:
-    case Builtins::kStringPrototypeStrike:
-    case Builtins::kStringPrototypeSub:
-    case Builtins::kStringPrototypeSubstr:
-    case Builtins::kStringPrototypeSubstring:
-    case Builtins::kStringPrototypeSup:
-    case Builtins::kStringPrototypeToString:
+    case Builtin::kStringFromCharCode:
+    case Builtin::kStringFromCodePoint:
+    case Builtin::kStringConstructor:
+    case Builtin::kStringPrototypeAnchor:
+    case Builtin::kStringPrototypeAt:
+    case Builtin::kStringPrototypeBig:
+    case Builtin::kStringPrototypeBlink:
+    case Builtin::kStringPrototypeBold:
+    case Builtin::kStringPrototypeCharAt:
+    case Builtin::kStringPrototypeCharCodeAt:
+    case Builtin::kStringPrototypeCodePointAt:
+    case Builtin::kStringPrototypeConcat:
+    case Builtin::kStringPrototypeEndsWith:
+    case Builtin::kStringPrototypeFixed:
+    case Builtin::kStringPrototypeFontcolor:
+    case Builtin::kStringPrototypeFontsize:
+    case Builtin::kStringPrototypeIncludes:
+    case Builtin::kStringPrototypeIndexOf:
+    case Builtin::kStringPrototypeItalics:
+    case Builtin::kStringPrototypeLastIndexOf:
+    case Builtin::kStringPrototypeLink:
+    case Builtin::kStringPrototypeMatchAll:
+    case Builtin::kStringPrototypePadEnd:
+    case Builtin::kStringPrototypePadStart:
+    case Builtin::kStringPrototypeRepeat:
+    case Builtin::kStringPrototypeSlice:
+    case Builtin::kStringPrototypeSmall:
+    case Builtin::kStringPrototypeStartsWith:
+    case Builtin::kStringSlowFlatten:
+    case Builtin::kStringPrototypeStrike:
+    case Builtin::kStringPrototypeSub:
+    case Builtin::kStringPrototypeSubstr:
+    case Builtin::kStringPrototypeSubstring:
+    case Builtin::kStringPrototypeSup:
+    case Builtin::kStringPrototypeToString:
 #ifndef V8_INTL_SUPPORT
-    case Builtins::kStringPrototypeToLowerCase:
-    case Builtins::kStringPrototypeToUpperCase:
+    case Builtin::kStringPrototypeToLowerCase:
+    case Builtin::kStringPrototypeToUpperCase:
 #endif
-    case Builtins::kStringPrototypeTrim:
-    case Builtins::kStringPrototypeTrimEnd:
-    case Builtins::kStringPrototypeTrimStart:
-    case Builtins::kStringPrototypeValueOf:
-    case Builtins::kStringToNumber:
-    case Builtins::kStringSubstring:
+    case Builtin::kStringPrototypeTrim:
+    case Builtin::kStringPrototypeTrimEnd:
+    case Builtin::kStringPrototypeTrimStart:
+    case Builtin::kStringPrototypeValueOf:
+    case Builtin::kStringToNumber:
+    case Builtin::kStringSubstring:
     // Symbol builtins.
-    case Builtins::kSymbolConstructor:
-    case Builtins::kSymbolKeyFor:
-    case Builtins::kSymbolPrototypeToString:
-    case Builtins::kSymbolPrototypeValueOf:
-    case Builtins::kSymbolPrototypeToPrimitive:
+    case Builtin::kSymbolConstructor:
+    case Builtin::kSymbolKeyFor:
+    case Builtin::kSymbolPrototypeToString:
+    case Builtin::kSymbolPrototypeValueOf:
+    case Builtin::kSymbolPrototypeToPrimitive:
     // JSON builtins.
-    case Builtins::kJsonParse:
-    case Builtins::kJsonStringify:
+    case Builtin::kJsonParse:
+    case Builtin::kJsonStringify:
     // Global function builtins.
-    case Builtins::kGlobalDecodeURI:
-    case Builtins::kGlobalDecodeURIComponent:
-    case Builtins::kGlobalEncodeURI:
-    case Builtins::kGlobalEncodeURIComponent:
-    case Builtins::kGlobalEscape:
-    case Builtins::kGlobalUnescape:
-    case Builtins::kGlobalIsFinite:
-    case Builtins::kGlobalIsNaN:
+    case Builtin::kGlobalDecodeURI:
+    case Builtin::kGlobalDecodeURIComponent:
+    case Builtin::kGlobalEncodeURI:
+    case Builtin::kGlobalEncodeURIComponent:
+    case Builtin::kGlobalEscape:
+    case Builtin::kGlobalUnescape:
+    case Builtin::kGlobalIsFinite:
+    case Builtin::kGlobalIsNaN:
     // Function builtins.
-    case Builtins::kFunctionPrototypeToString:
-    case Builtins::kFunctionPrototypeBind:
-    case Builtins::kFastFunctionPrototypeBind:
-    case Builtins::kFunctionPrototypeCall:
-    case Builtins::kFunctionPrototypeApply:
+    case Builtin::kFunctionPrototypeToString:
+    case Builtin::kFunctionPrototypeBind:
+    case Builtin::kFastFunctionPrototypeBind:
+    case Builtin::kFunctionPrototypeCall:
+    case Builtin::kFunctionPrototypeApply:
     // Error builtins.
-    case Builtins::kErrorConstructor:
+    case Builtin::kErrorConstructor:
     // RegExp builtins.
-    case Builtins::kRegExpConstructor:
+    case Builtin::kRegExpConstructor:
     // Internal.
-    case Builtins::kStrictPoisonPillThrower:
-    case Builtins::kAllocateInYoungGeneration:
-    case Builtins::kAllocateInOldGeneration:
-    case Builtins::kAllocateRegularInYoungGeneration:
-    case Builtins::kAllocateRegularInOldGeneration:
+    case Builtin::kStrictPoisonPillThrower:
+    case Builtin::kAllocateInYoungGeneration:
+    case Builtin::kAllocateInOldGeneration:
+    case Builtin::kAllocateRegularInYoungGeneration:
+    case Builtin::kAllocateRegularInOldGeneration:
       return DebugInfo::kHasNoSideEffect;
 
     // Set builtins.
-    case Builtins::kSetIteratorPrototypeNext:
-    case Builtins::kSetPrototypeAdd:
-    case Builtins::kSetPrototypeClear:
-    case Builtins::kSetPrototypeDelete:
+    case Builtin::kSetIteratorPrototypeNext:
+    case Builtin::kSetPrototypeAdd:
+    case Builtin::kSetPrototypeClear:
+    case Builtin::kSetPrototypeDelete:
     // Array builtins.
-    case Builtins::kArrayIteratorPrototypeNext:
-    case Builtins::kArrayPrototypePop:
-    case Builtins::kArrayPrototypePush:
-    case Builtins::kArrayPrototypeReverse:
-    case Builtins::kArrayPrototypeShift:
-    case Builtins::kArrayPrototypeUnshift:
-    case Builtins::kArrayPrototypeSort:
-    case Builtins::kArrayPrototypeSplice:
-    case Builtins::kArrayUnshift:
+    case Builtin::kArrayIteratorPrototypeNext:
+    case Builtin::kArrayPrototypePop:
+    case Builtin::kArrayPrototypePush:
+    case Builtin::kArrayPrototypeReverse:
+    case Builtin::kArrayPrototypeShift:
+    case Builtin::kArrayPrototypeUnshift:
+    case Builtin::kArrayPrototypeSort:
+    case Builtin::kArrayPrototypeSplice:
+    case Builtin::kArrayUnshift:
     // Map builtins.
-    case Builtins::kMapIteratorPrototypeNext:
-    case Builtins::kMapPrototypeClear:
-    case Builtins::kMapPrototypeDelete:
-    case Builtins::kMapPrototypeSet:
+    case Builtin::kMapIteratorPrototypeNext:
+    case Builtin::kMapPrototypeClear:
+    case Builtin::kMapPrototypeDelete:
+    case Builtin::kMapPrototypeSet:
     // Date builtins.
-    case Builtins::kDatePrototypeSetDate:
-    case Builtins::kDatePrototypeSetFullYear:
-    case Builtins::kDatePrototypeSetHours:
-    case Builtins::kDatePrototypeSetMilliseconds:
-    case Builtins::kDatePrototypeSetMinutes:
-    case Builtins::kDatePrototypeSetMonth:
-    case Builtins::kDatePrototypeSetSeconds:
-    case Builtins::kDatePrototypeSetTime:
-    case Builtins::kDatePrototypeSetUTCDate:
-    case Builtins::kDatePrototypeSetUTCFullYear:
-    case Builtins::kDatePrototypeSetUTCHours:
-    case Builtins::kDatePrototypeSetUTCMilliseconds:
-    case Builtins::kDatePrototypeSetUTCMinutes:
-    case Builtins::kDatePrototypeSetUTCMonth:
-    case Builtins::kDatePrototypeSetUTCSeconds:
-    case Builtins::kDatePrototypeSetYear:
+    case Builtin::kDatePrototypeSetDate:
+    case Builtin::kDatePrototypeSetFullYear:
+    case Builtin::kDatePrototypeSetHours:
+    case Builtin::kDatePrototypeSetMilliseconds:
+    case Builtin::kDatePrototypeSetMinutes:
+    case Builtin::kDatePrototypeSetMonth:
+    case Builtin::kDatePrototypeSetSeconds:
+    case Builtin::kDatePrototypeSetTime:
+    case Builtin::kDatePrototypeSetUTCDate:
+    case Builtin::kDatePrototypeSetUTCFullYear:
+    case Builtin::kDatePrototypeSetUTCHours:
+    case Builtin::kDatePrototypeSetUTCMilliseconds:
+    case Builtin::kDatePrototypeSetUTCMinutes:
+    case Builtin::kDatePrototypeSetUTCMonth:
+    case Builtin::kDatePrototypeSetUTCSeconds:
+    case Builtin::kDatePrototypeSetYear:
     // RegExp builtins.
-    case Builtins::kRegExpPrototypeTest:
-    case Builtins::kRegExpPrototypeExec:
-    case Builtins::kRegExpPrototypeSplit:
-    case Builtins::kRegExpPrototypeFlagsGetter:
-    case Builtins::kRegExpPrototypeGlobalGetter:
-    case Builtins::kRegExpPrototypeHasIndicesGetter:
-    case Builtins::kRegExpPrototypeIgnoreCaseGetter:
-    case Builtins::kRegExpPrototypeMatchAll:
-    case Builtins::kRegExpPrototypeMultilineGetter:
-    case Builtins::kRegExpPrototypeDotAllGetter:
-    case Builtins::kRegExpPrototypeUnicodeGetter:
-    case Builtins::kRegExpPrototypeStickyGetter:
+    case Builtin::kRegExpPrototypeTest:
+    case Builtin::kRegExpPrototypeExec:
+    case Builtin::kRegExpPrototypeSplit:
+    case Builtin::kRegExpPrototypeFlagsGetter:
+    case Builtin::kRegExpPrototypeGlobalGetter:
+    case Builtin::kRegExpPrototypeHasIndicesGetter:
+    case Builtin::kRegExpPrototypeIgnoreCaseGetter:
+    case Builtin::kRegExpPrototypeMatchAll:
+    case Builtin::kRegExpPrototypeMultilineGetter:
+    case Builtin::kRegExpPrototypeDotAllGetter:
+    case Builtin::kRegExpPrototypeUnicodeGetter:
+    case Builtin::kRegExpPrototypeStickyGetter:
       return DebugInfo::kRequiresRuntimeChecks;
     default:
       if (FLAG_trace_side_effect_free_debug_evaluate) {
@@ -959,18 +959,18 @@ DebugInfo::SideEffectState DebugEvaluate::FunctionGetSideEffectState(
                                    : DebugInfo::kHasNoSideEffect;
   } else if (info->IsApiFunction()) {
     if (info->GetCode().is_builtin()) {
-      return info->GetCode().builtin_index() == Builtins::kHandleApiCall
+      return info->GetCode().builtin_index() == Builtin::kHandleApiCall
                  ? DebugInfo::kHasNoSideEffect
                  : DebugInfo::kHasSideEffects;
     }
   } else {
     // Check built-ins against allowlist.
     int builtin_index =
-        info->HasBuiltinId() ? info->builtin_id() : Builtins::kNoBuiltinId;
+        info->HasBuiltinId() ? info->builtin_id() : Builtin::kNoBuiltinId;
     if (!Builtins::IsBuiltinId(builtin_index))
       return DebugInfo::kHasSideEffects;
     DebugInfo::SideEffectState state =
-        BuiltinGetSideEffectState(static_cast<Builtins::Name>(builtin_index));
+        BuiltinGetSideEffectState(static_cast<Builtin>(builtin_index));
     return state;
   }
 
@@ -978,114 +978,114 @@ DebugInfo::SideEffectState DebugEvaluate::FunctionGetSideEffectState(
 }
 
 #ifdef DEBUG
-static bool TransitivelyCalledBuiltinHasNoSideEffect(Builtins::Name caller,
-                                                     Builtins::Name callee) {
+static bool TransitivelyCalledBuiltinHasNoSideEffect(Builtin caller,
+                                                     Builtin callee) {
   switch (callee) {
       // Transitively called Builtins:
-    case Builtins::kAbort:
-    case Builtins::kAbortCSAAssert:
-    case Builtins::kAdaptorWithBuiltinExitFrame:
-    case Builtins::kArrayConstructorImpl:
-    case Builtins::kArrayEveryLoopContinuation:
-    case Builtins::kArrayFilterLoopContinuation:
-    case Builtins::kArrayFindIndexLoopContinuation:
-    case Builtins::kArrayFindLoopContinuation:
-    case Builtins::kArrayForEachLoopContinuation:
-    case Builtins::kArrayIncludesHoleyDoubles:
-    case Builtins::kArrayIncludesPackedDoubles:
-    case Builtins::kArrayIncludesSmiOrObject:
-    case Builtins::kArrayIndexOfHoleyDoubles:
-    case Builtins::kArrayIndexOfPackedDoubles:
-    case Builtins::kArrayIndexOfSmiOrObject:
-    case Builtins::kArrayMapLoopContinuation:
-    case Builtins::kArrayReduceLoopContinuation:
-    case Builtins::kArrayReduceRightLoopContinuation:
-    case Builtins::kArraySomeLoopContinuation:
-    case Builtins::kArrayTimSort:
-    case Builtins::kCall_ReceiverIsAny:
-    case Builtins::kCall_ReceiverIsNotNullOrUndefined:
-    case Builtins::kCall_ReceiverIsNullOrUndefined:
-    case Builtins::kCallWithArrayLike:
-    case Builtins::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
-    case Builtins::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit:
-    case Builtins::kCEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit:
-    case Builtins::kCEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit:
-    case Builtins::kCEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit:
-    case Builtins::kCEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
-    case Builtins::kCEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit:
-    case Builtins::kCEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit:
-    case Builtins::kCEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit:
-    case Builtins::kCEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit:
-    case Builtins::kCloneFastJSArray:
-    case Builtins::kConstruct:
-    case Builtins::kConvertToLocaleString:
-    case Builtins::kCreateTypedArray:
-    case Builtins::kDirectCEntry:
-    case Builtins::kDoubleToI:
-    case Builtins::kExtractFastJSArray:
-    case Builtins::kFastNewObject:
-    case Builtins::kFindOrderedHashMapEntry:
-    case Builtins::kFlatMapIntoArray:
-    case Builtins::kFlattenIntoArray:
-    case Builtins::kGetProperty:
-    case Builtins::kHasProperty:
-    case Builtins::kCreateHTML:
-    case Builtins::kNonNumberToNumber:
-    case Builtins::kNonPrimitiveToPrimitive_Number:
-    case Builtins::kNumberToString:
-    case Builtins::kObjectToString:
-    case Builtins::kOrderedHashTableHealIndex:
-    case Builtins::kOrdinaryToPrimitive_Number:
-    case Builtins::kOrdinaryToPrimitive_String:
-    case Builtins::kParseInt:
-    case Builtins::kProxyHasProperty:
-    case Builtins::kProxyIsExtensible:
-    case Builtins::kProxyGetPrototypeOf:
-    case Builtins::kRecordWriteEmitRememberedSetSaveFP:
-    case Builtins::kRecordWriteOmitRememberedSetSaveFP:
-    case Builtins::kRecordWriteEmitRememberedSetIgnoreFP:
-    case Builtins::kRecordWriteOmitRememberedSetIgnoreFP:
-    case Builtins::kStringAdd_CheckNone:
-    case Builtins::kStringEqual:
-    case Builtins::kStringIndexOf:
-    case Builtins::kStringRepeat:
-    case Builtins::kToInteger:
-    case Builtins::kToLength:
-    case Builtins::kToName:
-    case Builtins::kToObject:
-    case Builtins::kToString:
+    case Builtin::kAbort:
+    case Builtin::kAbortCSAAssert:
+    case Builtin::kAdaptorWithBuiltinExitFrame:
+    case Builtin::kArrayConstructorImpl:
+    case Builtin::kArrayEveryLoopContinuation:
+    case Builtin::kArrayFilterLoopContinuation:
+    case Builtin::kArrayFindIndexLoopContinuation:
+    case Builtin::kArrayFindLoopContinuation:
+    case Builtin::kArrayForEachLoopContinuation:
+    case Builtin::kArrayIncludesHoleyDoubles:
+    case Builtin::kArrayIncludesPackedDoubles:
+    case Builtin::kArrayIncludesSmiOrObject:
+    case Builtin::kArrayIndexOfHoleyDoubles:
+    case Builtin::kArrayIndexOfPackedDoubles:
+    case Builtin::kArrayIndexOfSmiOrObject:
+    case Builtin::kArrayMapLoopContinuation:
+    case Builtin::kArrayReduceLoopContinuation:
+    case Builtin::kArrayReduceRightLoopContinuation:
+    case Builtin::kArraySomeLoopContinuation:
+    case Builtin::kArrayTimSort:
+    case Builtin::kCall_ReceiverIsAny:
+    case Builtin::kCall_ReceiverIsNotNullOrUndefined:
+    case Builtin::kCall_ReceiverIsNullOrUndefined:
+    case Builtin::kCallWithArrayLike:
+    case Builtin::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
+    case Builtin::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit:
+    case Builtin::kCEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit:
+    case Builtin::kCEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit:
+    case Builtin::kCEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit:
+    case Builtin::kCEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
+    case Builtin::kCEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit:
+    case Builtin::kCEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit:
+    case Builtin::kCEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit:
+    case Builtin::kCEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit:
+    case Builtin::kCloneFastJSArray:
+    case Builtin::kConstruct:
+    case Builtin::kConvertToLocaleString:
+    case Builtin::kCreateTypedArray:
+    case Builtin::kDirectCEntry:
+    case Builtin::kDoubleToI:
+    case Builtin::kExtractFastJSArray:
+    case Builtin::kFastNewObject:
+    case Builtin::kFindOrderedHashMapEntry:
+    case Builtin::kFlatMapIntoArray:
+    case Builtin::kFlattenIntoArray:
+    case Builtin::kGetProperty:
+    case Builtin::kHasProperty:
+    case Builtin::kCreateHTML:
+    case Builtin::kNonNumberToNumber:
+    case Builtin::kNonPrimitiveToPrimitive_Number:
+    case Builtin::kNumberToString:
+    case Builtin::kObjectToString:
+    case Builtin::kOrderedHashTableHealIndex:
+    case Builtin::kOrdinaryToPrimitive_Number:
+    case Builtin::kOrdinaryToPrimitive_String:
+    case Builtin::kParseInt:
+    case Builtin::kProxyHasProperty:
+    case Builtin::kProxyIsExtensible:
+    case Builtin::kProxyGetPrototypeOf:
+    case Builtin::kRecordWriteEmitRememberedSetSaveFP:
+    case Builtin::kRecordWriteOmitRememberedSetSaveFP:
+    case Builtin::kRecordWriteEmitRememberedSetIgnoreFP:
+    case Builtin::kRecordWriteOmitRememberedSetIgnoreFP:
+    case Builtin::kStringAdd_CheckNone:
+    case Builtin::kStringEqual:
+    case Builtin::kStringIndexOf:
+    case Builtin::kStringRepeat:
+    case Builtin::kToInteger:
+    case Builtin::kToLength:
+    case Builtin::kToName:
+    case Builtin::kToObject:
+    case Builtin::kToString:
 #ifdef V8_IS_TSAN
-    case Builtins::kTSANRelaxedStore32IgnoreFP:
-    case Builtins::kTSANRelaxedStore32SaveFP:
-    case Builtins::kTSANRelaxedStore64IgnoreFP:
-    case Builtins::kTSANRelaxedStore64SaveFP:
+    case Builtin::kTSANRelaxedStore32IgnoreFP:
+    case Builtin::kTSANRelaxedStore32SaveFP:
+    case Builtin::kTSANRelaxedStore64IgnoreFP:
+    case Builtin::kTSANRelaxedStore64SaveFP:
 #endif  // V8_IS_TSAN
-    case Builtins::kWeakMapLookupHashIndex:
+    case Builtin::kWeakMapLookupHashIndex:
       return true;
-    case Builtins::kJoinStackPop:
-    case Builtins::kJoinStackPush:
+    case Builtin::kJoinStackPop:
+    case Builtin::kJoinStackPush:
       switch (caller) {
-        case Builtins::kArrayPrototypeJoin:
-        case Builtins::kArrayPrototypeToLocaleString:
-        case Builtins::kTypedArrayPrototypeJoin:
-        case Builtins::kTypedArrayPrototypeToLocaleString:
+        case Builtin::kArrayPrototypeJoin:
+        case Builtin::kArrayPrototypeToLocaleString:
+        case Builtin::kTypedArrayPrototypeJoin:
+        case Builtin::kTypedArrayPrototypeToLocaleString:
           return true;
         default:
           return false;
       }
-    case Builtins::kFastCreateDataProperty:
+    case Builtin::kFastCreateDataProperty:
       switch (caller) {
-        case Builtins::kArrayPrototypeSlice:
-        case Builtins::kArrayFilter:
+        case Builtin::kArrayPrototypeSlice:
+        case Builtin::kArrayFilter:
           return true;
         default:
           return false;
       }
-    case Builtins::kSetProperty:
+    case Builtin::kSetProperty:
       switch (caller) {
-        case Builtins::kArrayPrototypeSlice:
-        case Builtins::kTypedArrayPrototypeMap:
-        case Builtins::kStringPrototypeMatchAll:
+        case Builtin::kArrayPrototypeSlice:
+        case Builtin::kTypedArrayPrototypeMap:
+        case Builtin::kStringPrototypeMatchAll:
           return true;
         default:
           return false;
@@ -1100,8 +1100,8 @@ void DebugEvaluate::VerifyTransitiveBuiltins(Isolate* isolate) {
   // TODO(yangguo): also check runtime calls.
   bool failed = false;
   bool sanity_check = false;
-  for (int i = 0; i < Builtins::builtin_count; i++) {
-    Builtins::Name caller = static_cast<Builtins::Name>(i);
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
+    Builtin caller = static_cast<Builtin>(i);
     DebugInfo::SideEffectState state = BuiltinGetSideEffectState(caller);
     if (state != DebugInfo::kHasNoSideEffect) continue;
     Code code = isolate->builtins()->builtin(caller);
@@ -1114,8 +1114,7 @@ void DebugEvaluate::VerifyTransitiveBuiltins(Isolate* isolate) {
       Code callee_code = isolate->heap()->GcSafeFindCodeForInnerPointer(
           rinfo->target_address());
       if (!callee_code.is_builtin()) continue;
-      Builtins::Name callee =
-          static_cast<Builtins::Name>(callee_code.builtin_index());
+      Builtin callee = static_cast<Builtin>(callee_code.builtin_index());
       if (BuiltinGetSideEffectState(callee) == DebugInfo::kHasNoSideEffect) {
         continue;
       }
diff --git a/src/debug/debug-interface.cc b/src/debug/debug-interface.cc
index ae9169b3468..6250f77bcbd 100644
--- a/src/debug/debug-interface.cc
+++ b/src/debug/debug-interface.cc
@@ -847,7 +847,7 @@ Local<Function> GetBuiltin(Isolate* v8_isolate, Builtin builtin) {
   i::HandleScope handle_scope(isolate);
 
   CHECK_EQ(builtin, kStringToLowerCase);
-  i::Builtins::Name builtin_id = i::Builtins::kStringPrototypeToLocaleLowerCase;
+  i::Builtin builtin_id = i::Builtin::kStringPrototypeToLocaleLowerCase;
 
   i::Factory* factory = isolate->factory();
   i::Handle<i::String> name = isolate->factory()->empty_string();
diff --git a/src/debug/debug.cc b/src/debug/debug.cc
index c7cdda36dff..bc6ec835022 100644
--- a/src/debug/debug.cc
+++ b/src/debug/debug.cc
@@ -1254,15 +1254,13 @@ class DiscardBaselineCodeVisitor : public ThreadVisitor {
         // we deoptimized in the debugger and are stepping into it.
         JavaScriptFrame* frame = it.frame();
         Address pc = frame->pc();
-        Builtins::Name builtin_index =
-            InstructionStream::TryLookupCode(isolate, pc);
-        if (builtin_index == Builtins::kBaselineEnterAtBytecode ||
-            builtin_index == Builtins::kBaselineEnterAtNextBytecode) {
+        Builtin builtin_index = InstructionStream::TryLookupCode(isolate, pc);
+        if (builtin_index == Builtin::kBaselineEnterAtBytecode ||
+            builtin_index == Builtin::kBaselineEnterAtNextBytecode) {
           Address* pc_addr = frame->pc_address();
-          Builtins::Name advance =
-              builtin_index == Builtins::kBaselineEnterAtBytecode
-                  ? Builtins::kInterpreterEnterAtBytecode
-                  : Builtins::kInterpreterEnterAtNextBytecode;
+          Builtin advance = builtin_index == Builtin::kBaselineEnterAtBytecode
+                                ? Builtin::kInterpreterEnterAtBytecode
+                                : Builtin::kInterpreterEnterAtNextBytecode;
           Address advance_pc =
               isolate->builtins()->builtin(advance).InstructionStart();
           PointerAuthentication::ReplacePC(pc_addr, advance_pc,
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index eabd9ebb41c..e48d91b6206 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -632,25 +632,25 @@ void Deoptimizer::DeleteFrameDescriptions() {
 #endif  // DEBUG
 }
 
-Builtins::Name Deoptimizer::GetDeoptWithResumeBuiltin(DeoptimizeReason reason) {
+Builtin Deoptimizer::GetDeoptWithResumeBuiltin(DeoptimizeReason reason) {
   switch (reason) {
     case DeoptimizeReason::kDynamicCheckMaps:
-      return Builtins::kDynamicCheckMapsTrampoline;
+      return Builtin::kDynamicCheckMapsTrampoline;
     default:
       UNREACHABLE();
   }
 }
 
-Builtins::Name Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind kind) {
+Builtin Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind kind) {
   switch (kind) {
     case DeoptimizeKind::kEager:
-      return Builtins::kDeoptimizationEntry_Eager;
+      return Builtin::kDeoptimizationEntry_Eager;
     case DeoptimizeKind::kSoft:
-      return Builtins::kDeoptimizationEntry_Soft;
+      return Builtin::kDeoptimizationEntry_Soft;
     case DeoptimizeKind::kBailout:
-      return Builtins::kDeoptimizationEntry_Bailout;
+      return Builtin::kDeoptimizationEntry_Bailout;
     case DeoptimizeKind::kLazy:
-      return Builtins::kDeoptimizationEntry_Lazy;
+      return Builtin::kDeoptimizationEntry_Lazy;
     case DeoptimizeKind::kEagerWithResume:
       // EagerWithResume deopts will call a special builtin (specified by
       // GetDeoptWithResumeBuiltin) which will itself select the deoptimization
@@ -661,20 +661,20 @@ Builtins::Name Deoptimizer::GetDeoptimizationEntry(DeoptimizeKind kind) {
 
 bool Deoptimizer::IsDeoptimizationEntry(Isolate* isolate, Address addr,
                                         DeoptimizeKind* type_out) {
-  Builtins::Name builtin = InstructionStream::TryLookupCode(isolate, addr);
+  Builtin builtin = InstructionStream::TryLookupCode(isolate, addr);
   if (!Builtins::IsBuiltinId(builtin)) return false;
 
   switch (builtin) {
-    case Builtins::kDeoptimizationEntry_Eager:
+    case Builtin::kDeoptimizationEntry_Eager:
       *type_out = DeoptimizeKind::kEager;
       return true;
-    case Builtins::kDeoptimizationEntry_Soft:
+    case Builtin::kDeoptimizationEntry_Soft:
       *type_out = DeoptimizeKind::kSoft;
       return true;
-    case Builtins::kDeoptimizationEntry_Bailout:
+    case Builtin::kDeoptimizationEntry_Bailout:
       *type_out = DeoptimizeKind::kBailout;
       return true;
-    case Builtins::kDeoptimizationEntry_Lazy:
+    case Builtin::kDeoptimizationEntry_Lazy:
       *type_out = DeoptimizeKind::kLazy;
       return true;
     default:
@@ -991,13 +991,13 @@ void Deoptimizer::DoComputeOutputFrames() {
 namespace {
 
 // Get the dispatch builtin for unoptimized frames.
-Builtins::Name DispatchBuiltinFor(bool is_baseline, bool advance_bc) {
+Builtin DispatchBuiltinFor(bool is_baseline, bool advance_bc) {
   if (is_baseline) {
-    return advance_bc ? Builtins::kBaselineEnterAtNextBytecode
-                      : Builtins::kBaselineEnterAtBytecode;
+    return advance_bc ? Builtin::kBaselineEnterAtNextBytecode
+                      : Builtin::kBaselineEnterAtBytecode;
   } else {
-    return advance_bc ? Builtins::kInterpreterEnterAtNextBytecode
-                      : Builtins::kInterpreterEnterAtBytecode;
+    return advance_bc ? Builtin::kInterpreterEnterAtNextBytecode
+                      : Builtin::kInterpreterEnterAtBytecode;
   }
 }
 
@@ -1300,7 +1300,7 @@ void Deoptimizer::DoComputeUnoptimizedFrame(TranslatedFrame* translated_frame,
     Register context_reg = JavaScriptFrame::context_register();
     output_frame->SetRegister(context_reg.code(), context_value);
     // Set the continuation for the topmost frame.
-    Code continuation = builtins->builtin(Builtins::kNotifyDeoptimized);
+    Code continuation = builtins->builtin(Builtin::kNotifyDeoptimized);
     output_frame->SetContinuation(
         static_cast<intptr_t>(continuation.InstructionStart()));
   }
@@ -1380,7 +1380,7 @@ void Deoptimizer::DoComputeConstructStubFrame(TranslatedFrame* translated_frame,
   CHECK(!is_topmost || deopt_kind_ == DeoptimizeKind::kLazy);
 
   Builtins* builtins = isolate_->builtins();
-  Code construct_stub = builtins->builtin(Builtins::kJSConstructStubGeneric);
+  Code construct_stub = builtins->builtin(Builtin::kJSConstructStubGeneric);
   BytecodeOffset bytecode_offset = translated_frame->bytecode_offset();
 
   const int parameters_count = translated_frame->height();
@@ -1536,7 +1536,7 @@ void Deoptimizer::DoComputeConstructStubFrame(TranslatedFrame* translated_frame,
   if (is_topmost) {
     Builtins* builtins = isolate_->builtins();
     DCHECK_EQ(DeoptimizeKind::kLazy, deopt_kind_);
-    Code continuation = builtins->builtin(Builtins::kNotifyDeoptimized);
+    Code continuation = builtins->builtin(Builtin::kNotifyDeoptimized);
     output_frame->SetContinuation(
         static_cast<intptr_t>(continuation.InstructionStart()));
   }
@@ -1573,18 +1573,18 @@ StackFrame::Type BuiltinContinuationModeToFrameType(
 
 }  // namespace
 
-Builtins::Name Deoptimizer::TrampolineForBuiltinContinuation(
+Builtin Deoptimizer::TrampolineForBuiltinContinuation(
     BuiltinContinuationMode mode, bool must_handle_result) {
   switch (mode) {
     case BuiltinContinuationMode::STUB:
-      return must_handle_result ? Builtins::kContinueToCodeStubBuiltinWithResult
-                                : Builtins::kContinueToCodeStubBuiltin;
+      return must_handle_result ? Builtin::kContinueToCodeStubBuiltinWithResult
+                                : Builtin::kContinueToCodeStubBuiltin;
     case BuiltinContinuationMode::JAVASCRIPT:
     case BuiltinContinuationMode::JAVASCRIPT_WITH_CATCH:
     case BuiltinContinuationMode::JAVASCRIPT_HANDLE_EXCEPTION:
       return must_handle_result
-                 ? Builtins::kContinueToJavaScriptBuiltinWithResult
-                 : Builtins::kContinueToJavaScriptBuiltin;
+                 ? Builtin::kContinueToJavaScriptBuiltinWithResult
+                 : Builtin::kContinueToJavaScriptBuiltin;
   }
   UNREACHABLE();
 }
@@ -1703,7 +1703,7 @@ void Deoptimizer::DoComputeBuiltinContinuation(
   TranslatedFrame::iterator value_iterator = translated_frame->begin();
 
   const BytecodeOffset bytecode_offset = translated_frame->bytecode_offset();
-  Builtins::Name builtin_name =
+  Builtin builtin_name =
       Builtins::GetBuiltinFromBytecodeOffset(bytecode_offset);
   CallInterfaceDescriptor continuation_descriptor =
       Builtins::CallInterfaceDescriptorFor(builtin_name);
@@ -1977,7 +1977,7 @@ void Deoptimizer::DoComputeBuiltinContinuation(
   }
 
   Code continuation =
-      isolate()->builtins()->builtin(Builtins::kNotifyDeoptimized);
+      isolate()->builtins()->builtin(Builtin::kNotifyDeoptimized);
   output_frame->SetContinuation(
       static_cast<intptr_t>(continuation.InstructionStart()));
 }
diff --git a/src/deoptimizer/deoptimizer.h b/src/deoptimizer/deoptimizer.h
index 61a40d3556a..4ff5601e35d 100644
--- a/src/deoptimizer/deoptimizer.h
+++ b/src/deoptimizer/deoptimizer.h
@@ -93,11 +93,10 @@ class Deoptimizer : public Malloced {
 
   // Returns the builtin that will perform a check and either eagerly deopt with
   // |reason| or resume execution in the optimized code.
-  V8_EXPORT_PRIVATE static Builtins::Name GetDeoptWithResumeBuiltin(
+  V8_EXPORT_PRIVATE static Builtin GetDeoptWithResumeBuiltin(
       DeoptimizeReason reason);
 
-  V8_EXPORT_PRIVATE static Builtins::Name GetDeoptimizationEntry(
-      DeoptimizeKind kind);
+  V8_EXPORT_PRIVATE static Builtin GetDeoptimizationEntry(DeoptimizeKind kind);
 
   // Returns true if {addr} is a deoptimization entry and stores its type in
   // {type_out}. Returns false if {addr} is not a deoptimization entry.
@@ -165,8 +164,8 @@ class Deoptimizer : public Malloced {
   void DoComputeConstructStubFrame(TranslatedFrame* translated_frame,
                                    int frame_index);
 
-  static Builtins::Name TrampolineForBuiltinContinuation(
-      BuiltinContinuationMode mode, bool must_handle_result);
+  static Builtin TrampolineForBuiltinContinuation(BuiltinContinuationMode mode,
+                                                  bool must_handle_result);
 
 #if V8_ENABLE_WEBASSEMBLY
   TranslatedValue TranslatedValueForWasmReturnKind(
diff --git a/src/diagnostics/disassembler.cc b/src/diagnostics/disassembler.cc
index 91a7a72bbf5..6056fd5436f 100644
--- a/src/diagnostics/disassembler.cc
+++ b/src/diagnostics/disassembler.cc
@@ -129,7 +129,7 @@ const char* V8NameConverter::RootRelativeName(int offset) const {
   const unsigned kExtRefsTableSize = ExternalReferenceTable::kSizeInBytes;
   const int kBuiltinsTableStart = IsolateData::builtins_table_offset();
   const unsigned kBuiltinsTableSize =
-      Builtins::builtin_count * kSystemPointerSize;
+      Builtins::kBuiltinCount * kSystemPointerSize;
 
   if (static_cast<unsigned>(offset - kRootsTableStart) < kRootsTableSize) {
     uint32_t offset_in_roots_table = offset - kRootsTableStart;
@@ -166,8 +166,8 @@ const char* V8NameConverter::RootRelativeName(int offset) const {
              kBuiltinsTableSize) {
     uint32_t offset_in_builtins_table = (offset - kBuiltinsTableStart);
 
-    Builtins::Name builtin_id = static_cast<Builtins::Name>(
-        offset_in_builtins_table / kSystemPointerSize);
+    Builtin builtin_id =
+        static_cast<Builtin>(offset_in_builtins_table / kSystemPointerSize);
 
     const char* name = Builtins::name(builtin_id);
     SNPrintF(v8_buffer_, "builtin (%s)", name);
diff --git a/src/diagnostics/objects-debug.cc b/src/diagnostics/objects-debug.cc
index e96e42097c8..5b47b31eda0 100644
--- a/src/diagnostics/objects-debug.cc
+++ b/src/diagnostics/objects-debug.cc
@@ -887,7 +887,7 @@ void SharedFunctionInfo::SharedFunctionInfoVerify(ReadOnlyRoots roots) {
     CHECK(!construct_as_builtin());
   } else {
     int id = builtin_id();
-    if (id != Builtins::kCompileLazy && id != Builtins::kEmptyFunction) {
+    if (id != Builtin::kCompileLazy && id != Builtin::kEmptyFunction) {
       CHECK(construct_as_builtin());
     } else {
       CHECK(!construct_as_builtin());
@@ -1342,7 +1342,7 @@ void JSRegExp::JSRegExpVerify(Isolate* isolate) {
       bool is_compiled = latin1_code.IsCode();
       if (is_compiled) {
         CHECK_EQ(Code::cast(latin1_code).builtin_index(),
-                 Builtins::kRegExpExperimentalTrampoline);
+                 Builtin::kRegExpExperimentalTrampoline);
         CHECK_EQ(uc16_code, latin1_code);
 
         CHECK(latin1_bytecode.IsByteArray());
@@ -1628,7 +1628,7 @@ void WasmExportedFunctionData::WasmExportedFunctionDataVerify(
   CHECK(wrapper_code().kind() == CodeKind::JS_TO_WASM_FUNCTION ||
         wrapper_code().kind() == CodeKind::C_WASM_ENTRY ||
         (wrapper_code().is_builtin() &&
-         wrapper_code().builtin_index() == Builtins::kGenericJSToWasmWrapper));
+         wrapper_code().builtin_index() == Builtin::kGenericJSToWasmWrapper));
 }
 
 USE_TORQUE_VERIFIER(WasmModuleObject)
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index bef92948ebd..8b0030f3938 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -225,13 +225,13 @@ namespace {
 
 bool IsInterpreterFramePc(Isolate* isolate, Address pc,
                           StackFrame::State* state) {
-  Builtins::Name builtin_index = InstructionStream::TryLookupCode(isolate, pc);
-  if (builtin_index != Builtins::kNoBuiltinId &&
-      (builtin_index == Builtins::kInterpreterEntryTrampoline ||
-       builtin_index == Builtins::kInterpreterEnterAtBytecode ||
-       builtin_index == Builtins::kInterpreterEnterAtNextBytecode ||
-       builtin_index == Builtins::kBaselineEnterAtBytecode ||
-       builtin_index == Builtins::kBaselineEnterAtNextBytecode)) {
+  Builtin builtin_index = InstructionStream::TryLookupCode(isolate, pc);
+  if (builtin_index != Builtin::kNoBuiltinId &&
+      (builtin_index == Builtin::kInterpreterEntryTrampoline ||
+       builtin_index == Builtin::kInterpreterEnterAtBytecode ||
+       builtin_index == Builtin::kInterpreterEnterAtNextBytecode ||
+       builtin_index == Builtin::kBaselineEnterAtBytecode ||
+       builtin_index == Builtin::kBaselineEnterAtNextBytecode)) {
     return true;
   } else if (FLAG_interpreted_frames_native_stack) {
     intptr_t marker = Memory<intptr_t>(
@@ -694,7 +694,7 @@ void NativeFrame::ComputeCallerState(State* state) const {
 }
 
 Code EntryFrame::unchecked_code() const {
-  return isolate()->heap()->builtin(Builtins::kJSEntry);
+  return isolate()->heap()->builtin(Builtin::kJSEntry);
 }
 
 void EntryFrame::ComputeCallerState(State* state) const {
@@ -716,7 +716,7 @@ StackFrame::Type CWasmEntryFrame::GetCallerState(State* state) const {
 #endif  // V8_ENABLE_WEBASSEMBLY
 
 Code ConstructEntryFrame::unchecked_code() const {
-  return isolate()->heap()->builtin(Builtins::kJSConstructEntry);
+  return isolate()->heap()->builtin(Builtin::kJSConstructEntry);
 }
 
 void ExitFrame::ComputeCallerState(State* state) const {
@@ -2012,7 +2012,7 @@ void JsToWasmFrame::Iterate(RootVisitor* v) const {
   //        |      ....       | <- spill_slot_base--|
   //        |- - - - - - - - -|                     |
   if (code.is_null() || !code.is_builtin() ||
-      code.builtin_index() != Builtins::kGenericJSToWasmWrapper) {
+      code.builtin_index() != Builtin::kGenericJSToWasmWrapper) {
     // If it's not the  GenericJSToWasmWrapper, then it's the TurboFan compiled
     // specific wrapper. So we have to call IterateCompiledFrame.
     IterateCompiledFrame(v);
@@ -2332,7 +2332,7 @@ ConstructStubFrameInfo::ConstructStubFrameInfo(int translation_height,
   // value of result register is preserved during continuation execution.
   // We do this here by "pushing" the result of the constructor function to
   // the top of the reconstructed stack and popping it in
-  // {Builtins::kNotifyDeoptimized}.
+  // {Builtin::kNotifyDeoptimized}.
 
   static constexpr int kTopOfStackPadding = TopOfStackRegisterPaddingSlots();
   static constexpr int kTheResult = 1;
@@ -2388,7 +2388,7 @@ BuiltinContinuationFrameInfo::BuiltinContinuationFrameInfo(
   // value of result register is preserved during continuation execution.
   // We do this here by "pushing" the result of callback function to the
   // top of the reconstructed stack and popping it in
-  // {Builtins::kNotifyDeoptimized}.
+  // {Builtin::kNotifyDeoptimized}.
   static constexpr int kTopOfStackPadding = TopOfStackRegisterPaddingSlots();
   static constexpr int kTheResult = 1;
   const int push_result_count =
diff --git a/src/execution/isolate-data.h b/src/execution/isolate-data.h
index bc3e2b8d1a6..32f8dc79bec 100644
--- a/src/execution/isolate-data.h
+++ b/src/execution/isolate-data.h
@@ -66,7 +66,7 @@ class IsolateData final {
   static constexpr int builtin_entry_table_offset() {
     return kBuiltinEntryTableOffset - kIsolateRootBias;
   }
-  static constexpr int builtin_entry_slot_offset(Builtins::Name builtin_index) {
+  static constexpr int builtin_entry_slot_offset(Builtin builtin_index) {
     DCHECK(Builtins::IsBuiltinId(builtin_index));
     return builtin_entry_table_offset() + builtin_index * kSystemPointerSize;
   }
@@ -107,7 +107,7 @@ class IsolateData final {
   }
 
   // Root-register-relative offset of the builtin table entry.
-  static int builtin_slot_offset(Builtins::Name id) {
+  static int builtin_slot_offset(Builtin id) {
     return builtins_table_offset() + id * kSystemPointerSize;
   }
 
@@ -165,8 +165,8 @@ class IsolateData final {
   V(kRootsTableOffset, RootsTable::kEntriesCount* kSystemPointerSize)         \
   V(kExternalReferenceTableOffset, ExternalReferenceTable::kSizeInBytes)      \
   V(kThreadLocalTopOffset, ThreadLocalTop::kSizeInBytes)                      \
-  V(kBuiltinEntryTableOffset, Builtins::builtin_count* kSystemPointerSize)    \
-  V(kBuiltinsTableOffset, Builtins::builtin_count* kSystemPointerSize)        \
+  V(kBuiltinEntryTableOffset, Builtins::kBuiltinCount* kSystemPointerSize)    \
+  V(kBuiltinsTableOffset, Builtins::kBuiltinCount* kSystemPointerSize)        \
   FIELDS_HEAP_SANDBOX(V)                                                      \
   V(kStackIsIterableOffset, kUInt8Size)                                       \
   /* This padding aligns IsolateData size by 8 bytes. */                      \
@@ -218,10 +218,10 @@ class IsolateData final {
   // The entry points for all builtins. This corresponds to
   // Code::InstructionStart() for each Code object in the builtins table below.
   // The entry table is in IsolateData for easy access through kRootRegister.
-  Address builtin_entry_table_[Builtins::builtin_count] = {};
+  Address builtin_entry_table_[Builtins::kBuiltinCount] = {};
 
   // The entries in this array are tagged pointers to Code objects.
-  Address builtins_[Builtins::builtin_count] = {};
+  Address builtins_[Builtins::kBuiltinCount] = {};
 
   // Table containing pointers to external objects.
 #ifdef V8_HEAP_SANDBOX
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index 4f1f0e50449..fafad45a852 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -391,7 +391,7 @@ size_t Isolate::HashIsolateForEmbeddedBlob() {
   size_t hash = kSeed;
 
   // Hash data sections of builtin code objects.
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Code code = heap_.builtin(i);
 
     DCHECK(Internals::HasHeapObjectTag(code.ptr()));
@@ -872,7 +872,7 @@ bool NoExtension(const v8::FunctionCallbackInfo<v8::Value>&) { return false; }
 namespace {
 
 bool IsBuiltinFunction(Isolate* isolate, HeapObject object,
-                       Builtins::Name builtin_index) {
+                       Builtin builtin_index) {
   if (!object.IsJSFunction()) return false;
   JSFunction const function = JSFunction::cast(object);
   return function.code() == isolate->builtins()->builtin(builtin_index);
@@ -893,11 +893,11 @@ void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,
     // Check if the {reaction} has one of the known async function or
     // async generator continuations as its fulfill handler.
     if (IsBuiltinFunction(isolate, reaction->fulfill_handler(),
-                          Builtins::kAsyncFunctionAwaitResolveClosure) ||
+                          Builtin::kAsyncFunctionAwaitResolveClosure) ||
         IsBuiltinFunction(isolate, reaction->fulfill_handler(),
-                          Builtins::kAsyncGeneratorAwaitResolveClosure) ||
+                          Builtin::kAsyncGeneratorAwaitResolveClosure) ||
         IsBuiltinFunction(isolate, reaction->fulfill_handler(),
-                          Builtins::kAsyncGeneratorYieldResolveClosure)) {
+                          Builtin::kAsyncGeneratorYieldResolveClosure)) {
       // Now peak into the handlers' AwaitContext to get to
       // the JSGeneratorObject for the async function.
       Handle<Context> context(
@@ -925,7 +925,7 @@ void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,
                          isolate);
       }
     } else if (IsBuiltinFunction(isolate, reaction->fulfill_handler(),
-                                 Builtins::kPromiseAllResolveElementClosure)) {
+                                 Builtin::kPromiseAllResolveElementClosure)) {
       Handle<JSFunction> function(JSFunction::cast(reaction->fulfill_handler()),
                                   isolate);
       Handle<Context> context(function->context(), isolate);
@@ -943,7 +943,7 @@ void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,
       if (!capability->promise().IsJSPromise()) return;
       promise = handle(JSPromise::cast(capability->promise()), isolate);
     } else if (IsBuiltinFunction(isolate, reaction->reject_handler(),
-                                 Builtins::kPromiseAnyRejectElementClosure)) {
+                                 Builtin::kPromiseAnyRejectElementClosure)) {
       Handle<JSFunction> function(JSFunction::cast(reaction->reject_handler()),
                                   isolate);
       Handle<Context> context(function->context(), isolate);
@@ -960,7 +960,7 @@ void CaptureAsyncStackTrace(Isolate* isolate, Handle<JSPromise> promise,
       if (!capability->promise().IsJSPromise()) return;
       promise = handle(JSPromise::cast(capability->promise()), isolate);
     } else if (IsBuiltinFunction(isolate, reaction->fulfill_handler(),
-                                 Builtins::kPromiseCapabilityDefaultResolve)) {
+                                 Builtin::kPromiseCapabilityDefaultResolve)) {
       Handle<JSFunction> function(JSFunction::cast(reaction->fulfill_handler()),
                                   isolate);
       Handle<Context> context(function->context(), isolate);
@@ -1087,15 +1087,15 @@ Handle<FixedArray> CaptureStackTrace(Isolate* isolate, Handle<Object> caller,
       // Check if the {reaction} has one of the known async function or
       // async generator continuations as its fulfill handler.
       if (IsBuiltinFunction(isolate, promise_reaction_job_task->handler(),
-                            Builtins::kAsyncFunctionAwaitResolveClosure) ||
+                            Builtin::kAsyncFunctionAwaitResolveClosure) ||
           IsBuiltinFunction(isolate, promise_reaction_job_task->handler(),
-                            Builtins::kAsyncGeneratorAwaitResolveClosure) ||
+                            Builtin::kAsyncGeneratorAwaitResolveClosure) ||
           IsBuiltinFunction(isolate, promise_reaction_job_task->handler(),
-                            Builtins::kAsyncGeneratorYieldResolveClosure) ||
+                            Builtin::kAsyncGeneratorYieldResolveClosure) ||
           IsBuiltinFunction(isolate, promise_reaction_job_task->handler(),
-                            Builtins::kAsyncFunctionAwaitRejectClosure) ||
+                            Builtin::kAsyncFunctionAwaitRejectClosure) ||
           IsBuiltinFunction(isolate, promise_reaction_job_task->handler(),
-                            Builtins::kAsyncGeneratorAwaitRejectClosure)) {
+                            Builtin::kAsyncGeneratorAwaitRejectClosure)) {
         // Now peak into the handlers' AwaitContext to get to
         // the JSGeneratorObject for the async function.
         Handle<Context> context(
@@ -1913,8 +1913,7 @@ Object Isolate::UnwindAndFindHandler() {
           InterpretedFrame::cast(js_frame)->PatchBytecodeOffset(
               static_cast<int>(offset));
 
-          Code code =
-              builtins()->builtin(Builtins::kInterpreterEnterAtBytecode);
+          Code code = builtins()->builtin(Builtin::kInterpreterEnterAtBytecode);
           return FoundHandler(context, code.InstructionStart(), 0,
                               code.constant_pool(), return_sp, frame->fp());
         }
@@ -2687,7 +2686,7 @@ void Isolate::ReleaseSharedPtrs() {
 bool Isolate::IsBuiltinsTableHandleLocation(Address* handle_location) {
   FullObjectSlot location(handle_location);
   FullObjectSlot first_root(builtins_table());
-  FullObjectSlot last_root(builtins_table() + Builtins::builtin_count);
+  FullObjectSlot last_root(builtins_table() + Builtins::kBuiltinCount);
   if (location >= last_root) return false;
   if (location < first_root) return false;
   return true;
@@ -3384,7 +3383,7 @@ void CreateOffHeapTrampolines(Isolate* isolate) {
   EmbeddedData d = EmbeddedData::FromBlob(isolate);
 
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Address instruction_start = d.InstructionStartOfBuiltin(i);
     Handle<Code> trampoline = isolate->factory()->NewOffHeapTrampolineFor(
         builtins->builtin_handle(i), instruction_start);
@@ -3722,7 +3721,7 @@ bool Isolate::Init(SnapshotData* startup_snapshot_data,
     // this at mksnapshot-time, but not at runtime.
     // See also: https://crbug.com/v8/8713.
     heap_.SetInterpreterEntryTrampolineForProfiling(
-        heap_.builtin(Builtins::kInterpreterEntryTrampoline));
+        heap_.builtin(Builtin::kInterpreterEntryTrampoline));
 #endif
 
     builtins_constants_table_builder_->Finalize();
@@ -4620,14 +4619,14 @@ void Isolate::RunPromiseHookForAsyncEventDelegate(PromiseHookType type,
           }
           last_frame_was_promise_builtin = false;
           if (info->HasBuiltinId()) {
-            if (info->builtin_id() == Builtins::kPromisePrototypeThen) {
+            if (info->builtin_id() == Builtin::kPromisePrototypeThen) {
               type = debug::kDebugPromiseThen;
               last_frame_was_promise_builtin = true;
-            } else if (info->builtin_id() == Builtins::kPromisePrototypeCatch) {
+            } else if (info->builtin_id() == Builtin::kPromisePrototypeCatch) {
               type = debug::kDebugPromiseCatch;
               last_frame_was_promise_builtin = true;
             } else if (info->builtin_id() ==
-                       Builtins::kPromisePrototypeFinally) {
+                       Builtin::kPromisePrototypeFinally) {
               type = debug::kDebugPromiseFinally;
               last_frame_was_promise_builtin = true;
             }
diff --git a/src/heap/factory-base.cc b/src/heap/factory-base.cc
index df78716a8de..4e645c5c59e 100644
--- a/src/heap/factory-base.cc
+++ b/src/heap/factory-base.cc
@@ -263,7 +263,7 @@ Handle<SharedFunctionInfo> FactoryBase<Impl>::NewSharedFunctionInfoForLiteral(
   FunctionKind kind = literal->kind();
   Handle<SharedFunctionInfo> shared =
       NewSharedFunctionInfo(literal->GetName(isolate()), MaybeHandle<Code>(),
-                            Builtins::kCompileLazy, kind);
+                            Builtin::kCompileLazy, kind);
   SharedFunctionInfo::InitFromFunctionLiteral(isolate(), shared, literal,
                                               is_toplevel);
   shared->SetScript(read_only_roots(), *script, literal->function_literal_id(),
@@ -335,7 +335,7 @@ Handle<SharedFunctionInfo> FactoryBase<Impl>::NewSharedFunctionInfo(
     raw.set_builtin_id(maybe_builtin_index);
   } else {
     DCHECK(raw.HasBuiltinId());
-    DCHECK_EQ(Builtins::kIllegal, raw.builtin_id());
+    DCHECK_EQ(Builtin::kIllegal, raw.builtin_id());
   }
 
   raw.CalculateConstructAsBuiltin();
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index 5b70cb7b0d2..e46b4f04e4d 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -1407,7 +1407,7 @@ Handle<WasmJSFunctionData> Factory::NewWasmJSFunctionData(
   result.set_serialized_signature(*serialized_sig);
   // Default value, will be overwritten by the caller.
   result.set_wasm_to_js_wrapper_code(
-      isolate()->heap()->builtin(Builtins::kAbort));
+      isolate()->heap()->builtin(Builtin::kAbort));
   return handle(result, isolate());
 }
 
@@ -1457,18 +1457,18 @@ Handle<WasmCapiFunctionData> Factory::NewWasmCapiFunctionData(
 Handle<SharedFunctionInfo>
 Factory::NewSharedFunctionInfoForWasmExportedFunction(
     Handle<String> name, Handle<WasmExportedFunctionData> data) {
-  return NewSharedFunctionInfo(name, data, Builtins::kNoBuiltinId);
+  return NewSharedFunctionInfo(name, data, Builtin::kNoBuiltinId);
 }
 
 Handle<SharedFunctionInfo> Factory::NewSharedFunctionInfoForWasmJSFunction(
     Handle<String> name, Handle<WasmJSFunctionData> data) {
-  return NewSharedFunctionInfo(name, data, Builtins::kNoBuiltinId);
+  return NewSharedFunctionInfo(name, data, Builtin::kNoBuiltinId);
 }
 
 Handle<SharedFunctionInfo> Factory::NewSharedFunctionInfoForWasmCapiFunction(
     Handle<WasmCapiFunctionData> data) {
   return NewSharedFunctionInfo(MaybeHandle<String>(), data,
-                               Builtins::kNoBuiltinId, kConciseMethod);
+                               Builtin::kNoBuiltinId, kConciseMethod);
 }
 #endif  // V8_ENABLE_WEBASSEMBLY
 
@@ -2911,7 +2911,7 @@ Handle<SharedFunctionInfo> Factory::NewSharedFunctionInfoForApiFunction(
     MaybeHandle<String> maybe_name,
     Handle<FunctionTemplateInfo> function_template_info, FunctionKind kind) {
   Handle<SharedFunctionInfo> shared = NewSharedFunctionInfo(
-      maybe_name, function_template_info, Builtins::kNoBuiltinId, kind);
+      maybe_name, function_template_info, Builtin::kNoBuiltinId, kind);
   return shared;
 }
 
@@ -3605,7 +3605,7 @@ bool Factory::EmptyStringRootIsInitialized() {
 
 Handle<JSFunction> Factory::NewFunctionForTesting(Handle<String> name) {
   Handle<SharedFunctionInfo> info =
-      NewSharedFunctionInfoForBuiltin(name, Builtins::kIllegal);
+      NewSharedFunctionInfoForBuiltin(name, Builtin::kIllegal);
   info->set_language_mode(LanguageMode::kSloppy);
   return JSFunctionBuilder{isolate(), info, isolate()->native_context()}
       .Build();
diff --git a/src/heap/factory.h b/src/heap/factory.h
index 2ffa3c7a56d..b18012df333 100644
--- a/src/heap/factory.h
+++ b/src/heap/factory.h
@@ -840,7 +840,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
     }
 
     CodeBuilder& set_builtin_index(int32_t builtin_index) {
-      DCHECK_IMPLIES(builtin_index != Builtins::kNoBuiltinId,
+      DCHECK_IMPLIES(builtin_index != Builtin::kNoBuiltinId,
                      !CodeKindIsJSFunction(kind_));
       builtin_index_ = builtin_index;
       return *this;
@@ -912,7 +912,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
     const CodeKind kind_;
 
     MaybeHandle<Object> self_reference_;
-    int32_t builtin_index_ = Builtins::kNoBuiltinId;
+    int32_t builtin_index_ = Builtin::kNoBuiltinId;
     uint32_t inlined_bytecode_size_ = 0;
     int32_t kind_specific_flags_ = 0;
     // Either source_position_table for non-baseline code
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index bf7dd20b2dd..b994bbd9cc4 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -4514,7 +4514,7 @@ Code Heap::builtin(int index) {
 }
 
 Address Heap::builtin_address(int index) {
-  DCHECK(Builtins::IsBuiltinId(index) || index == Builtins::builtin_count);
+  DCHECK(Builtins::IsBuiltinId(index) || index == Builtins::kBuiltinCount);
   return reinterpret_cast<Address>(&isolate()->builtins_table()[index]);
 }
 
@@ -4739,7 +4739,7 @@ void Heap::IterateWeakGlobalHandles(RootVisitor* v) {
 }
 
 void Heap::IterateBuiltins(RootVisitor* v) {
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     v->VisitRootPointer(Root::kBuiltins, Builtins::name(i),
                         FullObjectSlot(builtin_address(i)));
   }
@@ -6476,7 +6476,7 @@ void Heap::SetDetachedContexts(WeakArrayList detached_contexts) {
 }
 
 void Heap::SetInterpreterEntryTrampolineForProfiling(Code code) {
-  DCHECK_EQ(Builtins::kInterpreterEntryTrampoline, code.builtin_index());
+  DCHECK_EQ(Builtin::kInterpreterEntryTrampoline, code.builtin_index());
   set_interpreter_entry_trampoline_for_profiling(code);
 }
 
@@ -6802,8 +6802,7 @@ Code Heap::GcSafeCastToCode(HeapObject object, Address inner_pointer) {
 bool Heap::GcSafeCodeContains(Code code, Address addr) {
   Map map = GcSafeMapOfCodeSpaceObject(code);
   DCHECK(map == ReadOnlyRoots(this).code_map());
-  Builtins::Name maybe_builtin =
-      InstructionStream::TryLookupCode(isolate(), addr);
+  Builtin maybe_builtin = InstructionStream::TryLookupCode(isolate(), addr);
   if (Builtins::IsBuiltinId(maybe_builtin) &&
       code.builtin_index() == maybe_builtin) {
     return true;
@@ -6814,7 +6813,7 @@ bool Heap::GcSafeCodeContains(Code code, Address addr) {
 }
 
 Code Heap::GcSafeFindCodeForInnerPointer(Address inner_pointer) {
-  Builtins::Name maybe_builtin =
+  Builtin maybe_builtin =
       InstructionStream::TryLookupCode(isolate(), inner_pointer);
   if (Builtins::IsBuiltinId(maybe_builtin)) {
     return builtin(maybe_builtin);
diff --git a/src/heap/setup-heap-internal.cc b/src/heap/setup-heap-internal.cc
index f41cb59920a..06ebd7460ab 100644
--- a/src/heap/setup-heap-internal.cc
+++ b/src/heap/setup-heap-internal.cc
@@ -54,7 +54,7 @@ namespace internal {
 namespace {
 
 Handle<SharedFunctionInfo> CreateSharedFunctionInfo(
-    Isolate* isolate, Builtins::Name builtin_id, int len,
+    Isolate* isolate, Builtin builtin_id, int len,
     FunctionKind kind = FunctionKind::kNormalFunction) {
   Handle<SharedFunctionInfo> shared =
       isolate->factory()->NewSharedFunctionInfoForBuiltin(
@@ -918,52 +918,52 @@ void Heap::CreateInitialObjects() {
   // Async functions:
   {
     Handle<SharedFunctionInfo> info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncFunctionAwaitRejectClosure, 1);
+        isolate(), Builtin::kAsyncFunctionAwaitRejectClosure, 1);
     set_async_function_await_reject_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncFunctionAwaitResolveClosure, 1);
+        isolate(), Builtin::kAsyncFunctionAwaitResolveClosure, 1);
     set_async_function_await_resolve_shared_fun(*info);
   }
 
   // Async generators:
   {
     Handle<SharedFunctionInfo> info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncGeneratorAwaitResolveClosure, 1);
+        isolate(), Builtin::kAsyncGeneratorAwaitResolveClosure, 1);
     set_async_generator_await_resolve_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncGeneratorAwaitRejectClosure, 1);
+        isolate(), Builtin::kAsyncGeneratorAwaitRejectClosure, 1);
     set_async_generator_await_reject_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncGeneratorYieldResolveClosure, 1);
+        isolate(), Builtin::kAsyncGeneratorYieldResolveClosure, 1);
     set_async_generator_yield_resolve_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncGeneratorReturnResolveClosure, 1);
+        isolate(), Builtin::kAsyncGeneratorReturnResolveClosure, 1);
     set_async_generator_return_resolve_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncGeneratorReturnClosedResolveClosure, 1);
+        isolate(), Builtin::kAsyncGeneratorReturnClosedResolveClosure, 1);
     set_async_generator_return_closed_resolve_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate(), Builtins::kAsyncGeneratorReturnClosedRejectClosure, 1);
+        isolate(), Builtin::kAsyncGeneratorReturnClosedRejectClosure, 1);
     set_async_generator_return_closed_reject_shared_fun(*info);
   }
 
   // AsyncIterator:
   {
     Handle<SharedFunctionInfo> info = CreateSharedFunctionInfo(
-        isolate_, Builtins::kAsyncIteratorValueUnwrap, 1);
+        isolate_, Builtin::kAsyncIteratorValueUnwrap, 1);
     set_async_iterator_value_unwrap_shared_fun(*info);
   }
 
   // Promises:
   {
     Handle<SharedFunctionInfo> info = CreateSharedFunctionInfo(
-        isolate_, Builtins::kPromiseCapabilityDefaultResolve, 1,
+        isolate_, Builtin::kPromiseCapabilityDefaultResolve, 1,
         FunctionKind::kConciseMethod);
     info->set_native(true);
     info->set_function_map_index(
@@ -971,62 +971,62 @@ void Heap::CreateInitialObjects() {
     set_promise_capability_default_resolve_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(isolate_,
-                                    Builtins::kPromiseCapabilityDefaultReject,
-                                    1, FunctionKind::kConciseMethod);
+                                    Builtin::kPromiseCapabilityDefaultReject, 1,
+                                    FunctionKind::kConciseMethod);
     info->set_native(true);
     info->set_function_map_index(
         Context::STRICT_FUNCTION_WITHOUT_PROTOTYPE_MAP_INDEX);
     set_promise_capability_default_reject_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate_, Builtins::kPromiseGetCapabilitiesExecutor, 2);
+        isolate_, Builtin::kPromiseGetCapabilitiesExecutor, 2);
     set_promise_get_capabilities_executor_shared_fun(*info);
   }
 
   // Promises / finally:
   {
     Handle<SharedFunctionInfo> info =
-        CreateSharedFunctionInfo(isolate(), Builtins::kPromiseThenFinally, 1);
+        CreateSharedFunctionInfo(isolate(), Builtin::kPromiseThenFinally, 1);
     info->set_native(true);
     set_promise_then_finally_shared_fun(*info);
 
     info =
-        CreateSharedFunctionInfo(isolate(), Builtins::kPromiseCatchFinally, 1);
+        CreateSharedFunctionInfo(isolate(), Builtin::kPromiseCatchFinally, 1);
     info->set_native(true);
     set_promise_catch_finally_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(isolate(),
-                                    Builtins::kPromiseValueThunkFinally, 0);
+                                    Builtin::kPromiseValueThunkFinally, 0);
     set_promise_value_thunk_finally_shared_fun(*info);
 
-    info = CreateSharedFunctionInfo(isolate(), Builtins::kPromiseThrowerFinally,
-                                    0);
+    info =
+        CreateSharedFunctionInfo(isolate(), Builtin::kPromiseThrowerFinally, 0);
     set_promise_thrower_finally_shared_fun(*info);
   }
 
   // Promise combinators:
   {
     Handle<SharedFunctionInfo> info = CreateSharedFunctionInfo(
-        isolate_, Builtins::kPromiseAllResolveElementClosure, 1);
+        isolate_, Builtin::kPromiseAllResolveElementClosure, 1);
     set_promise_all_resolve_element_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate_, Builtins::kPromiseAllSettledResolveElementClosure, 1);
+        isolate_, Builtin::kPromiseAllSettledResolveElementClosure, 1);
     set_promise_all_settled_resolve_element_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate_, Builtins::kPromiseAllSettledRejectElementClosure, 1);
+        isolate_, Builtin::kPromiseAllSettledRejectElementClosure, 1);
     set_promise_all_settled_reject_element_shared_fun(*info);
 
     info = CreateSharedFunctionInfo(
-        isolate_, Builtins::kPromiseAnyRejectElementClosure, 1);
+        isolate_, Builtin::kPromiseAnyRejectElementClosure, 1);
     set_promise_any_reject_element_shared_fun(*info);
   }
 
   // ProxyRevoke:
   {
     Handle<SharedFunctionInfo> info =
-        CreateSharedFunctionInfo(isolate_, Builtins::kProxyRevoke, 0);
+        CreateSharedFunctionInfo(isolate_, Builtin::kProxyRevoke, 0);
     set_proxy_revoke_shared_fun(*info);
   }
 }
diff --git a/src/ic/accessor-assembler.cc b/src/ic/accessor-assembler.cc
index 65e4a688a63..13fbb9b8fb1 100644
--- a/src/ic/accessor-assembler.cc
+++ b/src/ic/accessor-assembler.cc
@@ -181,7 +181,7 @@ void AccessorAssembler::TryMegaDOMCase(TNode<Object> lookup_start_object,
   // TODO(gsathya): This builtin throws an exception on interface check fail but
   // we should miss to the runtime.
   exit_point->Return(
-      CallBuiltin(Builtins::kCallFunctionTemplate_CheckCompatibleReceiver,
+      CallBuiltin(Builtin::kCallFunctionTemplate_CheckCompatibleReceiver,
                   context, getter, IntPtrConstant(0), lookup_start_object));
 }
 
@@ -770,7 +770,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerLoadNamedCase(
 
       BIND(&if_unique_name);
       exit_point->ReturnCallStub(
-          Builtins::CallableFor(isolate(), Builtins::kProxyGetProperty),
+          Builtins::CallableFor(isolate(), Builtin::kProxyGetProperty),
           p->context(), holder, var_unique.value(), p->receiver(),
           SmiConstant(on_nonexistent));
 
@@ -787,7 +787,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerLoadNamedCase(
                                     p->receiver(), SmiConstant(on_nonexistent));
     } else {
       exit_point->ReturnCallStub(
-          Builtins::CallableFor(isolate(), Builtins::kProxyGetProperty),
+          Builtins::CallableFor(isolate(), Builtin::kProxyGetProperty),
           p->context(), holder, p->name(), p->receiver(),
           SmiConstant(on_nonexistent));
     }
@@ -913,7 +913,7 @@ void AccessorAssembler::HandleLoadICSmiHandlerHasNamedCase(
                 WordEqual(handler_kind,
                           IntPtrConstant(LoadHandler::kModuleExport)))));
     exit_point->ReturnCallStub(
-        Builtins::CallableFor(isolate(), Builtins::kHasProperty), p->context(),
+        Builtins::CallableFor(isolate(), Builtin::kHasProperty), p->context(),
         p->receiver(), p->name());
   }
 
@@ -1895,7 +1895,7 @@ void AccessorAssembler::HandleStoreToProxy(const StoreICParameters* p,
               &to_name_failed);
 
     BIND(&if_unique_name);
-    CallBuiltin(Builtins::kProxySetProperty, p->context(), proxy,
+    CallBuiltin(Builtin::kProxySetProperty, p->context(), proxy,
                 var_unique.value(), p->value(), p->receiver());
     Return(p->value());
 
@@ -1909,9 +1909,8 @@ void AccessorAssembler::HandleStoreToProxy(const StoreICParameters* p,
     TailCallRuntime(Runtime::kSetPropertyWithReceiver, p->context(), proxy,
                     p->name(), p->value(), p->receiver());
   } else {
-    TNode<Object> name =
-        CallBuiltin(Builtins::kToName, p->context(), p->name());
-    TailCallBuiltin(Builtins::kProxySetProperty, p->context(), proxy, name,
+    TNode<Object> name = CallBuiltin(Builtin::kToName, p->context(), p->name());
+    TailCallBuiltin(Builtin::kProxySetProperty, p->context(), proxy, name,
                     p->value(), p->receiver());
   }
 }
@@ -2580,7 +2579,7 @@ void AccessorAssembler::GenericElementLoad(
     TNode<IntPtrT> length = LoadStringLengthAsWord(CAST(lookup_start_object));
     GotoIfNot(UintPtrLessThan(index, length), slow);
     IncrementCounter(isolate()->counters()->ic_keyed_load_generic_smi(), 1);
-    TailCallBuiltin(Builtins::kStringCharAt, NoContextConstant(),
+    TailCallBuiltin(Builtin::kStringCharAt, NoContextConstant(),
                     lookup_start_object, index);
   }
 
@@ -2763,7 +2762,7 @@ void AccessorAssembler::GenericPropertyLoad(
     GotoIf(IsPrivateSymbol(name), slow);
 
     direct_exit.ReturnCallStub(
-        Builtins::CallableFor(isolate(), Builtins::kProxyGetProperty),
+        Builtins::CallableFor(isolate(), Builtin::kProxyGetProperty),
         p->context(), lookup_start_object, name, p->receiver(),
         SmiConstant(OnNonExistent::kReturnUndefined));
   }
@@ -2942,8 +2941,7 @@ void AccessorAssembler::LoadIC_BytecodeHandler(const LazyLoadICParameters* p,
     Comment("LoadIC_BytecodeHandler_noninlined");
 
     // Call into the stub that implements the non-inlined parts of LoadIC.
-    Callable ic =
-        Builtins::CallableFor(isolate(), Builtins::kLoadIC_Noninlined);
+    Callable ic = Builtins::CallableFor(isolate(), Builtin::kLoadIC_Noninlined);
     TNode<Code> code_target = HeapConstant(ic.code());
     exit_point->ReturnCallStub(ic.descriptor(), code_target, p->context(),
                                p->receiver_and_lookup_start_object(), p->name(),
@@ -2955,7 +2953,7 @@ void AccessorAssembler::LoadIC_BytecodeHandler(const LazyLoadICParameters* p,
     Comment("LoadIC_BytecodeHandler_nofeedback");
     // Call into the stub that implements the non-inlined parts of LoadIC.
     exit_point->ReturnCallStub(
-        Builtins::CallableFor(isolate(), Builtins::kLoadIC_NoFeedback),
+        Builtins::CallableFor(isolate(), Builtin::kLoadIC_NoFeedback),
         p->context(), p->receiver(), p->name(),
         SmiConstant(FeedbackSlotKind::kLoadProperty));
   }
@@ -3018,7 +3016,7 @@ void AccessorAssembler::LoadIC(const LoadICParameters* p) {
     Comment("LoadIC_nofeedback");
     // Call into the stub that implements the non-inlined parts of LoadIC.
     direct_exit.ReturnCallStub(
-        Builtins::CallableFor(isolate(), Builtins::kLoadIC_NoFeedback),
+        Builtins::CallableFor(isolate(), Builtin::kLoadIC_NoFeedback),
         p->context(), p->receiver(), p->name(),
         SmiConstant(FeedbackSlotKind::kLoadProperty));
   }
@@ -3212,7 +3210,7 @@ void AccessorAssembler::LoadGlobalIC(TNode<HeapObject> maybe_feedback_vector,
                              ? FeedbackSlotKind::kLoadGlobalInsideTypeof
                              : FeedbackSlotKind::kLoadGlobalNotInsideTypeof);
     exit_point->ReturnCallStub(
-        Builtins::CallableFor(isolate(), Builtins::kLoadGlobalIC_NoFeedback),
+        Builtins::CallableFor(isolate(), Builtin::kLoadGlobalIC_NoFeedback),
         lazy_context(), lazy_name(), SmiConstant(ic_kind));
   }
 }
@@ -3335,7 +3333,7 @@ void AccessorAssembler::LoadGlobalIC_NoFeedback(TNode<Context> context,
   BIND(&regular_load);
   TNode<JSGlobalObject> global_object =
       CAST(LoadContextElement(native_context, Context::EXTENSION_INDEX));
-  TailCallStub(Builtins::CallableFor(isolate(), Builtins::kLoadIC_NoFeedback),
+  TailCallStub(Builtins::CallableFor(isolate(), Builtin::kLoadIC_NoFeedback),
                context, global_object, name, smi_typeof_mode);
 }
 
@@ -3390,11 +3388,10 @@ void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p,
   BIND(&generic);
   {
     // TODO(jkummerow): Inline this? Or some of it?
-    TailCallBuiltin(access_mode == LoadAccessMode::kLoad
-                        ? Builtins::kKeyedLoadIC_Megamorphic
-                        : Builtins::kKeyedHasIC_Megamorphic,
-                    p->context(), p->receiver(), p->name(), p->slot(),
-                    p->vector());
+    TailCallBuiltin(
+        access_mode == LoadAccessMode::kLoad ? Builtin::kKeyedLoadIC_Megamorphic
+                                             : Builtin::kKeyedHasIC_Megamorphic,
+        p->context(), p->receiver(), p->name(), p->slot(), p->vector());
   }
 
   BIND(&try_uninitialized);
@@ -3447,8 +3444,8 @@ void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p,
       // If the name comparison succeeded, we know we have a weak fixed array
       // with at least one map/handler pair.
       TailCallBuiltin(access_mode == LoadAccessMode::kLoad
-                          ? Builtins::kKeyedLoadIC_PolymorphicName
-                          : Builtins::kKeyedHasIC_PolymorphicName,
+                          ? Builtin::kKeyedLoadIC_PolymorphicName
+                          : Builtin::kKeyedHasIC_PolymorphicName,
                       p->context(), p->receiver(), var_name.value(), p->slot(),
                       p->vector());
     }
@@ -3492,7 +3489,7 @@ void AccessorAssembler::KeyedLoadICGeneric(const LoadICParameters* p) {
 
     BIND(&if_other);
     {
-      var_name = CallBuiltin(Builtins::kToName, p->context(), var_name.value());
+      var_name = CallBuiltin(Builtin::kToName, p->context(), var_name.value());
       TryToName(var_name.value(), &if_index, &var_index, &if_unique_name,
                 &var_unique, &if_runtime, &if_notunique);
     }
@@ -3641,7 +3638,7 @@ void AccessorAssembler::StoreIC(const StoreICParameters* p) {
 
   BIND(&no_feedback);
   {
-    TailCallBuiltin(Builtins::kStoreIC_NoFeedback, p->context(), p->receiver(),
+    TailCallBuiltin(Builtin::kStoreIC_NoFeedback, p->context(), p->receiver(),
                     p->name(), p->value(), p->slot());
   }
 
@@ -3832,7 +3829,7 @@ void AccessorAssembler::KeyedStoreIC(const StoreICParameters* p) {
 
     BIND(&no_feedback);
     {
-      TailCallBuiltin(Builtins::kKeyedStoreIC_Megamorphic, p->context(),
+      TailCallBuiltin(Builtin::kKeyedStoreIC_Megamorphic, p->context(),
                       p->receiver(), p->name(), p->value(), p->slot());
     }
 
@@ -3950,8 +3947,8 @@ void AccessorAssembler::StoreInArrayLiteralIC(const StoreICParameters* p) {
   BIND(&no_feedback);
   {
     Comment("StoreInArrayLiteralIC_NoFeedback");
-    TailCallBuiltin(Builtins::kSetPropertyInLiteral, p->context(),
-                    p->receiver(), p->name(), p->value());
+    TailCallBuiltin(Builtin::kSetPropertyInLiteral, p->context(), p->receiver(),
+                    p->name(), p->value());
   }
 
   BIND(&miss);
@@ -4068,7 +4065,7 @@ void AccessorAssembler::GenerateLoadICTrampoline() {
   auto context = Parameter<Context>(Descriptor::kContext);
   TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
 
-  TailCallBuiltin(Builtins::kLoadIC, context, receiver, name, slot, vector);
+  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
 }
 
 void AccessorAssembler::GenerateLoadICBaseline() {
@@ -4080,7 +4077,7 @@ void AccessorAssembler::GenerateLoadICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kLoadIC, context, receiver, name, slot, vector);
+  TailCallBuiltin(Builtin::kLoadIC, context, receiver, name, slot, vector);
 }
 
 void AccessorAssembler::GenerateLoadICTrampoline_Megamorphic() {
@@ -4092,7 +4089,7 @@ void AccessorAssembler::GenerateLoadICTrampoline_Megamorphic() {
   auto context = Parameter<Context>(Descriptor::kContext);
   TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
 
-  TailCallBuiltin(Builtins::kLoadIC_Megamorphic, context, receiver, name, slot,
+  TailCallBuiltin(Builtin::kLoadIC_Megamorphic, context, receiver, name, slot,
                   vector);
 }
 
@@ -4121,8 +4118,8 @@ void AccessorAssembler::GenerateLoadSuperICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kLoadSuperIC, context, receiver,
-                  lookup_start_object, name, slot, vector);
+  TailCallBuiltin(Builtin::kLoadSuperIC, context, receiver, lookup_start_object,
+                  name, slot, vector);
 }
 
 void AccessorAssembler::GenerateLoadGlobalIC_NoFeedback() {
@@ -4275,8 +4272,7 @@ void AccessorAssembler::GenerateKeyedLoadICTrampoline() {
   auto context = Parameter<Context>(Descriptor::kContext);
   TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
 
-  TailCallBuiltin(Builtins::kKeyedLoadIC, context, receiver, name, slot,
-                  vector);
+  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
 }
 
 void AccessorAssembler::GenerateKeyedLoadICBaseline() {
@@ -4288,8 +4284,7 @@ void AccessorAssembler::GenerateKeyedLoadICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kKeyedLoadIC, context, receiver, name, slot,
-                  vector);
+  TailCallBuiltin(Builtin::kKeyedLoadIC, context, receiver, name, slot, vector);
 }
 
 void AccessorAssembler::GenerateKeyedLoadICTrampoline_Megamorphic() {
@@ -4301,7 +4296,7 @@ void AccessorAssembler::GenerateKeyedLoadICTrampoline_Megamorphic() {
   auto context = Parameter<Context>(Descriptor::kContext);
   TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
 
-  TailCallBuiltin(Builtins::kKeyedLoadIC_Megamorphic, context, receiver, name,
+  TailCallBuiltin(Builtin::kKeyedLoadIC_Megamorphic, context, receiver, name,
                   slot, vector);
 }
 
@@ -4340,7 +4335,7 @@ void AccessorAssembler::GenerateStoreGlobalICTrampoline() {
   auto context = Parameter<Context>(Descriptor::kContext);
   TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
 
-  TailCallBuiltin(Builtins::kStoreGlobalIC, context, name, value, slot, vector);
+  TailCallBuiltin(Builtin::kStoreGlobalIC, context, name, value, slot, vector);
 }
 
 void AccessorAssembler::GenerateStoreGlobalICBaseline() {
@@ -4352,7 +4347,7 @@ void AccessorAssembler::GenerateStoreGlobalICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kStoreGlobalIC, context, name, value, slot, vector);
+  TailCallBuiltin(Builtin::kStoreGlobalIC, context, name, value, slot, vector);
 }
 
 void AccessorAssembler::GenerateStoreIC() {
@@ -4379,7 +4374,7 @@ void AccessorAssembler::GenerateStoreICTrampoline() {
   auto context = Parameter<Context>(Descriptor::kContext);
   TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
 
-  TailCallBuiltin(Builtins::kStoreIC, context, receiver, name, value, slot,
+  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
                   vector);
 }
 
@@ -4393,7 +4388,7 @@ void AccessorAssembler::GenerateStoreICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kStoreIC, context, receiver, name, value, slot,
+  TailCallBuiltin(Builtin::kStoreIC, context, receiver, name, value, slot,
                   vector);
 }
 
@@ -4421,7 +4416,7 @@ void AccessorAssembler::GenerateKeyedStoreICTrampoline() {
   auto context = Parameter<Context>(Descriptor::kContext);
   TNode<FeedbackVector> vector = LoadFeedbackVectorForStub();
 
-  TailCallBuiltin(Builtins::kKeyedStoreIC, context, receiver, name, value, slot,
+  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
                   vector);
 }
 
@@ -4435,7 +4430,7 @@ void AccessorAssembler::GenerateKeyedStoreICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kKeyedStoreIC, context, receiver, name, value, slot,
+  TailCallBuiltin(Builtin::kKeyedStoreIC, context, receiver, name, value, slot,
                   vector);
 }
 
@@ -4464,8 +4459,8 @@ void AccessorAssembler::GenerateStoreInArrayLiteralICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kStoreInArrayLiteralIC, context, array, index,
-                  value, slot, vector);
+  TailCallBuiltin(Builtin::kStoreInArrayLiteralIC, context, array, index, value,
+                  slot, vector);
 }
 
 void AccessorAssembler::GenerateCloneObjectIC_Slow() {
@@ -4531,7 +4526,7 @@ void AccessorAssembler::GenerateCloneObjectICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kCloneObjectIC, context, source, flags, slot,
+  TailCallBuiltin(Builtin::kCloneObjectIC, context, source, flags, slot,
                   vector);
 }
 
@@ -4664,7 +4659,7 @@ void AccessorAssembler::GenerateCloneObjectIC() {
 
   BIND(&slow);
   {
-    TailCallBuiltin(Builtins::kCloneObjectIC_Slow, context, source, flags, slot,
+    TailCallBuiltin(Builtin::kCloneObjectIC_Slow, context, source, flags, slot,
                     maybe_vector);
   }
 
@@ -4703,7 +4698,7 @@ void AccessorAssembler::GenerateKeyedHasICBaseline() {
   TNode<FeedbackVector> vector = LoadFeedbackVectorFromBaseline();
   TNode<Context> context = LoadContextFromBaseline();
 
-  TailCallBuiltin(Builtins::kKeyedHasIC, context, receiver, name, slot, vector);
+  TailCallBuiltin(Builtin::kKeyedHasIC, context, receiver, name, slot, vector);
 }
 
 void AccessorAssembler::GenerateKeyedHasIC_Megamorphic() {
diff --git a/src/ic/binary-op-assembler.cc b/src/ic/binary-op-assembler.cc
index 3c0fc420ee5..4a97b5f902a 100644
--- a/src/ic/binary-op-assembler.cc
+++ b/src/ic/binary-op-assembler.cc
@@ -173,7 +173,7 @@ TNode<Object> BinaryOpAssembler::Generate_AddWithFeedback(
         UpdateFeedback(var_type_feedback.value(), maybe_feedback_vector(),
                        slot_id, update_feedback_mode);
         var_result =
-            CallBuiltin(Builtins::kStringAdd_CheckNone, context(), lhs, rhs);
+            CallBuiltin(Builtin::kStringAdd_CheckNone, context(), lhs, rhs);
 
         Goto(&end);
       }
@@ -195,7 +195,7 @@ TNode<Object> BinaryOpAssembler::Generate_AddWithFeedback(
   {
     // Both {lhs} and {rhs} are of BigInt type.
     Label bigint_too_big(this);
-    var_result = CallBuiltin(Builtins::kBigIntAddNoThrow, context(), lhs, rhs);
+    var_result = CallBuiltin(Builtin::kBigIntAddNoThrow, context(), lhs, rhs);
     // Check for sentinel that signals BigIntTooBig exception.
     GotoIf(TaggedIsSmi(var_result.value()), &bigint_too_big);
 
@@ -229,7 +229,7 @@ TNode<Object> BinaryOpAssembler::Generate_AddWithFeedback(
   {
     UpdateFeedback(var_type_feedback.value(), maybe_feedback_vector(), slot_id,
                    update_feedback_mode);
-    var_result = CallBuiltin(Builtins::kAdd, context(), lhs, rhs);
+    var_result = CallBuiltin(Builtin::kAdd, context(), lhs, rhs);
     Goto(&end);
   }
 
@@ -402,7 +402,7 @@ TNode<Object> BinaryOpAssembler::Generate_BinaryOperationWithFeedback(
     if (op == Operation::kSubtract) {
       Label bigint_too_big(this);
       var_result =
-          CallBuiltin(Builtins::kBigIntSubtractNoThrow, context(), lhs, rhs);
+          CallBuiltin(Builtin::kBigIntSubtractNoThrow, context(), lhs, rhs);
 
       // Check for sentinel that signals BigIntTooBig exception.
       GotoIf(TaggedIsSmi(var_result.value()), &bigint_too_big);
@@ -435,16 +435,16 @@ TNode<Object> BinaryOpAssembler::Generate_BinaryOperationWithFeedback(
     TNode<Object> result;
     switch (op) {
       case Operation::kSubtract:
-        result = CallBuiltin(Builtins::kSubtract, context(), lhs, rhs);
+        result = CallBuiltin(Builtin::kSubtract, context(), lhs, rhs);
         break;
       case Operation::kMultiply:
-        result = CallBuiltin(Builtins::kMultiply, context(), lhs, rhs);
+        result = CallBuiltin(Builtin::kMultiply, context(), lhs, rhs);
         break;
       case Operation::kDivide:
-        result = CallBuiltin(Builtins::kDivide, context(), lhs, rhs);
+        result = CallBuiltin(Builtin::kDivide, context(), lhs, rhs);
         break;
       case Operation::kModulus:
-        result = CallBuiltin(Builtins::kModulus, context(), lhs, rhs);
+        result = CallBuiltin(Builtin::kModulus, context(), lhs, rhs);
         break;
       default:
         UNREACHABLE();
@@ -580,7 +580,7 @@ TNode<Object> BinaryOpAssembler::Generate_ExponentiateWithFeedback(
   TNode<Smi> dummy_feedback = SmiConstant(BinaryOperationFeedback::kAny);
   UpdateFeedback(dummy_feedback, maybe_feedback_vector(), slot_id,
                  update_feedback_mode);
-  return CallBuiltin(Builtins::kExponentiate, context(), base, exponent);
+  return CallBuiltin(Builtin::kExponentiate, context(), base, exponent);
 }
 
 TNode<Object> BinaryOpAssembler::Generate_BitwiseBinaryOpWithOptionalFeedback(
diff --git a/src/ic/stub-cache.cc b/src/ic/stub-cache.cc
index cf276ea040f..0510f684772 100644
--- a/src/ic/stub-cache.cc
+++ b/src/ic/stub-cache.cc
@@ -89,7 +89,7 @@ void StubCache::Set(Name name, Map map, MaybeObject handler) {
   // If the primary entry has useful data in it, we retire it to the
   // secondary cache before overwriting it.
   if (old_handler != MaybeObject::FromObject(
-                         isolate()->builtins()->builtin(Builtins::kIllegal)) &&
+                         isolate()->builtins()->builtin(Builtin::kIllegal)) &&
       !primary->map.IsSmi()) {
     Map old_map =
         Map::cast(StrongTaggedValue::ToObject(isolate(), primary->map));
@@ -125,8 +125,8 @@ MaybeObject StubCache::Get(Name name, Map map) {
 }
 
 void StubCache::Clear() {
-  MaybeObject empty = MaybeObject::FromObject(
-      isolate_->builtins()->builtin(Builtins::kIllegal));
+  MaybeObject empty =
+      MaybeObject::FromObject(isolate_->builtins()->builtin(Builtin::kIllegal));
   Name empty_string = ReadOnlyRoots(isolate()).empty_string();
   for (int i = 0; i < kPrimaryTableSize; i++) {
     primary_[i].key = StrongTaggedValue(empty_string);
diff --git a/src/ic/unary-op-assembler.cc b/src/ic/unary-op-assembler.cc
index 4308f561a76..97ce0cf48d2 100644
--- a/src/ic/unary-op-assembler.cc
+++ b/src/ic/unary-op-assembler.cc
@@ -198,7 +198,7 @@ class UnaryOpAssemblerImpl final : public CodeStubAssembler {
         CSA_ASSERT(this, SmiEqual(var_feedback.value(),
                                   SmiConstant(BinaryOperationFeedback::kNone)));
         OverwriteFeedback(&var_feedback, BinaryOperationFeedback::kAny);
-        var_value = CallBuiltin(Builtins::kNonNumberToNumeric, context,
+        var_value = CallBuiltin(Builtin::kNonNumberToNumeric, context,
                                 value_heap_object);
         Goto(&start);
       }
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index 58ac5aaa581..9a1abc59293 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -381,7 +381,7 @@ void Bootstrapper::DetachGlobal(Handle<Context> env) {
 namespace {
 
 #ifdef DEBUG
-bool IsFunctionMapOrSpecialBuiltin(Handle<Map> map, Builtins::Name builtin_id,
+bool IsFunctionMapOrSpecialBuiltin(Handle<Map> map, Builtin builtin_id,
                                    Handle<Context> context) {
   // During bootstrapping some of these maps could be not created yet.
   return ((*map == context->get(Context::STRICT_FUNCTION_MAP_INDEX)) ||
@@ -392,14 +392,15 @@ bool IsFunctionMapOrSpecialBuiltin(Handle<Map> map, Builtins::Name builtin_id,
                Context::STRICT_FUNCTION_WITH_READONLY_PROTOTYPE_MAP_INDEX)) ||
           // Check if it's a creation of an empty or Proxy function during
           // bootstrapping.
-          (builtin_id == Builtins::kEmptyFunction ||
-           builtin_id == Builtins::kProxyConstructor));
+          (builtin_id == Builtin::kEmptyFunction ||
+           builtin_id == Builtin::kProxyConstructor));
 }
 #endif  // DEBUG
 
-V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltin(
-    Isolate* isolate, Handle<String> name, Handle<Map> map,
-    Builtins::Name builtin_id) {
+V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltin(Isolate* isolate,
+                                                        Handle<String> name,
+                                                        Handle<Map> map,
+                                                        Builtin builtin_id) {
   Factory* factory = isolate->factory();
   Handle<NativeContext> context(isolate->native_context());
   DCHECK(IsFunctionMapOrSpecialBuiltin(map, builtin_id, context));
@@ -414,7 +415,7 @@ V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltin(
 }
 
 V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithPrototype(
-    Isolate* isolate, Handle<String> name, Builtins::Name builtin_id,
+    Isolate* isolate, Handle<String> name, Builtin builtin_id,
     Handle<HeapObject> prototype, InstanceType type, int instance_size,
     int inobject_properties, MutableMode prototype_mutability) {
   Factory* factory = isolate->factory();
@@ -459,7 +460,7 @@ V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithPrototype(
 }
 
 V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithoutPrototype(
-    Isolate* isolate, Handle<String> name, Builtins::Name builtin_id) {
+    Isolate* isolate, Handle<String> name, Builtin builtin_id) {
   Factory* factory = isolate->factory();
   Handle<NativeContext> context(isolate->native_context());
   Handle<Map> map = isolate->strict_function_without_prototype_map();
@@ -476,8 +477,7 @@ V8_NOINLINE Handle<JSFunction> CreateFunctionForBuiltinWithoutPrototype(
 
 V8_NOINLINE Handle<JSFunction> CreateFunction(
     Isolate* isolate, Handle<String> name, InstanceType type, int instance_size,
-    int inobject_properties, Handle<HeapObject> prototype,
-    Builtins::Name builtin_id) {
+    int inobject_properties, Handle<HeapObject> prototype, Builtin builtin_id) {
   DCHECK(Builtins::HasJSLinkage(builtin_id));
 
   Handle<JSFunction> result = CreateFunctionForBuiltinWithPrototype(
@@ -496,8 +496,7 @@ V8_NOINLINE Handle<JSFunction> CreateFunction(
 
 V8_NOINLINE Handle<JSFunction> CreateFunction(
     Isolate* isolate, const char* name, InstanceType type, int instance_size,
-    int inobject_properties, Handle<HeapObject> prototype,
-    Builtins::Name builtin_id) {
+    int inobject_properties, Handle<HeapObject> prototype, Builtin builtin_id) {
   return CreateFunction(
       isolate, isolate->factory()->InternalizeUtf8String(name), type,
       instance_size, inobject_properties, prototype, builtin_id);
@@ -506,7 +505,7 @@ V8_NOINLINE Handle<JSFunction> CreateFunction(
 V8_NOINLINE Handle<JSFunction> InstallFunction(
     Isolate* isolate, Handle<JSObject> target, Handle<String> name,
     InstanceType type, int instance_size, int inobject_properties,
-    Handle<HeapObject> prototype, Builtins::Name call) {
+    Handle<HeapObject> prototype, Builtin call) {
   DCHECK(Builtins::HasJSLinkage(call));
   Handle<JSFunction> function = CreateFunction(
       isolate, name, type, instance_size, inobject_properties, prototype, call);
@@ -517,7 +516,7 @@ V8_NOINLINE Handle<JSFunction> InstallFunction(
 V8_NOINLINE Handle<JSFunction> InstallFunction(
     Isolate* isolate, Handle<JSObject> target, const char* name,
     InstanceType type, int instance_size, int inobject_properties,
-    Handle<HeapObject> prototype, Builtins::Name call) {
+    Handle<HeapObject> prototype, Builtin call) {
   return InstallFunction(isolate, target,
                          isolate->factory()->InternalizeUtf8String(name), type,
                          instance_size, inobject_properties, prototype, call);
@@ -531,8 +530,7 @@ V8_NOINLINE Handle<JSFunction> InstallFunction(
 V8_NOINLINE Handle<JSFunction> InstallConstructor(
     Isolate* isolate, Handle<JSObject> target, const char* name,
     InstanceType type, int instance_size, int inobject_properties,
-    Handle<HeapObject> prototype, Builtins::Name call,
-    InstanceType constructor_type) {
+    Handle<HeapObject> prototype, Builtin call, InstanceType constructor_type) {
   Handle<JSFunction> function = InstallFunction(
       isolate, target, isolate->factory()->InternalizeUtf8String(name), type,
       instance_size, inobject_properties, prototype, call);
@@ -543,8 +541,8 @@ V8_NOINLINE Handle<JSFunction> InstallConstructor(
 
 V8_NOINLINE Handle<JSFunction> SimpleCreateFunction(Isolate* isolate,
                                                     Handle<String> name,
-                                                    Builtins::Name call,
-                                                    int len, bool adapt) {
+                                                    Builtin call, int len,
+                                                    bool adapt) {
   DCHECK(Builtins::HasJSLinkage(call));
   name = String::Flatten(isolate, name, AllocationType::kOld);
   Handle<JSFunction> fun =
@@ -563,8 +561,8 @@ V8_NOINLINE Handle<JSFunction> SimpleCreateFunction(Isolate* isolate,
 }
 
 V8_NOINLINE Handle<JSFunction> InstallFunctionWithBuiltinId(
-    Isolate* isolate, Handle<JSObject> base, const char* name,
-    Builtins::Name call, int len, bool adapt) {
+    Isolate* isolate, Handle<JSObject> base, const char* name, Builtin call,
+    int len, bool adapt) {
   Handle<String> internalized_name =
       isolate->factory()->InternalizeUtf8String(name);
   Handle<JSFunction> fun =
@@ -574,9 +572,8 @@ V8_NOINLINE Handle<JSFunction> InstallFunctionWithBuiltinId(
 }
 
 V8_NOINLINE Handle<JSFunction> SimpleInstallFunction(
-    Isolate* isolate, Handle<JSObject> base, const char* name,
-    Builtins::Name call, int len, bool adapt,
-    PropertyAttributes attrs = DONT_ENUM) {
+    Isolate* isolate, Handle<JSObject> base, const char* name, Builtin call,
+    int len, bool adapt, PropertyAttributes attrs = DONT_ENUM) {
   // Although function name does not have to be internalized the property name
   // will be internalized during property addition anyway, so do it here now.
   Handle<String> internalized_name =
@@ -589,7 +586,7 @@ V8_NOINLINE Handle<JSFunction> SimpleInstallFunction(
 
 V8_NOINLINE Handle<JSFunction> InstallFunctionAtSymbol(
     Isolate* isolate, Handle<JSObject> base, Handle<Symbol> symbol,
-    const char* symbol_string, Builtins::Name call, int len, bool adapt,
+    const char* symbol_string, Builtin call, int len, bool adapt,
     PropertyAttributes attrs = DONT_ENUM) {
   Handle<String> internalized_symbol =
       isolate->factory()->InternalizeUtf8String(symbol_string);
@@ -602,8 +599,8 @@ V8_NOINLINE Handle<JSFunction> InstallFunctionAtSymbol(
 V8_NOINLINE void SimpleInstallGetterSetter(Isolate* isolate,
                                            Handle<JSObject> base,
                                            Handle<String> name,
-                                           Builtins::Name call_getter,
-                                           Builtins::Name call_setter) {
+                                           Builtin call_getter,
+                                           Builtin call_setter) {
   Handle<String> getter_name =
       Name::ToFunctionName(isolate, name, isolate->factory()->get_string())
           .ToHandleChecked();
@@ -620,16 +617,18 @@ V8_NOINLINE void SimpleInstallGetterSetter(Isolate* isolate,
 }
 
 void SimpleInstallGetterSetter(Isolate* isolate, Handle<JSObject> base,
-                               const char* name, Builtins::Name call_getter,
-                               Builtins::Name call_setter) {
+                               const char* name, Builtin call_getter,
+                               Builtin call_setter) {
   SimpleInstallGetterSetter(isolate, base,
                             isolate->factory()->InternalizeUtf8String(name),
                             call_getter, call_setter);
 }
 
-V8_NOINLINE Handle<JSFunction> SimpleInstallGetter(
-    Isolate* isolate, Handle<JSObject> base, Handle<Name> name,
-    Handle<Name> property_name, Builtins::Name call, bool adapt) {
+V8_NOINLINE Handle<JSFunction> SimpleInstallGetter(Isolate* isolate,
+                                                   Handle<JSObject> base,
+                                                   Handle<Name> name,
+                                                   Handle<Name> property_name,
+                                                   Builtin call, bool adapt) {
   Handle<String> getter_name =
       Name::ToFunctionName(isolate, name, isolate->factory()->get_string())
           .ToHandleChecked();
@@ -647,8 +646,7 @@ V8_NOINLINE Handle<JSFunction> SimpleInstallGetter(
 V8_NOINLINE Handle<JSFunction> SimpleInstallGetter(Isolate* isolate,
                                                    Handle<JSObject> base,
                                                    Handle<Name> name,
-                                                   Builtins::Name call,
-                                                   bool adapt) {
+                                                   Builtin call, bool adapt) {
   return SimpleInstallGetter(isolate, base, name, name, call, adapt);
 }
 
@@ -673,7 +671,7 @@ V8_NOINLINE void InstallSpeciesGetter(Isolate* isolate,
   // TODO(adamk): We should be able to share a SharedFunctionInfo
   // between all these JSFunctins.
   SimpleInstallGetter(isolate, constructor, factory->symbol_species_string(),
-                      factory->species_symbol(), Builtins::kReturnReceiver,
+                      factory->species_symbol(), Builtin::kReturnReceiver,
                       true);
 }
 
@@ -703,7 +701,7 @@ Handle<JSFunction> Genesis::CreateEmptyFunction() {
   // ES#sec-properties-of-the-function-prototype-object
   Handle<JSFunction> empty_function =
       CreateFunctionForBuiltin(isolate(), factory()->empty_string(),
-                               empty_function_map, Builtins::kEmptyFunction);
+                               empty_function_map, Builtin::kEmptyFunction);
   native_context()->set_empty_function(*empty_function);
 
   // --- E m p t y ---
@@ -755,7 +753,7 @@ Handle<JSFunction> Genesis::GetThrowTypeErrorIntrinsic() {
   }
   Handle<String> name = factory()->empty_string();
   Handle<JSFunction> function = CreateFunctionForBuiltinWithoutPrototype(
-      isolate(), name, Builtins::kStrictPoisonPillThrower);
+      isolate(), name, Builtin::kStrictPoisonPillThrower);
   function->shared().DontAdaptArguments();
 
   // %ThrowTypeError% must have a name property with an empty string value. Per
@@ -835,7 +833,7 @@ void Genesis::CreateObjectFunction(Handle<JSFunction> empty_function) {
 
   Handle<JSFunction> object_fun = CreateFunction(
       isolate_, factory->Object_string(), JS_OBJECT_TYPE, instance_size,
-      inobject_properties, factory->null_value(), Builtins::kObjectConstructor);
+      inobject_properties, factory->null_value(), Builtin::kObjectConstructor);
   object_fun->shared().set_length(1);
   object_fun->shared().DontAdaptArguments();
   native_context()->set_object_function(*object_fun);
@@ -914,7 +912,7 @@ void Genesis::CreateIteratorMaps(Handle<JSFunction> empty) {
 
   InstallFunctionAtSymbol(isolate(), iterator_prototype,
                           factory()->iterator_symbol(), "[Symbol.iterator]",
-                          Builtins::kReturnReceiver, 0, true);
+                          Builtin::kReturnReceiver, 0, true);
   native_context()->set_initial_iterator_prototype(*iterator_prototype);
   CHECK_NE(iterator_prototype->map().ptr(),
            isolate_->initial_object_prototype()->map().ptr());
@@ -943,17 +941,17 @@ void Genesis::CreateIteratorMaps(Handle<JSFunction> empty) {
                         static_cast<PropertyAttributes>(DONT_ENUM | READ_ONLY));
   InstallToStringTag(isolate(), generator_object_prototype, "Generator");
   SimpleInstallFunction(isolate(), generator_object_prototype, "next",
-                        Builtins::kGeneratorPrototypeNext, 1, false);
+                        Builtin::kGeneratorPrototypeNext, 1, false);
   SimpleInstallFunction(isolate(), generator_object_prototype, "return",
-                        Builtins::kGeneratorPrototypeReturn, 1, false);
+                        Builtin::kGeneratorPrototypeReturn, 1, false);
   SimpleInstallFunction(isolate(), generator_object_prototype, "throw",
-                        Builtins::kGeneratorPrototypeThrow, 1, false);
+                        Builtin::kGeneratorPrototypeThrow, 1, false);
 
   // Internal version of generator_prototype_next, flagged as non-native such
   // that it doesn't show up in Error traces.
   Handle<JSFunction> generator_next_internal =
       SimpleCreateFunction(isolate(), factory()->next_string(),
-                           Builtins::kGeneratorPrototypeNext, 1, false);
+                           Builtin::kGeneratorPrototypeNext, 1, false);
   generator_next_internal->shared().set_native(false);
   native_context()->set_generator_next_internal(*generator_next_internal);
 
@@ -962,21 +960,21 @@ void Genesis::CreateIteratorMaps(Handle<JSFunction> empty) {
   {
     Handle<JSFunction> async_module_evaluate_internal =
         SimpleCreateFunction(isolate(), factory()->next_string(),
-                             Builtins::kAsyncModuleEvaluate, 1, false);
+                             Builtin::kAsyncModuleEvaluate, 1, false);
     async_module_evaluate_internal->shared().set_native(false);
     native_context()->set_async_module_evaluate_internal(
         *async_module_evaluate_internal);
 
     Handle<JSFunction> call_async_module_fulfilled =
         SimpleCreateFunction(isolate(), factory()->empty_string(),
-                             Builtins::kCallAsyncModuleFulfilled, 1, false);
+                             Builtin::kCallAsyncModuleFulfilled, 1, false);
     call_async_module_fulfilled->shared().set_native(false);
     native_context()->set_call_async_module_fulfilled(
         *call_async_module_fulfilled);
 
     Handle<JSFunction> call_async_module_rejected =
         SimpleCreateFunction(isolate(), factory()->empty_string(),
-                             Builtins::kCallAsyncModuleRejected, 1, false);
+                             Builtin::kCallAsyncModuleRejected, 1, false);
     call_async_module_rejected->shared().set_native(false);
     native_context()->set_call_async_module_rejected(
         *call_async_module_rejected);
@@ -1015,7 +1013,7 @@ void Genesis::CreateAsyncIteratorMaps(Handle<JSFunction> empty) {
 
   InstallFunctionAtSymbol(
       isolate(), async_iterator_prototype, factory()->async_iterator_symbol(),
-      "[Symbol.asyncIterator]", Builtins::kReturnReceiver, 0, true);
+      "[Symbol.asyncIterator]", Builtin::kReturnReceiver, 0, true);
   native_context()->set_initial_async_iterator_prototype(
       *async_iterator_prototype);
 
@@ -1024,13 +1022,12 @@ void Genesis::CreateAsyncIteratorMaps(Handle<JSFunction> empty) {
   Handle<JSObject> async_from_sync_iterator_prototype = factory()->NewJSObject(
       isolate()->object_function(), AllocationType::kOld);
   SimpleInstallFunction(isolate(), async_from_sync_iterator_prototype, "next",
-                        Builtins::kAsyncFromSyncIteratorPrototypeNext, 1,
-                        false);
+                        Builtin::kAsyncFromSyncIteratorPrototypeNext, 1, false);
   SimpleInstallFunction(isolate(), async_from_sync_iterator_prototype, "return",
-                        Builtins::kAsyncFromSyncIteratorPrototypeReturn, 1,
+                        Builtin::kAsyncFromSyncIteratorPrototypeReturn, 1,
                         false);
   SimpleInstallFunction(isolate(), async_from_sync_iterator_prototype, "throw",
-                        Builtins::kAsyncFromSyncIteratorPrototypeThrow, 1,
+                        Builtin::kAsyncFromSyncIteratorPrototypeThrow, 1,
                         false);
 
   InstallToStringTag(isolate(), async_from_sync_iterator_prototype,
@@ -1080,11 +1077,11 @@ void Genesis::CreateAsyncIteratorMaps(Handle<JSFunction> empty) {
   InstallToStringTag(isolate(), async_generator_object_prototype,
                      "AsyncGenerator");
   SimpleInstallFunction(isolate(), async_generator_object_prototype, "next",
-                        Builtins::kAsyncGeneratorPrototypeNext, 1, false);
+                        Builtin::kAsyncGeneratorPrototypeNext, 1, false);
   SimpleInstallFunction(isolate(), async_generator_object_prototype, "return",
-                        Builtins::kAsyncGeneratorPrototypeReturn, 1, false);
+                        Builtin::kAsyncGeneratorPrototypeReturn, 1, false);
   SimpleInstallFunction(isolate(), async_generator_object_prototype, "throw",
-                        Builtins::kAsyncGeneratorPrototypeThrow, 1, false);
+                        Builtin::kAsyncGeneratorPrototypeThrow, 1, false);
 
   // Create maps for generator functions and their prototypes.  Store those
   // maps in the native context. The "prototype" property descriptor is
@@ -1296,7 +1293,7 @@ Handle<JSGlobalObject> Genesis::CreateNewGlobals(
     Handle<JSObject> prototype =
         factory()->NewFunctionPrototype(isolate()->object_function());
     js_global_object_function = CreateFunctionForBuiltinWithPrototype(
-        isolate(), name, Builtins::kIllegal, prototype, JS_GLOBAL_OBJECT_TYPE,
+        isolate(), name, Builtin::kIllegal, prototype, JS_GLOBAL_OBJECT_TYPE,
         JSGlobalObject::kHeaderSize, 0, MUTABLE);
 #ifdef DEBUG
     LookupIterator it(isolate(), prototype, factory()->constructor_string(),
@@ -1326,7 +1323,7 @@ Handle<JSGlobalObject> Genesis::CreateNewGlobals(
   if (global_proxy_template.IsEmpty()) {
     Handle<String> name = factory()->empty_string();
     global_proxy_function = CreateFunctionForBuiltinWithPrototype(
-        isolate(), name, Builtins::kIllegal, factory()->the_hole_value(),
+        isolate(), name, Builtin::kIllegal, factory()->the_hole_value(),
         JS_GLOBAL_PROXY_TYPE, JSGlobalProxy::SizeWithEmbedderFields(0), 0,
         MUTABLE);
   } else {
@@ -1403,11 +1400,11 @@ static void InstallWithIntrinsicDefaultProto(Isolate* isolate,
                                  kReleaseStore);
 }
 
-static void InstallError(
-    Isolate* isolate, Handle<JSObject> global, Handle<String> name,
-    int context_index,
-    Builtins::Name error_constructor = Builtins::kErrorConstructor,
-    int error_function_length = 1, int in_object_properties = 2) {
+static void InstallError(Isolate* isolate, Handle<JSObject> global,
+                         Handle<String> name, int context_index,
+                         Builtin error_constructor = Builtin::kErrorConstructor,
+                         int error_function_length = 1,
+                         int in_object_properties = 2) {
   Factory* factory = isolate->factory();
 
   if (FLAG_harmony_error_cause) {
@@ -1425,7 +1422,7 @@ static void InstallError(
 
   if (context_index == Context::ERROR_FUNCTION_INDEX) {
     SimpleInstallFunction(isolate, error_fun, "captureStackTrace",
-                          Builtins::kErrorCaptureStackTrace, 2, false);
+                          Builtin::kErrorCaptureStackTrace, 2, false);
   }
 
   InstallWithIntrinsicDefaultProto(isolate, error_fun, context_index);
@@ -1448,7 +1445,7 @@ static void InstallError(
     if (context_index == Context::ERROR_FUNCTION_INDEX) {
       Handle<JSFunction> to_string_fun =
           SimpleInstallFunction(isolate, prototype, "toString",
-                                Builtins::kErrorPrototypeToString, 0, true);
+                                Builtin::kErrorPrototypeToString, 0, true);
       isolate->native_context()->set_error_to_string(*to_string_fun);
       isolate->native_context()->set_initial_error_prototype(*prototype);
     } else {
@@ -1539,95 +1536,95 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                           DONT_ENUM);
 
     SimpleInstallFunction(isolate_, object_function, "assign",
-                          Builtins::kObjectAssign, 2, false);
+                          Builtin::kObjectAssign, 2, false);
     SimpleInstallFunction(isolate_, object_function, "getOwnPropertyDescriptor",
-                          Builtins::kObjectGetOwnPropertyDescriptor, 2, false);
+                          Builtin::kObjectGetOwnPropertyDescriptor, 2, false);
     SimpleInstallFunction(isolate_, object_function,
                           "getOwnPropertyDescriptors",
-                          Builtins::kObjectGetOwnPropertyDescriptors, 1, false);
+                          Builtin::kObjectGetOwnPropertyDescriptors, 1, false);
     SimpleInstallFunction(isolate_, object_function, "getOwnPropertyNames",
-                          Builtins::kObjectGetOwnPropertyNames, 1, true);
+                          Builtin::kObjectGetOwnPropertyNames, 1, true);
     SimpleInstallFunction(isolate_, object_function, "getOwnPropertySymbols",
-                          Builtins::kObjectGetOwnPropertySymbols, 1, false);
-    SimpleInstallFunction(isolate_, object_function, "is", Builtins::kObjectIs,
+                          Builtin::kObjectGetOwnPropertySymbols, 1, false);
+    SimpleInstallFunction(isolate_, object_function, "is", Builtin::kObjectIs,
                           2, true);
     SimpleInstallFunction(isolate_, object_function, "preventExtensions",
-                          Builtins::kObjectPreventExtensions, 1, true);
+                          Builtin::kObjectPreventExtensions, 1, true);
     SimpleInstallFunction(isolate_, object_function, "seal",
-                          Builtins::kObjectSeal, 1, false);
+                          Builtin::kObjectSeal, 1, false);
 
     Handle<JSFunction> object_create = SimpleInstallFunction(
-        isolate_, object_function, "create", Builtins::kObjectCreate, 2, false);
+        isolate_, object_function, "create", Builtin::kObjectCreate, 2, false);
     native_context()->set_object_create(*object_create);
 
     SimpleInstallFunction(isolate_, object_function, "defineProperties",
-                          Builtins::kObjectDefineProperties, 2, true);
+                          Builtin::kObjectDefineProperties, 2, true);
 
     SimpleInstallFunction(isolate_, object_function, "defineProperty",
-                          Builtins::kObjectDefineProperty, 3, true);
+                          Builtin::kObjectDefineProperty, 3, true);
 
     SimpleInstallFunction(isolate_, object_function, "freeze",
-                          Builtins::kObjectFreeze, 1, false);
+                          Builtin::kObjectFreeze, 1, false);
 
     SimpleInstallFunction(isolate_, object_function, "getPrototypeOf",
-                          Builtins::kObjectGetPrototypeOf, 1, true);
+                          Builtin::kObjectGetPrototypeOf, 1, true);
     SimpleInstallFunction(isolate_, object_function, "setPrototypeOf",
-                          Builtins::kObjectSetPrototypeOf, 2, true);
+                          Builtin::kObjectSetPrototypeOf, 2, true);
 
     SimpleInstallFunction(isolate_, object_function, "isExtensible",
-                          Builtins::kObjectIsExtensible, 1, true);
+                          Builtin::kObjectIsExtensible, 1, true);
     SimpleInstallFunction(isolate_, object_function, "isFrozen",
-                          Builtins::kObjectIsFrozen, 1, false);
+                          Builtin::kObjectIsFrozen, 1, false);
 
     SimpleInstallFunction(isolate_, object_function, "isSealed",
-                          Builtins::kObjectIsSealed, 1, false);
+                          Builtin::kObjectIsSealed, 1, false);
 
     SimpleInstallFunction(isolate_, object_function, "keys",
-                          Builtins::kObjectKeys, 1, true);
+                          Builtin::kObjectKeys, 1, true);
     SimpleInstallFunction(isolate_, object_function, "entries",
-                          Builtins::kObjectEntries, 1, true);
+                          Builtin::kObjectEntries, 1, true);
     SimpleInstallFunction(isolate_, object_function, "fromEntries",
-                          Builtins::kObjectFromEntries, 1, false);
+                          Builtin::kObjectFromEntries, 1, false);
     SimpleInstallFunction(isolate_, object_function, "values",
-                          Builtins::kObjectValues, 1, true);
+                          Builtin::kObjectValues, 1, true);
 
     SimpleInstallFunction(isolate_, isolate_->initial_object_prototype(),
-                          "__defineGetter__", Builtins::kObjectDefineGetter, 2,
+                          "__defineGetter__", Builtin::kObjectDefineGetter, 2,
                           true);
     SimpleInstallFunction(isolate_, isolate_->initial_object_prototype(),
-                          "__defineSetter__", Builtins::kObjectDefineSetter, 2,
+                          "__defineSetter__", Builtin::kObjectDefineSetter, 2,
                           true);
     SimpleInstallFunction(isolate_, isolate_->initial_object_prototype(),
                           "hasOwnProperty",
-                          Builtins::kObjectPrototypeHasOwnProperty, 1, true);
+                          Builtin::kObjectPrototypeHasOwnProperty, 1, true);
     SimpleInstallFunction(isolate_, isolate_->initial_object_prototype(),
-                          "__lookupGetter__", Builtins::kObjectLookupGetter, 1,
+                          "__lookupGetter__", Builtin::kObjectLookupGetter, 1,
                           true);
     SimpleInstallFunction(isolate_, isolate_->initial_object_prototype(),
-                          "__lookupSetter__", Builtins::kObjectLookupSetter, 1,
+                          "__lookupSetter__", Builtin::kObjectLookupSetter, 1,
                           true);
     SimpleInstallFunction(isolate_, isolate_->initial_object_prototype(),
                           "isPrototypeOf",
-                          Builtins::kObjectPrototypeIsPrototypeOf, 1, true);
+                          Builtin::kObjectPrototypeIsPrototypeOf, 1, true);
     SimpleInstallFunction(
         isolate_, isolate_->initial_object_prototype(), "propertyIsEnumerable",
-        Builtins::kObjectPrototypePropertyIsEnumerable, 1, false);
+        Builtin::kObjectPrototypePropertyIsEnumerable, 1, false);
     Handle<JSFunction> object_to_string = SimpleInstallFunction(
         isolate_, isolate_->initial_object_prototype(), "toString",
-        Builtins::kObjectPrototypeToString, 0, true);
+        Builtin::kObjectPrototypeToString, 0, true);
     native_context()->set_object_to_string(*object_to_string);
     Handle<JSFunction> object_value_of = SimpleInstallFunction(
         isolate_, isolate_->initial_object_prototype(), "valueOf",
-        Builtins::kObjectPrototypeValueOf, 0, true);
+        Builtin::kObjectPrototypeValueOf, 0, true);
     native_context()->set_object_value_of_function(*object_value_of);
 
     SimpleInstallGetterSetter(
         isolate_, isolate_->initial_object_prototype(), factory->proto_string(),
-        Builtins::kObjectPrototypeGetProto, Builtins::kObjectPrototypeSetProto);
+        Builtin::kObjectPrototypeGetProto, Builtin::kObjectPrototypeSetProto);
 
     SimpleInstallFunction(isolate_, isolate_->initial_object_prototype(),
                           "toLocaleString",
-                          Builtins::kObjectPrototypeToLocaleString, 0, true);
+                          Builtin::kObjectPrototypeToLocaleString, 0, true);
   }
 
   Handle<JSObject> global(native_context()->global_object(), isolate());
@@ -1637,7 +1634,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSFunction> function_fun =
         InstallFunction(isolate_, global, "Function", JS_FUNCTION_TYPE,
                         JSFunction::kSizeWithPrototype, 0, prototype,
-                        Builtins::kFunctionConstructor);
+                        Builtin::kFunctionConstructor);
     // Function instances are sloppy by default.
     function_fun->set_prototype_or_initial_map(*isolate_->sloppy_function_map(),
                                                kReleaseStore);
@@ -1651,22 +1648,21 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                           function_fun, DONT_ENUM);
     Handle<JSFunction> function_prototype_apply =
         SimpleInstallFunction(isolate_, prototype, "apply",
-                              Builtins::kFunctionPrototypeApply, 2, false);
+                              Builtin::kFunctionPrototypeApply, 2, false);
     native_context()->set_function_prototype_apply(*function_prototype_apply);
     SimpleInstallFunction(isolate_, prototype, "bind",
-                          Builtins::kFastFunctionPrototypeBind, 1, false);
+                          Builtin::kFastFunctionPrototypeBind, 1, false);
     SimpleInstallFunction(isolate_, prototype, "call",
-                          Builtins::kFunctionPrototypeCall, 1, false);
+                          Builtin::kFunctionPrototypeCall, 1, false);
     Handle<JSFunction> function_to_string =
         SimpleInstallFunction(isolate_, prototype, "toString",
-                              Builtins::kFunctionPrototypeToString, 0, false);
+                              Builtin::kFunctionPrototypeToString, 0, false);
     native_context()->set_function_to_string(*function_to_string);
 
     // Install the @@hasInstance function.
     Handle<JSFunction> has_instance = InstallFunctionAtSymbol(
         isolate_, prototype, factory->has_instance_symbol(),
-        "[Symbol.hasInstance]", Builtins::kFunctionPrototypeHasInstance, 1,
-        true,
+        "[Symbol.hasInstance]", Builtin::kFunctionPrototypeHasInstance, 1, true,
         static_cast<PropertyAttributes>(DONT_ENUM | DONT_DELETE | READ_ONLY));
     native_context()->set_function_has_instance(*has_instance);
 
@@ -1690,7 +1686,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
   {  // --- A r r a y ---
     Handle<JSFunction> array_function = InstallConstructor(
         isolate_, global, "Array", JS_ARRAY_TYPE, JSArray::kHeaderSize, 0,
-        isolate_->initial_object_prototype(), Builtins::kArrayConstructor,
+        isolate_->initial_object_prototype(), Builtin::kArrayConstructor,
         JS_ARRAY_CONSTRUCTOR_TYPE);
     array_function->shared().DontAdaptArguments();
 
@@ -1732,91 +1728,89 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     native_context()->set_initial_array_prototype(*proto);
 
     SimpleInstallFunction(isolate_, array_function, "isArray",
-                          Builtins::kArrayIsArray, 1, true);
-    SimpleInstallFunction(isolate_, array_function, "from",
-                          Builtins::kArrayFrom, 1, false);
-    SimpleInstallFunction(isolate_, array_function, "of", Builtins::kArrayOf, 0,
+                          Builtin::kArrayIsArray, 1, true);
+    SimpleInstallFunction(isolate_, array_function, "from", Builtin::kArrayFrom,
+                          1, false);
+    SimpleInstallFunction(isolate_, array_function, "of", Builtin::kArrayOf, 0,
                           false);
 
     JSObject::AddProperty(isolate_, proto, factory->constructor_string(),
                           array_function, DONT_ENUM);
 
-    SimpleInstallFunction(isolate_, proto, "concat", Builtins::kArrayConcat, 1,
+    SimpleInstallFunction(isolate_, proto, "concat", Builtin::kArrayConcat, 1,
                           false);
     SimpleInstallFunction(isolate_, proto, "copyWithin",
-                          Builtins::kArrayPrototypeCopyWithin, 2, false);
-    SimpleInstallFunction(isolate_, proto, "fill",
-                          Builtins::kArrayPrototypeFill, 1, false);
-    SimpleInstallFunction(isolate_, proto, "find",
-                          Builtins::kArrayPrototypeFind, 1, false);
+                          Builtin::kArrayPrototypeCopyWithin, 2, false);
+    SimpleInstallFunction(isolate_, proto, "fill", Builtin::kArrayPrototypeFill,
+                          1, false);
+    SimpleInstallFunction(isolate_, proto, "find", Builtin::kArrayPrototypeFind,
+                          1, false);
     SimpleInstallFunction(isolate_, proto, "findIndex",
-                          Builtins::kArrayPrototypeFindIndex, 1, false);
+                          Builtin::kArrayPrototypeFindIndex, 1, false);
     SimpleInstallFunction(isolate_, proto, "lastIndexOf",
-                          Builtins::kArrayPrototypeLastIndexOf, 1, false);
-    SimpleInstallFunction(isolate_, proto, "pop", Builtins::kArrayPrototypePop,
+                          Builtin::kArrayPrototypeLastIndexOf, 1, false);
+    SimpleInstallFunction(isolate_, proto, "pop", Builtin::kArrayPrototypePop,
                           0, false);
-    SimpleInstallFunction(isolate_, proto, "push",
-                          Builtins::kArrayPrototypePush, 1, false);
+    SimpleInstallFunction(isolate_, proto, "push", Builtin::kArrayPrototypePush,
+                          1, false);
     SimpleInstallFunction(isolate_, proto, "reverse",
-                          Builtins::kArrayPrototypeReverse, 0, false);
+                          Builtin::kArrayPrototypeReverse, 0, false);
     SimpleInstallFunction(isolate_, proto, "shift",
-                          Builtins::kArrayPrototypeShift, 0, false);
+                          Builtin::kArrayPrototypeShift, 0, false);
     SimpleInstallFunction(isolate_, proto, "unshift",
-                          Builtins::kArrayPrototypeUnshift, 1, false);
+                          Builtin::kArrayPrototypeUnshift, 1, false);
     SimpleInstallFunction(isolate_, proto, "slice",
-                          Builtins::kArrayPrototypeSlice, 2, false);
-    SimpleInstallFunction(isolate_, proto, "sort",
-                          Builtins::kArrayPrototypeSort, 1, false);
+                          Builtin::kArrayPrototypeSlice, 2, false);
+    SimpleInstallFunction(isolate_, proto, "sort", Builtin::kArrayPrototypeSort,
+                          1, false);
     SimpleInstallFunction(isolate_, proto, "splice",
-                          Builtins::kArrayPrototypeSplice, 2, false);
-    SimpleInstallFunction(isolate_, proto, "includes", Builtins::kArrayIncludes,
+                          Builtin::kArrayPrototypeSplice, 2, false);
+    SimpleInstallFunction(isolate_, proto, "includes", Builtin::kArrayIncludes,
                           1, false);
-    SimpleInstallFunction(isolate_, proto, "indexOf", Builtins::kArrayIndexOf,
+    SimpleInstallFunction(isolate_, proto, "indexOf", Builtin::kArrayIndexOf, 1,
+                          false);
+    SimpleInstallFunction(isolate_, proto, "join", Builtin::kArrayPrototypeJoin,
                           1, false);
-    SimpleInstallFunction(isolate_, proto, "join",
-                          Builtins::kArrayPrototypeJoin, 1, false);
 
     {  // Set up iterator-related properties.
       Handle<JSFunction> keys = InstallFunctionWithBuiltinId(
-          isolate_, proto, "keys", Builtins::kArrayPrototypeKeys, 0, true);
+          isolate_, proto, "keys", Builtin::kArrayPrototypeKeys, 0, true);
       native_context()->set_array_keys_iterator(*keys);
 
       Handle<JSFunction> entries = InstallFunctionWithBuiltinId(
-          isolate_, proto, "entries", Builtins::kArrayPrototypeEntries, 0,
-          true);
+          isolate_, proto, "entries", Builtin::kArrayPrototypeEntries, 0, true);
       native_context()->set_array_entries_iterator(*entries);
 
       Handle<JSFunction> values = InstallFunctionWithBuiltinId(
-          isolate_, proto, "values", Builtins::kArrayPrototypeValues, 0, true);
+          isolate_, proto, "values", Builtin::kArrayPrototypeValues, 0, true);
       JSObject::AddProperty(isolate_, proto, factory->iterator_symbol(), values,
                             DONT_ENUM);
       native_context()->set_array_values_iterator(*values);
     }
 
     Handle<JSFunction> for_each_fun = SimpleInstallFunction(
-        isolate_, proto, "forEach", Builtins::kArrayForEach, 1, false);
+        isolate_, proto, "forEach", Builtin::kArrayForEach, 1, false);
     native_context()->set_array_for_each_iterator(*for_each_fun);
-    SimpleInstallFunction(isolate_, proto, "filter", Builtins::kArrayFilter, 1,
+    SimpleInstallFunction(isolate_, proto, "filter", Builtin::kArrayFilter, 1,
                           false);
-    SimpleInstallFunction(isolate_, proto, "flat",
-                          Builtins::kArrayPrototypeFlat, 0, false);
+    SimpleInstallFunction(isolate_, proto, "flat", Builtin::kArrayPrototypeFlat,
+                          0, false);
     SimpleInstallFunction(isolate_, proto, "flatMap",
-                          Builtins::kArrayPrototypeFlatMap, 1, false);
-    SimpleInstallFunction(isolate_, proto, "map", Builtins::kArrayMap, 1,
+                          Builtin::kArrayPrototypeFlatMap, 1, false);
+    SimpleInstallFunction(isolate_, proto, "map", Builtin::kArrayMap, 1, false);
+    SimpleInstallFunction(isolate_, proto, "every", Builtin::kArrayEvery, 1,
                           false);
-    SimpleInstallFunction(isolate_, proto, "every", Builtins::kArrayEvery, 1,
+    SimpleInstallFunction(isolate_, proto, "some", Builtin::kArraySome, 1,
                           false);
-    SimpleInstallFunction(isolate_, proto, "some", Builtins::kArraySome, 1,
-                          false);
-    SimpleInstallFunction(isolate_, proto, "reduce", Builtins::kArrayReduce, 1,
+    SimpleInstallFunction(isolate_, proto, "reduce", Builtin::kArrayReduce, 1,
                           false);
     SimpleInstallFunction(isolate_, proto, "reduceRight",
-                          Builtins::kArrayReduceRight, 1, false);
+                          Builtin::kArrayReduceRight, 1, false);
     SimpleInstallFunction(isolate_, proto, "toLocaleString",
-                          Builtins::kArrayPrototypeToLocaleString, 0, false);
+                          Builtin::kArrayPrototypeToLocaleString, 0, false);
     array_prototype_to_string_fun =
         SimpleInstallFunction(isolate_, proto, "toString",
-                              Builtins::kArrayPrototypeToString, 0, false);
+                              Builtin::kArrayPrototypeToString, 0, false);
 
     Handle<JSObject> unscopables = factory->NewJSObjectWithNullProto();
     InstallTrueValuedProperty(isolate_, unscopables, "copyWithin");
@@ -1855,13 +1849,12 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                        factory->ArrayIterator_string());
 
     InstallFunctionWithBuiltinId(isolate_, array_iterator_prototype, "next",
-                                 Builtins::kArrayIteratorPrototypeNext, 0,
-                                 true);
+                                 Builtin::kArrayIteratorPrototypeNext, 0, true);
 
     Handle<JSFunction> array_iterator_function =
         CreateFunction(isolate_, factory->ArrayIterator_string(),
                        JS_ARRAY_ITERATOR_TYPE, JSArrayIterator::kHeaderSize, 0,
-                       array_iterator_prototype, Builtins::kIllegal);
+                       array_iterator_prototype, Builtin::kIllegal);
     array_iterator_function->shared().set_native(false);
 
     native_context()->set_initial_array_iterator_map(
@@ -1874,7 +1867,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSFunction> number_fun = InstallFunction(
         isolate_, global, "Number", JS_PRIMITIVE_WRAPPER_TYPE,
         JSPrimitiveWrapper::kHeaderSize, 0,
-        isolate_->initial_object_prototype(), Builtins::kNumberConstructor);
+        isolate_->initial_object_prototype(), Builtin::kNumberConstructor);
     number_fun->shared().DontAdaptArguments();
     number_fun->shared().set_length(1);
     InstallWithIntrinsicDefaultProto(isolate_, number_fun,
@@ -1892,39 +1885,39 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     // Install the Number.prototype methods.
     SimpleInstallFunction(isolate_, prototype, "toExponential",
-                          Builtins::kNumberPrototypeToExponential, 1, false);
+                          Builtin::kNumberPrototypeToExponential, 1, false);
     SimpleInstallFunction(isolate_, prototype, "toFixed",
-                          Builtins::kNumberPrototypeToFixed, 1, false);
+                          Builtin::kNumberPrototypeToFixed, 1, false);
     SimpleInstallFunction(isolate_, prototype, "toPrecision",
-                          Builtins::kNumberPrototypeToPrecision, 1, false);
+                          Builtin::kNumberPrototypeToPrecision, 1, false);
     SimpleInstallFunction(isolate_, prototype, "toString",
-                          Builtins::kNumberPrototypeToString, 1, false);
+                          Builtin::kNumberPrototypeToString, 1, false);
     SimpleInstallFunction(isolate_, prototype, "valueOf",
-                          Builtins::kNumberPrototypeValueOf, 0, true);
+                          Builtin::kNumberPrototypeValueOf, 0, true);
 
     SimpleInstallFunction(isolate_, prototype, "toLocaleString",
-                          Builtins::kNumberPrototypeToLocaleString, 0, false);
+                          Builtin::kNumberPrototypeToLocaleString, 0, false);
 
     // Install the Number functions.
     SimpleInstallFunction(isolate_, number_fun, "isFinite",
-                          Builtins::kNumberIsFinite, 1, true);
+                          Builtin::kNumberIsFinite, 1, true);
     SimpleInstallFunction(isolate_, number_fun, "isInteger",
-                          Builtins::kNumberIsInteger, 1, true);
-    SimpleInstallFunction(isolate_, number_fun, "isNaN", Builtins::kNumberIsNaN,
+                          Builtin::kNumberIsInteger, 1, true);
+    SimpleInstallFunction(isolate_, number_fun, "isNaN", Builtin::kNumberIsNaN,
                           1, true);
     SimpleInstallFunction(isolate_, number_fun, "isSafeInteger",
-                          Builtins::kNumberIsSafeInteger, 1, true);
+                          Builtin::kNumberIsSafeInteger, 1, true);
 
     // Install Number.parseFloat and Global.parseFloat.
     Handle<JSFunction> parse_float_fun =
         SimpleInstallFunction(isolate_, number_fun, "parseFloat",
-                              Builtins::kNumberParseFloat, 1, true);
+                              Builtin::kNumberParseFloat, 1, true);
     JSObject::AddProperty(isolate_, global_object, "parseFloat",
                           parse_float_fun, DONT_ENUM);
 
     // Install Number.parseInt and Global.parseInt.
     Handle<JSFunction> parse_int_fun = SimpleInstallFunction(
-        isolate_, number_fun, "parseInt", Builtins::kNumberParseInt, 2, true);
+        isolate_, number_fun, "parseInt", Builtin::kNumberParseInt, 2, true);
     JSObject::AddProperty(isolate_, global_object, "parseInt", parse_int_fun,
                           DONT_ENUM);
 
@@ -1958,7 +1951,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSFunction> boolean_fun = InstallFunction(
         isolate_, global, "Boolean", JS_PRIMITIVE_WRAPPER_TYPE,
         JSPrimitiveWrapper::kHeaderSize, 0,
-        isolate_->initial_object_prototype(), Builtins::kBooleanConstructor);
+        isolate_->initial_object_prototype(), Builtin::kBooleanConstructor);
     boolean_fun->shared().DontAdaptArguments();
     boolean_fun->shared().set_length(1);
     InstallWithIntrinsicDefaultProto(isolate_, boolean_fun,
@@ -1976,16 +1969,16 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     // Install the Boolean.prototype methods.
     SimpleInstallFunction(isolate_, prototype, "toString",
-                          Builtins::kBooleanPrototypeToString, 0, true);
+                          Builtin::kBooleanPrototypeToString, 0, true);
     SimpleInstallFunction(isolate_, prototype, "valueOf",
-                          Builtins::kBooleanPrototypeValueOf, 0, true);
+                          Builtin::kBooleanPrototypeValueOf, 0, true);
   }
 
   {  // --- S t r i n g ---
     Handle<JSFunction> string_fun = InstallFunction(
         isolate_, global, "String", JS_PRIMITIVE_WRAPPER_TYPE,
         JSPrimitiveWrapper::kHeaderSize, 0,
-        isolate_->initial_object_prototype(), Builtins::kStringConstructor);
+        isolate_->initial_object_prototype(), Builtin::kStringConstructor);
     string_fun->shared().DontAdaptArguments();
     string_fun->shared().set_length(1);
     InstallWithIntrinsicDefaultProto(isolate_, string_fun,
@@ -2007,14 +2000,14 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     // Install the String.fromCharCode function.
     SimpleInstallFunction(isolate_, string_fun, "fromCharCode",
-                          Builtins::kStringFromCharCode, 1, false);
+                          Builtin::kStringFromCharCode, 1, false);
 
     // Install the String.fromCodePoint function.
     SimpleInstallFunction(isolate_, string_fun, "fromCodePoint",
-                          Builtins::kStringFromCodePoint, 1, false);
+                          Builtin::kStringFromCodePoint, 1, false);
 
     // Install the String.raw function.
-    SimpleInstallFunction(isolate_, string_fun, "raw", Builtins::kStringRaw, 1,
+    SimpleInstallFunction(isolate_, string_fun, "raw", Builtin::kStringRaw, 1,
                           false);
 
     // Create the %StringPrototype%
@@ -2030,129 +2023,127 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     // Install the String.prototype methods.
     SimpleInstallFunction(isolate_, prototype, "anchor",
-                          Builtins::kStringPrototypeAnchor, 1, false);
+                          Builtin::kStringPrototypeAnchor, 1, false);
     SimpleInstallFunction(isolate_, prototype, "big",
-                          Builtins::kStringPrototypeBig, 0, false);
+                          Builtin::kStringPrototypeBig, 0, false);
     SimpleInstallFunction(isolate_, prototype, "blink",
-                          Builtins::kStringPrototypeBlink, 0, false);
+                          Builtin::kStringPrototypeBlink, 0, false);
     SimpleInstallFunction(isolate_, prototype, "bold",
-                          Builtins::kStringPrototypeBold, 0, false);
+                          Builtin::kStringPrototypeBold, 0, false);
     SimpleInstallFunction(isolate_, prototype, "charAt",
-                          Builtins::kStringPrototypeCharAt, 1, true);
+                          Builtin::kStringPrototypeCharAt, 1, true);
     SimpleInstallFunction(isolate_, prototype, "charCodeAt",
-                          Builtins::kStringPrototypeCharCodeAt, 1, true);
+                          Builtin::kStringPrototypeCharCodeAt, 1, true);
     SimpleInstallFunction(isolate_, prototype, "codePointAt",
-                          Builtins::kStringPrototypeCodePointAt, 1, true);
+                          Builtin::kStringPrototypeCodePointAt, 1, true);
     SimpleInstallFunction(isolate_, prototype, "concat",
-                          Builtins::kStringPrototypeConcat, 1, false);
+                          Builtin::kStringPrototypeConcat, 1, false);
     SimpleInstallFunction(isolate_, prototype, "endsWith",
-                          Builtins::kStringPrototypeEndsWith, 1, false);
+                          Builtin::kStringPrototypeEndsWith, 1, false);
     SimpleInstallFunction(isolate_, prototype, "fontcolor",
-                          Builtins::kStringPrototypeFontcolor, 1, false);
+                          Builtin::kStringPrototypeFontcolor, 1, false);
     SimpleInstallFunction(isolate_, prototype, "fontsize",
-                          Builtins::kStringPrototypeFontsize, 1, false);
+                          Builtin::kStringPrototypeFontsize, 1, false);
     SimpleInstallFunction(isolate_, prototype, "fixed",
-                          Builtins::kStringPrototypeFixed, 0, false);
+                          Builtin::kStringPrototypeFixed, 0, false);
     SimpleInstallFunction(isolate_, prototype, "includes",
-                          Builtins::kStringPrototypeIncludes, 1, false);
+                          Builtin::kStringPrototypeIncludes, 1, false);
     SimpleInstallFunction(isolate_, prototype, "indexOf",
-                          Builtins::kStringPrototypeIndexOf, 1, false);
+                          Builtin::kStringPrototypeIndexOf, 1, false);
     SimpleInstallFunction(isolate_, prototype, "italics",
-                          Builtins::kStringPrototypeItalics, 0, false);
+                          Builtin::kStringPrototypeItalics, 0, false);
     SimpleInstallFunction(isolate_, prototype, "lastIndexOf",
-                          Builtins::kStringPrototypeLastIndexOf, 1, false);
+                          Builtin::kStringPrototypeLastIndexOf, 1, false);
     SimpleInstallFunction(isolate_, prototype, "link",
-                          Builtins::kStringPrototypeLink, 1, false);
+                          Builtin::kStringPrototypeLink, 1, false);
 #ifdef V8_INTL_SUPPORT
     SimpleInstallFunction(isolate_, prototype, "localeCompare",
-                          Builtins::kStringPrototypeLocaleCompare, 1, false);
+                          Builtin::kStringPrototypeLocaleCompare, 1, false);
 #else
     SimpleInstallFunction(isolate_, prototype, "localeCompare",
-                          Builtins::kStringPrototypeLocaleCompare, 1, true);
+                          Builtin::kStringPrototypeLocaleCompare, 1, true);
 #endif  // V8_INTL_SUPPORT
     SimpleInstallFunction(isolate_, prototype, "match",
-                          Builtins::kStringPrototypeMatch, 1, true);
+                          Builtin::kStringPrototypeMatch, 1, true);
     SimpleInstallFunction(isolate_, prototype, "matchAll",
-                          Builtins::kStringPrototypeMatchAll, 1, true);
+                          Builtin::kStringPrototypeMatchAll, 1, true);
 #ifdef V8_INTL_SUPPORT
     SimpleInstallFunction(isolate_, prototype, "normalize",
-                          Builtins::kStringPrototypeNormalizeIntl, 0, false);
+                          Builtin::kStringPrototypeNormalizeIntl, 0, false);
 #else
     SimpleInstallFunction(isolate_, prototype, "normalize",
-                          Builtins::kStringPrototypeNormalize, 0, false);
+                          Builtin::kStringPrototypeNormalize, 0, false);
 #endif  // V8_INTL_SUPPORT
     SimpleInstallFunction(isolate_, prototype, "padEnd",
-                          Builtins::kStringPrototypePadEnd, 1, false);
+                          Builtin::kStringPrototypePadEnd, 1, false);
     SimpleInstallFunction(isolate_, prototype, "padStart",
-                          Builtins::kStringPrototypePadStart, 1, false);
+                          Builtin::kStringPrototypePadStart, 1, false);
     SimpleInstallFunction(isolate_, prototype, "repeat",
-                          Builtins::kStringPrototypeRepeat, 1, true);
+                          Builtin::kStringPrototypeRepeat, 1, true);
     SimpleInstallFunction(isolate_, prototype, "replace",
-                          Builtins::kStringPrototypeReplace, 2, true);
+                          Builtin::kStringPrototypeReplace, 2, true);
     SimpleInstallFunction(isolate(), prototype, "replaceAll",
-                          Builtins::kStringPrototypeReplaceAll, 2, true);
+                          Builtin::kStringPrototypeReplaceAll, 2, true);
     SimpleInstallFunction(isolate_, prototype, "search",
-                          Builtins::kStringPrototypeSearch, 1, true);
+                          Builtin::kStringPrototypeSearch, 1, true);
     SimpleInstallFunction(isolate_, prototype, "slice",
-                          Builtins::kStringPrototypeSlice, 2, false);
+                          Builtin::kStringPrototypeSlice, 2, false);
     SimpleInstallFunction(isolate_, prototype, "small",
-                          Builtins::kStringPrototypeSmall, 0, false);
+                          Builtin::kStringPrototypeSmall, 0, false);
     SimpleInstallFunction(isolate_, prototype, "split",
-                          Builtins::kStringPrototypeSplit, 2, false);
+                          Builtin::kStringPrototypeSplit, 2, false);
     SimpleInstallFunction(isolate_, prototype, "strike",
-                          Builtins::kStringPrototypeStrike, 0, false);
+                          Builtin::kStringPrototypeStrike, 0, false);
     SimpleInstallFunction(isolate_, prototype, "sub",
-                          Builtins::kStringPrototypeSub, 0, false);
+                          Builtin::kStringPrototypeSub, 0, false);
     SimpleInstallFunction(isolate_, prototype, "substr",
-                          Builtins::kStringPrototypeSubstr, 2, false);
+                          Builtin::kStringPrototypeSubstr, 2, false);
     SimpleInstallFunction(isolate_, prototype, "substring",
-                          Builtins::kStringPrototypeSubstring, 2, false);
+                          Builtin::kStringPrototypeSubstring, 2, false);
     SimpleInstallFunction(isolate_, prototype, "sup",
-                          Builtins::kStringPrototypeSup, 0, false);
+                          Builtin::kStringPrototypeSup, 0, false);
     SimpleInstallFunction(isolate_, prototype, "startsWith",
-                          Builtins::kStringPrototypeStartsWith, 1, false);
+                          Builtin::kStringPrototypeStartsWith, 1, false);
     SimpleInstallFunction(isolate_, prototype, "toString",
-                          Builtins::kStringPrototypeToString, 0, true);
+                          Builtin::kStringPrototypeToString, 0, true);
     SimpleInstallFunction(isolate_, prototype, "trim",
-                          Builtins::kStringPrototypeTrim, 0, false);
+                          Builtin::kStringPrototypeTrim, 0, false);
 
     // Install `String.prototype.trimStart` with `trimLeft` alias.
     Handle<JSFunction> trim_start_fun =
         SimpleInstallFunction(isolate_, prototype, "trimStart",
-                              Builtins::kStringPrototypeTrimStart, 0, false);
+                              Builtin::kStringPrototypeTrimStart, 0, false);
     JSObject::AddProperty(isolate_, prototype, "trimLeft", trim_start_fun,
                           DONT_ENUM);
 
     // Install `String.prototype.trimEnd` with `trimRight` alias.
     Handle<JSFunction> trim_end_fun =
         SimpleInstallFunction(isolate_, prototype, "trimEnd",
-                              Builtins::kStringPrototypeTrimEnd, 0, false);
+                              Builtin::kStringPrototypeTrimEnd, 0, false);
     JSObject::AddProperty(isolate_, prototype, "trimRight", trim_end_fun,
                           DONT_ENUM);
 
     SimpleInstallFunction(isolate_, prototype, "toLocaleLowerCase",
-                          Builtins::kStringPrototypeToLocaleLowerCase, 0,
-                          false);
+                          Builtin::kStringPrototypeToLocaleLowerCase, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toLocaleUpperCase",
-                          Builtins::kStringPrototypeToLocaleUpperCase, 0,
-                          false);
+                          Builtin::kStringPrototypeToLocaleUpperCase, 0, false);
 #ifdef V8_INTL_SUPPORT
     SimpleInstallFunction(isolate_, prototype, "toLowerCase",
-                          Builtins::kStringPrototypeToLowerCaseIntl, 0, true);
+                          Builtin::kStringPrototypeToLowerCaseIntl, 0, true);
     SimpleInstallFunction(isolate_, prototype, "toUpperCase",
-                          Builtins::kStringPrototypeToUpperCaseIntl, 0, false);
+                          Builtin::kStringPrototypeToUpperCaseIntl, 0, false);
 #else
     SimpleInstallFunction(isolate_, prototype, "toLowerCase",
-                          Builtins::kStringPrototypeToLowerCase, 0, false);
+                          Builtin::kStringPrototypeToLowerCase, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toUpperCase",
-                          Builtins::kStringPrototypeToUpperCase, 0, false);
+                          Builtin::kStringPrototypeToUpperCase, 0, false);
 #endif
     SimpleInstallFunction(isolate_, prototype, "valueOf",
-                          Builtins::kStringPrototypeValueOf, 0, true);
+                          Builtin::kStringPrototypeValueOf, 0, true);
 
     InstallFunctionAtSymbol(
         isolate_, prototype, factory->iterator_symbol(), "[Symbol.iterator]",
-        Builtins::kStringPrototypeIterator, 0, true, DONT_ENUM);
+        Builtin::kStringPrototypeIterator, 0, true, DONT_ENUM);
   }
 
   {  // --- S t r i n g I t e r a t o r ---
@@ -2170,13 +2161,13 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallToStringTag(isolate_, string_iterator_prototype, "String Iterator");
 
     InstallFunctionWithBuiltinId(isolate_, string_iterator_prototype, "next",
-                                 Builtins::kStringIteratorPrototypeNext, 0,
+                                 Builtin::kStringIteratorPrototypeNext, 0,
                                  true);
 
     Handle<JSFunction> string_iterator_function = CreateFunction(
         isolate_, factory->InternalizeUtf8String("StringIterator"),
         JS_STRING_ITERATOR_TYPE, JSStringIterator::kHeaderSize, 0,
-        string_iterator_prototype, Builtins::kIllegal);
+        string_iterator_prototype, Builtin::kIllegal);
     string_iterator_function->shared().set_native(false);
     native_context()->set_initial_string_iterator_map(
         string_iterator_function->initial_map());
@@ -2185,19 +2176,19 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
   }
 
   {  // --- S y m b o l ---
-    Handle<JSFunction> symbol_fun = InstallFunction(
-        isolate_, global, "Symbol", JS_PRIMITIVE_WRAPPER_TYPE,
-        JSPrimitiveWrapper::kHeaderSize, 0, factory->the_hole_value(),
-        Builtins::kSymbolConstructor);
+    Handle<JSFunction> symbol_fun =
+        InstallFunction(isolate_, global, "Symbol", JS_PRIMITIVE_WRAPPER_TYPE,
+                        JSPrimitiveWrapper::kHeaderSize, 0,
+                        factory->the_hole_value(), Builtin::kSymbolConstructor);
     symbol_fun->shared().set_length(0);
     symbol_fun->shared().DontAdaptArguments();
     native_context()->set_symbol_function(*symbol_fun);
 
     // Install the Symbol.for and Symbol.keyFor functions.
-    SimpleInstallFunction(isolate_, symbol_fun, "for", Builtins::kSymbolFor, 1,
+    SimpleInstallFunction(isolate_, symbol_fun, "for", Builtin::kSymbolFor, 1,
                           false);
     SimpleInstallFunction(isolate_, symbol_fun, "keyFor",
-                          Builtins::kSymbolKeyFor, 1, false);
+                          Builtin::kSymbolKeyFor, 1, false);
 
     // Install well-known symbols.
     InstallConstant(isolate_, symbol_fun, "asyncIterator",
@@ -2230,37 +2221,37 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     // Install the Symbol.prototype methods.
     InstallFunctionWithBuiltinId(isolate_, prototype, "toString",
-                                 Builtins::kSymbolPrototypeToString, 0, true);
+                                 Builtin::kSymbolPrototypeToString, 0, true);
     InstallFunctionWithBuiltinId(isolate_, prototype, "valueOf",
-                                 Builtins::kSymbolPrototypeValueOf, 0, true);
+                                 Builtin::kSymbolPrototypeValueOf, 0, true);
 
     // Install the Symbol.prototype.description getter.
     SimpleInstallGetter(isolate_, prototype,
                         factory->InternalizeUtf8String("description"),
-                        Builtins::kSymbolPrototypeDescriptionGetter, true);
+                        Builtin::kSymbolPrototypeDescriptionGetter, true);
 
     // Install the @@toPrimitive function.
     InstallFunctionAtSymbol(
         isolate_, prototype, factory->to_primitive_symbol(),
-        "[Symbol.toPrimitive]", Builtins::kSymbolPrototypeToPrimitive, 1, true,
+        "[Symbol.toPrimitive]", Builtin::kSymbolPrototypeToPrimitive, 1, true,
         static_cast<PropertyAttributes>(DONT_ENUM | READ_ONLY));
   }
 
   {  // --- D a t e ---
     Handle<JSFunction> date_fun = InstallFunction(
         isolate_, global, "Date", JS_DATE_TYPE, JSDate::kHeaderSize, 0,
-        factory->the_hole_value(), Builtins::kDateConstructor);
+        factory->the_hole_value(), Builtin::kDateConstructor);
     InstallWithIntrinsicDefaultProto(isolate_, date_fun,
                                      Context::DATE_FUNCTION_INDEX);
     date_fun->shared().set_length(7);
     date_fun->shared().DontAdaptArguments();
 
     // Install the Date.now, Date.parse and Date.UTC functions.
-    SimpleInstallFunction(isolate_, date_fun, "now", Builtins::kDateNow, 0,
+    SimpleInstallFunction(isolate_, date_fun, "now", Builtin::kDateNow, 0,
                           false);
-    SimpleInstallFunction(isolate_, date_fun, "parse", Builtins::kDateParse, 1,
+    SimpleInstallFunction(isolate_, date_fun, "parse", Builtin::kDateParse, 1,
                           false);
-    SimpleInstallFunction(isolate_, date_fun, "UTC", Builtins::kDateUTC, 7,
+    SimpleInstallFunction(isolate_, date_fun, "UTC", Builtin::kDateUTC, 7,
                           false);
 
     // Setup %DatePrototype%.
@@ -2269,114 +2260,114 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     // Install the Date.prototype methods.
     SimpleInstallFunction(isolate_, prototype, "toString",
-                          Builtins::kDatePrototypeToString, 0, false);
+                          Builtin::kDatePrototypeToString, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toDateString",
-                          Builtins::kDatePrototypeToDateString, 0, false);
+                          Builtin::kDatePrototypeToDateString, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toTimeString",
-                          Builtins::kDatePrototypeToTimeString, 0, false);
+                          Builtin::kDatePrototypeToTimeString, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toISOString",
-                          Builtins::kDatePrototypeToISOString, 0, false);
+                          Builtin::kDatePrototypeToISOString, 0, false);
     Handle<JSFunction> to_utc_string =
         SimpleInstallFunction(isolate_, prototype, "toUTCString",
-                              Builtins::kDatePrototypeToUTCString, 0, false);
+                              Builtin::kDatePrototypeToUTCString, 0, false);
     JSObject::AddProperty(isolate_, prototype, "toGMTString", to_utc_string,
                           DONT_ENUM);
     SimpleInstallFunction(isolate_, prototype, "getDate",
-                          Builtins::kDatePrototypeGetDate, 0, true);
+                          Builtin::kDatePrototypeGetDate, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setDate",
-                          Builtins::kDatePrototypeSetDate, 1, false);
+                          Builtin::kDatePrototypeSetDate, 1, false);
     SimpleInstallFunction(isolate_, prototype, "getDay",
-                          Builtins::kDatePrototypeGetDay, 0, true);
+                          Builtin::kDatePrototypeGetDay, 0, true);
     SimpleInstallFunction(isolate_, prototype, "getFullYear",
-                          Builtins::kDatePrototypeGetFullYear, 0, true);
+                          Builtin::kDatePrototypeGetFullYear, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setFullYear",
-                          Builtins::kDatePrototypeSetFullYear, 3, false);
+                          Builtin::kDatePrototypeSetFullYear, 3, false);
     SimpleInstallFunction(isolate_, prototype, "getHours",
-                          Builtins::kDatePrototypeGetHours, 0, true);
+                          Builtin::kDatePrototypeGetHours, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setHours",
-                          Builtins::kDatePrototypeSetHours, 4, false);
+                          Builtin::kDatePrototypeSetHours, 4, false);
     SimpleInstallFunction(isolate_, prototype, "getMilliseconds",
-                          Builtins::kDatePrototypeGetMilliseconds, 0, true);
+                          Builtin::kDatePrototypeGetMilliseconds, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setMilliseconds",
-                          Builtins::kDatePrototypeSetMilliseconds, 1, false);
+                          Builtin::kDatePrototypeSetMilliseconds, 1, false);
     SimpleInstallFunction(isolate_, prototype, "getMinutes",
-                          Builtins::kDatePrototypeGetMinutes, 0, true);
+                          Builtin::kDatePrototypeGetMinutes, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setMinutes",
-                          Builtins::kDatePrototypeSetMinutes, 3, false);
+                          Builtin::kDatePrototypeSetMinutes, 3, false);
     SimpleInstallFunction(isolate_, prototype, "getMonth",
-                          Builtins::kDatePrototypeGetMonth, 0, true);
+                          Builtin::kDatePrototypeGetMonth, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setMonth",
-                          Builtins::kDatePrototypeSetMonth, 2, false);
+                          Builtin::kDatePrototypeSetMonth, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getSeconds",
-                          Builtins::kDatePrototypeGetSeconds, 0, true);
+                          Builtin::kDatePrototypeGetSeconds, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setSeconds",
-                          Builtins::kDatePrototypeSetSeconds, 2, false);
+                          Builtin::kDatePrototypeSetSeconds, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getTime",
-                          Builtins::kDatePrototypeGetTime, 0, true);
+                          Builtin::kDatePrototypeGetTime, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setTime",
-                          Builtins::kDatePrototypeSetTime, 1, false);
+                          Builtin::kDatePrototypeSetTime, 1, false);
     SimpleInstallFunction(isolate_, prototype, "getTimezoneOffset",
-                          Builtins::kDatePrototypeGetTimezoneOffset, 0, true);
+                          Builtin::kDatePrototypeGetTimezoneOffset, 0, true);
     SimpleInstallFunction(isolate_, prototype, "getUTCDate",
-                          Builtins::kDatePrototypeGetUTCDate, 0, true);
+                          Builtin::kDatePrototypeGetUTCDate, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setUTCDate",
-                          Builtins::kDatePrototypeSetUTCDate, 1, false);
+                          Builtin::kDatePrototypeSetUTCDate, 1, false);
     SimpleInstallFunction(isolate_, prototype, "getUTCDay",
-                          Builtins::kDatePrototypeGetUTCDay, 0, true);
+                          Builtin::kDatePrototypeGetUTCDay, 0, true);
     SimpleInstallFunction(isolate_, prototype, "getUTCFullYear",
-                          Builtins::kDatePrototypeGetUTCFullYear, 0, true);
+                          Builtin::kDatePrototypeGetUTCFullYear, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setUTCFullYear",
-                          Builtins::kDatePrototypeSetUTCFullYear, 3, false);
+                          Builtin::kDatePrototypeSetUTCFullYear, 3, false);
     SimpleInstallFunction(isolate_, prototype, "getUTCHours",
-                          Builtins::kDatePrototypeGetUTCHours, 0, true);
+                          Builtin::kDatePrototypeGetUTCHours, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setUTCHours",
-                          Builtins::kDatePrototypeSetUTCHours, 4, false);
+                          Builtin::kDatePrototypeSetUTCHours, 4, false);
     SimpleInstallFunction(isolate_, prototype, "getUTCMilliseconds",
-                          Builtins::kDatePrototypeGetUTCMilliseconds, 0, true);
+                          Builtin::kDatePrototypeGetUTCMilliseconds, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setUTCMilliseconds",
-                          Builtins::kDatePrototypeSetUTCMilliseconds, 1, false);
+                          Builtin::kDatePrototypeSetUTCMilliseconds, 1, false);
     SimpleInstallFunction(isolate_, prototype, "getUTCMinutes",
-                          Builtins::kDatePrototypeGetUTCMinutes, 0, true);
+                          Builtin::kDatePrototypeGetUTCMinutes, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setUTCMinutes",
-                          Builtins::kDatePrototypeSetUTCMinutes, 3, false);
+                          Builtin::kDatePrototypeSetUTCMinutes, 3, false);
     SimpleInstallFunction(isolate_, prototype, "getUTCMonth",
-                          Builtins::kDatePrototypeGetUTCMonth, 0, true);
+                          Builtin::kDatePrototypeGetUTCMonth, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setUTCMonth",
-                          Builtins::kDatePrototypeSetUTCMonth, 2, false);
+                          Builtin::kDatePrototypeSetUTCMonth, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getUTCSeconds",
-                          Builtins::kDatePrototypeGetUTCSeconds, 0, true);
+                          Builtin::kDatePrototypeGetUTCSeconds, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setUTCSeconds",
-                          Builtins::kDatePrototypeSetUTCSeconds, 2, false);
+                          Builtin::kDatePrototypeSetUTCSeconds, 2, false);
     SimpleInstallFunction(isolate_, prototype, "valueOf",
-                          Builtins::kDatePrototypeValueOf, 0, true);
+                          Builtin::kDatePrototypeValueOf, 0, true);
     SimpleInstallFunction(isolate_, prototype, "getYear",
-                          Builtins::kDatePrototypeGetYear, 0, true);
+                          Builtin::kDatePrototypeGetYear, 0, true);
     SimpleInstallFunction(isolate_, prototype, "setYear",
-                          Builtins::kDatePrototypeSetYear, 1, false);
+                          Builtin::kDatePrototypeSetYear, 1, false);
     SimpleInstallFunction(isolate_, prototype, "toJSON",
-                          Builtins::kDatePrototypeToJson, 1, false);
+                          Builtin::kDatePrototypeToJson, 1, false);
 
 #ifdef V8_INTL_SUPPORT
     SimpleInstallFunction(isolate_, prototype, "toLocaleString",
-                          Builtins::kDatePrototypeToLocaleString, 0, false);
+                          Builtin::kDatePrototypeToLocaleString, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toLocaleDateString",
-                          Builtins::kDatePrototypeToLocaleDateString, 0, false);
+                          Builtin::kDatePrototypeToLocaleDateString, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toLocaleTimeString",
-                          Builtins::kDatePrototypeToLocaleTimeString, 0, false);
+                          Builtin::kDatePrototypeToLocaleTimeString, 0, false);
 #else
     // Install Intl fallback functions.
     SimpleInstallFunction(isolate_, prototype, "toLocaleString",
-                          Builtins::kDatePrototypeToString, 0, false);
+                          Builtin::kDatePrototypeToString, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toLocaleDateString",
-                          Builtins::kDatePrototypeToDateString, 0, false);
+                          Builtin::kDatePrototypeToDateString, 0, false);
     SimpleInstallFunction(isolate_, prototype, "toLocaleTimeString",
-                          Builtins::kDatePrototypeToTimeString, 0, false);
+                          Builtin::kDatePrototypeToTimeString, 0, false);
 #endif  // V8_INTL_SUPPORT
 
     // Install the @@toPrimitive function.
     InstallFunctionAtSymbol(
         isolate_, prototype, factory->to_primitive_symbol(),
-        "[Symbol.toPrimitive]", Builtins::kDatePrototypeToPrimitive, 1, true,
+        "[Symbol.toPrimitive]", Builtin::kDatePrototypeToPrimitive, 1, true,
         static_cast<PropertyAttributes>(DONT_ENUM | READ_ONLY));
   }
 
@@ -2384,7 +2375,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSFunction> promise_fun = InstallConstructor(
         isolate_, global, "Promise", JS_PROMISE_TYPE,
         JSPromise::kSizeWithEmbedderFields, 0, factory->the_hole_value(),
-        Builtins::kPromiseConstructor, JS_PROMISE_CONSTRUCTOR_TYPE);
+        Builtin::kPromiseConstructor, JS_PROMISE_CONSTRUCTOR_TYPE);
     InstallWithIntrinsicDefaultProto(isolate_, promise_fun,
                                      Context::PROMISE_FUNCTION_INDEX);
 
@@ -2395,24 +2386,24 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallSpeciesGetter(isolate_, promise_fun);
 
     Handle<JSFunction> promise_all = InstallFunctionWithBuiltinId(
-        isolate_, promise_fun, "all", Builtins::kPromiseAll, 1, true);
+        isolate_, promise_fun, "all", Builtin::kPromiseAll, 1, true);
     native_context()->set_promise_all(*promise_all);
 
     InstallFunctionWithBuiltinId(isolate_, promise_fun, "allSettled",
-                                 Builtins::kPromiseAllSettled, 1, true);
+                                 Builtin::kPromiseAllSettled, 1, true);
 
     Handle<JSFunction> promise_any = InstallFunctionWithBuiltinId(
-        isolate_, promise_fun, "any", Builtins::kPromiseAny, 1, true);
+        isolate_, promise_fun, "any", Builtin::kPromiseAny, 1, true);
     native_context()->set_promise_any(*promise_any);
 
     InstallFunctionWithBuiltinId(isolate_, promise_fun, "race",
-                                 Builtins::kPromiseRace, 1, true);
+                                 Builtin::kPromiseRace, 1, true);
 
     InstallFunctionWithBuiltinId(isolate_, promise_fun, "resolve",
-                                 Builtins::kPromiseResolveTrampoline, 1, true);
+                                 Builtin::kPromiseResolveTrampoline, 1, true);
 
     InstallFunctionWithBuiltinId(isolate_, promise_fun, "reject",
-                                 Builtins::kPromiseReject, 1, true);
+                                 Builtin::kPromiseReject, 1, true);
 
     // Setup %PromisePrototype%.
     Handle<JSObject> prototype(
@@ -2422,14 +2413,14 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallToStringTag(isolate_, prototype, factory->Promise_string());
 
     Handle<JSFunction> promise_then = InstallFunctionWithBuiltinId(
-        isolate_, prototype, "then", Builtins::kPromisePrototypeThen, 2, true);
+        isolate_, prototype, "then", Builtin::kPromisePrototypeThen, 2, true);
     native_context()->set_promise_then(*promise_then);
 
     InstallFunctionWithBuiltinId(isolate_, prototype, "catch",
-                                 Builtins::kPromisePrototypeCatch, 1, true);
+                                 Builtin::kPromisePrototypeCatch, 1, true);
 
     InstallFunctionWithBuiltinId(isolate_, prototype, "finally",
-                                 Builtins::kPromisePrototypeFinally, 1, true);
+                                 Builtin::kPromisePrototypeFinally, 1, true);
 
     DCHECK(promise_fun->HasFastProperties());
 
@@ -2448,7 +2439,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
         isolate_, global, "RegExp", JS_REG_EXP_TYPE,
         JSRegExp::kHeaderSize + JSRegExp::kInObjectFieldCount * kTaggedSize,
         JSRegExp::kInObjectFieldCount, factory->the_hole_value(),
-        Builtins::kRegExpConstructor, JS_REG_EXP_CONSTRUCTOR_TYPE);
+        Builtin::kRegExpConstructor, JS_REG_EXP_CONSTRUCTOR_TYPE);
     InstallWithIntrinsicDefaultProto(isolate_, regexp_fun,
                                      Context::REGEXP_FUNCTION_INDEX);
     Handle<SharedFunctionInfo> shared(regexp_fun->shared(), isolate_);
@@ -2464,40 +2455,40 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       {
         Handle<JSFunction> fun =
             SimpleInstallFunction(isolate_, prototype, "exec",
-                                  Builtins::kRegExpPrototypeExec, 1, true);
+                                  Builtin::kRegExpPrototypeExec, 1, true);
         native_context()->set_regexp_exec_function(*fun);
         DCHECK_EQ(JSRegExp::kExecFunctionDescriptorIndex,
                   prototype->map().LastAdded().as_int());
       }
 
       SimpleInstallGetter(isolate_, prototype, factory->dotAll_string(),
-                          Builtins::kRegExpPrototypeDotAllGetter, true);
+                          Builtin::kRegExpPrototypeDotAllGetter, true);
       SimpleInstallGetter(isolate_, prototype, factory->flags_string(),
-                          Builtins::kRegExpPrototypeFlagsGetter, true);
+                          Builtin::kRegExpPrototypeFlagsGetter, true);
       SimpleInstallGetter(isolate_, prototype, factory->global_string(),
-                          Builtins::kRegExpPrototypeGlobalGetter, true);
+                          Builtin::kRegExpPrototypeGlobalGetter, true);
       SimpleInstallGetter(isolate_, prototype, factory->ignoreCase_string(),
-                          Builtins::kRegExpPrototypeIgnoreCaseGetter, true);
+                          Builtin::kRegExpPrototypeIgnoreCaseGetter, true);
       SimpleInstallGetter(isolate_, prototype, factory->multiline_string(),
-                          Builtins::kRegExpPrototypeMultilineGetter, true);
+                          Builtin::kRegExpPrototypeMultilineGetter, true);
       SimpleInstallGetter(isolate_, prototype, factory->source_string(),
-                          Builtins::kRegExpPrototypeSourceGetter, true);
+                          Builtin::kRegExpPrototypeSourceGetter, true);
       SimpleInstallGetter(isolate_, prototype, factory->sticky_string(),
-                          Builtins::kRegExpPrototypeStickyGetter, true);
+                          Builtin::kRegExpPrototypeStickyGetter, true);
       SimpleInstallGetter(isolate_, prototype, factory->unicode_string(),
-                          Builtins::kRegExpPrototypeUnicodeGetter, true);
+                          Builtin::kRegExpPrototypeUnicodeGetter, true);
 
       SimpleInstallFunction(isolate_, prototype, "compile",
-                            Builtins::kRegExpPrototypeCompile, 2, true);
+                            Builtin::kRegExpPrototypeCompile, 2, true);
       SimpleInstallFunction(isolate_, prototype, "toString",
-                            Builtins::kRegExpPrototypeToString, 0, false);
+                            Builtin::kRegExpPrototypeToString, 0, false);
       SimpleInstallFunction(isolate_, prototype, "test",
-                            Builtins::kRegExpPrototypeTest, 1, true);
+                            Builtin::kRegExpPrototypeTest, 1, true);
 
       {
         Handle<JSFunction> fun = InstallFunctionAtSymbol(
             isolate_, prototype, factory->match_symbol(), "[Symbol.match]",
-            Builtins::kRegExpPrototypeMatch, 1, true);
+            Builtin::kRegExpPrototypeMatch, 1, true);
         native_context()->set_regexp_match_function(*fun);
         DCHECK_EQ(JSRegExp::kSymbolMatchFunctionDescriptorIndex,
                   prototype->map().LastAdded().as_int());
@@ -2506,7 +2497,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       {
         Handle<JSFunction> fun = InstallFunctionAtSymbol(
             isolate_, prototype, factory->match_all_symbol(),
-            "[Symbol.matchAll]", Builtins::kRegExpPrototypeMatchAll, 1, true);
+            "[Symbol.matchAll]", Builtin::kRegExpPrototypeMatchAll, 1, true);
         native_context()->set_regexp_match_all_function(*fun);
         DCHECK_EQ(JSRegExp::kSymbolMatchAllFunctionDescriptorIndex,
                   prototype->map().LastAdded().as_int());
@@ -2515,7 +2506,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       {
         Handle<JSFunction> fun = InstallFunctionAtSymbol(
             isolate_, prototype, factory->replace_symbol(), "[Symbol.replace]",
-            Builtins::kRegExpPrototypeReplace, 2, false);
+            Builtin::kRegExpPrototypeReplace, 2, false);
         native_context()->set_regexp_replace_function(*fun);
         DCHECK_EQ(JSRegExp::kSymbolReplaceFunctionDescriptorIndex,
                   prototype->map().LastAdded().as_int());
@@ -2524,7 +2515,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       {
         Handle<JSFunction> fun = InstallFunctionAtSymbol(
             isolate_, prototype, factory->search_symbol(), "[Symbol.search]",
-            Builtins::kRegExpPrototypeSearch, 1, true);
+            Builtin::kRegExpPrototypeSearch, 1, true);
         native_context()->set_regexp_search_function(*fun);
         DCHECK_EQ(JSRegExp::kSymbolSearchFunctionDescriptorIndex,
                   prototype->map().LastAdded().as_int());
@@ -2533,7 +2524,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       {
         Handle<JSFunction> fun = InstallFunctionAtSymbol(
             isolate_, prototype, factory->split_symbol(), "[Symbol.split]",
-            Builtins::kRegExpPrototypeSplit, 2, false);
+            Builtin::kRegExpPrototypeSplit, 2, false);
         native_context()->set_regexp_split_function(*fun);
         DCHECK_EQ(JSRegExp::kSymbolSplitFunctionDescriptorIndex,
                   prototype->map().LastAdded().as_int());
@@ -2558,44 +2549,44 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       // Static properties set by a successful match.
 
       SimpleInstallGetterSetter(isolate_, regexp_fun, factory->input_string(),
-                                Builtins::kRegExpInputGetter,
-                                Builtins::kRegExpInputSetter);
+                                Builtin::kRegExpInputGetter,
+                                Builtin::kRegExpInputSetter);
       SimpleInstallGetterSetter(isolate_, regexp_fun, "$_",
-                                Builtins::kRegExpInputGetter,
-                                Builtins::kRegExpInputSetter);
+                                Builtin::kRegExpInputGetter,
+                                Builtin::kRegExpInputSetter);
 
       SimpleInstallGetterSetter(isolate_, regexp_fun, "lastMatch",
-                                Builtins::kRegExpLastMatchGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpLastMatchGetter,
+                                Builtin::kEmptyFunction);
       SimpleInstallGetterSetter(isolate_, regexp_fun, "$&",
-                                Builtins::kRegExpLastMatchGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpLastMatchGetter,
+                                Builtin::kEmptyFunction);
 
       SimpleInstallGetterSetter(isolate_, regexp_fun, "lastParen",
-                                Builtins::kRegExpLastParenGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpLastParenGetter,
+                                Builtin::kEmptyFunction);
       SimpleInstallGetterSetter(isolate_, regexp_fun, "$+",
-                                Builtins::kRegExpLastParenGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpLastParenGetter,
+                                Builtin::kEmptyFunction);
 
       SimpleInstallGetterSetter(isolate_, regexp_fun, "leftContext",
-                                Builtins::kRegExpLeftContextGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpLeftContextGetter,
+                                Builtin::kEmptyFunction);
       SimpleInstallGetterSetter(isolate_, regexp_fun, "$`",
-                                Builtins::kRegExpLeftContextGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpLeftContextGetter,
+                                Builtin::kEmptyFunction);
 
       SimpleInstallGetterSetter(isolate_, regexp_fun, "rightContext",
-                                Builtins::kRegExpRightContextGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpRightContextGetter,
+                                Builtin::kEmptyFunction);
       SimpleInstallGetterSetter(isolate_, regexp_fun, "$'",
-                                Builtins::kRegExpRightContextGetter,
-                                Builtins::kEmptyFunction);
+                                Builtin::kRegExpRightContextGetter,
+                                Builtin::kEmptyFunction);
 
-#define INSTALL_CAPTURE_GETTER(i)                                \
-  SimpleInstallGetterSetter(isolate_, regexp_fun, "$" #i,        \
-                            Builtins::kRegExpCapture##i##Getter, \
-                            Builtins::kEmptyFunction)
+#define INSTALL_CAPTURE_GETTER(i)                               \
+  SimpleInstallGetterSetter(isolate_, regexp_fun, "$" #i,       \
+                            Builtin::kRegExpCapture##i##Getter, \
+                            Builtin::kEmptyFunction)
       INSTALL_CAPTURE_GETTER(1);
       INSTALL_CAPTURE_GETTER(2);
       INSTALL_CAPTURE_GETTER(3);
@@ -2647,13 +2638,12 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                        "RegExp String Iterator");
 
     SimpleInstallFunction(isolate(), regexp_string_iterator_prototype, "next",
-                          Builtins::kRegExpStringIteratorPrototypeNext, 0,
-                          true);
+                          Builtin::kRegExpStringIteratorPrototypeNext, 0, true);
 
     Handle<JSFunction> regexp_string_iterator_function = CreateFunction(
         isolate(), "RegExpStringIterator", JS_REG_EXP_STRING_ITERATOR_TYPE,
         JSRegExpStringIterator::kHeaderSize, 0,
-        regexp_string_iterator_prototype, Builtins::kIllegal);
+        regexp_string_iterator_prototype, Builtin::kIllegal);
     regexp_string_iterator_function->shared().set_native(false);
     native_context()->set_initial_regexp_string_iterator_prototype_map(
         regexp_string_iterator_function->initial_map());
@@ -2666,7 +2656,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
   // -- A g g r e g a t e E r r o r
   InstallError(isolate_, global, factory->AggregateError_string(),
                Context::AGGREGATE_ERROR_FUNCTION_INDEX,
-               Builtins::kAggregateErrorConstructor, 2, 2);
+               Builtin::kAggregateErrorConstructor, 2, 2);
 
   // -- E v a l E r r o r
   InstallError(isolate_, global, factory->EvalError_string(),
@@ -2723,10 +2713,10 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSObject> json_object =
         factory->NewJSObject(isolate_->object_function(), AllocationType::kOld);
     JSObject::AddProperty(isolate_, global, "JSON", json_object, DONT_ENUM);
-    SimpleInstallFunction(isolate_, json_object, "parse", Builtins::kJsonParse,
+    SimpleInstallFunction(isolate_, json_object, "parse", Builtin::kJsonParse,
                           2, false);
     SimpleInstallFunction(isolate_, json_object, "stringify",
-                          Builtins::kJsonStringify, 3, true);
+                          Builtin::kJsonStringify, 3, true);
     InstallToStringTag(isolate_, json_object, "JSON");
   }
 
@@ -2734,57 +2724,57 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSObject> math =
         factory->NewJSObject(isolate_->object_function(), AllocationType::kOld);
     JSObject::AddProperty(isolate_, global, "Math", math, DONT_ENUM);
-    SimpleInstallFunction(isolate_, math, "abs", Builtins::kMathAbs, 1, true);
-    SimpleInstallFunction(isolate_, math, "acos", Builtins::kMathAcos, 1, true);
-    SimpleInstallFunction(isolate_, math, "acosh", Builtins::kMathAcosh, 1,
+    SimpleInstallFunction(isolate_, math, "abs", Builtin::kMathAbs, 1, true);
+    SimpleInstallFunction(isolate_, math, "acos", Builtin::kMathAcos, 1, true);
+    SimpleInstallFunction(isolate_, math, "acosh", Builtin::kMathAcosh, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "asin", Builtins::kMathAsin, 1, true);
-    SimpleInstallFunction(isolate_, math, "asinh", Builtins::kMathAsinh, 1,
+    SimpleInstallFunction(isolate_, math, "asin", Builtin::kMathAsin, 1, true);
+    SimpleInstallFunction(isolate_, math, "asinh", Builtin::kMathAsinh, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "atan", Builtins::kMathAtan, 1, true);
-    SimpleInstallFunction(isolate_, math, "atanh", Builtins::kMathAtanh, 1,
+    SimpleInstallFunction(isolate_, math, "atan", Builtin::kMathAtan, 1, true);
+    SimpleInstallFunction(isolate_, math, "atanh", Builtin::kMathAtanh, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "atan2", Builtins::kMathAtan2, 2,
+    SimpleInstallFunction(isolate_, math, "atan2", Builtin::kMathAtan2, 2,
                           true);
-    SimpleInstallFunction(isolate_, math, "ceil", Builtins::kMathCeil, 1, true);
-    SimpleInstallFunction(isolate_, math, "cbrt", Builtins::kMathCbrt, 1, true);
-    SimpleInstallFunction(isolate_, math, "expm1", Builtins::kMathExpm1, 1,
+    SimpleInstallFunction(isolate_, math, "ceil", Builtin::kMathCeil, 1, true);
+    SimpleInstallFunction(isolate_, math, "cbrt", Builtin::kMathCbrt, 1, true);
+    SimpleInstallFunction(isolate_, math, "expm1", Builtin::kMathExpm1, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "clz32", Builtins::kMathClz32, 1,
+    SimpleInstallFunction(isolate_, math, "clz32", Builtin::kMathClz32, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "cos", Builtins::kMathCos, 1, true);
-    SimpleInstallFunction(isolate_, math, "cosh", Builtins::kMathCosh, 1, true);
-    SimpleInstallFunction(isolate_, math, "exp", Builtins::kMathExp, 1, true);
+    SimpleInstallFunction(isolate_, math, "cos", Builtin::kMathCos, 1, true);
+    SimpleInstallFunction(isolate_, math, "cosh", Builtin::kMathCosh, 1, true);
+    SimpleInstallFunction(isolate_, math, "exp", Builtin::kMathExp, 1, true);
     Handle<JSFunction> math_floor = SimpleInstallFunction(
-        isolate_, math, "floor", Builtins::kMathFloor, 1, true);
+        isolate_, math, "floor", Builtin::kMathFloor, 1, true);
     native_context()->set_math_floor(*math_floor);
-    SimpleInstallFunction(isolate_, math, "fround", Builtins::kMathFround, 1,
+    SimpleInstallFunction(isolate_, math, "fround", Builtin::kMathFround, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "hypot", Builtins::kMathHypot, 2,
+    SimpleInstallFunction(isolate_, math, "hypot", Builtin::kMathHypot, 2,
                           false);
-    SimpleInstallFunction(isolate_, math, "imul", Builtins::kMathImul, 2, true);
-    SimpleInstallFunction(isolate_, math, "log", Builtins::kMathLog, 1, true);
-    SimpleInstallFunction(isolate_, math, "log1p", Builtins::kMathLog1p, 1,
+    SimpleInstallFunction(isolate_, math, "imul", Builtin::kMathImul, 2, true);
+    SimpleInstallFunction(isolate_, math, "log", Builtin::kMathLog, 1, true);
+    SimpleInstallFunction(isolate_, math, "log1p", Builtin::kMathLog1p, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "log2", Builtins::kMathLog2, 1, true);
-    SimpleInstallFunction(isolate_, math, "log10", Builtins::kMathLog10, 1,
+    SimpleInstallFunction(isolate_, math, "log2", Builtin::kMathLog2, 1, true);
+    SimpleInstallFunction(isolate_, math, "log10", Builtin::kMathLog10, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "max", Builtins::kMathMax, 2, false);
-    SimpleInstallFunction(isolate_, math, "min", Builtins::kMathMin, 2, false);
+    SimpleInstallFunction(isolate_, math, "max", Builtin::kMathMax, 2, false);
+    SimpleInstallFunction(isolate_, math, "min", Builtin::kMathMin, 2, false);
     Handle<JSFunction> math_pow = SimpleInstallFunction(
-        isolate_, math, "pow", Builtins::kMathPow, 2, true);
+        isolate_, math, "pow", Builtin::kMathPow, 2, true);
     native_context()->set_math_pow(*math_pow);
-    SimpleInstallFunction(isolate_, math, "random", Builtins::kMathRandom, 0,
+    SimpleInstallFunction(isolate_, math, "random", Builtin::kMathRandom, 0,
                           true);
-    SimpleInstallFunction(isolate_, math, "round", Builtins::kMathRound, 1,
+    SimpleInstallFunction(isolate_, math, "round", Builtin::kMathRound, 1,
                           true);
-    SimpleInstallFunction(isolate_, math, "sign", Builtins::kMathSign, 1, true);
-    SimpleInstallFunction(isolate_, math, "sin", Builtins::kMathSin, 1, true);
-    SimpleInstallFunction(isolate_, math, "sinh", Builtins::kMathSinh, 1, true);
-    SimpleInstallFunction(isolate_, math, "sqrt", Builtins::kMathSqrt, 1, true);
-    SimpleInstallFunction(isolate_, math, "tan", Builtins::kMathTan, 1, true);
-    SimpleInstallFunction(isolate_, math, "tanh", Builtins::kMathTanh, 1, true);
-    SimpleInstallFunction(isolate_, math, "trunc", Builtins::kMathTrunc, 1,
+    SimpleInstallFunction(isolate_, math, "sign", Builtin::kMathSign, 1, true);
+    SimpleInstallFunction(isolate_, math, "sin", Builtin::kMathSin, 1, true);
+    SimpleInstallFunction(isolate_, math, "sinh", Builtin::kMathSinh, 1, true);
+    SimpleInstallFunction(isolate_, math, "sqrt", Builtin::kMathSqrt, 1, true);
+    SimpleInstallFunction(isolate_, math, "tan", Builtin::kMathTan, 1, true);
+    SimpleInstallFunction(isolate_, math, "tanh", Builtin::kMathTanh, 1, true);
+    SimpleInstallFunction(isolate_, math, "trunc", Builtin::kMathTrunc, 1,
                           true);
 
     // Install math constants.
@@ -2812,7 +2802,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     Handle<NativeContext> context(isolate()->native_context());
     Handle<SharedFunctionInfo> info =
-        factory->NewSharedFunctionInfoForBuiltin(name, Builtins::kIllegal);
+        factory->NewSharedFunctionInfoForBuiltin(name, Builtin::kIllegal);
     info->set_language_mode(LanguageMode::kStrict);
 
     Handle<JSFunction> cons =
@@ -2823,52 +2813,52 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSObject> console = factory->NewJSObject(cons, AllocationType::kOld);
     DCHECK(console->IsJSObject());
     JSObject::AddProperty(isolate_, global, name, console, DONT_ENUM);
-    SimpleInstallFunction(isolate_, console, "debug", Builtins::kConsoleDebug,
-                          0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "error", Builtins::kConsoleError,
-                          0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "info", Builtins::kConsoleInfo, 0,
+    SimpleInstallFunction(isolate_, console, "debug", Builtin::kConsoleDebug, 0,
                           false, NONE);
-    SimpleInstallFunction(isolate_, console, "log", Builtins::kConsoleLog, 0,
+    SimpleInstallFunction(isolate_, console, "error", Builtin::kConsoleError, 0,
                           false, NONE);
-    SimpleInstallFunction(isolate_, console, "warn", Builtins::kConsoleWarn, 0,
+    SimpleInstallFunction(isolate_, console, "info", Builtin::kConsoleInfo, 0,
                           false, NONE);
-    SimpleInstallFunction(isolate_, console, "dir", Builtins::kConsoleDir, 0,
+    SimpleInstallFunction(isolate_, console, "log", Builtin::kConsoleLog, 0,
                           false, NONE);
-    SimpleInstallFunction(isolate_, console, "dirxml", Builtins::kConsoleDirXml,
-                          0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "table", Builtins::kConsoleTable,
-                          0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "trace", Builtins::kConsoleTrace,
-                          0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "group", Builtins::kConsoleGroup,
+    SimpleInstallFunction(isolate_, console, "warn", Builtin::kConsoleWarn, 0,
+                          false, NONE);
+    SimpleInstallFunction(isolate_, console, "dir", Builtin::kConsoleDir, 0,
+                          false, NONE);
+    SimpleInstallFunction(isolate_, console, "dirxml", Builtin::kConsoleDirXml,
                           0, false, NONE);
+    SimpleInstallFunction(isolate_, console, "table", Builtin::kConsoleTable, 0,
+                          false, NONE);
+    SimpleInstallFunction(isolate_, console, "trace", Builtin::kConsoleTrace, 0,
+                          false, NONE);
+    SimpleInstallFunction(isolate_, console, "group", Builtin::kConsoleGroup, 0,
+                          false, NONE);
     SimpleInstallFunction(isolate_, console, "groupCollapsed",
-                          Builtins::kConsoleGroupCollapsed, 0, false, NONE);
+                          Builtin::kConsoleGroupCollapsed, 0, false, NONE);
     SimpleInstallFunction(isolate_, console, "groupEnd",
-                          Builtins::kConsoleGroupEnd, 0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "clear", Builtins::kConsoleClear,
-                          0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "count", Builtins::kConsoleCount,
-                          0, false, NONE);
+                          Builtin::kConsoleGroupEnd, 0, false, NONE);
+    SimpleInstallFunction(isolate_, console, "clear", Builtin::kConsoleClear, 0,
+                          false, NONE);
+    SimpleInstallFunction(isolate_, console, "count", Builtin::kConsoleCount, 0,
+                          false, NONE);
     SimpleInstallFunction(isolate_, console, "countReset",
-                          Builtins::kConsoleCountReset, 0, false, NONE);
+                          Builtin::kConsoleCountReset, 0, false, NONE);
     SimpleInstallFunction(isolate_, console, "assert",
-                          Builtins::kFastConsoleAssert, 0, false, NONE);
+                          Builtin::kFastConsoleAssert, 0, false, NONE);
     SimpleInstallFunction(isolate_, console, "profile",
-                          Builtins::kConsoleProfile, 0, false, NONE);
+                          Builtin::kConsoleProfile, 0, false, NONE);
     SimpleInstallFunction(isolate_, console, "profileEnd",
-                          Builtins::kConsoleProfileEnd, 0, false, NONE);
-    SimpleInstallFunction(isolate_, console, "time", Builtins::kConsoleTime, 0,
+                          Builtin::kConsoleProfileEnd, 0, false, NONE);
+    SimpleInstallFunction(isolate_, console, "time", Builtin::kConsoleTime, 0,
                           false, NONE);
     SimpleInstallFunction(isolate_, console, "timeLog",
-                          Builtins::kConsoleTimeLog, 0, false, NONE);
+                          Builtin::kConsoleTimeLog, 0, false, NONE);
     SimpleInstallFunction(isolate_, console, "timeEnd",
-                          Builtins::kConsoleTimeEnd, 0, false, NONE);
+                          Builtin::kConsoleTimeEnd, 0, false, NONE);
     SimpleInstallFunction(isolate_, console, "timeStamp",
-                          Builtins::kConsoleTimeStamp, 0, false, NONE);
+                          Builtin::kConsoleTimeStamp, 0, false, NONE);
     SimpleInstallFunction(isolate_, console, "context",
-                          Builtins::kConsoleContext, 1, true, NONE);
+                          Builtin::kConsoleContext, 1, true, NONE);
     InstallToStringTag(isolate_, console, "Object");
   }
 
@@ -2884,13 +2874,13 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallToStringTag(isolate_, intl, "Intl");
 
     SimpleInstallFunction(isolate(), intl, "getCanonicalLocales",
-                          Builtins::kIntlGetCanonicalLocales, 1, false);
+                          Builtin::kIntlGetCanonicalLocales, 1, false);
 
     {  // -- D a t e T i m e F o r m a t
       Handle<JSFunction> date_time_format_constructor = InstallFunction(
           isolate_, intl, "DateTimeFormat", JS_DATE_TIME_FORMAT_TYPE,
           JSDateTimeFormat::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kDateTimeFormatConstructor);
+          Builtin::kDateTimeFormatConstructor);
       date_time_format_constructor->shared().set_length(0);
       date_time_format_constructor->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(
@@ -2899,7 +2889,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
       SimpleInstallFunction(
           isolate(), date_time_format_constructor, "supportedLocalesOf",
-          Builtins::kDateTimeFormatSupportedLocalesOf, 1, false);
+          Builtin::kDateTimeFormatSupportedLocalesOf, 1, false);
 
       Handle<JSObject> prototype(
           JSObject::cast(date_time_format_constructor->prototype()), isolate_);
@@ -2907,38 +2897,38 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       InstallToStringTag(isolate_, prototype, "Intl.DateTimeFormat");
 
       SimpleInstallFunction(isolate_, prototype, "resolvedOptions",
-                            Builtins::kDateTimeFormatPrototypeResolvedOptions,
-                            0, false);
+                            Builtin::kDateTimeFormatPrototypeResolvedOptions, 0,
+                            false);
 
       SimpleInstallFunction(isolate_, prototype, "formatToParts",
-                            Builtins::kDateTimeFormatPrototypeFormatToParts, 1,
+                            Builtin::kDateTimeFormatPrototypeFormatToParts, 1,
                             false);
 
       SimpleInstallGetter(isolate_, prototype, factory->format_string(),
-                          Builtins::kDateTimeFormatPrototypeFormat, false);
+                          Builtin::kDateTimeFormatPrototypeFormat, false);
 
       SimpleInstallFunction(isolate_, prototype, "formatRange",
-                            Builtins::kDateTimeFormatPrototypeFormatRange, 2,
+                            Builtin::kDateTimeFormatPrototypeFormatRange, 2,
                             false);
-      SimpleInstallFunction(
-          isolate_, prototype, "formatRangeToParts",
-          Builtins::kDateTimeFormatPrototypeFormatRangeToParts, 2, false);
+      SimpleInstallFunction(isolate_, prototype, "formatRangeToParts",
+                            Builtin::kDateTimeFormatPrototypeFormatRangeToParts,
+                            2, false);
     }
 
     {  // -- N u m b e r F o r m a t
       Handle<JSFunction> number_format_constructor = InstallFunction(
           isolate_, intl, "NumberFormat", JS_NUMBER_FORMAT_TYPE,
           JSNumberFormat::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kNumberFormatConstructor);
+          Builtin::kNumberFormatConstructor);
       number_format_constructor->shared().set_length(0);
       number_format_constructor->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(
           isolate_, number_format_constructor,
           Context::INTL_NUMBER_FORMAT_FUNCTION_INDEX);
 
-      SimpleInstallFunction(
-          isolate(), number_format_constructor, "supportedLocalesOf",
-          Builtins::kNumberFormatSupportedLocalesOf, 1, false);
+      SimpleInstallFunction(isolate(), number_format_constructor,
+                            "supportedLocalesOf",
+                            Builtin::kNumberFormatSupportedLocalesOf, 1, false);
 
       Handle<JSObject> prototype(
           JSObject::cast(number_format_constructor->prototype()), isolate_);
@@ -2946,27 +2936,27 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       InstallToStringTag(isolate_, prototype, "Intl.NumberFormat");
 
       SimpleInstallFunction(isolate_, prototype, "resolvedOptions",
-                            Builtins::kNumberFormatPrototypeResolvedOptions, 0,
+                            Builtin::kNumberFormatPrototypeResolvedOptions, 0,
                             false);
 
       SimpleInstallFunction(isolate_, prototype, "formatToParts",
-                            Builtins::kNumberFormatPrototypeFormatToParts, 1,
+                            Builtin::kNumberFormatPrototypeFormatToParts, 1,
                             false);
       SimpleInstallGetter(isolate_, prototype, factory->format_string(),
-                          Builtins::kNumberFormatPrototypeFormatNumber, false);
+                          Builtin::kNumberFormatPrototypeFormatNumber, false);
     }
 
     {  // -- C o l l a t o r
       Handle<JSFunction> collator_constructor = InstallFunction(
           isolate_, intl, "Collator", JS_COLLATOR_TYPE, JSCollator::kHeaderSize,
-          0, factory->the_hole_value(), Builtins::kCollatorConstructor);
+          0, factory->the_hole_value(), Builtin::kCollatorConstructor);
       collator_constructor->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(isolate_, collator_constructor,
                                        Context::INTL_COLLATOR_FUNCTION_INDEX);
 
       SimpleInstallFunction(isolate(), collator_constructor,
                             "supportedLocalesOf",
-                            Builtins::kCollatorSupportedLocalesOf, 1, false);
+                            Builtin::kCollatorSupportedLocalesOf, 1, false);
 
       Handle<JSObject> prototype(
           JSObject::cast(collator_constructor->prototype()), isolate_);
@@ -2974,23 +2964,23 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       InstallToStringTag(isolate_, prototype, "Intl.Collator");
 
       SimpleInstallFunction(isolate_, prototype, "resolvedOptions",
-                            Builtins::kCollatorPrototypeResolvedOptions, 0,
+                            Builtin::kCollatorPrototypeResolvedOptions, 0,
                             false);
 
       SimpleInstallGetter(isolate_, prototype, factory->compare_string(),
-                          Builtins::kCollatorPrototypeCompare, false);
+                          Builtin::kCollatorPrototypeCompare, false);
     }
 
     {  // -- V 8 B r e a k I t e r a t o r
       Handle<JSFunction> v8_break_iterator_constructor = InstallFunction(
           isolate_, intl, "v8BreakIterator", JS_V8_BREAK_ITERATOR_TYPE,
           JSV8BreakIterator::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kV8BreakIteratorConstructor);
+          Builtin::kV8BreakIteratorConstructor);
       v8_break_iterator_constructor->shared().DontAdaptArguments();
 
       SimpleInstallFunction(
           isolate_, v8_break_iterator_constructor, "supportedLocalesOf",
-          Builtins::kV8BreakIteratorSupportedLocalesOf, 1, false);
+          Builtin::kV8BreakIteratorSupportedLocalesOf, 1, false);
 
       Handle<JSObject> prototype(
           JSObject::cast(v8_break_iterator_constructor->prototype()), isolate_);
@@ -2998,30 +2988,30 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       InstallToStringTag(isolate_, prototype, factory->Object_string());
 
       SimpleInstallFunction(isolate_, prototype, "resolvedOptions",
-                            Builtins::kV8BreakIteratorPrototypeResolvedOptions,
+                            Builtin::kV8BreakIteratorPrototypeResolvedOptions,
                             0, false);
 
       SimpleInstallGetter(isolate_, prototype, factory->adoptText_string(),
-                          Builtins::kV8BreakIteratorPrototypeAdoptText, false);
+                          Builtin::kV8BreakIteratorPrototypeAdoptText, false);
 
       SimpleInstallGetter(isolate_, prototype, factory->first_string(),
-                          Builtins::kV8BreakIteratorPrototypeFirst, false);
+                          Builtin::kV8BreakIteratorPrototypeFirst, false);
 
       SimpleInstallGetter(isolate_, prototype, factory->next_string(),
-                          Builtins::kV8BreakIteratorPrototypeNext, false);
+                          Builtin::kV8BreakIteratorPrototypeNext, false);
 
       SimpleInstallGetter(isolate_, prototype, factory->current_string(),
-                          Builtins::kV8BreakIteratorPrototypeCurrent, false);
+                          Builtin::kV8BreakIteratorPrototypeCurrent, false);
 
       SimpleInstallGetter(isolate_, prototype, factory->breakType_string(),
-                          Builtins::kV8BreakIteratorPrototypeBreakType, false);
+                          Builtin::kV8BreakIteratorPrototypeBreakType, false);
     }
 
     {  // -- P l u r a l R u l e s
       Handle<JSFunction> plural_rules_constructor = InstallFunction(
           isolate_, intl, "PluralRules", JS_PLURAL_RULES_TYPE,
           JSPluralRules::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kPluralRulesConstructor);
+          Builtin::kPluralRulesConstructor);
       plural_rules_constructor->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(
           isolate_, plural_rules_constructor,
@@ -3029,7 +3019,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
       SimpleInstallFunction(isolate(), plural_rules_constructor,
                             "supportedLocalesOf",
-                            Builtins::kPluralRulesSupportedLocalesOf, 1, false);
+                            Builtin::kPluralRulesSupportedLocalesOf, 1, false);
 
       Handle<JSObject> prototype(
           JSObject::cast(plural_rules_constructor->prototype()), isolate_);
@@ -3037,18 +3027,18 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       InstallToStringTag(isolate_, prototype, "Intl.PluralRules");
 
       SimpleInstallFunction(isolate_, prototype, "resolvedOptions",
-                            Builtins::kPluralRulesPrototypeResolvedOptions, 0,
+                            Builtin::kPluralRulesPrototypeResolvedOptions, 0,
                             false);
 
       SimpleInstallFunction(isolate_, prototype, "select",
-                            Builtins::kPluralRulesPrototypeSelect, 1, false);
+                            Builtin::kPluralRulesPrototypeSelect, 1, false);
     }
 
     {  // -- R e l a t i v e T i m e F o r m a t
       Handle<JSFunction> relative_time_format_fun = InstallFunction(
           isolate(), intl, "RelativeTimeFormat", JS_RELATIVE_TIME_FORMAT_TYPE,
           JSRelativeTimeFormat::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kRelativeTimeFormatConstructor);
+          Builtin::kRelativeTimeFormatConstructor);
       relative_time_format_fun->shared().set_length(0);
       relative_time_format_fun->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(
@@ -3057,7 +3047,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
       SimpleInstallFunction(
           isolate(), relative_time_format_fun, "supportedLocalesOf",
-          Builtins::kRelativeTimeFormatSupportedLocalesOf, 1, false);
+          Builtin::kRelativeTimeFormatSupportedLocalesOf, 1, false);
 
       // Setup %RelativeTimeFormatPrototype%.
       Handle<JSObject> prototype(
@@ -3068,12 +3058,12 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
       SimpleInstallFunction(
           isolate(), prototype, "resolvedOptions",
-          Builtins::kRelativeTimeFormatPrototypeResolvedOptions, 0, false);
+          Builtin::kRelativeTimeFormatPrototypeResolvedOptions, 0, false);
       SimpleInstallFunction(isolate(), prototype, "format",
-                            Builtins::kRelativeTimeFormatPrototypeFormat, 2,
+                            Builtin::kRelativeTimeFormatPrototypeFormat, 2,
                             false);
       SimpleInstallFunction(isolate(), prototype, "formatToParts",
-                            Builtins::kRelativeTimeFormatPrototypeFormatToParts,
+                            Builtin::kRelativeTimeFormatPrototypeFormatToParts,
                             2, false);
     }
 
@@ -3081,14 +3071,14 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       Handle<JSFunction> list_format_fun = InstallFunction(
           isolate(), intl, "ListFormat", JS_LIST_FORMAT_TYPE,
           JSListFormat::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kListFormatConstructor);
+          Builtin::kListFormatConstructor);
       list_format_fun->shared().set_length(0);
       list_format_fun->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(
           isolate_, list_format_fun, Context::INTL_LIST_FORMAT_FUNCTION_INDEX);
 
       SimpleInstallFunction(isolate(), list_format_fun, "supportedLocalesOf",
-                            Builtins::kListFormatSupportedLocalesOf, 1, false);
+                            Builtin::kListFormatSupportedLocalesOf, 1, false);
 
       // Setup %ListFormatPrototype%.
       Handle<JSObject> prototype(
@@ -3097,19 +3087,19 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       InstallToStringTag(isolate(), prototype, "Intl.ListFormat");
 
       SimpleInstallFunction(isolate(), prototype, "resolvedOptions",
-                            Builtins::kListFormatPrototypeResolvedOptions, 0,
+                            Builtin::kListFormatPrototypeResolvedOptions, 0,
                             false);
       SimpleInstallFunction(isolate(), prototype, "format",
-                            Builtins::kListFormatPrototypeFormat, 1, false);
+                            Builtin::kListFormatPrototypeFormat, 1, false);
       SimpleInstallFunction(isolate(), prototype, "formatToParts",
-                            Builtins::kListFormatPrototypeFormatToParts, 1,
+                            Builtin::kListFormatPrototypeFormatToParts, 1,
                             false);
     }
 
     {  // -- L o c a l e
       Handle<JSFunction> locale_fun = InstallFunction(
           isolate(), intl, "Locale", JS_LOCALE_TYPE, JSLocale::kHeaderSize, 0,
-          factory->the_hole_value(), Builtins::kLocaleConstructor);
+          factory->the_hole_value(), Builtin::kLocaleConstructor);
       InstallWithIntrinsicDefaultProto(isolate(), locale_fun,
                                        Context::INTL_LOCALE_FUNCTION_INDEX);
       locale_fun->shared().set_length(1);
@@ -3122,41 +3112,41 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       InstallToStringTag(isolate(), prototype, "Intl.Locale");
 
       SimpleInstallFunction(isolate(), prototype, "toString",
-                            Builtins::kLocalePrototypeToString, 0, false);
+                            Builtin::kLocalePrototypeToString, 0, false);
       SimpleInstallFunction(isolate(), prototype, "maximize",
-                            Builtins::kLocalePrototypeMaximize, 0, false);
+                            Builtin::kLocalePrototypeMaximize, 0, false);
       SimpleInstallFunction(isolate(), prototype, "minimize",
-                            Builtins::kLocalePrototypeMinimize, 0, false);
+                            Builtin::kLocalePrototypeMinimize, 0, false);
       // Base locale getters.
       SimpleInstallGetter(isolate(), prototype, factory->language_string(),
-                          Builtins::kLocalePrototypeLanguage, true);
+                          Builtin::kLocalePrototypeLanguage, true);
       SimpleInstallGetter(isolate(), prototype, factory->script_string(),
-                          Builtins::kLocalePrototypeScript, true);
+                          Builtin::kLocalePrototypeScript, true);
       SimpleInstallGetter(isolate(), prototype, factory->region_string(),
-                          Builtins::kLocalePrototypeRegion, true);
+                          Builtin::kLocalePrototypeRegion, true);
       SimpleInstallGetter(isolate(), prototype, factory->baseName_string(),
-                          Builtins::kLocalePrototypeBaseName, true);
+                          Builtin::kLocalePrototypeBaseName, true);
       // Unicode extension getters.
       SimpleInstallGetter(isolate(), prototype, factory->calendar_string(),
-                          Builtins::kLocalePrototypeCalendar, true);
+                          Builtin::kLocalePrototypeCalendar, true);
       SimpleInstallGetter(isolate(), prototype, factory->caseFirst_string(),
-                          Builtins::kLocalePrototypeCaseFirst, true);
+                          Builtin::kLocalePrototypeCaseFirst, true);
       SimpleInstallGetter(isolate(), prototype, factory->collation_string(),
-                          Builtins::kLocalePrototypeCollation, true);
+                          Builtin::kLocalePrototypeCollation, true);
       SimpleInstallGetter(isolate(), prototype, factory->hourCycle_string(),
-                          Builtins::kLocalePrototypeHourCycle, true);
+                          Builtin::kLocalePrototypeHourCycle, true);
       SimpleInstallGetter(isolate(), prototype, factory->numeric_string(),
-                          Builtins::kLocalePrototypeNumeric, true);
+                          Builtin::kLocalePrototypeNumeric, true);
       SimpleInstallGetter(isolate(), prototype,
                           factory->numberingSystem_string(),
-                          Builtins::kLocalePrototypeNumberingSystem, true);
+                          Builtin::kLocalePrototypeNumberingSystem, true);
     }
 
     {  // -- D i s p l a y N a m e s
       Handle<JSFunction> display_names_fun = InstallFunction(
           isolate(), intl, "DisplayNames", JS_DISPLAY_NAMES_TYPE,
           JSDisplayNames::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kDisplayNamesConstructor);
+          Builtin::kDisplayNamesConstructor);
       display_names_fun->shared().set_length(2);
       display_names_fun->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(
@@ -3164,8 +3154,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
           Context::INTL_DISPLAY_NAMES_FUNCTION_INDEX);
 
       SimpleInstallFunction(isolate(), display_names_fun, "supportedLocalesOf",
-                            Builtins::kDisplayNamesSupportedLocalesOf, 1,
-                            false);
+                            Builtin::kDisplayNamesSupportedLocalesOf, 1, false);
 
       {
         // Setup %DisplayNamesPrototype%.
@@ -3175,11 +3164,11 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
         InstallToStringTag(isolate(), prototype, "Intl.DisplayNames");
 
         SimpleInstallFunction(isolate(), prototype, "resolvedOptions",
-                              Builtins::kDisplayNamesPrototypeResolvedOptions,
-                              0, false);
+                              Builtin::kDisplayNamesPrototypeResolvedOptions, 0,
+                              false);
 
         SimpleInstallFunction(isolate(), prototype, "of",
-                              Builtins::kDisplayNamesPrototypeOf, 1, false);
+                              Builtin::kDisplayNamesPrototypeOf, 1, false);
       }
     }
 
@@ -3187,13 +3176,13 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
       Handle<JSFunction> segmenter_fun = InstallFunction(
           isolate(), intl, "Segmenter", JS_SEGMENTER_TYPE,
           JSSegmenter::kHeaderSize, 0, factory->the_hole_value(),
-          Builtins::kSegmenterConstructor);
+          Builtin::kSegmenterConstructor);
       segmenter_fun->shared().set_length(0);
       segmenter_fun->shared().DontAdaptArguments();
       InstallWithIntrinsicDefaultProto(isolate_, segmenter_fun,
                                        Context::INTL_SEGMENTER_FUNCTION_INDEX);
       SimpleInstallFunction(isolate(), segmenter_fun, "supportedLocalesOf",
-                            Builtins::kSegmenterSupportedLocalesOf, 1, false);
+                            Builtin::kSegmenterSupportedLocalesOf, 1, false);
       {
         // Setup %SegmenterPrototype%.
         Handle<JSObject> prototype(
@@ -3206,10 +3195,10 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
         // "Intl.Segmenter".
         InstallToStringTag(isolate(), prototype, "Intl.Segmenter");
         SimpleInstallFunction(isolate(), prototype, "resolvedOptions",
-                              Builtins::kSegmenterPrototypeResolvedOptions, 0,
+                              Builtin::kSegmenterPrototypeResolvedOptions, 0,
                               false);
         SimpleInstallFunction(isolate(), prototype, "segment",
-                              Builtins::kSegmenterPrototypeSegment, 1, false);
+                              Builtin::kSegmenterPrototypeSegment, 1, false);
       }
       {
         // Setup %SegmentsPrototype%.
@@ -3220,15 +3209,15 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                 .ToHandleChecked();
         Handle<JSFunction> segments_fun = CreateFunction(
             isolate(), name_string, JS_SEGMENTS_TYPE, JSSegments::kHeaderSize,
-            0, prototype, Builtins::kIllegal);
+            0, prototype, Builtin::kIllegal);
         segments_fun->shared().set_native(false);
         segments_fun->shared().set_length(0);
         segments_fun->shared().DontAdaptArguments();
         SimpleInstallFunction(isolate(), prototype, "containing",
-                              Builtins::kSegmentsPrototypeContaining, 1, false);
+                              Builtin::kSegmentsPrototypeContaining, 1, false);
         InstallFunctionAtSymbol(isolate_, prototype, factory->iterator_symbol(),
                                 "[Symbol.iterator]",
-                                Builtins::kSegmentsPrototypeIterator, 0, true,
+                                Builtin::kSegmentsPrototypeIterator, 0, true,
                                 DONT_ENUM);
         Handle<Map> segments_map(segments_fun->initial_map(), isolate());
         native_context()->set_intl_segments_map(*segments_map);
@@ -3248,15 +3237,14 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
         // "Segmenter String Iterator".
         InstallToStringTag(isolate(), prototype, "Segmenter String Iterator");
         SimpleInstallFunction(isolate(), prototype, "next",
-                              Builtins::kSegmentIteratorPrototypeNext, 0,
-                              false);
+                              Builtin::kSegmentIteratorPrototypeNext, 0, false);
         // Setup SegmentIterator constructor.
         Handle<String> name_string =
             Name::ToFunctionName(isolate(), factory->SegmentIterator_string())
                 .ToHandleChecked();
         Handle<JSFunction> segment_iterator_fun = CreateFunction(
             isolate(), name_string, JS_SEGMENT_ITERATOR_TYPE,
-            JSSegmentIterator::kHeaderSize, 0, prototype, Builtins::kIllegal);
+            JSSegmentIterator::kHeaderSize, 0, prototype, Builtin::kIllegal);
         segment_iterator_fun->shared().set_native(false);
         Handle<Map> segment_iterator_map(segment_iterator_fun->initial_map(),
                                          isolate());
@@ -3278,7 +3266,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
         isolate_,
         factory->InternalizeUtf8String(
             "arrayBufferConstructor_DoNotInitialize"),
-        Builtins::kArrayBufferConstructor_DoNotInitialize, 1, false);
+        Builtin::kArrayBufferConstructor_DoNotInitialize, 1, false);
     native_context()->set_array_buffer_noinit_fun(*array_buffer_noinit_fun);
   }
 
@@ -3316,47 +3304,47 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     native_context()->set_atomics_object(*atomics_object);
 
     SimpleInstallFunction(isolate_, atomics_object, "load",
-                          Builtins::kAtomicsLoad, 2, true);
+                          Builtin::kAtomicsLoad, 2, true);
     SimpleInstallFunction(isolate_, atomics_object, "store",
-                          Builtins::kAtomicsStore, 3, true);
-    SimpleInstallFunction(isolate_, atomics_object, "add",
-                          Builtins::kAtomicsAdd, 3, true);
-    SimpleInstallFunction(isolate_, atomics_object, "sub",
-                          Builtins::kAtomicsSub, 3, true);
-    SimpleInstallFunction(isolate_, atomics_object, "and",
-                          Builtins::kAtomicsAnd, 3, true);
-    SimpleInstallFunction(isolate_, atomics_object, "or", Builtins::kAtomicsOr,
+                          Builtin::kAtomicsStore, 3, true);
+    SimpleInstallFunction(isolate_, atomics_object, "add", Builtin::kAtomicsAdd,
+                          3, true);
+    SimpleInstallFunction(isolate_, atomics_object, "sub", Builtin::kAtomicsSub,
+                          3, true);
+    SimpleInstallFunction(isolate_, atomics_object, "and", Builtin::kAtomicsAnd,
+                          3, true);
+    SimpleInstallFunction(isolate_, atomics_object, "or", Builtin::kAtomicsOr,
+                          3, true);
+    SimpleInstallFunction(isolate_, atomics_object, "xor", Builtin::kAtomicsXor,
                           3, true);
-    SimpleInstallFunction(isolate_, atomics_object, "xor",
-                          Builtins::kAtomicsXor, 3, true);
     SimpleInstallFunction(isolate_, atomics_object, "exchange",
-                          Builtins::kAtomicsExchange, 3, true);
+                          Builtin::kAtomicsExchange, 3, true);
     SimpleInstallFunction(isolate_, atomics_object, "compareExchange",
-                          Builtins::kAtomicsCompareExchange, 4, true);
+                          Builtin::kAtomicsCompareExchange, 4, true);
     SimpleInstallFunction(isolate_, atomics_object, "isLockFree",
-                          Builtins::kAtomicsIsLockFree, 1, true);
+                          Builtin::kAtomicsIsLockFree, 1, true);
     SimpleInstallFunction(isolate_, atomics_object, "wait",
-                          Builtins::kAtomicsWait, 4, true);
+                          Builtin::kAtomicsWait, 4, true);
     SimpleInstallFunction(isolate(), atomics_object, "waitAsync",
-                          Builtins::kAtomicsWaitAsync, 4, true);
+                          Builtin::kAtomicsWaitAsync, 4, true);
     SimpleInstallFunction(isolate_, atomics_object, "notify",
-                          Builtins::kAtomicsNotify, 3, true);
+                          Builtin::kAtomicsNotify, 3, true);
   }
 
   {  // -- T y p e d A r r a y
     Handle<JSFunction> typed_array_fun = CreateFunction(
         isolate_, factory->InternalizeUtf8String("TypedArray"),
         JS_TYPED_ARRAY_TYPE, JSTypedArray::kHeaderSize, 0,
-        factory->the_hole_value(), Builtins::kTypedArrayBaseConstructor);
+        factory->the_hole_value(), Builtin::kTypedArrayBaseConstructor);
     typed_array_fun->shared().set_native(false);
     typed_array_fun->shared().set_length(0);
     InstallSpeciesGetter(isolate_, typed_array_fun);
     native_context()->set_typed_array_function(*typed_array_fun);
 
     SimpleInstallFunction(isolate_, typed_array_fun, "of",
-                          Builtins::kTypedArrayOf, 0, false);
+                          Builtin::kTypedArrayOf, 0, false);
     SimpleInstallFunction(isolate_, typed_array_fun, "from",
-                          Builtins::kTypedArrayFrom, 1, false);
+                          Builtin::kTypedArrayFrom, 1, false);
 
     // Setup %TypedArrayPrototype%.
     Handle<JSObject> prototype(
@@ -3366,73 +3354,72 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     // Install the "buffer", "byteOffset", "byteLength", "length"
     // and @@toStringTag getters on the {prototype}.
     SimpleInstallGetter(isolate_, prototype, factory->buffer_string(),
-                        Builtins::kTypedArrayPrototypeBuffer, false);
+                        Builtin::kTypedArrayPrototypeBuffer, false);
     SimpleInstallGetter(isolate_, prototype, factory->byte_length_string(),
-                        Builtins::kTypedArrayPrototypeByteLength, true);
+                        Builtin::kTypedArrayPrototypeByteLength, true);
     SimpleInstallGetter(isolate_, prototype, factory->byte_offset_string(),
-                        Builtins::kTypedArrayPrototypeByteOffset, true);
+                        Builtin::kTypedArrayPrototypeByteOffset, true);
     SimpleInstallGetter(isolate_, prototype, factory->length_string(),
-                        Builtins::kTypedArrayPrototypeLength, true);
+                        Builtin::kTypedArrayPrototypeLength, true);
     SimpleInstallGetter(isolate_, prototype, factory->to_string_tag_symbol(),
-                        Builtins::kTypedArrayPrototypeToStringTag, true);
+                        Builtin::kTypedArrayPrototypeToStringTag, true);
 
     // Install "keys", "values" and "entries" methods on the {prototype}.
     InstallFunctionWithBuiltinId(isolate_, prototype, "entries",
-                                 Builtins::kTypedArrayPrototypeEntries, 0,
-                                 true);
+                                 Builtin::kTypedArrayPrototypeEntries, 0, true);
 
     InstallFunctionWithBuiltinId(isolate_, prototype, "keys",
-                                 Builtins::kTypedArrayPrototypeKeys, 0, true);
+                                 Builtin::kTypedArrayPrototypeKeys, 0, true);
 
     Handle<JSFunction> values = InstallFunctionWithBuiltinId(
-        isolate_, prototype, "values", Builtins::kTypedArrayPrototypeValues, 0,
+        isolate_, prototype, "values", Builtin::kTypedArrayPrototypeValues, 0,
         true);
     JSObject::AddProperty(isolate_, prototype, factory->iterator_symbol(),
                           values, DONT_ENUM);
 
     // TODO(caitp): alphasort accessors/methods
     SimpleInstallFunction(isolate_, prototype, "copyWithin",
-                          Builtins::kTypedArrayPrototypeCopyWithin, 2, false);
+                          Builtin::kTypedArrayPrototypeCopyWithin, 2, false);
     SimpleInstallFunction(isolate_, prototype, "every",
-                          Builtins::kTypedArrayPrototypeEvery, 1, false);
+                          Builtin::kTypedArrayPrototypeEvery, 1, false);
     SimpleInstallFunction(isolate_, prototype, "fill",
-                          Builtins::kTypedArrayPrototypeFill, 1, false);
+                          Builtin::kTypedArrayPrototypeFill, 1, false);
     SimpleInstallFunction(isolate_, prototype, "filter",
-                          Builtins::kTypedArrayPrototypeFilter, 1, false);
+                          Builtin::kTypedArrayPrototypeFilter, 1, false);
     SimpleInstallFunction(isolate_, prototype, "find",
-                          Builtins::kTypedArrayPrototypeFind, 1, false);
+                          Builtin::kTypedArrayPrototypeFind, 1, false);
     SimpleInstallFunction(isolate_, prototype, "findIndex",
-                          Builtins::kTypedArrayPrototypeFindIndex, 1, false);
+                          Builtin::kTypedArrayPrototypeFindIndex, 1, false);
     SimpleInstallFunction(isolate_, prototype, "forEach",
-                          Builtins::kTypedArrayPrototypeForEach, 1, false);
+                          Builtin::kTypedArrayPrototypeForEach, 1, false);
     SimpleInstallFunction(isolate_, prototype, "includes",
-                          Builtins::kTypedArrayPrototypeIncludes, 1, false);
+                          Builtin::kTypedArrayPrototypeIncludes, 1, false);
     SimpleInstallFunction(isolate_, prototype, "indexOf",
-                          Builtins::kTypedArrayPrototypeIndexOf, 1, false);
+                          Builtin::kTypedArrayPrototypeIndexOf, 1, false);
     SimpleInstallFunction(isolate_, prototype, "join",
-                          Builtins::kTypedArrayPrototypeJoin, 1, false);
+                          Builtin::kTypedArrayPrototypeJoin, 1, false);
     SimpleInstallFunction(isolate_, prototype, "lastIndexOf",
-                          Builtins::kTypedArrayPrototypeLastIndexOf, 1, false);
+                          Builtin::kTypedArrayPrototypeLastIndexOf, 1, false);
     SimpleInstallFunction(isolate_, prototype, "map",
-                          Builtins::kTypedArrayPrototypeMap, 1, false);
+                          Builtin::kTypedArrayPrototypeMap, 1, false);
     SimpleInstallFunction(isolate_, prototype, "reverse",
-                          Builtins::kTypedArrayPrototypeReverse, 0, false);
+                          Builtin::kTypedArrayPrototypeReverse, 0, false);
     SimpleInstallFunction(isolate_, prototype, "reduce",
-                          Builtins::kTypedArrayPrototypeReduce, 1, false);
+                          Builtin::kTypedArrayPrototypeReduce, 1, false);
     SimpleInstallFunction(isolate_, prototype, "reduceRight",
-                          Builtins::kTypedArrayPrototypeReduceRight, 1, false);
+                          Builtin::kTypedArrayPrototypeReduceRight, 1, false);
     SimpleInstallFunction(isolate_, prototype, "set",
-                          Builtins::kTypedArrayPrototypeSet, 1, false);
+                          Builtin::kTypedArrayPrototypeSet, 1, false);
     SimpleInstallFunction(isolate_, prototype, "slice",
-                          Builtins::kTypedArrayPrototypeSlice, 2, false);
+                          Builtin::kTypedArrayPrototypeSlice, 2, false);
     SimpleInstallFunction(isolate_, prototype, "some",
-                          Builtins::kTypedArrayPrototypeSome, 1, false);
+                          Builtin::kTypedArrayPrototypeSome, 1, false);
     SimpleInstallFunction(isolate_, prototype, "sort",
-                          Builtins::kTypedArrayPrototypeSort, 1, false);
+                          Builtin::kTypedArrayPrototypeSort, 1, false);
     SimpleInstallFunction(isolate_, prototype, "subarray",
-                          Builtins::kTypedArrayPrototypeSubArray, 2, false);
+                          Builtin::kTypedArrayPrototypeSubArray, 2, false);
     SimpleInstallFunction(isolate_, prototype, "toLocaleString",
-                          Builtins::kTypedArrayPrototypeToLocaleString, 0,
+                          Builtin::kTypedArrayPrototypeToLocaleString, 0,
                           false);
     JSObject::AddProperty(isolate_, prototype, factory->toString_string(),
                           array_prototype_to_string_fun, DONT_ENUM);
@@ -3455,7 +3442,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSFunction> data_view_fun = InstallFunction(
         isolate_, global, "DataView", JS_DATA_VIEW_TYPE,
         JSDataView::kSizeWithEmbedderFields, 0, factory->the_hole_value(),
-        Builtins::kDataViewConstructor);
+        Builtin::kDataViewConstructor);
     InstallWithIntrinsicDefaultProto(isolate_, data_view_fun,
                                      Context::DATA_VIEW_FUN_INDEX);
     data_view_fun->shared().set_length(1);
@@ -3470,58 +3457,58 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     // Install the "buffer", "byteOffset" and "byteLength" getters
     // on the {prototype}.
     SimpleInstallGetter(isolate_, prototype, factory->buffer_string(),
-                        Builtins::kDataViewPrototypeGetBuffer, false);
+                        Builtin::kDataViewPrototypeGetBuffer, false);
     SimpleInstallGetter(isolate_, prototype, factory->byte_length_string(),
-                        Builtins::kDataViewPrototypeGetByteLength, false);
+                        Builtin::kDataViewPrototypeGetByteLength, false);
     SimpleInstallGetter(isolate_, prototype, factory->byte_offset_string(),
-                        Builtins::kDataViewPrototypeGetByteOffset, false);
+                        Builtin::kDataViewPrototypeGetByteOffset, false);
 
     SimpleInstallFunction(isolate_, prototype, "getInt8",
-                          Builtins::kDataViewPrototypeGetInt8, 1, false);
+                          Builtin::kDataViewPrototypeGetInt8, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setInt8",
-                          Builtins::kDataViewPrototypeSetInt8, 2, false);
+                          Builtin::kDataViewPrototypeSetInt8, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getUint8",
-                          Builtins::kDataViewPrototypeGetUint8, 1, false);
+                          Builtin::kDataViewPrototypeGetUint8, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setUint8",
-                          Builtins::kDataViewPrototypeSetUint8, 2, false);
+                          Builtin::kDataViewPrototypeSetUint8, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getInt16",
-                          Builtins::kDataViewPrototypeGetInt16, 1, false);
+                          Builtin::kDataViewPrototypeGetInt16, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setInt16",
-                          Builtins::kDataViewPrototypeSetInt16, 2, false);
+                          Builtin::kDataViewPrototypeSetInt16, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getUint16",
-                          Builtins::kDataViewPrototypeGetUint16, 1, false);
+                          Builtin::kDataViewPrototypeGetUint16, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setUint16",
-                          Builtins::kDataViewPrototypeSetUint16, 2, false);
+                          Builtin::kDataViewPrototypeSetUint16, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getInt32",
-                          Builtins::kDataViewPrototypeGetInt32, 1, false);
+                          Builtin::kDataViewPrototypeGetInt32, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setInt32",
-                          Builtins::kDataViewPrototypeSetInt32, 2, false);
+                          Builtin::kDataViewPrototypeSetInt32, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getUint32",
-                          Builtins::kDataViewPrototypeGetUint32, 1, false);
+                          Builtin::kDataViewPrototypeGetUint32, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setUint32",
-                          Builtins::kDataViewPrototypeSetUint32, 2, false);
+                          Builtin::kDataViewPrototypeSetUint32, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getFloat32",
-                          Builtins::kDataViewPrototypeGetFloat32, 1, false);
+                          Builtin::kDataViewPrototypeGetFloat32, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setFloat32",
-                          Builtins::kDataViewPrototypeSetFloat32, 2, false);
+                          Builtin::kDataViewPrototypeSetFloat32, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getFloat64",
-                          Builtins::kDataViewPrototypeGetFloat64, 1, false);
+                          Builtin::kDataViewPrototypeGetFloat64, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setFloat64",
-                          Builtins::kDataViewPrototypeSetFloat64, 2, false);
+                          Builtin::kDataViewPrototypeSetFloat64, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getBigInt64",
-                          Builtins::kDataViewPrototypeGetBigInt64, 1, false);
+                          Builtin::kDataViewPrototypeGetBigInt64, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setBigInt64",
-                          Builtins::kDataViewPrototypeSetBigInt64, 2, false);
+                          Builtin::kDataViewPrototypeSetBigInt64, 2, false);
     SimpleInstallFunction(isolate_, prototype, "getBigUint64",
-                          Builtins::kDataViewPrototypeGetBigUint64, 1, false);
+                          Builtin::kDataViewPrototypeGetBigUint64, 1, false);
     SimpleInstallFunction(isolate_, prototype, "setBigUint64",
-                          Builtins::kDataViewPrototypeSetBigUint64, 2, false);
+                          Builtin::kDataViewPrototypeSetBigUint64, 2, false);
   }
 
   {  // -- M a p
     Handle<JSFunction> js_map_fun = InstallFunction(
         isolate_, global, "Map", JS_MAP_TYPE, JSMap::kHeaderSize, 0,
-        factory->the_hole_value(), Builtins::kMapConstructor);
+        factory->the_hole_value(), Builtin::kMapConstructor);
     InstallWithIntrinsicDefaultProto(isolate_, js_map_fun,
                                      Context::JS_MAP_FUN_INDEX);
 
@@ -3536,40 +3523,39 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallToStringTag(isolate_, prototype, factory->Map_string());
 
     Handle<JSFunction> map_get = SimpleInstallFunction(
-        isolate_, prototype, "get", Builtins::kMapPrototypeGet, 1, true);
+        isolate_, prototype, "get", Builtin::kMapPrototypeGet, 1, true);
     native_context()->set_map_get(*map_get);
 
     Handle<JSFunction> map_set = SimpleInstallFunction(
-        isolate_, prototype, "set", Builtins::kMapPrototypeSet, 2, true);
+        isolate_, prototype, "set", Builtin::kMapPrototypeSet, 2, true);
     // Check that index of "set" function in JSCollection is correct.
     DCHECK_EQ(JSCollection::kAddFunctionDescriptorIndex,
               prototype->map().LastAdded().as_int());
     native_context()->set_map_set(*map_set);
 
     Handle<JSFunction> map_has = SimpleInstallFunction(
-        isolate_, prototype, "has", Builtins::kMapPrototypeHas, 1, true);
+        isolate_, prototype, "has", Builtin::kMapPrototypeHas, 1, true);
     native_context()->set_map_has(*map_has);
 
     Handle<JSFunction> map_delete = SimpleInstallFunction(
-        isolate_, prototype, "delete", Builtins::kMapPrototypeDelete, 1, true);
+        isolate_, prototype, "delete", Builtin::kMapPrototypeDelete, 1, true);
     native_context()->set_map_delete(*map_delete);
 
     SimpleInstallFunction(isolate_, prototype, "clear",
-                          Builtins::kMapPrototypeClear, 0, true);
-    Handle<JSFunction> entries =
-        SimpleInstallFunction(isolate_, prototype, "entries",
-                              Builtins::kMapPrototypeEntries, 0, true);
+                          Builtin::kMapPrototypeClear, 0, true);
+    Handle<JSFunction> entries = SimpleInstallFunction(
+        isolate_, prototype, "entries", Builtin::kMapPrototypeEntries, 0, true);
     JSObject::AddProperty(isolate_, prototype, factory->iterator_symbol(),
                           entries, DONT_ENUM);
     SimpleInstallFunction(isolate_, prototype, "forEach",
-                          Builtins::kMapPrototypeForEach, 1, false);
+                          Builtin::kMapPrototypeForEach, 1, false);
     SimpleInstallFunction(isolate_, prototype, "keys",
-                          Builtins::kMapPrototypeKeys, 0, true);
+                          Builtin::kMapPrototypeKeys, 0, true);
     SimpleInstallGetter(isolate_, prototype,
                         factory->InternalizeUtf8String("size"),
-                        Builtins::kMapPrototypeGetSize, true);
+                        Builtin::kMapPrototypeGetSize, true);
     SimpleInstallFunction(isolate_, prototype, "values",
-                          Builtins::kMapPrototypeValues, 0, true);
+                          Builtin::kMapPrototypeValues, 0, true);
 
     native_context()->set_initial_map_prototype_map(prototype->map());
 
@@ -3581,10 +3567,10 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
   }
 
   {  // -- B i g I n t
-    Handle<JSFunction> bigint_fun = InstallFunction(
-        isolate_, global, "BigInt", JS_PRIMITIVE_WRAPPER_TYPE,
-        JSPrimitiveWrapper::kHeaderSize, 0, factory->the_hole_value(),
-        Builtins::kBigIntConstructor);
+    Handle<JSFunction> bigint_fun =
+        InstallFunction(isolate_, global, "BigInt", JS_PRIMITIVE_WRAPPER_TYPE,
+                        JSPrimitiveWrapper::kHeaderSize, 0,
+                        factory->the_hole_value(), Builtin::kBigIntConstructor);
     bigint_fun->shared().DontAdaptArguments();
     bigint_fun->shared().set_length(1);
     InstallWithIntrinsicDefaultProto(isolate_, bigint_fun,
@@ -3593,10 +3579,10 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     // Install the properties of the BigInt constructor.
     // asUintN(bits, bigint)
     SimpleInstallFunction(isolate_, bigint_fun, "asUintN",
-                          Builtins::kBigIntAsUintN, 2, false);
+                          Builtin::kBigIntAsUintN, 2, false);
     // asIntN(bits, bigint)
     SimpleInstallFunction(isolate_, bigint_fun, "asIntN",
-                          Builtins::kBigIntAsIntN, 2, false);
+                          Builtin::kBigIntAsIntN, 2, false);
 
     // Set up the %BigIntPrototype%.
     Handle<JSObject> prototype(JSObject::cast(bigint_fun->instance_prototype()),
@@ -3607,13 +3593,13 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     // "constructor" is created implicitly by InstallFunction() above.
     // toLocaleString([reserved1 [, reserved2]])
     SimpleInstallFunction(isolate_, prototype, "toLocaleString",
-                          Builtins::kBigIntPrototypeToLocaleString, 0, false);
+                          Builtin::kBigIntPrototypeToLocaleString, 0, false);
     // toString([radix])
     SimpleInstallFunction(isolate_, prototype, "toString",
-                          Builtins::kBigIntPrototypeToString, 0, false);
+                          Builtin::kBigIntPrototypeToString, 0, false);
     // valueOf()
     SimpleInstallFunction(isolate_, prototype, "valueOf",
-                          Builtins::kBigIntPrototypeValueOf, 0, false);
+                          Builtin::kBigIntPrototypeValueOf, 0, false);
     // @@toStringTag
     InstallToStringTag(isolate_, prototype, factory->BigInt_string());
   }
@@ -3621,7 +3607,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
   {  // -- S e t
     Handle<JSFunction> js_set_fun = InstallFunction(
         isolate_, global, "Set", JS_SET_TYPE, JSSet::kHeaderSize, 0,
-        factory->the_hole_value(), Builtins::kSetConstructor);
+        factory->the_hole_value(), Builtin::kSetConstructor);
     InstallWithIntrinsicDefaultProto(isolate_, js_set_fun,
                                      Context::JS_SET_FUN_INDEX);
 
@@ -3636,31 +3622,31 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallToStringTag(isolate_, prototype, factory->Set_string());
 
     Handle<JSFunction> set_has = SimpleInstallFunction(
-        isolate_, prototype, "has", Builtins::kSetPrototypeHas, 1, true);
+        isolate_, prototype, "has", Builtin::kSetPrototypeHas, 1, true);
     native_context()->set_set_has(*set_has);
 
     Handle<JSFunction> set_add = SimpleInstallFunction(
-        isolate_, prototype, "add", Builtins::kSetPrototypeAdd, 1, true);
+        isolate_, prototype, "add", Builtin::kSetPrototypeAdd, 1, true);
     // Check that index of "add" function in JSCollection is correct.
     DCHECK_EQ(JSCollection::kAddFunctionDescriptorIndex,
               prototype->map().LastAdded().as_int());
     native_context()->set_set_add(*set_add);
 
     Handle<JSFunction> set_delete = SimpleInstallFunction(
-        isolate_, prototype, "delete", Builtins::kSetPrototypeDelete, 1, true);
+        isolate_, prototype, "delete", Builtin::kSetPrototypeDelete, 1, true);
     native_context()->set_set_delete(*set_delete);
 
     SimpleInstallFunction(isolate_, prototype, "clear",
-                          Builtins::kSetPrototypeClear, 0, true);
+                          Builtin::kSetPrototypeClear, 0, true);
     SimpleInstallFunction(isolate_, prototype, "entries",
-                          Builtins::kSetPrototypeEntries, 0, true);
+                          Builtin::kSetPrototypeEntries, 0, true);
     SimpleInstallFunction(isolate_, prototype, "forEach",
-                          Builtins::kSetPrototypeForEach, 1, false);
+                          Builtin::kSetPrototypeForEach, 1, false);
     SimpleInstallGetter(isolate_, prototype,
                         factory->InternalizeUtf8String("size"),
-                        Builtins::kSetPrototypeGetSize, true);
+                        Builtin::kSetPrototypeGetSize, true);
     Handle<JSFunction> values = SimpleInstallFunction(
-        isolate_, prototype, "values", Builtins::kSetPrototypeValues, 0, true);
+        isolate_, prototype, "values", Builtin::kSetPrototypeValues, 0, true);
     JSObject::AddProperty(isolate_, prototype, factory->keys_string(), values,
                           DONT_ENUM);
     JSObject::AddProperty(isolate_, prototype, factory->iterator_symbol(),
@@ -3733,7 +3719,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
   {  // -- W e a k M a p
     Handle<JSFunction> cons = InstallFunction(
         isolate_, global, "WeakMap", JS_WEAK_MAP_TYPE, JSWeakMap::kHeaderSize,
-        0, factory->the_hole_value(), Builtins::kWeakMapConstructor);
+        0, factory->the_hole_value(), Builtin::kWeakMapConstructor);
     InstallWithIntrinsicDefaultProto(isolate_, cons,
                                      Context::JS_WEAK_MAP_FUN_INDEX);
 
@@ -3746,20 +3732,20 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                                isolate());
 
     SimpleInstallFunction(isolate_, prototype, "delete",
-                          Builtins::kWeakMapPrototypeDelete, 1, true);
+                          Builtin::kWeakMapPrototypeDelete, 1, true);
     Handle<JSFunction> weakmap_get = SimpleInstallFunction(
-        isolate_, prototype, "get", Builtins::kWeakMapGet, 1, true);
+        isolate_, prototype, "get", Builtin::kWeakMapGet, 1, true);
     native_context()->set_weakmap_get(*weakmap_get);
 
     Handle<JSFunction> weakmap_set = SimpleInstallFunction(
-        isolate_, prototype, "set", Builtins::kWeakMapPrototypeSet, 2, true);
+        isolate_, prototype, "set", Builtin::kWeakMapPrototypeSet, 2, true);
     // Check that index of "set" function in JSWeakCollection is correct.
     DCHECK_EQ(JSWeakCollection::kAddFunctionDescriptorIndex,
               prototype->map().LastAdded().as_int());
 
     native_context()->set_weakmap_set(*weakmap_set);
     SimpleInstallFunction(isolate_, prototype, "has",
-                          Builtins::kWeakMapPrototypeHas, 1, true);
+                          Builtin::kWeakMapPrototypeHas, 1, true);
 
     InstallToStringTag(isolate_, prototype, "WeakMap");
 
@@ -3769,7 +3755,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
   {  // -- W e a k S e t
     Handle<JSFunction> cons = InstallFunction(
         isolate_, global, "WeakSet", JS_WEAK_SET_TYPE, JSWeakSet::kHeaderSize,
-        0, factory->the_hole_value(), Builtins::kWeakSetConstructor);
+        0, factory->the_hole_value(), Builtin::kWeakSetConstructor);
     InstallWithIntrinsicDefaultProto(isolate_, cons,
                                      Context::JS_WEAK_SET_FUN_INDEX);
 
@@ -3782,12 +3768,12 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                                isolate());
 
     SimpleInstallFunction(isolate_, prototype, "delete",
-                          Builtins::kWeakSetPrototypeDelete, 1, true);
+                          Builtin::kWeakSetPrototypeDelete, 1, true);
     SimpleInstallFunction(isolate_, prototype, "has",
-                          Builtins::kWeakSetPrototypeHas, 1, true);
+                          Builtin::kWeakSetPrototypeHas, 1, true);
 
     Handle<JSFunction> weakset_add = SimpleInstallFunction(
-        isolate_, prototype, "add", Builtins::kWeakSetPrototypeAdd, 1, true);
+        isolate_, prototype, "add", Builtin::kWeakSetPrototypeAdd, 1, true);
     // Check that index of "add" function in JSWeakCollection is correct.
     DCHECK_EQ(JSWeakCollection::kAddFunctionDescriptorIndex,
               prototype->map().LastAdded().as_int());
@@ -3810,7 +3796,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
     Handle<String> name = factory->Proxy_string();
     Handle<JSFunction> proxy_function = CreateFunctionForBuiltin(
-        isolate(), name, proxy_function_map, Builtins::kProxyConstructor);
+        isolate(), name, proxy_function_map, Builtin::kProxyConstructor);
 
     isolate_->proxy_map()->SetConstructor(*proxy_function);
 
@@ -3823,7 +3809,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     DCHECK(!proxy_function->has_prototype_property());
 
     SimpleInstallFunction(isolate_, proxy_function, "revocable",
-                          Builtins::kProxyRevocable, 2, true);
+                          Builtin::kProxyRevocable, 2, true);
   }
 
   {  // -- R e f l e c t
@@ -3834,37 +3820,37 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallToStringTag(isolate_, reflect, reflect_string);
 
     SimpleInstallFunction(isolate_, reflect, "defineProperty",
-                          Builtins::kReflectDefineProperty, 3, true);
+                          Builtin::kReflectDefineProperty, 3, true);
 
     SimpleInstallFunction(isolate_, reflect, "deleteProperty",
-                          Builtins::kReflectDeleteProperty, 2, true);
+                          Builtin::kReflectDeleteProperty, 2, true);
 
     Handle<JSFunction> apply = SimpleInstallFunction(
-        isolate_, reflect, "apply", Builtins::kReflectApply, 3, false);
+        isolate_, reflect, "apply", Builtin::kReflectApply, 3, false);
     native_context()->set_reflect_apply(*apply);
 
     Handle<JSFunction> construct = SimpleInstallFunction(
-        isolate_, reflect, "construct", Builtins::kReflectConstruct, 2, false);
+        isolate_, reflect, "construct", Builtin::kReflectConstruct, 2, false);
     native_context()->set_reflect_construct(*construct);
 
-    SimpleInstallFunction(isolate_, reflect, "get", Builtins::kReflectGet, 2,
+    SimpleInstallFunction(isolate_, reflect, "get", Builtin::kReflectGet, 2,
                           false);
     SimpleInstallFunction(isolate_, reflect, "getOwnPropertyDescriptor",
-                          Builtins::kReflectGetOwnPropertyDescriptor, 2, true);
+                          Builtin::kReflectGetOwnPropertyDescriptor, 2, true);
     SimpleInstallFunction(isolate_, reflect, "getPrototypeOf",
-                          Builtins::kReflectGetPrototypeOf, 1, true);
-    SimpleInstallFunction(isolate_, reflect, "has", Builtins::kReflectHas, 2,
+                          Builtin::kReflectGetPrototypeOf, 1, true);
+    SimpleInstallFunction(isolate_, reflect, "has", Builtin::kReflectHas, 2,
                           true);
     SimpleInstallFunction(isolate_, reflect, "isExtensible",
-                          Builtins::kReflectIsExtensible, 1, true);
+                          Builtin::kReflectIsExtensible, 1, true);
     SimpleInstallFunction(isolate_, reflect, "ownKeys",
-                          Builtins::kReflectOwnKeys, 1, true);
+                          Builtin::kReflectOwnKeys, 1, true);
     SimpleInstallFunction(isolate_, reflect, "preventExtensions",
-                          Builtins::kReflectPreventExtensions, 1, true);
-    SimpleInstallFunction(isolate_, reflect, "set", Builtins::kReflectSet, 3,
+                          Builtin::kReflectPreventExtensions, 1, true);
+    SimpleInstallFunction(isolate_, reflect, "set", Builtin::kReflectSet, 3,
                           false);
     SimpleInstallFunction(isolate_, reflect, "setPrototypeOf",
-                          Builtins::kReflectSetPrototypeOf, 2, true);
+                          Builtin::kReflectSetPrototypeOf, 2, true);
   }
 
   {  // --- B o u n d F u n c t i o n
@@ -3903,7 +3889,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     Handle<JSFunction> finalization_registry_fun = InstallFunction(
         isolate_, global, factory->FinalizationRegistry_string(),
         JS_FINALIZATION_REGISTRY_TYPE, JSFinalizationRegistry::kHeaderSize, 0,
-        factory->the_hole_value(), Builtins::kFinalizationRegistryConstructor);
+        factory->the_hole_value(), Builtin::kFinalizationRegistryConstructor);
     InstallWithIntrinsicDefaultProto(
         isolate_, finalization_registry_fun,
         Context::JS_FINALIZATION_REGISTRY_FUNCTION_INDEX);
@@ -3919,11 +3905,11 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
                        factory->FinalizationRegistry_string());
 
     SimpleInstallFunction(isolate_, finalization_registry_prototype, "register",
-                          Builtins::kFinalizationRegistryRegister, 2, false);
+                          Builtin::kFinalizationRegistryRegister, 2, false);
 
     SimpleInstallFunction(isolate_, finalization_registry_prototype,
                           "unregister",
-                          Builtins::kFinalizationRegistryUnregister, 1, false);
+                          Builtin::kFinalizationRegistryUnregister, 1, false);
 
     // The cleanupSome function is created but not exposed, as it is used
     // internally by InvokeFinalizationRegistryCleanupFromTask.
@@ -3931,14 +3917,14 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     // It is exposed by FLAG_harmony_weak_refs_with_cleanup_some.
     Handle<JSFunction> cleanup_some_fun = SimpleCreateFunction(
         isolate_, factory->InternalizeUtf8String("cleanupSome"),
-        Builtins::kFinalizationRegistryPrototypeCleanupSome, 0, false);
+        Builtin::kFinalizationRegistryPrototypeCleanupSome, 0, false);
     native_context()->set_finalization_registry_cleanup_some(*cleanup_some_fun);
   }
 
   {  // -- W e a k R e f
     Handle<JSFunction> weak_ref_fun = InstallFunction(
         isolate_, global, "WeakRef", JS_WEAK_REF_TYPE, JSWeakRef::kHeaderSize,
-        0, factory->the_hole_value(), Builtins::kWeakRefConstructor);
+        0, factory->the_hole_value(), Builtin::kWeakRefConstructor);
     InstallWithIntrinsicDefaultProto(isolate_, weak_ref_fun,
                                      Context::JS_WEAK_REF_FUNCTION_INDEX);
 
@@ -3951,13 +3937,13 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     InstallToStringTag(isolate_, weak_ref_prototype, factory->WeakRef_string());
 
     SimpleInstallFunction(isolate_, weak_ref_prototype, "deref",
-                          Builtins::kWeakRefDeref, 0, true);
+                          Builtin::kWeakRefDeref, 0, true);
   }
 
   {  // --- sloppy arguments map
     Handle<String> arguments_string = factory->Arguments_string();
     Handle<JSFunction> function = CreateFunctionForBuiltinWithPrototype(
-        isolate(), arguments_string, Builtins::kIllegal,
+        isolate(), arguments_string, Builtin::kIllegal,
         isolate()->initial_object_prototype(), JS_ARGUMENTS_OBJECT_TYPE,
         JSSloppyArgumentsObject::kSize, 2, MUTABLE);
     Handle<Map> map(function->initial_map(), isolate());
@@ -4050,10 +4036,9 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
 
   {  // --- context extension
     // Create a function for the context extension objects.
-    Handle<JSFunction> context_extension_fun =
-        CreateFunction(isolate_, factory->empty_string(),
-                       JS_CONTEXT_EXTENSION_OBJECT_TYPE, JSObject::kHeaderSize,
-                       0, factory->the_hole_value(), Builtins::kIllegal);
+    Handle<JSFunction> context_extension_fun = CreateFunction(
+        isolate_, factory->empty_string(), JS_CONTEXT_EXTENSION_OBJECT_TYPE,
+        JSObject::kHeaderSize, 0, factory->the_hole_value(), Builtin::kIllegal);
     native_context()->set_context_extension_function(*context_extension_fun);
   }
 
@@ -4061,7 +4046,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     // Set up the call-as-function delegate.
     Handle<JSFunction> delegate =
         SimpleCreateFunction(isolate_, factory->empty_string(),
-                             Builtins::kHandleApiCallAsFunction, 0, false);
+                             Builtin::kHandleApiCallAsFunction, 0, false);
     native_context()->set_call_as_function_delegate(*delegate);
   }
 
@@ -4069,7 +4054,7 @@ void Genesis::InitializeGlobal(Handle<JSGlobalObject> global_object,
     // Set up the call-as-constructor delegate.
     Handle<JSFunction> delegate =
         SimpleCreateFunction(isolate_, factory->empty_string(),
-                             Builtins::kHandleApiCallAsConstructor, 0, false);
+                             Builtin::kHandleApiCallAsConstructor, 0, false);
     native_context()->set_call_as_constructor_delegate(*delegate);
   }
 }  // NOLINT(readability/fn_size)
@@ -4087,7 +4072,7 @@ Handle<JSFunction> Genesis::InstallTypedArray(const char* name,
   Handle<JSFunction> result = InstallConstructor(
       isolate(), global, name, JS_TYPED_ARRAY_TYPE,
       JSTypedArray::kSizeWithEmbedderFields, 0, factory()->the_hole_value(),
-      Builtins::kTypedArrayConstructor, type);
+      Builtin::kTypedArrayConstructor, type);
   result->initial_map().set_elements_kind(elements_kind);
 
   result->shared().DontAdaptArguments();
@@ -4200,7 +4185,7 @@ void Genesis::InitializeIteratorFunctions() {
     Handle<JSFunction> generator_function_function = CreateFunction(
         isolate, "GeneratorFunction", JS_FUNCTION_TYPE,
         JSFunction::kSizeWithPrototype, 0, generator_function_prototype,
-        Builtins::kGeneratorFunctionConstructor);
+        Builtin::kGeneratorFunctionConstructor);
     generator_function_function->set_prototype_or_initial_map(
         native_context->generator_function_map(), kReleaseStore);
     generator_function_function->shared().DontAdaptArguments();
@@ -4229,7 +4214,7 @@ void Genesis::InitializeIteratorFunctions() {
     Handle<JSFunction> async_generator_function_function = CreateFunction(
         isolate, "AsyncGeneratorFunction", JS_FUNCTION_TYPE,
         JSFunction::kSizeWithPrototype, 0, async_generator_function_prototype,
-        Builtins::kAsyncGeneratorFunctionConstructor);
+        Builtin::kAsyncGeneratorFunctionConstructor);
     async_generator_function_function->set_prototype_or_initial_map(
         native_context->async_generator_function_map(), kReleaseStore);
     async_generator_function_function->shared().DontAdaptArguments();
@@ -4260,7 +4245,7 @@ void Genesis::InitializeIteratorFunctions() {
 
     // Install the next function on the {prototype}.
     InstallFunctionWithBuiltinId(isolate, prototype, "next",
-                                 Builtins::kSetIteratorPrototypeNext, 0, true);
+                                 Builtin::kSetIteratorPrototypeNext, 0, true);
     native_context->set_initial_set_iterator_prototype(*prototype);
     CHECK_NE(prototype->map().ptr(),
              isolate_->initial_object_prototype()->map().ptr());
@@ -4269,7 +4254,7 @@ void Genesis::InitializeIteratorFunctions() {
     // Setup SetIterator constructor.
     Handle<JSFunction> set_iterator_function = CreateFunction(
         isolate, "SetIterator", JS_SET_VALUE_ITERATOR_TYPE,
-        JSSetIterator::kHeaderSize, 0, prototype, Builtins::kIllegal);
+        JSSetIterator::kHeaderSize, 0, prototype, Builtin::kIllegal);
     set_iterator_function->shared().set_native(false);
 
     Handle<Map> set_value_iterator_map(set_iterator_function->initial_map(),
@@ -4293,7 +4278,7 @@ void Genesis::InitializeIteratorFunctions() {
 
     // Install the next function on the {prototype}.
     InstallFunctionWithBuiltinId(isolate, prototype, "next",
-                                 Builtins::kMapIteratorPrototypeNext, 0, true);
+                                 Builtin::kMapIteratorPrototypeNext, 0, true);
     native_context->set_initial_map_iterator_prototype(*prototype);
     CHECK_NE(prototype->map().ptr(),
              isolate_->initial_object_prototype()->map().ptr());
@@ -4302,7 +4287,7 @@ void Genesis::InitializeIteratorFunctions() {
     // Setup MapIterator constructor.
     Handle<JSFunction> map_iterator_function = CreateFunction(
         isolate, "MapIterator", JS_MAP_KEY_ITERATOR_TYPE,
-        JSMapIterator::kHeaderSize, 0, prototype, Builtins::kIllegal);
+        JSMapIterator::kHeaderSize, 0, prototype, Builtin::kIllegal);
     map_iterator_function->shared().set_native(false);
 
     Handle<Map> map_key_iterator_map(map_iterator_function->initial_map(),
@@ -4330,7 +4315,7 @@ void Genesis::InitializeIteratorFunctions() {
     Handle<JSFunction> async_function_constructor = CreateFunction(
         isolate, "AsyncFunction", JS_FUNCTION_TYPE,
         JSFunction::kSizeWithPrototype, 0, async_function_prototype,
-        Builtins::kAsyncFunctionConstructor);
+        Builtin::kAsyncFunctionConstructor);
     async_function_constructor->set_prototype_or_initial_map(
         native_context->async_function_map(), kReleaseStore);
     async_function_constructor->shared().DontAdaptArguments();
@@ -4371,7 +4356,7 @@ void Genesis::InitializeCallSiteBuiltins() {
 
   Handle<JSFunction> callsite_fun = CreateFunction(
       isolate(), "CallSite", JS_OBJECT_TYPE, JSObject::kHeaderSize, 0,
-      factory->the_hole_value(), Builtins::kUnsupportedThrower);
+      factory->the_hole_value(), Builtin::kUnsupportedThrower);
   callsite_fun->shared().DontAdaptArguments();
   isolate()->native_context()->set_callsite_function(*callsite_fun);
 
@@ -4381,34 +4366,34 @@ void Genesis::InitializeCallSiteBuiltins() {
 
   struct FunctionInfo {
     const char* name;
-    Builtins::Name id;
+    Builtin id;
   };
 
   FunctionInfo infos[] = {
-      {"getColumnNumber", Builtins::kCallSitePrototypeGetColumnNumber},
+      {"getColumnNumber", Builtin::kCallSitePrototypeGetColumnNumber},
       {"getEnclosingColumnNumber",
-        Builtins::kCallSitePrototypeGetEnclosingColumnNumber},
+       Builtin::kCallSitePrototypeGetEnclosingColumnNumber},
       {"getEnclosingLineNumber",
-        Builtins::kCallSitePrototypeGetEnclosingLineNumber},
-      {"getEvalOrigin", Builtins::kCallSitePrototypeGetEvalOrigin},
-      {"getFileName", Builtins::kCallSitePrototypeGetFileName},
-      {"getFunction", Builtins::kCallSitePrototypeGetFunction},
-      {"getFunctionName", Builtins::kCallSitePrototypeGetFunctionName},
-      {"getLineNumber", Builtins::kCallSitePrototypeGetLineNumber},
-      {"getMethodName", Builtins::kCallSitePrototypeGetMethodName},
-      {"getPosition", Builtins::kCallSitePrototypeGetPosition},
-      {"getPromiseIndex", Builtins::kCallSitePrototypeGetPromiseIndex},
+       Builtin::kCallSitePrototypeGetEnclosingLineNumber},
+      {"getEvalOrigin", Builtin::kCallSitePrototypeGetEvalOrigin},
+      {"getFileName", Builtin::kCallSitePrototypeGetFileName},
+      {"getFunction", Builtin::kCallSitePrototypeGetFunction},
+      {"getFunctionName", Builtin::kCallSitePrototypeGetFunctionName},
+      {"getLineNumber", Builtin::kCallSitePrototypeGetLineNumber},
+      {"getMethodName", Builtin::kCallSitePrototypeGetMethodName},
+      {"getPosition", Builtin::kCallSitePrototypeGetPosition},
+      {"getPromiseIndex", Builtin::kCallSitePrototypeGetPromiseIndex},
       {"getScriptNameOrSourceURL",
-       Builtins::kCallSitePrototypeGetScriptNameOrSourceURL},
-      {"getThis", Builtins::kCallSitePrototypeGetThis},
-      {"getTypeName", Builtins::kCallSitePrototypeGetTypeName},
-      {"isAsync", Builtins::kCallSitePrototypeIsAsync},
-      {"isConstructor", Builtins::kCallSitePrototypeIsConstructor},
-      {"isEval", Builtins::kCallSitePrototypeIsEval},
-      {"isNative", Builtins::kCallSitePrototypeIsNative},
-      {"isPromiseAll", Builtins::kCallSitePrototypeIsPromiseAll},
-      {"isToplevel", Builtins::kCallSitePrototypeIsToplevel},
-      {"toString", Builtins::kCallSitePrototypeToString}};
+       Builtin::kCallSitePrototypeGetScriptNameOrSourceURL},
+      {"getThis", Builtin::kCallSitePrototypeGetThis},
+      {"getTypeName", Builtin::kCallSitePrototypeGetTypeName},
+      {"isAsync", Builtin::kCallSitePrototypeIsAsync},
+      {"isConstructor", Builtin::kCallSitePrototypeIsConstructor},
+      {"isEval", Builtin::kCallSitePrototypeIsEval},
+      {"isNative", Builtin::kCallSitePrototypeIsNative},
+      {"isPromiseAll", Builtin::kCallSitePrototypeIsPromiseAll},
+      {"isToplevel", Builtin::kCallSitePrototypeIsToplevel},
+      {"toString", Builtin::kCallSitePrototypeToString}};
 
   PropertyAttributes attrs =
       static_cast<PropertyAttributes>(DONT_ENUM | DONT_DELETE | READ_ONLY);
@@ -4444,7 +4429,7 @@ void Genesis::InitializeGlobal_harmony_object_has_own() {
 
   Handle<JSFunction> object_function = isolate_->object_function();
   SimpleInstallFunction(isolate_, object_function, "hasOwn",
-                        Builtins::kObjectHasOwn, 2, true);
+                        Builtin::kObjectHasOwn, 2, true);
 }
 
 void Genesis::InitializeGlobal_harmony_sharedarraybuffer() {
@@ -4508,7 +4493,7 @@ void Genesis::InitializeGlobal_harmony_regexp_match_indices() {
 
   Handle<JSObject> prototype(native_context()->regexp_prototype(), isolate());
   SimpleInstallGetter(isolate(), prototype, factory()->has_indices_string(),
-                      Builtins::kRegExpPrototypeHasIndicesGetter, true);
+                      Builtin::kRegExpPrototypeHasIndicesGetter, true);
 
   // Store regexp prototype map again after change.
   native_context()->set_regexp_prototype_map(prototype->map());
@@ -4522,7 +4507,7 @@ void Genesis::InitializeGlobal_regexp_linear_flag() {
       JSObject::cast(regexp_fun->instance_prototype()), isolate());
   SimpleInstallGetter(isolate(), regexp_prototype,
                       isolate()->factory()->linear_string(),
-                      Builtins::kRegExpPrototypeLinearGetter, true);
+                      Builtin::kRegExpPrototypeLinearGetter, true);
 
   // Store regexp prototype map again after change.
   native_context()->set_regexp_prototype_map(regexp_prototype->map());
@@ -4538,7 +4523,7 @@ void Genesis::InitializeGlobal_harmony_relative_indexing_methods() {
         JSObject::cast(array_function->instance_prototype()), isolate());
 
     SimpleInstallFunction(isolate(), array_prototype, "at",
-                          Builtins::kArrayPrototypeAt, 1, true);
+                          Builtin::kArrayPrototypeAt, 1, true);
 
     Handle<JSObject> unscopables = Handle<JSObject>::cast(
         JSReceiver::GetProperty(isolate(), array_prototype,
@@ -4554,7 +4539,7 @@ void Genesis::InitializeGlobal_harmony_relative_indexing_methods() {
         JSObject::cast(string_function->instance_prototype()), isolate());
 
     SimpleInstallFunction(isolate(), string_prototype, "at",
-                          Builtins::kStringPrototypeAt, 1, true);
+                          Builtin::kStringPrototypeAt, 1, true);
   }
 
   {
@@ -4564,7 +4549,7 @@ void Genesis::InitializeGlobal_harmony_relative_indexing_methods() {
         JSObject::cast(typed_array_function->instance_prototype()), isolate());
 
     SimpleInstallFunction(isolate(), typed_array_prototype, "at",
-                          Builtins::kTypedArrayPrototypeAt, 1, true);
+                          Builtin::kTypedArrayPrototypeAt, 1, true);
   }
 }
 
@@ -4576,20 +4561,20 @@ void Genesis::InitializeGlobal_harmony_intl_locale_info() {
       JSObject::cast(native_context()->intl_locale_function().prototype()),
       isolate_);
   SimpleInstallGetter(isolate(), prototype, factory()->calendars_string(),
-                      Builtins::kLocalePrototypeCalendars, true);
+                      Builtin::kLocalePrototypeCalendars, true);
   SimpleInstallGetter(isolate(), prototype, factory()->collations_string(),
-                      Builtins::kLocalePrototypeCollations, true);
+                      Builtin::kLocalePrototypeCollations, true);
   SimpleInstallGetter(isolate(), prototype, factory()->hourCycles_string(),
-                      Builtins::kLocalePrototypeHourCycles, true);
+                      Builtin::kLocalePrototypeHourCycles, true);
   SimpleInstallGetter(isolate(), prototype,
                       factory()->numberingSystems_string(),
-                      Builtins::kLocalePrototypeNumberingSystems, true);
+                      Builtin::kLocalePrototypeNumberingSystems, true);
   SimpleInstallGetter(isolate(), prototype, factory()->textInfo_string(),
-                      Builtins::kLocalePrototypeTextInfo, true);
+                      Builtin::kLocalePrototypeTextInfo, true);
   SimpleInstallGetter(isolate(), prototype, factory()->timeZones_string(),
-                      Builtins::kLocalePrototypeTimeZones, true);
+                      Builtin::kLocalePrototypeTimeZones, true);
   SimpleInstallGetter(isolate(), prototype, factory()->weekInfo_string(),
-                      Builtins::kLocalePrototypeWeekInfo, true);
+                      Builtin::kLocalePrototypeWeekInfo, true);
 }
 
 #endif  // V8_INTL_SUPPORT
@@ -4619,7 +4604,7 @@ Handle<JSFunction> Genesis::CreateArrayBuffer(
   Handle<JSFunction> array_buffer_fun =
       CreateFunction(isolate(), name, JS_ARRAY_BUFFER_TYPE,
                      JSArrayBuffer::kSizeWithEmbedderFields, 0, prototype,
-                     Builtins::kArrayBufferConstructor);
+                     Builtin::kArrayBufferConstructor);
   array_buffer_fun->shared().DontAdaptArguments();
   array_buffer_fun->shared().set_length(1);
 
@@ -4630,47 +4615,46 @@ Handle<JSFunction> Genesis::CreateArrayBuffer(
   switch (array_buffer_kind) {
     case ARRAY_BUFFER:
       InstallFunctionWithBuiltinId(isolate(), array_buffer_fun, "isView",
-                                   Builtins::kArrayBufferIsView, 1, true);
+                                   Builtin::kArrayBufferIsView, 1, true);
 
       // Install the "byteLength" getter on the {prototype}.
       SimpleInstallGetter(isolate(), prototype, factory()->byte_length_string(),
-                          Builtins::kArrayBufferPrototypeGetByteLength, false);
+                          Builtin::kArrayBufferPrototypeGetByteLength, false);
 
       SimpleInstallFunction(isolate(), prototype, "slice",
-                            Builtins::kArrayBufferPrototypeSlice, 2, true);
+                            Builtin::kArrayBufferPrototypeSlice, 2, true);
       break;
 
     case SHARED_ARRAY_BUFFER:
       // Install the "byteLength" getter on the {prototype}.
       SimpleInstallGetter(isolate(), prototype, factory()->byte_length_string(),
-                          Builtins::kSharedArrayBufferPrototypeGetByteLength,
+                          Builtin::kSharedArrayBufferPrototypeGetByteLength,
                           false);
 
       SimpleInstallFunction(isolate(), prototype, "slice",
-                            Builtins::kSharedArrayBufferPrototypeSlice, 2,
-                            true);
+                            Builtin::kSharedArrayBufferPrototypeSlice, 2, true);
       break;
     case RESIZABLE_ARRAY_BUFFER:
       SimpleInstallGetter(isolate(), prototype, factory()->byte_length_string(),
-                          Builtins::kResizableArrayBufferPrototypeGetByteLength,
+                          Builtin::kResizableArrayBufferPrototypeGetByteLength,
                           false);
       SimpleInstallGetter(
           isolate(), prototype, factory()->max_byte_length_string(),
-          Builtins::kResizableArrayBufferPrototypeGetMaxByteLength, false);
+          Builtin::kResizableArrayBufferPrototypeGetMaxByteLength, false);
       SimpleInstallFunction(isolate(), prototype, "resize",
-                            Builtins::kResizableArrayBufferPrototypeResize, 1,
+                            Builtin::kResizableArrayBufferPrototypeResize, 1,
                             true);
       break;
     case GROWABLE_SHARED_ARRAY_BUFFER:
       SimpleInstallGetter(
           isolate(), prototype, factory()->byte_length_string(),
-          Builtins::kGrowableSharedArrayBufferPrototypeGetByteLength, true);
+          Builtin::kGrowableSharedArrayBufferPrototypeGetByteLength, true);
       SimpleInstallGetter(
           isolate(), prototype, factory()->max_byte_length_string(),
-          Builtins::kGrowableSharedArrayBufferPrototypeGetMaxByteLength, false);
+          Builtin::kGrowableSharedArrayBufferPrototypeGetMaxByteLength, false);
       SimpleInstallFunction(isolate(), prototype, "grow",
-                            Builtins::kGrowableSharedArrayBufferPrototypeGrow,
-                            1, true);
+                            Builtin::kGrowableSharedArrayBufferPrototypeGrow, 1,
+                            true);
       break;
   }
 
@@ -4724,42 +4708,42 @@ bool Genesis::InstallABunchOfRandomThings() {
 
   // Install Global.decodeURI.
   InstallFunctionWithBuiltinId(isolate(), global_object, "decodeURI",
-                               Builtins::kGlobalDecodeURI, 1, false);
+                               Builtin::kGlobalDecodeURI, 1, false);
 
   // Install Global.decodeURIComponent.
   InstallFunctionWithBuiltinId(isolate(), global_object, "decodeURIComponent",
-                               Builtins::kGlobalDecodeURIComponent, 1, false);
+                               Builtin::kGlobalDecodeURIComponent, 1, false);
 
   // Install Global.encodeURI.
   InstallFunctionWithBuiltinId(isolate(), global_object, "encodeURI",
-                               Builtins::kGlobalEncodeURI, 1, false);
+                               Builtin::kGlobalEncodeURI, 1, false);
 
   // Install Global.encodeURIComponent.
   InstallFunctionWithBuiltinId(isolate(), global_object, "encodeURIComponent",
-                               Builtins::kGlobalEncodeURIComponent, 1, false);
+                               Builtin::kGlobalEncodeURIComponent, 1, false);
 
   // Install Global.escape.
   InstallFunctionWithBuiltinId(isolate(), global_object, "escape",
-                               Builtins::kGlobalEscape, 1, false);
+                               Builtin::kGlobalEscape, 1, false);
 
   // Install Global.unescape.
   InstallFunctionWithBuiltinId(isolate(), global_object, "unescape",
-                               Builtins::kGlobalUnescape, 1, false);
+                               Builtin::kGlobalUnescape, 1, false);
 
   // Install Global.eval.
   {
     Handle<JSFunction> eval = SimpleInstallFunction(
-        isolate(), global_object, "eval", Builtins::kGlobalEval, 1, false);
+        isolate(), global_object, "eval", Builtin::kGlobalEval, 1, false);
     native_context()->set_global_eval_fun(*eval);
   }
 
   // Install Global.isFinite
   InstallFunctionWithBuiltinId(isolate(), global_object, "isFinite",
-                               Builtins::kGlobalIsFinite, 1, true);
+                               Builtin::kGlobalIsFinite, 1, true);
 
   // Install Global.isNaN
   InstallFunctionWithBuiltinId(isolate(), global_object, "isNaN",
-                               Builtins::kGlobalIsNaN, 1, true);
+                               Builtin::kGlobalIsNaN, 1, true);
 
   // Install Array builtin functions.
   {
@@ -5010,10 +4994,10 @@ bool Genesis::InstallExtrasBindings() {
 
   // binding.isTraceCategoryEnabled(category)
   SimpleInstallFunction(isolate(), extras_binding, "isTraceCategoryEnabled",
-                        Builtins::kIsTraceCategoryEnabled, 1, true);
+                        Builtin::kIsTraceCategoryEnabled, 1, true);
 
   // binding.trace(phase, category, name, id, data)
-  SimpleInstallFunction(isolate(), extras_binding, "trace", Builtins::kTrace, 5,
+  SimpleInstallFunction(isolate(), extras_binding, "trace", Builtin::kTrace, 5,
                         true);
 
   native_context()->set_extras_binding_object(*extras_binding);
diff --git a/src/interpreter/interpreter-assembler.cc b/src/interpreter/interpreter-assembler.cc
index 5facbf2dabb..843acfd08c5 100644
--- a/src/interpreter/interpreter-assembler.cc
+++ b/src/interpreter/interpreter-assembler.cc
@@ -1551,9 +1551,9 @@ void InterpreterAssembler::ToNumberOrNumeric(Object::Conversion mode) {
 
   BIND(&if_objectisother);
   {
-    auto builtin = Builtins::kNonNumberToNumber;
+    auto builtin = Builtin::kNonNumberToNumber;
     if (mode == Object::Conversion::kToNumeric) {
-      builtin = Builtins::kNonNumberToNumeric;
+      builtin = Builtin::kNonNumberToNumeric;
       // Special case for collecting BigInt feedback.
       Label not_bigint(this);
       GotoIfNot(IsBigInt(CAST(object)), &not_bigint);
diff --git a/src/interpreter/interpreter-generator.cc b/src/interpreter/interpreter-generator.cc
index 6032d1e9ba5..037485e2dd3 100644
--- a/src/interpreter/interpreter-generator.cc
+++ b/src/interpreter/interpreter-generator.cc
@@ -236,7 +236,7 @@ IGNITION_HANDLER(StaGlobal, InterpreterAssembler) {
   TNode<TaggedIndex> slot = BytecodeOperandIdxTaggedIndex(1);
   TNode<HeapObject> maybe_vector = LoadFeedbackVector();
 
-  CallBuiltin(Builtins::kStoreGlobalIC, context, name, value, slot,
+  CallBuiltin(Builtin::kStoreGlobalIC, context, name, value, slot,
               maybe_vector);
 
   Dispatch();
@@ -559,7 +559,7 @@ IGNITION_HANDLER(LdaNamedPropertyFromSuper, InterpreterAssembler) {
   TNode<Context> context = GetContext();
 
   TNode<Object> result =
-      CallBuiltin(Builtins::kLoadSuperIC, context, receiver,
+      CallBuiltin(Builtin::kLoadSuperIC, context, receiver,
                   home_object_prototype, name, slot, feedback_vector);
   SetAccumulator(result);
   Dispatch();
@@ -577,7 +577,7 @@ IGNITION_HANDLER(LdaKeyedProperty, InterpreterAssembler) {
   TNode<Context> context = GetContext();
 
   TVARIABLE(Object, var_result);
-  var_result = CallBuiltin(Builtins::kKeyedLoadIC, context, object, name, slot,
+  var_result = CallBuiltin(Builtin::kKeyedLoadIC, context, object, name, slot,
                            feedback_vector);
   SetAccumulator(var_result.value());
   Dispatch();
@@ -616,7 +616,7 @@ class InterpreterStoreNamedPropertyAssembler : public InterpreterAssembler {
 // the name in constant pool entry <name_index> with the value in the
 // accumulator.
 IGNITION_HANDLER(StaNamedProperty, InterpreterStoreNamedPropertyAssembler) {
-  Callable ic = Builtins::CallableFor(isolate(), Builtins::kStoreIC);
+  Callable ic = Builtins::CallableFor(isolate(), Builtin::kStoreIC);
   StaNamedProperty(ic, NamedPropertyType::kNotOwn);
 }
 
@@ -643,8 +643,8 @@ IGNITION_HANDLER(StaKeyedProperty, InterpreterAssembler) {
   TNode<Context> context = GetContext();
 
   TVARIABLE(Object, var_result);
-  var_result = CallBuiltin(Builtins::kKeyedStoreIC, context, object, name,
-                           value, slot, maybe_vector);
+  var_result = CallBuiltin(Builtin::kKeyedStoreIC, context, object, name, value,
+                           slot, maybe_vector);
   // To avoid special logic in the deoptimizer to re-materialize the value in
   // the accumulator, we overwrite the accumulator after the IC call. It
   // doesn't really matter what we write to the accumulator here, since we
@@ -667,7 +667,7 @@ IGNITION_HANDLER(StaInArrayLiteral, InterpreterAssembler) {
   TNode<Context> context = GetContext();
 
   TVARIABLE(Object, var_result);
-  var_result = CallBuiltin(Builtins::kStoreInArrayLiteralIC, context, array,
+  var_result = CallBuiltin(Builtin::kStoreInArrayLiteralIC, context, array,
                            index, value, slot, feedback_vector);
   // To avoid special logic in the deoptimizer to re-materialize the value in
   // the accumulator, we overwrite the accumulator after the IC call. It
@@ -1148,7 +1148,7 @@ IGNITION_HANDLER(Negate, InterpreterAssembler) {
 IGNITION_HANDLER(ToName, InterpreterAssembler) {
   TNode<Object> object = GetAccumulator();
   TNode<Context> context = GetContext();
-  TNode<Object> result = CallBuiltin(Builtins::kToName, context, object);
+  TNode<Object> result = CallBuiltin(Builtin::kToName, context, object);
   StoreRegisterAtOperandIndex(result, 0);
   Dispatch();
 }
@@ -1173,7 +1173,7 @@ IGNITION_HANDLER(ToNumeric, InterpreterAssembler) {
 IGNITION_HANDLER(ToObject, InterpreterAssembler) {
   TNode<Object> accumulator = GetAccumulator();
   TNode<Context> context = GetContext();
-  TNode<Object> result = CallBuiltin(Builtins::kToObject, context, accumulator);
+  TNode<Object> result = CallBuiltin(Builtin::kToObject, context, accumulator);
   StoreRegisterAtOperandIndex(result, 0);
   Dispatch();
 }
@@ -1293,7 +1293,7 @@ IGNITION_HANDLER(DeletePropertyStrict, InterpreterAssembler) {
   TNode<Object> key = GetAccumulator();
   TNode<Context> context = GetContext();
   TNode<Object> result =
-      CallBuiltin(Builtins::kDeleteProperty, context, object, key,
+      CallBuiltin(Builtin::kDeleteProperty, context, object, key,
                   SmiConstant(Smi::FromEnum(LanguageMode::kStrict)));
   SetAccumulator(result);
   Dispatch();
@@ -1308,7 +1308,7 @@ IGNITION_HANDLER(DeletePropertySloppy, InterpreterAssembler) {
   TNode<Object> key = GetAccumulator();
   TNode<Context> context = GetContext();
   TNode<Object> result =
-      CallBuiltin(Builtins::kDeleteProperty, context, object, key,
+      CallBuiltin(Builtin::kDeleteProperty, context, object, key,
                   SmiConstant(Smi::FromEnum(LanguageMode::kSloppy)));
   SetAccumulator(result);
   Dispatch();
@@ -1678,7 +1678,7 @@ IGNITION_HANDLER(TestIn, InterpreterAssembler) {
   TNode<Context> context = GetContext();
 
   TVARIABLE(Object, var_result);
-  var_result = CallBuiltin(Builtins::kKeyedHasIC, context, object, name, slot,
+  var_result = CallBuiltin(Builtin::kKeyedHasIC, context, object, name, slot,
                            feedback_vector);
   SetAccumulator(var_result.value());
   Dispatch();
@@ -2309,7 +2309,7 @@ IGNITION_HANDLER(CreateArrayFromIterable, InterpreterAssembler) {
   TNode<Object> iterable = GetAccumulator();
   TNode<Context> context = GetContext();
   TNode<Object> result =
-      CallBuiltin(Builtins::kIterableToListWithSymbolLookup, context, iterable);
+      CallBuiltin(Builtin::kIterableToListWithSymbolLookup, context, iterable);
   SetAccumulator(result);
   Dispatch();
 }
@@ -2389,7 +2389,7 @@ IGNITION_HANDLER(CloneObject, InterpreterAssembler) {
   TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
   TNode<Context> context = GetContext();
 
-  TNode<Object> result = CallBuiltin(Builtins::kCloneObjectIC, context, source,
+  TNode<Object> result = CallBuiltin(Builtin::kCloneObjectIC, context, source,
                                      smi_flags, slot, maybe_feedback_vector);
   SetAccumulator(result);
   Dispatch();
@@ -2409,7 +2409,7 @@ IGNITION_HANDLER(GetTemplateObject, InterpreterAssembler) {
   TNode<UintPtrT> slot = BytecodeOperandIdx(1);
   TNode<HeapObject> maybe_feedback_vector = LoadFeedbackVector();
   TNode<Object> result =
-      CallBuiltin(Builtins::kGetTemplateObject, context, shared_info,
+      CallBuiltin(Builtin::kGetTemplateObject, context, shared_info,
                   description, slot, maybe_feedback_vector);
   SetAccumulator(result);
   Dispatch();
@@ -2439,7 +2439,7 @@ IGNITION_HANDLER(CreateClosure, InterpreterAssembler) {
   BIND(&if_fast);
   {
     TNode<Object> result =
-        CallBuiltin(Builtins::kFastNewClosure, context, shared, feedback_cell);
+        CallBuiltin(Builtin::kFastNewClosure, context, shared, feedback_cell);
     SetAccumulator(result);
     Dispatch();
   }
@@ -2773,8 +2773,7 @@ IGNITION_HANDLER(IncBlockCounter, InterpreterAssembler) {
   TNode<Smi> coverage_array_slot = BytecodeOperandIdxSmi(0);
   TNode<Context> context = GetContext();
 
-  CallBuiltin(Builtins::kIncBlockCounter, context, closure,
-              coverage_array_slot);
+  CallBuiltin(Builtin::kIncBlockCounter, context, closure, coverage_array_slot);
 
   Dispatch();
 }
@@ -2919,7 +2918,7 @@ IGNITION_HANDLER(GetIterator, InterpreterAssembler) {
   TNode<TaggedIndex> call_slot = BytecodeOperandIdxTaggedIndex(2);
 
   TNode<Object> iterator =
-      CallBuiltin(Builtins::kGetIteratorWithFeedback, context, receiver,
+      CallBuiltin(Builtin::kGetIteratorWithFeedback, context, receiver,
                   load_slot, call_slot, feedback_vector);
   SetAccumulator(iterator);
   Dispatch();
diff --git a/src/interpreter/interpreter-intrinsics-generator.cc b/src/interpreter/interpreter-intrinsics-generator.cc
index c98f78f8788..96f456d2ebe 100644
--- a/src/interpreter/interpreter-intrinsics-generator.cc
+++ b/src/interpreter/interpreter-intrinsics-generator.cc
@@ -44,7 +44,7 @@ class IntrinsicsGenerator {
                                    InstanceTypeCompareMode mode);
   TNode<Object> IntrinsicAsBuiltinCall(
       const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
-      Builtins::Name name, int arg_count);
+      Builtin name, int arg_count);
   void AbortIfArgCountMismatch(int expected, TNode<Word32T> actual);
 
 #define DECLARE_INTRINSIC_HELPER(name, lower_case, count)               \
@@ -143,7 +143,7 @@ TNode<Oddball> IntrinsicsGenerator::IsInstanceType(TNode<Object> input,
 
 TNode<Object> IntrinsicsGenerator::IntrinsicAsBuiltinCall(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
-    Builtins::Name name, int arg_count) {
+    Builtin name, int arg_count) {
   Callable callable = Builtins::CallableFor(isolate_, name);
   switch (arg_count) {
     case 1:
@@ -195,34 +195,34 @@ TNode<Object> IntrinsicsGenerator::IsSmi(
 TNode<Object> IntrinsicsGenerator::CopyDataProperties(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kCopyDataProperties,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kCopyDataProperties,
                                 arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::CreateIterResultObject(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context,
-                                Builtins::kCreateIterResultObject, arg_count);
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kCreateIterResultObject,
+                                arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::HasProperty(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kHasProperty,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kHasProperty,
                                 arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::ToLength(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kToLength, arg_count);
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kToLength, arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::ToObject(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kToObject, arg_count);
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kToObject, arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::Call(
@@ -262,7 +262,7 @@ TNode<Object> IntrinsicsGenerator::CreateAsyncFromSyncIterator(
 TNode<Object> IntrinsicsGenerator::CreateJSGeneratorObject(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kCreateGeneratorObject,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kCreateGeneratorObject,
                                 arg_count);
 }
 
@@ -298,69 +298,69 @@ TNode<Object> IntrinsicsGenerator::AsyncFunctionAwaitCaught(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
   return IntrinsicAsBuiltinCall(args, context,
-                                Builtins::kAsyncFunctionAwaitCaught, arg_count);
+                                Builtin::kAsyncFunctionAwaitCaught, arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncFunctionAwaitUncaught(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
   return IntrinsicAsBuiltinCall(
-      args, context, Builtins::kAsyncFunctionAwaitUncaught, arg_count);
+      args, context, Builtin::kAsyncFunctionAwaitUncaught, arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncFunctionEnter(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kAsyncFunctionEnter,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kAsyncFunctionEnter,
                                 arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncFunctionReject(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kAsyncFunctionReject,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kAsyncFunctionReject,
                                 arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncFunctionResolve(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kAsyncFunctionResolve,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kAsyncFunctionResolve,
                                 arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncGeneratorAwaitCaught(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(
-      args, context, Builtins::kAsyncGeneratorAwaitCaught, arg_count);
+  return IntrinsicAsBuiltinCall(args, context,
+                                Builtin::kAsyncGeneratorAwaitCaught, arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncGeneratorAwaitUncaught(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
   return IntrinsicAsBuiltinCall(
-      args, context, Builtins::kAsyncGeneratorAwaitUncaught, arg_count);
+      args, context, Builtin::kAsyncGeneratorAwaitUncaught, arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncGeneratorReject(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kAsyncGeneratorReject,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kAsyncGeneratorReject,
                                 arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncGeneratorResolve(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kAsyncGeneratorResolve,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kAsyncGeneratorResolve,
                                 arg_count);
 }
 
 TNode<Object> IntrinsicsGenerator::AsyncGeneratorYield(
     const InterpreterAssembler::RegListNodePair& args, TNode<Context> context,
     int arg_count) {
-  return IntrinsicAsBuiltinCall(args, context, Builtins::kAsyncGeneratorYield,
+  return IntrinsicAsBuiltinCall(args, context, Builtin::kAsyncGeneratorYield,
                                 arg_count);
 }
 
diff --git a/src/interpreter/interpreter.cc b/src/interpreter/interpreter.cc
index 9727cfcc8c0..8e600ecea6f 100644
--- a/src/interpreter/interpreter.cc
+++ b/src/interpreter/interpreter.cc
@@ -97,7 +97,7 @@ int BuiltinIndexFromBytecode(Bytecode bytecode, OperandScale operand_scale) {
     // kIllegalBytecodeHandlerEncoding for illegal bytecode/scale combinations.
     uint8_t offset = kWideBytecodeToBuiltinsMapping[index];
     if (offset == kIllegalBytecodeHandlerEncoding) {
-      return Builtins::kIllegalHandler;
+      return Builtin::kIllegalHandler;
     } else {
       index = kNumberOfBytecodeHandlers + offset;
       if (operand_scale == OperandScale::kQuadruple) {
@@ -105,7 +105,7 @@ int BuiltinIndexFromBytecode(Bytecode bytecode, OperandScale operand_scale) {
       }
     }
   }
-  return Builtins::kFirstBytecodeHandler + index;
+  return Builtin::kFirstBytecodeHandler + index;
 }
 
 }  // namespace
diff --git a/src/logging/log.cc b/src/logging/log.cc
index 1e76a66a66b..c7c386ac8d7 100644
--- a/src/logging/log.cc
+++ b/src/logging/log.cc
@@ -1359,7 +1359,7 @@ void Logger::CodeCreateEvent(LogEventsAndTags tag, Handle<AbstractCode> code,
   if (!is_listening_to_code_events()) return;
   if (!FLAG_log_code) return;
   if (*code == AbstractCode::cast(
-                   isolate_->builtins()->builtin(Builtins::kCompileLazy))) {
+                   isolate_->builtins()->builtin(Builtin::kCompileLazy))) {
     return;
   }
   {
diff --git a/src/objects/code-inl.h b/src/objects/code-inl.h
index f53c585538d..28b7b430c84 100644
--- a/src/objects/code-inl.h
+++ b/src/objects/code-inl.h
@@ -448,28 +448,28 @@ inline bool Code::is_interpreter_trampoline_builtin() const {
   // Check for kNoBuiltinId first to abort early when the current Code object
   // is not a builtin.
   const int index = builtin_index();
-  return index != Builtins::kNoBuiltinId &&
-         (index == Builtins::kInterpreterEntryTrampoline ||
-          index == Builtins::kInterpreterEnterAtBytecode ||
-          index == Builtins::kInterpreterEnterAtNextBytecode);
+  return index != Builtin::kNoBuiltinId &&
+         (index == Builtin::kInterpreterEntryTrampoline ||
+          index == Builtin::kInterpreterEnterAtBytecode ||
+          index == Builtin::kInterpreterEnterAtNextBytecode);
 }
 
 inline bool Code::is_baseline_trampoline_builtin() const {
   const int index = builtin_index();
-  return index != Builtins::kNoBuiltinId &&
-         (index == Builtins::kBaselineOutOfLinePrologue ||
-          index == Builtins::kBaselineEnterAtBytecode ||
-          index == Builtins::kBaselineEnterAtNextBytecode);
+  return index != Builtin::kNoBuiltinId &&
+         (index == Builtin::kBaselineOutOfLinePrologue ||
+          index == Builtin::kBaselineEnterAtBytecode ||
+          index == Builtin::kBaselineEnterAtNextBytecode);
 }
 
 inline bool Code::is_baseline_leave_frame_builtin() const {
-  return builtin_index() == Builtins::kBaselineLeaveFrame;
+  return builtin_index() == Builtin::kBaselineLeaveFrame;
 }
 
 inline bool Code::checks_optimization_marker() const {
   bool checks_marker =
-      (builtin_index() == Builtins::kCompileLazy ||
-       builtin_index() == Builtins::kInterpreterEntryTrampoline ||
+      (builtin_index() == Builtin::kCompileLazy ||
+       builtin_index() == Builtin::kInterpreterEntryTrampoline ||
        CodeKindCanTierUp(kind()));
   return checks_marker ||
          (CodeKindCanDeoptimize(kind()) && marked_for_deoptimization());
@@ -540,17 +540,17 @@ inline HandlerTable::CatchPrediction Code::GetBuiltinCatchPrediction() {
 
 int Code::builtin_index() const {
   int index = RELAXED_READ_INT_FIELD(*this, kBuiltinIndexOffset);
-  DCHECK(index == Builtins::kNoBuiltinId || Builtins::IsBuiltinId(index));
+  DCHECK(index == Builtin::kNoBuiltinId || Builtins::IsBuiltinId(index));
   return index;
 }
 
 void Code::set_builtin_index(int index) {
-  DCHECK(index == Builtins::kNoBuiltinId || Builtins::IsBuiltinId(index));
+  DCHECK(index == Builtin::kNoBuiltinId || Builtins::IsBuiltinId(index));
   RELAXED_WRITE_INT_FIELD(*this, kBuiltinIndexOffset, index);
 }
 
 bool Code::is_builtin() const {
-  return builtin_index() != Builtins::kNoBuiltinId;
+  return builtin_index() != Builtin::kNoBuiltinId;
 }
 
 unsigned Code::inlined_bytecode_size() const {
diff --git a/src/objects/code.h b/src/objects/code.h
index b7508ec3106..f070c6273af 100644
--- a/src/objects/code.h
+++ b/src/objects/code.h
@@ -298,7 +298,7 @@ class Code : public HeapObject {
 
   // [builtin_index]: For builtins, tells which builtin index the code object
   // has. The builtin index is a non-negative integer for builtins, and
-  // Builtins::kNoBuiltinId (-1) otherwise.
+  // Builtin::kNoBuiltinId (-1) otherwise.
   inline int builtin_index() const;
   inline void set_builtin_index(int id);
   inline bool is_builtin() const;
diff --git a/src/objects/contexts.h b/src/objects/contexts.h
index 996b9f2481f..dbde4b91010 100644
--- a/src/objects/contexts.h
+++ b/src/objects/contexts.h
@@ -526,7 +526,7 @@ class Context : public TorqueGeneratedContext<Context, HeapObject> {
   static const int kExtendedHeaderSize = kTodoHeaderSize + kExtensionSize;
 
   // A region of native context entries containing maps for functions created
-  // by Builtins::kFastNewClosure.
+  // by Builtin::kFastNewClosure.
   static const int FIRST_FUNCTION_MAP_INDEX = SLOPPY_FUNCTION_MAP_INDEX;
   static const int LAST_FUNCTION_MAP_INDEX = CLASS_FUNCTION_MAP_INDEX;
 
diff --git a/src/objects/feedback-vector.cc b/src/objects/feedback-vector.cc
index 006e7a176f4..88035ea0dbf 100644
--- a/src/objects/feedback-vector.cc
+++ b/src/objects/feedback-vector.cc
@@ -331,7 +331,7 @@ Handle<FeedbackVector> NewFeedbackVectorForTesting(
   Handle<FeedbackMetadata> metadata = FeedbackMetadata::New(isolate, spec);
   Handle<SharedFunctionInfo> shared =
       isolate->factory()->NewSharedFunctionInfoForBuiltin(
-          isolate->factory()->empty_string(), Builtins::kIllegal);
+          isolate->factory()->empty_string(), Builtin::kIllegal);
   // Set the raw feedback metadata to circumvent checks that we are not
   // overwriting existing metadata.
   shared->set_raw_outer_scope_info_or_feedback_metadata(*metadata);
@@ -1174,18 +1174,18 @@ namespace {
 bool BuiltinHasKeyedAccessStoreMode(int builtin_index) {
   DCHECK(Builtins::IsBuiltinId(builtin_index));
   switch (builtin_index) {
-    case Builtins::kKeyedStoreIC_SloppyArguments_Standard:
-    case Builtins::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW:
-    case Builtins::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB:
-    case Builtins::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
-    case Builtins::kStoreFastElementIC_Standard:
-    case Builtins::kStoreFastElementIC_GrowNoTransitionHandleCOW:
-    case Builtins::kStoreFastElementIC_NoTransitionIgnoreOOB:
-    case Builtins::kStoreFastElementIC_NoTransitionHandleCOW:
-    case Builtins::kElementsTransitionAndStore_Standard:
-    case Builtins::kElementsTransitionAndStore_GrowNoTransitionHandleCOW:
-    case Builtins::kElementsTransitionAndStore_NoTransitionIgnoreOOB:
-    case Builtins::kElementsTransitionAndStore_NoTransitionHandleCOW:
+    case Builtin::kKeyedStoreIC_SloppyArguments_Standard:
+    case Builtin::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW:
+    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB:
+    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
+    case Builtin::kStoreFastElementIC_Standard:
+    case Builtin::kStoreFastElementIC_GrowNoTransitionHandleCOW:
+    case Builtin::kStoreFastElementIC_NoTransitionIgnoreOOB:
+    case Builtin::kStoreFastElementIC_NoTransitionHandleCOW:
+    case Builtin::kElementsTransitionAndStore_Standard:
+    case Builtin::kElementsTransitionAndStore_GrowNoTransitionHandleCOW:
+    case Builtin::kElementsTransitionAndStore_NoTransitionIgnoreOOB:
+    case Builtin::kElementsTransitionAndStore_NoTransitionHandleCOW:
       return true;
     default:
       return false;
@@ -1196,21 +1196,21 @@ bool BuiltinHasKeyedAccessStoreMode(int builtin_index) {
 KeyedAccessStoreMode KeyedAccessStoreModeForBuiltin(int builtin_index) {
   DCHECK(BuiltinHasKeyedAccessStoreMode(builtin_index));
   switch (builtin_index) {
-    case Builtins::kKeyedStoreIC_SloppyArguments_Standard:
-    case Builtins::kStoreFastElementIC_Standard:
-    case Builtins::kElementsTransitionAndStore_Standard:
+    case Builtin::kKeyedStoreIC_SloppyArguments_Standard:
+    case Builtin::kStoreFastElementIC_Standard:
+    case Builtin::kElementsTransitionAndStore_Standard:
       return STANDARD_STORE;
-    case Builtins::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW:
-    case Builtins::kStoreFastElementIC_GrowNoTransitionHandleCOW:
-    case Builtins::kElementsTransitionAndStore_GrowNoTransitionHandleCOW:
+    case Builtin::kKeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW:
+    case Builtin::kStoreFastElementIC_GrowNoTransitionHandleCOW:
+    case Builtin::kElementsTransitionAndStore_GrowNoTransitionHandleCOW:
       return STORE_AND_GROW_HANDLE_COW;
-    case Builtins::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB:
-    case Builtins::kStoreFastElementIC_NoTransitionIgnoreOOB:
-    case Builtins::kElementsTransitionAndStore_NoTransitionIgnoreOOB:
+    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB:
+    case Builtin::kStoreFastElementIC_NoTransitionIgnoreOOB:
+    case Builtin::kElementsTransitionAndStore_NoTransitionIgnoreOOB:
       return STORE_IGNORE_OUT_OF_BOUNDS;
-    case Builtins::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
-    case Builtins::kStoreFastElementIC_NoTransitionHandleCOW:
-    case Builtins::kElementsTransitionAndStore_NoTransitionHandleCOW:
+    case Builtin::kKeyedStoreIC_SloppyArguments_NoTransitionHandleCOW:
+    case Builtin::kStoreFastElementIC_NoTransitionHandleCOW:
+    case Builtin::kElementsTransitionAndStore_NoTransitionHandleCOW:
       return STORE_HANDLE_COW;
     default:
       UNREACHABLE();
diff --git a/src/objects/js-function-inl.h b/src/objects/js-function-inl.h
index b0a53f58759..63cee9c6ed9 100644
--- a/src/objects/js-function-inl.h
+++ b/src/objects/js-function-inl.h
@@ -270,7 +270,7 @@ DEF_GETTER(JSFunction, prototype, Object) {
 }
 
 bool JSFunction::is_compiled() const {
-  return code(kAcquireLoad).builtin_index() != Builtins::kCompileLazy &&
+  return code(kAcquireLoad).builtin_index() != Builtin::kCompileLazy &&
          shared().is_compiled();
 }
 
@@ -287,8 +287,7 @@ bool JSFunction::NeedsResetDueToFlushedBytecode() {
 
   SharedFunctionInfo shared = SharedFunctionInfo::cast(maybe_shared);
   Code code = Code::cast(maybe_code);
-  return !shared.is_compiled() &&
-         code.builtin_index() != Builtins::kCompileLazy;
+  return !shared.is_compiled() && code.builtin_index() != Builtin::kCompileLazy;
 }
 
 void JSFunction::ResetIfBytecodeFlushed(
@@ -298,7 +297,7 @@ void JSFunction::ResetIfBytecodeFlushed(
   if (FLAG_flush_bytecode && NeedsResetDueToFlushedBytecode()) {
     // Bytecode was flushed and function is now uncompiled, reset JSFunction
     // by setting code to CompileLazy and clearing the feedback vector.
-    set_code(GetIsolate()->builtins()->builtin(i::Builtins::kCompileLazy));
+    set_code(GetIsolate()->builtins()->builtin(i::Builtin::kCompileLazy));
     raw_feedback_cell().reset_feedback_vector(gc_notify_updated_slot);
   }
 }
diff --git a/src/objects/js-function.cc b/src/objects/js-function.cc
index ec7746dd3c6..5ffba6d5590 100644
--- a/src/objects/js-function.cc
+++ b/src/objects/js-function.cc
@@ -119,7 +119,7 @@ bool JSFunction::ActiveTierIsIgnition() const {
   DCHECK_IMPLIES(result, code.is_interpreter_trampoline_builtin() ||
                              (CodeKindIsOptimizedJSFunction(code.kind()) &&
                               code.marked_for_deoptimization()) ||
-                             (code.builtin_index() == Builtins::kCompileLazy &&
+                             (code.builtin_index() == Builtin::kCompileLazy &&
                               shared().IsInterpreted()));
 #endif  // DEBUG
   return result;
diff --git a/src/objects/shared-function-info-inl.h b/src/objects/shared-function-info-inl.h
index 6d34f946f40..15fd30e2798 100644
--- a/src/objects/shared-function-info-inl.h
+++ b/src/objects/shared-function-info-inl.h
@@ -314,7 +314,7 @@ void SharedFunctionInfo::CalculateConstructAsBuiltin() {
   bool uses_builtins_construct_stub = false;
   if (HasBuiltinId()) {
     int id = builtin_id();
-    if (id != Builtins::kCompileLazy && id != Builtins::kEmptyFunction) {
+    if (id != Builtin::kCompileLazy && id != Builtin::kEmptyFunction) {
       uses_builtins_construct_stub = true;
     }
   } else if (IsApiFunction()) {
@@ -444,7 +444,7 @@ void SharedFunctionInfo::set_feedback_metadata(FeedbackMetadata value,
 
 bool SharedFunctionInfo::is_compiled() const {
   Object data = function_data(kAcquireLoad);
-  return data != Smi::FromEnum(Builtins::kCompileLazy) &&
+  return data != Smi::FromEnum(Builtin::kCompileLazy) &&
          !data.IsUncompiledData();
 }
 
@@ -549,7 +549,7 @@ void SharedFunctionInfo::SetActiveBytecodeArray(BytecodeArray bytecode) {
 }
 
 void SharedFunctionInfo::set_bytecode_array(BytecodeArray bytecode) {
-  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtins::kCompileLazy) ||
+  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtin::kCompileLazy) ||
          HasUncompiledData());
   set_function_data(bytecode, kReleaseStore);
 }
@@ -641,7 +641,7 @@ AsmWasmData SharedFunctionInfo::asm_wasm_data() const {
 }
 
 void SharedFunctionInfo::set_asm_wasm_data(AsmWasmData data) {
-  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtins::kCompileLazy) ||
+  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtin::kCompileLazy) ||
          HasUncompiledData() || HasAsmWasmData());
   set_function_data(data, kReleaseStore);
 }
@@ -690,7 +690,7 @@ UncompiledData SharedFunctionInfo::uncompiled_data() const {
 }
 
 void SharedFunctionInfo::set_uncompiled_data(UncompiledData uncompiled_data) {
-  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtins::kCompileLazy) ||
+  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtin::kCompileLazy) ||
          HasUncompiledData());
   DCHECK(uncompiled_data.IsUncompiledData());
   set_function_data(uncompiled_data, kReleaseStore);
@@ -708,7 +708,7 @@ SharedFunctionInfo::uncompiled_data_with_preparse_data() const {
 
 void SharedFunctionInfo::set_uncompiled_data_with_preparse_data(
     UncompiledDataWithPreparseData uncompiled_data_with_preparse_data) {
-  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtins::kCompileLazy));
+  DCHECK(function_data(kAcquireLoad) == Smi::FromEnum(Builtin::kCompileLazy));
   DCHECK(uncompiled_data_with_preparse_data.IsUncompiledDataWithPreparseData());
   set_function_data(uncompiled_data_with_preparse_data, kReleaseStore);
 }
diff --git a/src/objects/shared-function-info.cc b/src/objects/shared-function-info.cc
index 054a314f454..6a3747232a2 100644
--- a/src/objects/shared-function-info.cc
+++ b/src/objects/shared-function-info.cc
@@ -32,7 +32,7 @@ void SharedFunctionInfo::Init(ReadOnlyRoots ro_roots, int unique_id) {
   // Set the function data to the "illegal" builtin. Ideally we'd use some sort
   // of "uninitialized" marker here, but it's cheaper to use a valid buitin and
   // avoid having to do uninitialized checks elsewhere.
-  set_builtin_id(Builtins::kIllegal);
+  set_builtin_id(Builtin::kIllegal);
 
   // Set the name to the no-name sentinel, this can be updated later.
   set_name_or_scope_info(SharedFunctionInfo::kNoSharedNameSentinel,
@@ -82,7 +82,7 @@ Code SharedFunctionInfo::GetCode() const {
   if (data.IsBytecodeArray()) {
     // Having a bytecode array means we are a compiled, interpreted function.
     DCHECK(HasBytecodeArray());
-    return isolate->builtins()->builtin(Builtins::kInterpreterEntryTrampoline);
+    return isolate->builtins()->builtin(Builtin::kInterpreterEntryTrampoline);
   }
   if (data.IsBaselineData()) {
     // Having BaselineData means we are a compiled, baseline function.
@@ -93,7 +93,7 @@ Code SharedFunctionInfo::GetCode() const {
   if (data.IsAsmWasmData()) {
     // Having AsmWasmData means we are an asm.js/wasm function.
     DCHECK(HasAsmWasmData());
-    return isolate->builtins()->builtin(Builtins::kInstantiateAsmJs);
+    return isolate->builtins()->builtin(Builtin::kInstantiateAsmJs);
   }
   if (data.IsWasmExportedFunctionData()) {
     // Having a WasmExportedFunctionData means the code is in there.
@@ -110,12 +110,12 @@ Code SharedFunctionInfo::GetCode() const {
   if (data.IsUncompiledData()) {
     // Having uncompiled data (with or without scope) means we need to compile.
     DCHECK(HasUncompiledData());
-    return isolate->builtins()->builtin(Builtins::kCompileLazy);
+    return isolate->builtins()->builtin(Builtin::kCompileLazy);
   }
   if (data.IsFunctionTemplateInfo()) {
     // Having a function template info means we are an API function.
     DCHECK(IsApiFunction());
-    return isolate->builtins()->builtin(Builtins::kHandleApiCall);
+    return isolate->builtins()->builtin(Builtin::kHandleApiCall);
   }
   if (data.IsInterpreterData()) {
     Code code = InterpreterTrampoline();
@@ -605,7 +605,7 @@ int SharedFunctionInfo::StartPosition() const {
     return uncompiled_data().start_position();
   }
   if (IsApiFunction() || HasBuiltinId()) {
-    DCHECK_IMPLIES(HasBuiltinId(), builtin_id() != Builtins::kCompileLazy);
+    DCHECK_IMPLIES(HasBuiltinId(), builtin_id() != Builtin::kCompileLazy);
     return 0;
   }
 #if V8_ENABLE_WEBASSEMBLY
@@ -632,7 +632,7 @@ int SharedFunctionInfo::EndPosition() const {
     return uncompiled_data().end_position();
   }
   if (IsApiFunction() || HasBuiltinId()) {
-    DCHECK_IMPLIES(HasBuiltinId(), builtin_id() != Builtins::kCompileLazy);
+    DCHECK_IMPLIES(HasBuiltinId(), builtin_id() != Builtin::kCompileLazy);
     return 0;
   }
 #if V8_ENABLE_WEBASSEMBLY
diff --git a/src/objects/shared-function-info.h b/src/objects/shared-function-info.h
index a936cf8daa1..fc44f52061a 100644
--- a/src/objects/shared-function-info.h
+++ b/src/objects/shared-function-info.h
@@ -332,7 +332,7 @@ class SharedFunctionInfo
   inline const wasm::FunctionSig* wasm_function_signature() const;
 #endif  // V8_ENABLE_WEBASSEMBLY
 
-  // builtin_id corresponds to the auto-generated Builtins::Name id.
+  // builtin_id corresponds to the auto-generated Builtin id.
   inline bool HasBuiltinId() const;
   inline int builtin_id() const;
   inline void set_builtin_id(int builtin_id);
diff --git a/src/profiler/cpu-profiler-inl.h b/src/profiler/cpu-profiler-inl.h
index 220f879fd66..ebfc6be7f39 100644
--- a/src/profiler/cpu-profiler-inl.h
+++ b/src/profiler/cpu-profiler-inl.h
@@ -50,7 +50,7 @@ void ReportBuiltinEventRecord::UpdateCodeMap(CodeMap* code_map) {
     return;
   }
 #if V8_ENABLE_WEBASSEMBLY
-  if (builtin_id == Builtins::kGenericJSToWasmWrapper) {
+  if (builtin_id == Builtin::kGenericJSToWasmWrapper) {
     // Make sure to add the generic js-to-wasm wrapper builtin, because that
     // one is supposed to show up in profiles.
     entry = new CodeEntry(CodeEventListener::BUILTIN_TAG,
diff --git a/src/profiler/cpu-profiler.cc b/src/profiler/cpu-profiler.cc
index ba9022be1b0..7fee62b99e0 100644
--- a/src/profiler/cpu-profiler.cc
+++ b/src/profiler/cpu-profiler.cc
@@ -395,10 +395,10 @@ void ProfilerCodeObserver::CreateEntriesForRuntimeCallStats() {
 void ProfilerCodeObserver::LogBuiltins() {
   Builtins* builtins = isolate_->builtins();
   DCHECK(builtins->is_initialized());
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     CodeEventsContainer evt_rec(CodeEventRecord::REPORT_BUILTIN);
     ReportBuiltinEventRecord* rec = &evt_rec.ReportBuiltinEventRecord_;
-    Builtins::Name id = static_cast<Builtins::Name>(i);
+    Builtin id = static_cast<Builtin>(i);
     Code code = builtins->builtin(id);
     rec->instruction_start = code.InstructionStart();
     rec->instruction_size = code.InstructionSize();
diff --git a/src/profiler/cpu-profiler.h b/src/profiler/cpu-profiler.h
index ced37e4ade5..c8e4540337b 100644
--- a/src/profiler/cpu-profiler.h
+++ b/src/profiler/cpu-profiler.h
@@ -98,7 +98,7 @@ class ReportBuiltinEventRecord : public CodeEventRecord {
  public:
   Address instruction_start;
   unsigned instruction_size;
-  Builtins::Name builtin_id;
+  Builtin builtin_id;
 
   V8_INLINE void UpdateCodeMap(CodeMap* code_map);
 };
diff --git a/src/profiler/profile-generator-inl.h b/src/profiler/profile-generator-inl.h
index 83c1108ddb0..1a513f694d2 100644
--- a/src/profiler/profile-generator-inl.h
+++ b/src/profiler/profile-generator-inl.h
@@ -18,7 +18,7 @@ CodeEntry::CodeEntry(CodeEventListener::LogEventsAndTags tag, const char* name,
                      std::unique_ptr<SourcePositionTable> line_info,
                      bool is_shared_cross_origin, CodeType code_type)
     : bit_field_(TagField::encode(tag) |
-                 BuiltinIdField::encode(Builtins::builtin_count) |
+                 BuiltinIdField::encode(Builtin::kIllegal) |
                  CodeTypeField::encode(code_type) |
                  SharedCrossOriginField::encode(is_shared_cross_origin)),
       name_(name),
diff --git a/src/profiler/profile-generator.cc b/src/profiler/profile-generator.cc
index 93075d4f7c2..5a5730615c8 100644
--- a/src/profiler/profile-generator.cc
+++ b/src/profiler/profile-generator.cc
@@ -157,13 +157,11 @@ bool CodeEntry::IsSameFunctionAs(const CodeEntry* entry) const {
          line_number_ == entry->line_number_;
 }
 
-
-void CodeEntry::SetBuiltinId(Builtins::Name id) {
+void CodeEntry::SetBuiltinId(Builtin id) {
   bit_field_ = TagField::update(bit_field_, CodeEventListener::BUILTIN_TAG);
   bit_field_ = BuiltinIdField::update(bit_field_, id);
 }
 
-
 int CodeEntry::GetSourceLine(int pc_offset) const {
   if (line_info_) return line_info_->GetSourceLineNumber(pc_offset);
   return v8::CpuProfileNode::kNoLineNumberInfo;
diff --git a/src/profiler/profile-generator.h b/src/profiler/profile-generator.h
index c4bffa945a0..fc355d16857 100644
--- a/src/profiler/profile-generator.h
+++ b/src/profiler/profile-generator.h
@@ -130,10 +130,8 @@ class CodeEntry {
 
   void FillFunctionInfo(SharedFunctionInfo shared);
 
-  void SetBuiltinId(Builtins::Name id);
-  Builtins::Name builtin_id() const {
-    return BuiltinIdField::decode(bit_field_);
-  }
+  void SetBuiltinId(Builtin id);
+  Builtin builtin_id() const { return BuiltinIdField::decode(bit_field_); }
 
   bool is_shared_cross_origin() const {
     return SharedCrossOriginField::decode(bit_field_);
@@ -208,8 +206,8 @@ class CodeEntry {
   RareData* EnsureRareData();
 
   using TagField = base::BitField<CodeEventListener::LogEventsAndTags, 0, 8>;
-  using BuiltinIdField = base::BitField<Builtins::Name, 8, 20>;
-  static_assert(Builtins::builtin_count <= BuiltinIdField::kNumValues,
+  using BuiltinIdField = base::BitField<Builtin, 8, 20>;
+  static_assert(Builtins::kBuiltinCount <= BuiltinIdField::kNumValues,
                 "builtin_count exceeds size of bitfield");
   using CodeTypeField = base::BitField<CodeType, 28, 2>;
   using UsedField = base::BitField<bool, 30, 1>;
diff --git a/src/profiler/symbolizer.cc b/src/profiler/symbolizer.cc
index ca6eb269faa..295c103aa8c 100644
--- a/src/profiler/symbolizer.cc
+++ b/src/profiler/symbolizer.cc
@@ -96,8 +96,8 @@ Symbolizer::SymbolizedSample Symbolizer::SymbolizeTickSample(
         src_line_not_found = false;
         stack_trace.push_back({pc_entry, src_line});
 
-        if (pc_entry->builtin_id() == Builtins::kFunctionPrototypeApply ||
-            pc_entry->builtin_id() == Builtins::kFunctionPrototypeCall) {
+        if (pc_entry->builtin_id() == Builtin::kFunctionPrototypeApply ||
+            pc_entry->builtin_id() == Builtin::kFunctionPrototypeCall) {
           // When current function is either the Function.prototype.apply or the
           // Function.prototype.call builtin the top frame is either frame of
           // the calling JS function or internal frame.
diff --git a/src/regexp/arm/regexp-macro-assembler-arm.cc b/src/regexp/arm/regexp-macro-assembler-arm.cc
index 48e8fae663b..4b7153b35ff 100644
--- a/src/regexp/arm/regexp-macro-assembler-arm.cc
+++ b/src/regexp/arm/regexp-macro-assembler-arm.cc
@@ -1084,7 +1084,7 @@ void RegExpMacroAssemblerARM::CallCheckStackGuardState() {
   __ mov(ip, Operand(stack_guard_check));
 
   EmbeddedData d = EmbeddedData::FromBlob();
-  Address entry = d.InstructionStartOfBuiltin(Builtins::kDirectCEntry);
+  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
   __ mov(lr, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(lr);
 
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.cc b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
index 5e24500a261..72821e61c51 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.cc
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
@@ -1407,7 +1407,7 @@ void RegExpMacroAssemblerARM64::CallCheckStackGuardState(Register scratch) {
       ExternalReference::re_check_stack_guard_state(isolate());
   __ Mov(scratch, check_stack_guard_state);
 
-  __ CallBuiltin(Builtins::kDirectCEntry);
+  __ CallBuiltin(Builtin::kDirectCEntry);
 
   // The input string may have been moved in memory, we need to reload it.
   __ Peek(input_start(), kSystemPointerSize);
diff --git a/src/regexp/mips/regexp-macro-assembler-mips.cc b/src/regexp/mips/regexp-macro-assembler-mips.cc
index e1b1119c172..043f71d161f 100644
--- a/src/regexp/mips/regexp-macro-assembler-mips.cc
+++ b/src/regexp/mips/regexp-macro-assembler-mips.cc
@@ -1137,8 +1137,8 @@ void RegExpMacroAssemblerMIPS::CallCheckStackGuardState(Register scratch) {
   __ li(t9, Operand(stack_guard_check));
 
   EmbeddedData d = EmbeddedData::FromBlob();
-  CHECK(Builtins::IsIsolateIndependent(Builtins::kDirectCEntry));
-  Address entry = d.InstructionStartOfBuiltin(Builtins::kDirectCEntry);
+  CHECK(Builtins::IsIsolateIndependent(Builtin::kDirectCEntry));
+  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
   __ li(kScratchReg, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(kScratchReg);
 
diff --git a/src/regexp/mips64/regexp-macro-assembler-mips64.cc b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
index 48252a206e2..dad43291571 100644
--- a/src/regexp/mips64/regexp-macro-assembler-mips64.cc
+++ b/src/regexp/mips64/regexp-macro-assembler-mips64.cc
@@ -1173,8 +1173,8 @@ void RegExpMacroAssemblerMIPS::CallCheckStackGuardState(Register scratch) {
   __ li(t9, Operand(stack_guard_check));
 
   EmbeddedData d = EmbeddedData::FromBlob();
-  CHECK(Builtins::IsIsolateIndependent(Builtins::kDirectCEntry));
-  Address entry = d.InstructionStartOfBuiltin(Builtins::kDirectCEntry);
+  CHECK(Builtins::IsIsolateIndependent(Builtin::kDirectCEntry));
+  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
   __ li(kScratchReg, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(kScratchReg);
 
diff --git a/src/regexp/ppc/regexp-macro-assembler-ppc.cc b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
index b9382aea2e0..ce088233c3f 100644
--- a/src/regexp/ppc/regexp-macro-assembler-ppc.cc
+++ b/src/regexp/ppc/regexp-macro-assembler-ppc.cc
@@ -1157,7 +1157,7 @@ void RegExpMacroAssemblerPPC::CallCheckStackGuardState(Register scratch) {
   __ mov(ip, Operand(stack_guard_check));
 
   EmbeddedData d = EmbeddedData::FromBlob();
-  Address entry = d.InstructionStartOfBuiltin(Builtins::kDirectCEntry);
+  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
   __ mov(r0, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(r0);
 
diff --git a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
index 422a8904e8a..449a9c35038 100644
--- a/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
+++ b/src/regexp/riscv64/regexp-macro-assembler-riscv64.cc
@@ -1104,8 +1104,8 @@ void RegExpMacroAssemblerRISCV::CallCheckStackGuardState(Register scratch) {
   __ li(t6, Operand(stack_guard_check));
 
   EmbeddedData d = EmbeddedData::FromBlob();
-  CHECK(Builtins::IsIsolateIndependent(Builtins::kDirectCEntry));
-  Address entry = d.InstructionStartOfBuiltin(Builtins::kDirectCEntry);
+  CHECK(Builtins::IsIsolateIndependent(Builtin::kDirectCEntry));
+  Address entry = d.InstructionStartOfBuiltin(Builtin::kDirectCEntry);
   __ li(kScratchReg, Operand(entry, RelocInfo::OFF_HEAP_TARGET));
   __ Call(kScratchReg);
 
diff --git a/src/runtime/runtime-compiler.cc b/src/runtime/runtime-compiler.cc
index 1586e35e254..874ad9e9ec8 100644
--- a/src/runtime/runtime-compiler.cc
+++ b/src/runtime/runtime-compiler.cc
@@ -172,8 +172,8 @@ RUNTIME_FUNCTION(Runtime_InstantiateAsmJs) {
   shared->set_is_asm_wasm_broken(true);
 #endif
   DCHECK(function->code() ==
-         isolate->builtins()->builtin(Builtins::kInstantiateAsmJs));
-  function->set_code(isolate->builtins()->builtin(Builtins::kCompileLazy));
+         isolate->builtins()->builtin(Builtin::kInstantiateAsmJs));
+  function->set_code(isolate->builtins()->builtin(Builtin::kCompileLazy));
   DCHECK(!isolate->has_pending_exception());
   return Smi::zero();
 }
diff --git a/src/runtime/runtime-test-wasm.cc b/src/runtime/runtime-test-wasm.cc
index 54976dcc05b..82a9d4cd854 100644
--- a/src/runtime/runtime-test-wasm.cc
+++ b/src/runtime/runtime-test-wasm.cc
@@ -237,7 +237,7 @@ RUNTIME_FUNCTION(Runtime_IsAsmWasmCode) {
     return ReadOnlyRoots(isolate).false_value();
   }
   if (function.shared().HasBuiltinId() &&
-      function.shared().builtin_id() == Builtins::kInstantiateAsmJs) {
+      function.shared().builtin_id() == Builtin::kInstantiateAsmJs) {
     // Hasn't been compiled yet.
     return ReadOnlyRoots(isolate).false_value();
   }
@@ -270,7 +270,7 @@ RUNTIME_FUNCTION(Runtime_IsWasmCode) {
   bool is_js_to_wasm =
       function.code().kind() == CodeKind::JS_TO_WASM_FUNCTION ||
       (function.code().is_builtin() &&
-       function.code().builtin_index() == Builtins::kGenericJSToWasmWrapper);
+       function.code().builtin_index() == Builtin::kGenericJSToWasmWrapper);
   return isolate->heap()->ToBoolean(is_js_to_wasm);
 }
 
diff --git a/src/snapshot/embedded/embedded-data.cc b/src/snapshot/embedded/embedded-data.cc
index fb3883a410d..890fb34c6ef 100644
--- a/src/snapshot/embedded/embedded-data.cc
+++ b/src/snapshot/embedded/embedded-data.cc
@@ -16,16 +16,16 @@ namespace internal {
 
 namespace {
 
-Builtins::Name TryLookupCode(const EmbeddedData& d, Address address) {
-  if (!d.IsInCodeRange(address)) return Builtins::kNoBuiltinId;
+Builtin TryLookupCode(const EmbeddedData& d, Address address) {
+  if (!d.IsInCodeRange(address)) return Builtin::kNoBuiltinId;
 
-  if (address < d.InstructionStartOfBuiltin(0)) return Builtins::kNoBuiltinId;
+  if (address < d.InstructionStartOfBuiltin(0)) return Builtin::kNoBuiltinId;
 
   // Note: Addresses within the padding section between builtins (i.e. within
   // start + size <= address < start + padded_size) are interpreted as belonging
   // to the preceding builtin.
 
-  int l = 0, r = Builtins::builtin_count;
+  int l = 0, r = Builtins::kBuiltinCount;
   while (l < r) {
     const int mid = (l + r) / 2;
     Address start = d.InstructionStartOfBuiltin(mid);
@@ -36,7 +36,7 @@ Builtins::Name TryLookupCode(const EmbeddedData& d, Address address) {
     } else if (address >= end) {
       l = mid + 1;
     } else {
-      return static_cast<Builtins::Name>(mid);
+      return static_cast<Builtin>(mid);
     }
   }
 
@@ -81,14 +81,12 @@ bool InstructionStream::TryGetAddressForHashing(Isolate* isolate,
 }
 
 // static
-Builtins::Name InstructionStream::TryLookupCode(Isolate* isolate,
-                                                Address address) {
+Builtin InstructionStream::TryLookupCode(Isolate* isolate, Address address) {
   // Mksnapshot calls this while the embedded blob is not available yet.
-  if (isolate->embedded_blob_code() == nullptr) return Builtins::kNoBuiltinId;
+  if (isolate->embedded_blob_code() == nullptr) return Builtin::kNoBuiltinId;
   DCHECK_NOT_NULL(Isolate::CurrentEmbeddedBlobCode());
 
-  Builtins::Name builtin =
-      i::TryLookupCode(EmbeddedData::FromBlob(isolate), address);
+  Builtin builtin = i::TryLookupCode(EmbeddedData::FromBlob(isolate), address);
 
   if (isolate->is_short_builtin_calls_enabled() &&
       !Builtins::IsBuiltinId(builtin)) {
@@ -194,7 +192,7 @@ bool BuiltinAliasesOffHeapTrampolineRegister(Isolate* isolate, Code code) {
   }
 
   Callable callable = Builtins::CallableFor(
-      isolate, static_cast<Builtins::Name>(code.builtin_index()));
+      isolate, static_cast<Builtin>(code.builtin_index()));
   CallInterfaceDescriptor descriptor = callable.descriptor();
 
   for (int i = 0; i < descriptor.GetRegisterParameterCount(); i++) {
@@ -211,7 +209,7 @@ void FinalizeEmbeddedCodeTargets(Isolate* isolate, EmbeddedData* blob) {
       RelocInfo::ModeMask(RelocInfo::RELATIVE_CODE_TARGET);
 
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Code code = isolate->builtins()->builtin(i);
     RelocIterator on_heap_it(code, kRelocMask);
     RelocIterator off_heap_it(blob, code, kRelocMask);
@@ -264,7 +262,7 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
   uint32_t raw_code_size = 0;
   uint32_t raw_data_size = 0;
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Code code = builtins->builtin(i);
 
     // Sanity-check that the given builtin is isolate-independent and does not
@@ -329,7 +327,7 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
   // .. and the variable-size data section.
   uint8_t* const raw_metadata_start = blob_data + RawMetadataOffset();
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Code code = builtins->builtin(i);
     uint32_t offset = layout_descriptions[i].metadata_offset;
     uint8_t* dst = raw_metadata_start + offset;
@@ -342,7 +340,7 @@ EmbeddedData EmbeddedData::FromIsolate(Isolate* isolate) {
   // .. and the variable-size code section.
   uint8_t* const raw_code_start = blob_code + RawCodeOffset();
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     Code code = builtins->builtin(i);
     uint32_t offset = layout_descriptions[i].instruction_offset;
     uint8_t* dst = raw_code_start + offset;
@@ -409,14 +407,14 @@ uint32_t EmbeddedData::MetadataSizeOfBuiltin(int i) const {
 }
 
 Address EmbeddedData::InstructionStartOfBytecodeHandlers() const {
-  return InstructionStartOfBuiltin(Builtins::kFirstBytecodeHandler);
+  return InstructionStartOfBuiltin(Builtin::kFirstBytecodeHandler);
 }
 
 Address EmbeddedData::InstructionEndOfBytecodeHandlers() const {
-  STATIC_ASSERT(Builtins::kFirstBytecodeHandler + kNumberOfBytecodeHandlers +
+  STATIC_ASSERT(Builtin::kFirstBytecodeHandler + kNumberOfBytecodeHandlers +
                     2 * kNumberOfWideBytecodeHandlers ==
-                Builtins::builtin_count);
-  int lastBytecodeHandler = Builtins::builtin_count - 1;
+                Builtins::kBuiltinCount);
+  int lastBytecodeHandler = Builtins::kBuiltinCount - 1;
   return InstructionStartOfBuiltin(lastBytecodeHandler) +
          InstructionSizeOfBuiltin(lastBytecodeHandler);
 }
@@ -443,7 +441,7 @@ size_t EmbeddedData::CreateEmbeddedBlobCodeHash() const {
 void EmbeddedData::PrintStatistics() const {
   DCHECK(FLAG_serialization_statistics);
 
-  constexpr int kCount = Builtins::builtin_count;
+  constexpr int kCount = Builtins::kBuiltinCount;
   int sizes[kCount];
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
   for (int i = 0; i < kCount; i++) {
diff --git a/src/snapshot/embedded/embedded-data.h b/src/snapshot/embedded/embedded-data.h
index 12f524d154b..3a7d3abd38c 100644
--- a/src/snapshot/embedded/embedded-data.h
+++ b/src/snapshot/embedded/embedded-data.h
@@ -32,7 +32,7 @@ class InstructionStream final : public AllStatic {
 
   // Returns the corresponding builtin ID if lookup succeeds, and kNoBuiltinId
   // otherwise.
-  static Builtins::Name TryLookupCode(Isolate* isolate, Address address);
+  static Builtin TryLookupCode(Isolate* isolate, Address address);
 
   // During snapshot creation, we first create an executable off-heap area
   // containing all off-heap code. The area is guaranteed to be contiguous.
@@ -183,7 +183,7 @@ class EmbeddedData final {
   // [0] instruction section of builtin 0
   // ... instruction sections
 
-  static constexpr uint32_t kTableSize = Builtins::builtin_count;
+  static constexpr uint32_t kTableSize = Builtins::kBuiltinCount;
   static constexpr uint32_t EmbeddedBlobDataHashOffset() { return 0; }
   static constexpr uint32_t EmbeddedBlobDataHashSize() { return kSizetSize; }
   static constexpr uint32_t EmbeddedBlobCodeHashOffset() {
diff --git a/src/snapshot/embedded/embedded-file-writer.cc b/src/snapshot/embedded/embedded-file-writer.cc
index 0df841261dd..7ab92c235c7 100644
--- a/src/snapshot/embedded/embedded-file-writer.cc
+++ b/src/snapshot/embedded/embedded-file-writer.cc
@@ -157,7 +157,7 @@ void EmbeddedFileWriter::WriteCodeSection(PlatformEmbeddedFileWriterBase* w,
   w->DeclareLabel(EmbeddedBlobCodeDataSymbol().c_str());
 
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < i::Builtins::builtin_count; i++) {
+  for (int i = 0; i < i::Builtins::kBuiltinCount; i++) {
     WriteBuiltin(w, blob, i);
   }
   w->Newline();
@@ -283,7 +283,7 @@ int EmbeddedFileWriter::GetExternallyCompiledFilenameCount() const {
 }
 
 void EmbeddedFileWriter::PrepareBuiltinSourcePositionMap(Builtins* builtins) {
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     // Retrieve the SourcePositionTable and copy it.
     Code code = builtins->builtin(i);
     // Verify that the code object is still the "real code" and not a
@@ -298,9 +298,9 @@ void EmbeddedFileWriter::PrepareBuiltinSourcePositionMap(Builtins* builtins) {
 
 void EmbeddedFileWriter::PrepareBuiltinLabelInfoMap(int create_offset,
                                                     int invoke_offset) {
-  label_info_[Builtins::kJSConstructStubGeneric].push_back(
+  label_info_[Builtin::kJSConstructStubGeneric].push_back(
       {create_offset, "construct_stub_create_deopt_addr"});
-  label_info_[Builtins::kJSConstructStubGeneric].push_back(
+  label_info_[Builtin::kJSConstructStubGeneric].push_back(
       {invoke_offset, "construct_stub_invoke_deopt_addr"});
 }
 
diff --git a/src/snapshot/embedded/embedded-file-writer.h b/src/snapshot/embedded/embedded-file-writer.h
index 0650f070a24..bf942807f1c 100644
--- a/src/snapshot/embedded/embedded-file-writer.h
+++ b/src/snapshot/embedded/embedded-file-writer.h
@@ -46,7 +46,7 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
   void SetBuiltinUnwindData(
       int builtin_index,
       const win64_unwindinfo::BuiltinUnwindInfo& unwinding_info) override {
-    DCHECK_LT(builtin_index, Builtins::builtin_count);
+    DCHECK_LT(builtin_index, Builtins::kBuiltinCount);
     unwind_infos_[builtin_index] = unwinding_info;
   }
 #endif  // V8_OS_WIN64
@@ -180,11 +180,11 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
   }
 
  private:
-  std::vector<byte> source_positions_[Builtins::builtin_count];
-  std::vector<LabelInfo> label_info_[Builtins::builtin_count];
+  std::vector<byte> source_positions_[Builtins::kBuiltinCount];
+  std::vector<LabelInfo> label_info_[Builtins::kBuiltinCount];
 
 #if defined(V8_OS_WIN64)
-  win64_unwindinfo::BuiltinUnwindInfo unwind_infos_[Builtins::builtin_count];
+  win64_unwindinfo::BuiltinUnwindInfo unwind_infos_[Builtins::kBuiltinCount];
 #endif  // V8_OS_WIN64
 
   std::map<const char*, int> external_filenames_;
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-win.cc b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
index 3dff5d34d1d..40d8dd036a9 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-win.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
@@ -111,7 +111,7 @@ void EmitUnwindData(PlatformEmbeddedFileWriterWin* w,
   {
     STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
     Address prev_builtin_end_offset = 0;
-    for (int i = 0; i < Builtins::builtin_count; i++) {
+    for (int i = 0; i < Builtins::kBuiltinCount; i++) {
       // Some builtins are leaf functions from the point of view of Win64 stack
       // walking: they do not move the stack pointer and do not require a PDATA
       // entry because the return address can be retrieved from [rsp].
@@ -194,7 +194,7 @@ void EmitUnwindData(PlatformEmbeddedFileWriterWin* w,
   std::vector<win64_unwindinfo::FrameOffsets> fp_adjustments;
 
   STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
-  for (int i = 0; i < Builtins::builtin_count; i++) {
+  for (int i = 0; i < Builtins::kBuiltinCount; i++) {
     if (unwind_infos[i].is_leaf_function()) continue;
 
     uint64_t builtin_start_offset = blob->InstructionStartOfBuiltin(i) -
diff --git a/src/snapshot/serializer.cc b/src/snapshot/serializer.cc
index f09ebeea77a..7ace802272c 100644
--- a/src/snapshot/serializer.cc
+++ b/src/snapshot/serializer.cc
@@ -998,12 +998,12 @@ void Serializer::ObjectSerializer::VisitRuntimeEntry(Code host,
 
 void Serializer::ObjectSerializer::VisitOffHeapTarget(Code host,
                                                       RelocInfo* rinfo) {
-  STATIC_ASSERT(EmbeddedData::kTableSize == Builtins::builtin_count);
+  STATIC_ASSERT(EmbeddedData::kTableSize == Builtins::kBuiltinCount);
 
   Address addr = rinfo->target_off_heap_target();
   CHECK_NE(kNullAddress, addr);
 
-  Builtins::Name builtin = InstructionStream::TryLookupCode(isolate(), addr);
+  Builtin builtin = InstructionStream::TryLookupCode(isolate(), addr);
   CHECK(Builtins::IsBuiltinId(builtin));
   CHECK(Builtins::IsIsolateIndependent(builtin));
 
diff --git a/src/snapshot/startup-serializer.cc b/src/snapshot/startup-serializer.cc
index ec68d448868..7e4c6986eff 100644
--- a/src/snapshot/startup-serializer.cc
+++ b/src/snapshot/startup-serializer.cc
@@ -98,13 +98,13 @@ bool IsUnexpectedCodeObject(Isolate* isolate, HeapObject obj) {
   // See Heap::interpreter_entry_trampoline_for_profiling.
 
   switch (code.builtin_index()) {
-    case Builtins::kAbort:
-    case Builtins::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
-    case Builtins::kInterpreterEntryTrampoline:
-    case Builtins::kRecordWriteEmitRememberedSetSaveFP:
-    case Builtins::kRecordWriteOmitRememberedSetSaveFP:
-    case Builtins::kRecordWriteEmitRememberedSetIgnoreFP:
-    case Builtins::kRecordWriteOmitRememberedSetIgnoreFP:
+    case Builtin::kAbort:
+    case Builtin::kCEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit:
+    case Builtin::kInterpreterEntryTrampoline:
+    case Builtin::kRecordWriteEmitRememberedSetSaveFP:
+    case Builtin::kRecordWriteOmitRememberedSetSaveFP:
+    case Builtin::kRecordWriteEmitRememberedSetIgnoreFP:
+    case Builtin::kRecordWriteOmitRememberedSetIgnoreFP:
       return false;
     default:
       return true;
diff --git a/src/torque/csa-generator.cc b/src/torque/csa-generator.cc
index 2f840c1918b..5443e812fdb 100644
--- a/src/torque/csa-generator.cc
+++ b/src/torque/csa-generator.cc
@@ -115,7 +115,7 @@ void CSAGenerator::EmitInstruction(
     const PushBuiltinPointerInstruction& instruction,
     Stack<std::string>* stack) {
   const std::string str =
-      "ca_.UncheckedCast<BuiltinPtr>(ca_.SmiConstant(Builtins::k" +
+      "ca_.UncheckedCast<BuiltinPtr>(ca_.SmiConstant(Builtin::k" +
       instruction.external_name + "))";
   stack->Push(str);
   SetDefinitionVariable(instruction.GetValueDefinition(), str);
@@ -524,7 +524,7 @@ void CSAGenerator::EmitInstruction(const CallBuiltinInstruction& instruction,
   std::vector<const Type*> result_types =
       LowerType(instruction.builtin->signature().return_type);
   if (instruction.is_tailcall) {
-    out() << "   CodeStubAssembler(state_).TailCallBuiltin(Builtins::k"
+    out() << "   CodeStubAssembler(state_).TailCallBuiltin(Builtin::k"
           << instruction.builtin->ExternalName();
     if (!instruction.builtin->signature().HasContextParameter()) {
       // Add dummy context parameter to satisfy the TailCallBuiltin signature.
@@ -574,7 +574,7 @@ void CSAGenerator::EmitInstruction(const CallBuiltinInstruction& instruction,
     }
     out() << "    " << lhs_name << " = ";
     out() << "ca_.CallStub<" << lhs_type
-          << ">(Builtins::CallableFor(ca_.isolate(), Builtins::k"
+          << ">(Builtins::CallableFor(ca_.isolate(), Builtin::k"
           << instruction.builtin->ExternalName() << ")";
     if (!instruction.builtin->signature().HasContextParameter()) {
       // Add dummy context parameter to satisfy the CallBuiltin signature.
diff --git a/src/utils/memcopy.cc b/src/utils/memcopy.cc
index 3332baa3e62..d06e19b13d2 100644
--- a/src/utils/memcopy.cc
+++ b/src/utils/memcopy.cc
@@ -38,19 +38,19 @@ void init_memcopy_functions() {
   if (Isolate::CurrentEmbeddedBlobIsBinaryEmbedded()) {
     EmbeddedData d = EmbeddedData::FromBlob();
     memmove_function = reinterpret_cast<MemMoveFunction>(
-        d.InstructionStartOfBuiltin(Builtins::kMemMove));
+        d.InstructionStartOfBuiltin(Builtin::kMemMove));
   }
 #elif V8_OS_POSIX && V8_HOST_ARCH_ARM
   if (Isolate::CurrentEmbeddedBlobIsBinaryEmbedded()) {
     EmbeddedData d = EmbeddedData::FromBlob();
     memcopy_uint8_function = reinterpret_cast<MemCopyUint8Function>(
-        d.InstructionStartOfBuiltin(Builtins::kMemCopyUint8Uint8));
+        d.InstructionStartOfBuiltin(Builtin::kMemCopyUint8Uint8));
   }
 #elif V8_OS_POSIX && V8_HOST_ARCH_MIPS
   if (Isolate::CurrentEmbeddedBlobIsBinaryEmbedded()) {
     EmbeddedData d = EmbeddedData::FromBlob();
     memcopy_uint8_function = reinterpret_cast<MemCopyUint8Function>(
-        d.InstructionStartOfBuiltin(Builtins::kMemCopyUint8Uint8));
+        d.InstructionStartOfBuiltin(Builtin::kMemCopyUint8Uint8));
   }
 #endif
 }
diff --git a/src/wasm/function-compiler.cc b/src/wasm/function-compiler.cc
index 4a2db3d496e..385f9584b35 100644
--- a/src/wasm/function-compiler.cc
+++ b/src/wasm/function-compiler.cc
@@ -331,7 +331,7 @@ Handle<Code> JSToWasmWrapperCompilationUnit::Finalize() {
   Handle<Code> code;
   if (use_generic_wrapper_) {
     code =
-        isolate_->builtins()->builtin_handle(Builtins::kGenericJSToWasmWrapper);
+        isolate_->builtins()->builtin_handle(Builtin::kGenericJSToWasmWrapper);
   } else {
     CompilationJob::Status status = job_->FinalizeJob(isolate_);
     CHECK_EQ(status, CompilationJob::SUCCEEDED);
diff --git a/src/wasm/wasm-code-manager.cc b/src/wasm/wasm-code-manager.cc
index 9a14d94aff8..4be11572e8b 100644
--- a/src/wasm/wasm-code-manager.cc
+++ b/src/wasm/wasm-code-manager.cc
@@ -1469,16 +1469,16 @@ void NativeModule::AddCodeSpaceLocked(base::AddressRegion region) {
         region);
     CHECK(region.contains(far_jump_table->instruction_start()));
     EmbeddedData embedded_data = EmbeddedData::FromBlob();
-#define RUNTIME_STUB(Name) Builtins::k##Name,
+#define RUNTIME_STUB(Name) Builtin::k##Name,
 #define RUNTIME_STUB_TRAP(Name) RUNTIME_STUB(ThrowWasm##Name)
-    Builtins::Name stub_names[WasmCode::kRuntimeStubCount] = {
+    Builtin stub_names[WasmCode::kRuntimeStubCount] = {
         WASM_RUNTIME_STUB_LIST(RUNTIME_STUB, RUNTIME_STUB_TRAP)};
 #undef RUNTIME_STUB
 #undef RUNTIME_STUB_TRAP
     STATIC_ASSERT(Builtins::kAllBuiltinsAreIsolateIndependent);
     Address builtin_addresses[WasmCode::kRuntimeStubCount];
     for (int i = 0; i < WasmCode::kRuntimeStubCount; ++i) {
-      Builtins::Name builtin = stub_names[i];
+      Builtin builtin = stub_names[i];
       builtin_addresses[i] = embedded_data.InstructionStartOfBuiltin(builtin);
     }
     JumpTableAssembler::GenerateFarJumpTable(
@@ -2346,10 +2346,10 @@ void WasmCodeRefScope::AddRef(WasmCode* code) {
   code->IncRef();
 }
 
-Builtins::Name RuntimeStubIdToBuiltinName(WasmCode::RuntimeStubId stub_id) {
-#define RUNTIME_STUB_NAME(Name) Builtins::k##Name,
-#define RUNTIME_STUB_NAME_TRAP(Name) Builtins::kThrowWasm##Name,
-  constexpr Builtins::Name builtin_names[] = {
+Builtin RuntimeStubIdToBuiltinName(WasmCode::RuntimeStubId stub_id) {
+#define RUNTIME_STUB_NAME(Name) Builtin::k##Name,
+#define RUNTIME_STUB_NAME_TRAP(Name) Builtin::kThrowWasm##Name,
+  constexpr Builtin builtin_names[] = {
       WASM_RUNTIME_STUB_LIST(RUNTIME_STUB_NAME, RUNTIME_STUB_NAME_TRAP)};
 #undef RUNTIME_STUB_NAME
 #undef RUNTIME_STUB_NAME_TRAP
diff --git a/src/wasm/wasm-code-manager.h b/src/wasm/wasm-code-manager.h
index 64090c0eb4f..9fb3295b4a4 100644
--- a/src/wasm/wasm-code-manager.h
+++ b/src/wasm/wasm-code-manager.h
@@ -1039,7 +1039,7 @@ class GlobalWasmCodeRef {
   const std::shared_ptr<NativeModule> native_module_;
 };
 
-Builtins::Name RuntimeStubIdToBuiltinName(WasmCode::RuntimeStubId);
+Builtin RuntimeStubIdToBuiltinName(WasmCode::RuntimeStubId);
 const char* GetRuntimeStubName(WasmCode::RuntimeStubId);
 
 }  // namespace wasm
diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
index 9c9ddc39c61..ad0290887b5 100644
--- a/src/wasm/wasm-js.cc
+++ b/src/wasm/wasm-js.cc
@@ -2096,7 +2096,7 @@ void WasmJs::Install(Isolate* isolate, bool exposed_on_global_object) {
   Handle<String> name = v8_str(isolate, "WebAssembly");
   // Not supposed to be called, hence using the kIllegal builtin as code.
   Handle<SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name, Builtins::kIllegal);
+      factory->NewSharedFunctionInfoForBuiltin(name, Builtin::kIllegal);
   info->set_language_mode(LanguageMode::kStrict);
 
   Handle<JSFunction> cons =
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index b0e9f468bee..c1fdc37f425 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1852,7 +1852,7 @@ bool WasmExportedFunction::IsWasmExportedFunction(Object object) {
   if (!object.IsJSFunction()) return false;
   JSFunction js_function = JSFunction::cast(object);
   if (CodeKind::JS_TO_WASM_FUNCTION != js_function.code().kind() &&
-      js_function.code().builtin_index() != Builtins::kGenericJSToWasmWrapper) {
+      js_function.code().builtin_index() != Builtin::kGenericJSToWasmWrapper) {
     return false;
   }
   DCHECK(js_function.shared().HasWasmExportedFunctionData());
@@ -1886,7 +1886,7 @@ Handle<WasmCapiFunction> WasmCapiFunction::New(
   Handle<WasmCapiFunctionData> fun_data =
       isolate->factory()->NewWasmCapiFunctionData(
           call_target, embedder_data,
-          isolate->builtins()->builtin_handle(Builtins::kIllegal),
+          isolate->builtins()->builtin_handle(Builtin::kIllegal),
           serialized_signature);
   Handle<SharedFunctionInfo> shared =
       isolate->factory()->NewSharedFunctionInfoForWasmCapiFunction(fun_data);
@@ -1906,10 +1906,9 @@ int WasmExportedFunction::function_index() {
 Handle<WasmExportedFunction> WasmExportedFunction::New(
     Isolate* isolate, Handle<WasmInstanceObject> instance, int func_index,
     int arity, Handle<Code> export_wrapper) {
-  DCHECK(
-      CodeKind::JS_TO_WASM_FUNCTION == export_wrapper->kind() ||
-      (export_wrapper->is_builtin() &&
-       export_wrapper->builtin_index() == Builtins::kGenericJSToWasmWrapper));
+  DCHECK(CodeKind::JS_TO_WASM_FUNCTION == export_wrapper->kind() ||
+         (export_wrapper->is_builtin() &&
+          export_wrapper->builtin_index() == Builtin::kGenericJSToWasmWrapper));
   int num_imported_functions = instance->module()->num_imported_functions;
   Handle<Object> ref =
       func_index >= num_imported_functions
diff --git a/src/web-snapshot/web-snapshot.cc b/src/web-snapshot/web-snapshot.cc
index 3732b0d10af..9c7c42697aa 100644
--- a/src/web-snapshot/web-snapshot.cc
+++ b/src/web-snapshot/web-snapshot.cc
@@ -811,7 +811,7 @@ void WebSnapshotDeserializer::DeserializeFunctions() {
     Handle<SharedFunctionInfo> shared =
         isolate_->factory()->NewSharedFunctionInfo(
             isolate_->factory()->empty_string(), MaybeHandle<Code>(),
-            Builtins::kCompileLazy, FunctionFlagsToFunctionKind(flags));
+            Builtin::kCompileLazy, FunctionFlagsToFunctionKind(flags));
     shared->set_script(*script);
     // Index 0 is reserved for top-level shared function info (which web
     // snapshot scripts don't have).
diff --git a/test/cctest/compiler/code-assembler-tester.h b/test/cctest/compiler/code-assembler-tester.h
index ec404dcfa50..6dc343fa08d 100644
--- a/test/cctest/compiler/code-assembler-tester.h
+++ b/test/cctest/compiler/code-assembler-tester.h
@@ -24,7 +24,7 @@ class CodeAssemblerTester {
       : zone_(isolate->allocator(), ZONE_NAME, kCompressGraphZone),
         scope_(isolate),
         state_(isolate, &zone_, descriptor, CodeKind::FOR_TESTING, name,
-               PoisoningMitigationLevel::kDontPoison, Builtins::kNoBuiltinId) {}
+               PoisoningMitigationLevel::kDontPoison, Builtin::kNoBuiltinId) {}
 
   // Test generating code for a stub. Assumes VoidDescriptor call interface.
   explicit CodeAssemblerTester(Isolate* isolate, const char* name = "test")
@@ -48,7 +48,7 @@ class CodeAssemblerTester {
       : zone_(isolate->allocator(), ZONE_NAME, kCompressGraphZone),
         scope_(isolate),
         state_(isolate, &zone_, call_descriptor, CodeKind::FOR_TESTING, name,
-               PoisoningMitigationLevel::kDontPoison, Builtins::kNoBuiltinId) {}
+               PoisoningMitigationLevel::kDontPoison, Builtin::kNoBuiltinId) {}
 
   CodeAssemblerState* state() { return &state_; }
 
diff --git a/test/cctest/compiler/test-code-generator.cc b/test/cctest/compiler/test-code-generator.cc
index d52515ec5d9..0b85a4e15b5 100644
--- a/test/cctest/compiler/test-code-generator.cc
+++ b/test/cctest/compiler/test-code-generator.cc
@@ -1010,7 +1010,7 @@ class CodeGeneratorTester {
         base::Optional<OsrHelper>(), kNoSourcePosition, nullptr,
         PoisoningMitigationLevel::kDontPoison,
         AssemblerOptions::Default(environment->main_isolate()),
-        Builtins::kNoBuiltinId, kMaxUnoptimizedFrameHeight,
+        Builtin::kNoBuiltinId, kMaxUnoptimizedFrameHeight,
         kMaxPushedArgumentCount);
 
     generator_->tasm()->CodeEntry();
diff --git a/test/cctest/compiler/test-linkage.cc b/test/cctest/compiler/test-linkage.cc
index bd6d0a5f0f0..d07ced6b4a9 100644
--- a/test/cctest/compiler/test-linkage.cc
+++ b/test/cctest/compiler/test-linkage.cc
@@ -107,7 +107,7 @@ TEST(TestLinkageStubCall) {
   // TODO(bbudge) Add tests for FP registers.
   Isolate* isolate = CcTest::InitIsolateOnce();
   Zone zone(isolate->allocator(), ZONE_NAME);
-  Callable callable = Builtins::CallableFor(isolate, Builtins::kToNumber);
+  Callable callable = Builtins::CallableFor(isolate, Builtin::kToNumber);
   OptimizedCompilationInfo info(ArrayVector("test"), &zone,
                                 CodeKind::FOR_TESTING);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
@@ -129,7 +129,7 @@ TEST(TestFPLinkageStubCall) {
   Isolate* isolate = CcTest::InitIsolateOnce();
   Zone zone(isolate->allocator(), ZONE_NAME);
   Callable callable =
-      Builtins::CallableFor(isolate, Builtins::kWasmFloat64ToNumber);
+      Builtins::CallableFor(isolate, Builtin::kWasmFloat64ToNumber);
   OptimizedCompilationInfo info(ArrayVector("test"), &zone,
                                 CodeKind::FOR_TESTING);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
diff --git a/test/cctest/heap/test-alloc.cc b/test/cctest/heap/test-alloc.cc
index 67040e4d60e..d1462878b52 100644
--- a/test/cctest/heap/test-alloc.cc
+++ b/test/cctest/heap/test-alloc.cc
@@ -85,7 +85,7 @@ Handle<Object> HeapTester::TestAllocateAfterFailures() {
 
   // Code space.
   heap::SimulateFullSpace(heap->code_space());
-  size = CcTest::i_isolate()->builtins()->builtin(Builtins::kIllegal).Size();
+  size = CcTest::i_isolate()->builtins()->builtin(Builtin::kIllegal).Size();
   obj =
       heap->AllocateRaw(size, AllocationType::kCode, AllocationOrigin::kRuntime)
           .ToObjectChecked();
@@ -139,7 +139,7 @@ TEST(StressJS) {
 
   Handle<NativeContext> context(isolate->native_context());
   Handle<SharedFunctionInfo> info = factory->NewSharedFunctionInfoForBuiltin(
-      factory->function_string(), Builtins::kEmptyFunction);
+      factory->function_string(), Builtin::kEmptyFunction);
   info->set_language_mode(LanguageMode::kStrict);
   Handle<JSFunction> function =
       Factory::JSFunctionBuilder{isolate, info, context}.Build();
diff --git a/test/cctest/interpreter/test-interpreter.cc b/test/cctest/interpreter/test-interpreter.cc
index 3596b03c25d..4112f838de7 100644
--- a/test/cctest/interpreter/test-interpreter.cc
+++ b/test/cctest/interpreter/test-interpreter.cc
@@ -5087,24 +5087,24 @@ TEST(InterpreterGetBytecodeHandler) {
   Code wide_handler =
       interpreter->GetBytecodeHandler(Bytecode::kWide, OperandScale::kSingle);
 
-  CHECK_EQ(wide_handler.builtin_index(), Builtins::kWideHandler);
+  CHECK_EQ(wide_handler.builtin_index(), Builtin::kWideHandler);
 
   Code add_handler =
       interpreter->GetBytecodeHandler(Bytecode::kAdd, OperandScale::kSingle);
 
-  CHECK_EQ(add_handler.builtin_index(), Builtins::kAddHandler);
+  CHECK_EQ(add_handler.builtin_index(), Builtin::kAddHandler);
 
   // Test that double-width bytecode handlers deserializer correctly, including
   // an illegal bytecode handler since there is no Wide.Wide handler.
   Code wide_wide_handler =
       interpreter->GetBytecodeHandler(Bytecode::kWide, OperandScale::kDouble);
 
-  CHECK_EQ(wide_wide_handler.builtin_index(), Builtins::kIllegalHandler);
+  CHECK_EQ(wide_wide_handler.builtin_index(), Builtin::kIllegalHandler);
 
   Code add_wide_handler =
       interpreter->GetBytecodeHandler(Bytecode::kAdd, OperandScale::kDouble);
 
-  CHECK_EQ(add_wide_handler.builtin_index(), Builtins::kAddWideHandler);
+  CHECK_EQ(add_wide_handler.builtin_index(), Builtin::kAddWideHandler);
 }
 
 TEST(InterpreterCollectSourcePositions) {
diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
index acdb0f340f6..18169e5832e 100644
--- a/test/cctest/test-api.cc
+++ b/test/cctest/test-api.cc
@@ -27074,18 +27074,18 @@ TEST(GetJSEntryStubs) {
   v8::JSEntryStubs entry_stubs = isolate->GetJSEntryStubs();
 
   v8::JSEntryStub entry_stub = entry_stubs.js_entry_stub;
-  CHECK_EQ(i_isolate->heap()->builtin(i::Builtins::kJSEntry).InstructionStart(),
+  CHECK_EQ(i_isolate->heap()->builtin(i::Builtin::kJSEntry).InstructionStart(),
            reinterpret_cast<i::Address>(entry_stub.code.start));
 
   v8::JSEntryStub construct_stub = entry_stubs.js_construct_entry_stub;
   CHECK_EQ(i_isolate->heap()
-               ->builtin(i::Builtins::kJSConstructEntry)
+               ->builtin(i::Builtin::kJSConstructEntry)
                .InstructionStart(),
            reinterpret_cast<i::Address>(construct_stub.code.start));
 
   v8::JSEntryStub microtask_stub = entry_stubs.js_run_microtasks_entry_stub;
   CHECK_EQ(i_isolate->heap()
-               ->builtin(i::Builtins::kJSRunMicrotasksEntry)
+               ->builtin(i::Builtin::kJSRunMicrotasksEntry)
                .InstructionStart(),
            reinterpret_cast<i::Address>(microtask_stub.code.start));
 }
diff --git a/test/cctest/test-assembler-ia32.cc b/test/cctest/test-assembler-ia32.cc
index b95fe619d1d..423bf88dbf7 100644
--- a/test/cctest/test-assembler-ia32.cc
+++ b/test/cctest/test-assembler-ia32.cc
@@ -1532,14 +1532,14 @@ TEST(DeoptExitSizeIsFixed) {
     Label before_exit;
     masm.bind(&before_exit);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      Builtins::Name target = Deoptimizer::GetDeoptWithResumeBuiltin(
+      Builtin target = Deoptimizer::GetDeoptWithResumeBuiltin(
           DeoptimizeReason::kDynamicCheckMaps);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
                Deoptimizer::kEagerWithResumeBeforeArgsSize);
     } else {
-      Builtins::Name target = Deoptimizer::GetDeoptimizationEntry(kind);
+      Builtin target = Deoptimizer::GetDeoptimizationEntry(kind);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
diff --git a/test/cctest/test-code-stub-assembler.cc b/test/cctest/test-code-stub-assembler.cc
index dcff92bcfca..574cc82fee9 100644
--- a/test/cctest/test-code-stub-assembler.cc
+++ b/test/cctest/test-code-stub-assembler.cc
@@ -2494,7 +2494,7 @@ TEST(CallBuiltin) {
     auto name = m.Parameter<Name>(2);
     auto context = m.Parameter<Context>(kNumParams + 3);
 
-    auto value = m.CallBuiltin(Builtins::kGetProperty, context, receiver, name);
+    auto value = m.CallBuiltin(Builtin::kGetProperty, context, receiver, name);
     m.Return(value);
   }
 
@@ -2523,7 +2523,7 @@ TEST(TailCallBuiltin) {
     auto name = m.Parameter<Name>(2);
     auto context = m.Parameter<Context>(kNumParams + 3);
 
-    m.TailCallBuiltin(Builtins::kGetProperty, context, receiver, name);
+    m.TailCallBuiltin(Builtin::kGetProperty, context, receiver, name);
   }
 
   FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
@@ -3003,7 +3003,7 @@ TEST(NewPromiseCapability) {
 
     const TNode<Oddball> debug_event = m.TrueConstant();
     const TNode<Object> capability =
-        m.CallBuiltin(Builtins::kNewPromiseCapability, context,
+        m.CallBuiltin(Builtin::kNewPromiseCapability, context,
                       promise_constructor, debug_event);
     m.Return(capability);
 
@@ -3049,7 +3049,7 @@ TEST(NewPromiseCapability) {
     auto constructor = m.Parameter<Object>(1);
     const TNode<Oddball> debug_event = m.TrueConstant();
     const TNode<Object> capability = m.CallBuiltin(
-        Builtins::kNewPromiseCapability, context, constructor, debug_event);
+        Builtin::kNewPromiseCapability, context, constructor, debug_event);
     m.Return(capability);
 
     FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
@@ -3900,7 +3900,7 @@ TEST(TestCallBuiltinInlineTrampoline) {
 
   TNode<Smi> index = m.SmiConstant(2);
 
-  m.Return(m.CallStub(Builtins::CallableFor(isolate, Builtins::kStringRepeat),
+  m.Return(m.CallStub(Builtins::CallableFor(isolate, Builtin::kStringRepeat),
                       context, str, index));
   AssemblerOptions options = AssemblerOptions::Default(isolate);
   options.inline_offheap_trampolines = true;
@@ -3926,7 +3926,7 @@ DISABLED_TEST(TestCallBuiltinIndirectLoad) {
 
   TNode<Smi> index = m.SmiConstant(2);
 
-  m.Return(m.CallStub(Builtins::CallableFor(isolate, Builtins::kStringRepeat),
+  m.Return(m.CallStub(Builtins::CallableFor(isolate, Builtin::kStringRepeat),
                       context, str, index));
   AssemblerOptions options = AssemblerOptions::Default(isolate);
   options.inline_offheap_trampolines = false;
@@ -4003,7 +4003,7 @@ TEST(WasmInt32ToHeapNumber) {
     CodeStubAssembler m(asm_tester.state());
     const TNode<Int32T> arg = m.Int32Constant(test_value);
     const TNode<Object> call_result = m.CallBuiltin(
-        Builtins::kWasmInt32ToHeapNumber, m.NoContextConstant(), arg);
+        Builtin::kWasmInt32ToHeapNumber, m.NoContextConstant(), arg);
     m.Return(call_result);
 
     FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
@@ -4049,7 +4049,7 @@ TEST(WasmTaggedNonSmiToInt32) {
   const auto arg = m.Parameter<Object>(1);
   int32_t result = 0;
   Node* base = m.IntPtrConstant(reinterpret_cast<intptr_t>(&result));
-  Node* value = m.CallBuiltin(Builtins::kWasmTaggedNonSmiToInt32, context, arg);
+  Node* value = m.CallBuiltin(Builtin::kWasmTaggedNonSmiToInt32, context, arg);
   m.StoreNoWriteBarrier(MachineRepresentation::kWord32, base, value);
   m.Return(m.UndefinedConstant());
 
@@ -4089,7 +4089,7 @@ TEST(WasmFloat32ToNumber) {
     CodeStubAssembler m(asm_tester.state());
     const TNode<Float32T> arg = m.Float32Constant(test_value);
     const TNode<Object> call_result = m.CallBuiltin(
-        Builtins::kWasmFloat32ToNumber, m.NoContextConstant(), arg);
+        Builtin::kWasmFloat32ToNumber, m.NoContextConstant(), arg);
     m.Return(call_result);
 
     FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
@@ -4129,7 +4129,7 @@ TEST(WasmFloat64ToNumber) {
     CodeStubAssembler m(asm_tester.state());
     const TNode<Float64T> arg = m.Float64Constant(test_value);
     const TNode<Object> call_result = m.CallBuiltin(
-        Builtins::kWasmFloat64ToNumber, m.NoContextConstant(), arg);
+        Builtin::kWasmFloat64ToNumber, m.NoContextConstant(), arg);
     m.Return(call_result);
 
     FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
@@ -4185,7 +4185,7 @@ TEST(WasmTaggedToFloat64) {
   const auto arg = m.Parameter<Object>(1);
   double result = 0;
   Node* base = m.IntPtrConstant(reinterpret_cast<intptr_t>(&result));
-  Node* value = m.CallBuiltin(Builtins::kWasmTaggedToFloat64, context, arg);
+  Node* value = m.CallBuiltin(Builtin::kWasmTaggedToFloat64, context, arg);
   m.StoreNoWriteBarrier(MachineRepresentation::kFloat64, base, value);
   m.Return(m.UndefinedConstant());
 
diff --git a/test/cctest/test-debug.cc b/test/cctest/test-debug.cc
index 5e49f1fa75a..a4f3d4d9a6b 100644
--- a/test/cctest/test-debug.cc
+++ b/test/cctest/test-debug.cc
@@ -4486,7 +4486,7 @@ TEST(BuiltinsExceptionPrediction) {
 
   i::Builtins* builtins = iisolate->builtins();
   bool fail = false;
-  for (int i = 0; i < i::Builtins::builtin_count; i++) {
+  for (int i = 0; i < i::Builtins::kBuiltinCount; i++) {
     i::Code builtin = builtins->builtin(i);
     if (builtin.kind() != i::CodeKind::BUILTIN) continue;
     auto prediction = builtin.GetBuiltinCatchPrediction();
diff --git a/test/cctest/test-feedback-vector.h b/test/cctest/test-feedback-vector.h
index db0e59b0a4f..d50719f4af9 100644
--- a/test/cctest/test-feedback-vector.h
+++ b/test/cctest/test-feedback-vector.h
@@ -45,7 +45,7 @@ Handle<FeedbackVector> NewFeedbackVector(Isolate* isolate, Spec* spec) {
   Handle<FeedbackMetadata> metadata = FeedbackMetadata::New(isolate, spec);
   Handle<SharedFunctionInfo> shared =
       isolate->factory()->NewSharedFunctionInfoForBuiltin(
-          isolate->factory()->empty_string(), Builtins::kIllegal);
+          isolate->factory()->empty_string(), Builtin::kIllegal);
   // Set the raw feedback metadata to circumvent checks that we are not
   // overwriting existing metadata.
   shared->set_raw_outer_scope_info_or_feedback_metadata(*metadata);
diff --git a/test/cctest/test-field-type-tracking.cc b/test/cctest/test-field-type-tracking.cc
index d106f59ddf1..ce98b754525 100644
--- a/test/cctest/test-field-type-tracking.cc
+++ b/test/cctest/test-field-type-tracking.cc
@@ -1562,7 +1562,7 @@ TEST(ReconfigureDataFieldAttribute_DataConstantToDataFieldAfterTargetMap) {
       Handle<Map> sloppy_map =
           Map::CopyInitialMap(isolate, isolate->sloppy_function_map());
       Handle<SharedFunctionInfo> info =
-          factory->NewSharedFunctionInfoForBuiltin(name, Builtins::kIllegal);
+          factory->NewSharedFunctionInfoForBuiltin(name, Builtin::kIllegal);
       function_type_ = FieldType::Class(sloppy_map, isolate);
       CHECK(sloppy_map->is_stable());
 
@@ -2722,7 +2722,7 @@ TEST(TransitionDataConstantToAnotherDataConstant) {
   Handle<Map> sloppy_map =
       Map::CopyInitialMap(isolate, isolate->sloppy_function_map());
   Handle<SharedFunctionInfo> info =
-      factory->NewSharedFunctionInfoForBuiltin(name, Builtins::kIllegal);
+      factory->NewSharedFunctionInfoForBuiltin(name, Builtin::kIllegal);
   CHECK(sloppy_map->is_stable());
 
   Handle<JSFunction> js_func1 =
diff --git a/test/cctest/test-log.cc b/test/cctest/test-log.cc
index d1f88877cd0..f56d65316b9 100644
--- a/test/cctest/test-log.cc
+++ b/test/cctest/test-log.cc
@@ -1188,7 +1188,7 @@ UNINITIALIZED_TEST(BuiltinsNotLoggedAsLazyCompile) {
     logger.StopLogging();
 
     i::Handle<i::Code> builtin = logger.i_isolate()->builtins()->builtin_handle(
-        i::Builtins::kBooleanConstructor);
+        i::Builtin::kBooleanConstructor);
     i::EmbeddedVector<char, 100> buffer;
 
     // Should only be logged as "Builtin" with a name, never as "LazyCompile".
diff --git a/test/cctest/test-macro-assembler-arm.cc b/test/cctest/test-macro-assembler-arm.cc
index 2274bab01a5..1190a4afb92 100644
--- a/test/cctest/test-macro-assembler-arm.cc
+++ b/test/cctest/test-macro-assembler-arm.cc
@@ -325,14 +325,14 @@ TEST(DeoptExitSizeIsFixed) {
     Label before_exit;
     masm.bind(&before_exit);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      Builtins::Name target = Deoptimizer::GetDeoptWithResumeBuiltin(
+      Builtin target = Deoptimizer::GetDeoptWithResumeBuiltin(
           DeoptimizeReason::kDynamicCheckMaps);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
                Deoptimizer::kEagerWithResumeBeforeArgsSize);
     } else {
-      Builtins::Name target = Deoptimizer::GetDeoptimizationEntry(kind);
+      Builtin target = Deoptimizer::GetDeoptimizationEntry(kind);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
diff --git a/test/cctest/test-macro-assembler-arm64.cc b/test/cctest/test-macro-assembler-arm64.cc
index 31fc1fae120..b896d3d0d4b 100644
--- a/test/cctest/test-macro-assembler-arm64.cc
+++ b/test/cctest/test-macro-assembler-arm64.cc
@@ -106,14 +106,14 @@ TEST(DeoptExitSizeIsFixed) {
     Label before_exit;
     if (kind == DeoptimizeKind::kEagerWithResume) {
       masm.bind(&before_exit);
-      Builtins::Name target = Deoptimizer::GetDeoptWithResumeBuiltin(
+      Builtin target = Deoptimizer::GetDeoptWithResumeBuiltin(
           DeoptimizeReason::kDynamicCheckMaps);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  &before_exit);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
                Deoptimizer::kEagerWithResumeBeforeArgsSize);
     } else {
-      Builtins::Name target = Deoptimizer::GetDeoptimizationEntry(kind);
+      Builtin target = Deoptimizer::GetDeoptimizationEntry(kind);
       // Mirroring logic in code-generator.cc.
       if (kind == DeoptimizeKind::kLazy) {
         // CFI emits an extra instruction here.
diff --git a/test/cctest/test-macro-assembler-mips.cc b/test/cctest/test-macro-assembler-mips.cc
index 03d778ef247..1e347d1a546 100644
--- a/test/cctest/test-macro-assembler-mips.cc
+++ b/test/cctest/test-macro-assembler-mips.cc
@@ -1350,14 +1350,14 @@ TEST(DeoptExitSizeIsFixed) {
     Label before_exit;
     masm.bind(&before_exit);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      Builtins::Name target = Deoptimizer::GetDeoptWithResumeBuiltin(
+      Builtin target = Deoptimizer::GetDeoptWithResumeBuiltin(
           DeoptimizeReason::kDynamicCheckMaps);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
                Deoptimizer::kEagerWithResumeBeforeArgsSize);
     } else {
-      Builtins::Name target = Deoptimizer::GetDeoptimizationEntry(kind);
+      Builtin target = Deoptimizer::GetDeoptimizationEntry(kind);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
diff --git a/test/cctest/test-macro-assembler-mips64.cc b/test/cctest/test-macro-assembler-mips64.cc
index 69cfa0cfda6..b69323171ed 100644
--- a/test/cctest/test-macro-assembler-mips64.cc
+++ b/test/cctest/test-macro-assembler-mips64.cc
@@ -1702,14 +1702,14 @@ TEST(DeoptExitSizeIsFixed) {
     Label before_exit;
     masm.bind(&before_exit);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      Builtins::Name target = Deoptimizer::GetDeoptWithResumeBuiltin(
+      Builtin target = Deoptimizer::GetDeoptWithResumeBuiltin(
           DeoptimizeReason::kDynamicCheckMaps);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
                Deoptimizer::kEagerWithResumeBeforeArgsSize);
     } else {
-      Builtins::Name target = Deoptimizer::GetDeoptimizationEntry(kind);
+      Builtin target = Deoptimizer::GetDeoptimizationEntry(kind);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
diff --git a/test/cctest/test-macro-assembler-riscv64.cc b/test/cctest/test-macro-assembler-riscv64.cc
index a21923a6994..6c3f36cc7c0 100644
--- a/test/cctest/test-macro-assembler-riscv64.cc
+++ b/test/cctest/test-macro-assembler-riscv64.cc
@@ -1532,14 +1532,14 @@ TEST(DeoptExitSizeIsFixed) {
     Label before_exit;
     masm.bind(&before_exit);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      Builtins::Name target = Deoptimizer::GetDeoptWithResumeBuiltin(
+      Builtin target = Deoptimizer::GetDeoptWithResumeBuiltin(
           DeoptimizeReason::kDynamicCheckMaps);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
                Deoptimizer::kEagerWithResumeBeforeArgsSize);
     } else {
-      Builtins::Name target = Deoptimizer::GetDeoptimizationEntry(kind);
+      Builtin target = Deoptimizer::GetDeoptimizationEntry(kind);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
diff --git a/test/cctest/test-macro-assembler-x64.cc b/test/cctest/test-macro-assembler-x64.cc
index 00ef735fc26..b0487e46d02 100644
--- a/test/cctest/test-macro-assembler-x64.cc
+++ b/test/cctest/test-macro-assembler-x64.cc
@@ -1063,14 +1063,14 @@ TEST(DeoptExitSizeIsFixed) {
     Label before_exit;
     masm.bind(&before_exit);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      Builtins::Name target = Deoptimizer::GetDeoptWithResumeBuiltin(
+      Builtin target = Deoptimizer::GetDeoptWithResumeBuiltin(
           DeoptimizeReason::kDynamicCheckMaps);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
                Deoptimizer::kEagerWithResumeBeforeArgsSize);
     } else {
-      Builtins::Name target = Deoptimizer::GetDeoptimizationEntry(kind);
+      Builtin target = Deoptimizer::GetDeoptimizationEntry(kind);
       masm.CallForDeoptimization(target, 42, &before_exit, kind, &before_exit,
                                  nullptr);
       CHECK_EQ(masm.SizeOfCodeGeneratedSince(&before_exit),
diff --git a/test/cctest/test-swiss-name-dictionary-csa.cc b/test/cctest/test-swiss-name-dictionary-csa.cc
index 5c730883e86..bc93f4a43a7 100644
--- a/test/cctest/test-swiss-name-dictionary-csa.cc
+++ b/test/cctest/test-swiss-name-dictionary-csa.cc
@@ -266,7 +266,7 @@ Handle<Code> CSATestRunner::create_find_entry(Isolate* isolate) {
   // TODO(v8:11330): Remove once CSA implementation has a fallback for
   // non-SSSE3/AVX configurations.
   if (!IsEnabled()) {
-    return isolate->builtins()->builtin_handle(Builtins::kIllegal);
+    return isolate->builtins()->builtin_handle(Builtin::kIllegal);
   }
   STATIC_ASSERT(kFindEntryParams == 2);  // (table, key)
   compiler::CodeAssemblerTester asm_tester(isolate, kFindEntryParams + 1);
@@ -338,7 +338,7 @@ Handle<Code> CSATestRunner::create_delete(Isolate* isolate) {
   // TODO(v8:11330): Remove once CSA implementation has a fallback for
   // non-SSSE3/AVX configurations.
   if (!IsEnabled()) {
-    return isolate->builtins()->builtin_handle(Builtins::kIllegal);
+    return isolate->builtins()->builtin_handle(Builtin::kIllegal);
   }
   STATIC_ASSERT(kDeleteParams == 2);  // (table, entry)
   compiler::CodeAssemblerTester asm_tester(isolate, kDeleteParams + 1);
@@ -363,7 +363,7 @@ Handle<Code> CSATestRunner::create_add(Isolate* isolate) {
   // TODO(v8:11330): Remove once CSA implementation has a fallback for
   // non-SSSE3/AVX configurations.
   if (!IsEnabled()) {
-    return isolate->builtins()->builtin_handle(Builtins::kIllegal);
+    return isolate->builtins()->builtin_handle(Builtin::kIllegal);
   }
   STATIC_ASSERT(kAddParams == 4);  // (table, key, value, details)
   compiler::CodeAssemblerTester asm_tester(isolate, kAddParams + 1);
diff --git a/test/cctest/test-unwinder-code-pages.cc b/test/cctest/test-unwinder-code-pages.cc
index cac00e0a707..9a5a4eac1fa 100644
--- a/test/cctest/test-unwinder-code-pages.cc
+++ b/test/cctest/test-unwinder-code-pages.cc
@@ -166,7 +166,7 @@ TEST(Unwind_BuiltinPCInMiddle_Success_CodePagesAPI) {
   register_state.fp = stack;
 
   // Put the current PC inside of a valid builtin.
-  Code builtin = i_isolate->builtins()->builtin(Builtins::kStringEqual);
+  Code builtin = i_isolate->builtins()->builtin(Builtin::kStringEqual);
   const uintptr_t offset = 40;
   CHECK_LT(offset, builtin.InstructionSize());
   register_state.pc =
@@ -223,7 +223,7 @@ TEST(Unwind_BuiltinPCAtStart_Success_CodePagesAPI) {
 
   // Put the current PC at the start of a valid builtin, so that we are setting
   // up the frame.
-  Code builtin = i_isolate->builtins()->builtin(Builtins::kStringEqual);
+  Code builtin = i_isolate->builtins()->builtin(Builtin::kStringEqual);
   register_state.pc = reinterpret_cast<void*>(builtin.InstructionStart());
 
   bool unwound = v8::Unwinder::TryUnwindV8Frames(
@@ -454,7 +454,7 @@ TEST(Unwind_JSEntry_Fail_CodePagesAPI) {
   CHECK_LE(pages_length, arraysize(code_pages));
   RegisterState register_state;
 
-  Code js_entry = i_isolate->heap()->builtin(Builtins::kJSEntry);
+  Code js_entry = i_isolate->heap()->builtin(Builtin::kJSEntry);
   byte* start = reinterpret_cast<byte*>(js_entry.InstructionStart());
   register_state.pc = start + 10;
 
@@ -636,7 +636,7 @@ TEST(PCIsInV8_InJSEntryRange_CodePagesAPI) {
       isolate->CopyCodePages(arraysize(code_pages), code_pages);
   CHECK_LE(pages_length, arraysize(code_pages));
 
-  Code js_entry = i_isolate->heap()->builtin(Builtins::kJSEntry);
+  Code js_entry = i_isolate->heap()->builtin(Builtin::kJSEntry);
   byte* start = reinterpret_cast<byte*>(js_entry.InstructionStart());
   size_t length = js_entry.InstructionSize();
 
diff --git a/test/cctest/wasm/test-run-wasm-wrappers.cc b/test/cctest/wasm/test-run-wasm-wrappers.cc
index 5ab6db40270..3db267cc470 100644
--- a/test/cctest/wasm/test-run-wasm-wrappers.cc
+++ b/test/cctest/wasm/test-run-wasm-wrappers.cc
@@ -33,7 +33,7 @@ Handle<WasmInstanceObject> CompileModule(Zone* zone, Isolate* isolate,
 
 bool IsGeneric(Code wrapper) {
   return wrapper.is_builtin() &&
-         wrapper.builtin_index() == Builtins::kGenericJSToWasmWrapper;
+         wrapper.builtin_index() == Builtin::kGenericJSToWasmWrapper;
 }
 
 bool IsSpecific(Code wrapper) {
diff --git a/test/unittests/compiler/backend/instruction-selector-unittest.cc b/test/unittests/compiler/backend/instruction-selector-unittest.cc
index 11ee5d20759..f4e3ea07b1c 100644
--- a/test/unittests/compiler/backend/instruction-selector-unittest.cc
+++ b/test/unittests/compiler/backend/instruction-selector-unittest.cc
@@ -408,7 +408,7 @@ TARGET_TEST_F(InstructionSelectorTest, CallStubWithDeopt) {
   ZoneVector<MachineType> float64_type(1, MachineType::Float64(), zone());
   ZoneVector<MachineType> tagged_type(1, MachineType::AnyTagged(), zone());
 
-  Callable callable = Builtins::CallableFor(isolate(), Builtins::kToObject);
+  Callable callable = Builtins::CallableFor(isolate(), Builtin::kToObject);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       zone(), callable.descriptor(), 1, CallDescriptor::kNeedsFrameState,
       Operator::kNoProperties);
@@ -501,7 +501,7 @@ TARGET_TEST_F(InstructionSelectorTest, CallStubWithDeoptRecursiveFrameState) {
   ZoneVector<MachineType> int32_type(1, MachineType::Int32(), zone());
   ZoneVector<MachineType> float64_type(1, MachineType::Float64(), zone());
 
-  Callable callable = Builtins::CallableFor(isolate(), Builtins::kToObject);
+  Callable callable = Builtins::CallableFor(isolate(), Builtin::kToObject);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       zone(), callable.descriptor(), 1, CallDescriptor::kNeedsFrameState,
       Operator::kNoProperties);
diff --git a/test/unittests/compiler/js-call-reducer-unittest.cc b/test/unittests/compiler/js-call-reducer-unittest.cc
index 435495169a5..e0776382573 100644
--- a/test/unittests/compiler/js-call-reducer-unittest.cc
+++ b/test/unittests/compiler/js-call-reducer-unittest.cc
@@ -104,7 +104,7 @@ class JSCallReducerTest : public TypedGraphTest {
     Handle<FeedbackMetadata> metadata = FeedbackMetadata::New(isolate(), &spec);
     Handle<SharedFunctionInfo> shared =
         isolate()->factory()->NewSharedFunctionInfoForBuiltin(
-            isolate()->factory()->empty_string(), Builtins::kIllegal);
+            isolate()->factory()->empty_string(), Builtin::kIllegal);
     // Set the raw feedback metadata to circumvent checks that we are not
     // overwriting existing metadata.
     shared->set_raw_outer_scope_info_or_feedback_metadata(*metadata);
diff --git a/test/unittests/compiler/redundancy-elimination-unittest.cc b/test/unittests/compiler/redundancy-elimination-unittest.cc
index 14960358788..252e7ce8e22 100644
--- a/test/unittests/compiler/redundancy-elimination-unittest.cc
+++ b/test/unittests/compiler/redundancy-elimination-unittest.cc
@@ -35,7 +35,7 @@ class RedundancyEliminationTest : public GraphTest {
     Handle<FeedbackMetadata> metadata = FeedbackMetadata::New(isolate(), &spec);
     Handle<SharedFunctionInfo> shared =
         isolate()->factory()->NewSharedFunctionInfoForBuiltin(
-            isolate()->factory()->empty_string(), Builtins::kIllegal);
+            isolate()->factory()->empty_string(), Builtin::kIllegal);
     shared->set_raw_outer_scope_info_or_feedback_metadata(*metadata);
     Handle<ClosureFeedbackCellArray> closure_feedback_cell_array =
         ClosureFeedbackCellArray::New(isolate(), shared);
diff --git a/test/unittests/test-helpers.cc b/test/unittests/test-helpers.cc
index 6691784a718..9154992b2b3 100644
--- a/test/unittests/test-helpers.cc
+++ b/test/unittests/test-helpers.cc
@@ -39,7 +39,7 @@ Handle<SharedFunctionInfo> CreateSharedFunctionInfo(
   Handle<SharedFunctionInfo> shared =
       isolate->factory()->NewSharedFunctionInfoForBuiltin(
           isolate->factory()->NewStringFromAsciiChecked("f"),
-          Builtins::kCompileLazy);
+          Builtin::kCompileLazy);
   int function_literal_id = 1;
   shared->set_function_literal_id(function_literal_id);
   // Ensure that the function can be compiled lazily.
-- 
2.35.1


From e39af94dd18e6079cfd91d4d1751c3c21c723230 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Thu, 17 Nov 2022 14:33:21 +0800
Subject: [PATCH] [riscv64] Fix failed: vector[] index out of

GenPCRelativeJumpAndLink doesn't use BlockTrampolinePoolScope.
It inserts a BlockTrampolinePool which causes this error.

And also alter debug info format.

Change-Id: I160f13f4261fdcf1f7978bfce9b5169d363e6a10
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4032016
Commit-Queue: Yahan Lu <yahan@iscas.ac.cn>
Reviewed-by: ji qiu <qiuji@iscas.ac.cn>
Commit-Queue: ji qiu <qiuji@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#84316}
---
 src/codegen/riscv/assembler-riscv.cc       | 20 ++++++++++----------
 src/codegen/riscv/macro-assembler-riscv.cc |  1 +
 src/codegen/riscv/macro-assembler-riscv.h  |  2 ++
 3 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/src/codegen/riscv/assembler-riscv.cc b/src/codegen/riscv/assembler-riscv.cc
index 4e2ffdaa6c..f8c2e33051 100644
--- a/src/codegen/riscv/assembler-riscv.cc
+++ b/src/codegen/riscv/assembler-riscv.cc
@@ -501,7 +501,7 @@ void Assembler::target_at_put(int pos, int target_pos, bool is_internal,
     *reinterpret_cast<uintptr_t*>(buffer_start_ + pos) = imm;
     return;
   }
-  DEBUG_PRINTF("target_at_put: %p (%d) to %p (%d)\n",
+  DEBUG_PRINTF("\ttarget_at_put: %p (%d) to %p (%d)\n",
                reinterpret_cast<Instr*>(buffer_start_ + pos), pos,
                reinterpret_cast<Instr*>(buffer_start_ + target_pos),
                target_pos);
@@ -597,7 +597,7 @@ void Assembler::print(const Label* L) {
 
 void Assembler::bind_to(Label* L, int pos) {
   DCHECK(0 <= pos && pos <= pc_offset());  // Must have valid binding position.
-  DEBUG_PRINTF("binding %d to label %p\n", pos, L);
+  DEBUG_PRINTF("\tbinding %d to label %p\n", pos, L);
   int trampoline_pos = kInvalidSlotPos;
   bool is_internal = false;
   if (L->is_linked() && !trampoline_emitted_) {
@@ -666,7 +666,7 @@ void Assembler::next(Label* L, bool is_internal) {
     L->Unuse();
   } else {
     DCHECK_GE(link, 0);
-    DEBUG_PRINTF("next: %p to %p (%d)\n", L,
+    DEBUG_PRINTF("\tnext: %p to %p (%d)\n", L,
                  reinterpret_cast<Instr*>(buffer_start_ + link), link);
     L->link_to(link);
   }
@@ -740,7 +740,7 @@ int32_t Assembler::get_trampoline_entry(int32_t pos) {
 
 uintptr_t Assembler::jump_address(Label* L) {
   intptr_t target_pos;
-  DEBUG_PRINTF("jump_address: %p to %p (%d)\n", L,
+  DEBUG_PRINTF("\tjump_address: %p to %p (%d)\n", L,
                reinterpret_cast<Instr*>(buffer_start_ + pc_offset()),
                pc_offset());
   if (L->is_bound()) {
@@ -771,7 +771,7 @@ uintptr_t Assembler::jump_address(Label* L) {
 int32_t Assembler::branch_long_offset(Label* L) {
   intptr_t target_pos;
 
-  DEBUG_PRINTF("branch_long_offset: %p to %p (%d)\n", L,
+  DEBUG_PRINTF("\tbranch_long_offset: %p to %p (%d)\n", L,
                reinterpret_cast<Instr*>(buffer_start_ + pc_offset()),
                pc_offset());
   if (L->is_bound()) {
@@ -803,7 +803,7 @@ int32_t Assembler::branch_long_offset(Label* L) {
 int32_t Assembler::branch_offset_helper(Label* L, OffsetSize bits) {
   int32_t target_pos;
 
-  DEBUG_PRINTF("branch_offset_helper: %p to %p (%d)\n", L,
+  DEBUG_PRINTF("\tbranch_offset_helper: %p to %p (%d)\n", L,
                reinterpret_cast<Instr*>(buffer_start_ + pc_offset()),
                pc_offset());
   if (L->is_bound()) {
@@ -835,7 +835,7 @@ int32_t Assembler::branch_offset_helper(Label* L, OffsetSize bits) {
 
 void Assembler::label_at_put(Label* L, int at_offset) {
   int target_pos;
-  DEBUG_PRINTF("label_at_put: %p @ %p (%d)\n", L,
+  DEBUG_PRINTF("\tlabel_at_put: %p @ %p (%d)\n", L,
                reinterpret_cast<Instr*>(buffer_start_ + at_offset), at_offset);
   if (L->is_bound()) {
     target_pos = L->pos();
@@ -1179,7 +1179,7 @@ void Assembler::li_ptr(Register rd, int64_t imm) {
 }
 
 void Assembler::li_constant(Register rd, int64_t imm) {
-  DEBUG_PRINTF("li_constant(%d, %lx <%ld>)\n", ToNumber(rd), imm, imm);
+  DEBUG_PRINTF("\tli_constant(%d, %lx <%ld>)\n", ToNumber(rd), imm, imm);
   lui(rd, (imm + (1LL << 47) + (1LL << 35) + (1LL << 23) + (1LL << 11)) >>
               48);  // Bits 63:48
   addiw(rd, rd,
@@ -1236,7 +1236,7 @@ void Assembler::li_ptr(Register rd, int32_t imm) {
 }
 
 void Assembler::li_constant(Register rd, int32_t imm) {
-  DEBUG_PRINTF("li_constant(%d, %x <%d>)\n", ToNumber(rd), imm, imm);
+  DEBUG_PRINTF("\tli_constant(%d, %x <%d>)\n", ToNumber(rd), imm, imm);
   int32_t high_20 = ((imm + 0x800) >> 12);  // bits31:12
   int32_t low_12 = imm & 0xfff;             // bits11:0
   lui(rd, high_20);
@@ -1335,7 +1335,7 @@ int Assembler::RelocateInternalReference(RelocInfo::Mode rmode, Address pc,
   DCHECK(RelocInfo::IsInternalReferenceEncoded(rmode));
   if (IsLui(instr)) {
     uintptr_t target_address = target_address_at(pc) + pc_delta;
-    DEBUG_PRINTF("target_address 0x%" PRIxPTR "\n", target_address);
+    DEBUG_PRINTF("\ttarget_address 0x%" PRIxPTR "\n", target_address);
     set_target_value_at(pc, target_address);
 #if V8_TARGET_ARCH_RISCV64
     return 8;  // Number of instructions patched.
diff --git a/src/codegen/riscv/macro-assembler-riscv.cc b/src/codegen/riscv/macro-assembler-riscv.cc
index 0ad3f1360b..00a89a40c1 100644
--- a/src/codegen/riscv/macro-assembler-riscv.cc
+++ b/src/codegen/riscv/macro-assembler-riscv.cc
@@ -4475,6 +4475,7 @@ MemOperand TurboAssembler::EntryFromBuiltinAsOperand(Builtin builtin) {
 }
 
 void TurboAssembler::PatchAndJump(Address target) {
+  BlockTrampolinePoolScope block_trampoline_pool(this);
   UseScratchRegisterScope temps(this);
   Register scratch = temps.Acquire();
   auipc(scratch, 0);  // Load PC into scratch
diff --git a/src/codegen/riscv/macro-assembler-riscv.h b/src/codegen/riscv/macro-assembler-riscv.h
index eb4b71cb43..76c6436991 100644
--- a/src/codegen/riscv/macro-assembler-riscv.h
+++ b/src/codegen/riscv/macro-assembler-riscv.h
@@ -212,6 +212,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   void LoadRootRelative(Register destination, int32_t offset) final;
 
   inline void GenPCRelativeJump(Register rd, int32_t imm32) {
+    BlockTrampolinePoolScope block_trampoline_pool(this);
     DCHECK(is_int32(imm32 + 0x800));
     int32_t Hi20 = ((imm32 + 0x800) >> 12);
     int32_t Lo12 = imm32 << 20 >> 20;
@@ -220,6 +221,7 @@ class V8_EXPORT_PRIVATE TurboAssembler : public TurboAssemblerBase {
   }
 
   inline void GenPCRelativeJumpAndLink(Register rd, int32_t imm32) {
+    BlockTrampolinePoolScope block_trampoline_pool(this);
     DCHECK(is_int32(imm32 + 0x800));
     int32_t Hi20 = ((imm32 + 0x800) >> 12);
     int32_t Lo12 = imm32 << 20 >> 20;
-- 
2.35.1


From 61ebf10fbcc10c7fe6a13b4e94a93200111cfb65 Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Tue, 16 May 2023 12:16:07 +0200
Subject: [PATCH] [diagnostics] Use uint8_t instead of byte

Byte is an alias for the standard uint8_t type (defined in
src/common/globals.h and src/diagnostics/disasm.h).
For readability, avoid the alias and use the uint8_t directly.

R=ahaas@chromium.org

Change-Id: I4bbb1d8dc52c92fe5e54e1f13c73fa842da94d9a
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4523175
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#87693}
---
 src/diagnostics/arm/disasm-arm.cc         |  45 ++---
 src/diagnostics/arm64/disasm-arm64.cc     |  14 +-
 src/diagnostics/disasm.h                  |  14 +-
 src/diagnostics/disassembler.cc           |  28 +--
 src/diagnostics/disassembler.h            |   2 +-
 src/diagnostics/eh-frame.cc               |  48 ++---
 src/diagnostics/eh-frame.h                |  40 ++--
 src/diagnostics/gdb-jit.cc                |  10 +-
 src/diagnostics/ia32/disasm-ia32.cc       | 195 +++++++++---------
 src/diagnostics/loong64/disasm-loong64.cc |  26 +--
 src/diagnostics/mips64/disasm-mips64.cc   |  54 ++---
 src/diagnostics/objects-printer.cc        |   2 +-
 src/diagnostics/ppc/disasm-ppc.cc         |  28 +--
 src/diagnostics/riscv/disasm-riscv.cc     |  30 +--
 src/diagnostics/s390/disasm-s390.cc       |  34 ++--
 src/diagnostics/unwinder.cc               |   6 +-
 src/diagnostics/x64/disasm-x64.cc         | 231 +++++++++++-----------
 17 files changed, 405 insertions(+), 402 deletions(-)

diff --git a/src/diagnostics/arm/disasm-arm.cc b/src/diagnostics/arm/disasm-arm.cc
index 01b697b4bb..2e21165e83 100644
--- a/src/diagnostics/arm/disasm-arm.cc
+++ b/src/diagnostics/arm/disasm-arm.cc
@@ -10,9 +10,9 @@
 //
 //   NameConverter converter;
 //   Disassembler d(converter);
-//   for (byte* pc = begin; pc < end;) {
+//   for (uint8_t* pc = begin; pc < end;) {
 //     v8::base::EmbeddedVector<char, 256> buffer;
-//     byte* prev_pc = pc;
+//     uint8_t* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
 //            prev_pc, *reinterpret_cast<int32_t*>(prev_pc), buffer);
@@ -60,10 +60,10 @@ class Decoder {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(byte* instruction);
+  int InstructionDecode(uint8_t* instruction);
 
-  static bool IsConstantPoolAt(byte* instr_ptr);
-  static int ConstantPoolSizeAt(byte* instr_ptr);
+  static bool IsConstantPoolAt(uint8_t* instr_ptr);
+  static int ConstantPoolSizeAt(uint8_t* instr_ptr);
 
  private:
   // Bottleneck functions to print into the out_buffer.
@@ -525,8 +525,8 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
       }
       // 'msg: for simulator break instructions
       DCHECK(STRING_STARTS_WITH(format, "msg"));
-      byte* str =
-          reinterpret_cast<byte*>(instr->InstructionBits() & 0x0FFFFFFF);
+      uint8_t* str =
+          reinterpret_cast<uint8_t*>(instr->InstructionBits() & 0x0FFFFFFF);
       out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s",
                                         converter_.NameInCode(str));
       return 3;
@@ -634,7 +634,7 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
       int off = (static_cast<uint32_t>(instr->SImmed24Value()) << 2) + 8u;
       out_buffer_pos_ += base::SNPrintF(
           out_buffer_ + out_buffer_pos_, "%+d -> %s", off,
-          converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + off));
+          converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + off));
       return 6;
     }
     case 'u': {  // 'u: signed or unsigned multiplies
@@ -663,8 +663,9 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
     case 'A': {
       // Print pc-relative address.
       int offset = instr->Offset12Value();
-      byte* pc = reinterpret_cast<byte*>(instr) + Instruction::kPcLoadDelta;
-      byte* addr;
+      uint8_t* pc =
+          reinterpret_cast<uint8_t*>(instr) + Instruction::kPcLoadDelta;
+      uint8_t* addr;
       switch (instr->PUField()) {
         case db_x: {
           addr = pc - offset;
@@ -1762,7 +1763,7 @@ void Decoder::DecodeVCVTBetweenFloatingPointAndInteger(Instruction* instr) {
 }
 
 void Decoder::DecodeVmovImmediate(Instruction* instr) {
-  byte cmode = instr->Bits(11, 8);
+  uint8_t cmode = instr->Bits(11, 8);
   int vd = instr->VFPDRegValue(kSimd128Precision);
   int a = instr->Bit(24);
   int bcd = instr->Bits(18, 16);
@@ -2514,12 +2515,12 @@ void Decoder::DecodeAdvancedSIMDElementOrStructureLoadStore(
 
 #undef VERIFY
 
-bool Decoder::IsConstantPoolAt(byte* instr_ptr) {
+bool Decoder::IsConstantPoolAt(uint8_t* instr_ptr) {
   int instruction_bits = *(reinterpret_cast<int*>(instr_ptr));
   return (instruction_bits & kConstantPoolMarkerMask) == kConstantPoolMarker;
 }
 
-int Decoder::ConstantPoolSizeAt(byte* instr_ptr) {
+int Decoder::ConstantPoolSizeAt(uint8_t* instr_ptr) {
   if (IsConstantPoolAt(instr_ptr)) {
     int instruction_bits = *(reinterpret_cast<int*>(instr_ptr));
     return DecodeConstantPoolLength(instruction_bits);
@@ -2529,7 +2530,7 @@ int Decoder::ConstantPoolSizeAt(byte* instr_ptr) {
 }
 
 // Disassemble the instruction at *instr_ptr into the output buffer.
-int Decoder::InstructionDecode(byte* instr_ptr) {
+int Decoder::InstructionDecode(uint8_t* instr_ptr) {
   Instruction* instr = Instruction::At(reinterpret_cast<Address>(instr_ptr));
   // Print raw instruction bytes.
   out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
@@ -2589,12 +2590,12 @@ int Decoder::InstructionDecode(byte* instr_ptr) {
 
 namespace disasm {
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -2610,7 +2611,7 @@ const char* NameConverter::NameOfXMMRegister(int reg) const {
   UNREACHABLE();  // ARM does not have any XMM registers
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // The default name converter is called for unknown code. So we will not try
   // to access any memory.
   return "";
@@ -2619,23 +2620,23 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
 }
 
-int Disassembler::ConstantPoolSizeAt(byte* instruction) {
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) {
   return v8::internal::Decoder::ConstantPoolSizeAt(instruction);
 }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     v8::internal::PrintF(f, "%p    %08x      %s\n", static_cast<void*>(prev_pc),
                          *reinterpret_cast<int32_t*>(prev_pc), buffer.begin());
diff --git a/src/diagnostics/arm64/disasm-arm64.cc b/src/diagnostics/arm64/disasm-arm64.cc
index 94471fa2c7..7cadde65a4 100644
--- a/src/diagnostics/arm64/disasm-arm64.cc
+++ b/src/diagnostics/arm64/disasm-arm64.cc
@@ -4463,12 +4463,12 @@ void PrintDisassembler::ProcessOutput(Instruction* instr) {
 
 namespace disasm {
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -4492,7 +4492,7 @@ const char* NameConverter::NameOfXMMRegister(int reg) const {
   UNREACHABLE();  // ARM64 does not have any XMM registers
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // The default name converter is called for unknown code, so we will not try
   // to access any memory.
   return "";
@@ -4517,7 +4517,7 @@ class BufferDisassembler : public v8::internal::DisassemblingDecoder {
 };
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instr) {
+                                    uint8_t* instr) {
   USE(converter_);  // avoid unused field warning
   v8::internal::Decoder<v8::internal::DispatchingDecoderVisitor> decoder;
   BufferDisassembler disasm(buffer);
@@ -4527,18 +4527,18 @@ int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
   return v8::internal::kInstrSize;
 }
 
-int Disassembler::ConstantPoolSizeAt(byte* instr) {
+int Disassembler::ConstantPoolSizeAt(uint8_t* instr) {
   return v8::internal::Assembler::ConstantPoolSizeAt(
       reinterpret_cast<v8::internal::Instruction*>(instr));
 }
 
-void Disassembler::Disassemble(FILE* file, byte* start, byte* end,
+void Disassembler::Disassemble(FILE* file, uint8_t* start, uint8_t* end,
                                UnimplementedOpcodeAction) {
   v8::internal::Decoder<v8::internal::DispatchingDecoderVisitor> decoder;
   v8::internal::PrintDisassembler disasm(file);
   decoder.AppendVisitor(&disasm);
 
-  for (byte* pc = start; pc < end; pc += v8::internal::kInstrSize) {
+  for (uint8_t* pc = start; pc < end; pc += v8::internal::kInstrSize) {
     decoder.Decode(reinterpret_cast<v8::internal::Instruction*>(pc));
   }
 }
diff --git a/src/diagnostics/disasm.h b/src/diagnostics/disasm.h
index aea93a235b..0b96b4aae8 100644
--- a/src/diagnostics/disasm.h
+++ b/src/diagnostics/disasm.h
@@ -9,8 +9,6 @@
 
 namespace disasm {
 
-using byte = unsigned char;
-
 // Interface and default implementation for converting addresses and
 // register-numbers to text.  The default implementation is machine
 // specific.
@@ -20,9 +18,9 @@ class V8_EXPORT_PRIVATE NameConverter {
   virtual const char* NameOfCPURegister(int reg) const;
   virtual const char* NameOfByteCPURegister(int reg) const;
   virtual const char* NameOfXMMRegister(int reg) const;
-  virtual const char* NameOfAddress(byte* addr) const;
-  virtual const char* NameOfConstant(byte* addr) const;
-  virtual const char* NameInCode(byte* addr) const;
+  virtual const char* NameOfAddress(uint8_t* addr) const;
+  virtual const char* NameOfConstant(uint8_t* addr) const;
+  virtual const char* NameInCode(uint8_t* addr) const;
 
   // Given a root-register-relative offset, returns either a name or nullptr if
   // none is found.
@@ -56,16 +54,16 @@ class Disassembler {
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
   V8_EXPORT_PRIVATE int InstructionDecode(v8::base::Vector<char> buffer,
-                                          byte* instruction);
+                                          uint8_t* instruction);
 
   // Returns -1 if instruction does not mark the beginning of a constant pool,
   // or the number of entries in the constant pool beginning here.
-  int ConstantPoolSizeAt(byte* instruction);
+  int ConstantPoolSizeAt(uint8_t* instruction);
 
   // Write disassembly into specified file 'f' using specified NameConverter
   // (see constructor).
   V8_EXPORT_PRIVATE static void Disassemble(
-      FILE* f, byte* begin, byte* end,
+      FILE* f, uint8_t* begin, uint8_t* end,
       UnimplementedOpcodeAction unimplemented_action =
           kAbortOnUnimplementedOpcode);
 
diff --git a/src/diagnostics/disassembler.cc b/src/diagnostics/disassembler.cc
index a9b3a74433..54b7fe8405 100644
--- a/src/diagnostics/disassembler.cc
+++ b/src/diagnostics/disassembler.cc
@@ -42,8 +42,8 @@ class V8NameConverter : public disasm::NameConverter {
  public:
   explicit V8NameConverter(Isolate* isolate, CodeReference code = {})
       : isolate_(isolate), code_(code) {}
-  const char* NameOfAddress(byte* pc) const override;
-  const char* NameInCode(byte* addr) const override;
+  const char* NameOfAddress(uint8_t* pc) const override;
+  const char* NameInCode(uint8_t* addr) const override;
   const char* RootRelativeName(int offset) const override;
 
   const CodeReference& code() const { return code_; }
@@ -82,7 +82,7 @@ void V8NameConverter::InitExternalRefsCache() const {
   }
 }
 
-const char* V8NameConverter::NameOfAddress(byte* pc) const {
+const char* V8NameConverter::NameOfAddress(uint8_t* pc) const {
   if (!code_.is_null()) {
     const char* name =
         isolate_ ? isolate_->builtins()->Lookup(reinterpret_cast<Address>(pc))
@@ -115,7 +115,7 @@ const char* V8NameConverter::NameOfAddress(byte* pc) const {
   return disasm::NameConverter::NameOfAddress(pc);
 }
 
-const char* V8NameConverter::NameInCode(byte* addr) const {
+const char* V8NameConverter::NameInCode(uint8_t* addr) const {
   // The V8NameConverter is used for well known code, so we can "safely"
   // dereference pointers in generated code.
   return code_.is_null() ? "" : reinterpret_cast<const char*>(addr);
@@ -280,12 +280,12 @@ static void PrintRelocInfo(std::ostringstream& out, Isolate* isolate,
 
 static int DecodeIt(Isolate* isolate, ExternalReferenceEncoder* ref_encoder,
                     std::ostream& os, CodeReference code,
-                    const V8NameConverter& converter, byte* begin, byte* end,
-                    Address current_pc, size_t range_limit) {
+                    const V8NameConverter& converter, uint8_t* begin,
+                    uint8_t* end, Address current_pc, size_t range_limit) {
   CHECK(!code.is_null());
   v8::base::EmbeddedVector<char, 128> decode_buffer;
   std::ostringstream out;
-  byte* pc = begin;
+  uint8_t* pc = begin;
   disasm::Disassembler d(converter,
                          disasm::Disassembler::kContinueOnUnimplementedOpcode);
   RelocIterator rit(code);
@@ -294,7 +294,7 @@ static int DecodeIt(Isolate* isolate, ExternalReferenceEncoder* ref_encoder,
 
   while (pc < end) {
     // First decode instruction so that we know its length.
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     bool decoding_constant_pool = constants > 0;
     if (decoding_constant_pool) {
       SNPrintF(
@@ -315,8 +315,8 @@ static int DecodeIt(Isolate* isolate, ExternalReferenceEncoder* ref_encoder,
                  rit.rinfo()->pc() == reinterpret_cast<Address>(pc) &&
                  rit.rinfo()->rmode() == RelocInfo::INTERNAL_REFERENCE) {
         // A raw pointer embedded in code stream.
-        byte* ptr =
-            base::ReadUnalignedValue<byte*>(reinterpret_cast<Address>(pc));
+        uint8_t* ptr =
+            base::ReadUnalignedValue<uint8_t*>(reinterpret_cast<Address>(pc));
         SNPrintF(decode_buffer, "%08" V8PRIxPTR "       jump table entry %4zu",
                  reinterpret_cast<intptr_t>(ptr),
                  static_cast<size_t>(ptr - begin));
@@ -439,8 +439,8 @@ static int DecodeIt(Isolate* isolate, ExternalReferenceEncoder* ref_encoder,
   return static_cast<int>(pc - begin);
 }
 
-int Disassembler::Decode(Isolate* isolate, std::ostream& os, byte* begin,
-                         byte* end, CodeReference code, Address current_pc,
+int Disassembler::Decode(Isolate* isolate, std::ostream& os, uint8_t* begin,
+                         uint8_t* end, CodeReference code, Address current_pc,
                          size_t range_limit) {
   DCHECK_WITH_MSG(v8_flags.text_is_readable,
                   "Builtins disassembly requires a readable .text section");
@@ -463,8 +463,8 @@ int Disassembler::Decode(Isolate* isolate, std::ostream& os, byte* begin,
 
 #else  // ENABLE_DISASSEMBLER
 
-int Disassembler::Decode(Isolate* isolate, std::ostream& os, byte* begin,
-                         byte* end, CodeReference code, Address current_pc,
+int Disassembler::Decode(Isolate* isolate, std::ostream& os, uint8_t* begin,
+                         uint8_t* end, CodeReference code, Address current_pc,
                          size_t range_limit) {
   return 0;
 }
diff --git a/src/diagnostics/disassembler.h b/src/diagnostics/disassembler.h
index 82ce496eef..560d2d4814 100644
--- a/src/diagnostics/disassembler.h
+++ b/src/diagnostics/disassembler.h
@@ -21,7 +21,7 @@ class Disassembler : public AllStatic {
   // the code object is used for name resolution and may be null.
   // TODO(titzer): accept a {WasmCodeManager*} if {isolate} is null
   V8_EXPORT_PRIVATE static int Decode(Isolate* isolate, std::ostream& os,
-                                      byte* begin, byte* end,
+                                      uint8_t* begin, uint8_t* end,
                                       CodeReference code = {},
                                       Address current_pc = kNullAddress,
                                       size_t range_limit = 0);
diff --git a/src/diagnostics/eh-frame.cc b/src/diagnostics/eh-frame.cc
index 223e288e6e..ff249c2da7 100644
--- a/src/diagnostics/eh-frame.cc
+++ b/src/diagnostics/eh-frame.cc
@@ -90,7 +90,7 @@ void EhFrameWriter::WriteCie() {
   static const int kCIEIdentifier = 0;
   static const int kCIEVersion = 3;
   static const int kAugmentationDataSize = 2;
-  static const byte kAugmentationString[] = {'z', 'L', 'R', 0};
+  static const uint8_t kAugmentationString[] = {'z', 'L', 'R', 0};
 
   // Placeholder for the size of the CIE.
   int size_offset = eh_frame_offset();
@@ -242,8 +242,8 @@ void EhFrameWriter::WritePaddingToAlignedSize(int unpadded_size) {
 
   int padding_size = RoundUp(unpadded_size, kSystemPointerSize) - unpadded_size;
 
-  byte nop = static_cast<byte>(EhFrameConstants::DwarfOpcodes::kNop);
-  static const byte kPadding[] = {nop, nop, nop, nop, nop, nop, nop, nop};
+  uint8_t nop = static_cast<uint8_t>(EhFrameConstants::DwarfOpcodes::kNop);
+  static const uint8_t kPadding[] = {nop, nop, nop, nop, nop, nop, nop, nop};
   DCHECK_LE(padding_size, static_cast<int>(sizeof(kPadding)));
   WriteBytes(&kPadding[0], padding_size);
 }
@@ -364,7 +364,8 @@ void EhFrameWriter::Finish(int code_size) {
   PatchInt32(GetProcedureSizeOffset(), code_size);
 
   // Terminate the .eh_frame.
-  static const byte kTerminator[EhFrameConstants::kEhFrameTerminatorSize] = {0};
+  static const uint8_t kTerminator[EhFrameConstants::kEhFrameTerminatorSize] = {
+      0};
   WriteBytes(&kTerminator[0], EhFrameConstants::kEhFrameTerminatorSize);
 
   WriteEhFrameHdr(code_size);
@@ -380,7 +381,7 @@ void EhFrameWriter::GetEhFrame(CodeDesc* desc) {
 
 void EhFrameWriter::WriteULeb128(uint32_t value) {
   do {
-    byte chunk = value & 0x7F;
+    uint8_t chunk = value & 0x7F;
     value >>= 7;
     if (value != 0) chunk |= 0x80;
     WriteByte(chunk);
@@ -391,7 +392,7 @@ void EhFrameWriter::WriteSLeb128(int32_t value) {
   static const int kSignBitMask = 0x40;
   bool done;
   do {
-    byte chunk = value & 0x7F;
+    uint8_t chunk = value & 0x7F;
     value >>= 7;
     done = ((value == 0) && ((chunk & kSignBitMask) == 0)) ||
            ((value == -1) && ((chunk & kSignBitMask) != 0));
@@ -417,9 +418,9 @@ int32_t EhFrameIterator::GetNextSLeb128() {
 }
 
 // static
-uint32_t EhFrameIterator::DecodeULeb128(const byte* encoded,
+uint32_t EhFrameIterator::DecodeULeb128(const uint8_t* encoded,
                                         int* encoded_size) {
-  const byte* current = encoded;
+  const uint8_t* current = encoded;
   uint32_t result = 0;
   int shift = 0;
 
@@ -436,13 +437,14 @@ uint32_t EhFrameIterator::DecodeULeb128(const byte* encoded,
 }
 
 // static
-int32_t EhFrameIterator::DecodeSLeb128(const byte* encoded, int* encoded_size) {
-  static const byte kSignBitMask = 0x40;
+int32_t EhFrameIterator::DecodeSLeb128(const uint8_t* encoded,
+                                       int* encoded_size) {
+  static const uint8_t kSignBitMask = 0x40;
 
-  const byte* current = encoded;
+  const uint8_t* current = encoded;
   int32_t result = 0;
   int shift = 0;
-  byte chunk;
+  uint8_t chunk;
 
   do {
     chunk = *current++;
@@ -479,8 +481,8 @@ class V8_NODISCARD StreamModifiersScope final {
 
 // static
 void EhFrameDisassembler::DumpDwarfDirectives(std::ostream& stream,
-                                              const byte* start,
-                                              const byte* end) {
+                                              const uint8_t* start,
+                                              const uint8_t* end) {
   StreamModifiersScope modifiers_scope(&stream);
 
   EhFrameIterator eh_frame_iterator(start, end);
@@ -489,7 +491,7 @@ void EhFrameDisassembler::DumpDwarfDirectives(std::ostream& stream,
   while (!eh_frame_iterator.Done()) {
     stream << eh_frame_iterator.current_address() << "  ";
 
-    byte bytecode = eh_frame_iterator.GetNextByte();
+    uint8_t bytecode = eh_frame_iterator.GetNextByte();
 
     if (((bytecode >> EhFrameConstants::kLocationMaskSize) & 0xFF) ==
         EhFrameConstants::kLocationTag) {
@@ -596,9 +598,9 @@ void EhFrameDisassembler::DisassembleToStream(std::ostream& stream) {
       kInt32Size;
   const int fde_offset = cie_size;
 
-  const byte* cie_directives_start =
+  const uint8_t* cie_directives_start =
       start_ + EhFrameConstants::kInitialStateOffsetInCie;
-  const byte* cie_directives_end = start_ + cie_size;
+  const uint8_t* cie_directives_end = start_ + cie_size;
   DCHECK_LE(cie_directives_start, cie_directives_end);
 
   stream << reinterpret_cast<const void*>(start_) << "  .eh_frame: CIE\n";
@@ -616,7 +618,7 @@ void EhFrameDisassembler::DisassembleToStream(std::ostream& stream) {
   uint32_t procedure_size =
       base::ReadUnalignedValue<uint32_t>(procedure_size_address);
 
-  const byte* fde_start = start_ + fde_offset;
+  const uint8_t* fde_start = start_ + fde_offset;
   stream << reinterpret_cast<const void*>(fde_start) << "  .eh_frame: FDE\n"
          << reinterpret_cast<const void*>(procedure_offset_address)
          << "  | procedure_offset=" << procedure_offset << '\n'
@@ -625,18 +627,18 @@ void EhFrameDisassembler::DisassembleToStream(std::ostream& stream) {
 
   const int fde_directives_offset = fde_offset + 4 * kInt32Size + 1;
 
-  const byte* fde_directives_start = start_ + fde_directives_offset;
-  const byte* fde_directives_end = end_ - EhFrameConstants::kEhFrameHdrSize -
-                                   EhFrameConstants::kEhFrameTerminatorSize;
+  const uint8_t* fde_directives_start = start_ + fde_directives_offset;
+  const uint8_t* fde_directives_end = end_ - EhFrameConstants::kEhFrameHdrSize -
+                                      EhFrameConstants::kEhFrameTerminatorSize;
   DCHECK_LE(fde_directives_start, fde_directives_end);
 
   DumpDwarfDirectives(stream, fde_directives_start, fde_directives_end);
 
-  const byte* fde_terminator_start = fde_directives_end;
+  const uint8_t* fde_terminator_start = fde_directives_end;
   stream << reinterpret_cast<const void*>(fde_terminator_start)
          << "  .eh_frame: terminator\n";
 
-  const byte* eh_frame_hdr_start =
+  const uint8_t* eh_frame_hdr_start =
       fde_terminator_start + EhFrameConstants::kEhFrameTerminatorSize;
   stream << reinterpret_cast<const void*>(eh_frame_hdr_start)
          << "  .eh_frame_hdr\n";
diff --git a/src/diagnostics/eh-frame.h b/src/diagnostics/eh-frame.h
index 3cd3318f69..10a1daa5f2 100644
--- a/src/diagnostics/eh-frame.h
+++ b/src/diagnostics/eh-frame.h
@@ -19,7 +19,7 @@ class CodeDesc;
 class V8_EXPORT_PRIVATE EhFrameConstants final
     : public NON_EXPORTED_BASE(AllStatic) {
  public:
-  enum class DwarfOpcodes : byte {
+  enum class DwarfOpcodes : uint8_t {
     kNop = 0x00,
     kAdvanceLoc1 = 0x02,
     kAdvanceLoc2 = 0x03,
@@ -32,7 +32,7 @@ class V8_EXPORT_PRIVATE EhFrameConstants final
     kOffsetExtendedSf = 0x11,
   };
 
-  enum DwarfEncodingSpecifiers : byte {
+  enum DwarfEncodingSpecifiers : uint8_t {
     kUData4 = 0x03,
     kSData4 = 0x0b,
     kPcRel = 0x10,
@@ -138,18 +138,18 @@ class V8_EXPORT_PRIVATE EhFrameWriter {
   void WriteSLeb128(int32_t value);
   void WriteULeb128(uint32_t value);
 
-  void WriteByte(byte value) { eh_frame_buffer_.push_back(value); }
+  void WriteByte(uint8_t value) { eh_frame_buffer_.push_back(value); }
   void WriteOpcode(EhFrameConstants::DwarfOpcodes opcode) {
-    WriteByte(static_cast<byte>(opcode));
+    WriteByte(static_cast<uint8_t>(opcode));
   }
-  void WriteBytes(const byte* start, int size) {
+  void WriteBytes(const uint8_t* start, int size) {
     eh_frame_buffer_.insert(eh_frame_buffer_.end(), start, start + size);
   }
   void WriteInt16(uint16_t value) {
-    WriteBytes(reinterpret_cast<const byte*>(&value), sizeof(value));
+    WriteBytes(reinterpret_cast<const uint8_t*>(&value), sizeof(value));
   }
   void WriteInt32(uint32_t value) {
-    WriteBytes(reinterpret_cast<const byte*>(&value), sizeof(value));
+    WriteBytes(reinterpret_cast<const uint8_t*>(&value), sizeof(value));
   }
   void PatchInt32(int base_offset, uint32_t value) {
     DCHECK_EQ(
@@ -207,12 +207,12 @@ class V8_EXPORT_PRIVATE EhFrameWriter {
   InternalState writer_state_;
   Register base_register_;
   int base_offset_;
-  ZoneVector<byte> eh_frame_buffer_;
+  ZoneVector<uint8_t> eh_frame_buffer_;
 };
 
 class V8_EXPORT_PRIVATE EhFrameIterator {
  public:
-  EhFrameIterator(const byte* start, const byte* end)
+  EhFrameIterator(const uint8_t* start, const uint8_t* end)
       : start_(start), next_(start), end_(end) {
     DCHECK_LE(start, end);
   }
@@ -238,7 +238,7 @@ class V8_EXPORT_PRIVATE EhFrameIterator {
 
   uint32_t GetNextUInt32() { return GetNextValue<uint32_t>(); }
   uint16_t GetNextUInt16() { return GetNextValue<uint16_t>(); }
-  byte GetNextByte() { return GetNextValue<byte>(); }
+  uint8_t GetNextByte() { return GetNextValue<uint8_t>(); }
   EhFrameConstants::DwarfOpcodes GetNextOpcode() {
     return static_cast<EhFrameConstants::DwarfOpcodes>(GetNextByte());
   }
@@ -265,8 +265,8 @@ class V8_EXPORT_PRIVATE EhFrameIterator {
  private:
   static const int kDirectivesOffsetInFde = 4 * kInt32Size + 1;
 
-  static uint32_t DecodeULeb128(const byte* encoded, int* encoded_size);
-  static int32_t DecodeSLeb128(const byte* encoded, int* encoded_size);
+  static uint32_t DecodeULeb128(const uint8_t* encoded, int* encoded_size);
+  static int32_t DecodeSLeb128(const uint8_t* encoded, int* encoded_size);
 
   template <typename T>
   T GetNextValue() {
@@ -277,16 +277,16 @@ class V8_EXPORT_PRIVATE EhFrameIterator {
     return result;
   }
 
-  const byte* start_;
-  const byte* next_;
-  const byte* end_;
+  const uint8_t* start_;
+  const uint8_t* next_;
+  const uint8_t* end_;
 };
 
 #ifdef ENABLE_DISASSEMBLER
 
 class EhFrameDisassembler final {
  public:
-  EhFrameDisassembler(const byte* start, const byte* end)
+  EhFrameDisassembler(const uint8_t* start, const uint8_t* end)
       : start_(start), end_(end) {
     DCHECK_LT(start, end);
   }
@@ -296,13 +296,13 @@ class EhFrameDisassembler final {
   void DisassembleToStream(std::ostream& stream);
 
  private:
-  static void DumpDwarfDirectives(std::ostream& stream, const byte* start,
-                                  const byte* end);
+  static void DumpDwarfDirectives(std::ostream& stream, const uint8_t* start,
+                                  const uint8_t* end);
 
   static const char* DwarfRegisterCodeToString(int code);
 
-  const byte* start_;
-  const byte* end_;
+  const uint8_t* start_;
+  const uint8_t* end_;
 };
 
 #endif
diff --git a/src/diagnostics/gdb-jit.cc b/src/diagnostics/gdb-jit.cc
index 83d69ae72d..9a3f526af4 100644
--- a/src/diagnostics/gdb-jit.cc
+++ b/src/diagnostics/gdb-jit.cc
@@ -54,7 +54,7 @@ class Writer {
       : debug_object_(debug_object),
         position_(0),
         capacity_(1024),
-        buffer_(reinterpret_cast<byte*>(base::Malloc(capacity_))) {}
+        buffer_(reinterpret_cast<uint8_t*>(base::Malloc(capacity_))) {}
 
   ~Writer() { base::Free(buffer_); }
 
@@ -107,13 +107,13 @@ class Writer {
   void Ensure(uintptr_t pos) {
     if (capacity_ < pos) {
       while (capacity_ < pos) capacity_ *= 2;
-      buffer_ = reinterpret_cast<byte*>(base::Realloc(buffer_, capacity_));
+      buffer_ = reinterpret_cast<uint8_t*>(base::Realloc(buffer_, capacity_));
     }
   }
 
   DebugObject* debug_object() { return debug_object_; }
 
-  byte* buffer() { return buffer_; }
+  uint8_t* buffer() { return buffer_; }
 
   void Align(uintptr_t align) {
     uintptr_t delta = position_ % align;
@@ -174,7 +174,7 @@ class Writer {
   DebugObject* debug_object_;
   uintptr_t position_;
   uintptr_t capacity_;
-  byte* buffer_;
+  uint8_t* buffer_;
 };
 
 class ELFStringTable;
@@ -1993,7 +1993,7 @@ static void AddJITCodeEntry(CodeMap* map, const base::AddressRegion region,
     SNPrintF(base::Vector<char>(file_name, kMaxFileNameSize),
              "/tmp/elfdump%s%d.o", (name_hint != nullptr) ? name_hint : "",
              file_num++);
-    WriteBytes(file_name, reinterpret_cast<byte*>(entry->symfile_addr_),
+    WriteBytes(file_name, reinterpret_cast<uint8_t*>(entry->symfile_addr_),
                static_cast<int>(entry->symfile_size_));
   }
 #endif
diff --git a/src/diagnostics/ia32/disasm-ia32.cc b/src/diagnostics/ia32/disasm-ia32.cc
index 5f19dd03e0..92929b0917 100644
--- a/src/diagnostics/ia32/disasm-ia32.cc
+++ b/src/diagnostics/ia32/disasm-ia32.cc
@@ -115,7 +115,7 @@ struct InstructionDesc {
 class InstructionTable {
  public:
   InstructionTable();
-  const InstructionDesc& Get(byte x) const { return instructions_[x]; }
+  const InstructionDesc& Get(uint8_t x) const { return instructions_[x]; }
   static InstructionTable* get_instance() {
     static InstructionTable table;
     return &table;
@@ -126,7 +126,7 @@ class InstructionTable {
   void Clear();
   void Init();
   void CopyTable(const ByteMnemonic bm[], InstructionType type);
-  void SetTableRange(InstructionType type, byte start, byte end,
+  void SetTableRange(InstructionType type, uint8_t start, uint8_t end,
                      const char* mnem);
   void AddJumpConditionalShort();
 };
@@ -170,9 +170,9 @@ void InstructionTable::CopyTable(const ByteMnemonic bm[],
   }
 }
 
-void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
-                                     const char* mnem) {
-  for (byte b = start; b <= end; b++) {
+void InstructionTable::SetTableRange(InstructionType type, uint8_t start,
+                                     uint8_t end, const char* mnem) {
+  for (uint8_t b = start; b <= end; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered.
     id->mnem = mnem;
@@ -181,7 +181,7 @@ void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
 }
 
 void InstructionTable::AddJumpConditionalShort() {
-  for (byte b = 0x70; b <= 0x7F; b++) {
+  for (uint8_t b = 0x70; b <= 0x7F; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered.
     id->mnem = jump_conditional_mnem[b & 0x0F];
@@ -227,13 +227,13 @@ class DisassemblerIA32 {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(v8::base::Vector<char> buffer, byte* instruction);
+  int InstructionDecode(v8::base::Vector<char> buffer, uint8_t* instruction);
 
  private:
   const NameConverter& converter_;
-  byte vex_byte0_;  // 0xC4 or 0xC5
-  byte vex_byte1_;
-  byte vex_byte2_;  // only for 3 bytes vex prefix
+  uint8_t vex_byte0_;  // 0xC4 or 0xC5
+  uint8_t vex_byte1_;
+  uint8_t vex_byte2_;  // only for 3 bytes vex prefix
   InstructionTable* instruction_table_;
   v8::base::EmbeddedVector<char, 128> tmp_buffer_;
   unsigned int tmp_buffer_pos_;
@@ -262,31 +262,31 @@ class DisassemblerIA32 {
 
   bool vex_128() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 4) == 0;
   }
 
   bool vex_none() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 0;
   }
 
   bool vex_66() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 1;
   }
 
   bool vex_f3() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 2;
   }
 
   bool vex_f2() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 3;
   }
 
@@ -312,7 +312,7 @@ class DisassemblerIA32 {
 
   int vex_vreg() {
     DCHECK(vex_byte0_ == 0xC4 || vex_byte0_ == 0xC5);
-    byte checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == 0xC4 ? vex_byte2_ : vex_byte1_;
     return ~(checked >> 3) & 0xF;
   }
 
@@ -330,18 +330,18 @@ class DisassemblerIA32 {
     return converter_.NameOfXMMRegister(reg);
   }
 
-  const char* NameOfAddress(byte* addr) const {
+  const char* NameOfAddress(uint8_t* addr) const {
     return converter_.NameOfAddress(addr);
   }
 
   // Disassembler helper functions.
-  static void get_modrm(byte data, int* mod, int* regop, int* rm) {
+  static void get_modrm(uint8_t data, int* mod, int* regop, int* rm) {
     *mod = (data >> 6) & 3;
     *regop = (data & 0x38) >> 3;
     *rm = data & 7;
   }
 
-  static void get_sib(byte data, int* scale, int* index, int* base) {
+  static void get_sib(uint8_t data, int* scale, int* index, int* base) {
     *scale = (data >> 6) & 3;
     *index = (data >> 3) & 7;
     *base = data & 7;
@@ -349,23 +349,24 @@ class DisassemblerIA32 {
 
   using RegisterNameMapping = const char* (DisassemblerIA32::*)(int reg) const;
 
-  int PrintRightOperandHelper(byte* modrmp, RegisterNameMapping register_name);
-  int PrintRightOperand(byte* modrmp);
-  int PrintRightByteOperand(byte* modrmp);
-  int PrintRightXMMOperand(byte* modrmp);
-  int PrintOperands(const char* mnem, OperandOrder op_order, byte* data);
-  int PrintImmediateOp(byte* data);
-  int F7Instruction(byte* data);
-  int D1D3C1Instruction(byte* data);
-  int JumpShort(byte* data);
-  int JumpConditional(byte* data, const char* comment);
-  int JumpConditionalShort(byte* data, const char* comment);
-  int SetCC(byte* data);
-  int CMov(byte* data);
-  int FPUInstruction(byte* data);
-  int MemoryFPUInstruction(int escape_opcode, int regop, byte* modrm_start);
-  int RegisterFPUInstruction(int escape_opcode, byte modrm_byte);
-  int AVXInstruction(byte* data);
+  int PrintRightOperandHelper(uint8_t* modrmp,
+                              RegisterNameMapping register_name);
+  int PrintRightOperand(uint8_t* modrmp);
+  int PrintRightByteOperand(uint8_t* modrmp);
+  int PrintRightXMMOperand(uint8_t* modrmp);
+  int PrintOperands(const char* mnem, OperandOrder op_order, uint8_t* data);
+  int PrintImmediateOp(uint8_t* data);
+  int F7Instruction(uint8_t* data);
+  int D1D3C1Instruction(uint8_t* data);
+  int JumpShort(uint8_t* data);
+  int JumpConditional(uint8_t* data, const char* comment);
+  int JumpConditionalShort(uint8_t* data, const char* comment);
+  int SetCC(uint8_t* data);
+  int CMov(uint8_t* data);
+  int FPUInstruction(uint8_t* data);
+  int MemoryFPUInstruction(int escape_opcode, int regop, uint8_t* modrm_start);
+  int RegisterFPUInstruction(int escape_opcode, uint8_t modrm_byte);
+  int AVXInstruction(uint8_t* data);
   PRINTF_FORMAT(2, 3) void AppendToBuffer(const char* format, ...);
 
   void UnimplementedInstruction() {
@@ -388,7 +389,7 @@ void DisassemblerIA32::AppendToBuffer(const char* format, ...) {
 }
 
 int DisassemblerIA32::PrintRightOperandHelper(
-    byte* modrmp, RegisterNameMapping direct_register_name) {
+    uint8_t* modrmp, RegisterNameMapping direct_register_name) {
   int mod, regop, rm;
   get_modrm(*modrmp, &mod, &regop, &rm);
   RegisterNameMapping register_name =
@@ -399,7 +400,7 @@ int DisassemblerIA32::PrintRightOperandHelper(
         AppendToBuffer("[0x%x]", Imm32(modrmp + 1));
         return 5;
       } else if (rm == esp) {
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         if (index == esp && base == esp && scale == 0 /*times_1*/) {
@@ -426,7 +427,7 @@ int DisassemblerIA32::PrintRightOperandHelper(
     case 1:  // fall through
     case 2: {
       if (rm == esp) {
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         int disp = mod == 2 ? Imm32(modrmp + 2) : Imm8(modrmp + 2);
@@ -456,24 +457,24 @@ int DisassemblerIA32::PrintRightOperandHelper(
   UNREACHABLE();
 }
 
-int DisassemblerIA32::PrintRightOperand(byte* modrmp) {
+int DisassemblerIA32::PrintRightOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerIA32::NameOfCPURegister);
 }
 
-int DisassemblerIA32::PrintRightByteOperand(byte* modrmp) {
+int DisassemblerIA32::PrintRightByteOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp,
                                  &DisassemblerIA32::NameOfByteCPURegister);
 }
 
-int DisassemblerIA32::PrintRightXMMOperand(byte* modrmp) {
+int DisassemblerIA32::PrintRightXMMOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerIA32::NameOfXMMRegister);
 }
 
 // Returns number of bytes used including the current *data.
 // Writes instruction's mnemonic, left and right operands to 'tmp_buffer_'.
 int DisassemblerIA32::PrintOperands(const char* mnem, OperandOrder op_order,
-                                    byte* data) {
-  byte modrm = *data;
+                                    uint8_t* data) {
+  uint8_t modrm = *data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   int advance = 0;
@@ -497,9 +498,9 @@ int DisassemblerIA32::PrintOperands(const char* mnem, OperandOrder op_order,
 
 // Returns number of bytes used by machine instruction, including *data byte.
 // Writes immediate instructions to 'tmp_buffer_'.
-int DisassemblerIA32::PrintImmediateOp(byte* data) {
+int DisassemblerIA32::PrintImmediateOp(uint8_t* data) {
   bool sign_extension_bit = (*data & 0x02) != 0;
-  byte modrm = *(data + 1);
+  uint8_t modrm = *(data + 1);
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   const char* mnem = "Imm???";
@@ -540,9 +541,9 @@ int DisassemblerIA32::PrintImmediateOp(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::F7Instruction(byte* data) {
+int DisassemblerIA32::F7Instruction(uint8_t* data) {
   DCHECK_EQ(0xF7, *data);
-  byte modrm = *++data;
+  uint8_t modrm = *++data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   const char* mnem = "";
@@ -580,10 +581,10 @@ int DisassemblerIA32::F7Instruction(byte* data) {
   return 1 + count;
 }
 
-int DisassemblerIA32::D1D3C1Instruction(byte* data) {
-  byte op = *data;
+int DisassemblerIA32::D1D3C1Instruction(uint8_t* data) {
+  uint8_t op = *data;
   DCHECK(op == 0xD1 || op == 0xD3 || op == 0xC1);
-  byte modrm = *++data;
+  uint8_t modrm = *++data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   int imm8 = -1;
@@ -632,19 +633,19 @@ int DisassemblerIA32::D1D3C1Instruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::JumpShort(byte* data) {
+int DisassemblerIA32::JumpShort(uint8_t* data) {
   DCHECK_EQ(0xEB, *data);
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   AppendToBuffer("jmp %s", NameOfAddress(dest));
   return 2;
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::JumpConditional(byte* data, const char* comment) {
+int DisassemblerIA32::JumpConditional(uint8_t* data, const char* comment) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
-  byte* dest = data + Imm32(data + 2) + 6;
+  uint8_t cond = *(data + 1) & 0x0F;
+  uint8_t* dest = data + Imm32(data + 2) + 6;
   const char* mnem = jump_conditional_mnem[cond];
   AppendToBuffer("%s %s", mnem, NameOfAddress(dest));
   if (comment != nullptr) {
@@ -654,10 +655,10 @@ int DisassemblerIA32::JumpConditional(byte* data, const char* comment) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::JumpConditionalShort(byte* data, const char* comment) {
-  byte cond = *data & 0x0F;
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+int DisassemblerIA32::JumpConditionalShort(uint8_t* data, const char* comment) {
+  uint8_t cond = *data & 0x0F;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   const char* mnem = jump_conditional_mnem[cond];
   AppendToBuffer("%s %s", mnem, NameOfAddress(dest));
   if (comment != nullptr) {
@@ -667,9 +668,9 @@ int DisassemblerIA32::JumpConditionalShort(byte* data, const char* comment) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::SetCC(byte* data) {
+int DisassemblerIA32::SetCC(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
+  uint8_t cond = *(data + 1) & 0x0F;
   const char* mnem = set_conditional_mnem[cond];
   AppendToBuffer("%s ", mnem);
   PrintRightByteOperand(data + 2);
@@ -677,9 +678,9 @@ int DisassemblerIA32::SetCC(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::CMov(byte* data) {
+int DisassemblerIA32::CMov(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
+  uint8_t cond = *(data + 1) & 0x0F;
   const char* mnem = conditional_move_mnem[cond];
   int op_size = PrintOperands(mnem, REG_OPER_OP_ORDER, data + 2);
   return 2 + op_size;  // includes 0x0F
@@ -687,9 +688,9 @@ int DisassemblerIA32::CMov(byte* data) {
 
 const char* sf_str[4] = {"", "rl", "ra", "ll"};
 
-int DisassemblerIA32::AVXInstruction(byte* data) {
-  byte opcode = *data;
-  byte* current = data + 1;
+int DisassemblerIA32::AVXInstruction(uint8_t* data) {
+  uint8_t opcode = *data;
+  uint8_t* current = data + 1;
   if (vex_66() && vex_0f38()) {
     int mod, regop, rm, vvvv = vex_vreg();
     get_modrm(*current, &mod, &regop, &rm);
@@ -1406,10 +1407,10 @@ int DisassemblerIA32::AVXInstruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerIA32::FPUInstruction(byte* data) {
-  byte escape_opcode = *data;
+int DisassemblerIA32::FPUInstruction(uint8_t* data) {
+  uint8_t escape_opcode = *data;
   DCHECK_EQ(0xD8, escape_opcode & 0xF8);
-  byte modrm_byte = *(data + 1);
+  uint8_t modrm_byte = *(data + 1);
 
   if (modrm_byte >= 0xC0) {
     return RegisterFPUInstruction(escape_opcode, modrm_byte);
@@ -1419,7 +1420,7 @@ int DisassemblerIA32::FPUInstruction(byte* data) {
 }
 
 int DisassemblerIA32::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
-                                           byte* modrm_start) {
+                                           uint8_t* modrm_start) {
   const char* mnem = "?";
   int regop = (modrm_byte >> 3) & 0x7;  // reg/op field of modrm byte.
   switch (escape_opcode) {
@@ -1502,7 +1503,7 @@ int DisassemblerIA32::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
 }
 
 int DisassemblerIA32::RegisterFPUInstruction(int escape_opcode,
-                                             byte modrm_byte) {
+                                             uint8_t modrm_byte) {
   bool has_register = false;  // Is the FPU register encoded in modrm_byte?
   const char* mnem = "?";
 
@@ -1701,7 +1702,7 @@ int DisassemblerIA32::RegisterFPUInstruction(int escape_opcode,
 
 // Mnemonics for instructions 0xF0 byte.
 // Returns nullptr if the instruction is not handled here.
-static const char* F0Mnem(byte f0byte) {
+static const char* F0Mnem(uint8_t f0byte) {
   switch (f0byte) {
     case 0x0B:
       return "ud2";
@@ -1746,9 +1747,9 @@ static const char* F0Mnem(byte f0byte) {
 
 // Disassembled instruction '*instr' and writes it into 'out_buffer'.
 int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
-                                        byte* instr) {
+                                        uint8_t* instr) {
   tmp_buffer_pos_ = 0;  // starting to write as position 0
-  byte* data = instr;
+  uint8_t* data = instr;
   // Check for hints.
   const char* branch_hint = nullptr;
   // We use these two prefixes only with branch prediction
@@ -1800,7 +1801,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
         break;
 
       case MOVE_REG_INSTR: {
-        byte* addr = reinterpret_cast<byte*>(Imm32(data + 1));
+        uint8_t* addr = reinterpret_cast<uint8_t*>(Imm32(data + 1));
         AppendToBuffer("mov %s,%s", NameOfCPURegister(*data & 0x07),
                        NameOfAddress(addr));
         data += 5;
@@ -1808,14 +1809,14 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
       }
 
       case CALL_JUMP_INSTR: {
-        byte* addr = data + Imm32(data + 1) + 5;
+        uint8_t* addr = data + Imm32(data + 1) + 5;
         AppendToBuffer("%s %s", idesc.mnem, NameOfAddress(addr));
         data += 5;
         break;
       }
 
       case SHORT_IMMEDIATE_INSTR: {
-        byte* addr = reinterpret_cast<byte*>(Imm32(data + 1));
+        uint8_t* addr = reinterpret_cast<uint8_t*>(Imm32(data + 1));
         AppendToBuffer("%s eax,%s", idesc.mnem, NameOfAddress(addr));
         data += 5;
         break;
@@ -1878,7 +1879,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
         break;
 
       case 0x0F: {
-        byte f0byte = data[1];
+        uint8_t f0byte = data[1];
         const char* f0mnem = F0Mnem(f0byte);
         int mod, regop, rm;
         // Not every instruction use this, and it is safe to index data+2 as all
@@ -2220,7 +2221,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
             data += PrintRightXMMOperand(data);
           } else if (*data == 0x38) {
             data++;
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2268,7 +2269,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
                   "roundss",
                   "roundsd",
               };
-              byte op = *data;
+              uint8_t op = *data;
               data++;
               int mod, regop, rm;
               get_modrm(*data, &mod, &regop, &rm);
@@ -2376,7 +2377,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
             const char* const pseudo_op[] = {"andpd",   "andnpd", "orpd",
                                              "xorpd",   "addpd",  "mulpd",
                                              "cvtpd2ps"};
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2390,7 +2391,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
                 "divpd",
                 "maxpd",
             };
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2514,7 +2515,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
                            NameOfXMMRegister(rm));
             data++;
           } else {
-            byte op = *data;
+            uint8_t op = *data;
             data++;
             int mod, regop, rm;
             get_modrm(*data, &mod, &regop, &rm);
@@ -2592,7 +2593,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
 
       case 0xF2:
         if (*(data + 1) == 0x0F) {
-          byte b2 = *(data + 2);
+          uint8_t b2 = *(data + 2);
           if (b2 == 0x11) {
             AppendToBuffer("movsd ");
             data += 3;
@@ -2675,7 +2676,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
 
       case 0xF3:
         if (*(data + 1) == 0x0F) {
-          byte b2 = *(data + 2);
+          uint8_t b2 = *(data + 2);
           if (b2 == 0x11) {
             AppendToBuffer("movss ");
             data += 3;
@@ -2841,7 +2842,7 @@ int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
 
   int outp = 0;
   // Instruction bytes.
-  for (byte* bp = instr; bp < data; bp++) {
+  for (uint8_t* bp = instr; bp < data; bp++) {
     outp += v8::base::SNPrintF(out_buffer + outp, "%02x", *bp);
   }
   // Indent instruction, leaving space for 6 bytes, i.e. 12 characters in hex.
@@ -2864,12 +2865,12 @@ static const char* const byte_cpu_regs[8] = {"al", "cl", "dl", "bl",
 static const char* const xmm_regs[8] = {"xmm0", "xmm1", "xmm2", "xmm3",
                                         "xmm4", "xmm5", "xmm6", "xmm7"};
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -2888,7 +2889,7 @@ const char* NameConverter::NameOfXMMRegister(int reg) const {
   return "noxmmreg";
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // IA32 does not embed debug strings at the moment.
   UNREACHABLE();
 }
@@ -2896,28 +2897,28 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   DisassemblerIA32 d(converter_, unimplemented_opcode_action());
   return d.InstructionDecode(buffer, instruction);
 }
 
 // The IA-32 assembler does not currently use constant pools.
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
 // static
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     fprintf(f, "%p", static_cast<void*>(prev_pc));
     fprintf(f, "    ");
 
-    for (byte* bp = prev_pc; bp < pc; bp++) {
+    for (uint8_t* bp = prev_pc; bp < pc; bp++) {
       fprintf(f, "%02x", *bp);
     }
     for (int i = 6 - (pc - prev_pc); i >= 0; i--) {
diff --git a/src/diagnostics/loong64/disasm-loong64.cc b/src/diagnostics/loong64/disasm-loong64.cc
index 9d8aee96a3..ed036ee54a 100644
--- a/src/diagnostics/loong64/disasm-loong64.cc
+++ b/src/diagnostics/loong64/disasm-loong64.cc
@@ -39,7 +39,7 @@ class Decoder {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(byte* instruction);
+  int InstructionDecode(uint8_t* instruction);
 
  private:
   // Bottleneck functions to print into the out_buffer.
@@ -297,7 +297,7 @@ void Decoder::PrintPCOffs16(Instruction* instr) {
                (32 - kOffsLowBits - n_bits);
   out_buffer_pos_ += base::SNPrintF(
       out_buffer_ + out_buffer_pos_, "%s",
-      converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + target));
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + target));
 }
 
 void Decoder::PrintPCOffs21(Instruction* instr) {
@@ -308,7 +308,7 @@ void Decoder::PrintPCOffs21(Instruction* instr) {
       (32 - kOffsLowBits - kOffs21HighBits - n_bits);
   out_buffer_pos_ += base::SNPrintF(
       out_buffer_ + out_buffer_pos_, "%s",
-      converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + target));
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + target));
 }
 
 void Decoder::PrintPCOffs26(Instruction* instr) {
@@ -319,7 +319,7 @@ void Decoder::PrintPCOffs26(Instruction* instr) {
       (32 - kOffsLowBits - kOffs26HighBits - n_bits);
   out_buffer_pos_ += base::SNPrintF(
       out_buffer_ + out_buffer_pos_, "%s",
-      converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + target));
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + target));
 }
 
 void Decoder::PrintOffs16(Instruction* instr) {
@@ -1598,7 +1598,7 @@ void Decoder::DecodeTypekOp22(Instruction* instr) {
   }
 }
 
-int Decoder::InstructionDecode(byte* instr_ptr) {
+int Decoder::InstructionDecode(uint8_t* instr_ptr) {
   Instruction* instr = Instruction::At(instr_ptr);
   out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
                                     "%08x       ", instr->InstructionBits());
@@ -1653,12 +1653,12 @@ int Decoder::InstructionDecode(byte* instr_ptr) {
 
 namespace disasm {
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -1674,7 +1674,7 @@ const char* NameConverter::NameOfByteCPURegister(int reg) const {
   UNREACHABLE();
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // The default name converter is called for unknown code. So we will not try
   // to access any memory.
   return "";
@@ -1683,21 +1683,21 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
 }
 
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     v8::internal::PrintF(f, "%p    %08x      %s\n", static_cast<void*>(prev_pc),
                          *reinterpret_cast<int32_t*>(prev_pc), buffer.begin());
diff --git a/src/diagnostics/mips64/disasm-mips64.cc b/src/diagnostics/mips64/disasm-mips64.cc
index 0712431fc3..fa80ad2519 100644
--- a/src/diagnostics/mips64/disasm-mips64.cc
+++ b/src/diagnostics/mips64/disasm-mips64.cc
@@ -10,9 +10,9 @@
 //
 //   NameConverter converter;
 //   Disassembler d(converter);
-//   for (byte* pc = begin; pc < end;) {
+//   for (uint8_t* pc = begin; pc < end;) {
 //     v8::base::EmbeddedVector<char, 256> buffer;
-//     byte* prev_pc = pc;
+//     uint8_t* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
 //            prev_pc, *reinterpret_cast<int32_t*>(prev_pc), buffer);
@@ -59,7 +59,7 @@ class Decoder {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(byte* instruction);
+  int InstructionDecode(uint8_t* instruction);
 
  private:
   // Bottleneck functions to print into the out_buffer.
@@ -356,10 +356,10 @@ void Decoder::PrintXImm16(Instruction* instr) {
 //      PC + delta_pc + (offset << n_bits)
 void Decoder::PrintPCImm16(Instruction* instr, int delta_pc, int n_bits) {
   int16_t offset = instr->Imm16Value();
-  out_buffer_pos_ +=
-      base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s",
-                     converter_.NameOfAddress(reinterpret_cast<byte*>(instr) +
-                                              delta_pc + (offset << n_bits)));
+  out_buffer_pos_ += base::SNPrintF(
+      out_buffer_ + out_buffer_pos_, "%s",
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + delta_pc +
+                               (offset << n_bits)));
 }
 
 // Print 18-bit signed immediate value.
@@ -413,10 +413,10 @@ void Decoder::PrintPCImm21(Instruction* instr, int delta_pc, int n_bits) {
   // set sign
   imm21 <<= (32 - kImm21Bits);
   imm21 >>= (32 - kImm21Bits);
-  out_buffer_pos_ +=
-      base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s",
-                     converter_.NameOfAddress(reinterpret_cast<byte*>(instr) +
-                                              delta_pc + (imm21 << n_bits)));
+  out_buffer_pos_ += base::SNPrintF(
+      out_buffer_ + out_buffer_pos_, "%s",
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + delta_pc +
+                               (imm21 << n_bits)));
 }
 
 // Print 26-bit hex immediate value.
@@ -445,10 +445,10 @@ void Decoder::PrintPCImm26(Instruction* instr, int delta_pc, int n_bits) {
   // set sign
   imm26 <<= (32 - kImm26Bits);
   imm26 >>= (32 - kImm26Bits);
-  out_buffer_pos_ +=
-      base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s",
-                     converter_.NameOfAddress(reinterpret_cast<byte*>(instr) +
-                                              delta_pc + (imm26 << n_bits)));
+  out_buffer_pos_ += base::SNPrintF(
+      out_buffer_ + out_buffer_pos_, "%s",
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + delta_pc +
+                               (imm26 << n_bits)));
 }
 
 // Print absoulte address for 26-bit offset or immediate value.
@@ -458,9 +458,9 @@ void Decoder::PrintPCImm26(Instruction* instr) {
   int32_t imm26 = instr->Imm26Value();
   uint64_t pc_mask = ~0xFFFFFFF;
   uint64_t pc = ((uint64_t)(instr + 1) & pc_mask) | (imm26 << 2);
-  out_buffer_pos_ +=
-      base::SNPrintF(out_buffer_ + out_buffer_pos_, "%s",
-                     converter_.NameOfAddress((reinterpret_cast<byte*>(pc))));
+  out_buffer_pos_ += base::SNPrintF(
+      out_buffer_ + out_buffer_pos_, "%s",
+      converter_.NameOfAddress((reinterpret_cast<uint8_t*>(pc))));
 }
 
 void Decoder::PrintBp2(Instruction* instr) {
@@ -2934,7 +2934,7 @@ void Decoder::DecodeTypeMsa2RF(Instruction* instr) {
 // All instructions are one word long, except for the simulator
 // pseudo-instruction stop(msg). For that one special case, we return
 // size larger than one kInstrSize.
-int Decoder::InstructionDecode(byte* instr_ptr) {
+int Decoder::InstructionDecode(uint8_t* instr_ptr) {
   Instruction* instr = Instruction::At(instr_ptr);
   // Print raw instruction bytes.
   out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
@@ -2966,12 +2966,12 @@ int Decoder::InstructionDecode(byte* instr_ptr) {
 
 namespace disasm {
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -2987,7 +2987,7 @@ const char* NameConverter::NameOfByteCPURegister(int reg) const {
   UNREACHABLE();  // MIPS does not have the concept of a byte register.
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // The default name converter is called for unknown code. So we will not try
   // to access any memory.
   return "";
@@ -2996,22 +2996,22 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
 }
 
 // The MIPS assembler does not currently use constant pools.
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     v8::internal::PrintF(f, "%p    %08x      %s\n", static_cast<void*>(prev_pc),
                          *reinterpret_cast<int32_t*>(prev_pc), buffer.begin());
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index dee4607eef..ee5bf4c935 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -2154,7 +2154,7 @@ void WasmArray::WasmArrayPrint(std::ostream& os) {
 #else
         for (int j = kSimd128Size - 1; j >= 0; j--) {
 #endif
-          os << reinterpret_cast<byte*>(this->ElementAddress(i))[j];
+          os << reinterpret_cast<uint8_t*>(this->ElementAddress(i))[j];
         }
         os << std::dec;
       }
diff --git a/src/diagnostics/ppc/disasm-ppc.cc b/src/diagnostics/ppc/disasm-ppc.cc
index 88a14da017..1899f35614 100644
--- a/src/diagnostics/ppc/disasm-ppc.cc
+++ b/src/diagnostics/ppc/disasm-ppc.cc
@@ -10,9 +10,9 @@
 //
 //   NameConverter converter;
 //   Disassembler d(converter);
-//   for (byte* pc = begin; pc < end;) {
+//   for (uint8_t* pc = begin; pc < end;) {
 //     v8::base::EmbeddedVector<char, 256> buffer;
-//     byte* prev_pc = pc;
+//     uint8_t* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
 //            prev_pc, *reinterpret_cast<int32_t*>(prev_pc), buffer);
@@ -59,7 +59,7 @@ class Decoder {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(byte* instruction);
+  int InstructionDecode(uint8_t* instruction);
 
   // Prefixed instructions.
   enum PrefixType { not_prefixed, is_prefixed };
@@ -356,13 +356,13 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
         int off = ((instr->Bits(25, 2)) << 8) >> 6;
         out_buffer_pos_ += base::SNPrintF(
             out_buffer_ + out_buffer_pos_, "%+d -> %s", off,
-            converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + off));
+            converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + off));
         return 8;
       } else if ((format[6] == '1') && (format[7] == '6')) {
         int off = ((instr->Bits(15, 2)) << 18) >> 16;
         out_buffer_pos_ += base::SNPrintF(
             out_buffer_ + out_buffer_pos_, "%+d -> %s", off,
-            converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + off));
+            converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + off));
         return 8;
       }
       break;
@@ -1582,7 +1582,7 @@ void Decoder::DecodeExt6(Instruction* instr) {
 #undef VERIFY
 
 // Disassemble the instruction at *instr_ptr into the output buffer.
-int Decoder::InstructionDecode(byte* instr_ptr) {
+int Decoder::InstructionDecode(uint8_t* instr_ptr) {
   Instruction* instr = Instruction::At(instr_ptr);
 
   uint32_t opcode = instr->OpcodeValue() << 26;
@@ -1936,12 +1936,12 @@ int Decoder::InstructionDecode(byte* instr_ptr) {
 
 namespace disasm {
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -1957,7 +1957,7 @@ const char* NameConverter::NameOfXMMRegister(int reg) const {
   UNREACHABLE();  // PPC does not have any XMM registers
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // The default name converter is called for unknown code. So we will not try
   // to access any memory.
   return "";
@@ -1966,22 +1966,22 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
 }
 
 // The PPC assembler does not currently use constant pools.
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     v8::internal::PrintF(f, "%p    %08x      %s\n", static_cast<void*>(prev_pc),
                          *reinterpret_cast<int32_t*>(prev_pc), buffer.begin());
diff --git a/src/diagnostics/riscv/disasm-riscv.cc b/src/diagnostics/riscv/disasm-riscv.cc
index 801d774713..7419659ef0 100644
--- a/src/diagnostics/riscv/disasm-riscv.cc
+++ b/src/diagnostics/riscv/disasm-riscv.cc
@@ -10,9 +10,9 @@
 //
 //   NameConverter converter;
 //   Disassembler d(converter);
-//   for (byte* pc = begin; pc < end;) {
+//   for (uint8_t* pc = begin; pc < end;) {
 //     v8::base::EmbeddedVector<char, 256> buffer;
-//     byte* prev_pc = pc;
+//     uint8_t* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
 //            prev_pc, *reinterpret_cast<int32_t*>(prev_pc), buffer);
@@ -56,7 +56,7 @@ class Decoder {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(byte* instruction);
+  int InstructionDecode(uint8_t* instruction);
 
  private:
   // Bottleneck functions to print into the out_buffer.
@@ -264,7 +264,7 @@ void Decoder::PrintTarget(Instruction* instr) {
       int32_t imm = Assembler::BrachlongOffset((instr - 4)->InstructionBits(),
                                                instr->InstructionBits());
       const char* target =
-          converter_.NameOfAddress(reinterpret_cast<byte*>(instr - 4) + imm);
+          converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr - 4) + imm);
       out_buffer_pos_ +=
           base::SNPrintF(out_buffer_ + out_buffer_pos_, " -> %s", target);
       return;
@@ -275,7 +275,7 @@ void Decoder::PrintTarget(Instruction* instr) {
 void Decoder::PrintBranchOffset(Instruction* instr) {
   int32_t imm = instr->BranchOffset();
   const char* target =
-      converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + imm);
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + imm);
   out_buffer_pos_ +=
       base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d -> %s", imm, target);
 }
@@ -313,7 +313,7 @@ void Decoder::PrintImm20U(Instruction* instr) {
 void Decoder::PrintImm20J(Instruction* instr) {
   int32_t imm = instr->Imm20JValue();
   const char* target =
-      converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + imm);
+      converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + imm);
   out_buffer_pos_ +=
       base::SNPrintF(out_buffer_ + out_buffer_pos_, "%d -> %s", imm, target);
 }
@@ -2879,7 +2879,7 @@ void Decoder::DecodeRvvVS(Instruction* instr) {
 // All instructions are one word long, except for the simulator
 // pseudo-instruction stop(msg). For that one special case, we return
 // size larger than one kInstrSize.
-int Decoder::InstructionDecode(byte* instr_ptr) {
+int Decoder::InstructionDecode(uint8_t* instr_ptr) {
   Instruction* instr = Instruction::At(instr_ptr);
   // Print raw instruction bytes.
   out_buffer_pos_ += base::SNPrintF(out_buffer_ + out_buffer_pos_,
@@ -2952,12 +2952,12 @@ int Decoder::InstructionDecode(byte* instr_ptr) {
 
 namespace disasm {
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -2974,7 +2974,7 @@ const char* NameConverter::NameOfByteCPURegister(int reg) const {
   // return "nobytereg";
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // The default name converter is called for unknown code. So we will not try
   // to access any memory.
   return "";
@@ -2983,24 +2983,24 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
 }
 
-int Disassembler::ConstantPoolSizeAt(byte* instruction) {
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) {
   return v8::internal::Assembler::ConstantPoolSizeAt(
       reinterpret_cast<v8::internal::Instruction*>(instruction));
 }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     v8::internal::PrintF(f, "%p    %08x      %s\n", static_cast<void*>(prev_pc),
                          *reinterpret_cast<uint32_t*>(prev_pc), buffer.begin());
diff --git a/src/diagnostics/s390/disasm-s390.cc b/src/diagnostics/s390/disasm-s390.cc
index 97f0113d3b..8cfe039714 100644
--- a/src/diagnostics/s390/disasm-s390.cc
+++ b/src/diagnostics/s390/disasm-s390.cc
@@ -10,9 +10,9 @@
 //
 //   NameConverter converter;
 //   Disassembler d(converter);
-//   for (byte* pc = begin; pc < end;) {
+//   for (uint8_t* pc = begin; pc < end;) {
 //     v8::base::EmbeddedVector<char, 256> buffer;
-//     byte* prev_pc = pc;
+//     uint8_t* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
 //            prev_pc, *reinterpret_cast<int32_t*>(prev_pc), buffer);
@@ -59,7 +59,7 @@ class Decoder {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(byte* instruction);
+  int InstructionDecode(uint8_t* instruction);
 
  private:
   // Bottleneck functions to print into the out_buffer.
@@ -281,13 +281,13 @@ int Decoder::FormatOption(Instruction* instr, const char* format) {
         int off = ((instr->Bits(25, 2)) << 8) >> 6;
         out_buffer_pos_ += base::SNPrintF(
             out_buffer_ + out_buffer_pos_, "%+d -> %s", off,
-            converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + off));
+            converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + off));
         return 8;
       } else if ((format[6] == '1') && (format[7] == '6')) {
         int off = ((instr->Bits(15, 2)) << 18) >> 16;
         out_buffer_pos_ += base::SNPrintF(
             out_buffer_ + out_buffer_pos_, "%+d -> %s", off,
-            converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + off));
+            converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + off));
         return 8;
       }
       break;
@@ -411,7 +411,7 @@ int Decoder::FormatImmediate(Instruction* instr, const char* format) {
 
     out_buffer_pos_ += base::SNPrintF(
         out_buffer_ + out_buffer_pos_, "%d -> %s", value,
-        converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + value));
+        converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + value));
     return 2;
   } else if (format[1] == '5') {  // immediate in 16-31, but outputs as offset
     RILInstruction* rilinstr = reinterpret_cast<RILInstruction*>(instr);
@@ -423,7 +423,7 @@ int Decoder::FormatImmediate(Instruction* instr, const char* format) {
 
     out_buffer_pos_ += base::SNPrintF(
         out_buffer_ + out_buffer_pos_, "%d -> %s", value,
-        converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + value));
+        converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + value));
     return 2;
   } else if (format[1] == '6') {  // unsigned immediate in 16-31
     RIInstruction* riinstr = reinterpret_cast<RIInstruction*>(instr);
@@ -483,7 +483,7 @@ int Decoder::FormatImmediate(Instruction* instr, const char* format) {
 
     out_buffer_pos_ += base::SNPrintF(
         out_buffer_ + out_buffer_pos_, "%d -> %s", value,
-        converter_.NameOfAddress(reinterpret_cast<byte*>(instr) + value));
+        converter_.NameOfAddress(reinterpret_cast<uint8_t*>(instr) + value));
     return 2;
   }
 
@@ -1009,7 +1009,7 @@ bool Decoder::DecodeGeneric(Instruction* instr) {
 }
 
 // Disassemble the instruction at *instr_ptr into the output buffer.
-int Decoder::InstructionDecode(byte* instr_ptr) {
+int Decoder::InstructionDecode(uint8_t* instr_ptr) {
   Instruction* instr = Instruction::At(instr_ptr);
   int instrLength = instr->InstructionLength();
 
@@ -1041,12 +1041,12 @@ int Decoder::InstructionDecode(byte* instr_ptr) {
 
 namespace disasm {
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -1064,7 +1064,7 @@ const char* NameConverter::NameOfXMMRegister(int reg) const {
   UNREACHABLE();
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // The default name converter is called for unknown code. So we will not try
   // to access any memory.
   return "";
@@ -1073,22 +1073,22 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
 }
 
 // The S390 assembler does not currently use constant pools.
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     v8::internal::PrintF(f, "%p    %08x      %s\n", static_cast<void*>(prev_pc),
                          *reinterpret_cast<int32_t*>(prev_pc), buffer.begin());
diff --git a/src/diagnostics/unwinder.cc b/src/diagnostics/unwinder.cc
index 00a5e7dbe6..ab524e8826 100644
--- a/src/diagnostics/unwinder.cc
+++ b/src/diagnostics/unwinder.cc
@@ -22,10 +22,10 @@ i::Address Load(i::Address address) {
 
 namespace {
 
-const i::byte* CalculateEnd(const void* start, size_t length_in_bytes) {
+const uint8_t* CalculateEnd(const void* start, size_t length_in_bytes) {
   // Given that the length of the memory range is in bytes and it is not
-  // necessarily aligned, we need to do the pointer arithmetic in byte* here.
-  const i::byte* start_as_byte = reinterpret_cast<const i::byte*>(start);
+  // necessarily aligned, we need to do the pointer arithmetic in uint8_t* here.
+  const uint8_t* start_as_byte = reinterpret_cast<const uint8_t*>(start);
   return start_as_byte + length_in_bytes;
 }
 
diff --git a/src/diagnostics/x64/disasm-x64.cc b/src/diagnostics/x64/disasm-x64.cc
index d569d0d4e6..74e80b26d2 100644
--- a/src/diagnostics/x64/disasm-x64.cc
+++ b/src/diagnostics/x64/disasm-x64.cc
@@ -153,15 +153,15 @@ struct InstructionDesc {
 class InstructionTable {
  public:
   InstructionTable();
-  const InstructionDesc& Get(byte x) const { return instructions_[x]; }
+  const InstructionDesc& Get(uint8_t x) const { return instructions_[x]; }
 
  private:
   InstructionDesc instructions_[256];
   void Clear();
   void Init();
   void CopyTable(const ByteMnemonic bm[], InstructionType type);
-  void SetTableRange(InstructionType type, byte start, byte end, bool byte_size,
-                     const char* mnem);
+  void SetTableRange(InstructionType type, uint8_t start, uint8_t end,
+                     bool byte_size, const char* mnem);
   void AddJumpConditionalShort();
 };
 
@@ -204,9 +204,10 @@ void InstructionTable::CopyTable(const ByteMnemonic bm[],
   }
 }
 
-void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
-                                     bool byte_size, const char* mnem) {
-  for (byte b = start; b <= end; b++) {
+void InstructionTable::SetTableRange(InstructionType type, uint8_t start,
+                                     uint8_t end, bool byte_size,
+                                     const char* mnem) {
+  for (uint8_t b = start; b <= end; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered
     id->mnem = mnem;
@@ -216,7 +217,7 @@ void InstructionTable::SetTableRange(InstructionType type, byte start, byte end,
 }
 
 void InstructionTable::AddJumpConditionalShort() {
-  for (byte b = 0x70; b <= 0x7F; b++) {
+  for (uint8_t b = 0x70; b <= 0x7F; b++) {
     InstructionDesc* id = &instructions_[b];
     DCHECK_EQ(NO_INSTR, id->type);  // Information not already entered
     id->mnem = nullptr;             // Computed depending on condition code.
@@ -311,7 +312,7 @@ class DisassemblerX64 {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(v8::base::Vector<char> buffer, byte* instruction);
+  int InstructionDecode(v8::base::Vector<char> buffer, uint8_t* instruction);
 
  private:
   enum OperandSize {
@@ -325,20 +326,20 @@ class DisassemblerX64 {
   v8::base::EmbeddedVector<char, 128> tmp_buffer_;
   unsigned int tmp_buffer_pos_;
   bool abort_on_unimplemented_;
-  // Prefixes parsed
-  byte rex_;
-  byte operand_size_;    // 0x66 or (if no group 3 prefix is present) 0x0.
-  byte group_1_prefix_;  // 0xF2, 0xF3, or (if no group 1 prefix is present) 0.
-  byte segment_prefix_;  // 0x64 or (if no group 2 prefix is present) 0.
-  byte address_size_prefix_;  // 0x67 or (if no group 4 prefix is present) 0.
-  byte vex_byte0_;            // 0xC4 or 0xC5
-  byte vex_byte1_;
-  byte vex_byte2_;  // only for 3 bytes vex prefix
+  // Prefixes parsed.
+  uint8_t rex_;
+  uint8_t operand_size_;         // 0x66 or (without group 3 prefix) 0x0.
+  uint8_t group_1_prefix_;       // 0xF2, 0xF3, or (without group 1 prefix) 0.
+  uint8_t segment_prefix_;       // 0x64 or (without group 2 prefix) 0.
+  uint8_t address_size_prefix_;  // 0x67 or (without group 4 prefix) 0.
+  uint8_t vex_byte0_;            // 0xC4 or 0xC5.
+  uint8_t vex_byte1_;
+  uint8_t vex_byte2_;  // only for 3 bytes vex prefix.
   // Byte size operand override.
   bool byte_size_operand_;
   const InstructionTable* const instruction_table_;
 
-  void setRex(byte rex) {
+  void setRex(uint8_t rex) {
     DCHECK_EQ(0x40, rex & 0xF0);
     rex_ = rex;
   }
@@ -363,37 +364,37 @@ class DisassemblerX64 {
 
   bool vex_128() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 4) == 0;
   }
 
   bool vex_256() const {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 4) != 0;
   }
 
   bool vex_none() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 0;
   }
 
   bool vex_66() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 1;
   }
 
   bool vex_f3() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 2;
   }
 
   bool vex_f2() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return (checked & 3) == 3;
   }
 
@@ -414,7 +415,7 @@ class DisassemblerX64 {
 
   int vex_vreg() {
     DCHECK(vex_byte0_ == VEX3_PREFIX || vex_byte0_ == VEX2_PREFIX);
-    byte checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
+    uint8_t checked = vex_byte0_ == VEX3_PREFIX ? vex_byte2_ : vex_byte1_;
     return ~(checked >> 3) & 0xF;
   }
 
@@ -449,18 +450,18 @@ class DisassemblerX64 {
     }
   }
 
-  const char* NameOfAddress(byte* addr) const {
+  const char* NameOfAddress(uint8_t* addr) const {
     return converter_.NameOfAddress(addr);
   }
 
   // Disassembler helper functions.
-  void get_modrm(byte data, int* mod, int* regop, int* rm) {
+  void get_modrm(uint8_t data, int* mod, int* regop, int* rm) {
     *mod = (data >> 6) & 3;
     *regop = ((data & 0x38) >> 3) | (rex_r() ? 8 : 0);
     *rm = (data & 7) | (rex_b() ? 8 : 0);
   }
 
-  void get_sib(byte data, int* scale, int* index, int* base) {
+  void get_sib(uint8_t data, int* scale, int* index, int* base) {
     *scale = (data >> 6) & 3;
     *index = ((data >> 3) & 7) | (rex_x() ? 8 : 0);
     *base = (data & 7) | (rex_b() ? 8 : 0);
@@ -469,27 +470,27 @@ class DisassemblerX64 {
   using RegisterNameMapping = const char* (DisassemblerX64::*)(int reg) const;
 
   void TryAppendRootRelativeName(int offset);
-  int PrintRightOperandHelper(byte* modrmp, RegisterNameMapping register_name);
-  int PrintRightOperand(byte* modrmp);
-  int PrintRightByteOperand(byte* modrmp);
-  int PrintRightXMMOperand(byte* modrmp);
-  int PrintRightAVXOperand(byte* modrmp);
-  int PrintOperands(const char* mnem, OperandType op_order, byte* data);
-  int PrintImmediate(byte* data, OperandSize size);
-  int PrintImmediateOp(byte* data);
-  const char* TwoByteMnemonic(byte opcode);
-  int TwoByteOpcodeInstruction(byte* data);
-  int ThreeByteOpcodeInstruction(byte* data);
-  int F6F7Instruction(byte* data);
-  int ShiftInstruction(byte* data);
-  int JumpShort(byte* data);
-  int JumpConditional(byte* data);
-  int JumpConditionalShort(byte* data);
-  int SetCC(byte* data);
-  int FPUInstruction(byte* data);
-  int MemoryFPUInstruction(int escape_opcode, int regop, byte* modrm_start);
-  int RegisterFPUInstruction(int escape_opcode, byte modrm_byte);
-  int AVXInstruction(byte* data);
+  int PrintRightOperandHelper(uint8_t* modrmp, RegisterNameMapping);
+  int PrintRightOperand(uint8_t* modrmp);
+  int PrintRightByteOperand(uint8_t* modrmp);
+  int PrintRightXMMOperand(uint8_t* modrmp);
+  int PrintRightAVXOperand(uint8_t* modrmp);
+  int PrintOperands(const char* mnem, OperandType op_order, uint8_t* data);
+  int PrintImmediate(uint8_t* data, OperandSize size);
+  int PrintImmediateOp(uint8_t* data);
+  const char* TwoByteMnemonic(uint8_t opcode);
+  int TwoByteOpcodeInstruction(uint8_t* data);
+  int ThreeByteOpcodeInstruction(uint8_t* data);
+  int F6F7Instruction(uint8_t* data);
+  int ShiftInstruction(uint8_t* data);
+  int JumpShort(uint8_t* data);
+  int JumpConditional(uint8_t* data);
+  int JumpConditionalShort(uint8_t* data);
+  int SetCC(uint8_t* data);
+  int FPUInstruction(uint8_t* data);
+  int MemoryFPUInstruction(int escape_opcode, int regop, uint8_t* modrm_start);
+  int RegisterFPUInstruction(int escape_opcode, uint8_t modrm_byte);
+  int AVXInstruction(uint8_t* data);
   PRINTF_FORMAT(2, 3) void AppendToBuffer(const char* format, ...);
 
   void UnimplementedInstruction() {
@@ -516,7 +517,7 @@ void DisassemblerX64::TryAppendRootRelativeName(int offset) {
 }
 
 int DisassemblerX64::PrintRightOperandHelper(
-    byte* modrmp, RegisterNameMapping direct_register_name) {
+    uint8_t* modrmp, RegisterNameMapping direct_register_name) {
   int mod, regop, rm;
   get_modrm(*modrmp, &mod, &regop, &rm);
   RegisterNameMapping register_name =
@@ -528,7 +529,7 @@ int DisassemblerX64::PrintRightOperandHelper(
         return 5;
       } else if ((rm & 7) == 4) {
         // Codes for SIB byte.
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         if (index == 4 && (base & 7) == 4 && scale == 0 /*times_1*/) {
@@ -558,7 +559,7 @@ int DisassemblerX64::PrintRightOperandHelper(
     case 1:  // fall through
     case 2:
       if ((rm & 7) == 4) {
-        byte sib = *(modrmp + 1);
+        uint8_t sib = *(modrmp + 1);
         int scale, index, base;
         get_sib(sib, &scale, &index, &base);
         int disp = (mod == 2) ? Imm32(modrmp + 2) : Imm8(modrmp + 2);
@@ -592,7 +593,7 @@ int DisassemblerX64::PrintRightOperandHelper(
   UNREACHABLE();
 }
 
-int DisassemblerX64::PrintImmediate(byte* data, OperandSize size) {
+int DisassemblerX64::PrintImmediate(uint8_t* data, OperandSize size) {
   int64_t value;
   int count;
   switch (size) {
@@ -619,28 +620,28 @@ int DisassemblerX64::PrintImmediate(byte* data, OperandSize size) {
   return count;
 }
 
-int DisassemblerX64::PrintRightOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerX64::NameOfCPURegister);
 }
 
-int DisassemblerX64::PrintRightByteOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightByteOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp,
                                  &DisassemblerX64::NameOfByteCPURegister);
 }
 
-int DisassemblerX64::PrintRightXMMOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightXMMOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerX64::NameOfXMMRegister);
 }
 
-int DisassemblerX64::PrintRightAVXOperand(byte* modrmp) {
+int DisassemblerX64::PrintRightAVXOperand(uint8_t* modrmp) {
   return PrintRightOperandHelper(modrmp, &DisassemblerX64::NameOfAVXRegister);
 }
 
 // Returns number of bytes used including the current *data.
 // Writes instruction's mnemonic, left and right operands to 'tmp_buffer_'.
 int DisassemblerX64::PrintOperands(const char* mnem, OperandType op_order,
-                                   byte* data) {
-  byte modrm = *data;
+                                   uint8_t* data) {
+  uint8_t modrm = *data;
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   int advance = 0;
@@ -690,10 +691,10 @@ int DisassemblerX64::PrintOperands(const char* mnem, OperandType op_order,
 
 // Returns number of bytes used by machine instruction, including *data byte.
 // Writes immediate instructions to 'tmp_buffer_'.
-int DisassemblerX64::PrintImmediateOp(byte* data) {
+int DisassemblerX64::PrintImmediateOp(uint8_t* data) {
   DCHECK(*data == 0x80 || *data == 0x81 || *data == 0x83);
   bool byte_size_immediate = *data != 0x81;
-  byte modrm = *(data + 1);
+  uint8_t modrm = *(data + 1);
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   const char* mnem = "Imm???";
@@ -736,9 +737,9 @@ int DisassemblerX64::PrintImmediateOp(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::F6F7Instruction(byte* data) {
+int DisassemblerX64::F6F7Instruction(uint8_t* data) {
   DCHECK(*data == 0xF7 || *data == 0xF6);
-  byte modrm = *(data + 1);
+  uint8_t modrm = *(data + 1);
   int mod, regop, rm;
   get_modrm(modrm, &mod, &regop, &rm);
   if (regop != 0) {
@@ -790,8 +791,8 @@ int DisassemblerX64::F6F7Instruction(byte* data) {
   }
 }
 
-int DisassemblerX64::ShiftInstruction(byte* data) {
-  byte op = *data & (~1);
+int DisassemblerX64::ShiftInstruction(uint8_t* data) {
+  uint8_t op = *data & (~1);
   int count = 1;
   if (op != 0xD0 && op != 0xD2 && op != 0xC0) {
     UnimplementedInstruction();
@@ -799,7 +800,7 @@ int DisassemblerX64::ShiftInstruction(byte* data) {
   }
   // Print mneumonic.
   {
-    byte modrm = *(data + count);
+    uint8_t modrm = *(data + count);
     int mod, regop, rm;
     get_modrm(modrm, &mod, &regop, &rm);
     regop &= 0x7;  // The REX.R bit does not affect the operation.
@@ -851,38 +852,38 @@ int DisassemblerX64::ShiftInstruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::JumpShort(byte* data) {
+int DisassemblerX64::JumpShort(uint8_t* data) {
   DCHECK_EQ(0xEB, *data);
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   AppendToBuffer("jmp %s", NameOfAddress(dest));
   return 2;
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::JumpConditional(byte* data) {
+int DisassemblerX64::JumpConditional(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
-  byte* dest = data + Imm32(data + 2) + 6;
+  uint8_t cond = *(data + 1) & 0x0F;
+  uint8_t* dest = data + Imm32(data + 2) + 6;
   const char* mnem = conditional_code_suffix[cond];
   AppendToBuffer("j%s %s", mnem, NameOfAddress(dest));
   return 6;  // includes 0x0F
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::JumpConditionalShort(byte* data) {
-  byte cond = *data & 0x0F;
-  byte b = *(data + 1);
-  byte* dest = data + static_cast<int8_t>(b) + 2;
+int DisassemblerX64::JumpConditionalShort(uint8_t* data) {
+  uint8_t cond = *data & 0x0F;
+  uint8_t b = *(data + 1);
+  uint8_t* dest = data + static_cast<int8_t>(b) + 2;
   const char* mnem = conditional_code_suffix[cond];
   AppendToBuffer("j%s %s", mnem, NameOfAddress(dest));
   return 2;
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::SetCC(byte* data) {
+int DisassemblerX64::SetCC(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
-  byte cond = *(data + 1) & 0x0F;
+  uint8_t cond = *(data + 1) & 0x0F;
   const char* mnem = conditional_code_suffix[cond];
   AppendToBuffer("set%s%c ", mnem, operand_size_code());
   PrintRightByteOperand(data + 2);
@@ -891,9 +892,9 @@ int DisassemblerX64::SetCC(byte* data) {
 
 const char* sf_str[4] = {"", "rl", "ra", "ll"};
 
-int DisassemblerX64::AVXInstruction(byte* data) {
-  byte opcode = *data;
-  byte* current = data + 1;
+int DisassemblerX64::AVXInstruction(uint8_t* data) {
+  uint8_t opcode = *data;
+  uint8_t* current = data + 1;
   if (vex_66() && vex_0f38()) {
     int mod, regop, rm, vvvv = vex_vreg();
     get_modrm(*current, &mod, &regop, &rm);
@@ -1574,10 +1575,10 @@ int DisassemblerX64::AVXInstruction(byte* data) {
 }
 
 // Returns number of bytes used, including *data.
-int DisassemblerX64::FPUInstruction(byte* data) {
-  byte escape_opcode = *data;
+int DisassemblerX64::FPUInstruction(uint8_t* data) {
+  uint8_t escape_opcode = *data;
   DCHECK_EQ(0xD8, escape_opcode & 0xF8);
-  byte modrm_byte = *(data + 1);
+  uint8_t modrm_byte = *(data + 1);
 
   if (modrm_byte >= 0xC0) {
     return RegisterFPUInstruction(escape_opcode, modrm_byte);
@@ -1587,7 +1588,7 @@ int DisassemblerX64::FPUInstruction(byte* data) {
 }
 
 int DisassemblerX64::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
-                                          byte* modrm_start) {
+                                          uint8_t* modrm_start) {
   const char* mnem = "?";
   int regop = (modrm_byte >> 3) & 0x7;  // reg/op field of modrm byte.
   switch (escape_opcode) {
@@ -1661,7 +1662,7 @@ int DisassemblerX64::MemoryFPUInstruction(int escape_opcode, int modrm_byte,
 }
 
 int DisassemblerX64::RegisterFPUInstruction(int escape_opcode,
-                                            byte modrm_byte) {
+                                            uint8_t modrm_byte) {
   bool has_register = false;  // Is the FPU register encoded in modrm_byte?
   const char* mnem = "?";
 
@@ -1844,9 +1845,9 @@ int DisassemblerX64::RegisterFPUInstruction(int escape_opcode,
 
 // Handle all two-byte opcodes, which start with 0x0F.
 // These instructions may be affected by an 0x66, 0xF2, or 0xF3 prefix.
-int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
-  byte opcode = *(data + 1);
-  byte* current = data + 2;
+int DisassemblerX64::TwoByteOpcodeInstruction(uint8_t* data) {
+  uint8_t opcode = *(data + 1);
+  uint8_t* current = data + 2;
   // At return, "current" points to the start of the next instruction.
   const char* mnemonic = TwoByteMnemonic(opcode);
   // Not every instruction will use this, but it doesn't hurt to figure it out
@@ -2180,13 +2181,13 @@ int DisassemblerX64::TwoByteOpcodeInstruction(byte* data) {
 // Handle all three-byte opcodes, which start with 0x0F38 or 0x0F3A.
 // These instructions may be affected by an 0x66, 0xF2, or 0xF3 prefix, but we
 // only have instructions prefixed with 0x66 for now.
-int DisassemblerX64::ThreeByteOpcodeInstruction(byte* data) {
+int DisassemblerX64::ThreeByteOpcodeInstruction(uint8_t* data) {
   DCHECK_EQ(0x0F, *data);
   // Only support 3-byte opcodes prefixed with 0x66 for now.
   DCHECK_EQ(0x66, operand_size_);
-  byte second_byte = *(data + 1);
-  byte third_byte = *(data + 2);
-  byte* current = data + 3;
+  uint8_t second_byte = *(data + 1);
+  uint8_t third_byte = *(data + 2);
+  uint8_t* current = data + 3;
   int mod, regop, rm;
   get_modrm(*current, &mod, &regop, &rm);
   if (second_byte == 0x38) {
@@ -2274,7 +2275,7 @@ int DisassemblerX64::ThreeByteOpcodeInstruction(byte* data) {
 // Mnemonics for two-byte opcode instructions starting with 0x0F.
 // The argument is the second byte of the two-byte opcode.
 // Returns nullptr if the instruction is not handled here.
-const char* DisassemblerX64::TwoByteMnemonic(byte opcode) {
+const char* DisassemblerX64::TwoByteMnemonic(uint8_t opcode) {
   if (opcode >= 0xC8 && opcode <= 0xCF) return "bswap";
   switch (opcode) {
     case 0x1F:
@@ -2335,12 +2336,12 @@ const char* DisassemblerX64::TwoByteMnemonic(byte opcode) {
 
 // Disassembles the instruction at instr, and writes it into out_buffer.
 int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
-                                       byte* instr) {
+                                       uint8_t* instr) {
   tmp_buffer_pos_ = 0;  // starting to write as position 0
-  byte* data = instr;
+  uint8_t* data = instr;
   bool processed = true;  // Will be set to false if the current instruction
                           // is not in 'instructions' table.
-  byte current;
+  uint8_t current;
 
   // Scan for prefixes.
   while (true) {
@@ -2426,18 +2427,18 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
         data++;
         break;
       case MOVE_REG_INSTR: {
-        byte* addr = nullptr;
+        uint8_t* addr = nullptr;
         switch (operand_size()) {
           case OPERAND_WORD_SIZE:
-            addr = reinterpret_cast<byte*>(Imm16(data + 1));
+            addr = reinterpret_cast<uint8_t*>(Imm16(data + 1));
             data += 3;
             break;
           case OPERAND_DOUBLEWORD_SIZE:
-            addr = reinterpret_cast<byte*>(Imm32_U(data + 1));
+            addr = reinterpret_cast<uint8_t*>(Imm32_U(data + 1));
             data += 5;
             break;
           case OPERAND_QUADWORD_SIZE:
-            addr = reinterpret_cast<byte*>(Imm64(data + 1));
+            addr = reinterpret_cast<uint8_t*>(Imm64(data + 1));
             data += 9;
             break;
           default:
@@ -2450,7 +2451,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
       }
 
       case CALL_JUMP_INSTR: {
-        byte* addr = data + Imm32(data + 1) + 5;
+        uint8_t* addr = data + Imm32(data + 1) + 5;
         AppendToBuffer("%s %s", idesc.mnem, NameOfAddress(addr));
         data += 5;
         break;
@@ -2638,7 +2639,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
       case 0xBE:
       case 0xBF: {
         // mov reg8,imm8 or mov reg32,imm32
-        byte opcode = *data;
+        uint8_t opcode = *data;
         data++;
         bool is_32bit = (opcode >= 0xB8);
         int reg = (opcode & 0x7) | (rex_b() ? 8 : 0);
@@ -2679,7 +2680,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
         switch (operand_size()) {
           case OPERAND_DOUBLEWORD_SIZE: {
             const char* memory_location =
-                NameOfAddress(reinterpret_cast<byte*>(Imm32(data + 1)));
+                NameOfAddress(reinterpret_cast<uint8_t*>(Imm32(data + 1)));
             if (*data == 0xA1) {  // Opcode 0xA1
               AppendToBuffer("movzxlq rax,(%s)", memory_location);
             } else {  // Opcode 0xA3
@@ -2691,7 +2692,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
           case OPERAND_QUADWORD_SIZE: {
             // New x64 instruction mov rax,(imm_64).
             const char* memory_location =
-                NameOfAddress(reinterpret_cast<byte*>(Imm64(data + 1)));
+                NameOfAddress(reinterpret_cast<uint8_t*>(Imm64(data + 1)));
             if (*data == 0xA1) {  // Opcode 0xA1
               AppendToBuffer("movq rax,(%s)", memory_location);
             } else {  // Opcode 0xA3
@@ -2785,7 +2786,7 @@ int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
 
   int outp = 0;
   // Instruction bytes.
-  for (byte* bp = instr; bp < data; bp++) {
+  for (uint8_t* bp = instr; bp < data; bp++) {
     outp += v8::base::SNPrintF(out_buffer + outp, "%02x", *bp);
   }
   // Indent instruction, leaving space for 10 bytes, i.e. 20 characters in hex.
@@ -2816,12 +2817,12 @@ static const char* const ymm_regs[16] = {
     "ymm0", "ymm1", "ymm2",  "ymm3",  "ymm4",  "ymm5",  "ymm6",  "ymm7",
     "ymm8", "ymm9", "ymm10", "ymm11", "ymm12", "ymm13", "ymm14", "ymm15"};
 
-const char* NameConverter::NameOfAddress(byte* addr) const {
+const char* NameConverter::NameOfAddress(uint8_t* addr) const {
   v8::base::SNPrintF(tmp_buffer_, "%p", static_cast<void*>(addr));
   return tmp_buffer_.begin();
 }
 
-const char* NameConverter::NameOfConstant(byte* addr) const {
+const char* NameConverter::NameOfConstant(uint8_t* addr) const {
   return NameOfAddress(addr);
 }
 
@@ -2845,7 +2846,7 @@ const char* NameOfYMMRegister(int reg) {
   return "noymmreg";
 }
 
-const char* NameConverter::NameInCode(byte* addr) const {
+const char* NameConverter::NameInCode(uint8_t* addr) const {
   // X64 does not embed debug strings at the moment.
   UNREACHABLE();
 }
@@ -2853,27 +2854,27 @@ const char* NameConverter::NameInCode(byte* addr) const {
 //------------------------------------------------------------------------------
 
 int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
-                                    byte* instruction) {
+                                    uint8_t* instruction) {
   DisassemblerX64 d(converter_, unimplemented_opcode_action());
   return d.InstructionDecode(buffer, instruction);
 }
 
 // The X64 assembler does not use constant pools.
-int Disassembler::ConstantPoolSizeAt(byte* instruction) { return -1; }
+int Disassembler::ConstantPoolSizeAt(uint8_t* instruction) { return -1; }
 
-void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
+void Disassembler::Disassemble(FILE* f, uint8_t* begin, uint8_t* end,
                                UnimplementedOpcodeAction unimplemented_action) {
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
-    byte* prev_pc = pc;
+    uint8_t* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
     fprintf(f, "%p", static_cast<void*>(prev_pc));
     fprintf(f, "    ");
 
-    for (byte* bp = prev_pc; bp < pc; bp++) {
+    for (uint8_t* bp = prev_pc; bp < pc; bp++) {
       fprintf(f, "%02x", *bp);
     }
     for (int i = 6 - static_cast<int>(pc - prev_pc); i >= 0; i--) {
-- 
2.35.1


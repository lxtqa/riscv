From 01551ab36e1123c084bbfeee717836422b3cb82d Mon Sep 17 00:00:00 2001
From: jingpeiyang <jingpeiyang@eswincomputing.com>
Date: Thu, 20 Apr 2023 10:37:19 +0800
Subject: [PATCH] [riscv][isolate]Move Isolate::handle_scope_data_ to
 IsolateData

Port commit bc45e84fe4abaa72c3e7cd37c250b484840ad512

Bug: v8:13825
Signed-off-by: jingpeiyang <jingpeiyang@eswincomputing.com>
Change-Id: I97da26dd57f779e0da9334c6bc7c50699fc13996
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4452548
Commit-Queue: Ji Qiu <qiuji@iscas.ac.cn>
Reviewed-by: Ji Qiu <qiuji@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#87183}
---
 src/builtins/riscv/builtins-riscv.cc       | 55 ++++++++++------------
 src/codegen/riscv/macro-assembler-riscv.cc |  2 +
 2 files changed, 26 insertions(+), 31 deletions(-)

diff --git a/src/builtins/riscv/builtins-riscv.cc b/src/builtins/riscv/builtins-riscv.cc
index 67814e7284..a4a69662b8 100644
--- a/src/builtins/riscv/builtins-riscv.cc
+++ b/src/builtins/riscv/builtins-riscv.cc
@@ -3093,12 +3093,6 @@ void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
 }
 namespace {
 
-int AddressOffset(ExternalReference ref0, ExternalReference ref1) {
-  int64_t offset = (ref0.address() - ref1.address());
-  DCHECK(static_cast<int>(offset) == offset);
-  return static_cast<int>(offset);
-}
-
 // Calls an API function.  Allocates HandleScope, extracts returned value
 // from handle and propagates exceptions.  Restores context.  stack_space
 // - space to be unwound on exit (includes the call JS arguments space and
@@ -3108,14 +3102,15 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
                               MemOperand* stack_space_operand,
                               MemOperand return_value_operand) {
   ASM_CODE_COMMENT(masm);
+  using ER = ExternalReference;
+
   Isolate* isolate = masm->isolate();
-  ExternalReference next_address =
-      ExternalReference::handle_scope_next_address(isolate);
-  const int kNextOffset = 0;
-  const int kLimitOffset = AddressOffset(
-      ExternalReference::handle_scope_limit_address(isolate), next_address);
-  const int kLevelOffset = AddressOffset(
-      ExternalReference::handle_scope_level_address(isolate), next_address);
+  MemOperand next_mem_op = __ ExternalReferenceAsOperand(
+      ER::handle_scope_next_address(isolate), no_reg);
+  MemOperand limit_mem_op = __ ExternalReferenceAsOperand(
+      ER::handle_scope_limit_address(isolate), no_reg);
+  MemOperand level_mem_op = __ ExternalReferenceAsOperand(
+      ER::handle_scope_level_address(isolate), no_reg);
 
   DCHECK(function_address == a1 || function_address == a2);
 
@@ -3126,22 +3121,20 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     {
       ASM_CODE_COMMENT_STRING(masm,
                               "Allocate HandleScope in callee-save registers.");
-      __ li(s5, next_address);
-      __ LoadWord(s3, MemOperand(s5, kNextOffset));
-      __ LoadWord(s1, MemOperand(s5, kLimitOffset));
-      __ Lw(s2, MemOperand(s5, kLevelOffset));
+      __ LoadWord(s3, next_mem_op);
+      __ LoadWord(s1, limit_mem_op);
+      __ Lw(s2, level_mem_op);
       __ Add32(s2, s2, Operand(1));
-      __ Sw(s2, MemOperand(s5, kLevelOffset));
+      __ Sw(s2, level_mem_op);
     }
     __ RecordComment("Check if profiler or side effects check is enabled");
-    __ Lb(scratch,
-          __ ExternalReferenceAsOperand(
-              ExternalReference::execution_mode_address(isolate), scratch));
+    __ Lb(scratch, __ ExternalReferenceAsOperand(
+                       ER::execution_mode_address(isolate), no_reg));
     __ Branch(&profiler_or_side_effects_check_enabled, ne, scratch,
               Operand(zero_reg));
 #ifdef V8_RUNTIME_CALL_STATS
     __ RecordComment("Check if RCS is enabled");
-    __ li(scratch, ExternalReference::address_of_runtime_stats_flag());
+    __ li(scratch, ER::address_of_runtime_stats_flag());
     __ Lw(scratch, MemOperand(scratch, 0));
     __ Branch(&profiler_or_side_effects_check_enabled, ne, scratch,
               Operand(zero_reg));
@@ -3165,15 +3158,15 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
         masm,
         "No more valid handles (the result handle was the last one)."
         "Restore previous handle scope.");
-    __ StoreWord(s3, MemOperand(s5, kNextOffset));
+    __ StoreWord(s3, next_mem_op);
     if (v8_flags.debug_code) {
-      __ Lw(a1, MemOperand(s5, kLevelOffset));
+      __ Lw(a1, level_mem_op);
       __ Check(eq, AbortReason::kUnexpectedLevelAfterReturnFromApiCall, a1,
                Operand(s2));
     }
     __ Sub32(s2, s2, Operand(1));
-    __ Sw(s2, MemOperand(s5, kLevelOffset));
-    __ LoadWord(kScratchReg, MemOperand(s5, kLimitOffset));
+    __ Sw(s2, level_mem_op);
+    __ LoadWord(kScratchReg, limit_mem_op);
     __ Branch(&delete_allocated_handles, ne, s1, Operand(kScratchReg));
   }
   __ RecordComment("Leave the API exit frame.");
@@ -3195,8 +3188,8 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     ASM_CODE_COMMENT_STRING(masm,
                             "Check if the function scheduled an exception.");
     __ LoadRoot(a4, RootIndex::kTheHoleValue);
-    __ li(kScratchReg, ExternalReference::scheduled_exception_address(isolate));
-    __ LoadWord(a5, MemOperand(kScratchReg));
+    __ LoadWord(a5, __ ExternalReferenceAsOperand(
+                        ER::scheduled_exception_address(isolate), no_reg));
     __ Branch(&promote_scheduled_exception, ne, a4, Operand(a5),
               Label::Distance::kNear);
   }
@@ -3226,11 +3219,11 @@ void CallApiFunctionAndReturn(MacroAssembler* masm, Register function_address,
     ASM_CODE_COMMENT_STRING(
         masm, "HandleScope limit has changed. Delete allocated extensions.");
     __ bind(&delete_allocated_handles);
-    __ StoreWord(s1, MemOperand(s5, kLimitOffset));
+    __ StoreWord(s1, limit_mem_op);
     __ Move(s3, a0);
     __ PrepareCallCFunction(1, s1);
-    __ li(a0, ExternalReference::isolate_address(isolate));
-    __ CallCFunction(ExternalReference::delete_handle_scope_extensions(), 1);
+    __ li(a0, ER::isolate_address(isolate));
+    __ CallCFunction(ER::delete_handle_scope_extensions(), 1);
     __ Move(a0, s3);
     __ Branch(&leave_exit_frame);
   }
diff --git a/src/codegen/riscv/macro-assembler-riscv.cc b/src/codegen/riscv/macro-assembler-riscv.cc
index ad46d83307..01875cd399 100644
--- a/src/codegen/riscv/macro-assembler-riscv.cc
+++ b/src/codegen/riscv/macro-assembler-riscv.cc
@@ -4261,6 +4261,7 @@ MemOperand MacroAssembler::ExternalReferenceAsOperand(
       return MemOperand(kRootRegister, static_cast<int32_t>(offset));
     } else {
       // Otherwise, do a memory load from the external reference table.
+      DCHECK(scratch.is_valid());
       LoadWord(scratch,
                MemOperand(kRootRegister,
                           RootRegisterOffsetForExternalReferenceTableEntry(
@@ -4268,6 +4269,7 @@ MemOperand MacroAssembler::ExternalReferenceAsOperand(
       return MemOperand(scratch, 0);
     }
   }
+  DCHECK(scratch.is_valid());
   li(scratch, reference);
   return MemOperand(scratch, 0);
 }
-- 
2.35.1


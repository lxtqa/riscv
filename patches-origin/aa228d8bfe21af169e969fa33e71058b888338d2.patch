From aa228d8bfe21af169e969fa33e71058b888338d2 Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Tue, 9 May 2023 13:02:51 +0200
Subject: [PATCH] [test] Use uint8_t instead of byte

Byte is an alias for the standard uint8_t type (defined in
src/common/globals.h).
For readability, avoid the alias and use the uint8_t directly.

R=ahaas@chromium.org

Change-Id: Ieb3669fe72a8ce1ffaac544215bb28dc684f8d72
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4508919
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#87522}
---
 .../test-atomic-load-store-codegen.cc         |   2 +-
 test/cctest/compiler/test-code-generator.cc   |   2 +-
 test/cctest/compiler/test-multiple-return.cc  |   8 +-
 test/cctest/compiler/test-run-load-store.cc   |  26 +-
 .../cctest/heap/test-concurrent-allocation.cc |   2 +-
 test/cctest/heap/test-heap.cc                 |   4 +-
 test/cctest/test-assembler-ia32.cc            |  40 +-
 test/cctest/test-assembler-s390.cc            |   2 +-
 test/cctest/test-disasm-regex-helper.cc       |   4 +-
 test/cctest/test-field-type-tracking.cc       |   2 +-
 test/cctest/test-log-stack-tracer.cc          |   3 +-
 test/cctest/test-serialize.cc                 |  54 +-
 test/cctest/test-unwinder-code-pages.cc       |  20 +-
 test/cctest/test-utils.cc                     |  12 +-
 test/cctest/wasm/test-gc.cc                   | 523 +++++++-------
 test/cctest/wasm/test-grow-memory.cc          |   4 +-
 test/cctest/wasm/test-jump-table-assembler.cc |   4 +-
 test/cctest/wasm/test-liftoff-for-fuzzing.cc  |   8 +-
 test/cctest/wasm/test-run-wasm-64.cc          |  40 +-
 test/cctest/wasm/test-run-wasm-bulk-memory.cc |  40 +-
 test/cctest/wasm/test-run-wasm-exceptions.cc  |  65 +-
 test/cctest/wasm/test-run-wasm-js.cc          |   8 +-
 test/cctest/wasm/test-run-wasm-memory64.cc    |   2 +-
 test/cctest/wasm/test-run-wasm-module.cc      |  78 +-
 .../cctest/wasm/test-run-wasm-relaxed-simd.cc |  32 +-
 .../cctest/wasm/test-run-wasm-simd-liftoff.cc |  32 +-
 test/cctest/wasm/test-run-wasm-simd.cc        | 223 +++---
 test/cctest/wasm/test-run-wasm-wrappers.cc    |  18 +-
 test/cctest/wasm/test-run-wasm.cc             | 108 +--
 .../cctest/wasm/test-streaming-compilation.cc |   4 +-
 test/cctest/wasm/test-wasm-metrics.cc         |   2 +-
 test/cctest/wasm/test-wasm-serialization.cc   |   6 +-
 test/cctest/wasm/test-wasm-shared-engine.cc   |   2 +-
 test/cctest/wasm/test-wasm-stack.cc           |   4 +-
 test/cctest/wasm/wasm-run-utils.cc            |  27 +-
 test/cctest/wasm/wasm-run-utils.h             |  36 +-
 test/cctest/wasm/wasm-simd-utils.cc           | 104 +--
 test/common/assembler-tester.h                |   4 +-
 test/common/wasm/wasm-macro-gen.h             | 679 ++++++++++--------
 test/common/wasm/wasm-module-runner.cc        |   4 +-
 test/common/wasm/wasm-module-runner.h         |   4 +-
 test/fuzzer/multi-return.cc                   |   2 +-
 test/fuzzer/wasm-compile.cc                   |  12 +-
 .../assembler/assembler-x64-unittest.cc       | 456 ++++++------
 .../assembler/disasm-arm-unittest.cc          |  22 +-
 .../assembler/disasm-arm64-unittest.cc        |   6 +-
 .../assembler/disasm-ia32-unittest.cc         |   6 +-
 .../assembler/disasm-loong64-unittest.cc      |  16 +-
 .../assembler/disasm-mips64-unittest.cc       |  24 +-
 .../assembler/disasm-ppc-unittest.cc          |  14 +-
 .../assembler/disasm-riscv-unittest.cc        |  16 +-
 .../assembler/disasm-s390-unittest.cc         |  14 +-
 .../assembler/disasm-x64-unittest.cc          |  10 +-
 .../assembler/macro-assembler-arm-unittest.cc |   8 +-
 .../macro-assembler-arm64-unittest.cc         |   8 +-
 test/unittests/base/vlq-unittest.cc           |   8 +-
 .../unittests/codegen/code-layout-unittest.cc |  18 +-
 test/unittests/codegen/code-pages-unittest.cc |  19 +-
 test/unittests/codegen/factory-unittest.cc    |   6 +-
 .../instruction-selector-arm64-unittest.cc    |   2 +-
 .../diagnostics/eh-frame-iterator-unittest.cc |  10 +-
 test/unittests/regexp/regexp-unittest.cc      |   8 +-
 test/unittests/strings/unicode-unittest.cc    |  12 +-
 test/unittests/wasm/decoder-unittest.cc       |  48 +-
 .../wasm/function-body-decoder-unittest.cc    | 632 ++++++++--------
 test/unittests/wasm/leb-helper-unittest.cc    |   4 +-
 .../wasm/loop-assignment-analysis-unittest.cc |  40 +-
 .../wasm/memory-protection-unittest.cc        |   2 +-
 .../unittests/wasm/module-decoder-unittest.cc | 572 +++++++--------
 .../wasm/streaming-decoder-unittest.cc        |   2 +-
 .../wasm/wasm-disassembler-unittest.cc        |  16 +-
 .../unittests/wasm/wasm-macro-gen-unittest.cc |   2 +-
 .../wasm/wasm-module-builder-unittest.cc      |   2 +-
 test/wasm-api-tests/callbacks.cc              |  10 +-
 test/wasm-api-tests/finalize.cc               |   4 +-
 test/wasm-api-tests/globals.cc                |  24 +-
 test/wasm-api-tests/hostref.cc                |  12 +-
 test/wasm-api-tests/memory.cc                 |  10 +-
 test/wasm-api-tests/multi-return.cc           |   6 +-
 test/wasm-api-tests/reflect.cc                |   2 +-
 test/wasm-api-tests/regressions.cc            |   2 +-
 test/wasm-api-tests/serialize.cc              |   2 +-
 test/wasm-api-tests/startup-errors.cc         |   2 +-
 test/wasm-api-tests/table.cc                  |   6 +-
 test/wasm-api-tests/threads.cc                |   2 +-
 test/wasm-api-tests/traps.cc                  |   8 +-
 test/wasm-api-tests/wasm-api-test.h           |   8 +-
 87 files changed, 2224 insertions(+), 2133 deletions(-)

diff --git a/test/cctest/compiler/test-atomic-load-store-codegen.cc b/test/cctest/compiler/test-atomic-load-store-codegen.cc
index 2b39cca0ef7..39b776108d6 100644
--- a/test/cctest/compiler/test-atomic-load-store-codegen.cc
+++ b/test/cctest/compiler/test-atomic-load-store-codegen.cc
@@ -15,7 +15,7 @@ namespace compiler {
 #if V8_TARGET_LITTLE_ENDIAN
 #define LSB(addr, bytes) addr
 #elif V8_TARGET_BIG_ENDIAN
-#define LSB(addr, bytes) reinterpret_cast<byte*>(addr + 1) - (bytes)
+#define LSB(addr, bytes) reinterpret_cast<uint8_t*>(addr + 1) - (bytes)
 #else
 #error "Unknown Architecture"
 #endif
diff --git a/test/cctest/compiler/test-code-generator.cc b/test/cctest/compiler/test-code-generator.cc
index cb195ad12ed..39d014bfa9b 100644
--- a/test/cctest/compiler/test-code-generator.cc
+++ b/test/cctest/compiler/test-code-generator.cc
@@ -1666,7 +1666,7 @@ TEST(Regress_1171759) {
   std::shared_ptr<wasm::NativeModule> module =
       AllocateNativeModule(handles.main_isolate(), code->instruction_size());
   wasm::WasmCodeRefScope wasm_code_ref_scope;
-  byte* code_start = module->AddCodeForTesting(code)->instructions().begin();
+  uint8_t* code_start = module->AddCodeForTesting(code)->instructions().begin();
 
   // Generate a minimal calling function, to push stack arguments.
   RawMachineAssemblerTester<int32_t> mt;
diff --git a/test/cctest/compiler/test-multiple-return.cc b/test/cctest/compiler/test-multiple-return.cc
index 9c65ee1582b..8ef9e7e3d13 100644
--- a/test/cctest/compiler/test-multiple-return.cc
+++ b/test/cctest/compiler/test-multiple-return.cc
@@ -187,7 +187,7 @@ void TestReturnMultipleValues(MachineType type, int min_count, int max_count) {
       std::shared_ptr<wasm::NativeModule> module = AllocateNativeModule(
           handles.main_isolate(), code->instruction_size());
       wasm::WasmCodeRefScope wasm_code_ref_scope;
-      byte* code_start =
+      uint8_t* code_start =
           module->AddCodeForTesting(code)->instructions().begin();
 
       RawMachineAssemblerTester<int32_t> mt(CodeKind::JS_TO_WASM_FUNCTION);
@@ -284,7 +284,8 @@ void ReturnLastValue(MachineType type) {
     std::shared_ptr<wasm::NativeModule> module =
         AllocateNativeModule(handles.main_isolate(), code->instruction_size());
     wasm::WasmCodeRefScope wasm_code_ref_scope;
-    byte* code_start = module->AddCodeForTesting(code)->instructions().begin();
+    uint8_t* code_start =
+        module->AddCodeForTesting(code)->instructions().begin();
 
     // Generate caller.
     int expect = return_count - 1;
@@ -347,7 +348,8 @@ void ReturnSumOfReturns(MachineType type) {
     std::shared_ptr<wasm::NativeModule> module =
         AllocateNativeModule(handles.main_isolate(), code->instruction_size());
     wasm::WasmCodeRefScope wasm_code_ref_scope;
-    byte* code_start = module->AddCodeForTesting(code)->instructions().begin();
+    uint8_t* code_start =
+        module->AddCodeForTesting(code)->instructions().begin();
 
     // Generate caller.
     RawMachineAssemblerTester<int32_t> mt;
diff --git a/test/cctest/compiler/test-run-load-store.cc b/test/cctest/compiler/test-run-load-store.cc
index a235c655883..d433b79fbd1 100644
--- a/test/cctest/compiler/test-run-load-store.cc
+++ b/test/cctest/compiler/test-run-load-store.cc
@@ -26,7 +26,7 @@ enum TestAlignment {
 #if V8_TARGET_LITTLE_ENDIAN
 #define LSB(addr, bytes) addr
 #elif V8_TARGET_BIG_ENDIAN
-#define LSB(addr, bytes) reinterpret_cast<byte*>(addr + 1) - (bytes)
+#define LSB(addr, bytes) reinterpret_cast<uint8_t*>(addr + 1) - (bytes)
 #else
 #error "Unknown Architecture"
 #endif
@@ -36,9 +36,9 @@ enum TestAlignment {
 #define A_GIG (1024ULL * 1024ULL * 1024ULL)
 
 namespace {
-byte* ComputeOffset(void* real_address, int32_t offset) {
-  return reinterpret_cast<byte*>(reinterpret_cast<Address>(real_address) -
-                                 offset);
+uint8_t* ComputeOffset(void* real_address, int32_t offset) {
+  return reinterpret_cast<uint8_t*>(reinterpret_cast<Address>(real_address) -
+                                    offset);
 }
 
 void RunLoadInt32(const TestAlignment t) {
@@ -69,7 +69,7 @@ void RunLoadInt32Offset(TestAlignment t) {
   for (size_t i = 0; i < arraysize(offsets); i++) {
     RawMachineAssemblerTester<int32_t> m;
     int32_t offset = offsets[i];
-    byte* pointer = ComputeOffset(&p1, offset);
+    uint8_t* pointer = ComputeOffset(&p1, offset);
 
     // generate load [#base + #index]
     if (t == TestAlignment::kAligned) {
@@ -97,8 +97,8 @@ void RunLoadStoreFloat32Offset(TestAlignment t) {
         base::AddWithWraparound(0x2342AABB, base::MulWithWraparound(i, 3));
     RawMachineAssemblerTester<int32_t> m;
     int32_t offset = i;
-    byte* from = ComputeOffset(&p1, offset);
-    byte* to = ComputeOffset(&p2, offset);
+    uint8_t* from = ComputeOffset(&p1, offset);
+    uint8_t* to = ComputeOffset(&p2, offset);
     // generate load [#base + #index]
     if (t == TestAlignment::kAligned) {
       Node* load = m.Load(MachineType::Float32(), m.PointerConstant(from),
@@ -135,8 +135,8 @@ void RunLoadStoreFloat64Offset(TestAlignment t) {
         base::AddWithWraparound(0x2342AABB, base::MulWithWraparound(i, 3));
     RawMachineAssemblerTester<int32_t> m;
     int32_t offset = i;
-    byte* from = ComputeOffset(&p1, offset);
-    byte* to = ComputeOffset(&p2, offset);
+    uint8_t* from = ComputeOffset(&p1, offset);
+    uint8_t* to = ComputeOffset(&p2, offset);
     // generate load [#base + #index]
     if (t == TestAlignment::kAligned) {
       Node* load = m.Load(MachineType::Float64(), m.PointerConstant(from),
@@ -225,9 +225,9 @@ template <typename CType>
 void InitBuffer(CType* buffer, size_t length, MachineType type) {
   const size_t kBufferSize = sizeof(CType) * length;
   if (!type.IsTagged()) {
-    byte* raw = reinterpret_cast<byte*>(buffer);
+    uint8_t* raw = reinterpret_cast<uint8_t*>(buffer);
     for (size_t i = 0; i < kBufferSize; i++) {
-      raw[i] = static_cast<byte>((i + kBufferSize) ^ 0xAA);
+      raw[i] = static_cast<uint8_t>((i + kBufferSize) ^ 0xAA);
     }
     return;
   }
@@ -343,8 +343,8 @@ void RunLoadStore(MachineType type, TestAlignment t) {
 template <typename CType>
 void RunUnalignedLoadStoreUnalignedAccess(MachineType type) {
   CType in, out;
-  byte in_buffer[2 * sizeof(CType)];
-  byte out_buffer[2 * sizeof(CType)];
+  uint8_t in_buffer[2 * sizeof(CType)];
+  uint8_t out_buffer[2 * sizeof(CType)];
 
   InitBuffer(&in, 1, type);
 
diff --git a/test/cctest/heap/test-concurrent-allocation.cc b/test/cctest/heap/test-concurrent-allocation.cc
index a255066d438..73a87687fab 100644
--- a/test/cctest/heap/test-concurrent-allocation.cc
+++ b/test/cctest/heap/test-concurrent-allocation.cc
@@ -520,7 +520,7 @@ UNINITIALIZED_TEST(ConcurrentRecordRelocSlot) {
     HeapObject value;
     {
       HandleScope handle_scope(i_isolate);
-      i::byte buffer[i::Assembler::kDefaultBufferSize];
+      uint8_t buffer[i::Assembler::kDefaultBufferSize];
       MacroAssembler masm(i_isolate, v8::internal::CodeObjectRequired::kYes,
                           ExternalAssemblerBuffer(buffer, sizeof(buffer)));
 #if V8_TARGET_ARCH_ARM64
diff --git a/test/cctest/heap/test-heap.cc b/test/cctest/heap/test-heap.cc
index 64343183591..9095a24b6f8 100644
--- a/test/cctest/heap/test-heap.cc
+++ b/test/cctest/heap/test-heap.cc
@@ -4520,7 +4520,7 @@ TEST(ObjectsInEagerlyDeoptimizedCodeAreWeak) {
 }
 
 static Handle<InstructionStream> DummyOptimizedCode(Isolate* isolate) {
-  i::byte buffer[i::Assembler::kDefaultBufferSize];
+  uint8_t buffer[i::Assembler::kDefaultBufferSize];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   CodeDesc desc;
@@ -7177,7 +7177,7 @@ TEST(Regress10900) {
   Isolate* isolate = CcTest::i_isolate();
   Heap* heap = isolate->heap();
   HandleScope handle_scope(isolate);
-  i::byte buffer[i::Assembler::kDefaultBufferSize];
+  uint8_t buffer[i::Assembler::kDefaultBufferSize];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
 #if V8_TARGET_ARCH_ARM64
diff --git a/test/cctest/test-assembler-ia32.cc b/test/cctest/test-assembler-ia32.cc
index 9155d027315..58c6e27f5c5 100644
--- a/test/cctest/test-assembler-ia32.cc
+++ b/test/cctest/test-assembler-ia32.cc
@@ -52,7 +52,7 @@ TEST(AssemblerIa320) {
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
 
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
 
@@ -80,7 +80,7 @@ TEST(AssemblerIa321) {
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
 
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
   Label L, C;
@@ -118,7 +118,7 @@ TEST(AssemblerIa322) {
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
 
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
   Label L, C;
@@ -161,7 +161,7 @@ TEST(AssemblerIa323) {
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
 
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
 
@@ -190,7 +190,7 @@ TEST(AssemblerIa324) {
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
 
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
 
@@ -218,7 +218,7 @@ TEST(AssemblerIa325) {
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
 
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
 
@@ -241,7 +241,7 @@ TEST(AssemblerIa326) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
 
@@ -279,7 +279,7 @@ TEST(AssemblerIa328) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
   __ mov(eax, Operand(esp, 4));
@@ -324,7 +324,7 @@ TEST(AssemblerMultiByteNop) {
   CcTest::InitializeVM();
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   __ push(ebx);
@@ -398,7 +398,7 @@ void DoSSE2(const v8::FunctionCallbackInfo<v8::Value>& info) {
   v8::Local<v8::Array> vec = v8::Local<v8::Array>::Cast(info[0]);
   CHECK_EQ(ELEMENT_COUNT, vec->Length());
 
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
 
@@ -480,7 +480,7 @@ TEST(AssemblerIa32Extractps) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   { CpuFeatureScope fscope41(&assm, SSE4_1);
@@ -512,7 +512,7 @@ TEST(AssemblerIa32SSE) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -548,7 +548,7 @@ TEST(AssemblerIa32SSE3) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -582,7 +582,7 @@ TEST(AssemblerX64FMA_sd) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -811,7 +811,7 @@ TEST(AssemblerX64FMA_ss) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1039,7 +1039,7 @@ TEST(AssemblerIa32BMI1) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1147,7 +1147,7 @@ TEST(AssemblerIa32LZCNT) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1195,7 +1195,7 @@ TEST(AssemblerIa32POPCNT) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1243,7 +1243,7 @@ TEST(AssemblerIa32BMI2) {
 
   Isolate* isolate = reinterpret_cast<Isolate*>(CcTest::isolate());
   HandleScope scope(isolate);
-  v8::internal::byte buffer[2048];
+  uint8_t buffer[2048];
   MacroAssembler assm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1521,7 +1521,7 @@ TEST(Regress621926) {
 TEST(DeoptExitSizeIsFixed) {
   Isolate* isolate = CcTest::i_isolate();
   HandleScope handles(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
 
diff --git a/test/cctest/test-assembler-s390.cc b/test/cctest/test-assembler-s390.cc
index 69b22e6907c..4402ae83e31 100644
--- a/test/cctest/test-assembler-s390.cc
+++ b/test/cctest/test-assembler-s390.cc
@@ -201,7 +201,7 @@ TEST(3) {
   __ mvc(MemOperand(r0, 123), MemOperand(r4, 567), Operand(88));
   __ sll(r13, Operand(10));
 
-  v8::internal::byte* bufPos = assm.buffer_pos();
+  v8::internal::uint8_t* bufPos = assm.buffer_pos();
   ::printf("buffer position = %p", static_cast<void*>(bufPos));
   ::fflush(stdout);
   // OS::DebugBreak();
diff --git a/test/cctest/test-disasm-regex-helper.cc b/test/cctest/test-disasm-regex-helper.cc
index d23f7f0332b..ee0e08a136b 100644
--- a/test/cctest/test-disasm-regex-helper.cc
+++ b/test/cctest/test-disasm-regex-helper.cc
@@ -25,8 +25,8 @@ std::string DisassembleFunction(const char* function) {
   Address begin = code->instruction_start();
   Address end = code->instruction_end();
   std::ostringstream os;
-  Disassembler::Decode(isolate, os, reinterpret_cast<byte*>(begin),
-                       reinterpret_cast<byte*>(end), CodeReference(code));
+  Disassembler::Decode(isolate, os, reinterpret_cast<uint8_t*>(begin),
+                       reinterpret_cast<uint8_t*>(end), CodeReference(code));
   return os.str();
 }
 
diff --git a/test/cctest/test-field-type-tracking.cc b/test/cctest/test-field-type-tracking.cc
index 6a69fa5771a..3bcadbcdbf1 100644
--- a/test/cctest/test-field-type-tracking.cc
+++ b/test/cctest/test-field-type-tracking.cc
@@ -606,7 +606,7 @@ struct CRFTData {
 };
 
 Handle<Code> CreateDummyOptimizedCode(Isolate* isolate) {
-  byte buffer[1];
+  uint8_t buffer[1];
   CodeDesc desc;
   desc.buffer = buffer;
   desc.buffer_size = arraysize(buffer);
diff --git a/test/cctest/test-log-stack-tracer.cc b/test/cctest/test-log-stack-tracer.cc
index 1331619e3d2..4a77d231c18 100644
--- a/test/cctest/test-log-stack-tracer.cc
+++ b/test/cctest/test-log-stack-tracer.cc
@@ -237,7 +237,7 @@ TEST(PureJSStackTrace) {
                                 sample.stack[base + 1]));
 }
 
-static void CFuncDoTrace(byte dummy_param) {
+static void CFuncDoTrace(uint8_t dummy_param) {
   Address fp;
 #if V8_HAS_BUILTIN_FRAME_ADDRESS
   fp = reinterpret_cast<Address>(__builtin_frame_address(0));
@@ -251,7 +251,6 @@ static void CFuncDoTrace(byte dummy_param) {
   i::TraceExtension::DoTrace(fp);
 }
 
-
 static int CFunc(int depth) {
   if (depth <= 0) {
     CFuncDoTrace(0);
diff --git a/test/cctest/test-serialize.cc b/test/cctest/test-serialize.cc
index 7898a36b0ef..ea8c8946def 100644
--- a/test/cctest/test-serialize.cc
+++ b/test/cctest/test-serialize.cc
@@ -75,9 +75,9 @@ void DisableAlwaysOpt() {
 // A convenience struct to simplify management of the blobs required to
 // deserialize an isolate.
 struct StartupBlobs {
-  base::Vector<const byte> startup;
-  base::Vector<const byte> read_only;
-  base::Vector<const byte> shared_space;
+  base::Vector<const uint8_t> startup;
+  base::Vector<const uint8_t> read_only;
+  base::Vector<const uint8_t> shared_space;
 
   void Dispose() {
     startup.Dispose();
@@ -136,12 +136,12 @@ class TestSerializer {
   }
 };
 
-static base::Vector<const byte> WritePayload(
-    const base::Vector<const byte>& payload) {
+static base::Vector<const uint8_t> WritePayload(
+    const base::Vector<const uint8_t>& payload) {
   int length = payload.length();
-  byte* blob = NewArray<byte>(length);
+  uint8_t* blob = NewArray<uint8_t>(length);
   memcpy(blob, payload.begin(), length);
-  return base::Vector<const byte>(const_cast<const byte*>(blob), length);
+  return base::Vector<const uint8_t>(const_cast<const uint8_t*>(blob), length);
 }
 
 namespace {
@@ -328,10 +328,10 @@ UNINITIALIZED_TEST(StartupSerializerTwiceRunScript) {
   FreeCurrentEmbeddedBlob();
 }
 
-static void SerializeContext(base::Vector<const byte>* startup_blob_out,
-                             base::Vector<const byte>* read_only_blob_out,
-                             base::Vector<const byte>* shared_space_blob_out,
-                             base::Vector<const byte>* context_blob_out) {
+static void SerializeContext(base::Vector<const uint8_t>* startup_blob_out,
+                             base::Vector<const uint8_t>* read_only_blob_out,
+                             base::Vector<const uint8_t>* shared_space_blob_out,
+                             base::Vector<const uint8_t>* context_blob_out) {
   v8::Isolate* v8_isolate = TestSerializer::NewIsolateInitialized();
   Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);
   Heap* heap = isolate->heap();
@@ -407,10 +407,10 @@ static void SerializeContext(base::Vector<const byte>* startup_blob_out,
 #ifdef SNAPSHOT_COMPRESSION
 UNINITIALIZED_TEST(SnapshotCompression) {
   DisableAlwaysOpt();
-  base::Vector<const byte> startup_blob;
-  base::Vector<const byte> read_only_blob;
-  base::Vector<const byte> shared_space_blob;
-  base::Vector<const byte> context_blob;
+  base::Vector<const uint8_t> startup_blob;
+  base::Vector<const uint8_t> read_only_blob;
+  base::Vector<const uint8_t> shared_space_blob;
+  base::Vector<const uint8_t> context_blob;
   SerializeContext(&startup_blob, &read_only_blob, &shared_space_blob,
                    &context_blob);
   SnapshotData original_snapshot_data(context_blob);
@@ -429,10 +429,10 @@ UNINITIALIZED_TEST(SnapshotCompression) {
 
 UNINITIALIZED_TEST(ContextSerializerContext) {
   DisableAlwaysOpt();
-  base::Vector<const byte> startup_blob;
-  base::Vector<const byte> read_only_blob;
-  base::Vector<const byte> shared_space_blob;
-  base::Vector<const byte> context_blob;
+  base::Vector<const uint8_t> startup_blob;
+  base::Vector<const uint8_t> read_only_blob;
+  base::Vector<const uint8_t> shared_space_blob;
+  base::Vector<const uint8_t> context_blob;
   SerializeContext(&startup_blob, &read_only_blob, &shared_space_blob,
                    &context_blob);
 
@@ -476,10 +476,10 @@ UNINITIALIZED_TEST(ContextSerializerContext) {
 }
 
 static void SerializeCustomContext(
-    base::Vector<const byte>* startup_blob_out,
-    base::Vector<const byte>* read_only_blob_out,
-    base::Vector<const byte>* shared_space_blob_out,
-    base::Vector<const byte>* context_blob_out) {
+    base::Vector<const uint8_t>* startup_blob_out,
+    base::Vector<const uint8_t>* read_only_blob_out,
+    base::Vector<const uint8_t>* shared_space_blob_out,
+    base::Vector<const uint8_t>* context_blob_out) {
   v8::Isolate* v8_isolate = TestSerializer::NewIsolateInitialized();
   Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);
   {
@@ -575,10 +575,10 @@ static void SerializeCustomContext(
 
 UNINITIALIZED_TEST(ContextSerializerCustomContext) {
   DisableAlwaysOpt();
-  base::Vector<const byte> startup_blob;
-  base::Vector<const byte> read_only_blob;
-  base::Vector<const byte> shared_space_blob;
-  base::Vector<const byte> context_blob;
+  base::Vector<const uint8_t> startup_blob;
+  base::Vector<const uint8_t> read_only_blob;
+  base::Vector<const uint8_t> shared_space_blob;
+  base::Vector<const uint8_t> context_blob;
   SerializeCustomContext(&startup_blob, &read_only_blob, &shared_space_blob,
                          &context_blob);
 
diff --git a/test/cctest/test-unwinder-code-pages.cc b/test/cctest/test-unwinder-code-pages.cc
index fe295f75de5..901f28b6dc8 100644
--- a/test/cctest/test-unwinder-code-pages.cc
+++ b/test/cctest/test-unwinder-code-pages.cc
@@ -253,10 +253,10 @@ const char* foo_source = R"(
 
 bool PagesContainsAddress(size_t length, MemoryRange* pages,
                           Address search_address) {
-  byte* addr = reinterpret_cast<byte*>(search_address);
+  uint8_t* addr = reinterpret_cast<uint8_t*>(search_address);
   auto it = std::find_if(pages, pages + length, [addr](const MemoryRange& r) {
-    const byte* page_start = reinterpret_cast<const byte*>(r.start);
-    const byte* page_end = page_start + r.length_in_bytes;
+    const uint8_t* page_start = reinterpret_cast<const uint8_t*>(r.start);
+    const uint8_t* page_end = page_start + r.length_in_bytes;
     return addr >= page_start && addr < page_end;
   });
   return it != pages + length;
@@ -456,7 +456,7 @@ TEST(Unwind_JSEntry_Fail_CodePagesAPI) {
   RegisterState register_state;
 
   Code js_entry = *BUILTIN_CODE(i_isolate, JSEntry);
-  byte* start = reinterpret_cast<byte*>(js_entry.instruction_start());
+  uint8_t* start = reinterpret_cast<uint8_t*>(js_entry.instruction_start());
   register_state.pc = start + 10;
 
   bool unwound = v8::Unwinder::TryUnwindV8Frames(
@@ -593,7 +593,7 @@ TEST(PCIsInV8_ValidStateNullPC_Fail_CodePagesAPI) {
 }
 
 void TestRangeBoundaries(size_t pages_length, MemoryRange* code_pages,
-                         byte* range_start, size_t range_length) {
+                         uint8_t* range_start, size_t range_length) {
   void* pc = range_start - 1;
   CHECK(!v8::Unwinder::PCIsInV8(pages_length, code_pages, pc));
   pc = range_start;
@@ -618,8 +618,8 @@ TEST(PCIsInV8_InAllCodePages_CodePagesAPI) {
   CHECK_LE(pages_length, arraysize(code_pages));
 
   for (size_t i = 0; i < pages_length; i++) {
-    byte* range_start =
-        const_cast<byte*>(reinterpret_cast<const byte*>(code_pages[i].start));
+    uint8_t* range_start = const_cast<uint8_t*>(
+        reinterpret_cast<const uint8_t*>(code_pages[i].start));
     size_t range_length = code_pages[i].length_in_bytes;
     TestRangeBoundaries(pages_length, code_pages, range_start, range_length);
   }
@@ -638,7 +638,7 @@ TEST(PCIsInV8_InJSEntryRange_CodePagesAPI) {
   CHECK_LE(pages_length, arraysize(code_pages));
 
   Code js_entry = *BUILTIN_CODE(i_isolate, JSEntry);
-  byte* start = reinterpret_cast<byte*>(js_entry.instruction_start());
+  uint8_t* start = reinterpret_cast<uint8_t*>(js_entry.instruction_start());
   size_t length = js_entry.instruction_size();
 
   void* pc = start;
@@ -661,7 +661,7 @@ TEST(PCIsInV8_LargeCodeObject_CodePagesAPI) {
   // Create a big function that ends up in CODE_LO_SPACE.
   const int instruction_size = Page::kPageSize + 1;
   CHECK_GT(instruction_size, MemoryChunkLayout::MaxRegularCodeObjectSize());
-  std::unique_ptr<byte[]> instructions(new byte[instruction_size]);
+  std::unique_ptr<uint8_t[]> instructions(new uint8_t[instruction_size]);
 
   CodeDesc desc;
   desc.buffer = instructions.get();
@@ -677,7 +677,7 @@ TEST(PCIsInV8_LargeCodeObject_CodePagesAPI) {
 
   CHECK(i_isolate->heap()->InSpace(foo_code->instruction_stream(),
                                    CODE_LO_SPACE));
-  byte* start = reinterpret_cast<byte*>(foo_code->instruction_start());
+  uint8_t* start = reinterpret_cast<uint8_t*>(foo_code->instruction_start());
 
   MemoryRange code_pages[v8::Isolate::kMinCodePagesBufferSize];
   size_t pages_length =
diff --git a/test/cctest/test-utils.cc b/test/cctest/test-utils.cc
index 479fde1ed00..43860ff66de 100644
--- a/test/cctest/test-utils.cc
+++ b/test/cctest/test-utils.cc
@@ -147,12 +147,8 @@ TEST(SNPrintF) {
 
 static const int kAreaSize = 512;
 
-
-void TestMemMove(byte* area1,
-                 byte* area2,
-                 int src_offset,
-                 int dest_offset,
-                 int length) {
+void TestMemMove(uint8_t* area1, uint8_t* area2, int src_offset,
+                 int dest_offset, int length) {
   for (int i = 0; i < kAreaSize; i++) {
     area1[i] = i & 0xFF;
     area2[i] = i & 0xFF;
@@ -172,8 +168,8 @@ void TestMemMove(byte* area1,
 }
 
 TEST(MemMove) {
-  byte* area1 = new byte[kAreaSize];
-  byte* area2 = new byte[kAreaSize];
+  uint8_t* area1 = new uint8_t[kAreaSize];
+  uint8_t* area2 = new uint8_t[kAreaSize];
 
   static const int kMinOffset = 32;
   static const int kMaxOffset = 64;
diff --git a/test/cctest/wasm/test-gc.cc b/test/cctest/wasm/test-gc.cc
index db94fc2ca65..6131f4f752a 100644
--- a/test/cctest/wasm/test-gc.cc
+++ b/test/cctest/wasm/test-gc.cc
@@ -49,23 +49,24 @@ class WasmGCTester {
     testing::SetupIsolateForWasmModule(isolate_);
   }
 
-  byte AddGlobal(ValueType type, bool mutability, WasmInitExpr init) {
+  uint8_t AddGlobal(ValueType type, bool mutability, WasmInitExpr init) {
     return builder_.AddGlobal(type, mutability, init);
   }
 
-  byte DefineFunction(FunctionSig* sig, std::initializer_list<ValueType> locals,
-                      std::initializer_list<byte> code) {
+  uint8_t DefineFunction(FunctionSig* sig,
+                         std::initializer_list<ValueType> locals,
+                         std::initializer_list<uint8_t> code) {
     return DefineFunctionImpl(builder_.AddFunction(sig), locals, code);
   }
 
-  byte DefineFunction(uint32_t sig_index,
-                      std::initializer_list<ValueType> locals,
-                      std::initializer_list<byte> code) {
+  uint8_t DefineFunction(uint32_t sig_index,
+                         std::initializer_list<ValueType> locals,
+                         std::initializer_list<uint8_t> code) {
     return DefineFunctionImpl(builder_.AddFunction(sig_index), locals, code);
   }
 
   void DefineExportedFunction(const char* name, FunctionSig* sig,
-                              std::initializer_list<byte> code) {
+                              std::initializer_list<uint8_t> code) {
     WasmFunctionBuilder* fun = builder_.AddFunction(sig);
     fun->EmitCode(code.begin(), static_cast<uint32_t>(code.size()));
     builder_.AddExport(base::CStrVector(name), fun);
@@ -80,8 +81,9 @@ class WasmGCTester {
                            isolate_->factory()->undefined_value(), argc, args);
   }
 
-  byte DefineStruct(std::initializer_list<F> fields,
-                    uint32_t supertype = kNoSuperType, bool is_final = false) {
+  uint8_t DefineStruct(std::initializer_list<F> fields,
+                       uint32_t supertype = kNoSuperType,
+                       bool is_final = false) {
     StructType::Builder type_builder(&zone_,
                                      static_cast<uint32_t>(fields.size()));
     for (F field : fields) {
@@ -90,18 +92,19 @@ class WasmGCTester {
     return builder_.AddStructType(type_builder.Build(), is_final, supertype);
   }
 
-  byte DefineArray(ValueType element_type, bool mutability,
-                   uint32_t supertype = kNoSuperType, bool is_final = false) {
+  uint8_t DefineArray(ValueType element_type, bool mutability,
+                      uint32_t supertype = kNoSuperType,
+                      bool is_final = false) {
     return builder_.AddArrayType(zone_.New<ArrayType>(element_type, mutability),
                                  is_final, supertype);
   }
 
-  byte DefineSignature(FunctionSig* sig, uint32_t supertype = kNoSuperType,
-                       bool is_final = false) {
+  uint8_t DefineSignature(FunctionSig* sig, uint32_t supertype = kNoSuperType,
+                          bool is_final = false) {
     return builder_.ForceAddSignature(sig, is_final, supertype);
   }
 
-  byte DefineTable(ValueType type, uint32_t min_size, uint32_t max_size) {
+  uint8_t DefineTable(ValueType type, uint32_t min_size, uint32_t max_size) {
     return builder_.AddTable(type, min_size, max_size);
   }
 
@@ -199,9 +202,9 @@ class WasmGCTester {
   const FlagScope<bool> flag_wasm_dynamic_tiering;
   const FlagScope<bool> flag_tierup;
 
-  byte DefineFunctionImpl(WasmFunctionBuilder* fun,
-                          std::initializer_list<ValueType> locals,
-                          std::initializer_list<byte> code) {
+  uint8_t DefineFunctionImpl(WasmFunctionBuilder* fun,
+                             std::initializer_list<ValueType> locals,
+                             std::initializer_list<uint8_t> code) {
     for (ValueType local : locals) {
       fun->AddLocal(local);
     }
@@ -266,9 +269,9 @@ ValueType refNull(uint32_t type_index) {
 WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
   WasmGCTester tester(execution_tier);
 
-  const byte type_index =
+  const uint8_t type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
-  const byte empty_struct_index = tester.DefineStruct({});
+  const uint8_t empty_struct_index = tester.DefineStruct({});
   ValueType kRefType = ref(type_index);
   ValueType kEmptyStructType = ref(empty_struct_index);
   ValueType kRefNullType = refNull(type_index);
@@ -276,7 +279,7 @@ WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
   FunctionSig sig_qe_v(1, 0, &kEmptyStructType);
 
   // Test struct.new and struct.get.
-  const byte kGet1 = tester.DefineFunction(
+  const uint8_t kGet1 = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_STRUCT_GET(
            type_index, 0,
@@ -284,7 +287,7 @@ WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
        kExprEnd});
 
   // Test struct.new and struct.get.
-  const byte kGet2 = tester.DefineFunction(
+  const uint8_t kGet2 = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_STRUCT_GET(
            type_index, 1,
@@ -292,24 +295,24 @@ WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
        kExprEnd});
 
   // Test struct.new, returning struct reference.
-  const byte kGetStruct = tester.DefineFunction(
+  const uint8_t kGetStruct = tester.DefineFunction(
       &sig_q_v, {},
       {WASM_STRUCT_NEW(type_index, WASM_I32V(42), WASM_I32V(64)), kExprEnd});
 
-  const byte kGetStructNominal = tester.DefineFunction(
+  const uint8_t kGetStructNominal = tester.DefineFunction(
       &sig_q_v, {},
       {WASM_STRUCT_NEW_DEFAULT(type_index), WASM_DROP,
        WASM_STRUCT_NEW(type_index, WASM_I32V(42), WASM_I32V(64)), kExprEnd});
 
   // Test struct.new, returning reference to an empty struct.
-  const byte kGetEmptyStruct = tester.DefineFunction(
+  const uint8_t kGetEmptyStruct = tester.DefineFunction(
       &sig_qe_v, {},
       {WASM_GC_OP(kExprStructNew), empty_struct_index, kExprEnd});
 
   // Test struct.set, struct refs types in locals.
-  const byte j_local_index = 0;
-  const byte j_field_index = 0;
-  const byte kSet = tester.DefineFunction(
+  const uint8_t j_local_index = 0;
+  const uint8_t j_field_index = 0;
+  const uint8_t kSet = tester.DefineFunction(
       tester.sigs.i_v(), {kRefNullType},
       {WASM_LOCAL_SET(j_local_index, WASM_STRUCT_NEW(type_index, WASM_I32V(42),
                                                      WASM_I32V(64))),
@@ -319,7 +322,7 @@ WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
                        WASM_LOCAL_GET(j_local_index)),
        kExprEnd});
 
-  const byte kNullDereference = tester.DefineFunction(
+  const uint8_t kNullDereference = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_STRUCT_GET(type_index, 0, WASM_REF_NULL(type_index)), kExprEnd});
 
@@ -341,25 +344,25 @@ WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
 // Test struct.get, ref.as_non_null and ref-typed globals.
 WASM_COMPILED_EXEC_TEST(WasmRefAsNonNull) {
   WasmGCTester tester(execution_tier);
-  const byte type_index =
+  const uint8_t type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefTypes[] = {ref(type_index)};
   ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, kRefTypes);
 
-  const byte global_index =
+  const uint8_t global_index =
       tester.AddGlobal(kRefNullType, true,
                        WasmInitExpr::RefNullConst(
                            static_cast<HeapType::Representation>(type_index)));
-  const byte field_index = 0;
-  const byte kNonNull = tester.DefineFunction(
+  const uint8_t field_index = 0;
+  const uint8_t kNonNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_GLOBAL_SET(global_index, WASM_STRUCT_NEW(type_index, WASM_I32V(55),
                                                      WASM_I32V(66))),
        WASM_STRUCT_GET(type_index, field_index,
                        WASM_REF_AS_NON_NULL(WASM_GLOBAL_GET(global_index))),
        kExprEnd});
-  const byte kNull = tester.DefineFunction(
+  const uint8_t kNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_GLOBAL_SET(global_index, WASM_REF_NULL(type_index)),
        WASM_STRUCT_GET(type_index, field_index,
@@ -374,16 +377,16 @@ WASM_COMPILED_EXEC_TEST(WasmRefAsNonNull) {
 WASM_COMPILED_EXEC_TEST(WasmRefAsNonNullSkipCheck) {
   FlagScope<bool> no_check(&v8_flags.experimental_wasm_skip_null_checks, true);
   WasmGCTester tester(execution_tier);
-  const byte type_index =
+  const uint8_t type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefType = ref(type_index);
   FunctionSig sig_q_v(1, 0, &kRefType);
 
-  const byte global_index =
+  const uint8_t global_index =
       tester.AddGlobal(refNull(type_index), true,
                        WasmInitExpr::RefNullConst(
                            static_cast<HeapType::Representation>(type_index)));
-  const byte kFunc = tester.DefineFunction(
+  const uint8_t kFunc = tester.DefineFunction(
       &sig_q_v, {},
       {WASM_GLOBAL_SET(global_index, WASM_REF_NULL(type_index)),
        WASM_REF_AS_NON_NULL(WASM_GLOBAL_GET(global_index)), kExprEnd});
@@ -396,13 +399,13 @@ WASM_COMPILED_EXEC_TEST(WasmRefAsNonNullSkipCheck) {
 
 WASM_COMPILED_EXEC_TEST(WasmBrOnNull) {
   WasmGCTester tester(execution_tier);
-  const byte type_index =
+  const uint8_t type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefTypes[] = {ref(type_index)};
   ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, kRefTypes);
-  const byte local_index = 0;
-  const byte kTaken = tester.DefineFunction(
+  const uint8_t local_index = 0;
+  const uint8_t kTaken = tester.DefineFunction(
       tester.sigs.i_v(), {kRefNullType},
       {WASM_BLOCK_I(WASM_I32V(42),
                     // Branch will be taken.
@@ -411,8 +414,8 @@ WASM_COMPILED_EXEC_TEST(WasmBrOnNull) {
                     WASM_I32V(52), WASM_BR(0)),
        kExprEnd});
 
-  const byte field_index = 0;
-  const byte kNotTaken = tester.DefineFunction(
+  const uint8_t field_index = 0;
+  const uint8_t kNotTaken = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_I(
            WASM_I32V(42),
@@ -432,14 +435,14 @@ WASM_COMPILED_EXEC_TEST(WasmBrOnNull) {
 
 WASM_COMPILED_EXEC_TEST(WasmBrOnNonNull) {
   WasmGCTester tester(execution_tier);
-  const byte type_index =
+  const uint8_t type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefType = ref(type_index);
   ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, &kRefType);
-  const byte field_index = 0;
+  const uint8_t field_index = 0;
 
-  const byte kTaken = tester.DefineFunction(
+  const uint8_t kTaken = tester.DefineFunction(
       tester.sigs.i_v(), {kRefNullType, kRefNullType},
       {WASM_LOCAL_SET(
            0, WASM_STRUCT_NEW(type_index, WASM_I32V(52), WASM_I32V(62))),
@@ -453,7 +456,7 @@ WASM_COMPILED_EXEC_TEST(WasmBrOnNonNull) {
                                     WASM_REF_AS_NON_NULL(WASM_LOCAL_GET(1)))),
        kExprEnd});
 
-  const byte kNotTaken = tester.DefineFunction(
+  const uint8_t kNotTaken = tester.DefineFunction(
       tester.sigs.i_v(), {kRefNullType, kRefNullType},
       {WASM_LOCAL_SET(0, WASM_REF_NULL(type_index)),
        WASM_LOCAL_SET(
@@ -473,10 +476,10 @@ WASM_COMPILED_EXEC_TEST(WasmBrOnNonNull) {
 WASM_COMPILED_EXEC_TEST(RefCast) {
   WasmGCTester tester(execution_tier);
 
-  const byte supertype_index = tester.DefineStruct({F(kWasmI32, true)});
-  const byte subtype1_index = tester.DefineStruct(
+  const uint8_t supertype_index = tester.DefineStruct({F(kWasmI32, true)});
+  const uint8_t subtype1_index = tester.DefineStruct(
       {F(kWasmI32, true), F(kWasmF32, false)}, supertype_index);
-  const byte subtype2_index = tester.DefineStruct(
+  const uint8_t subtype2_index = tester.DefineStruct(
       {F(kWasmI32, true), F(kWasmI64, false)}, supertype_index);
   auto super_sig =
       FixedSizeSignature<ValueType>::Params(ValueType::RefNull(subtype1_index))
@@ -487,19 +490,19 @@ WASM_COMPILED_EXEC_TEST(RefCast) {
   auto sub_sig2 =
       FixedSizeSignature<ValueType>::Params(ValueType::RefNull(supertype_index))
           .Returns(ValueType::RefNull(subtype2_index));
-  const byte function_type_index = tester.DefineSignature(&super_sig);
-  const byte function_subtype1_index =
+  const uint8_t function_type_index = tester.DefineSignature(&super_sig);
+  const uint8_t function_subtype1_index =
       tester.DefineSignature(&sub_sig1, function_type_index);
-  const byte function_subtype2_index =
+  const uint8_t function_subtype2_index =
       tester.DefineSignature(&sub_sig2, function_type_index);
-  const byte function_index = tester.DefineFunction(
+  const uint8_t function_index = tester.DefineFunction(
       function_subtype1_index, {},
       {WASM_STRUCT_NEW(subtype1_index, WASM_I32V(10), WASM_F32(20)), WASM_END});
   // Just so this function counts as "declared".
   tester.AddGlobal(ValueType::RefNull(function_type_index), false,
                    WasmInitExpr::RefFuncConst(function_index));
 
-  const byte kTestSuccessful = tester.DefineFunction(
+  const uint8_t kTestSuccessful = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(supertype_index)},
       {WASM_LOCAL_SET(
            0, WASM_STRUCT_NEW(subtype1_index, WASM_I32V(10), WASM_F32(20))),
@@ -507,7 +510,7 @@ WASM_COMPILED_EXEC_TEST(RefCast) {
                        WASM_REF_CAST(WASM_LOCAL_GET(0), subtype1_index)),
        WASM_END});
 
-  const byte kTestFailed = tester.DefineFunction(
+  const uint8_t kTestFailed = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(supertype_index)},
       {WASM_LOCAL_SET(
            0, WASM_STRUCT_NEW(subtype1_index, WASM_I32V(10), WASM_F32(20))),
@@ -515,19 +518,19 @@ WASM_COMPILED_EXEC_TEST(RefCast) {
                        WASM_REF_CAST(WASM_LOCAL_GET(0), subtype2_index)),
        WASM_END});
 
-  const byte kFuncTestSuccessfulSuper = tester.DefineFunction(
+  const uint8_t kFuncTestSuccessfulSuper = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(function_type_index)},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(function_index)),
        WASM_REF_CAST(WASM_LOCAL_GET(0), function_type_index), WASM_DROP,
        WASM_I32V(0), WASM_END});
 
-  const byte kFuncTestSuccessfulSub = tester.DefineFunction(
+  const uint8_t kFuncTestSuccessfulSub = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(function_type_index)},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(function_index)),
        WASM_REF_CAST(WASM_LOCAL_GET(0), function_subtype1_index), WASM_DROP,
        WASM_I32V(0), WASM_END});
 
-  const byte kFuncTestFailed = tester.DefineFunction(
+  const uint8_t kFuncTestFailed = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(function_type_index)},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(function_index)),
        WASM_REF_CAST(WASM_LOCAL_GET(0), function_subtype2_index), WASM_DROP,
@@ -546,11 +549,11 @@ WASM_COMPILED_EXEC_TEST(RefCastNoChecks) {
                         true);
   WasmGCTester tester(execution_tier);
 
-  const byte supertype_index = tester.DefineStruct({F(kWasmI32, true)});
-  const byte subtype1_index = tester.DefineStruct(
+  const uint8_t supertype_index = tester.DefineStruct({F(kWasmI32, true)});
+  const uint8_t subtype1_index = tester.DefineStruct(
       {F(kWasmI32, true), F(kWasmF32, true)}, supertype_index);
 
-  const byte kTestSuccessful = tester.DefineFunction(
+  const uint8_t kTestSuccessful = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(supertype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype1_index)),
        WASM_STRUCT_GET(subtype1_index, 0,
@@ -563,10 +566,10 @@ WASM_COMPILED_EXEC_TEST(RefCastNoChecks) {
 
 WASM_COMPILED_EXEC_TEST(BrOnCast) {
   WasmGCTester tester(execution_tier);
-  const byte type_index = tester.DefineStruct({F(kWasmI32, true)});
-  const byte other_type_index = tester.DefineStruct({F(kWasmF32, true)});
+  const uint8_t type_index = tester.DefineStruct({F(kWasmI32, true)});
+  const uint8_t other_type_index = tester.DefineStruct({F(kWasmF32, true)});
 
-  const byte kTestStructStatic = tester.DefineFunction(
+  const uint8_t kTestStructStatic = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmI32, kWasmStructRef},
       {WASM_BLOCK_R(
            ValueType::RefNull(type_index), WASM_LOCAL_SET(0, WASM_I32V(111)),
@@ -589,7 +592,7 @@ WASM_COMPILED_EXEC_TEST(BrOnCast) {
        WASM_GC_OP(kExprStructGet), type_index, 0, WASM_LOCAL_GET(0),
        kExprI32Add, kExprEnd});
 
-  const byte kTestStructStaticNull = tester.DefineFunction(
+  const uint8_t kTestStructStaticNull = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmI32, kWasmStructRef},
       {WASM_BLOCK_R(
            ValueType::RefNull(type_index), WASM_LOCAL_SET(0, WASM_I32V(111)),
@@ -612,7 +615,7 @@ WASM_COMPILED_EXEC_TEST(BrOnCast) {
        WASM_GC_OP(kExprStructGet), type_index, 0, WASM_LOCAL_GET(0),
        kExprI32Add, kExprEnd});
 
-  const byte kTestNullDeprecated = tester.DefineFunction(
+  const uint8_t kTestNullDeprecated = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmI32, kWasmStructRef},
       {WASM_BLOCK_R(ValueType::RefNull(type_index),
                     WASM_LOCAL_SET(0, WASM_I32V(111)),
@@ -624,7 +627,7 @@ WASM_COMPILED_EXEC_TEST(BrOnCast) {
                     WASM_LOCAL_SET(0, WASM_I32V(222))),  // Final result.
        WASM_DROP, WASM_LOCAL_GET(0), kExprEnd});
 
-  const byte kTestNull = tester.DefineFunction(
+  const uint8_t kTestNull = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmI32, kWasmStructRef},
       {WASM_BLOCK_R(ValueType::RefNull(type_index),
                     WASM_LOCAL_SET(0, WASM_I32V(111)),
@@ -636,7 +639,7 @@ WASM_COMPILED_EXEC_TEST(BrOnCast) {
        WASM_DROP, WASM_LOCAL_GET(0), kExprEnd});
 
   // "br_on_cast null" also branches on null, treating it as a successful cast.
-  const byte kTestNullNull = tester.DefineFunction(
+  const uint8_t kTestNullNull = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmI32, kWasmStructRef},
       {WASM_BLOCK_R(ValueType::RefNull(type_index),
                     WASM_LOCAL_SET(0, WASM_I32V(111)),
@@ -646,7 +649,7 @@ WASM_COMPILED_EXEC_TEST(BrOnCast) {
                     WASM_GC_OP(kExprRefCast), type_index),
        WASM_DROP, WASM_LOCAL_GET(0), kExprEnd});
 
-  const byte kTypedAfterBranch = tester.DefineFunction(
+  const uint8_t kTypedAfterBranch = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmI32, kWasmStructRef},
       {WASM_LOCAL_SET(1, WASM_STRUCT_NEW(type_index, WASM_I32V(42))),
        WASM_BLOCK_I(
@@ -672,8 +675,8 @@ WASM_COMPILED_EXEC_TEST(BrOnCast) {
 
 WASM_COMPILED_EXEC_TEST(BrOnCastFail) {
   WasmGCTester tester(execution_tier);
-  const byte type0 = tester.DefineStruct({F(kWasmI32, true)});
-  const byte type1 =
+  const uint8_t type0 = tester.DefineStruct({F(kWasmI32, true)});
+  const uint8_t type1 =
       tester.DefineStruct({F(kWasmI64, true), F(kWasmI32, true)});
 
   const int field0_value = 5;
@@ -698,26 +701,26 @@ WASM_COMPILED_EXEC_TEST(BrOnCastFail) {
           WASM_GC_OP(kExprStructGet), type1, 1, kExprReturn),              \
       WASM_I32V(null_value), kExprEnd
 
-  const byte kBranchTaken = tester.DefineFunction(
+  const uint8_t kBranchTaken = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmStructRef},
       {FUNCTION_BODY(
           WASM_STRUCT_NEW(type1, WASM_I64V(10), WASM_I32V(field1_value)))});
 
-  const byte kBranchNotTaken = tester.DefineFunction(
+  const uint8_t kBranchNotTaken = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmStructRef},
       {FUNCTION_BODY(WASM_STRUCT_NEW(type0, WASM_I32V(field0_value)))});
 
-  const byte kNull =
+  const uint8_t kNull =
       tester.DefineFunction(tester.sigs.i_v(), {kWasmStructRef},
                             {FUNCTION_BODY(WASM_REF_NULL(type0))});
 
-  const byte kUnrelatedTypes = tester.DefineFunction(
+  const uint8_t kUnrelatedTypes = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(type1)},
       {FUNCTION_BODY(
           WASM_STRUCT_NEW(type1, WASM_I64V(10), WASM_I32V(field1_value)))});
 #undef FUNCTION_BODY
 
-  const byte kBranchTakenStatic = tester.DefineFunction(
+  const uint8_t kBranchTakenStatic = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmStructRef},
       {WASM_LOCAL_SET(
            0, WASM_STRUCT_NEW(type1, WASM_I64V(10), WASM_I32V(field1_value))),
@@ -739,13 +742,14 @@ WASM_COMPILED_EXEC_TEST(BrOnCastFail) {
 
 WASM_COMPILED_EXEC_TEST(WasmRefEq) {
   WasmGCTester tester(execution_tier);
-  byte type_index = tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
+  uint8_t type_index =
+      tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefTypes[] = {ref(type_index)};
   ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, kRefTypes);
 
-  byte local_index = 0;
-  const byte kFunc = tester.DefineFunction(
+  uint8_t local_index = 0;
+  const uint8_t kFunc = tester.DefineFunction(
       tester.sigs.i_v(), {kRefNullType},
       {WASM_LOCAL_SET(local_index, WASM_STRUCT_NEW(type_index, WASM_I32V(55),
                                                    WASM_I32V(66))),
@@ -777,16 +781,16 @@ WASM_COMPILED_EXEC_TEST(WasmRefEq) {
 WASM_COMPILED_EXEC_TEST(WasmPackedStructU) {
   WasmGCTester tester(execution_tier);
 
-  const byte type_index = tester.DefineStruct(
+  const uint8_t type_index = tester.DefineStruct(
       {F(kWasmI8, true), F(kWasmI16, true), F(kWasmI32, true)});
   ValueType struct_type = refNull(type_index);
 
-  const byte local_index = 0;
+  const uint8_t local_index = 0;
 
   int32_t expected_output_0 = 0x1234;
   int32_t expected_output_1 = -1;
 
-  const byte kF0 = tester.DefineFunction(
+  const uint8_t kF0 = tester.DefineFunction(
       tester.sigs.i_v(), {struct_type},
       {WASM_LOCAL_SET(local_index,
                       WASM_STRUCT_NEW(type_index, WASM_I32V(expected_output_0),
@@ -795,7 +799,7 @@ WASM_COMPILED_EXEC_TEST(WasmPackedStructU) {
        WASM_STRUCT_GET_U(type_index, 0, WASM_LOCAL_GET(local_index)),
        kExprEnd});
 
-  const byte kF1 = tester.DefineFunction(
+  const uint8_t kF1 = tester.DefineFunction(
       tester.sigs.i_v(), {struct_type},
       {WASM_LOCAL_SET(local_index,
                       WASM_STRUCT_NEW(type_index, WASM_I32V(expected_output_0),
@@ -812,16 +816,16 @@ WASM_COMPILED_EXEC_TEST(WasmPackedStructU) {
 WASM_COMPILED_EXEC_TEST(WasmPackedStructS) {
   WasmGCTester tester(execution_tier);
 
-  const byte type_index = tester.DefineStruct(
+  const uint8_t type_index = tester.DefineStruct(
       {F(kWasmI8, true), F(kWasmI16, true), F(kWasmI32, true)});
   ValueType struct_type = refNull(type_index);
 
-  const byte local_index = 0;
+  const uint8_t local_index = 0;
 
   int32_t expected_output_0 = 0x80;
   int32_t expected_output_1 = 42;
 
-  const byte kF0 = tester.DefineFunction(
+  const uint8_t kF0 = tester.DefineFunction(
       tester.sigs.i_v(), {struct_type},
       {WASM_LOCAL_SET(
            local_index,
@@ -830,7 +834,7 @@ WASM_COMPILED_EXEC_TEST(WasmPackedStructS) {
        WASM_STRUCT_GET_S(type_index, 0, WASM_LOCAL_GET(local_index)),
        kExprEnd});
 
-  const byte kF1 = tester.DefineFunction(
+  const uint8_t kF1 = tester.DefineFunction(
       tester.sigs.i_v(), {struct_type},
       {WASM_LOCAL_SET(local_index, WASM_STRUCT_NEW(type_index, WASM_I32V(0x80),
                                                    WASM_I32V(expected_output_1),
@@ -848,16 +852,16 @@ WASM_COMPILED_EXEC_TEST(WasmBasicArray) {
   WasmGCTester tester(execution_tier);
   if (!tester.HasSimdSupport(execution_tier)) return;
 
-  const byte type_index = tester.DefineArray(wasm::kWasmI32, true);
-  const byte fp_type_index = tester.DefineArray(wasm::kWasmF64, true);
-  const byte immut_type_index = tester.DefineArray(wasm::kWasmI32, false);
+  const uint8_t type_index = tester.DefineArray(wasm::kWasmI32, true);
+  const uint8_t fp_type_index = tester.DefineArray(wasm::kWasmF64, true);
+  const uint8_t immut_type_index = tester.DefineArray(wasm::kWasmI32, false);
   ValueType kRefTypes[] = {ref(type_index)};
   FunctionSig sig_q_v(1, 0, kRefTypes);
   ValueType kRefNullType = refNull(type_index);
 
   // f: a = [12, 12, 12]; a[1] = 42; return a[arg0]
-  const byte local_index = 1;
-  const byte kGetElem = tester.DefineFunction(
+  const uint8_t local_index = 1;
+  const uint8_t kGetElem = tester.DefineFunction(
       tester.sigs.i_i(), {kRefNullType},
       {WASM_LOCAL_SET(local_index,
                       WASM_ARRAY_NEW(type_index, WASM_I32V(12), WASM_I32V(3))),
@@ -868,28 +872,28 @@ WASM_COMPILED_EXEC_TEST(WasmBasicArray) {
        kExprEnd});
 
   // Reads and returns an array's length.
-  const byte kGetLength = tester.DefineFunction(
+  const uint8_t kGetLength = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_ARRAY_LEN(WASM_ARRAY_NEW(type_index, WASM_I32V(0), WASM_I32V(42))),
        kExprEnd});
 
   // Create an array of length 2, initialized to [42, 42].
-  const byte kAllocate = tester.DefineFunction(
+  const uint8_t kAllocate = tester.DefineFunction(
       &sig_q_v, {},
       {WASM_ARRAY_NEW(type_index, WASM_I32V(42), WASM_I32V(2)), kExprEnd});
 
-  const byte kAllocateStatic = tester.DefineFunction(
+  const uint8_t kAllocateStatic = tester.DefineFunction(
       &sig_q_v, {},
       {WASM_ARRAY_NEW_DEFAULT(type_index, WASM_I32V(2)), WASM_DROP,
        WASM_ARRAY_NEW(type_index, WASM_I32V(42), WASM_I32V(2)), kExprEnd});
 
-  const byte kInit =
+  const uint8_t kInit =
       tester.DefineFunction(&sig_q_v, {},
                             {WASM_ARRAY_NEW_FIXED(type_index, 3, WASM_I32V(10),
                                                   WASM_I32V(20), WASM_I32V(30)),
                              kExprEnd});
 
-  const byte kImmutable = tester.DefineFunction(
+  const uint8_t kImmutable = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_ARRAY_GET(immut_type_index,
                       WASM_ARRAY_NEW_FIXED(immut_type_index, 2, WASM_I32V(42),
@@ -898,20 +902,20 @@ WASM_COMPILED_EXEC_TEST(WasmBasicArray) {
        kExprEnd});
 
   const uint32_t kLongLength = 1u << 16;
-  const byte kAllocateLarge = tester.DefineFunction(
+  const uint8_t kAllocateLarge = tester.DefineFunction(
       &sig_q_v, {},
       {WASM_ARRAY_NEW_DEFAULT(type_index, WASM_I32V(kLongLength)), kExprEnd});
 
   ArrayType array_type(kWasmI32, true);
   const uint32_t kTooLong = WasmArray::MaxLength(&array_type) + 1;
-  const byte kAllocateTooLarge = tester.DefineFunction(
+  const uint8_t kAllocateTooLarge = tester.DefineFunction(
       &sig_q_v, {},
       {WASM_ARRAY_NEW_DEFAULT(type_index, WASM_I32V(kTooLong)), kExprEnd});
 
   // Tests that fp arrays work properly.
   // f: a = [10.0, 10.0, 10.0]; a[1] = 42.42; return static_cast<int64>(a[1]);
   double result_value = 42.42;
-  const byte kTestFpArray = tester.DefineFunction(
+  const uint8_t kTestFpArray = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(fp_type_index)},
       {WASM_LOCAL_SET(
            0, WASM_ARRAY_NEW(fp_type_index, WASM_F64(10.0), WASM_I32V(3))),
@@ -959,15 +963,15 @@ WASM_COMPILED_EXEC_TEST(WasmBasicArray) {
 
 WASM_COMPILED_EXEC_TEST(WasmPackedArrayU) {
   WasmGCTester tester(execution_tier);
-  const byte array_index = tester.DefineArray(kWasmI8, true);
+  const uint8_t array_index = tester.DefineArray(kWasmI8, true);
   ValueType array_type = refNull(array_index);
 
-  const byte param_index = 0;
-  const byte local_index = 1;
+  const uint8_t param_index = 0;
+  const uint8_t local_index = 1;
 
   int32_t expected_output_3 = 258;
 
-  const byte kF = tester.DefineFunction(
+  const uint8_t kF = tester.DefineFunction(
       tester.sigs.i_i(), {array_type},
       {WASM_LOCAL_SET(local_index,
                       WASM_ARRAY_NEW(array_index, WASM_I32V(0), WASM_I32V(4))),
@@ -993,14 +997,14 @@ WASM_COMPILED_EXEC_TEST(WasmPackedArrayU) {
 
 WASM_COMPILED_EXEC_TEST(WasmPackedArrayS) {
   WasmGCTester tester(execution_tier);
-  const byte array_index = tester.DefineArray(kWasmI16, true);
+  const uint8_t array_index = tester.DefineArray(kWasmI16, true);
   ValueType array_type = refNull(array_index);
 
   int32_t array_elements[] = {0x12345678, 10, 0xFEDC, 0xFF1234};
 
-  const byte param_index = 0;
-  const byte local_index = 1;
-  const byte kF = tester.DefineFunction(
+  const uint8_t param_index = 0;
+  const uint8_t local_index = 1;
+  const uint8_t kF = tester.DefineFunction(
       tester.sigs.i_i(), {array_type},
       {WASM_LOCAL_SET(local_index,
                       WASM_ARRAY_NEW(array_index, WASM_I32V(array_elements[0]),
@@ -1027,12 +1031,13 @@ WASM_COMPILED_EXEC_TEST(WasmPackedArrayS) {
 
 WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
   WasmGCTester tester(execution_tier);
-  const byte array32_index = tester.DefineArray(kWasmI32, true);
-  const byte array16_index = tester.DefineArray(kWasmI16, true);
-  const byte arrayref_index = tester.DefineArray(refNull(array32_index), true);
+  const uint8_t array32_index = tester.DefineArray(kWasmI32, true);
+  const uint8_t array16_index = tester.DefineArray(kWasmI16, true);
+  const uint8_t arrayref_index =
+      tester.DefineArray(refNull(array32_index), true);
 
   // Copies i32 ranges: local1[0..3] to local2[6..9].
-  const byte kCopyI32 = tester.DefineFunction(
+  const uint8_t kCopyI32 = tester.DefineFunction(
       tester.sigs.i_i(), {refNull(array32_index), refNull(array32_index)},
       {WASM_LOCAL_SET(1, WASM_ARRAY_NEW_DEFAULT(array32_index, WASM_I32V(10))),
        WASM_ARRAY_SET(array32_index, WASM_LOCAL_GET(1), WASM_I32V(0),
@@ -1051,7 +1056,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
        kExprEnd});
 
   // Copies i16 ranges: local1[0..3] to local2[6..9].
-  const byte kCopyI16 = tester.DefineFunction(
+  const uint8_t kCopyI16 = tester.DefineFunction(
       tester.sigs.i_i(), {refNull(array16_index), refNull(array16_index)},
       {WASM_LOCAL_SET(1, WASM_ARRAY_NEW_DEFAULT(array16_index, WASM_I32V(10))),
        WASM_ARRAY_SET(array16_index, WASM_LOCAL_GET(1), WASM_I32V(0),
@@ -1070,7 +1075,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
        kExprEnd});
 
   // Copies reference ranges: local1[0..3] to local2[6..9].
-  const byte kCopyRef = tester.DefineFunction(
+  const uint8_t kCopyRef = tester.DefineFunction(
       FunctionSig::Build(tester.zone(), {refNull(array32_index)}, {kWasmI32}),
       {refNull(arrayref_index), refNull(arrayref_index)},
       {WASM_LOCAL_SET(1, WASM_ARRAY_NEW_DEFAULT(arrayref_index, WASM_I32V(10))),
@@ -1090,7 +1095,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
        kExprEnd});
 
   // Copies overlapping reference ranges: local1[0..3] to local1[2..5].
-  const byte kCopyRefOverlapping = tester.DefineFunction(
+  const uint8_t kCopyRefOverlapping = tester.DefineFunction(
       FunctionSig::Build(tester.zone(), {refNull(array32_index)}, {kWasmI32}),
       {refNull(arrayref_index)},
       {WASM_LOCAL_SET(1, WASM_ARRAY_NEW_DEFAULT(arrayref_index, WASM_I32V(10))),
@@ -1108,7 +1113,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
        WASM_ARRAY_GET(arrayref_index, WASM_LOCAL_GET(1), WASM_LOCAL_GET(0)),
        kExprEnd});
 
-  const byte kOobSource = tester.DefineFunction(
+  const uint8_t kOobSource = tester.DefineFunction(
       tester.sigs.v_v(), {refNull(array32_index), refNull(array32_index)},
       {WASM_LOCAL_SET(0, WASM_ARRAY_NEW_DEFAULT(array32_index, WASM_I32V(10))),
        WASM_LOCAL_SET(1, WASM_ARRAY_NEW_DEFAULT(array32_index, WASM_I32V(10))),
@@ -1117,7 +1122,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
                        WASM_I32V(4)),
        kExprEnd});
 
-  const byte kOobDestination = tester.DefineFunction(
+  const uint8_t kOobDestination = tester.DefineFunction(
       tester.sigs.v_v(), {refNull(array32_index), refNull(array32_index)},
       {WASM_LOCAL_SET(0, WASM_ARRAY_NEW_DEFAULT(array32_index, WASM_I32V(10))),
        WASM_LOCAL_SET(1, WASM_ARRAY_NEW_DEFAULT(array32_index, WASM_I32V(10))),
@@ -1126,7 +1131,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
                        WASM_I32V(5)),
        kExprEnd});
 
-  const byte kZeroLength = tester.DefineFunction(
+  const uint8_t kZeroLength = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(arrayref_index), refNull(arrayref_index)},
       {WASM_LOCAL_SET(0, WASM_ARRAY_NEW_DEFAULT(arrayref_index, WASM_I32V(10))),
        WASM_LOCAL_SET(1, WASM_ARRAY_NEW_DEFAULT(arrayref_index, WASM_I32V(10))),
@@ -1185,13 +1190,13 @@ WASM_COMPILED_EXEC_TEST(NewDefault) {
   if (!tester.HasSimdSupport(execution_tier)) return;
 
   tester.builder()->StartRecursiveTypeGroup();
-  const byte struct_type = tester.DefineStruct(
+  const uint8_t struct_type = tester.DefineStruct(
       {F(wasm::kWasmI32, true), F(wasm::kWasmF64, true), F(refNull(0), true)});
   tester.builder()->EndRecursiveTypeGroup();
 
-  const byte array_type = tester.DefineArray(wasm::kWasmI32, true);
+  const uint8_t array_type = tester.DefineArray(wasm::kWasmI32, true);
   // Returns: struct[0] + f64_to_i32(struct[1]) + (struct[2].is_null ^ 1) == 0.
-  const byte allocate_struct = tester.DefineFunction(
+  const uint8_t allocate_struct = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(struct_type)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(struct_type)),
        WASM_I32_ADD(
@@ -1202,7 +1207,7 @@ WASM_COMPILED_EXEC_TEST(NewDefault) {
                             WASM_STRUCT_GET(struct_type, 2, WASM_LOCAL_GET(0))),
                         WASM_I32V(1))),
        kExprEnd});
-  const byte allocate_array = tester.DefineFunction(
+  const uint8_t allocate_array = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(array_type)},
       {WASM_LOCAL_SET(0, WASM_ARRAY_NEW_DEFAULT(array_type, WASM_I32V(2))),
        WASM_I32_ADD(
@@ -1218,84 +1223,84 @@ WASM_COMPILED_EXEC_TEST(NewDefault) {
 
 WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
   WasmGCTester tester(execution_tier);
-  byte type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
-  byte subtype_index = tester.DefineStruct(
+  uint8_t type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
+  uint8_t subtype_index = tester.DefineStruct(
       {F(wasm::kWasmI32, true), F(wasm::kWasmS128, true)}, type_index);
   ValueType sig_types[] = {kWasmS128, kWasmI32, kWasmF64};
   FunctionSig sig(1, 2, sig_types);
-  byte sig_index = tester.DefineSignature(&sig);
+  uint8_t sig_index = tester.DefineSignature(&sig);
 
-  const byte kRefTestNullDeprecated = tester.DefineFunction(
+  const uint8_t kRefTestNullDeprecated = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_TEST_DEPRECATED(WASM_REF_NULL(type_index), subtype_index),
        kExprEnd});
   // Upcasts should be optimized away for nominal types.
-  const byte kRefTestUpcastDeprecated = tester.DefineFunction(
+  const uint8_t kRefTestUpcastDeprecated = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_TEST_DEPRECATED(WASM_STRUCT_NEW_DEFAULT(subtype_index),
                                 type_index),
        kExprEnd});
-  const byte kRefTestUpcastNullDeprecated = tester.DefineFunction(
+  const uint8_t kRefTestUpcastNullDeprecated = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_TEST_DEPRECATED(WASM_REF_NULL(subtype_index), type_index),
        kExprEnd});
-  const byte kRefTestUnrelatedNullableDeprecated = tester.DefineFunction(
+  const uint8_t kRefTestUnrelatedNullableDeprecated = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
        WASM_REF_TEST_DEPRECATED(WASM_LOCAL_GET(0), sig_index), kExprEnd});
-  const byte kRefTestUnrelatedNullDeprecated = tester.DefineFunction(
+  const uint8_t kRefTestUnrelatedNullDeprecated = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_TEST_DEPRECATED(WASM_REF_NULL(subtype_index), sig_index),
        kExprEnd});
-  const byte kRefTestUnrelatedNonNullableDeprecated = tester.DefineFunction(
+  const uint8_t kRefTestUnrelatedNonNullableDeprecated = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_TEST_DEPRECATED(WASM_STRUCT_NEW_DEFAULT(type_index), sig_index),
        kExprEnd});
 
-  const byte kRefCastNullDeprecated =
+  const uint8_t kRefCastNullDeprecated =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_IS_NULL(WASM_REF_CAST_DEPRECATED(
                                  WASM_REF_NULL(type_index), subtype_index)),
                              kExprEnd});
-  const byte kRefCastNull =
+  const uint8_t kRefCastNull =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_IS_NULL(WASM_REF_CAST(
                                  WASM_REF_NULL(type_index), subtype_index)),
                              kExprEnd});
-  const byte kRefCastUpcast = tester.DefineFunction(
+  const uint8_t kRefCastUpcast = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(
            WASM_REF_CAST(WASM_STRUCT_NEW_DEFAULT(subtype_index), type_index)),
        kExprEnd});
-  const byte kRefCastUpcastNullDeprecated =
+  const uint8_t kRefCastUpcastNullDeprecated =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_IS_NULL(WASM_REF_CAST_DEPRECATED(
                                  WASM_REF_NULL(subtype_index), type_index)),
                              kExprEnd});
-  const byte kRefCastUpcastNull =
+  const uint8_t kRefCastUpcastNull =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_IS_NULL(WASM_REF_CAST(
                                  WASM_REF_NULL(subtype_index), type_index)),
                              kExprEnd});
   // Note: Casting of types from different type hierarchies is only valid for
   // the deprecated cast instruction.
-  const byte kRefCastUnrelatedNullable = tester.DefineFunction(
+  const uint8_t kRefCastUnrelatedNullable = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
        WASM_REF_IS_NULL(WASM_REF_CAST_DEPRECATED(WASM_LOCAL_GET(0), sig_index)),
        kExprEnd});
-  const byte kRefCastUnrelatedNull =
+  const uint8_t kRefCastUnrelatedNull =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_IS_NULL(WASM_REF_CAST_DEPRECATED(
                                  WASM_REF_NULL(subtype_index), sig_index)),
                              kExprEnd});
-  const byte kRefCastUnrelatedNonNullable = tester.DefineFunction(
+  const uint8_t kRefCastUnrelatedNonNullable = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_CAST_DEPRECATED(
            WASM_STRUCT_NEW_DEFAULT(type_index), sig_index)),
        kExprEnd});
 
-  const byte kBrOnCastNull = tester.DefineFunction(
+  const uint8_t kBrOnCastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(subtype_index), WASM_REF_NULL(type_index),
                     WASM_BR_ON_CAST(0, type_index, subtype_index), WASM_DROP,
@@ -1304,21 +1309,21 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
 
   // Real upcasts are invalid for br_on_cast. Casting to the same type is
   // however similar to an upcast.
-  const byte kBrOnCastUpcast = tester.DefineFunction(
+  const uint8_t kBrOnCastUpcast = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(type_index), WASM_STRUCT_NEW_DEFAULT(type_index),
                     WASM_BR_ON_CAST(0, type_index, type_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastUpcastNull = tester.DefineFunction(
+  const uint8_t kBrOnCastUpcastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(type_index), WASM_REF_NULL(type_index),
                     WASM_BR_ON_CAST(0, type_index, type_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastUnrelatedNullable = tester.DefineFunction(
+  const uint8_t kBrOnCastUnrelatedNullable = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
        WASM_BLOCK_R(refNull(sig_index), WASM_LOCAL_GET(0),
@@ -1326,21 +1331,21 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastUnrelatedNull = tester.DefineFunction(
+  const uint8_t kBrOnCastUnrelatedNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(sig_index), WASM_REF_NULL(subtype_index),
                     WASM_BR_ON_CAST_DEPRECATED(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastUnrelatedNonNullable = tester.DefineFunction(
+  const uint8_t kBrOnCastUnrelatedNonNullable = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(sig_index), WASM_STRUCT_NEW_DEFAULT(subtype_index),
                     WASM_BR_ON_CAST_DEPRECATED(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastFailNull = tester.DefineFunction(
+  const uint8_t kBrOnCastFailNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(type_index), WASM_REF_NULL(type_index),
                     WASM_BR_ON_CAST_FAIL(0, type_index, subtype_index),
@@ -1349,7 +1354,7 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
 
   // Real upcasts are invalid for br_on_cast. Casting to the same type is
   // however similar to an upcast.
-  const byte kBrOnCastFailUpcast = tester.DefineFunction(
+  const uint8_t kBrOnCastFailUpcast = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(subtype_index),
                     WASM_STRUCT_NEW_DEFAULT(subtype_index),
@@ -1357,14 +1362,14 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
                     WASM_DROP, WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastFailUpcastNull = tester.DefineFunction(
+  const uint8_t kBrOnCastFailUpcastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(subtype_index), WASM_REF_NULL(subtype_index),
                     WASM_BR_ON_CAST_FAIL(0, subtype_index, subtype_index),
                     WASM_DROP, WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastFailUnrelatedNullable = tester.DefineFunction(
+  const uint8_t kBrOnCastFailUnrelatedNullable = tester.DefineFunction(
       tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
        WASM_BLOCK_R(refNull(subtype_index), WASM_LOCAL_GET(0),
@@ -1372,14 +1377,14 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastFailUnrelatedNull = tester.DefineFunction(
+  const uint8_t kBrOnCastFailUnrelatedNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(subtype_index), WASM_REF_NULL(subtype_index),
                     WASM_BR_ON_CAST_FAIL_DEPRECATED(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
-  const byte kBrOnCastFailUnrelatedNonNullable = tester.DefineFunction(
+  const uint8_t kBrOnCastFailUnrelatedNonNullable = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_BLOCK_R(refNull(subtype_index),
                     WASM_STRUCT_NEW_DEFAULT(subtype_index),
@@ -1423,62 +1428,62 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
 WASM_COMPILED_EXEC_TEST(TrivialAbstractCasts) {
   // TODO(7748): Add tests for branch_on_*.
   WasmGCTester tester(execution_tier);
-  byte type_index = tester.DefineArray(wasm::kWasmI32, true);
-  byte struct_type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
+  uint8_t type_index = tester.DefineArray(wasm::kWasmI32, true);
+  uint8_t struct_type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
   ValueType sig_types[] = {kWasmS128, kWasmI32, kWasmF64};
   FunctionSig sig(1, 2, sig_types);
 
-  const byte kIsArrayNull = tester.DefineFunction(
+  const uint8_t kIsArrayNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_ARRAY(WASM_REF_NULL(kAnyRefCode)), kExprEnd});
-  const byte kIsArrayUpcast = tester.DefineFunction(
+  const uint8_t kIsArrayUpcast = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_ARRAY(WASM_ARRAY_NEW_DEFAULT(type_index, WASM_I32V(10))),
        kExprEnd});
-  const byte kIsArrayUpcastNullable = tester.DefineFunction(
+  const uint8_t kIsArrayUpcastNullable = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(type_index)},
       {WASM_LOCAL_SET(0, WASM_ARRAY_NEW_DEFAULT(type_index, WASM_I32V(10))),
        WASM_REF_IS_ARRAY(WASM_LOCAL_GET(0)), kExprEnd});
-  const byte kIsArrayUpcastNull = tester.DefineFunction(
+  const uint8_t kIsArrayUpcastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_ARRAY(WASM_REF_NULL(type_index)), kExprEnd});
-  const byte kIsArrayUnrelated = tester.DefineFunction(
+  const uint8_t kIsArrayUnrelated = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(struct_type_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(struct_type_index)),
        WASM_REF_IS_ARRAY(WASM_LOCAL_GET(0)), kExprEnd});
-  const byte kIsArrayUnrelatedNull = tester.DefineFunction(
+  const uint8_t kIsArrayUnrelatedNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_ARRAY(WASM_REF_NULL(kI31RefCode)), kExprEnd});
-  const byte kIsArrayUnrelatedNonNullable = tester.DefineFunction(
+  const uint8_t kIsArrayUnrelatedNonNullable = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_ARRAY(WASM_I31_NEW(WASM_I32V(10))), kExprEnd});
 
-  const byte kAsArrayNull = tester.DefineFunction(
+  const uint8_t kAsArrayNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(WASM_REF_NULL(kAnyRefCode))),
        kExprEnd});
-  const byte kAsArrayUpcast = tester.DefineFunction(
+  const uint8_t kAsArrayUpcast = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(
            WASM_ARRAY_NEW_DEFAULT(type_index, WASM_I32V(10)))),
        kExprEnd});
-  const byte kAsArrayUpcastNullable = tester.DefineFunction(
+  const uint8_t kAsArrayUpcastNullable = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(type_index)},
       {WASM_LOCAL_SET(0, WASM_ARRAY_NEW_DEFAULT(type_index, WASM_I32V(10))),
        WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(WASM_LOCAL_GET(0))), kExprEnd});
-  const byte kAsArrayUpcastNull = tester.DefineFunction(
+  const uint8_t kAsArrayUpcastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(WASM_REF_NULL(type_index))),
        kExprEnd});
-  const byte kAsArrayUnrelated = tester.DefineFunction(
+  const uint8_t kAsArrayUnrelated = tester.DefineFunction(
       tester.sigs.i_v(), {ValueType::RefNull(struct_type_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(struct_type_index)),
        WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(WASM_LOCAL_GET(0))), kExprEnd});
-  const byte kAsArrayUnrelatedNull = tester.DefineFunction(
+  const uint8_t kAsArrayUnrelatedNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(WASM_REF_NULL(kI31RefCode))),
        kExprEnd});
-  const byte kAsArrayUnrelatedNonNullable = tester.DefineFunction(
+  const uint8_t kAsArrayUnrelatedNonNullable = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(WASM_I31_NEW(WASM_I32V(10)))),
        kExprEnd});
@@ -1505,11 +1510,11 @@ WASM_COMPILED_EXEC_TEST(TrivialAbstractCasts) {
 WASM_COMPILED_EXEC_TEST(ArrayNewMap) {
   WasmGCTester tester(execution_tier);
 
-  const byte type_index = tester.DefineArray(kWasmI32, true);
+  const uint8_t type_index = tester.DefineArray(kWasmI32, true);
 
   ValueType array_type = ValueType::Ref(type_index);
   FunctionSig sig(1, 0, &array_type);
-  const byte array_new = tester.DefineFunction(
+  const uint8_t array_new = tester.DefineFunction(
       &sig, {},
       {WASM_ARRAY_NEW(type_index, WASM_I32V(10), WASM_I32V(42)), kExprEnd});
 
@@ -1522,11 +1527,11 @@ WASM_COMPILED_EXEC_TEST(ArrayNewMap) {
 
 WASM_COMPILED_EXEC_TEST(FunctionRefs) {
   WasmGCTester tester(execution_tier);
-  const byte func_index =
+  const uint8_t func_index =
       tester.DefineFunction(tester.sigs.i_v(), {}, {WASM_I32V(42), kExprEnd});
-  const byte sig_index = 0;
+  const uint8_t sig_index = 0;
 
-  const byte other_sig_index = tester.DefineSignature(tester.sigs.d_d());
+  const uint8_t other_sig_index = tester.DefineSignature(tester.sigs.d_d());
 
   // This is just so func_index counts as "declared".
   tester.AddGlobal(ValueType::RefNull(sig_index), false,
@@ -1535,30 +1540,30 @@ WASM_COMPILED_EXEC_TEST(FunctionRefs) {
   ValueType func_type = ValueType::RefNull(sig_index);
   FunctionSig sig_func(1, 0, &func_type);
 
-  const byte cast = tester.DefineFunction(
+  const uint8_t cast = tester.DefineFunction(
       &sig_func, {kWasmFuncRef},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(func_index)),
        WASM_REF_CAST(WASM_LOCAL_GET(0), sig_index), kExprEnd});
 
-  const byte cast_reference = tester.DefineFunction(
+  const uint8_t cast_reference = tester.DefineFunction(
       &sig_func, {}, {WASM_REF_FUNC(sig_index), kExprEnd});
 
-  const byte test_deprecated = tester.DefineFunction(
+  const uint8_t test_deprecated = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmFuncRef},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(func_index)),
        WASM_REF_TEST_DEPRECATED(WASM_LOCAL_GET(0), sig_index), kExprEnd});
 
-  const byte test_fail_deprecated = tester.DefineFunction(
+  const uint8_t test_fail_deprecated = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmFuncRef},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(func_index)),
        WASM_REF_TEST_DEPRECATED(WASM_LOCAL_GET(0), other_sig_index), kExprEnd});
 
-  const byte test = tester.DefineFunction(
+  const uint8_t test = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmFuncRef},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(func_index)),
        WASM_REF_TEST(WASM_LOCAL_GET(0), sig_index), kExprEnd});
 
-  const byte test_fail = tester.DefineFunction(
+  const uint8_t test_fail = tester.DefineFunction(
       tester.sigs.i_v(), {kWasmFuncRef},
       {WASM_LOCAL_SET(0, WASM_REF_FUNC(func_index)),
        WASM_REF_TEST(WASM_LOCAL_GET(0), other_sig_index), kExprEnd});
@@ -1588,11 +1593,11 @@ WASM_COMPILED_EXEC_TEST(FunctionRefs) {
 
 WASM_COMPILED_EXEC_TEST(CallRef) {
   WasmGCTester tester(execution_tier);
-  byte sig_index = tester.DefineSignature(tester.sigs.i_ii());
-  byte callee = tester.DefineFunction(
+  uint8_t sig_index = tester.DefineSignature(tester.sigs.i_ii());
+  uint8_t callee = tester.DefineFunction(
       sig_index, {},
       {WASM_I32_ADD(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)), kExprEnd});
-  byte caller =
+  uint8_t caller =
       tester.DefineFunction(tester.sigs.i_i(), {},
                             {WASM_CALL_REF(WASM_REF_FUNC(callee), sig_index,
                                            WASM_I32V(42), WASM_LOCAL_GET(0)),
@@ -1629,19 +1634,19 @@ WASM_COMPILED_EXEC_TEST(CallAbstractNullTypeImplicitConversion) {
   for (auto [super_type, sub_type_code] : null_ref_types) {
     CHECK(super_type.is_nullable());
     WasmGCTester tester(execution_tier);
-    byte struct_idx = tester.DefineStruct({F(wasm::kWasmI32, true)});
+    uint8_t struct_idx = tester.DefineStruct({F(wasm::kWasmI32, true)});
     CHECK_EQ(struct_idx, 0);
-    byte array_idx = tester.DefineArray(kWasmI32, true);
+    uint8_t array_idx = tester.DefineArray(kWasmI32, true);
     CHECK_EQ(array_idx, 1);
     FunctionSig dummySig(1, 0, &kWasmI32);
-    byte signature_idx = tester.DefineSignature(&dummySig);
+    uint8_t signature_idx = tester.DefineSignature(&dummySig);
     CHECK_EQ(signature_idx, 2);
 
     ValueType ref_sig_types[] = {kWasmI32, super_type};
     FunctionSig sig_ref(1, 1, ref_sig_types);
-    byte callee = tester.DefineFunction(
+    uint8_t callee = tester.DefineFunction(
         &sig_ref, {}, {WASM_REF_IS_NULL(WASM_LOCAL_GET(0)), kExprEnd});
-    byte caller = tester.DefineFunction(
+    uint8_t caller = tester.DefineFunction(
         tester.sigs.i_v(), {},
         {WASM_CALL_FUNCTION(callee, WASM_REF_NULL(sub_type_code)), kExprEnd});
 
@@ -1652,23 +1657,23 @@ WASM_COMPILED_EXEC_TEST(CallAbstractNullTypeImplicitConversion) {
 
 WASM_COMPILED_EXEC_TEST(CastNullRef) {
   WasmGCTester tester(execution_tier);
-  byte to_non_null = tester.DefineFunction(
+  uint8_t to_non_null = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_NON_NULL(WASM_REF_NULL(kNoneCode))),
        kExprEnd});
-  byte to_array = tester.DefineFunction(
+  uint8_t to_array = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_ARRAY(WASM_REF_NULL(kNoneCode))),
        kExprEnd});
-  byte to_struct = tester.DefineFunction(
+  uint8_t to_struct = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_STRUCT(WASM_REF_NULL(kNoneCode))),
        kExprEnd});
-  byte to_i31 = tester.DefineFunction(
+  uint8_t to_i31 = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_AS_I31(WASM_REF_NULL(kNoneCode))), kExprEnd});
-  byte struct_idx = tester.DefineStruct({F(wasm::kWasmI32, true)});
-  byte to_struct_idx = tester.DefineFunction(
+  uint8_t struct_idx = tester.DefineStruct({F(wasm::kWasmI32, true)});
+  uint8_t to_struct_idx = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_REF_CAST(WASM_REF_NULL(kNoneCode), struct_idx)),
        kExprEnd});
@@ -1684,12 +1689,12 @@ WASM_COMPILED_EXEC_TEST(CastNullRef) {
 
 WASM_COMPILED_EXEC_TEST(CallReftypeParameters) {
   WasmGCTester tester(execution_tier);
-  byte type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
+  uint8_t type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
   ValueType kRefType{refNull(type_index)};
   ValueType sig_types[] = {kWasmI32, kRefType, kRefType, kRefType, kRefType,
                            kWasmI32, kWasmI32, kWasmI32, kWasmI32};
   FunctionSig sig(1, 8, sig_types);
-  byte adder = tester.DefineFunction(
+  uint8_t adder = tester.DefineFunction(
       &sig, {},
       {WASM_I32_ADD(
            WASM_STRUCT_GET(type_index, 0, WASM_LOCAL_GET(0)),
@@ -1705,7 +1710,7 @@ WASM_COMPILED_EXEC_TEST(CallReftypeParameters) {
                                         WASM_I32_ADD(WASM_LOCAL_GET(6),
                                                      WASM_LOCAL_GET(7)))))))),
        kExprEnd});
-  byte caller = tester.DefineFunction(
+  uint8_t caller = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_CALL_FUNCTION(adder, WASM_STRUCT_NEW(type_index, WASM_I32V(2)),
                           WASM_STRUCT_NEW(type_index, WASM_I32V(4)),
@@ -1722,35 +1727,35 @@ WASM_COMPILED_EXEC_TEST(CallReftypeParameters) {
 WASM_COMPILED_EXEC_TEST(AbstractTypeChecks) {
   WasmGCTester tester(execution_tier);
 
-  byte array_index = tester.DefineArray(kWasmI32, true);
-  byte struct_index = tester.DefineStruct({F(kWasmI32, true)});
-  byte function_index =
+  uint8_t array_index = tester.DefineArray(kWasmI32, true);
+  uint8_t struct_index = tester.DefineStruct({F(kWasmI32, true)});
+  uint8_t function_index =
       tester.DefineFunction(tester.sigs.v_v(), {}, {kExprEnd});
-  byte sig_index = 2;
+  uint8_t sig_index = 2;
 
   // This is just so func_index counts as "declared".
   tester.AddGlobal(ValueType::RefNull(sig_index), false,
                    WasmInitExpr::RefFuncConst(function_index));
 
-  byte kStructCheckNull = tester.DefineFunction(
+  uint8_t kStructCheckNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_STRUCT(WASM_REF_NULL(kAnyRefCode)), kExprEnd});
-  byte kArrayCheckNull = tester.DefineFunction(
+  uint8_t kArrayCheckNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_ARRAY(WASM_REF_NULL(kAnyRefCode)), kExprEnd});
-  byte kI31CheckNull = tester.DefineFunction(
+  uint8_t kI31CheckNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_I31(WASM_REF_NULL(kAnyRefCode)), kExprEnd});
 
-  byte kStructCastNull =
+  uint8_t kStructCastNull =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_AS_STRUCT(WASM_REF_NULL(kAnyRefCode)),
                              WASM_DROP, WASM_I32V(1), kExprEnd});
-  byte kArrayCastNull =
+  uint8_t kArrayCastNull =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_AS_ARRAY(WASM_REF_NULL(kAnyRefCode)),
                              WASM_DROP, WASM_I32V(1), kExprEnd});
-  byte kI31CastNull =
+  uint8_t kI31CastNull =
       tester.DefineFunction(tester.sigs.i_v(), {},
                             {WASM_REF_AS_I31(WASM_REF_NULL(kAnyRefCode)),
                              WASM_DROP, WASM_I32V(1), kExprEnd});
@@ -1760,15 +1765,15 @@ WASM_COMPILED_EXEC_TEST(AbstractTypeChecks) {
                         {WASM_LOCAL_SET(0, WASM_SEQ(value)), \
                          WASM_REF_IS_##type(WASM_LOCAL_GET(0)), kExprEnd})
 
-  byte kStructCheckSuccess =
+  uint8_t kStructCheckSuccess =
       TYPE_CHECK(STRUCT, WASM_STRUCT_NEW_DEFAULT(struct_index));
-  byte kStructCheckFailure = TYPE_CHECK(STRUCT, WASM_I31_NEW(WASM_I32V(42)));
-  byte kArrayCheckSuccess =
+  uint8_t kStructCheckFailure = TYPE_CHECK(STRUCT, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kArrayCheckSuccess =
       TYPE_CHECK(ARRAY, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
-  byte kArrayCheckFailure =
+  uint8_t kArrayCheckFailure =
       TYPE_CHECK(ARRAY, WASM_STRUCT_NEW_DEFAULT(struct_index));
-  byte kI31CheckSuccess = TYPE_CHECK(I31, WASM_I31_NEW(WASM_I32V(42)));
-  byte kI31CheckFailure =
+  uint8_t kI31CheckSuccess = TYPE_CHECK(I31, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kI31CheckFailure =
       TYPE_CHECK(I31, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
 #undef TYPE_CHECK
 
@@ -1778,14 +1783,14 @@ WASM_COMPILED_EXEC_TEST(AbstractTypeChecks) {
                          WASM_REF_AS_##type(WASM_LOCAL_GET(0)), WASM_DROP, \
                          WASM_I32V(1), kExprEnd})
 
-  byte kStructCastSuccess =
+  uint8_t kStructCastSuccess =
       TYPE_CAST(STRUCT, WASM_STRUCT_NEW_DEFAULT(struct_index));
-  byte kStructCastFailure = TYPE_CAST(STRUCT, WASM_I31_NEW(WASM_I32V(42)));
-  byte kArrayCastSuccess =
+  uint8_t kStructCastFailure = TYPE_CAST(STRUCT, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kArrayCastSuccess =
       TYPE_CAST(ARRAY, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
-  byte kArrayCastFailure = TYPE_CAST(ARRAY, WASM_I31_NEW(WASM_I32V(42)));
-  byte kI31CastSuccess = TYPE_CAST(I31, WASM_I31_NEW(WASM_I32V(42)));
-  byte kI31CastFailure =
+  uint8_t kArrayCastFailure = TYPE_CAST(ARRAY, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kI31CastSuccess = TYPE_CAST(I31, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kI31CastFailure =
       TYPE_CAST(I31, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
 #undef TYPE_CAST
 
@@ -1800,14 +1805,14 @@ WASM_COMPILED_EXEC_TEST(AbstractTypeChecks) {
                                        WASM_RETURN(WASM_I32V(0)))),         \
        kExprEnd})
 
-  byte kBrOnStructTaken =
+  uint8_t kBrOnStructTaken =
       BR_ON(STRUCT, Struct, WASM_STRUCT_NEW_DEFAULT(struct_index));
-  byte kBrOnStructNotTaken = BR_ON(STRUCT, Struct, WASM_REF_NULL(kNoneCode));
-  byte kBrOnArrayTaken =
+  uint8_t kBrOnStructNotTaken = BR_ON(STRUCT, Struct, WASM_REF_NULL(kNoneCode));
+  uint8_t kBrOnArrayTaken =
       BR_ON(ARRAY, Array, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
-  byte kBrOnArrayNotTaken = BR_ON(ARRAY, Array, WASM_I31_NEW(WASM_I32V(42)));
-  byte kBrOnI31Taken = BR_ON(I31, I31, WASM_I31_NEW(WASM_I32V(42)));
-  byte kBrOnI31NotTaken =
+  uint8_t kBrOnArrayNotTaken = BR_ON(ARRAY, Array, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kBrOnI31Taken = BR_ON(I31, I31, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kBrOnI31NotTaken =
       BR_ON(I31, I31, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
 #undef BR_ON
 
@@ -1822,16 +1827,17 @@ WASM_COMPILED_EXEC_TEST(AbstractTypeChecks) {
                                        WASM_RETURN(WASM_I32V(1)))),    \
        kExprEnd})
 
-  byte kBrOnNonStructNotTaken =
+  uint8_t kBrOnNonStructNotTaken =
       BR_ON_NON(STRUCT, Struct, WASM_STRUCT_NEW_DEFAULT(struct_index));
-  byte kBrOnNonStructTaken =
+  uint8_t kBrOnNonStructTaken =
       BR_ON_NON(STRUCT, Struct, WASM_REF_NULL(kNoneCode));
-  byte kBrOnNonArrayNotTaken = BR_ON_NON(
+  uint8_t kBrOnNonArrayNotTaken = BR_ON_NON(
       ARRAY, Array, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
-  byte kBrOnNonArrayTaken =
+  uint8_t kBrOnNonArrayTaken =
       BR_ON_NON(ARRAY, Array, WASM_I31_NEW(WASM_I32V(42)));
-  byte kBrOnNonI31NotTaken = BR_ON_NON(I31, I31, WASM_I31_NEW(WASM_I32V(42)));
-  byte kBrOnNonI31Taken =
+  uint8_t kBrOnNonI31NotTaken =
+      BR_ON_NON(I31, I31, WASM_I31_NEW(WASM_I32V(42)));
+  uint8_t kBrOnNonI31Taken =
       BR_ON_NON(I31, I31, WASM_ARRAY_NEW_DEFAULT(array_index, WASM_I32V(10)));
 #undef BR_ON_NON
 
@@ -1880,20 +1886,20 @@ WASM_COMPILED_EXEC_TEST(AbstractTypeChecks) {
 // be modified (made to run longer) to measure performance of casts.
 WASM_COMPILED_EXEC_TEST(CastsBenchmark) {
   WasmGCTester tester(execution_tier);
-  const byte SuperType = tester.DefineStruct({F(wasm::kWasmI32, true)});
-  const byte SubType = tester.DefineStruct(
+  const uint8_t SuperType = tester.DefineStruct({F(wasm::kWasmI32, true)});
+  const uint8_t SubType = tester.DefineStruct(
       {F(wasm::kWasmI32, true), F(wasm::kWasmI32, true)}, SuperType);
 
-  const byte ListType = tester.DefineArray(kWasmStructRef, true);
+  const uint8_t ListType = tester.DefineArray(kWasmStructRef, true);
 
-  const byte List =
+  const uint8_t List =
       tester.AddGlobal(ValueType::RefNull(ListType), true,
                        WasmInitExpr::RefNullConst(
                            static_cast<HeapType::Representation>(ListType)));
 
   const uint32_t kListLength = 1024;
   const uint32_t i = 0;
-  const byte Prepare = tester.DefineFunction(
+  const uint8_t Prepare = tester.DefineFunction(
       tester.sigs.i_v(), {wasm::kWasmI32},
       {// List = new eqref[kListLength];
        WASM_GLOBAL_SET(
@@ -1922,7 +1928,7 @@ WASM_COMPILED_EXEC_TEST(CastsBenchmark) {
   const uint32_t list = 2;
   const uint32_t kLoops = 2;
   const uint32_t kIterations = kLoops * kListLength;
-  const byte Main = tester.DefineFunction(
+  const uint8_t Main = tester.DefineFunction(
       tester.sigs.i_v(),
       {
           wasm::kWasmI32,
@@ -1965,12 +1971,12 @@ WASM_COMPILED_EXEC_TEST(CastsBenchmark) {
 
 WASM_COMPILED_EXEC_TEST(GlobalInitReferencingGlobal) {
   WasmGCTester tester(execution_tier);
-  const byte from = tester.AddGlobal(kWasmI32, false, WasmInitExpr(42));
-  const byte to =
+  const uint8_t from = tester.AddGlobal(kWasmI32, false, WasmInitExpr(42));
+  const uint8_t to =
       tester.AddGlobal(kWasmI32, false, WasmInitExpr::GlobalGet(from));
 
-  const byte func = tester.DefineFunction(tester.sigs.i_v(), {},
-                                          {WASM_GLOBAL_GET(to), kExprEnd});
+  const uint8_t func = tester.DefineFunction(tester.sigs.i_v(), {},
+                                             {WASM_GLOBAL_GET(to), kExprEnd});
 
   tester.CompileModule();
 
@@ -1981,46 +1987,47 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
   WasmGCTester tester(execution_tier);
 
   tester.builder()->StartRecursiveTypeGroup();
-  byte super_struct = tester.DefineStruct({F(kWasmI32, false)});
-  byte sub_struct = tester.DefineStruct({F(kWasmI32, false), F(kWasmI32, true)},
-                                        super_struct);
+  uint8_t super_struct = tester.DefineStruct({F(kWasmI32, false)});
+  uint8_t sub_struct = tester.DefineStruct(
+      {F(kWasmI32, false), F(kWasmI32, true)}, super_struct);
   FunctionSig* super_sig =
       FunctionSig::Build(tester.zone(), {kWasmI32}, {refNull(sub_struct)});
-  byte super_sig_index = tester.DefineSignature(super_sig);
+  uint8_t super_sig_index = tester.DefineSignature(super_sig);
   FunctionSig* sub_sig =
       FunctionSig::Build(tester.zone(), {kWasmI32}, {refNull(super_struct)});
-  byte sub_sig_index = tester.DefineSignature(sub_sig, super_sig_index);
-  byte unrelated_sig_index = tester.DefineSignature(sub_sig, super_sig_index);
+  uint8_t sub_sig_index = tester.DefineSignature(sub_sig, super_sig_index);
+  uint8_t unrelated_sig_index =
+      tester.DefineSignature(sub_sig, super_sig_index);
   tester.builder()->EndRecursiveTypeGroup();
 
   tester.DefineTable(refNull(super_sig_index), 10, 10);
 
-  byte super_func = tester.DefineFunction(
+  uint8_t super_func = tester.DefineFunction(
       super_sig_index, {},
       {WASM_I32_ADD(WASM_STRUCT_GET(sub_struct, 0, WASM_LOCAL_GET(0)),
                     WASM_STRUCT_GET(sub_struct, 1, WASM_LOCAL_GET(0))),
        WASM_END});
 
-  byte sub_func = tester.DefineFunction(
+  uint8_t sub_func = tester.DefineFunction(
       sub_sig_index, {},
       {WASM_STRUCT_GET(super_struct, 0, WASM_LOCAL_GET(0)), WASM_END});
 
-  byte setup_func = tester.DefineFunction(
+  uint8_t setup_func = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_TABLE_SET(0, WASM_I32V(0), WASM_REF_NULL(super_sig_index)),
        WASM_TABLE_SET(0, WASM_I32V(1), WASM_REF_FUNC(super_func)),
        WASM_TABLE_SET(0, WASM_I32V(2), WASM_REF_FUNC(sub_func)),  // --
        WASM_I32V(0), WASM_END});
 
-  byte super_struct_producer = tester.DefineFunction(
+  uint8_t super_struct_producer = tester.DefineFunction(
       FunctionSig::Build(tester.zone(), {ref(super_struct)}, {}), {},
       {WASM_STRUCT_NEW(super_struct, WASM_I32V(-5)), WASM_END});
-  byte sub_struct_producer = tester.DefineFunction(
+  uint8_t sub_struct_producer = tester.DefineFunction(
       FunctionSig::Build(tester.zone(), {ref(sub_struct)}, {}), {},
       {WASM_STRUCT_NEW(sub_struct, WASM_I32V(7), WASM_I32V(11)), WASM_END});
 
   // Calling a null entry should trap.
-  byte call_null = tester.DefineFunction(
+  uint8_t call_null = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_CALL_INDIRECT(super_sig_index,
                           WASM_CALL_FUNCTION0(sub_struct_producer),
@@ -2028,7 +2035,7 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
        WASM_END});
   // Calling with a signature identical to the type of the table should work,
   // provided the entry has the same signature.
-  byte call_same_type = tester.DefineFunction(
+  uint8_t call_same_type = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_CALL_INDIRECT(super_sig_index,
                           WASM_CALL_FUNCTION0(sub_struct_producer),
@@ -2036,7 +2043,7 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
        WASM_END});
   // Calling with a signature that is a subtype of the type of the table should
   // work, provided the entry has the same signature.
-  byte call_subtype = tester.DefineFunction(
+  uint8_t call_subtype = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_CALL_INDIRECT(sub_sig_index,
                           WASM_CALL_FUNCTION0(super_struct_producer),
@@ -2044,7 +2051,7 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
        WASM_END});
   // Calling with a signature that is a subtype of the type of the table should
   // work, provided the entry has a subtype of the declared signature.
-  byte call_table_subtype_entry_subtype = tester.DefineFunction(
+  uint8_t call_table_subtype_entry_subtype = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_CALL_INDIRECT(super_sig_index,
                           WASM_CALL_FUNCTION0(sub_struct_producer),
@@ -2052,14 +2059,14 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
        WASM_END});
   // Calling with a signature that is mismatched to that of the entry should
   // trap.
-  byte call_type_mismatch = tester.DefineFunction(
+  uint8_t call_type_mismatch = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_CALL_INDIRECT(unrelated_sig_index,
                           WASM_CALL_FUNCTION0(super_struct_producer),
                           WASM_I32V(2)),
        WASM_END});
   // Getting a table element and then calling it with call_ref should work.
-  byte table_get_and_call_ref = tester.DefineFunction(
+  uint8_t table_get_and_call_ref = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_CALL_REF(WASM_TABLE_GET(0, WASM_I32V(2)), super_sig_index,
                      WASM_CALL_FUNCTION0(sub_struct_producer)),
@@ -2084,7 +2091,7 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
 
 WASM_COMPILED_EXEC_TEST(JsAccess) {
   WasmGCTester tester(execution_tier);
-  const byte type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
+  const uint8_t type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
   ValueType kRefType = ref(type_index);
   ValueType kSupertypeToI[] = {kWasmI32, kWasmStructRef};
   FunctionSig sig_t_v(1, 0, &kRefType);
@@ -2143,7 +2150,7 @@ WASM_COMPILED_EXEC_TEST(JsAccess) {
 WASM_COMPILED_EXEC_TEST(WasmExternInternalize) {
   WasmGCTester tester(execution_tier);
 
-  const byte kNull = tester.DefineFunction(
+  const uint8_t kNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_GC_INTERNALIZE(WASM_REF_NULL(kNoExternCode))),
        kExprEnd});
@@ -2155,7 +2162,7 @@ WASM_COMPILED_EXEC_TEST(WasmExternInternalize) {
 WASM_COMPILED_EXEC_TEST(WasmExternExternalize) {
   WasmGCTester tester(execution_tier);
 
-  const byte kNull = tester.DefineFunction(
+  const uint8_t kNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
       {WASM_REF_IS_NULL(WASM_GC_EXTERNALIZE(WASM_REF_NULL(kNoneCode))),
        kExprEnd});
diff --git a/test/cctest/wasm/test-grow-memory.cc b/test/cctest/wasm/test-grow-memory.cc
index b796e8ff9ac..48a440967ae 100644
--- a/test/cctest/wasm/test-grow-memory.cc
+++ b/test/cctest/wasm/test-grow-memory.cc
@@ -83,8 +83,8 @@ TEST(Run_WasmModule_Buffer_Externalized_GrowMem) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_MEMORY_GROW(WASM_I32V_1(6)), WASM_DROP,
-                   WASM_MEMORY_SIZE};
+    uint8_t code[] = {WASM_MEMORY_GROW(WASM_I32V_1(6)), WASM_DROP,
+                      WASM_MEMORY_SIZE};
     EMIT_CODE_WITH_END(f, code);
 
     ZoneBuffer buffer(&zone);
diff --git a/test/cctest/wasm/test-jump-table-assembler.cc b/test/cctest/wasm/test-jump-table-assembler.cc
index cab85314159..f7dd21bcc78 100644
--- a/test/cctest/wasm/test-jump-table-assembler.cc
+++ b/test/cctest/wasm/test-jump-table-assembler.cc
@@ -57,7 +57,7 @@ constexpr uint32_t kBufferSlotStartOffset = 0;
 #endif
 
 Address AllocateJumpTableThunk(
-    Address jump_target, byte* thunk_slot_buffer,
+    Address jump_target, uint8_t* thunk_slot_buffer,
     std::bitset<kAvailableBufferSlots>* used_slots,
     std::vector<std::unique_ptr<TestingAssemblerBuffer>>* thunk_buffers) {
 #if V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_LOONG64
@@ -252,7 +252,7 @@ TEST(JumpTablePatchingStress) {
   static_assert(kAssemblerBufferSize >= kJumpTableSize);
   auto buffer = AllocateAssemblerBuffer(kAssemblerBufferSize, nullptr,
                                         JitPermission::kMapAsJittable);
-  byte* thunk_slot_buffer = buffer->start() + kBufferSlotStartOffset;
+  uint8_t* thunk_slot_buffer = buffer->start() + kBufferSlotStartOffset;
 
   std::bitset<kAvailableBufferSlots> used_thunk_slots;
   buffer->MakeWritableAndExecutable();
diff --git a/test/cctest/wasm/test-liftoff-for-fuzzing.cc b/test/cctest/wasm/test-liftoff-for-fuzzing.cc
index 205e981ee72..786a916f585 100644
--- a/test/cctest/wasm/test-liftoff-for-fuzzing.cc
+++ b/test/cctest/wasm/test-liftoff-for-fuzzing.cc
@@ -43,7 +43,7 @@ TEST(NondeterminismUnopF64) {
 TEST(NondeterminismUnopF32x4AllNaN) {
   WasmRunner<int32_t, float> r(TestExecutionTier::kLiftoffForFuzzing);
 
-  byte value = 0;
+  uint8_t value = 0;
   r.Build({WASM_SIMD_UNOP(kExprF32x4Ceil,
                           WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value))),
            kExprDrop, WASM_ONE});
@@ -55,7 +55,7 @@ TEST(NondeterminismUnopF32x4AllNaN) {
 }
 
 TEST(NondeterminismUnopF32x4OneNaN) {
-  for (byte lane = 0; lane < 4; ++lane) {
+  for (uint8_t lane = 0; lane < 4; ++lane) {
     WasmRunner<int32_t, float> r(TestExecutionTier::kLiftoffForFuzzing);
     r.Build({WASM_SIMD_F32x4_SPLAT(WASM_F32(0)), WASM_LOCAL_GET(0),
              WASM_SIMD_OP(kExprF32x4ReplaceLane), lane,
@@ -71,7 +71,7 @@ TEST(NondeterminismUnopF32x4OneNaN) {
 TEST(NondeterminismUnopF64x2AllNaN) {
   WasmRunner<int32_t, double> r(TestExecutionTier::kLiftoffForFuzzing);
 
-  byte value = 0;
+  uint8_t value = 0;
   r.Build({WASM_SIMD_UNOP(kExprF64x2Ceil,
                           WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(value))),
            kExprDrop, WASM_ONE});
@@ -83,7 +83,7 @@ TEST(NondeterminismUnopF64x2AllNaN) {
 }
 
 TEST(NondeterminismUnopF64x2OneNaN) {
-  for (byte lane = 0; lane < 2; ++lane) {
+  for (uint8_t lane = 0; lane < 2; ++lane) {
     WasmRunner<int32_t, double> r(TestExecutionTier::kLiftoffForFuzzing);
     r.Build({WASM_SIMD_F64x2_SPLAT(WASM_F64(0)), WASM_LOCAL_GET(0),
              WASM_SIMD_OP(kExprF64x2ReplaceLane), lane,
diff --git a/test/cctest/wasm/test-run-wasm-64.cc b/test/cctest/wasm/test-run-wasm-64.cc
index 5cb74db51c9..b4adab1d275 100644
--- a/test/cctest/wasm/test-run-wasm-64.cc
+++ b/test/cctest/wasm/test-run-wasm-64.cc
@@ -1176,14 +1176,14 @@ WASM_EXEC_TEST(Call_Int64Sub) {
 }
 
 WASM_EXEC_TEST(LoadStoreI64_sx) {
-  byte loads[] = {kExprI64LoadMem8S, kExprI64LoadMem16S, kExprI64LoadMem32S,
-                  kExprI64LoadMem};
+  uint8_t loads[] = {kExprI64LoadMem8S, kExprI64LoadMem16S, kExprI64LoadMem32S,
+                     kExprI64LoadMem};
 
   for (size_t m = 0; m < arraysize(loads); m++) {
     WasmRunner<int64_t> r(execution_tier);
-    byte* memory = r.builder().AddMemoryElems<byte>(kWasmPageSize);
+    uint8_t* memory = r.builder().AddMemoryElems<uint8_t>(kWasmPageSize);
 
-    byte code[] = {
+    uint8_t code[] = {
         kExprI32Const,    8,  // --
         kExprI32Const,    0,  // --
         loads[m],             // --
@@ -1204,13 +1204,13 @@ WASM_EXEC_TEST(LoadStoreI64_sx) {
     for (int i = -1; i >= -128; i -= 11) {
       int size = 1 << m;
       r.builder().BlankMemory();
-      memory[size - 1] = static_cast<byte>(i);  // set the high order byte.
+      memory[size - 1] = static_cast<uint8_t>(i);  // set the high order byte.
 
       int64_t expected = static_cast<uint64_t>(static_cast<int64_t>(i))
                          << ((size - 1) * 8);
 
       CHECK_EQ(expected, r.Call());
-      CHECK_EQ(static_cast<byte>(i), memory[8 + size - 1]);
+      CHECK_EQ(static_cast<uint8_t>(i), memory[8 + size - 1]);
       for (int j = size; j < 8; j++) {
         CHECK_EQ(255, memory[8 + j]);
       }
@@ -1279,7 +1279,7 @@ WASM_EXEC_TEST(LoadMemI64) {
 }
 
 WASM_EXEC_TEST(LoadMemI64_alignment) {
-  for (byte alignment = 0; alignment <= 3; alignment++) {
+  for (uint8_t alignment = 0; alignment <= 3; alignment++) {
     WasmRunner<int64_t> r(execution_tier);
     int64_t* memory =
         r.builder().AddMemoryElems<int64_t>(kWasmPageSize / sizeof(int64_t));
@@ -1304,7 +1304,7 @@ WASM_EXEC_TEST(MemI64_Sum) {
   WasmRunner<uint64_t, int32_t> r(execution_tier);
   uint64_t* memory =
       r.builder().AddMemoryElems<uint64_t>(kWasmPageSize / sizeof(uint64_t));
-  const byte kSum = r.AllocateLocal(kWasmI64);
+  const uint8_t kSum = r.AllocateLocal(kWasmI64);
 
   r.Build(
       {WASM_WHILE(
@@ -1332,7 +1332,7 @@ WASM_EXEC_TEST(MemI64_Sum) {
 WASM_EXEC_TEST(StoreMemI64_alignment) {
   const int64_t kWritten = 0x12345678ABCD0011ll;
 
-  for (byte i = 0; i <= 3; i++) {
+  for (uint8_t i = 0; i <= 3; i++) {
     WasmRunner<int64_t, int64_t> r(execution_tier);
     int64_t* memory =
         r.builder().AddMemoryElems<int64_t>(kWasmPageSize / sizeof(int64_t));
@@ -1409,14 +1409,14 @@ WASM_EXEC_TEST(StoreMem_offset_oob_i64) {
 
   for (size_t m = 0; m < arraysize(machineTypes); m++) {
     WasmRunner<int32_t, uint32_t> r(execution_tier);
-    byte* memory = r.builder().AddMemoryElems<byte>(num_bytes);
+    uint8_t* memory = r.builder().AddMemoryElems<uint8_t>(num_bytes);
     r.builder().RandomizeMemory(1119 + static_cast<int>(m));
 
     r.Build({WASM_STORE_MEM_OFFSET(machineTypes[m], 8, WASM_LOCAL_GET(0),
                                    WASM_LOAD_MEM(machineTypes[m], WASM_ZERO)),
              WASM_ZERO});
 
-    byte memsize = machineTypes[m].MemSize();
+    uint8_t memsize = machineTypes[m].MemSize();
     uint32_t boundary = num_bytes - 8 - memsize;
     CHECK_EQ(0, r.Call(boundary));  // in bounds.
     CHECK_EQ(0, memcmp(&memory[0], &memory[8 + boundary], memsize));
@@ -1428,8 +1428,8 @@ WASM_EXEC_TEST(StoreMem_offset_oob_i64) {
 }
 
 WASM_EXEC_TEST(Store_i64_narrowed) {
-  constexpr byte kOpcodes[] = {kExprI64StoreMem8, kExprI64StoreMem16,
-                               kExprI64StoreMem32, kExprI64StoreMem};
+  constexpr uint8_t kOpcodes[] = {kExprI64StoreMem8, kExprI64StoreMem16,
+                                  kExprI64StoreMem32, kExprI64StoreMem};
   int stored_size_in_bytes = 0;
   for (auto opcode : kOpcodes) {
     stored_size_in_bytes = std::max(1, stored_size_in_bytes * 2);
@@ -1477,7 +1477,7 @@ static void CompileCallIndirectMany(TestExecutionTier tier, ValueType param) {
   // Make sure we don't run out of registers when compiling indirect calls
   // with many many parameters.
   TestSignatures sigs;
-  for (byte num_params = 0; num_params < 40; num_params++) {
+  for (uint8_t num_params = 0; num_params < 40; num_params++) {
     WasmRunner<void> r(tier);
     FunctionSig* sig = sigs.many(r.zone(), kWasmVoid, param, num_params);
 
@@ -1487,8 +1487,8 @@ static void CompileCallIndirectMany(TestExecutionTier tier, ValueType param) {
 
     WasmFunctionCompiler& t = r.NewFunction(sig);
 
-    std::vector<byte> code;
-    for (byte p = 0; p < num_params; p++) {
+    std::vector<uint8_t> code;
+    for (uint8_t p = 0; p < num_params; p++) {
       ADD_CODE(code, kExprLocalGet, p);
     }
     ADD_CODE(code, kExprI32Const, 0);
@@ -1537,7 +1537,7 @@ static void Run_WasmMixedCall_N(TestExecutionTier execution_tier, int start) {
     // =========================================================================
     // Build the calling function.
     // =========================================================================
-    std::vector<byte> code;
+    std::vector<uint8_t> code;
 
     // Load the arguments.
     for (int i = 0; i < num_params; i++) {
@@ -1549,7 +1549,7 @@ static void Run_WasmMixedCall_N(TestExecutionTier execution_tier, int start) {
     ADD_CODE(code, WASM_CALL_FUNCTION0(f.function_index()));
 
     // Store the result in a local.
-    byte local_index = r.AllocateLocal(ValueType::For(result));
+    uint8_t local_index = r.AllocateLocal(ValueType::For(result));
     ADD_CODE(code, kExprLocalSet, local_index);
 
     // Store the result in memory.
@@ -1569,8 +1569,8 @@ static void Run_WasmMixedCall_N(TestExecutionTier execution_tier, int start) {
       int size = result.MemSize();
       for (int i = 0; i < size; i++) {
         int base = (which + 1) * kElemSize;
-        byte expected = r.builder().raw_mem_at<byte>(base + i);
-        byte actual = r.builder().raw_mem_at<byte>(i);
+        uint8_t expected = r.builder().raw_mem_at<uint8_t>(base + i);
+        uint8_t actual = r.builder().raw_mem_at<uint8_t>(i);
         CHECK_EQ(expected, actual);
       }
     }
diff --git a/test/cctest/wasm/test-run-wasm-bulk-memory.cc b/test/cctest/wasm/test-run-wasm-bulk-memory.cc
index dd59b48ef57..78a2a745be7 100644
--- a/test/cctest/wasm/test-run-wasm-bulk-memory.cc
+++ b/test/cctest/wasm/test-run-wasm-bulk-memory.cc
@@ -15,9 +15,9 @@ namespace test_run_wasm_bulk_memory {
 
 namespace {
 void CheckMemoryEquals(TestingModuleBuilder* builder, size_t index,
-                       const std::vector<byte>& expected) {
-  const byte* mem_start = builder->raw_mem_start<byte>();
-  const byte* mem_end = builder->raw_mem_end<byte>();
+                       const std::vector<uint8_t>& expected) {
+  const uint8_t* mem_start = builder->raw_mem_start<uint8_t>();
+  const uint8_t* mem_end = builder->raw_mem_end<uint8_t>();
   size_t mem_size = mem_end - mem_start;
   CHECK_LE(index, mem_size);
   CHECK_LE(index + expected.size(), mem_size);
@@ -28,8 +28,8 @@ void CheckMemoryEquals(TestingModuleBuilder* builder, size_t index,
 
 void CheckMemoryEqualsZero(TestingModuleBuilder* builder, size_t index,
                            size_t length) {
-  const byte* mem_start = builder->raw_mem_start<byte>();
-  const byte* mem_end = builder->raw_mem_end<byte>();
+  const uint8_t* mem_start = builder->raw_mem_start<uint8_t>();
+  const uint8_t* mem_end = builder->raw_mem_end<uint8_t>();
   size_t mem_size = mem_end - mem_start;
   CHECK_LE(index, mem_size);
   CHECK_LE(index + length, mem_size);
@@ -39,7 +39,7 @@ void CheckMemoryEqualsZero(TestingModuleBuilder* builder, size_t index,
 }
 
 void CheckMemoryEqualsFollowedByZeroes(TestingModuleBuilder* builder,
-                                       const std::vector<byte>& expected) {
+                                       const std::vector<uint8_t>& expected) {
   CheckMemoryEquals(builder, 0, expected);
   CheckMemoryEqualsZero(builder, expected.size(),
                         builder->mem_size() - expected.size());
@@ -49,7 +49,7 @@ void CheckMemoryEqualsFollowedByZeroes(TestingModuleBuilder* builder,
 WASM_EXEC_TEST(MemoryInit) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
-  const byte data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+  const uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   r.Build({WASM_MEMORY_INIT(0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                             WASM_LOCAL_GET(2)),
@@ -84,7 +84,7 @@ WASM_EXEC_TEST(MemoryInit) {
 WASM_EXEC_TEST(MemoryInitOutOfBoundsData) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
-  const byte data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+  const uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   r.Build({WASM_MEMORY_INIT(0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                             WASM_LOCAL_GET(2)),
@@ -104,7 +104,7 @@ WASM_EXEC_TEST(MemoryInitOutOfBoundsData) {
 WASM_EXEC_TEST(MemoryInitOutOfBounds) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
-  const byte data[kWasmPageSize] = {};
+  const uint8_t data[kWasmPageSize] = {};
   r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   r.Build({WASM_MEMORY_INIT(0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                             WASM_LOCAL_GET(2)),
@@ -133,12 +133,12 @@ WASM_EXEC_TEST(MemoryInitOutOfBounds) {
 
 WASM_EXEC_TEST(MemoryCopy) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
-  byte* mem = r.builder().AddMemory(kWasmPageSize);
+  uint8_t* mem = r.builder().AddMemory(kWasmPageSize);
   r.Build({WASM_MEMORY_COPY(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                             WASM_LOCAL_GET(2)),
            kExprI32Const, 0});
 
-  const byte initial[] = {0, 11, 22, 33, 44, 55, 66, 77};
+  const uint8_t initial[] = {0, 11, 22, 33, 44, 55, 66, 77};
   memcpy(mem, initial, sizeof(initial));
 
   // Copy from [1, 8] to [10, 16].
@@ -160,12 +160,12 @@ WASM_EXEC_TEST(MemoryCopy) {
 
 WASM_EXEC_TEST(MemoryCopyOverlapping) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
-  byte* mem = r.builder().AddMemory(kWasmPageSize);
+  uint8_t* mem = r.builder().AddMemory(kWasmPageSize);
   r.Build({WASM_MEMORY_COPY(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                             WASM_LOCAL_GET(2)),
            kExprI32Const, 0});
 
-  const byte initial[] = {10, 20, 30};
+  const uint8_t initial[] = {10, 20, 30};
   memcpy(mem, initial, sizeof(initial));
 
   // Copy from [0, 3] -> [2, 5]. The copy must not overwrite 30 before copying
@@ -181,12 +181,12 @@ WASM_EXEC_TEST(MemoryCopyOverlapping) {
 
 WASM_EXEC_TEST(MemoryCopyOutOfBoundsData) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
-  byte* mem = r.builder().AddMemory(kWasmPageSize);
+  uint8_t* mem = r.builder().AddMemory(kWasmPageSize);
   r.Build({WASM_MEMORY_COPY(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                             WASM_LOCAL_GET(2)),
            kExprI32Const, 0});
 
-  const byte data[] = {11, 22, 33, 44, 55, 66, 77, 88};
+  const uint8_t data[] = {11, 22, 33, 44, 55, 66, 77, 88};
   memcpy(mem, data, sizeof(data));
 
   const uint32_t last_5_bytes = kWasmPageSize - 5;
@@ -263,7 +263,7 @@ WASM_EXEC_TEST(MemoryFillValueWrapsToByte) {
                             WASM_LOCAL_GET(2)),
            kExprI32Const, 0});
   CHECK_EQ(0, r.Call(0, 1000, 3));
-  const byte expected = 1000 & 255;
+  const uint8_t expected = 1000 & 255;
   CheckMemoryEqualsFollowedByZeroes(&r.builder(),
                                     {expected, expected, expected});
 }
@@ -274,7 +274,7 @@ WASM_EXEC_TEST(MemoryFillOutOfBoundsData) {
   r.Build({WASM_MEMORY_FILL(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                             WASM_LOCAL_GET(2)),
            kExprI32Const, 0});
-  const byte v = 123;
+  const uint8_t v = 123;
   CHECK_EQ(0xDEADBEEF, r.Call(kWasmPageSize - 5, v, 999));
   CheckMemoryEquals(&r.builder(), kWasmPageSize - 6, {0, 0, 0, 0, 0, 0});
 }
@@ -286,7 +286,7 @@ WASM_EXEC_TEST(MemoryFillOutOfBounds) {
                             WASM_LOCAL_GET(2)),
            kExprI32Const, 0});
 
-  const byte v = 123;
+  const uint8_t v = 123;
 
   // Destination range must not be out of bounds.
   CHECK_EQ(0xDEADBEEF, r.Call(1, v, kWasmPageSize));
@@ -303,7 +303,7 @@ WASM_EXEC_TEST(MemoryFillOutOfBounds) {
 WASM_EXEC_TEST(DataDropTwice) {
   WasmRunner<uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
-  const byte data[] = {0};
+  const uint8_t data[] = {0};
   r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   r.Build({WASM_DATA_DROP(0), kExprI32Const, 0});
 
@@ -314,7 +314,7 @@ WASM_EXEC_TEST(DataDropTwice) {
 WASM_EXEC_TEST(DataDropThenMemoryInit) {
   WasmRunner<uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
-  const byte data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
+  const uint8_t data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
   r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   r.Build({WASM_DATA_DROP(0),
            WASM_MEMORY_INIT(0, WASM_I32V_1(0), WASM_I32V_1(1), WASM_I32V_1(2)),
diff --git a/test/cctest/wasm/test-run-wasm-exceptions.cc b/test/cctest/wasm/test-run-wasm-exceptions.cc
index 664c317abaa..4172bc9faa7 100644
--- a/test/cctest/wasm/test-run-wasm-exceptions.cc
+++ b/test/cctest/wasm/test-run-wasm-exceptions.cc
@@ -13,7 +13,7 @@ namespace v8::internal::wasm {
 WASM_EXEC_TEST(TryCatchThrow) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -32,7 +32,7 @@ WASM_EXEC_TEST(TryCatchThrow) {
 WASM_EXEC_TEST(TryCatchThrowWithValue) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_i());
+  uint8_t except = r.builder().AddException(sigs.v_i());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -52,15 +52,15 @@ WASM_EXEC_TEST(TryCatchThrowWithValue) {
 WASM_EXEC_TEST(TryMultiCatchThrow) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except1 = r.builder().AddException(sigs.v_v());
-  byte except2 = r.builder().AddException(sigs.v_v());
+  uint8_t except1 = r.builder().AddException(sigs.v_v());
+  uint8_t except2 = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
   constexpr uint32_t kResult2 = 51;
 
   // Build the main test function.
   r.Build(
-      {kExprTry, static_cast<byte>((kWasmI32).value_type_code()),
+      {kExprTry, static_cast<uint8_t>((kWasmI32).value_type_code()),
        WASM_STMTS(WASM_I32V(kResult2),
                   WASM_IF(WASM_I32_EQZ(WASM_LOCAL_GET(0)), WASM_THROW(except1)),
                   WASM_IF(WASM_I32_EQ(WASM_LOCAL_GET(0), WASM_I32V(1)),
@@ -77,13 +77,13 @@ WASM_EXEC_TEST(TryMultiCatchThrow) {
 WASM_EXEC_TEST(TryCatchAllThrow) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
   // Build the main test function.
   r.Build(
-      {kExprTry, static_cast<byte>((kWasmI32).value_type_code()),
+      {kExprTry, static_cast<uint8_t>((kWasmI32).value_type_code()),
        WASM_STMTS(WASM_I32V(kResult1),
                   WASM_IF(WASM_I32_EQZ(WASM_LOCAL_GET(0)), WASM_THROW(except))),
        kExprCatchAll, WASM_I32V(kResult0), kExprEnd});
@@ -96,15 +96,15 @@ WASM_EXEC_TEST(TryCatchAllThrow) {
 WASM_EXEC_TEST(TryCatchCatchAllThrow) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except1 = r.builder().AddException(sigs.v_v());
-  byte except2 = r.builder().AddException(sigs.v_v());
+  uint8_t except1 = r.builder().AddException(sigs.v_v());
+  uint8_t except2 = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
   constexpr uint32_t kResult2 = 51;
 
   // Build the main test function.
   r.Build(
-      {kExprTry, static_cast<byte>((kWasmI32).value_type_code()),
+      {kExprTry, static_cast<uint8_t>((kWasmI32).value_type_code()),
        WASM_STMTS(WASM_I32V(kResult2),
                   WASM_IF(WASM_I32_EQZ(WASM_LOCAL_GET(0)), WASM_THROW(except1)),
                   WASM_IF(WASM_I32_EQ(WASM_LOCAL_GET(0), WASM_I32V(1)),
@@ -121,8 +121,8 @@ WASM_EXEC_TEST(TryCatchCatchAllThrow) {
 WASM_EXEC_TEST(TryImplicitRethrow) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except1 = r.builder().AddException(sigs.v_v());
-  byte except2 = r.builder().AddException(sigs.v_v());
+  uint8_t except1 = r.builder().AddException(sigs.v_v());
+  uint8_t except2 = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
   constexpr uint32_t kResult2 = 51;
@@ -145,7 +145,7 @@ WASM_EXEC_TEST(TryImplicitRethrow) {
 WASM_EXEC_TEST(TryDelegate) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -167,7 +167,7 @@ WASM_EXEC_TEST(TryDelegate) {
 WASM_EXEC_TEST(TestCatchlessTry) {
   TestSignatures sigs;
   WasmRunner<uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_i());
+  uint8_t except = r.builder().AddException(sigs.v_i());
   r.Build({WASM_TRY_CATCH_T(
       kWasmI32,
       WASM_TRY_T(kWasmI32, WASM_STMTS(WASM_I32V(0), WASM_THROW(except))),
@@ -178,8 +178,8 @@ WASM_EXEC_TEST(TestCatchlessTry) {
 WASM_EXEC_TEST(TryCatchRethrow) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except1 = r.builder().AddException(sigs.v_v());
-  byte except2 = r.builder().AddException(sigs.v_v());
+  uint8_t except1 = r.builder().AddException(sigs.v_v());
+  uint8_t except2 = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
   constexpr uint32_t kUnreachable = 51;
@@ -206,7 +206,7 @@ WASM_EXEC_TEST(TryCatchRethrow) {
 WASM_EXEC_TEST(TryDelegateToCaller) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -229,7 +229,7 @@ WASM_EXEC_TEST(TryDelegateToCaller) {
 WASM_EXEC_TEST(TryCatchCallDirect) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -256,7 +256,7 @@ WASM_EXEC_TEST(TryCatchCallDirect) {
 WASM_EXEC_TEST(TryCatchAllCallDirect) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -283,7 +283,7 @@ WASM_EXEC_TEST(TryCatchAllCallDirect) {
 WASM_EXEC_TEST(TryCatchCallIndirect) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -316,7 +316,7 @@ WASM_EXEC_TEST(TryCatchCallIndirect) {
 WASM_EXEC_TEST(TryCatchAllCallIndirect) {
   TestSignatures sigs;
   WasmRunner<uint32_t, uint32_t> r(execution_tier);
-  byte except = r.builder().AddException(sigs.v_v());
+  uint8_t except = r.builder().AddException(sigs.v_v());
   constexpr uint32_t kResult0 = 23;
   constexpr uint32_t kResult1 = 42;
 
@@ -404,7 +404,7 @@ WASM_COMPILED_EXEC_TEST(TryCatchAllCallExternal) {
 
 namespace {
 
-void TestTrapNotCaught(byte* code, size_t code_size,
+void TestTrapNotCaught(uint8_t* code, size_t code_size,
                        TestExecutionTier execution_tier) {
   TestSignatures sigs;
   WasmRunner<uint32_t> r(execution_tier, kWasmOrigin, nullptr, "main",
@@ -437,22 +437,22 @@ void TestTrapNotCaught(byte* code, size_t code_size,
 }  // namespace
 
 WASM_EXEC_TEST(TryCatchTrapUnreachable) {
-  byte code[] = {WASM_UNREACHABLE};
+  uint8_t code[] = {WASM_UNREACHABLE};
   TestTrapNotCaught(code, arraysize(code), execution_tier);
 }
 
 WASM_EXEC_TEST(TryCatchTrapMemOutOfBounds) {
-  byte code[] = {WASM_LOAD_MEM(MachineType::Int32(), WASM_I32V_1(-1))};
+  uint8_t code[] = {WASM_LOAD_MEM(MachineType::Int32(), WASM_I32V_1(-1))};
   TestTrapNotCaught(code, arraysize(code), execution_tier);
 }
 
 WASM_EXEC_TEST(TryCatchTrapDivByZero) {
-  byte code[] = {WASM_I32_DIVS(WASM_LOCAL_GET(0), WASM_I32V_1(0))};
+  uint8_t code[] = {WASM_I32_DIVS(WASM_LOCAL_GET(0), WASM_I32V_1(0))};
   TestTrapNotCaught(code, arraysize(code), execution_tier);
 }
 
 WASM_EXEC_TEST(TryCatchTrapRemByZero) {
-  byte code[] = {WASM_I32_REMS(WASM_LOCAL_GET(0), WASM_I32V_1(0))};
+  uint8_t code[] = {WASM_I32_REMS(WASM_LOCAL_GET(0), WASM_I32V_1(0))};
   TestTrapNotCaught(code, arraysize(code), execution_tier);
 }
 
@@ -460,9 +460,10 @@ WASM_EXEC_TEST(TryCatchTrapTableFill) {
   int table_index = 0;
   int length = 10;  // OOB.
   int start = 10;   // OOB.
-  byte code[] = {WASM_TABLE_FILL(table_index, WASM_I32V(length),
-                                 WASM_REF_NULL(kFuncRefCode), WASM_I32V(start)),
-                 WASM_I32V_1(42)};
+  uint8_t code[] = {
+      WASM_TABLE_FILL(table_index, WASM_I32V(length),
+                      WASM_REF_NULL(kFuncRefCode), WASM_I32V(start)),
+      WASM_I32V_1(42)};
   TestTrapNotCaught(code, arraysize(code), execution_tier);
 }
 
@@ -504,14 +505,14 @@ UNINITIALIZED_WASM_EXEC_TEST(TestStackOverflowNotCaught) {
 
   // Build a function that calls itself until stack overflow.
   WasmFunctionCompiler& stack_overflow = r.NewFunction(sigs.v_v());
-  stack_overflow.Build(
-      {kExprCallFunction, static_cast<byte>(stack_overflow.function_index())});
+  stack_overflow.Build({kExprCallFunction,
+                        static_cast<uint8_t>(stack_overflow.function_index())});
 
   // Build the main test function.
   r.Build({WASM_TRY_CATCH_ALL_T(
       kWasmI32,
       WASM_STMTS(WASM_I32V(1), kExprCallFunction,
-                 static_cast<byte>(stack_overflow.function_index())),
+                 static_cast<uint8_t>(stack_overflow.function_index())),
       WASM_STMTS(WASM_I32V(1)))});
 
   // Need to call through JS to allow for creation of stack traces.
diff --git a/test/cctest/wasm/test-run-wasm-js.cc b/test/cctest/wasm/test-run-wasm-js.cc
index 04ab378ace8..640d2acfeee 100644
--- a/test/cctest/wasm/test-run-wasm-js.cc
+++ b/test/cctest/wasm/test-run-wasm-js.cc
@@ -133,13 +133,13 @@ void RunJSSelectTest(TestExecutionTier tier, int which) {
     WasmFunctionCompiler& t = r.NewFunction(&sig);
 
     {
-      std::vector<byte> code;
+      std::vector<uint8_t> code;
 
       for (int i = 0; i < num_params; i++) {
         ADD_CODE(code, WASM_F64(inputs.arg_d(i)));
       }
 
-      ADD_CODE(code, kExprCallFunction, static_cast<byte>(js_index));
+      ADD_CODE(code, kExprCallFunction, static_cast<uint8_t>(js_index));
 
       size_t end = code.size();
       code.push_back(0);
@@ -371,7 +371,7 @@ void RunJSSelectAlignTest(TestExecutionTier tier, int num_args,
   Zone zone(&allocator, ZONE_NAME);
 
   // Build the calling code.
-  std::vector<byte> code;
+  std::vector<uint8_t> code;
 
   for (int i = 0; i < num_params; i++) {
     ADD_CODE(code, WASM_LOCAL_GET(i));
@@ -499,7 +499,7 @@ void RunPickerTest(TestExecutionTier tier, bool indirect) {
   WasmFunctionCompiler& rc_fn = r.NewFunction(sigs.i_i(), "rc");
 
   if (indirect) {
-    byte sig_index = r.builder().AddSignature(sigs.i_iii());
+    uint8_t sig_index = r.builder().AddSignature(sigs.i_iii());
     uint16_t indirect_function_table[] = {static_cast<uint16_t>(js_index)};
 
     r.builder().AddIndirectFunctionTable(indirect_function_table,
diff --git a/test/cctest/wasm/test-run-wasm-memory64.cc b/test/cctest/wasm/test-run-wasm-memory64.cc
index 185bacaf41d..8c0ec8b2616 100644
--- a/test/cctest/wasm/test-run-wasm-memory64.cc
+++ b/test/cctest/wasm/test-run-wasm-memory64.cc
@@ -60,7 +60,7 @@ WASM_EXEC_TEST(InitExpression) {
 
   ErrorThrower thrower(isolate, "TestMemory64InitExpression");
 
-  const byte data[] = {
+  const uint8_t data[] = {
       WASM_MODULE_HEADER,                     //
       SECTION(Memory,                         //
               ENTRY_COUNT(1),                 //
diff --git a/test/cctest/wasm/test-run-wasm-module.cc b/test/cctest/wasm/test-run-wasm-module.cc
index e46be437034..604c112a921 100644
--- a/test/cctest/wasm/test-run-wasm-module.cc
+++ b/test/cctest/wasm/test-run-wasm-module.cc
@@ -88,7 +88,7 @@ TEST(Run_WasmModule_Return114) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_I32V_2(kReturnValue)};
+    uint8_t code[] = {WASM_I32V_2(kReturnValue)};
     EMIT_CODE_WITH_END(f, code);
     TestModule(&zone, builder, kReturnValue);
   }
@@ -109,7 +109,7 @@ TEST(Run_WasmModule_CompilationHintsLazy) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_I32V_2(kReturnValue)};
+    uint8_t code[] = {WASM_I32V_2(kReturnValue)};
     EMIT_CODE_WITH_END(f, code);
     f->SetCompilationHint(WasmCompilationHintStrategy::kLazy,
                           WasmCompilationHintTier::kBaseline,
@@ -169,7 +169,7 @@ TEST(Run_WasmModule_CompilationHintsNoTiering) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_I32V_2(kReturnValue)};
+    uint8_t code[] = {WASM_I32V_2(kReturnValue)};
     EMIT_CODE_WITH_END(f, code);
     f->SetCompilationHint(WasmCompilationHintStrategy::kEager,
                           WasmCompilationHintTier::kBaseline,
@@ -217,7 +217,7 @@ TEST(Run_WasmModule_CompilationHintsTierUp) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_I32V_2(kReturnValue)};
+    uint8_t code[] = {WASM_I32V_2(kReturnValue)};
     EMIT_CODE_WITH_END(f, code);
     f->SetCompilationHint(WasmCompilationHintStrategy::kEager,
                           WasmCompilationHintTier::kBaseline,
@@ -279,7 +279,7 @@ TEST(Run_WasmModule_CompilationHintsLazyBaselineEagerTopTier) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_I32V_2(kReturnValue)};
+    uint8_t code[] = {WASM_I32V_2(kReturnValue)};
     EMIT_CODE_WITH_END(f, code);
     f->SetCompilationHint(
         WasmCompilationHintStrategy::kLazyBaselineEagerTopTier,
@@ -328,14 +328,14 @@ TEST(Run_WasmModule_CallAdd) {
     WasmFunctionBuilder* f1 = builder->AddFunction(sigs.i_ii());
     uint16_t param1 = 0;
     uint16_t param2 = 1;
-    byte code1[] = {
+    uint8_t code1[] = {
         WASM_I32_ADD(WASM_LOCAL_GET(param1), WASM_LOCAL_GET(param2))};
     EMIT_CODE_WITH_END(f1, code1);
 
     WasmFunctionBuilder* f2 = builder->AddFunction(sigs.i_v());
 
     ExportAsMain(f2);
-    byte code2[] = {
+    uint8_t code2[] = {
         WASM_CALL_FUNCTION(f1->func_index(), WASM_I32V_2(77), WASM_I32V_1(22))};
     EMIT_CODE_WITH_END(f2, code2);
     TestModule(&zone, builder, 99);
@@ -345,7 +345,7 @@ TEST(Run_WasmModule_CallAdd) {
 
 TEST(Run_WasmModule_ReadLoadedDataSegment) {
   {
-    static const byte kDataSegmentDest0 = 12;
+    static const uint8_t kDataSegmentDest0 = 12;
     v8::internal::AccountingAllocator allocator;
     Zone zone(&allocator, ZONE_NAME);
     TestSignatures sigs;
@@ -354,10 +354,10 @@ TEST(Run_WasmModule_ReadLoadedDataSegment) {
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
 
     ExportAsMain(f);
-    byte code[] = {
+    uint8_t code[] = {
         WASM_LOAD_MEM(MachineType::Int32(), WASM_I32V_1(kDataSegmentDest0))};
     EMIT_CODE_WITH_END(f, code);
-    byte data[] = {0xAA, 0xBB, 0xCC, 0xDD};
+    uint8_t data[] = {0xAA, 0xBB, 0xCC, 0xDD};
     builder->AddDataSegment(data, sizeof(data), kDataSegmentDest0);
     TestModule(&zone, builder, 0xDDCCBBAA);
   }
@@ -376,7 +376,7 @@ TEST(Run_WasmModule_CheckMemoryIsZero) {
 
     uint16_t localIndex = f->AddLocal(kWasmI32);
     ExportAsMain(f);
-    byte code[] = {WASM_BLOCK_I(
+    uint8_t code[] = {WASM_BLOCK_I(
         WASM_WHILE(
             WASM_I32_LTS(WASM_LOCAL_GET(localIndex), WASM_I32V_3(kCheckSize)),
             WASM_IF_ELSE(
@@ -401,7 +401,7 @@ TEST(Run_WasmModule_CallMain_recursive) {
 
     uint16_t localIndex = f->AddLocal(kWasmI32);
     ExportAsMain(f);
-    byte code[] = {
+    uint8_t code[] = {
         WASM_LOCAL_SET(localIndex,
                        WASM_LOAD_MEM(MachineType::Int32(), WASM_ZERO)),
         WASM_IF_ELSE_I(WASM_I32_LTS(WASM_LOCAL_GET(localIndex), WASM_I32V_1(5)),
@@ -425,14 +425,14 @@ TEST(Run_WasmModule_Global) {
     uint32_t global1 = builder->AddGlobal(kWasmI32);
     uint32_t global2 = builder->AddGlobal(kWasmI32);
     WasmFunctionBuilder* f1 = builder->AddFunction(sigs.i_v());
-    byte code1[] = {
+    uint8_t code1[] = {
         WASM_I32_ADD(WASM_GLOBAL_GET(global1), WASM_GLOBAL_GET(global2))};
     EMIT_CODE_WITH_END(f1, code1);
     WasmFunctionBuilder* f2 = builder->AddFunction(sigs.i_v());
     ExportAsMain(f2);
-    byte code2[] = {WASM_GLOBAL_SET(global1, WASM_I32V_1(56)),
-                    WASM_GLOBAL_SET(global2, WASM_I32V_1(41)),
-                    WASM_RETURN(WASM_CALL_FUNCTION0(f1->func_index()))};
+    uint8_t code2[] = {WASM_GLOBAL_SET(global1, WASM_I32V_1(56)),
+                       WASM_GLOBAL_SET(global2, WASM_I32V_1(41)),
+                       WASM_RETURN(WASM_CALL_FUNCTION0(f1->func_index()))};
     EMIT_CODE_WITH_END(f2, code2);
     TestModule(&zone, builder, 97);
   }
@@ -450,7 +450,7 @@ TEST(MemorySize) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_MEMORY_SIZE};
+    uint8_t code[] = {WASM_MEMORY_SIZE};
     EMIT_CODE_WITH_END(f, code);
     TestModule(&zone, builder, kExpectedValue);
   }
@@ -468,8 +468,8 @@ TEST(Run_WasmModule_MemSize_GrowMem) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_MEMORY_GROW(WASM_I32V_1(10)), WASM_DROP,
-                   WASM_MEMORY_SIZE};
+    uint8_t code[] = {WASM_MEMORY_GROW(WASM_I32V_1(10)), WASM_DROP,
+                      WASM_MEMORY_SIZE};
     EMIT_CODE_WITH_END(f, code);
     TestModule(&zone, builder, kExpectedValue);
   }
@@ -487,7 +487,7 @@ TEST(MemoryGrowZero) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_MEMORY_GROW(WASM_I32V(0))};
+    uint8_t code[] = {WASM_MEMORY_GROW(WASM_I32V(0))};
     EMIT_CODE_WITH_END(f, code);
     TestModule(&zone, builder, kExpectedValue);
   }
@@ -550,7 +550,7 @@ TEST(TestInterruptLoop) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {
+    uint8_t code[] = {
         WASM_LOOP(
             WASM_IF(WASM_NOT(WASM_LOAD_MEM(
                         MachineType::Int32(),
@@ -595,8 +595,8 @@ TEST(Run_WasmModule_MemoryGrowInIf) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_IF_ELSE_I(WASM_I32V(0), WASM_MEMORY_GROW(WASM_I32V(1)),
-                                  WASM_I32V(12))};
+    uint8_t code[] = {WASM_IF_ELSE_I(
+        WASM_I32V(0), WASM_MEMORY_GROW(WASM_I32V(1)), WASM_I32V(12))};
     EMIT_CODE_WITH_END(f, code);
     TestModule(&zone, builder, 12);
   }
@@ -616,9 +616,9 @@ TEST(Run_WasmModule_GrowMemOobOffset) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
     ExportAsMain(f);
-    byte code[] = {WASM_MEMORY_GROW(WASM_I32V_1(1)),
-                   WASM_STORE_MEM(MachineType::Int32(), WASM_I32V(index),
-                                  WASM_I32V(value))};
+    uint8_t code[] = {WASM_MEMORY_GROW(WASM_I32V_1(1)),
+                      WASM_STORE_MEM(MachineType::Int32(), WASM_I32V(index),
+                                     WASM_I32V(value))};
     EMIT_CODE_WITH_END(f, code);
     TestModuleException(&zone, builder);
   }
@@ -638,10 +638,10 @@ TEST(Run_WasmModule_GrowMemOobFixedIndex) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_i());
     ExportAsMain(f);
-    byte code[] = {WASM_MEMORY_GROW(WASM_LOCAL_GET(0)), WASM_DROP,
-                   WASM_STORE_MEM(MachineType::Int32(), WASM_I32V(index),
-                                  WASM_I32V(value)),
-                   WASM_LOAD_MEM(MachineType::Int32(), WASM_I32V(index))};
+    uint8_t code[] = {WASM_MEMORY_GROW(WASM_LOCAL_GET(0)), WASM_DROP,
+                      WASM_STORE_MEM(MachineType::Int32(), WASM_I32V(index),
+                                     WASM_I32V(value)),
+                      WASM_LOAD_MEM(MachineType::Int32(), WASM_I32V(index))};
     EMIT_CODE_WITH_END(f, code);
 
     HandleScope scope(isolate);
@@ -686,10 +686,10 @@ TEST(Run_WasmModule_GrowMemOobVariableIndex) {
     WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_i());
     ExportAsMain(f);
-    byte code[] = {WASM_MEMORY_GROW(WASM_I32V_1(1)), WASM_DROP,
-                   WASM_STORE_MEM(MachineType::Int32(), WASM_LOCAL_GET(0),
-                                  WASM_I32V(value)),
-                   WASM_LOAD_MEM(MachineType::Int32(), WASM_LOCAL_GET(0))};
+    uint8_t code[] = {WASM_MEMORY_GROW(WASM_I32V_1(1)), WASM_DROP,
+                      WASM_STORE_MEM(MachineType::Int32(), WASM_LOCAL_GET(0),
+                                     WASM_I32V(value)),
+                      WASM_LOAD_MEM(MachineType::Int32(), WASM_LOCAL_GET(0))};
     EMIT_CODE_WITH_END(f, code);
 
     HandleScope scope(isolate);
@@ -745,7 +745,7 @@ TEST(Run_WasmModule_Global_init) {
     uint32_t global2 =
         builder->AddGlobal(kWasmI32, false, WasmInitExpr(222222));
     WasmFunctionBuilder* f1 = builder->AddFunction(sigs.i_v());
-    byte code[] = {
+    uint8_t code[] = {
         WASM_I32_ADD(WASM_GLOBAL_GET(global1), WASM_GLOBAL_GET(global2))};
     EMIT_CODE_WITH_END(f1, code);
     ExportAsMain(f1);
@@ -777,7 +777,7 @@ static void RunWasmModuleGlobalInitTest(ValueType type, CType expected) {
       }
 
       WasmFunctionBuilder* f1 = builder->AddFunction(&sig);
-      byte code[] = {WASM_GLOBAL_GET(global)};
+      uint8_t code[] = {WASM_GLOBAL_GET(global)};
       EMIT_CODE_WITH_END(f1, code);
       ExportAsMain(f1);
       TestModule(&zone, builder, expected);
@@ -809,7 +809,7 @@ TEST(InitDataAtTheUpperLimit) {
 
     ErrorThrower thrower(isolate, "Run_WasmModule_InitDataAtTheUpperLimit");
 
-    const byte data[] = {
+    const uint8_t data[] = {
         WASM_MODULE_HEADER,   // --
         kMemorySectionCode,   // --
         U32V_1(4),            // section size
@@ -845,7 +845,7 @@ TEST(EmptyMemoryNonEmptyDataSegment) {
 
     ErrorThrower thrower(isolate, "Run_WasmModule_InitDataAtTheUpperLimit");
 
-    const byte data[] = {
+    const uint8_t data[] = {
         WASM_MODULE_HEADER,  // --
         kMemorySectionCode,  // --
         U32V_1(4),           // section size
@@ -879,7 +879,7 @@ TEST(EmptyMemoryEmptyDataSegment) {
 
     ErrorThrower thrower(isolate, "Run_WasmModule_InitDataAtTheUpperLimit");
 
-    const byte data[] = {
+    const uint8_t data[] = {
         WASM_MODULE_HEADER,  // --
         kMemorySectionCode,  // --
         U32V_1(4),           // section size
diff --git a/test/cctest/wasm/test-run-wasm-relaxed-simd.cc b/test/cctest/wasm/test-run-wasm-relaxed-simd.cc
index a64de211e96..efabd016e0a 100644
--- a/test/cctest/wasm/test-run-wasm-relaxed-simd.cc
+++ b/test/cctest/wasm/test-run-wasm-relaxed-simd.cc
@@ -133,7 +133,7 @@ WASM_RELAXED_SIMD_TEST(F32x4Qfma) {
   // Set up global to hold mask output.
   float* g = r.builder().AddGlobal<float>(kWasmS128);
   // Build fn to splat test values, perform compare op, and write the result.
-  byte value1 = 0, value2 = 1, value3 = 2;
+  uint8_t value1 = 0, value2 = 1, value3 = 2;
   r.Build(
       {WASM_GLOBAL_SET(0, WASM_SIMD_F32x4_QFMA(
                               WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value1)),
@@ -157,7 +157,7 @@ WASM_RELAXED_SIMD_TEST(F32x4Qfms) {
   // Set up global to hold mask output.
   float* g = r.builder().AddGlobal<float>(kWasmS128);
   // Build fn to splat test values, perform compare op, and write the result.
-  byte value1 = 0, value2 = 1, value3 = 2;
+  uint8_t value1 = 0, value2 = 1, value3 = 2;
   r.Build(
       {WASM_GLOBAL_SET(0, WASM_SIMD_F32x4_QFMS(
                               WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value1)),
@@ -181,7 +181,7 @@ WASM_RELAXED_SIMD_TEST(F64x2Qfma) {
   // Set up global to hold mask output.
   double* g = r.builder().AddGlobal<double>(kWasmS128);
   // Build fn to splat test values, perform compare op, and write the result.
-  byte value1 = 0, value2 = 1, value3 = 2;
+  uint8_t value1 = 0, value2 = 1, value3 = 2;
   r.Build(
       {WASM_GLOBAL_SET(0, WASM_SIMD_F64x2_QFMA(
                               WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(value1)),
@@ -205,7 +205,7 @@ WASM_RELAXED_SIMD_TEST(F64x2Qfms) {
   // Set up global to hold mask output.
   double* g = r.builder().AddGlobal<double>(kWasmS128);
   // Build fn to splat test values, perform compare op, and write the result.
-  byte value1 = 0, value2 = 1, value3 = 2;
+  uint8_t value1 = 0, value2 = 1, value3 = 2;
   r.Build(
       {WASM_GLOBAL_SET(0, WASM_SIMD_F64x2_QFMS(
                               WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(value1)),
@@ -229,9 +229,9 @@ TEST(RunWasm_RegressFmaReg_liftoff) {
   FLAG_SCOPE(liftoff_only);
   TestExecutionTier execution_tier = TestExecutionTier::kLiftoff;
   WasmRunner<int32_t, float, float, float> r(execution_tier);
-  byte local = r.AllocateLocal(kWasmS128);
+  uint8_t local = r.AllocateLocal(kWasmS128);
   float* g = r.builder().AddGlobal<float>(kWasmS128);
-  byte value1 = 0, value2 = 1, value3 = 2;
+  uint8_t value1 = 0, value2 = 1, value3 = 2;
   r.Build(
       {// Get the first arg from a local so that the register is blocked even
        // after the arguments have been popped off the stack. This ensures that
@@ -429,9 +429,9 @@ WASM_RELAXED_SIMD_TEST(I16x8RelaxedQ15MulRS) {
   // Global to hold output.
   int16_t* g = r.builder().template AddGlobal<int16_t>(kWasmS128);
   // Build fn to splat test values, perform binop, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(kExprI16x8RelaxedQ15MulRS,
@@ -460,9 +460,9 @@ WASM_RELAXED_SIMD_TEST(I16x8RelaxedQ15MulRS) {
 WASM_RELAXED_SIMD_TEST(I16x8DotI8x16I7x16S) {
   WasmRunner<int32_t, int8_t, int8_t> r(execution_tier);
   int16_t* g = r.builder().template AddGlobal<int16_t>(kWasmS128);
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(kExprI16x8DotI8x16I7x16S,
@@ -485,10 +485,10 @@ WASM_RELAXED_SIMD_TEST(I16x8DotI8x16I7x16S) {
 WASM_RELAXED_SIMD_TEST(I32x4DotI8x16I7x16AddS) {
   WasmRunner<int32_t, int8_t, int8_t, int32_t> r(execution_tier);
   int32_t* g = r.builder().template AddGlobal<int32_t>(kWasmS128);
-  byte value1 = 0, value2 = 1, value3 = 2;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
-  byte temp3 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1, value3 = 2;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t temp3 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_LOCAL_SET(temp3, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value3))),
diff --git a/test/cctest/wasm/test-run-wasm-simd-liftoff.cc b/test/cctest/wasm/test-run-wasm-simd-liftoff.cc
index 1f6ddd519ff..0a9bc1a6314 100644
--- a/test/cctest/wasm/test-run-wasm-simd-liftoff.cc
+++ b/test/cctest/wasm/test-run-wasm-simd-liftoff.cc
@@ -23,7 +23,7 @@ namespace test_run_wasm_simd_liftoff {
 
 TEST(S128Local) {
   WasmRunner<int32_t> r(TestExecutionTier::kLiftoff);
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_LOCAL_GET(temp1)), WASM_ONE});
   CHECK_EQ(1, r.Call());
 }
@@ -54,7 +54,7 @@ TEST(S128Param) {
   TestSignatures sigs;
   // We use a temp local to materialize a SIMD value, since at this point
   // Liftoff does not support any SIMD operations.
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   WasmFunctionCompiler& simd_func = r.NewFunction(sigs.i_s());
   simd_func.Build({WASM_ONE});
 
@@ -69,7 +69,7 @@ TEST(S128Return) {
   WasmRunner<int32_t> r(TestExecutionTier::kLiftoff);
   TestSignatures sigs;
   WasmFunctionCompiler& simd_func = r.NewFunction(sigs.s_i());
-  byte temp1 = simd_func.AllocateLocal(kWasmS128);
+  uint8_t temp1 = simd_func.AllocateLocal(kWasmS128);
   simd_func.Build({WASM_LOCAL_GET(temp1)});
 
   r.Build({WASM_CALL_FUNCTION(simd_func.function_index(), WASM_ONE), kExprDrop,
@@ -88,7 +88,7 @@ TEST(REGRESS_1088273) {
   WasmRunner<int32_t> r(TestExecutionTier::kLiftoff);
   TestSignatures sigs;
   WasmFunctionCompiler& simd_func = r.NewFunction(sigs.s_i());
-  byte temp1 = simd_func.AllocateLocal(kWasmS128);
+  uint8_t temp1 = simd_func.AllocateLocal(kWasmS128);
   simd_func.Build({WASM_LOCAL_GET(temp1)});
 
   r.Build({WASM_SIMD_SPLAT(I8x16, WASM_I32V(0x80)),
@@ -103,25 +103,25 @@ TEST(REGRESS_1088273) {
 TEST(I8x16Shuffle) {
   WasmRunner<int32_t> r(TestExecutionTier::kLiftoff);
   // Temps to use up registers and force non-adjacent registers for shuffle.
-  byte local0 = r.AllocateLocal(kWasmS128);
-  byte local1 = r.AllocateLocal(kWasmS128);
+  uint8_t local0 = r.AllocateLocal(kWasmS128);
+  uint8_t local1 = r.AllocateLocal(kWasmS128);
 
   //  g0 and g1 are globals that hold input values for the shuffle,
   //  g0 contains byte array [0, 1, ... 15], g1 contains byte array [16, 17,
   //  ... 31]. They should never be overwritten - write only to output.
-  byte* g0 = r.builder().AddGlobal<byte>(kWasmS128);
-  byte* g1 = r.builder().AddGlobal<byte>(kWasmS128);
+  uint8_t* g0 = r.builder().AddGlobal<uint8_t>(kWasmS128);
+  uint8_t* g1 = r.builder().AddGlobal<uint8_t>(kWasmS128);
   for (int i = 0; i < 16; i++) {
     LANE(g0, i) = i;
     LANE(g1, i) = i + 16;
   }
 
   // Output global holding a kWasmS128.
-  byte* output = r.builder().AddGlobal<byte>(kWasmS128);
+  uint8_t* output = r.builder().AddGlobal<uint8_t>(kWasmS128);
 
   // i8x16_shuffle(lhs, rhs, pattern) will take the last element of rhs and
   // place it into the last lane of lhs.
-  std::array<byte, 16> pattern = {
+  std::array<uint8_t, 16> pattern = {
       {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31}};
 
   // Set up locals so shuffle is called with non-adjacent registers v2 and v0.
@@ -138,7 +138,7 @@ TEST(I8x16Shuffle) {
 
   // The shuffle pattern only changes the last element.
   for (int i = 0; i < 15; i++) {
-    byte actual = LANE(output, i);
+    uint8_t actual = LANE(output, i);
     CHECK_EQ(i, actual);
   }
   CHECK_EQ(31, LANE(output, 15));
@@ -148,19 +148,19 @@ TEST(I8x16Shuffle) {
 // shuffle are the same register.
 TEST(I8x16Shuffle_SingleOperand) {
   WasmRunner<int32_t> r(TestExecutionTier::kLiftoff);
-  byte local0 = r.AllocateLocal(kWasmS128);
+  uint8_t local0 = r.AllocateLocal(kWasmS128);
 
-  byte* g0 = r.builder().AddGlobal<byte>(kWasmS128);
+  uint8_t* g0 = r.builder().AddGlobal<uint8_t>(kWasmS128);
   for (int i = 0; i < 16; i++) {
     LANE(g0, i) = i;
   }
 
-  byte* output = r.builder().AddGlobal<byte>(kWasmS128);
+  uint8_t* output = r.builder().AddGlobal<uint8_t>(kWasmS128);
 
   // This pattern reverses first operand. 31 should select the last lane of
   // the second operand, but since the operands are the same, the effect is that
   // the first operand is reversed.
-  std::array<byte, 16> pattern = {
+  std::array<uint8_t, 16> pattern = {
       {31, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0}};
 
   // Set up locals so shuffle is called with non-adjacent registers v2 and v0.
@@ -175,7 +175,7 @@ TEST(I8x16Shuffle_SingleOperand) {
 
   for (int i = 0; i < 16; i++) {
     // Check that the output is the reverse of input.
-    byte actual = LANE(output, i);
+    uint8_t actual = LANE(output, i);
     CHECK_EQ(15 - i, actual);
   }
 }
diff --git a/test/cctest/wasm/test-run-wasm-simd.cc b/test/cctest/wasm/test-run-wasm-simd.cc
index 0a2bbdecdc8..310fb5721ab 100644
--- a/test/cctest/wasm/test-run-wasm-simd.cc
+++ b/test/cctest/wasm/test-run-wasm-simd.cc
@@ -257,7 +257,7 @@ WASM_EXEC_TEST(F32x4Splat) {
   WasmRunner<int32_t, float> r(execution_tier);
   // Set up a global to hold output vector.
   float* g = r.builder().AddGlobal<float>(kWasmS128);
-  byte param1 = 0;
+  uint8_t param1 = 0;
   r.Build({WASM_GLOBAL_SET(0, WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(param1))),
            WASM_ONE});
 
@@ -280,7 +280,7 @@ WASM_EXEC_TEST(F32x4ReplaceLane) {
   // Set up a global to hold input/output vector.
   float* g = r.builder().AddGlobal<float>(kWasmS128);
   // Build function to replace each lane with its (FP) index.
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_F32(3.14159f))),
            WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_REPLACE_LANE(
                                      0, WASM_LOCAL_GET(temp1), WASM_F32(0.0f))),
@@ -305,8 +305,8 @@ WASM_EXEC_TEST(F32x4ConvertI32x4) {
   float* g0 = r.builder().AddGlobal<float>(kWasmS128);
   float* g1 = r.builder().AddGlobal<float>(kWasmS128);
   // Build fn to splat test value, perform conversions, and write the results.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(kExprF32x4SConvertI32x4,
                                              WASM_LOCAL_GET(temp1))),
@@ -337,8 +337,8 @@ void RunF128CompareOpConstImmTest(
     ScalarType* g2 = r.builder().template AddGlobal<ScalarType>(kWasmS128);
     // Build fn to splat test values, perform compare op on both sides, and
     // write the result.
-    byte value = 0;
-    byte temp = r.AllocateLocal(kWasmS128);
+    uint8_t value = 0;
+    uint8_t temp = r.AllocateLocal(kWasmS128);
     uint8_t const_buffer[kSimd128Size];
     for (size_t i = 0; i < kSimd128Size / sizeof(FloatType); i++) {
       WriteLittleEndianValue<FloatType>(
@@ -456,9 +456,9 @@ void RunShiftAddTestSequence(TestExecutionTier execution_tier,
   // globals to store results for left and right cases
   ScalarType* g1 = r.builder().template AddGlobal<ScalarType>(kWasmS128);
   ScalarType* g2 = r.builder().template AddGlobal<ScalarType>(kWasmS128);
-  byte param = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t param = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   auto expected_fn = [shift_fn](ScalarType x, ScalarType y, uint32_t imm) {
     return base::AddWithWraparound(x, shift_fn(y, imm));
   };
@@ -522,7 +522,7 @@ WASM_EXEC_TEST(I64x2Splat) {
   WasmRunner<int32_t, int64_t> r(execution_tier);
   // Set up a global to hold output vector.
   int64_t* g = r.builder().AddGlobal<int64_t>(kWasmS128);
-  byte param1 = 0;
+  uint8_t param1 = 0;
   r.Build({WASM_GLOBAL_SET(0, WASM_SIMD_I64x2_SPLAT(WASM_LOCAL_GET(param1))),
            WASM_ONE});
 
@@ -553,7 +553,7 @@ WASM_EXEC_TEST(I64x2ReplaceLane) {
   // Set up a global to hold input/output vector.
   int64_t* g = r.builder().AddGlobal<int64_t>(kWasmS128);
   // Build function to replace each lane with its index.
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I64x2_SPLAT(WASM_I64V(-1))),
            WASM_LOCAL_SET(temp1, WASM_SIMD_I64x2_REPLACE_LANE(
                                      0, WASM_LOCAL_GET(temp1), WASM_I64V(0))),
@@ -644,8 +644,8 @@ void RunICompareOpConstImmTest(TestExecutionTier execution_tier,
     ScalarType* g2 = r.builder().template AddGlobal<ScalarType>(kWasmS128);
     // Build fn to splat test values, perform compare op on both sides, and
     // write the result.
-    byte value = 0;
-    byte temp = r.AllocateLocal(kWasmS128);
+    uint8_t value = 0;
+    uint8_t temp = r.AllocateLocal(kWasmS128);
     uint8_t const_buffer[kSimd128Size];
     for (size_t i = 0; i < kSimd128Size / sizeof(ScalarType); i++) {
       WriteLittleEndianValue<ScalarType>(
@@ -708,7 +708,7 @@ WASM_EXEC_TEST(F64x2Splat) {
   WasmRunner<int32_t, double> r(execution_tier);
   // Set up a global to hold output vector.
   double* g = r.builder().AddGlobal<double>(kWasmS128);
-  byte param1 = 0;
+  uint8_t param1 = 0;
   r.Build({WASM_GLOBAL_SET(0, WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(param1))),
            WASM_ONE});
 
@@ -728,9 +728,9 @@ WASM_EXEC_TEST(F64x2Splat) {
 
 WASM_EXEC_TEST(F64x2ExtractLane) {
   WasmRunner<double, double> r(execution_tier);
-  byte param1 = 0;
-  byte temp1 = r.AllocateLocal(kWasmF64);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t param1 = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmF64);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(
                temp1, WASM_SIMD_F64x2_EXTRACT_LANE(
                           0, WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(param1)))),
@@ -753,7 +753,7 @@ WASM_EXEC_TEST(F64x2ReplaceLane) {
   double* g0 = r.builder().AddGlobal<double>(kWasmS128);
   double* g1 = r.builder().AddGlobal<double>(kWasmS128);
   // Build function to replace each lane with its (FP) index.
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F64x2_SPLAT(WASM_F64(1e100))),
            // Replace lane 0.
            WASM_GLOBAL_SET(0, WASM_SIMD_F64x2_REPLACE_LANE(
@@ -1062,7 +1062,7 @@ WASM_EXEC_TEST(I32x4Splat) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
   // Set up a global to hold output vector.
   int32_t* g = r.builder().AddGlobal<int32_t>(kWasmS128);
-  byte param1 = 0;
+  uint8_t param1 = 0;
   r.Build({WASM_GLOBAL_SET(0, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(param1))),
            WASM_ONE});
 
@@ -1081,7 +1081,7 @@ WASM_EXEC_TEST(I32x4ReplaceLane) {
   // Set up a global to hold input/output vector.
   int32_t* g = r.builder().AddGlobal<int32_t>(kWasmS128);
   // Build function to replace each lane with its index.
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_SPLAT(WASM_I32V(-1))),
            WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_REPLACE_LANE(
                                      0, WASM_LOCAL_GET(temp1), WASM_I32V(0))),
@@ -1103,7 +1103,7 @@ WASM_EXEC_TEST(I16x8Splat) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
   // Set up a global to hold output vector.
   int16_t* g = r.builder().AddGlobal<int16_t>(kWasmS128);
-  byte param1 = 0;
+  uint8_t param1 = 0;
   r.Build({WASM_GLOBAL_SET(0, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(param1))),
            WASM_ONE});
 
@@ -1132,7 +1132,7 @@ WASM_EXEC_TEST(I16x8ReplaceLane) {
   // Set up a global to hold input/output vector.
   int16_t* g = r.builder().AddGlobal<int16_t>(kWasmS128);
   // Build function to replace each lane with its index.
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_I32V(-1))),
            WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_REPLACE_LANE(
                                      0, WASM_LOCAL_GET(temp1), WASM_I32V(0))),
@@ -1160,7 +1160,7 @@ WASM_EXEC_TEST(I16x8ReplaceLane) {
 
 WASM_EXEC_TEST(I8x16BitMask) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
-  byte value1 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = r.AllocateLocal(kWasmS128);
 
   r.Build(
       {WASM_LOCAL_SET(value1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(0))),
@@ -1180,7 +1180,7 @@ WASM_EXEC_TEST(I8x16BitMask) {
 
 WASM_EXEC_TEST(I16x8BitMask) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
-  byte value1 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = r.AllocateLocal(kWasmS128);
 
   r.Build(
       {WASM_LOCAL_SET(value1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(0))),
@@ -1200,7 +1200,7 @@ WASM_EXEC_TEST(I16x8BitMask) {
 
 WASM_EXEC_TEST(I32x4BitMask) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
-  byte value1 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = r.AllocateLocal(kWasmS128);
 
   r.Build(
       {WASM_LOCAL_SET(value1, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(0))),
@@ -1220,7 +1220,7 @@ WASM_EXEC_TEST(I32x4BitMask) {
 
 WASM_EXEC_TEST(I64x2BitMask) {
   WasmRunner<int32_t, int64_t> r(execution_tier);
-  byte value1 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = r.AllocateLocal(kWasmS128);
 
   r.Build(
       {WASM_LOCAL_SET(value1, WASM_SIMD_I64x2_SPLAT(WASM_LOCAL_GET(0))),
@@ -1240,7 +1240,7 @@ WASM_EXEC_TEST(I8x16Splat) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
   // Set up a global to hold output vector.
   int8_t* g = r.builder().AddGlobal<int8_t>(kWasmS128);
-  byte param1 = 0;
+  uint8_t param1 = 0;
   r.Build({WASM_GLOBAL_SET(0, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(param1))),
            WASM_ONE});
 
@@ -1269,7 +1269,7 @@ WASM_EXEC_TEST(I8x16ReplaceLane) {
   // Set up a global to hold input/output vector.
   int8_t* g = r.builder().AddGlobal<int8_t>(kWasmS128);
   // Build function to replace each lane with its index.
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_I32V(-1))),
            WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_REPLACE_LANE(
                                      0, WASM_LOCAL_GET(temp1), WASM_I32V(0))),
@@ -1332,8 +1332,8 @@ WASM_EXEC_TEST(I32x4ConvertF32x4) {
   int32_t* g0 = r.builder().AddGlobal<int32_t>(kWasmS128);
   int32_t* g1 = r.builder().AddGlobal<int32_t>(kWasmS128);
   // Build fn to splat test value, perform conversions, and write the results.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(kExprI32x4SConvertF32x4,
                                              WASM_LOCAL_GET(temp1))),
@@ -1362,8 +1362,8 @@ WASM_EXEC_TEST(I32x4ConvertI16x8) {
   int32_t* g2 = r.builder().AddGlobal<int32_t>(kWasmS128);
   int32_t* g3 = r.builder().AddGlobal<int32_t>(kWasmS128);
   // Build fn to splat test value, perform conversions, and write the results.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(kExprI32x4SConvertI16x8High,
                                              WASM_LOCAL_GET(temp1))),
@@ -1397,8 +1397,8 @@ WASM_EXEC_TEST(I64x2ConvertI32x4) {
   uint64_t* g2 = r.builder().AddGlobal<uint64_t>(kWasmS128);
   uint64_t* g3 = r.builder().AddGlobal<uint64_t>(kWasmS128);
   // Build fn to splat test value, perform conversions, and write the results.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(kExprI64x2SConvertI32x4High,
                                              WASM_LOCAL_GET(temp1))),
@@ -1539,8 +1539,8 @@ void RunS128ConstBinOpTest(TestExecutionTier execution_tier,
     ScalarType* g = r.builder().template AddGlobal<ScalarType>(kWasmS128);
     // Build a function to splat one argument into a local,
     // and execute the op with a const as the second argument
-    byte value = 0;
-    byte temp = r.AllocateLocal(kWasmS128);
+    uint8_t value = 0;
+    uint8_t temp = r.AllocateLocal(kWasmS128);
     uint8_t const_buffer[16];
     for (size_t i = 0; i < kSimd128Size / sizeof(ScalarType); i++) {
       WriteLittleEndianValue<ScalarType>(
@@ -1724,8 +1724,8 @@ WASM_EXEC_TEST(I16x8ConvertI8x16) {
   int16_t* g2 = r.builder().AddGlobal<int16_t>(kWasmS128);
   int16_t* g3 = r.builder().AddGlobal<int16_t>(kWasmS128);
   // Build fn to splat test value, perform conversions, and write the results.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(kExprI16x8SConvertI8x16High,
                                              WASM_LOCAL_GET(temp1))),
@@ -1757,8 +1757,8 @@ WASM_EXEC_TEST(I16x8ConvertI32x4) {
   int16_t* g0 = r.builder().AddGlobal<int16_t>(kWasmS128);
   int16_t* g1 = r.builder().AddGlobal<int16_t>(kWasmS128);
   // Build fn to splat test value, perform conversions, and write the results.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(kExprI16x8SConvertI32x4,
                                               WASM_LOCAL_GET(temp1),
@@ -2091,9 +2091,9 @@ EXTMUL_ADD_OPTIMIZATION_TEST(int16_t, I16x8, int32_t, I32x4)
 WASM_EXEC_TEST(I32x4DotI16x8S) {
   WasmRunner<int32_t, int16_t, int16_t> r(execution_tier);
   int32_t* g = r.builder().template AddGlobal<int32_t>(kWasmS128);
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(
@@ -2149,8 +2149,8 @@ WASM_EXEC_TEST(I8x16Popcnt) {
   // Global to hold output.
   int8_t* g = r.builder().AddGlobal<int8_t>(kWasmS128);
   // Build fn to splat test value, perform unop, and write the result.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(
                0, WASM_SIMD_UNOP(kExprI8x16Popcnt, WASM_LOCAL_GET(temp1))),
@@ -2172,8 +2172,8 @@ WASM_EXEC_TEST(I8x16ConvertI16x8) {
   int8_t* g_s = r.builder().AddGlobal<int8_t>(kWasmS128);
   uint8_t* g_u = r.builder().AddGlobal<uint8_t>(kWasmS128);
   // Build fn to splat test value, perform conversions, and write the results.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(kExprI8x16SConvertI16x8,
                                               WASM_LOCAL_GET(temp1),
@@ -2340,12 +2340,12 @@ WASM_EXEC_TEST(I8x16ShiftAdd) {
 #define WASM_SIMD_SELECT_TEST(format)                                       \
   WASM_EXEC_TEST(S##format##Select) {                                       \
     WasmRunner<int32_t, int32_t, int32_t> r(execution_tier);                \
-    byte val1 = 0;                                                          \
-    byte val2 = 1;                                                          \
-    byte src1 = r.AllocateLocal(kWasmS128);                                 \
-    byte src2 = r.AllocateLocal(kWasmS128);                                 \
-    byte zero = r.AllocateLocal(kWasmS128);                                 \
-    byte mask = r.AllocateLocal(kWasmS128);                                 \
+    uint8_t val1 = 0;                                                       \
+    uint8_t val2 = 1;                                                       \
+    uint8_t src1 = r.AllocateLocal(kWasmS128);                              \
+    uint8_t src2 = r.AllocateLocal(kWasmS128);                              \
+    uint8_t zero = r.AllocateLocal(kWasmS128);                              \
+    uint8_t mask = r.AllocateLocal(kWasmS128);                              \
     r.Build(                                                                \
         {WASM_LOCAL_SET(src1,                                               \
                         WASM_SIMD_I##format##_SPLAT(WASM_LOCAL_GET(val1))), \
@@ -2379,13 +2379,13 @@ WASM_SIMD_SELECT_TEST(8x16)
 #define WASM_SIMD_NON_CANONICAL_SELECT_TEST(format)                          \
   WASM_EXEC_TEST(S##format##NonCanonicalSelect) {                            \
     WasmRunner<int32_t, int32_t, int32_t, int32_t> r(execution_tier);        \
-    byte val1 = 0;                                                           \
-    byte val2 = 1;                                                           \
-    byte combined = 2;                                                       \
-    byte src1 = r.AllocateLocal(kWasmS128);                                  \
-    byte src2 = r.AllocateLocal(kWasmS128);                                  \
-    byte zero = r.AllocateLocal(kWasmS128);                                  \
-    byte mask = r.AllocateLocal(kWasmS128);                                  \
+    uint8_t val1 = 0;                                                        \
+    uint8_t val2 = 1;                                                        \
+    uint8_t combined = 2;                                                    \
+    uint8_t src1 = r.AllocateLocal(kWasmS128);                               \
+    uint8_t src2 = r.AllocateLocal(kWasmS128);                               \
+    uint8_t zero = r.AllocateLocal(kWasmS128);                               \
+    uint8_t mask = r.AllocateLocal(kWasmS128);                               \
     r.Build(                                                                 \
         {WASM_LOCAL_SET(src1,                                                \
                         WASM_SIMD_I##format##_SPLAT(WASM_LOCAL_GET(val1))),  \
@@ -2764,18 +2764,18 @@ WASM_EXEC_TEST(I8x16ShuffleFuzz) {
   }
 }
 
-void AppendShuffle(const Shuffle& shuffle, std::vector<byte>* buffer) {
-  byte opcode[] = {WASM_SIMD_OP(kExprI8x16Shuffle)};
+void AppendShuffle(const Shuffle& shuffle, std::vector<uint8_t>* buffer) {
+  uint8_t opcode[] = {WASM_SIMD_OP(kExprI8x16Shuffle)};
   for (size_t i = 0; i < arraysize(opcode); ++i) buffer->push_back(opcode[i]);
   for (size_t i = 0; i < kSimd128Size; ++i) buffer->push_back((shuffle[i]));
 }
 
 void BuildShuffle(const std::vector<Shuffle>& shuffles,
-                  std::vector<byte>* buffer) {
+                  std::vector<uint8_t>* buffer) {
   // Perform the leaf shuffles on globals 0 and 1.
   size_t row_index = (shuffles.size() - 1) / 2;
   for (size_t i = row_index; i < shuffles.size(); ++i) {
-    byte operands[] = {WASM_GLOBAL_GET(0), WASM_GLOBAL_GET(1)};
+    uint8_t operands[] = {WASM_GLOBAL_GET(0), WASM_GLOBAL_GET(1)};
     for (size_t j = 0; j < arraysize(operands); ++j)
       buffer->push_back(operands[j]);
     AppendShuffle(shuffles[i], buffer);
@@ -2787,12 +2787,12 @@ void BuildShuffle(const std::vector<Shuffle>& shuffles,
     }
     row_index /= 2;
   } while (row_index != 0);
-  byte epilog[] = {kExprGlobalSet, static_cast<byte>(0), WASM_ONE};
+  uint8_t epilog[] = {kExprGlobalSet, static_cast<uint8_t>(0), WASM_ONE};
   for (size_t j = 0; j < arraysize(epilog); ++j) buffer->push_back(epilog[j]);
 }
 
 void RunWasmCode(TestExecutionTier execution_tier,
-                 const std::vector<byte>& code,
+                 const std::vector<uint8_t>& code,
                  std::array<int8_t, kSimd128Size>* result) {
   WasmRunner<int32_t> r(execution_tier);
   // Set up two test patterns as globals, e.g. [0, 1, 2, 3] and [4, 5, 6, 7].
@@ -2816,9 +2816,9 @@ void RunWasmCode(TestExecutionTier execution_tier,
   WASM_EXEC_TEST(ReductionTest##lanes) {                                      \
     WasmRunner<int32_t> r(execution_tier);                                    \
     if (lanes == 2) return;                                                   \
-    byte zero = r.AllocateLocal(kWasmS128);                                   \
-    byte one_one = r.AllocateLocal(kWasmS128);                                \
-    byte reduced = r.AllocateLocal(kWasmI32);                                 \
+    uint8_t zero = r.AllocateLocal(kWasmS128);                                \
+    uint8_t one_one = r.AllocateLocal(kWasmS128);                             \
+    uint8_t reduced = r.AllocateLocal(kWasmI32);                              \
     r.Build(                                                                  \
         {WASM_LOCAL_SET(zero, WASM_SIMD_I##format##_SPLAT(int_type(0))),      \
          WASM_LOCAL_SET(                                                      \
@@ -3139,15 +3139,15 @@ WASM_EXEC_TEST(F32x4AddRevec) {
   WasmRunner<float, int32_t, int32_t> r(execution_tier);
   float* memory =
       r.builder().AddMemoryElems<float>(kWasmPageSize / sizeof(float));
-  byte param1 = 0;
-  byte param2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
-  byte temp3 = r.AllocateLocal(kWasmS128);
-  byte temp4 = r.AllocateLocal(kWasmS128);
-  byte temp5 = r.AllocateLocal(kWasmF32);
-  byte temp6 = r.AllocateLocal(kWasmF32);
-  constexpr byte offset = 16;
+  uint8_t param1 = 0;
+  uint8_t param2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t temp3 = r.AllocateLocal(kWasmS128);
+  uint8_t temp4 = r.AllocateLocal(kWasmS128);
+  uint8_t temp5 = r.AllocateLocal(kWasmF32);
+  uint8_t temp6 = r.AllocateLocal(kWasmF32);
+  constexpr uint8_t offset = 16;
 
   // Multiple a vector of F32x8 with a constant and store the result to another
   // array
@@ -3229,8 +3229,8 @@ WASM_EXEC_TEST(SimdLoadStoreLoadMemargOffset) {
     WasmRunner<int32_t> r(execution_tier);
     int32_t* memory =
         r.builder().AddMemoryElems<int32_t>(kWasmPageSize / sizeof(int32_t));
-    constexpr byte offset_1 = 4;
-    constexpr byte offset_2 = 8;
+    constexpr uint8_t offset_1 = 4;
+    constexpr uint8_t offset_2 = 8;
     // Load from memory at offset_1, store to offset_2, load from offset_2, and
     // extract first lane. We use non-zero memarg offsets to test offset
     // decoding.
@@ -3358,7 +3358,7 @@ void RunLoadExtendTest(TestExecutionTier execution_tier, WasmOpcode op) {
   constexpr int lanes_t = 16 / sizeof(T);
   constexpr int mem_index = 16;  // Load from mem index 16 (bytes).
   // Load extends always load 64 bits, so alignment values can be from 0 to 3.
-  for (byte alignment = 0; alignment <= 3; alignment++) {
+  for (uint8_t alignment = 0; alignment <= 3; alignment++) {
     WasmRunner<int32_t> r(execution_tier);
     S* memory = r.builder().AddMemoryElems<S>(kWasmPageSize / sizeof(S));
     T* global = r.builder().AddGlobal<T>(kWasmS128);
@@ -3383,7 +3383,7 @@ void RunLoadExtendTest(TestExecutionTier execution_tier, WasmOpcode op) {
     WasmRunner<int32_t> r(execution_tier);
     S* memory = r.builder().AddMemoryElems<S>(kWasmPageSize / sizeof(S));
     T* global = r.builder().AddGlobal<T>(kWasmS128);
-    constexpr byte offset = sizeof(S);
+    constexpr uint8_t offset = sizeof(S);
     r.Build(
         {WASM_GLOBAL_SET(0, WASM_SIMD_LOAD_OP_OFFSET(op, WASM_ZERO, offset)),
          WASM_ONE});
@@ -3464,7 +3464,7 @@ void RunLoadZeroTest(TestExecutionTier execution_tier, WasmOpcode op) {
 
   // Check all supported alignments.
   constexpr int max_alignment = base::bits::CountTrailingZeros(sizeof(S));
-  for (byte alignment = 0; alignment <= max_alignment; alignment++) {
+  for (uint8_t alignment = 0; alignment <= max_alignment; alignment++) {
     WasmRunner<int32_t> r(execution_tier);
     std::tie(memory, global) = initialize_builder(&r);
 
@@ -3526,20 +3526,20 @@ WASM_EXEC_TEST(S128Load64Zero) {
 template <typename T>
 void RunLoadLaneTest(TestExecutionTier execution_tier, WasmOpcode load_op,
                      WasmOpcode splat_op) {
-  byte const_op = static_cast<byte>(
+  uint8_t const_op = static_cast<uint8_t>(
       splat_op == kExprI64x2Splat ? kExprI64Const : kExprI32Const);
 
-  constexpr byte lanes_s = kSimd128Size / sizeof(T);
+  constexpr uint8_t lanes_s = kSimd128Size / sizeof(T);
   constexpr int mem_index = 16;  // Load from mem index 16 (bytes).
-  constexpr byte splat_value = 33;
+  constexpr uint8_t splat_value = 33;
   T sentinel = T{-1};
 
   T* memory;
   T* global;
 
   auto build_fn = [=, &memory, &global](WasmRunner<int32_t>& r, int mem_index,
-                                        byte lane, byte alignment,
-                                        byte offset) {
+                                        uint8_t lane, uint8_t alignment,
+                                        uint8_t offset) {
     memory = r.builder().AddMemoryElems<T>(kWasmPageSize / sizeof(T));
     global = r.builder().AddGlobal<T>(kWasmS128);
     r.builder().WriteMemory(&memory[lanes_s], sentinel);
@@ -3552,13 +3552,13 @@ void RunLoadLaneTest(TestExecutionTier execution_tier, WasmOpcode load_op,
 
   auto check_results = [=](T* global, int sentinel_lane = 0) {
     // Only one lane is loaded, the rest of the lanes are unchanged.
-    for (byte i = 0; i < lanes_s; i++) {
+    for (uint8_t i = 0; i < lanes_s; i++) {
       T expected = i == sentinel_lane ? sentinel : static_cast<T>(splat_value);
       CHECK_EQ(expected, LANE(global, i));
     }
   };
 
-  for (byte lane_index = 0; lane_index < lanes_s; ++lane_index) {
+  for (uint8_t lane_index = 0; lane_index < lanes_s; ++lane_index) {
     WasmRunner<int32_t> r(execution_tier);
     build_fn(r, mem_index, lane_index, /*alignment=*/0, /*offset=*/0);
     r.Call();
@@ -3567,7 +3567,7 @@ void RunLoadLaneTest(TestExecutionTier execution_tier, WasmOpcode load_op,
 
   // Check all possible alignments.
   constexpr int max_alignment = base::bits::CountTrailingZeros(sizeof(T));
-  for (byte alignment = 0; alignment <= max_alignment; ++alignment) {
+  for (uint8_t alignment = 0; alignment <= max_alignment; ++alignment) {
     WasmRunner<int32_t> r(execution_tier);
     build_fn(r, mem_index, /*lane=*/0, alignment, /*offset=*/0);
     r.Call();
@@ -3624,16 +3624,17 @@ WASM_EXEC_TEST(S128Load64Lane) {
 template <typename T>
 void RunStoreLaneTest(TestExecutionTier execution_tier, WasmOpcode store_op,
                       WasmOpcode splat_op) {
-  constexpr byte lanes = kSimd128Size / sizeof(T);
+  constexpr uint8_t lanes = kSimd128Size / sizeof(T);
   constexpr int mem_index = 16;  // Store to mem index 16 (bytes).
-  constexpr byte splat_value = 33;
-  byte const_op = static_cast<byte>(
+  constexpr uint8_t splat_value = 33;
+  uint8_t const_op = static_cast<uint8_t>(
       splat_op == kExprI64x2Splat ? kExprI64Const : kExprI32Const);
 
   T* memory;  // Will be set by build_fn.
 
   auto build_fn = [=, &memory](WasmRunner<int32_t>& r, int mem_index,
-                               byte lane_index, byte alignment, byte offset) {
+                               uint8_t lane_index, uint8_t alignment,
+                               uint8_t offset) {
     memory = r.builder().AddMemoryElems<T>(kWasmPageSize / sizeof(T));
     // Splat splat_value, then only Store and replace a single lane.
     r.Build({WASM_I32V(mem_index), const_op, splat_value,
@@ -3643,18 +3644,18 @@ void RunStoreLaneTest(TestExecutionTier execution_tier, WasmOpcode store_op,
   };
 
   auto check_results = [=](WasmRunner<int32_t>& r, T* memory) {
-    for (byte i = 0; i < lanes; i++) {
+    for (uint8_t i = 0; i < lanes; i++) {
       CHECK_EQ(0, r.builder().ReadMemory(&memory[i]));
     }
 
     CHECK_EQ(splat_value, r.builder().ReadMemory(&memory[lanes]));
 
-    for (byte i = lanes + 1; i < lanes * 2; i++) {
+    for (uint8_t i = lanes + 1; i < lanes * 2; i++) {
       CHECK_EQ(0, r.builder().ReadMemory(&memory[i]));
     }
   };
 
-  for (byte lane_index = 0; lane_index < lanes; lane_index++) {
+  for (uint8_t lane_index = 0; lane_index < lanes; lane_index++) {
     WasmRunner<int32_t> r(execution_tier);
     build_fn(r, mem_index, lane_index, ZERO_ALIGNMENT, ZERO_OFFSET);
     r.Call();
@@ -3663,7 +3664,7 @@ void RunStoreLaneTest(TestExecutionTier execution_tier, WasmOpcode store_op,
 
   // Check all possible alignments.
   constexpr int max_alignment = base::bits::CountTrailingZeros(sizeof(T));
-  for (byte alignment = 0; alignment <= max_alignment; ++alignment) {
+  for (uint8_t alignment = 0; alignment <= max_alignment; ++alignment) {
     WasmRunner<int32_t> r(execution_tier);
     build_fn(r, mem_index, /*lane_index=*/0, alignment, ZERO_OFFSET);
     r.Call();
@@ -3718,7 +3719,7 @@ WASM_EXEC_TEST(S128Store64Lane) {
   WASM_EXEC_TEST(S##format##AnyTrue) {                                         \
     WasmRunner<int32_t, param_type> r(execution_tier);                         \
     if (lanes == 2) return;                                                    \
-    byte simd = r.AllocateLocal(kWasmS128);                                    \
+    uint8_t simd = r.AllocateLocal(kWasmS128);                                 \
     r.Build(                                                                   \
         {WASM_LOCAL_SET(simd, WASM_SIMD_I##format##_SPLAT(WASM_LOCAL_GET(0))), \
          WASM_SIMD_UNOP(kExprV128AnyTrue, WASM_LOCAL_GET(simd))});             \
@@ -3735,7 +3736,7 @@ WASM_SIMD_ANYTRUE_TEST(8x16, 16, 0xff, int32_t)
 // 0.0 and -0.0 will be different in an anytrue (IEEE753 says they are equals).
 WASM_EXEC_TEST(V128AnytrueWithNegativeZero) {
   WasmRunner<int32_t, int64_t> r(execution_tier);
-  byte simd = r.AllocateLocal(kWasmS128);
+  uint8_t simd = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(simd, WASM_SIMD_I64x2_SPLAT(WASM_LOCAL_GET(0))),
            WASM_SIMD_UNOP(kExprV128AnyTrue, WASM_LOCAL_GET(simd))});
   CHECK_EQ(1, r.Call(0x8000000000000000));
@@ -3746,7 +3747,7 @@ WASM_EXEC_TEST(V128AnytrueWithNegativeZero) {
   WASM_EXEC_TEST(I##format##AllTrue) {                                         \
     WasmRunner<int32_t, param_type> r(execution_tier);                         \
     if (lanes == 2) return;                                                    \
-    byte simd = r.AllocateLocal(kWasmS128);                                    \
+    uint8_t simd = r.AllocateLocal(kWasmS128);                                 \
     r.Build(                                                                   \
         {WASM_LOCAL_SET(simd, WASM_SIMD_I##format##_SPLAT(WASM_LOCAL_GET(0))), \
          WASM_SIMD_UNOP(kExprI##format##AllTrue, WASM_LOCAL_GET(simd))});      \
@@ -3761,7 +3762,7 @@ WASM_SIMD_ALLTRUE_TEST(8x16, 16, 0xff, int32_t)
 
 WASM_EXEC_TEST(BitSelect) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
-  byte simd = r.AllocateLocal(kWasmS128);
+  uint8_t simd = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(
                simd, WASM_SIMD_SELECT(
                          32x4, WASM_SIMD_I32x4_SPLAT(WASM_I32V(0x01020304)),
@@ -3774,7 +3775,7 @@ WASM_EXEC_TEST(BitSelect) {
 void RunSimdConstTest(TestExecutionTier execution_tier,
                       const std::array<uint8_t, kSimd128Size>& expected) {
   WasmRunner<uint32_t> r(execution_tier);
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   uint8_t* src0 = r.builder().AddGlobal<uint8_t>(kWasmS128);
   r.Build({WASM_GLOBAL_SET(temp1, WASM_SIMD_CONSTANT(expected)), WASM_ONE});
   CHECK_EQ(1, r.Call());
@@ -3854,7 +3855,7 @@ WASM_EXEC_TEST(I16x8GtUMixed) {
 WASM_EXEC_TEST(I16x8ExtractLaneU_I8x16Splat) {
   // Test that we are correctly signed/unsigned extending when extracting.
   WasmRunner<int32_t, int32_t> r(execution_tier);
-  byte simd_val = r.AllocateLocal(kWasmS128);
+  uint8_t simd_val = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(simd_val, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(0))),
            WASM_SIMD_I16x8_EXTRACT_LANE_U(0, WASM_LOCAL_GET(simd_val))});
   CHECK_EQ(0xfafa, r.Call(0xfa));
@@ -3954,8 +3955,8 @@ WASM_EXEC_TEST(AddExtAddPairwiseI32LeftUnsigned) {
 WASM_EXEC_TEST(Regress_12237) {
   WasmRunner<int32_t, int64_t> r(execution_tier);
   int64_t* g = r.builder().AddGlobal<int64_t>(kWasmS128);
-  byte value = 0;
-  byte temp = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp = r.AllocateLocal(kWasmS128);
   int64_t local = 123;
   r.Build({WASM_LOCAL_SET(
                temp, WASM_SIMD_OPN(kExprI64x2Splat, WASM_LOCAL_GET(value))),
@@ -3975,8 +3976,8 @@ WASM_EXEC_TEST(Regress_12237) {
 #define WASM_EXTRACT_I16x8_TEST(Sign, Type)                                  \
   WASM_EXEC_TEST(I16X8ExtractLane##Sign) {                                   \
     WasmRunner<int32_t, int32_t> r(execution_tier);                          \
-    byte int_val = r.AllocateLocal(kWasmI32);                                \
-    byte simd_val = r.AllocateLocal(kWasmS128);                              \
+    uint8_t int_val = r.AllocateLocal(kWasmI32);                             \
+    uint8_t simd_val = r.AllocateLocal(kWasmS128);                           \
     r.Build({WASM_LOCAL_SET(simd_val,                                        \
                             WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(int_val))), \
              WASM_SIMD_CHECK_LANE_U(I16x8, simd_val, I32, int_val, 0),       \
@@ -3992,8 +3993,8 @@ WASM_EXTRACT_I16x8_TEST(S, UINT16) WASM_EXTRACT_I16x8_TEST(I, INT16)
 #define WASM_EXTRACT_I8x16_TEST(Sign, Type)                                  \
   WASM_EXEC_TEST(I8x16ExtractLane##Sign) {                                   \
     WasmRunner<int32_t, int32_t> r(execution_tier);                          \
-    byte int_val = r.AllocateLocal(kWasmI32);                                \
-    byte simd_val = r.AllocateLocal(kWasmS128);                              \
+    uint8_t int_val = r.AllocateLocal(kWasmI32);                             \
+    uint8_t simd_val = r.AllocateLocal(kWasmS128);                           \
     r.Build({WASM_LOCAL_SET(simd_val,                                        \
                             WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(int_val))), \
              WASM_SIMD_CHECK_LANE_U(I8x16, simd_val, I32, int_val, 1),       \
diff --git a/test/cctest/wasm/test-run-wasm-wrappers.cc b/test/cctest/wasm/test-run-wasm-wrappers.cc
index 584ded1109b..6cbcea4da52 100644
--- a/test/cctest/wasm/test-run-wasm-wrappers.cc
+++ b/test/cctest/wasm/test-run-wasm-wrappers.cc
@@ -84,8 +84,8 @@ TEST(WrapperBudget) {
     TestSignatures sigs;
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_ii());
     f->builder()->AddExport(base::CStrVector("main"), f);
-    byte code[] = {WASM_I32_MUL(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
-                   WASM_END};
+    uint8_t code[] = {WASM_I32_MUL(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
+                      WASM_END};
     f->EmitCode(code, sizeof(code));
 
     // Compile the module.
@@ -134,7 +134,7 @@ TEST(WrapperReplacement) {
     TestSignatures sigs;
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_i());
     f->builder()->AddExport(base::CStrVector("main"), f);
-    byte code[] = {WASM_LOCAL_GET(0), WASM_END};
+    uint8_t code[] = {WASM_LOCAL_GET(0), WASM_END};
     f->EmitCode(code, sizeof(code));
 
     // Compile the module.
@@ -208,17 +208,17 @@ TEST(EagerWrapperReplacement) {
     TestSignatures sigs;
     WasmFunctionBuilder* add = builder->AddFunction(sigs.i_ii());
     add->builder()->AddExport(base::CStrVector("add"), add);
-    byte add_code[] = {WASM_I32_ADD(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
-                       WASM_END};
+    uint8_t add_code[] = {WASM_I32_ADD(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
+                          WASM_END};
     add->EmitCode(add_code, sizeof(add_code));
     WasmFunctionBuilder* mult = builder->AddFunction(sigs.i_ii());
     mult->builder()->AddExport(base::CStrVector("mult"), mult);
-    byte mult_code[] = {WASM_I32_MUL(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
-                        WASM_END};
+    uint8_t mult_code[] = {WASM_I32_MUL(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
+                           WASM_END};
     mult->EmitCode(mult_code, sizeof(mult_code));
     WasmFunctionBuilder* id = builder->AddFunction(sigs.i_i());
     id->builder()->AddExport(base::CStrVector("id"), id);
-    byte id_code[] = {WASM_LOCAL_GET(0), WASM_END};
+    uint8_t id_code[] = {WASM_LOCAL_GET(0), WASM_END};
     id->EmitCode(id_code, sizeof(id_code));
 
     // Compile the module.
@@ -313,7 +313,7 @@ TEST(WrapperReplacement_IndirectExport) {
     // Define a Wasm function, but do not add it to the exports.
     TestSignatures sigs;
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_i());
-    byte code[] = {WASM_LOCAL_GET(0), WASM_END};
+    uint8_t code[] = {WASM_LOCAL_GET(0), WASM_END};
     f->EmitCode(code, sizeof(code));
     uint32_t function_index = f->func_index();
 
diff --git a/test/cctest/wasm/test-run-wasm.cc b/test/cctest/wasm/test-run-wasm.cc
index 2cf87f12f35..6d87b89e30b 100644
--- a/test/cctest/wasm/test-run-wasm.cc
+++ b/test/cctest/wasm/test-run-wasm.cc
@@ -92,8 +92,8 @@ WASM_EXEC_TEST(Int32Add_P_fallthru) {
   FOR_INT32_INPUTS(i) { CHECK_EQ(base::AddWithWraparound(i, 13), r.Call(i)); }
 }
 
-static void RunInt32AddTest(TestExecutionTier execution_tier, const byte* code,
-                            size_t size) {
+static void RunInt32AddTest(TestExecutionTier execution_tier,
+                            const uint8_t* code, size_t size) {
   TestSignatures sigs;
   WasmRunner<int32_t, int32_t, int32_t> r(execution_tier);
   r.builder().AddSignature(sigs.ii_v());
@@ -109,26 +109,26 @@ static void RunInt32AddTest(TestExecutionTier execution_tier, const byte* code,
 }
 
 WASM_EXEC_TEST(Int32Add_P2) {
-  static const byte code[] = {
+  static const uint8_t code[] = {
       WASM_I32_ADD(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
   RunInt32AddTest(execution_tier, code, sizeof(code));
 }
 
 WASM_EXEC_TEST(Int32Add_block1) {
-  static const byte code[] = {
+  static const uint8_t code[] = {
       WASM_BLOCK_X(1, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)), kExprI32Add};
   RunInt32AddTest(execution_tier, code, sizeof(code));
 }
 
 WASM_EXEC_TEST(Int32Add_block2) {
-  static const byte code[] = {
+  static const uint8_t code[] = {
       WASM_BLOCK_X(1, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1), kExprBr, DEPTH_0),
       kExprI32Add};
   RunInt32AddTest(execution_tier, code, sizeof(code));
 }
 
 WASM_EXEC_TEST(Int32Add_multi_if) {
-  static const byte code[] = {
+  static const uint8_t code[] = {
       WASM_IF_ELSE_X(1, WASM_LOCAL_GET(0),
                      WASM_SEQ(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
                      WASM_SEQ(WASM_LOCAL_GET(1), WASM_LOCAL_GET(0))),
@@ -1092,10 +1092,10 @@ WASM_EXEC_TEST(BrTable4) {
 }
 
 WASM_EXEC_TEST(BrTable4x4) {
-  for (byte a = 0; a < 4; ++a) {
-    for (byte b = 0; b < 4; ++b) {
-      for (byte c = 0; c < 4; ++c) {
-        for (byte d = 0; d < 4; ++d) {
+  for (uint8_t a = 0; a < 4; ++a) {
+    for (uint8_t b = 0; b < 4; ++b) {
+      for (uint8_t c = 0; c < 4; ++c) {
+        for (uint8_t d = 0; d < 4; ++d) {
           for (int i = 0; i < 4; ++i) {
             uint32_t cases[] = {a, b, c, d};
 
@@ -1628,7 +1628,7 @@ WASM_EXEC_TEST(LoadMemI32) {
 }
 
 WASM_EXEC_TEST(LoadMemI32_alignment) {
-  for (byte alignment = 0; alignment <= 2; ++alignment) {
+  for (uint8_t alignment = 0; alignment <= 2; ++alignment) {
     WasmRunner<int32_t, int32_t> r(execution_tier);
     int32_t* memory =
         r.builder().AddMemoryElems<int32_t>(kWasmPageSize / sizeof(int32_t));
@@ -1679,10 +1679,10 @@ WASM_EXEC_TEST(LoadMem_offset_oob) {
 
   for (size_t m = 0; m < arraysize(machineTypes); ++m) {
     WasmRunner<int32_t, uint32_t> r(execution_tier);
-    r.builder().AddMemoryElems<byte>(num_bytes);
+    r.builder().AddMemoryElems<uint8_t>(num_bytes);
     r.builder().RandomizeMemory(1116 + static_cast<int>(m));
 
-    constexpr byte kOffset = 8;
+    constexpr uint8_t kOffset = 8;
     uint32_t boundary = num_bytes - kOffset - machineTypes[m].MemSize();
 
     r.Build({WASM_LOAD_MEM_OFFSET(machineTypes[m], kOffset, WASM_LOCAL_GET(0)),
@@ -1724,13 +1724,13 @@ WASM_EXEC_TEST(LoadMemI32_offset) {
 WASM_EXEC_TEST(LoadMemI32_const_oob_misaligned) {
   // This test accesses memory starting at kRunwayLength bytes before the end of
   // the memory until a few bytes beyond.
-  constexpr byte kRunwayLength = 12;
+  constexpr uint8_t kRunwayLength = 12;
   // TODO(titzer): Fix misaligned accesses on MIPS and re-enable.
-  for (byte offset = 0; offset < kRunwayLength + 5; ++offset) {
+  for (uint8_t offset = 0; offset < kRunwayLength + 5; ++offset) {
     for (uint32_t index = kWasmPageSize - kRunwayLength;
          index < kWasmPageSize + 5; ++index) {
       WasmRunner<int32_t> r(execution_tier);
-      r.builder().AddMemoryElems<byte>(kWasmPageSize);
+      r.builder().AddMemoryElems<uint8_t>(kWasmPageSize);
       r.builder().RandomizeMemory();
 
       r.Build({WASM_LOAD_MEM_OFFSET(MachineType::Int32(), offset,
@@ -1748,12 +1748,12 @@ WASM_EXEC_TEST(LoadMemI32_const_oob_misaligned) {
 WASM_EXEC_TEST(LoadMemI32_const_oob) {
   // This test accesses memory starting at kRunwayLength bytes before the end of
   // the memory until a few bytes beyond.
-  constexpr byte kRunwayLength = 24;
-  for (byte offset = 0; offset < kRunwayLength + 5; offset += 4) {
+  constexpr uint8_t kRunwayLength = 24;
+  for (uint8_t offset = 0; offset < kRunwayLength + 5; offset += 4) {
     for (uint32_t index = kWasmPageSize - kRunwayLength;
          index < kWasmPageSize + 5; index += 4) {
       WasmRunner<int32_t> r(execution_tier);
-      r.builder().AddMemoryElems<byte>(kWasmPageSize);
+      r.builder().AddMemoryElems<uint8_t>(kWasmPageSize);
       r.builder().RandomizeMemory();
 
       r.Build({WASM_LOAD_MEM_OFFSET(MachineType::Int32(), offset,
@@ -1771,7 +1771,7 @@ WASM_EXEC_TEST(LoadMemI32_const_oob) {
 WASM_EXEC_TEST(StoreMemI32_alignment) {
   const int32_t kWritten = 0x12345678;
 
-  for (byte i = 0; i <= 2; ++i) {
+  for (uint8_t i = 0; i <= 2; ++i) {
     WasmRunner<int32_t, int32_t> r(execution_tier);
     int32_t* memory =
         r.builder().AddMemoryElems<int32_t>(kWasmPageSize / sizeof(int32_t));
@@ -1821,7 +1821,7 @@ WASM_EXEC_TEST(StoreMem_offset_oob) {
 
   for (size_t m = 0; m < arraysize(machineTypes); ++m) {
     WasmRunner<int32_t, uint32_t> r(execution_tier);
-    byte* memory = r.builder().AddMemoryElems<byte>(num_bytes);
+    uint8_t* memory = r.builder().AddMemoryElems<uint8_t>(num_bytes);
 
     r.builder().RandomizeMemory(1119 + static_cast<int>(m));
 
@@ -1829,7 +1829,7 @@ WASM_EXEC_TEST(StoreMem_offset_oob) {
                                    WASM_LOAD_MEM(machineTypes[m], WASM_ZERO)),
              WASM_ZERO});
 
-    byte memsize = machineTypes[m].MemSize();
+    uint8_t memsize = machineTypes[m].MemSize();
     uint32_t boundary = num_bytes - 8 - memsize;
     CHECK_EQ(0, r.Call(boundary));  // in bounds.
     CHECK_EQ(0, memcmp(&memory[0], &memory[8 + boundary], memsize));
@@ -1841,8 +1841,8 @@ WASM_EXEC_TEST(StoreMem_offset_oob) {
 }
 
 WASM_EXEC_TEST(Store_i32_narrowed) {
-  constexpr byte kOpcodes[] = {kExprI32StoreMem8, kExprI32StoreMem16,
-                               kExprI32StoreMem};
+  constexpr uint8_t kOpcodes[] = {kExprI32StoreMem8, kExprI32StoreMem16,
+                                  kExprI32StoreMem};
   int stored_size_in_bytes = 0;
   for (auto opcode : kOpcodes) {
     stored_size_in_bytes = std::max(1, stored_size_in_bytes * 2);
@@ -1889,7 +1889,7 @@ WASM_EXEC_TEST(MemI32_Sum) {
   WasmRunner<uint32_t, int32_t> r(execution_tier);
   uint32_t* memory =
       r.builder().AddMemoryElems<uint32_t>(kWasmPageSize / sizeof(int32_t));
-  const byte kSum = r.AllocateLocal(kWasmI32);
+  const uint8_t kSum = r.AllocateLocal(kWasmI32);
 
   r.Build(
       {WASM_WHILE(
@@ -1955,7 +1955,7 @@ WASM_EXEC_TEST(MemF32_Sum) {
   r.builder().WriteMemory(&buffer[2], -77.25f);
   r.builder().WriteMemory(&buffer[3], 66666.25f);
   r.builder().WriteMemory(&buffer[4], 5555.25f);
-  const byte kSum = r.AllocateLocal(kWasmF32);
+  const uint8_t kSum = r.AllocateLocal(kWasmF32);
 
   r.Build(
       {WASM_WHILE(WASM_LOCAL_GET(0),
@@ -1984,7 +1984,7 @@ T GenerateAndRunFold(TestExecutionTier execution_tier, WasmOpcode binop,
   for (uint32_t i = 0; i < size; ++i) {
     r.builder().WriteMemory(&memory[i], buffer[i]);
   }
-  const byte kAccum = r.AllocateLocal(astType);
+  const uint8_t kAccum = r.AllocateLocal(astType);
 
   r.Build(
       {WASM_LOCAL_SET(kAccum, WASM_LOAD_MEM(memType, WASM_ZERO)),
@@ -2134,19 +2134,19 @@ static void TestBuildGraphForSimpleExpression(WasmOpcode opcode) {
                      DynamicTiering::kDynamicTiering);
 
   if (sig->parameter_count() == 1) {
-    byte code[] = {WASM_NO_LOCALS, kExprLocalGet, 0, static_cast<byte>(opcode),
-                   WASM_END};
+    uint8_t code[] = {WASM_NO_LOCALS, kExprLocalGet, 0,
+                      static_cast<uint8_t>(opcode), WASM_END};
     TestBuildingGraph(&zone, &jsgraph, &env, sig, nullptr, code,
                       code + arraysize(code));
   } else {
     CHECK_EQ(2, sig->parameter_count());
-    byte code[] = {WASM_NO_LOCALS,
-                   kExprLocalGet,
-                   0,
-                   kExprLocalGet,
-                   1,
-                   static_cast<byte>(opcode),
-                   WASM_END};
+    uint8_t code[] = {WASM_NO_LOCALS,
+                      kExprLocalGet,
+                      0,
+                      kExprLocalGet,
+                      1,
+                      static_cast<uint8_t>(opcode),
+                      WASM_END};
     TestBuildingGraph(&zone, &jsgraph, &env, sig, nullptr, code,
                       code + arraysize(code));
   }
@@ -2178,7 +2178,7 @@ WASM_EXEC_TEST(Int32LoadInt8_signext) {
 WASM_EXEC_TEST(Int32LoadInt8_zeroext) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
   const int kNumElems = kWasmPageSize;
-  byte* memory = r.builder().AddMemory(kNumElems);
+  uint8_t* memory = r.builder().AddMemory(kNumElems);
   r.builder().RandomizeMemory(77);
   memory[0] = 255;
   r.Build({WASM_LOAD_MEM(MachineType::Uint8(), WASM_LOCAL_GET(0))});
@@ -2191,7 +2191,7 @@ WASM_EXEC_TEST(Int32LoadInt8_zeroext) {
 WASM_EXEC_TEST(Int32LoadInt16_signext) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
   const int kNumBytes = kWasmPageSize;
-  byte* memory = r.builder().AddMemory(kNumBytes);
+  uint8_t* memory = r.builder().AddMemory(kNumBytes);
   r.builder().RandomizeMemory(888);
   memory[1] = 200;
   r.Build({WASM_LOAD_MEM(MachineType::Int16(), WASM_LOCAL_GET(0))});
@@ -2205,7 +2205,7 @@ WASM_EXEC_TEST(Int32LoadInt16_signext) {
 WASM_EXEC_TEST(Int32LoadInt16_zeroext) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
   const int kNumBytes = kWasmPageSize;
-  byte* memory = r.builder().AddMemory(kNumBytes);
+  uint8_t* memory = r.builder().AddMemory(kNumBytes);
   r.builder().RandomizeMemory(9999);
   memory[1] = 204;
   r.Build({WASM_LOAD_MEM(MachineType::Uint16(), WASM_LOCAL_GET(0))});
@@ -2299,7 +2299,7 @@ WASM_EXEC_TEST(MixedGlobals) {
   WasmRunner<int32_t, int32_t> r(execution_tier);
 
   int32_t* unused = r.builder().AddGlobal<int32_t>();
-  byte* memory = r.builder().AddMemory(kWasmPageSize);
+  uint8_t* memory = r.builder().AddMemory(kWasmPageSize);
 
   int32_t* var_int32 = r.builder().AddGlobal<int32_t>();
   uint32_t* var_uint32 = r.builder().AddGlobal<uint32_t>();
@@ -2392,7 +2392,7 @@ WASM_EXEC_TEST(CallF64StackParameter) {
 WASM_EXEC_TEST(CallVoid) {
   WasmRunner<int32_t> r(execution_tier);
 
-  const byte kMemOffset = 8;
+  const uint8_t kMemOffset = 8;
   const int32_t kElemNum = kMemOffset / sizeof(int32_t);
   const int32_t kExpected = 414444;
   // Build the target function.
@@ -2798,7 +2798,7 @@ static void Run_WasmMixedCall_N(TestExecutionTier execution_tier, int start) {
     // =========================================================================
     // Build the calling function.
     // =========================================================================
-    std::vector<byte> code;
+    std::vector<uint8_t> code;
 
     // Load the arguments.
     for (int i = 0; i < num_params; ++i) {
@@ -2810,7 +2810,7 @@ static void Run_WasmMixedCall_N(TestExecutionTier execution_tier, int start) {
     ADD_CODE(code, WASM_CALL_FUNCTION0(f.function_index()));
 
     // Store the result in a local.
-    byte local_index = r.AllocateLocal(ValueType::For(result));
+    uint8_t local_index = r.AllocateLocal(ValueType::For(result));
     ADD_CODE(code, kExprLocalSet, local_index);
 
     // Store the result in memory.
@@ -2830,8 +2830,8 @@ static void Run_WasmMixedCall_N(TestExecutionTier execution_tier, int start) {
       int size = result.MemSize();
       for (int i = 0; i < size; ++i) {
         int base = (which + 1) * kElemSize;
-        byte expected = r.builder().raw_mem_at<byte>(base + i);
-        byte actual = r.builder().raw_mem_at<byte>(i);
+        uint8_t expected = r.builder().raw_mem_at<uint8_t>(base + i);
+        uint8_t actual = r.builder().raw_mem_at<uint8_t>(i);
         CHECK_EQ(expected, actual);
       }
     }
@@ -2848,7 +2848,7 @@ WASM_EXEC_TEST(AddCall) {
   WasmFunctionCompiler& t1 = r.NewFunction<int32_t, int32_t, int32_t>();
   t1.Build({WASM_I32_ADD(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))});
 
-  byte local = r.AllocateLocal(kWasmI32);
+  uint8_t local = r.AllocateLocal(kWasmI32);
   r.Build({WASM_LOCAL_SET(local, WASM_I32V_2(99)),
            WASM_I32_ADD(
                WASM_CALL_FUNCTION(t1.function_index(), WASM_LOCAL_GET(0),
@@ -3498,7 +3498,7 @@ static void CompileCallIndirectMany(TestExecutionTier tier, ValueType param) {
   // Make sure we don't run out of registers when compiling indirect calls
   // with many many parameters.
   TestSignatures sigs;
-  for (byte num_params = 0; num_params < 40; ++num_params) {
+  for (uint8_t num_params = 0; num_params < 40; ++num_params) {
     WasmRunner<void> r(tier);
     FunctionSig* sig = sigs.many(r.zone(), kWasmVoid, param, num_params);
 
@@ -3508,8 +3508,8 @@ static void CompileCallIndirectMany(TestExecutionTier tier, ValueType param) {
 
     WasmFunctionCompiler& t = r.NewFunction(sig);
 
-    std::vector<byte> code;
-    for (byte p = 0; p < num_params; ++p) {
+    std::vector<uint8_t> code;
+    for (uint8_t p = 0; p < num_params; ++p) {
       ADD_CODE(code, kExprLocalGet, p);
     }
     ADD_CODE(code, kExprI32Const, 0);
@@ -3666,7 +3666,7 @@ WASM_EXEC_TEST(IfInsideUnreachable) {
 WASM_EXEC_TEST(IndirectNull) {
   WasmRunner<int32_t> r(execution_tier);
   FunctionSig sig(1, 0, &kWasmI32);
-  byte sig_index = r.builder().AddSignature(&sig);
+  uint8_t sig_index = r.builder().AddSignature(&sig);
   r.builder().AddIndirectFunctionTable(nullptr, 1);
 
   r.Build({WASM_CALL_INDIRECT(sig_index, WASM_I32V(0))});
@@ -3677,7 +3677,7 @@ WASM_EXEC_TEST(IndirectNull) {
 WASM_EXEC_TEST(IndirectNullTyped) {
   WasmRunner<int32_t> r(execution_tier);
   FunctionSig sig(1, 0, &kWasmI32);
-  byte sig_index = r.builder().AddSignature(&sig);
+  uint8_t sig_index = r.builder().AddSignature(&sig);
   r.builder().AddIndirectFunctionTable(nullptr, 1,
                                        ValueType::RefNull(sig_index));
 
@@ -3699,7 +3699,7 @@ void BinOpOnDifferentRegisters(
   static constexpr int kMaxNumLocals = 8;
   for (int num_locals = 1; num_locals < kMaxNumLocals; ++num_locals) {
     // {init_locals_code} is shared by all code generated in the loop below.
-    std::vector<byte> init_locals_code;
+    std::vector<uint8_t> init_locals_code;
     // Load from memory into the locals.
     for (int i = 0; i < num_locals; ++i) {
       ADD_CODE(
@@ -3708,7 +3708,7 @@ void BinOpOnDifferentRegisters(
                                           WASM_I32V_2(sizeof(ctype) * i))));
     }
     // {write_locals_code} is shared by all code generated in the loop below.
-    std::vector<byte> write_locals_code;
+    std::vector<uint8_t> write_locals_code;
     // Write locals back into memory, shifted by one element to the right.
     for (int i = 0; i < num_locals; ++i) {
       ADD_CODE(write_locals_code,
@@ -3724,7 +3724,7 @@ void BinOpOnDifferentRegisters(
         for (int i = 0; i < num_locals; ++i) {
           r.AllocateLocal(type);
         }
-        std::vector<byte> code(init_locals_code);
+        std::vector<uint8_t> code(init_locals_code);
         ADD_CODE(code,
                  // Store the result of the binary operation at memory[0].
                  WASM_STORE_MEM(type.machine_type(), WASM_ZERO,
diff --git a/test/cctest/wasm/test-streaming-compilation.cc b/test/cctest/wasm/test-streaming-compilation.cc
index 84bc7cea2e2..47f420255c2 100644
--- a/test/cctest/wasm/test-streaming-compilation.cc
+++ b/test/cctest/wasm/test-streaming-compilation.cc
@@ -346,7 +346,7 @@ ZoneBuffer GetValidCompiledModuleBytes(v8::Isolate* isolate, Zone* zone,
   // Serialize the NativeModule.
   i::wasm::WasmSerializer serializer(native_module);
   size_t size = serializer.GetSerializedNativeModuleSize();
-  std::vector<byte> buffer(size);
+  std::vector<uint8_t> buffer(size);
   CHECK(serializer.SerializeNativeModule(base::VectorOf(buffer)));
   ZoneBuffer result(zone, size);
   result.write(buffer.data(), size);
@@ -1345,7 +1345,7 @@ STREAM_TEST(TestDeserializationFails) {
   ZoneBuffer module_bytes =
       GetValidCompiledModuleBytes(isolate, tester.zone(), wire_bytes);
   // corrupt header
-  byte first_byte = *module_bytes.begin();
+  uint8_t first_byte = *module_bytes.begin();
   module_bytes.patch_u8(0, first_byte + 1);
   tester.SetCompiledModuleBytes(base::VectorOf(module_bytes));
   tester.OnBytesReceived(wire_bytes.begin(), wire_bytes.size());
diff --git a/test/cctest/wasm/test-wasm-metrics.cc b/test/cctest/wasm/test-wasm-metrics.cc
index 397d37089ac..2e6e423808c 100644
--- a/test/cctest/wasm/test-wasm-metrics.cc
+++ b/test/cctest/wasm/test-wasm-metrics.cc
@@ -278,7 +278,7 @@ COMPILE_TEST(TestEventMetrics) {
   WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
   WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
   f->builder()->AddExport(base::CStrVector("main"), f);
-  byte code[] = {WASM_I32V_2(0)};
+  uint8_t code[] = {WASM_I32V_2(0)};
   f->EmitCode(code, sizeof(code));
   f->Emit(kExprEnd);
   ZoneBuffer buffer(&zone);
diff --git a/test/cctest/wasm/test-wasm-serialization.cc b/test/cctest/wasm/test-wasm-serialization.cc
index 39ebe0c9ef4..d8f9c566752 100644
--- a/test/cctest/wasm/test-wasm-serialization.cc
+++ b/test/cctest/wasm/test-wasm-serialization.cc
@@ -43,8 +43,8 @@ class WasmSerializationTest {
     WasmFunctionBuilder* f;
     for (int i = 0; i < 3; ++i) {
       f = builder->AddFunction(sigs.i_i());
-      byte code[] = {WASM_LOCAL_GET(0), kExprI32Const, 1, kExprI32Add,
-                     kExprEnd};
+      uint8_t code[] = {WASM_LOCAL_GET(0), kExprI32Const, 1, kExprI32Add,
+                        kExprEnd};
       f->EmitCode(code, sizeof(code));
     }
     builder->AddExport(base::CStrVector(kFunctionName), f);
@@ -83,7 +83,7 @@ class WasmSerializationTest {
     CHECK(Deserialize().ToHandle(&module_object));
     {
       DisallowGarbageCollection assume_no_gc;
-      base::Vector<const byte> deserialized_module_wire_bytes =
+      base::Vector<const uint8_t> deserialized_module_wire_bytes =
           module_object->native_module()->wire_bytes();
       CHECK_EQ(deserialized_module_wire_bytes.size(), wire_bytes_.size());
       CHECK_EQ(memcmp(deserialized_module_wire_bytes.begin(),
diff --git a/test/cctest/wasm/test-wasm-shared-engine.cc b/test/cctest/wasm/test-wasm-shared-engine.cc
index d02c8ff6add..fddd379db70 100644
--- a/test/cctest/wasm/test-wasm-shared-engine.cc
+++ b/test/cctest/wasm/test-wasm-shared-engine.cc
@@ -106,7 +106,7 @@ ZoneBuffer* BuildReturnConstantModule(Zone* zone, int constant) {
   WasmModuleBuilder* builder = zone->New<WasmModuleBuilder>(zone);
   WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
   f->builder()->AddExport(base::CStrVector("main"), f);
-  byte code[] = {WASM_I32V_2(constant)};
+  uint8_t code[] = {WASM_I32V_2(constant)};
   f->EmitCode(code, sizeof(code));
   f->Emit(kExprEnd);
   builder->WriteTo(buffer);
diff --git a/test/cctest/wasm/test-wasm-stack.cc b/test/cctest/wasm/test-wasm-stack.cc
index e93808f3d9c..e7f462cf3ea 100644
--- a/test/cctest/wasm/test-wasm-stack.cc
+++ b/test/cctest/wasm/test-wasm-stack.cc
@@ -175,7 +175,7 @@ WASM_COMPILED_EXEC_TEST(CollectDetailedWasmStack_WasmUrl) {
   WasmRunner<int> r(execution_tier, kWasmOrigin, nullptr, "main",
                     kRuntimeExceptionSupport);
 
-  std::vector<byte> trap_code(1, kExprUnreachable);
+  std::vector<uint8_t> trap_code(1, kExprUnreachable);
   r.Build(trap_code.data(), trap_code.data() + trap_code.size());
 
   WasmFunctionCompiler& f = r.NewFunction<int>("call_main");
@@ -237,7 +237,7 @@ WASM_COMPILED_EXEC_TEST(CollectDetailedWasmStack_WasmError) {
     WasmRunner<int> r(execution_tier, kWasmOrigin, nullptr, "main",
                       kRuntimeExceptionSupport);
 
-    std::vector<byte> trap_code(unreachable_pos + 1, kExprNop);
+    std::vector<uint8_t> trap_code(unreachable_pos + 1, kExprNop);
     trap_code[unreachable_pos] = kExprUnreachable;
     r.Build(trap_code.data(), trap_code.data() + trap_code.size());
 
diff --git a/test/cctest/wasm/wasm-run-utils.cc b/test/cctest/wasm/wasm-run-utils.cc
index 6d9401c6a1e..bddc9181b86 100644
--- a/test/cctest/wasm/wasm-run-utils.cc
+++ b/test/cctest/wasm/wasm-run-utils.cc
@@ -58,7 +58,7 @@ TestingModuleBuilder::TestingModuleBuilder(
   test_module_->untagged_globals_buffer_size = kMaxGlobalsSize;
   // The GlobalsData must be located inside the sandbox, so allocate it from the
   // ArrayBuffer allocator.
-  globals_data_ = reinterpret_cast<byte*>(
+  globals_data_ = reinterpret_cast<uint8_t*>(
       CcTest::array_buffer_allocator()->Allocate(kMaxGlobalsSize));
 
   uint32_t maybe_import_index = 0;
@@ -109,7 +109,7 @@ TestingModuleBuilder::~TestingModuleBuilder() {
   CcTest::array_buffer_allocator()->Free(globals_data_, kMaxGlobalsSize);
 }
 
-byte* TestingModuleBuilder::AddMemory(uint32_t size, SharedFlag shared) {
+uint8_t* TestingModuleBuilder::AddMemory(uint32_t size, SharedFlag shared) {
   CHECK(!test_module_->has_memory);
   CHECK_NULL(mem_start_);
   CHECK_EQ(0, mem_size_);
@@ -130,7 +130,7 @@ byte* TestingModuleBuilder::AddMemory(uint32_t size, SharedFlag shared) {
   instance_object_->set_memory_object(*memory_object);
 
   mem_start_ =
-      reinterpret_cast<byte*>(memory_object->array_buffer().backing_store());
+      reinterpret_cast<uint8_t*>(memory_object->array_buffer().backing_store());
   mem_size_ = size;
   CHECK(size == 0 || mem_start_);
 
@@ -178,8 +178,8 @@ uint32_t TestingModuleBuilder::AddFunction(const FunctionSig* sig,
             test_module_->num_imported_functions +
                 test_module_->num_declared_functions);
   if (name) {
-    base::Vector<const byte> name_vec =
-        base::Vector<const byte>::cast(base::CStrVector(name));
+    base::Vector<const uint8_t> name_vec =
+        base::Vector<const uint8_t>::cast(base::CStrVector(name));
     test_module_->lazily_generated_names.AddForTesting(
         index, {AddBytes(name_vec), static_cast<uint32_t>(name_vec.length())});
   }
@@ -263,7 +263,7 @@ void TestingModuleBuilder::AddIndirectFunctionTable(
   instance_object_->set_tables(*new_tables);
 }
 
-uint32_t TestingModuleBuilder::AddBytes(base::Vector<const byte> bytes) {
+uint32_t TestingModuleBuilder::AddBytes(base::Vector<const uint8_t> bytes) {
   base::Vector<const uint8_t> old_bytes = native_module_->wire_bytes();
   uint32_t old_size = static_cast<uint32_t>(old_bytes.size());
   // Avoid placing strings at offset 0, this might be interpreted as "not
@@ -297,7 +297,7 @@ uint32_t TestingModuleBuilder::AddException(const FunctionSig* sig) {
 }
 
 uint32_t TestingModuleBuilder::AddPassiveDataSegment(
-    base::Vector<const byte> bytes) {
+    base::Vector<const uint8_t> bytes) {
   uint32_t index = static_cast<uint32_t>(test_module_->data_segments.size());
   DCHECK_EQ(index, test_module_->data_segments.size());
   DCHECK_EQ(index, data_segment_starts_.size());
@@ -334,13 +334,13 @@ uint32_t TestingModuleBuilder::AddPassiveDataSegment(
   Handle<FixedAddressArray> data_segment_starts =
       FixedAddressArray::New(isolate_, size);
   data_segment_starts->copy_in(
-      0, reinterpret_cast<byte*>(data_segment_starts_.data()),
+      0, reinterpret_cast<uint8_t*>(data_segment_starts_.data()),
       size * sizeof(Address));
   instance_object_->set_data_segment_starts(*data_segment_starts);
   Handle<FixedUInt32Array> data_segment_sizes =
       FixedUInt32Array::New(isolate_, size);
   data_segment_sizes->copy_in(
-      0, reinterpret_cast<byte*>(data_segment_sizes_.data()),
+      0, reinterpret_cast<uint8_t*>(data_segment_sizes_.data()),
       size * sizeof(uint32_t));
   instance_object_->set_data_segment_sizes(*data_segment_sizes);
   return index;
@@ -352,7 +352,7 @@ CompilationEnv TestingModuleBuilder::CreateCompilationEnv() {
 }
 
 const WasmGlobal* TestingModuleBuilder::AddGlobal(ValueType type) {
-  byte size = type.value_kind_size();
+  uint8_t size = type.value_kind_size();
   global_offset = (global_offset + size - 1) & ~(size - 1);  // align
   test_module_->globals.push_back(
       {type, true, {}, {global_offset}, false, false});
@@ -392,7 +392,7 @@ Handle<WasmInstanceObject> TestingModuleBuilder::InitInstanceObject() {
 
 void TestBuildingGraphWithBuilder(compiler::WasmGraphBuilder* builder,
                                   Zone* zone, const FunctionSig* sig,
-                                  const byte* start, const byte* end) {
+                                  const uint8_t* start, const uint8_t* end) {
   WasmFeatures unused_detected_features;
   FunctionBody body(sig, 0, start, end);
   std::vector<compiler::WasmLoopInfo> loops;
@@ -405,7 +405,7 @@ void TestBuildingGraphWithBuilder(compiler::WasmGraphBuilder* builder,
 void TestBuildingGraph(Zone* zone, compiler::JSGraph* jsgraph,
                        CompilationEnv* env, const FunctionSig* sig,
                        compiler::SourcePositionTable* source_position_table,
-                       const byte* start, const byte* end) {
+                       const uint8_t* start, const uint8_t* end) {
   compiler::WasmGraphBuilder builder(env, zone, jsgraph, sig,
                                      source_position_table);
   TestBuildingGraphWithBuilder(&builder, zone, sig, start, end);
@@ -536,7 +536,8 @@ struct WasmFunctionCompilerBuffer {};
 void WasmFunctionCompiler::Build(base::Vector<const uint8_t> bytes) {
   size_t locals_size = local_decls.Size();
   size_t total_size = bytes.size() + locals_size + 1;
-  byte* buffer = zone()->NewArray<byte, WasmFunctionCompilerBuffer>(total_size);
+  uint8_t* buffer =
+      zone()->NewArray<uint8_t, WasmFunctionCompilerBuffer>(total_size);
   // Prepend the local decls to the code.
   local_decls.Emit(buffer);
   // Emit the code.
diff --git a/test/cctest/wasm/wasm-run-utils.h b/test/cctest/wasm/wasm-run-utils.h
index 7b5f327caa5..91b6fe0c905 100644
--- a/test/cctest/wasm/wasm-run-utils.h
+++ b/test/cctest/wasm/wasm-run-utils.h
@@ -82,7 +82,7 @@ using compiler::Node;
 
 #define ADD_CODE(vec, ...)                           \
   do {                                               \
-    byte __buf[] = {__VA_ARGS__};                    \
+    uint8_t __buf[] = {__VA_ARGS__};                 \
     for (size_t __i = 0; __i < sizeof(__buf); __i++) \
       vec.push_back(__buf[__i]);                     \
   } while (false)
@@ -107,7 +107,7 @@ class TestingModuleBuilder {
                        TestingModuleMemoryType, Isolate* isolate);
   ~TestingModuleBuilder();
 
-  byte* AddMemory(uint32_t size, SharedFlag shared = SharedFlag::kNotShared);
+  uint8_t* AddMemory(uint32_t size, SharedFlag shared = SharedFlag::kNotShared);
 
   size_t CodeTableLength() const { return native_module_->num_functions(); }
 
@@ -124,14 +124,14 @@ class TestingModuleBuilder {
   }
 
   // TODO(7748): Allow selecting type finality.
-  byte AddSignature(const FunctionSig* sig) {
+  uint8_t AddSignature(const FunctionSig* sig) {
     test_module_->add_signature(sig, kNoSuperType, v8_flags.wasm_final_types);
     GetTypeCanonicalizer()->AddRecursiveGroup(test_module_.get(), 1);
     instance_object_->set_isorecursive_canonical_types(
         test_module_->isorecursive_canonical_type_ids.data());
     size_t size = test_module_->types.size();
     CHECK_GT(127, size);
-    return static_cast<byte>(size - 1);
+    return static_cast<uint8_t>(size - 1);
   }
 
   uint32_t mem_size() { return mem_size_; }
@@ -171,14 +171,14 @@ class TestingModuleBuilder {
 
   // Zero-initialize the memory.
   void BlankMemory() {
-    byte* raw = raw_mem_start<byte>();
+    uint8_t* raw = raw_mem_start<uint8_t>();
     memset(raw, 0, mem_size_);
   }
 
   // Pseudo-randomly initialize the memory.
   void RandomizeMemory(unsigned int seed = 88) {
-    byte* raw = raw_mem_start<byte>();
-    byte* end = raw_mem_end<byte>();
+    uint8_t* raw = raw_mem_start<uint8_t>();
+    uint8_t* end = raw_mem_end<uint8_t>();
     v8::base::RandomNumberGenerator rng;
     rng.SetSeed(seed);
     rng.NextBytes(raw, end - raw);
@@ -210,11 +210,11 @@ class TestingModuleBuilder {
                                 uint32_t table_size,
                                 ValueType table_type = kWasmFuncRef);
 
-  uint32_t AddBytes(base::Vector<const byte> bytes);
+  uint32_t AddBytes(base::Vector<const uint8_t> bytes);
 
   uint32_t AddException(const FunctionSig* sig);
 
-  uint32_t AddPassiveDataSegment(base::Vector<const byte> bytes);
+  uint32_t AddPassiveDataSegment(base::Vector<const uint8_t> bytes);
 
   WasmFunction* GetFunctionAt(int index) {
     return &test_module_->functions[index];
@@ -273,9 +273,9 @@ class TestingModuleBuilder {
   Isolate* isolate_;
   WasmFeatures enabled_features_;
   uint32_t global_offset = 0;
-  byte* mem_start_ = nullptr;
+  uint8_t* mem_start_ = nullptr;
   uint32_t mem_size_ = 0;
-  byte* globals_data_ = nullptr;
+  uint8_t* globals_data_ = nullptr;
   TestExecutionTier execution_tier_;
   Handle<WasmInstanceObject> instance_object_;
   NativeModule* native_module_ = nullptr;
@@ -284,10 +284,10 @@ class TestingModuleBuilder {
   int32_t nondeterminism_ = 0;
 
   // Data segment arrays that are normally allocated on the instance.
-  std::vector<byte> data_segment_data_;
+  std::vector<uint8_t> data_segment_data_;
   std::vector<Address> data_segment_starts_;
   std::vector<uint32_t> data_segment_sizes_;
-  std::vector<byte> dropped_elem_segments_;
+  std::vector<uint8_t> dropped_elem_segments_;
 
   const WasmGlobal* AddGlobal(ValueType type);
 
@@ -297,7 +297,7 @@ class TestingModuleBuilder {
 void TestBuildingGraph(Zone* zone, compiler::JSGraph* jsgraph,
                        CompilationEnv* env, const FunctionSig* sig,
                        compiler::SourcePositionTable* source_position_table,
-                       const byte* start, const byte* end);
+                       const uint8_t* start, const uint8_t* end);
 
 class WasmFunctionWrapper : private compiler::GraphAndBuilders {
  public:
@@ -365,9 +365,9 @@ class WasmFunctionCompiler : public compiler::GraphAndBuilders {
   }
   void Build(base::Vector<const uint8_t> bytes);
 
-  byte AllocateLocal(ValueType type) {
+  uint8_t AllocateLocal(ValueType type) {
     uint32_t index = local_decls.AddLocals(1, type);
-    byte result = static_cast<byte>(index);
+    uint8_t result = static_cast<uint8_t>(index);
     DCHECK_EQ(index, result);
     return result;
   }
@@ -444,12 +444,12 @@ class WasmRunnerBase : public InitializedHandleScope {
                                     const char* name = nullptr) {
     functions_.emplace_back(
         new WasmFunctionCompiler(&zone_, sig, &builder_, name));
-    byte sig_index = builder().AddSignature(sig);
+    uint8_t sig_index = builder().AddSignature(sig);
     functions_.back()->SetSigIndex(sig_index);
     return *functions_.back();
   }
 
-  byte AllocateLocal(ValueType type) {
+  uint8_t AllocateLocal(ValueType type) {
     return functions_[0]->AllocateLocal(type);
   }
 
diff --git a/test/cctest/wasm/wasm-simd-utils.cc b/test/cctest/wasm/wasm-simd-utils.cc
index 44dc6ce0751..696f890f8e5 100644
--- a/test/cctest/wasm/wasm-simd-utils.cc
+++ b/test/cctest/wasm/wasm-simd-utils.cc
@@ -28,8 +28,8 @@ void RunI8x16UnOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   int8_t* g = r.builder().AddGlobal<int8_t>(kWasmS128);
   // Build fn to splat test value, perform unop, and write the result.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(opcode, WASM_LOCAL_GET(temp1))),
            WASM_ONE});
@@ -50,9 +50,9 @@ void RunI8x16BinOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   T* g = r.builder().template AddGlobal<T>(kWasmS128);
   // Build fn to splat test values, perform binop, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -85,8 +85,8 @@ void RunI8x16ShiftOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
     int32_t* memory = r.builder().AddMemoryElems<int32_t>(1);
     int8_t* g_imm = r.builder().AddGlobal<int8_t>(kWasmS128);
     int8_t* g_mem = r.builder().AddGlobal<int8_t>(kWasmS128);
-    byte value = 0;
-    byte simd = r.AllocateLocal(kWasmS128);
+    uint8_t value = 0;
+    uint8_t simd = r.AllocateLocal(kWasmS128);
     // Shift using an immediate, and shift using a value loaded from memory.
     r.Build({WASM_LOCAL_SET(simd, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value))),
              WASM_GLOBAL_SET(0, WASM_SIMD_SHIFT_OP(opcode, WASM_LOCAL_GET(simd),
@@ -112,10 +112,10 @@ void RunI8x16ShiftOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
 void RunI8x16MixedRelationalOpTest(TestExecutionTier execution_tier,
                                    WasmOpcode opcode, Int8BinOp expected_op) {
   WasmRunner<int32_t, int32_t, int32_t> r(execution_tier);
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
-  byte temp3 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t temp3 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I8x16_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_LOCAL_SET(temp3, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -136,8 +136,8 @@ void RunI16x8UnOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   int16_t* g = r.builder().AddGlobal<int16_t>(kWasmS128);
   // Build fn to splat test value, perform unop, and write the result.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(opcode, WASM_LOCAL_GET(temp1))),
            WASM_ONE});
@@ -158,9 +158,9 @@ void RunI16x8BinOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   T* g = r.builder().template AddGlobal<T>(kWasmS128);
   // Build fn to splat test values, perform binop, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -192,8 +192,8 @@ void RunI16x8ShiftOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
     int32_t* memory = r.builder().AddMemoryElems<int32_t>(1);
     int16_t* g_imm = r.builder().AddGlobal<int16_t>(kWasmS128);
     int16_t* g_mem = r.builder().AddGlobal<int16_t>(kWasmS128);
-    byte value = 0;
-    byte simd = r.AllocateLocal(kWasmS128);
+    uint8_t value = 0;
+    uint8_t simd = r.AllocateLocal(kWasmS128);
     // Shift using an immediate, and shift using a value loaded from memory.
     r.Build({WASM_LOCAL_SET(simd, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value))),
              WASM_GLOBAL_SET(0, WASM_SIMD_SHIFT_OP(opcode, WASM_LOCAL_GET(simd),
@@ -219,10 +219,10 @@ void RunI16x8ShiftOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
 void RunI16x8MixedRelationalOpTest(TestExecutionTier execution_tier,
                                    WasmOpcode opcode, Int16BinOp expected_op) {
   WasmRunner<int32_t, int32_t, int32_t> r(execution_tier);
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
-  byte temp3 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t temp3 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I16x8_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_LOCAL_SET(temp3, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -243,8 +243,8 @@ void RunI32x4UnOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   int32_t* g = r.builder().AddGlobal<int32_t>(kWasmS128);
   // Build fn to splat test value, perform unop, and write the result.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(opcode, WASM_LOCAL_GET(temp1))),
            WASM_ONE});
@@ -264,9 +264,9 @@ void RunI32x4BinOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   int32_t* g = r.builder().AddGlobal<int32_t>(kWasmS128);
   // Build fn to splat test values, perform binop, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -292,8 +292,8 @@ void RunI32x4ShiftOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
     int32_t* memory = r.builder().AddMemoryElems<int32_t>(1);
     int32_t* g_imm = r.builder().AddGlobal<int32_t>(kWasmS128);
     int32_t* g_mem = r.builder().AddGlobal<int32_t>(kWasmS128);
-    byte value = 0;
-    byte simd = r.AllocateLocal(kWasmS128);
+    uint8_t value = 0;
+    uint8_t simd = r.AllocateLocal(kWasmS128);
     // Shift using an immediate, and shift using a value loaded from memory.
     r.Build({WASM_LOCAL_SET(simd, WASM_SIMD_I32x4_SPLAT(WASM_LOCAL_GET(value))),
              WASM_GLOBAL_SET(0, WASM_SIMD_SHIFT_OP(opcode, WASM_LOCAL_GET(simd),
@@ -322,8 +322,8 @@ void RunI64x2UnOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   int64_t* g = r.builder().AddGlobal<int64_t>(kWasmS128);
   // Build fn to splat test value, perform unop, and write the result.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I64x2_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(opcode, WASM_LOCAL_GET(temp1))),
            WASM_ONE});
@@ -343,9 +343,9 @@ void RunI64x2BinOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   int64_t* g = r.builder().AddGlobal<int64_t>(kWasmS128);
   // Build fn to splat test values, perform binop, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_I64x2_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_I64x2_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -371,8 +371,8 @@ void RunI64x2ShiftOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
     int32_t* memory = r.builder().AddMemoryElems<int32_t>(1);
     int64_t* g_imm = r.builder().AddGlobal<int64_t>(kWasmS128);
     int64_t* g_mem = r.builder().AddGlobal<int64_t>(kWasmS128);
-    byte value = 0;
-    byte simd = r.AllocateLocal(kWasmS128);
+    uint8_t value = 0;
+    uint8_t simd = r.AllocateLocal(kWasmS128);
     // Shift using an immediate, and shift using a value loaded from memory.
     r.Build({WASM_LOCAL_SET(simd, WASM_SIMD_I64x2_SPLAT(WASM_LOCAL_GET(value))),
              WASM_GLOBAL_SET(0, WASM_SIMD_SHIFT_OP(opcode, WASM_LOCAL_GET(simd),
@@ -446,8 +446,8 @@ void RunF32x4UnOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   float* g = r.builder().AddGlobal<float>(kWasmS128);
   // Build fn to splat test value, perform unop, and write the result.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(opcode, WASM_LOCAL_GET(temp1))),
            WASM_ONE});
@@ -505,9 +505,9 @@ void RunF32x4BinOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   float* g = r.builder().AddGlobal<float>(kWasmS128);
   // Build fn to splat test values, perform binop, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -553,9 +553,9 @@ void RunF32x4CompareOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Set up global to hold mask output.
   int32_t* g = r.builder().AddGlobal<int32_t>(kWasmS128);
   // Build fn to splat test values, perform compare op, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_F32x4_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -628,8 +628,8 @@ void RunF64x2UnOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   double* g = r.builder().AddGlobal<double>(kWasmS128);
   // Build fn to splat test value, perform unop, and write the result.
-  byte value = 0;
-  byte temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t value = 0;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(value))),
            WASM_GLOBAL_SET(0, WASM_SIMD_UNOP(opcode, WASM_LOCAL_GET(temp1))),
            WASM_ONE});
@@ -672,9 +672,9 @@ void RunF64x2BinOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Global to hold output.
   double* g = r.builder().AddGlobal<double>(kWasmS128);
   // Build fn to splat test value, perform binop, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(value1))),
            WASM_LOCAL_SET(temp2, WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(value2))),
            WASM_GLOBAL_SET(0, WASM_SIMD_BINOP(opcode, WASM_LOCAL_GET(temp1),
@@ -719,9 +719,9 @@ void RunF64x2CompareOpTest(TestExecutionTier execution_tier, WasmOpcode opcode,
   // Set up global to hold mask output.
   int64_t* g = r.builder().AddGlobal<int64_t>(kWasmS128);
   // Build fn to splat test values, perform compare op, and write the result.
-  byte value1 = 0, value2 = 1;
-  byte temp1 = r.AllocateLocal(kWasmS128);
-  byte temp2 = r.AllocateLocal(kWasmS128);
+  uint8_t value1 = 0, value2 = 1;
+  uint8_t temp1 = r.AllocateLocal(kWasmS128);
+  uint8_t temp2 = r.AllocateLocal(kWasmS128);
   // Make the lanes of each temp compare differently:
   // temp1 = y, x and temp2 = y, y.
   r.Build({WASM_LOCAL_SET(temp1, WASM_SIMD_F64x2_SPLAT(WASM_LOCAL_GET(value1))),
diff --git a/test/common/assembler-tester.h b/test/common/assembler-tester.h
index 880d9839677..053ec3ae2f0 100644
--- a/test/common/assembler-tester.h
+++ b/test/common/assembler-tester.h
@@ -30,8 +30,8 @@ class TestingAssemblerBuffer : public AssemblerBuffer {
 
   ~TestingAssemblerBuffer() override { reservation_.Free(); }
 
-  byte* start() const override {
-    return reinterpret_cast<byte*>(reservation_.address());
+  uint8_t* start() const override {
+    return reinterpret_cast<uint8_t*>(reservation_.address());
   }
 
   int size() const override { return static_cast<int>(reservation_.size()); }
diff --git a/test/common/wasm/wasm-macro-gen.h b/test/common/wasm/wasm-macro-gen.h
index c5ab2dc44b6..ae071d74e53 100644
--- a/test/common/wasm/wasm-macro-gen.h
+++ b/test/common/wasm/wasm-macro-gen.h
@@ -7,11 +7,11 @@
 
 #include "src/wasm/wasm-opcodes.h"
 
-#define U32_LE(v)                                    \
-  static_cast<byte>(v), static_cast<byte>((v) >> 8), \
-      static_cast<byte>((v) >> 16), static_cast<byte>((v) >> 24)
+#define U32_LE(v)                                          \
+  static_cast<uint8_t>(v), static_cast<uint8_t>((v) >> 8), \
+      static_cast<uint8_t>((v) >> 16), static_cast<uint8_t>((v) >> 24)
 
-#define U16_LE(v) static_cast<byte>(v), static_cast<byte>((v) >> 8)
+#define U16_LE(v) static_cast<uint8_t>(v), static_cast<uint8_t>((v) >> 8)
 
 #define WASM_MODULE_HEADER U32_LE(kWasmMagic), U32_LE(kWasmVersion)
 
@@ -33,8 +33,8 @@
 // The table index field in an element segment was repurposed as a flags field.
 // To specify a table index, we have to set the flag value to 2, followed by
 // the table index.
-#define TABLE_INDEX0 static_cast<byte>(ACTIVE_NO_INDEX)
-#define TABLE_INDEX(v) static_cast<byte>(ACTIVE_WITH_INDEX), U32V_1(v)
+#define TABLE_INDEX0 static_cast<uint8_t>(ACTIVE_NO_INDEX)
+#define TABLE_INDEX(v) static_cast<uint8_t>(ACTIVE_WITH_INDEX), U32V_1(v)
 
 #define ZERO_ALIGNMENT 0
 #define ZERO_OFFSET 0
@@ -46,24 +46,25 @@
 #define MASK_21 ((1 << 21) - 1)
 #define MASK_28 ((1 << 28) - 1)
 
-#define U32V_1(x) static_cast<byte>((x)&MASK_7)
-#define U32V_2(x) \
-  static_cast<byte>(((x)&MASK_7) | 0x80), static_cast<byte>(((x) >> 7) & MASK_7)
-#define U32V_3(x)                                      \
-  static_cast<byte>((((x)) & MASK_7) | 0x80),          \
-      static_cast<byte>((((x) >> 7) & MASK_7) | 0x80), \
-      static_cast<byte>(((x) >> 14) & MASK_7)
-#define U32V_4(x)                                       \
-  static_cast<byte>(((x)&MASK_7) | 0x80),               \
-      static_cast<byte>((((x) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>((((x) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((x) >> 21) & MASK_7)
-#define U32V_5(x)                                       \
-  static_cast<byte>(((x)&MASK_7) | 0x80),               \
-      static_cast<byte>((((x) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>((((x) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>((((x) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>((((x) >> 28) & MASK_7))
+#define U32V_1(x) static_cast<uint8_t>((x)&MASK_7)
+#define U32V_2(x)                            \
+  static_cast<uint8_t>(((x)&MASK_7) | 0x80), \
+      static_cast<uint8_t>(((x) >> 7) & MASK_7)
+#define U32V_3(x)                                         \
+  static_cast<uint8_t>((((x)) & MASK_7) | 0x80),          \
+      static_cast<uint8_t>((((x) >> 7) & MASK_7) | 0x80), \
+      static_cast<uint8_t>(((x) >> 14) & MASK_7)
+#define U32V_4(x)                                          \
+  static_cast<uint8_t>(((x)&MASK_7) | 0x80),               \
+      static_cast<uint8_t>((((x) >> 7) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>((((x) >> 14) & MASK_7) | 0x80), \
+      static_cast<uint8_t>(((x) >> 21) & MASK_7)
+#define U32V_5(x)                                          \
+  static_cast<uint8_t>(((x)&MASK_7) | 0x80),               \
+      static_cast<uint8_t>((((x) >> 7) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>((((x) >> 14) & MASK_7) | 0x80), \
+      static_cast<uint8_t>((((x) >> 21) & MASK_7) | 0x80), \
+      static_cast<uint8_t>((((x) >> 28) & MASK_7))
 
 #define U64V_1(x) U32V_1(static_cast<uint32_t>(x))
 #define U64V_2(x) U32V_2(static_cast<uint32_t>(x))
@@ -109,7 +110,8 @@
 #define DEPTH_1 1
 #define DEPTH_2 2
 
-#define WASM_HEAP_TYPE(heap_type) static_cast<byte>((heap_type).code() & 0x7f)
+#define WASM_HEAP_TYPE(heap_type) \
+  static_cast<uint8_t>((heap_type).code() & 0x7f)
 
 #define WASM_REF_TYPE(type)                        \
   (type).kind() == kRef ? kRefCode : kRefNullCode, \
@@ -121,13 +123,13 @@
 #define WASM_BLOCK_F(...) kExprBlock, kF32Code, __VA_ARGS__, kExprEnd
 #define WASM_BLOCK_D(...) kExprBlock, kF64Code, __VA_ARGS__, kExprEnd
 #define WASM_BLOCK_T(t, ...) \
-  kExprBlock, static_cast<byte>((t).value_type_code()), __VA_ARGS__, kExprEnd
+  kExprBlock, static_cast<uint8_t>((t).value_type_code()), __VA_ARGS__, kExprEnd
 
 #define WASM_BLOCK_R(type, ...) \
   kExprBlock, WASM_REF_TYPE(type), __VA_ARGS__, kExprEnd
 
 #define WASM_BLOCK_X(index, ...) \
-  kExprBlock, static_cast<byte>(index), __VA_ARGS__, kExprEnd
+  kExprBlock, static_cast<uint8_t>(index), __VA_ARGS__, kExprEnd
 
 #define WASM_INFINITE_LOOP kExprLoop, kVoidCode, kExprBr, DEPTH_0, kExprEnd
 
@@ -138,23 +140,24 @@
 #define WASM_LOOP_D(...) kExprLoop, kF64Code, __VA_ARGS__, kExprEnd
 
 #define WASM_LOOP_T(t, ...) \
-  kExprLoop, static_cast<byte>((t).value_type_code()), __VA_ARGS__, kExprEnd
+  kExprLoop, static_cast<uint8_t>((t).value_type_code()), __VA_ARGS__, kExprEnd
 
 #define WASM_LOOP_R(t, ...) kExprLoop, TYPE_IMM(t), __VA_ARGS__, kExprEnd
 
 #define WASM_LOOP_X(index, ...) \
-  kExprLoop, static_cast<byte>(index), __VA_ARGS__, kExprEnd
+  kExprLoop, static_cast<uint8_t>(index), __VA_ARGS__, kExprEnd
 
 #define WASM_IF(cond, ...) cond, kExprIf, kVoidCode, __VA_ARGS__, kExprEnd
 
-#define WASM_IF_T(t, cond, ...) \
-  cond, kExprIf, static_cast<byte>((t).value_type_code()), __VA_ARGS__, kExprEnd
+#define WASM_IF_T(t, cond, ...)                                            \
+  cond, kExprIf, static_cast<uint8_t>((t).value_type_code()), __VA_ARGS__, \
+      kExprEnd
 
 #define WASM_IF_R(t, cond, ...) \
   cond, kExprIf, TYPE_IMM(t), __VA_ARGS__, kExprEnd
 
 #define WASM_IF_X(index, cond, ...) \
-  cond, kExprIf, static_cast<byte>(index), __VA_ARGS__, kExprEnd
+  cond, kExprIf, static_cast<uint8_t>(index), __VA_ARGS__, kExprEnd
 
 #define WASM_IF_ELSE(cond, tstmt, fstmt) \
   cond, kExprIf, kVoidCode, tstmt, kExprElse, fstmt, kExprEnd
@@ -168,35 +171,35 @@
 #define WASM_IF_ELSE_D(cond, tstmt, fstmt) \
   cond, kExprIf, kF64Code, tstmt, kExprElse, fstmt, kExprEnd
 
-#define WASM_IF_ELSE_T(t, cond, tstmt, fstmt)                                \
-  cond, kExprIf, static_cast<byte>((t).value_type_code()), tstmt, kExprElse, \
-      fstmt, kExprEnd
+#define WASM_IF_ELSE_T(t, cond, tstmt, fstmt)                        \
+  cond, kExprIf, static_cast<uint8_t>((t).value_type_code()), tstmt, \
+      kExprElse, fstmt, kExprEnd
 
 #define WASM_IF_ELSE_R(t, cond, tstmt, fstmt) \
   cond, kExprIf, WASM_REF_TYPE(t), tstmt, kExprElse, fstmt, kExprEnd
 
-#define WASM_IF_ELSE_X(index, cond, tstmt, fstmt)                            \
-  cond, kExprIf, static_cast<byte>(index), tstmt, kExprElse, fstmt, kExprEnd
+#define WASM_IF_ELSE_X(index, cond, tstmt, fstmt) \
+  cond, kExprIf, static_cast<uint8_t>(index), tstmt, kExprElse, fstmt, kExprEnd
 
 #define WASM_TRY_T(t, trystmt) \
-  kExprTry, static_cast<byte>((t).value_type_code()), trystmt, kExprEnd
-#define WASM_TRY_CATCH_T(t, trystmt, catchstmt, except)                    \
-  kExprTry, static_cast<byte>((t).value_type_code()), trystmt, kExprCatch, \
+  kExprTry, static_cast<uint8_t>((t).value_type_code()), trystmt, kExprEnd
+#define WASM_TRY_CATCH_T(t, trystmt, catchstmt, except)                       \
+  kExprTry, static_cast<uint8_t>((t).value_type_code()), trystmt, kExprCatch, \
       except, catchstmt, kExprEnd
-#define WASM_TRY_CATCH_CATCH_T(t, trystmt, except1, catchstmt1, except2,   \
-                               catchstmt2)                                 \
-  kExprTry, static_cast<byte>((t).value_type_code()), trystmt, kExprCatch, \
+#define WASM_TRY_CATCH_CATCH_T(t, trystmt, except1, catchstmt1, except2,      \
+                               catchstmt2)                                    \
+  kExprTry, static_cast<uint8_t>((t).value_type_code()), trystmt, kExprCatch, \
       except1, catchstmt1, kExprCatch, except2, catchstmt2, kExprEnd
 #define WASM_TRY_CATCH_R(t, trystmt, catchstmt) \
   kExprTry, WASM_REF_TYPE(t), trystmt, kExprCatch, catchstmt, kExprEnd
-#define WASM_TRY_CATCH_ALL_T(t, trystmt, catchstmt)                           \
-  kExprTry, static_cast<byte>((t).value_type_code()), trystmt, kExprCatchAll, \
-      catchstmt, kExprEnd
+#define WASM_TRY_CATCH_ALL_T(t, trystmt, catchstmt)               \
+  kExprTry, static_cast<uint8_t>((t).value_type_code()), trystmt, \
+      kExprCatchAll, catchstmt, kExprEnd
 #define WASM_TRY_DELEGATE(trystmt, depth) \
   kExprTry, kVoidCode, trystmt, kExprDelegate, depth
-#define WASM_TRY_DELEGATE_T(t, trystmt, depth)                                \
-  kExprTry, static_cast<byte>((t).value_type_code()), trystmt, kExprDelegate, \
-      depth
+#define WASM_TRY_DELEGATE_T(t, trystmt, depth)                    \
+  kExprTry, static_cast<uint8_t>((t).value_type_code()), trystmt, \
+      kExprDelegate, depth
 
 #define WASM_SELECT(tval, fval, cond) tval, fval, cond, kExprSelect
 #define WASM_SELECT_I(tval, fval, cond) \
@@ -212,11 +215,11 @@
 #define WASM_SELECT_A(tval, fval, cond) \
   tval, fval, cond, kExprSelectWithType, U32V_1(1), kFuncRefCode
 
-#define WASM_BR(depth) kExprBr, static_cast<byte>(depth)
-#define WASM_BR_IF(depth, cond) cond, kExprBrIf, static_cast<byte>(depth)
+#define WASM_BR(depth) kExprBr, static_cast<uint8_t>(depth)
+#define WASM_BR_IF(depth, cond) cond, kExprBrIf, static_cast<uint8_t>(depth)
 #define WASM_BR_IFD(depth, val, cond) \
-  val, cond, kExprBrIf, static_cast<byte>(depth), kExprDrop
-#define WASM_CONTINUE(depth) kExprBr, static_cast<byte>(depth)
+  val, cond, kExprBrIf, static_cast<uint8_t>(depth), kExprDrop
+#define WASM_CONTINUE(depth) kExprBr, static_cast<uint8_t>(depth)
 #define WASM_UNREACHABLE kExprUnreachable
 #define WASM_RETURN(...) __VA_ARGS__, kExprReturn
 #define WASM_RETURN0 kExprReturn
@@ -224,7 +227,7 @@
 #define WASM_BR_TABLE(key, count, ...) \
   key, kExprBrTable, U32V_1(count), __VA_ARGS__
 
-#define WASM_THROW(index) kExprThrow, static_cast<byte>(index)
+#define WASM_THROW(index) kExprThrow, static_cast<uint8_t>(index)
 
 //------------------------------------------------------------------------------
 // Misc expressions.
@@ -319,248 +322,309 @@ inline uint16_t ExtractPrefixedOpcodeBytes(WasmOpcode opcode) {
 #define WASM_I32V(val) kExprI32Const, U32V_5(val)
 
 #define WASM_I32V_1(val) \
-  static_cast<byte>(CheckI32v((val), 1), kExprI32Const), U32V_1(val)
+  static_cast<uint8_t>(CheckI32v((val), 1), kExprI32Const), U32V_1(val)
 #define WASM_I32V_2(val) \
-  static_cast<byte>(CheckI32v((val), 2), kExprI32Const), U32V_2(val)
+  static_cast<uint8_t>(CheckI32v((val), 2), kExprI32Const), U32V_2(val)
 #define WASM_I32V_3(val) \
-  static_cast<byte>(CheckI32v((val), 3), kExprI32Const), U32V_3(val)
+  static_cast<uint8_t>(CheckI32v((val), 3), kExprI32Const), U32V_3(val)
 #define WASM_I32V_4(val) \
-  static_cast<byte>(CheckI32v((val), 4), kExprI32Const), U32V_4(val)
+  static_cast<uint8_t>(CheckI32v((val), 4), kExprI32Const), U32V_4(val)
 #define WASM_I32V_5(val) \
-  static_cast<byte>(CheckI32v((val), 5), kExprI32Const), U32V_5(val)
+  static_cast<uint8_t>(CheckI32v((val), 5), kExprI32Const), U32V_5(val)
 
 //------------------------------------------------------------------------------
 // Int64 Const operations
 //------------------------------------------------------------------------------
-#define WASM_I64V(val)                                                        \
-  kExprI64Const,                                                              \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 28) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 35) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 42) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 49) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 56) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 63) & MASK_7)
-
-#define WASM_I64V_1(val)                                                     \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 1), kExprI64Const), \
-      static_cast<byte>(static_cast<int64_t>(val) & MASK_7)
-#define WASM_I64V_2(val)                                                     \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 2), kExprI64Const), \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),        \
-      static_cast<byte>((static_cast<int64_t>(val) >> 7) & MASK_7)
-#define WASM_I64V_3(val)                                                     \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 3), kExprI64Const), \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),        \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 14) & MASK_7)
-#define WASM_I64V_4(val)                                                      \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 4), kExprI64Const),  \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 21) & MASK_7)
-#define WASM_I64V_5(val)                                                      \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 5), kExprI64Const),  \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 28) & MASK_7)
-#define WASM_I64V_6(val)                                                      \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 6), kExprI64Const),  \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 28) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 35) & MASK_7)
-#define WASM_I64V_7(val)                                                      \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 7), kExprI64Const),  \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 28) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 35) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 42) & MASK_7)
-#define WASM_I64V_8(val)                                                      \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 8), kExprI64Const),  \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 28) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 35) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 42) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 49) & MASK_7)
-#define WASM_I64V_9(val)                                                      \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 9), kExprI64Const),  \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 28) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 35) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 42) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 49) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 56) & MASK_7)
-#define WASM_I64V_10(val)                                                     \
-  static_cast<byte>(CheckI64v(static_cast<int64_t>(val), 10), kExprI64Const), \
-      static_cast<byte>((static_cast<int64_t>(val) & MASK_7) | 0x80),         \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 7) & MASK_7) | 0x80),  \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 14) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 21) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 28) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 35) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 42) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 49) & MASK_7) | 0x80), \
-      static_cast<byte>(((static_cast<int64_t>(val) >> 56) & MASK_7) | 0x80), \
-      static_cast<byte>((static_cast<int64_t>(val) >> 63) & MASK_7)
-
-#define WASM_F32(val)                                                        \
-  kExprF32Const,                                                             \
-      static_cast<byte>(base::bit_cast<int32_t>(static_cast<float>(val))),   \
-      static_cast<byte>(base::bit_cast<uint32_t>(static_cast<float>(val)) >> \
-                        8),                                                  \
-      static_cast<byte>(base::bit_cast<uint32_t>(static_cast<float>(val)) >> \
-                        16),                                                 \
-      static_cast<byte>(base::bit_cast<uint32_t>(static_cast<float>(val)) >> \
-                        24)
-#define WASM_F64(val)                                                         \
-  kExprF64Const,                                                              \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val))),  \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val)) >> \
-                        8),                                                   \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val)) >> \
-                        16),                                                  \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val)) >> \
-                        24),                                                  \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val)) >> \
-                        32),                                                  \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val)) >> \
-                        40),                                                  \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val)) >> \
-                        48),                                                  \
-      static_cast<byte>(base::bit_cast<uint64_t>(static_cast<double>(val)) >> \
-                        56)
-
-#define WASM_LOCAL_GET(index) kExprLocalGet, static_cast<byte>(index)
-#define WASM_LOCAL_SET(index, val) val, kExprLocalSet, static_cast<byte>(index)
-#define WASM_LOCAL_TEE(index, val) val, kExprLocalTee, static_cast<byte>(index)
+#define WASM_I64V(val)                                                    \
+  kExprI64Const,                                                          \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 21) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 28) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 35) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 42) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 49) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 56) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 63) & MASK_7)
+
+#define WASM_I64V_1(val)                                        \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 1), \
+                       kExprI64Const),                          \
+      static_cast<uint8_t>(static_cast<int64_t>(val) & MASK_7)
+#define WASM_I64V_2(val)                                                 \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 2),          \
+                       kExprI64Const),                                   \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80), \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 7) & MASK_7)
+#define WASM_I64V_3(val)                                                 \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 3),          \
+                       kExprI64Const),                                   \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80), \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) | \
+                           0x80),                                        \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 14) & MASK_7)
+#define WASM_I64V_4(val)                                                  \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 4),           \
+                       kExprI64Const),                                    \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 21) & MASK_7)
+#define WASM_I64V_5(val)                                                  \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 5),           \
+                       kExprI64Const),                                    \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 21) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 28) & MASK_7)
+#define WASM_I64V_6(val)                                                  \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 6),           \
+                       kExprI64Const),                                    \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 21) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 28) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 35) & MASK_7)
+#define WASM_I64V_7(val)                                                  \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 7),           \
+                       kExprI64Const),                                    \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 21) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 28) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 35) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 42) & MASK_7)
+#define WASM_I64V_8(val)                                                  \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 8),           \
+                       kExprI64Const),                                    \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 21) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 28) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 35) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 42) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 49) & MASK_7)
+#define WASM_I64V_9(val)                                                  \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 9),           \
+                       kExprI64Const),                                    \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 21) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 28) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 35) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 42) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 49) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 56) & MASK_7)
+#define WASM_I64V_10(val)                                                 \
+  static_cast<uint8_t>(CheckI64v(static_cast<int64_t>(val), 10),          \
+                       kExprI64Const),                                    \
+      static_cast<uint8_t>((static_cast<int64_t>(val) & MASK_7) | 0x80),  \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 7) & MASK_7) |  \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 14) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 21) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 28) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 35) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 42) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 49) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>(((static_cast<int64_t>(val) >> 56) & MASK_7) | \
+                           0x80),                                         \
+      static_cast<uint8_t>((static_cast<int64_t>(val) >> 63) & MASK_7)
+
+#define WASM_F32(val)                                                         \
+  kExprF32Const,                                                              \
+      static_cast<uint8_t>(base::bit_cast<int32_t>(static_cast<float>(val))), \
+      static_cast<uint8_t>(                                                   \
+          base::bit_cast<uint32_t>(static_cast<float>(val)) >> 8),            \
+      static_cast<uint8_t>(                                                   \
+          base::bit_cast<uint32_t>(static_cast<float>(val)) >> 16),           \
+      static_cast<uint8_t>(                                                   \
+          base::bit_cast<uint32_t>(static_cast<float>(val)) >> 24)
+#define WASM_F64(val)                                                \
+  kExprF64Const,                                                     \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val))),       \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val)) >> 8),  \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val)) >> 16), \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val)) >> 24), \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val)) >> 32), \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val)) >> 40), \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val)) >> 48), \
+      static_cast<uint8_t>(                                          \
+          base::bit_cast<uint64_t>(static_cast<double>(val)) >> 56)
+
+#define WASM_LOCAL_GET(index) kExprLocalGet, static_cast<uint8_t>(index)
+#define WASM_LOCAL_SET(index, val) \
+  val, kExprLocalSet, static_cast<uint8_t>(index)
+#define WASM_LOCAL_TEE(index, val) \
+  val, kExprLocalTee, static_cast<uint8_t>(index)
 #define WASM_DROP kExprDrop
-#define WASM_GLOBAL_GET(index) kExprGlobalGet, static_cast<byte>(index)
+#define WASM_GLOBAL_GET(index) kExprGlobalGet, static_cast<uint8_t>(index)
 #define WASM_GLOBAL_SET(index, val) \
-  val, kExprGlobalSet, static_cast<byte>(index)
+  val, kExprGlobalSet, static_cast<uint8_t>(index)
 #define WASM_TABLE_GET(table_index, index) \
-  index, kExprTableGet, static_cast<byte>(table_index)
+  index, kExprTableGet, static_cast<uint8_t>(table_index)
 #define WASM_TABLE_SET(table_index, index, val) \
-  index, val, kExprTableSet, static_cast<byte>(table_index)
-#define WASM_LOAD_MEM(type, index)                                           \
-  index,                                                                     \
-      static_cast<byte>(v8::internal::wasm::LoadStoreOpcodeOf(type, false)), \
+  index, val, kExprTableSet, static_cast<uint8_t>(table_index)
+#define WASM_LOAD_MEM(type, index)                             \
+  index,                                                       \
+      static_cast<uint8_t>(                                    \
+          v8::internal::wasm::LoadStoreOpcodeOf(type, false)), \
       ZERO_ALIGNMENT, ZERO_OFFSET
-#define WASM_STORE_MEM(type, index, val)                                    \
-  index, val,                                                               \
-      static_cast<byte>(v8::internal::wasm::LoadStoreOpcodeOf(type, true)), \
+#define WASM_STORE_MEM(type, index, val)                                       \
+  index, val,                                                                  \
+      static_cast<uint8_t>(v8::internal::wasm::LoadStoreOpcodeOf(type, true)), \
       ZERO_ALIGNMENT, ZERO_OFFSET
-#define WASM_LOAD_MEM_OFFSET(type, offset, index)                            \
-  index,                                                                     \
-      static_cast<byte>(v8::internal::wasm::LoadStoreOpcodeOf(type, false)), \
+#define WASM_LOAD_MEM_OFFSET(type, offset, index)              \
+  index,                                                       \
+      static_cast<uint8_t>(                                    \
+          v8::internal::wasm::LoadStoreOpcodeOf(type, false)), \
       ZERO_ALIGNMENT, offset
-#define WASM_STORE_MEM_OFFSET(type, offset, index, val)                     \
-  index, val,                                                               \
-      static_cast<byte>(v8::internal::wasm::LoadStoreOpcodeOf(type, true)), \
+#define WASM_STORE_MEM_OFFSET(type, offset, index, val)                        \
+  index, val,                                                                  \
+      static_cast<uint8_t>(v8::internal::wasm::LoadStoreOpcodeOf(type, true)), \
       ZERO_ALIGNMENT, offset
-#define WASM_LOAD_MEM_ALIGNMENT(type, index, alignment)                      \
-  index,                                                                     \
-      static_cast<byte>(v8::internal::wasm::LoadStoreOpcodeOf(type, false)), \
+#define WASM_LOAD_MEM_ALIGNMENT(type, index, alignment)        \
+  index,                                                       \
+      static_cast<uint8_t>(                                    \
+          v8::internal::wasm::LoadStoreOpcodeOf(type, false)), \
       alignment, ZERO_OFFSET
-#define WASM_STORE_MEM_ALIGNMENT(type, index, alignment, val)               \
-  index, val,                                                               \
-      static_cast<byte>(v8::internal::wasm::LoadStoreOpcodeOf(type, true)), \
+#define WASM_STORE_MEM_ALIGNMENT(type, index, alignment, val)                  \
+  index, val,                                                                  \
+      static_cast<uint8_t>(v8::internal::wasm::LoadStoreOpcodeOf(type, true)), \
       alignment, ZERO_OFFSET
-#define WASM_RETHROW(index) kExprRethrow, static_cast<byte>(index)
+#define WASM_RETHROW(index) kExprRethrow, static_cast<uint8_t>(index)
 
-#define WASM_CALL_FUNCTION0(index) kExprCallFunction, static_cast<byte>(index)
+#define WASM_CALL_FUNCTION0(index) \
+  kExprCallFunction, static_cast<uint8_t>(index)
 #define WASM_CALL_FUNCTION(index, ...) \
-  __VA_ARGS__, kExprCallFunction, static_cast<byte>(index)
+  __VA_ARGS__, kExprCallFunction, static_cast<uint8_t>(index)
 
 #define WASM_RETURN_CALL_FUNCTION0(index) \
-  kExprReturnCall, static_cast<byte>(index)
+  kExprReturnCall, static_cast<uint8_t>(index)
 #define WASM_RETURN_CALL_FUNCTION(index, ...) \
-  __VA_ARGS__, kExprReturnCall, static_cast<byte>(index)
+  __VA_ARGS__, kExprReturnCall, static_cast<uint8_t>(index)
 
 #define TABLE_ZERO 0
 
 //------------------------------------------------------------------------------
 // Heap-allocated object operations.
 //------------------------------------------------------------------------------
-#define WASM_GC_OP(op) kGCPrefix, static_cast<byte>(op)
+#define WASM_GC_OP(op) kGCPrefix, static_cast<uint8_t>(op)
 #define WASM_STRUCT_NEW(index, ...) \
-  __VA_ARGS__, WASM_GC_OP(kExprStructNew), static_cast<byte>(index)
+  __VA_ARGS__, WASM_GC_OP(kExprStructNew), static_cast<uint8_t>(index)
 #define WASM_STRUCT_NEW_DEFAULT(index) \
-  WASM_GC_OP(kExprStructNewDefault), static_cast<byte>(index)
-#define WASM_STRUCT_GET(typeidx, fieldidx, struct_obj)                \
-  struct_obj, WASM_GC_OP(kExprStructGet), static_cast<byte>(typeidx), \
-      static_cast<byte>(fieldidx)
-#define WASM_STRUCT_GET_S(typeidx, fieldidx, struct_obj)               \
-  struct_obj, WASM_GC_OP(kExprStructGetS), static_cast<byte>(typeidx), \
-      static_cast<byte>(fieldidx)
-#define WASM_STRUCT_GET_U(typeidx, fieldidx, struct_obj)               \
-  struct_obj, WASM_GC_OP(kExprStructGetU), static_cast<byte>(typeidx), \
-      static_cast<byte>(fieldidx)
-#define WASM_STRUCT_SET(typeidx, fieldidx, struct_obj, value)                \
-  struct_obj, value, WASM_GC_OP(kExprStructSet), static_cast<byte>(typeidx), \
-      static_cast<byte>(fieldidx)
+  WASM_GC_OP(kExprStructNewDefault), static_cast<uint8_t>(index)
+#define WASM_STRUCT_GET(typeidx, fieldidx, struct_obj)                   \
+  struct_obj, WASM_GC_OP(kExprStructGet), static_cast<uint8_t>(typeidx), \
+      static_cast<uint8_t>(fieldidx)
+#define WASM_STRUCT_GET_S(typeidx, fieldidx, struct_obj)                  \
+  struct_obj, WASM_GC_OP(kExprStructGetS), static_cast<uint8_t>(typeidx), \
+      static_cast<uint8_t>(fieldidx)
+#define WASM_STRUCT_GET_U(typeidx, fieldidx, struct_obj)                  \
+  struct_obj, WASM_GC_OP(kExprStructGetU), static_cast<uint8_t>(typeidx), \
+      static_cast<uint8_t>(fieldidx)
+#define WASM_STRUCT_SET(typeidx, fieldidx, struct_obj, value) \
+  struct_obj, value, WASM_GC_OP(kExprStructSet),              \
+      static_cast<uint8_t>(typeidx), static_cast<uint8_t>(fieldidx)
 #define WASM_REF_NULL(type_encoding) kExprRefNull, type_encoding
 #define WASM_REF_FUNC(index) kExprRefFunc, index
 #define WASM_REF_IS_NULL(val) val, kExprRefIsNull
 #define WASM_REF_AS_NON_NULL(val) val, kExprRefAsNonNull
 #define WASM_REF_EQ(lhs, rhs) lhs, rhs, kExprRefEq
 #define WASM_REF_TEST_DEPRECATED(ref, typeidx) \
-  ref, WASM_GC_OP(kExprRefTestDeprecated), static_cast<byte>(typeidx)
+  ref, WASM_GC_OP(kExprRefTestDeprecated), static_cast<uint8_t>(typeidx)
 #define WASM_REF_TEST(ref, typeidx) \
-  ref, WASM_GC_OP(kExprRefTest), static_cast<byte>(typeidx)
+  ref, WASM_GC_OP(kExprRefTest), static_cast<uint8_t>(typeidx)
 #define WASM_REF_TEST_NULL(ref, typeidx) \
-  ref, WASM_GC_OP(kExprRefTestNull), static_cast<byte>(typeidx)
+  ref, WASM_GC_OP(kExprRefTestNull), static_cast<uint8_t>(typeidx)
 #define WASM_REF_CAST_DEPRECATED(ref, typeidx) \
-  ref, WASM_GC_OP(kExprRefCastDeprecated), static_cast<byte>(typeidx)
+  ref, WASM_GC_OP(kExprRefCastDeprecated), static_cast<uint8_t>(typeidx)
 #define WASM_REF_CAST(ref, typeidx) \
-  ref, WASM_GC_OP(kExprRefCast), static_cast<byte>(typeidx)
+  ref, WASM_GC_OP(kExprRefCast), static_cast<uint8_t>(typeidx)
 #define WASM_REF_CAST_NULL(ref, typeidx) \
-  ref, WASM_GC_OP(kExprRefCastNull), static_cast<byte>(typeidx)
+  ref, WASM_GC_OP(kExprRefCastNull), static_cast<uint8_t>(typeidx)
 // Takes a reference value from the value stack to allow sequences of
 // conditional branches.
-#define WASM_BR_ON_CAST(depth, sourcetype, targettype)         \
-  WASM_GC_OP(kExprBrOnCastGeneric),                            \
-      static_cast<byte>(0b01), /*source is nullable*/          \
-      static_cast<byte>(depth), static_cast<byte>(sourcetype), \
-      static_cast<byte>(targettype)
-#define WASM_BR_ON_CAST_NULL(depth, sourcetype, targettype)    \
-  WASM_GC_OP(kExprBrOnCastGeneric),                            \
-      static_cast<byte>(0b11) /*source & target nullable*/,    \
-      static_cast<byte>(depth), static_cast<byte>(sourcetype), \
-      static_cast<byte>(targettype)
-#define WASM_BR_ON_CAST_DEPRECATED(depth, typeidx)               \
-  WASM_GC_OP(kExprBrOnCastDeprecated), static_cast<byte>(depth), \
-      static_cast<byte>(typeidx)
-#define WASM_BR_ON_CAST_FAIL(depth, sourcetype, targettype)    \
-  WASM_GC_OP(kExprBrOnCastFailGeneric),                        \
-      static_cast<byte>(0b01), /*source is nullable*/          \
-      static_cast<byte>(depth), static_cast<byte>(sourcetype), \
-      static_cast<byte>(targettype)
-#define WASM_BR_ON_CAST_FAIL_NULL(depth, sourcetype, targettype) \
-  WASM_GC_OP(kExprBrOnCastFailGeneric),                          \
-      static_cast<byte>(0b11), /*source, target nullable*/       \
-      static_cast<byte>(depth), static_cast<byte>(sourcetype),   \
-      static_cast<byte>(targettype)
-#define WASM_BR_ON_CAST_FAIL_DEPRECATED(depth, typeidx)              \
-  WASM_GC_OP(kExprBrOnCastFailDeprecated), static_cast<byte>(depth), \
-      static_cast<byte>(typeidx)
+#define WASM_BR_ON_CAST(depth, sourcetype, targettype)               \
+  WASM_GC_OP(kExprBrOnCastGeneric),                                  \
+      static_cast<uint8_t>(0b01), /*source is nullable*/             \
+      static_cast<uint8_t>(depth), static_cast<uint8_t>(sourcetype), \
+      static_cast<uint8_t>(targettype)
+#define WASM_BR_ON_CAST_NULL(depth, sourcetype, targettype)          \
+  WASM_GC_OP(kExprBrOnCastGeneric),                                  \
+      static_cast<uint8_t>(0b11) /*source & target nullable*/,       \
+      static_cast<uint8_t>(depth), static_cast<uint8_t>(sourcetype), \
+      static_cast<uint8_t>(targettype)
+#define WASM_BR_ON_CAST_DEPRECATED(depth, typeidx)                  \
+  WASM_GC_OP(kExprBrOnCastDeprecated), static_cast<uint8_t>(depth), \
+      static_cast<uint8_t>(typeidx)
+#define WASM_BR_ON_CAST_FAIL(depth, sourcetype, targettype)          \
+  WASM_GC_OP(kExprBrOnCastFailGeneric),                              \
+      static_cast<uint8_t>(0b01), /*source is nullable*/             \
+      static_cast<uint8_t>(depth), static_cast<uint8_t>(sourcetype), \
+      static_cast<uint8_t>(targettype)
+#define WASM_BR_ON_CAST_FAIL_NULL(depth, sourcetype, targettype)     \
+  WASM_GC_OP(kExprBrOnCastFailGeneric),                              \
+      static_cast<uint8_t>(0b11), /*source, target nullable*/        \
+      static_cast<uint8_t>(depth), static_cast<uint8_t>(sourcetype), \
+      static_cast<uint8_t>(targettype)
+#define WASM_BR_ON_CAST_FAIL_DEPRECATED(depth, typeidx)                 \
+  WASM_GC_OP(kExprBrOnCastFailDeprecated), static_cast<uint8_t>(depth), \
+      static_cast<uint8_t>(typeidx)
 
 #define WASM_GC_INTERNALIZE(extern) extern, WASM_GC_OP(kExprExternInternalize)
 #define WASM_GC_EXTERNALIZE(ref) ref, WASM_GC_OP(kExprExternExternalize)
@@ -572,57 +636,59 @@ inline uint16_t ExtractPrefixedOpcodeBytes(WasmOpcode opcode) {
 #define WASM_REF_AS_ARRAY(ref) ref, WASM_GC_OP(kExprRefAsArray)
 #define WASM_REF_AS_I31(ref) ref, WASM_GC_OP(kExprRefAsI31)
 #define WASM_BR_ON_ARRAY(depth) \
-  WASM_GC_OP(kExprBrOnArray), static_cast<byte>(depth)
+  WASM_GC_OP(kExprBrOnArray), static_cast<uint8_t>(depth)
 #define WASM_BR_ON_STRUCT(depth) \
-  WASM_GC_OP(kExprBrOnStruct), static_cast<byte>(depth)
-#define WASM_BR_ON_I31(depth) WASM_GC_OP(kExprBrOnI31), static_cast<byte>(depth)
+  WASM_GC_OP(kExprBrOnStruct), static_cast<uint8_t>(depth)
+#define WASM_BR_ON_I31(depth) \
+  WASM_GC_OP(kExprBrOnI31), static_cast<uint8_t>(depth)
 #define WASM_BR_ON_NON_ARRAY(depth) \
-  WASM_GC_OP(kExprBrOnNonArray), static_cast<byte>(depth)
+  WASM_GC_OP(kExprBrOnNonArray), static_cast<uint8_t>(depth)
 #define WASM_BR_ON_NON_STRUCT(depth) \
-  WASM_GC_OP(kExprBrOnNonStruct), static_cast<byte>(depth)
+  WASM_GC_OP(kExprBrOnNonStruct), static_cast<uint8_t>(depth)
 #define WASM_BR_ON_NON_I31(depth) \
-  WASM_GC_OP(kExprBrOnNonI31), static_cast<byte>(depth)
+  WASM_GC_OP(kExprBrOnNonI31), static_cast<uint8_t>(depth)
 
 #define WASM_ARRAY_NEW(index, default_value, length) \
-  default_value, length, WASM_GC_OP(kExprArrayNew), static_cast<byte>(index)
+  default_value, length, WASM_GC_OP(kExprArrayNew), static_cast<uint8_t>(index)
 #define WASM_ARRAY_NEW_DEFAULT(index, length) \
-  length, WASM_GC_OP(kExprArrayNewDefault), static_cast<byte>(index)
+  length, WASM_GC_OP(kExprArrayNewDefault), static_cast<uint8_t>(index)
 #define WASM_ARRAY_GET(typeidx, array, index) \
-  array, index, WASM_GC_OP(kExprArrayGet), static_cast<byte>(typeidx)
+  array, index, WASM_GC_OP(kExprArrayGet), static_cast<uint8_t>(typeidx)
 #define WASM_ARRAY_GET_U(typeidx, array, index) \
-  array, index, WASM_GC_OP(kExprArrayGetU), static_cast<byte>(typeidx)
+  array, index, WASM_GC_OP(kExprArrayGetU), static_cast<uint8_t>(typeidx)
 #define WASM_ARRAY_GET_S(typeidx, array, index) \
-  array, index, WASM_GC_OP(kExprArrayGetS), static_cast<byte>(typeidx)
+  array, index, WASM_GC_OP(kExprArrayGetS), static_cast<uint8_t>(typeidx)
 #define WASM_ARRAY_SET(typeidx, array, index, value) \
-  array, index, value, WASM_GC_OP(kExprArraySet), static_cast<byte>(typeidx)
+  array, index, value, WASM_GC_OP(kExprArraySet), static_cast<uint8_t>(typeidx)
 #define WASM_ARRAY_LEN(array) array, WASM_GC_OP(kExprArrayLen)
 #define WASM_ARRAY_COPY(dst_idx, src_idx, dst_array, dst_index, src_array, \
                         src_index, length)                                 \
   dst_array, dst_index, src_array, src_index, length,                      \
-      WASM_GC_OP(kExprArrayCopy), static_cast<byte>(dst_idx),              \
-      static_cast<byte>(src_idx)
-#define WASM_ARRAY_NEW_FIXED(index, length, ...)                         \
-  __VA_ARGS__, WASM_GC_OP(kExprArrayNewFixed), static_cast<byte>(index), \
-      static_cast<byte>(length)
+      WASM_GC_OP(kExprArrayCopy), static_cast<uint8_t>(dst_idx),           \
+      static_cast<uint8_t>(src_idx)
+#define WASM_ARRAY_NEW_FIXED(index, length, ...)                            \
+  __VA_ARGS__, WASM_GC_OP(kExprArrayNewFixed), static_cast<uint8_t>(index), \
+      static_cast<uint8_t>(length)
 
 #define WASM_I31_NEW(val) val, WASM_GC_OP(kExprI31New)
 #define WASM_I31_GET_S(val) val, WASM_GC_OP(kExprI31GetS)
 #define WASM_I31_GET_U(val) val, WASM_GC_OP(kExprI31GetU)
 
 #define WASM_BR_ON_NULL(depth, ref_object) \
-  ref_object, kExprBrOnNull, static_cast<byte>(depth)
+  ref_object, kExprBrOnNull, static_cast<uint8_t>(depth)
 
 #define WASM_BR_ON_NON_NULL(depth, ref_object) \
-  ref_object, kExprBrOnNonNull, static_cast<byte>(depth)
+  ref_object, kExprBrOnNonNull, static_cast<uint8_t>(depth)
 
 // Pass: sig_index, ...args, func_index
 #define WASM_CALL_INDIRECT(sig_index, ...) \
-  __VA_ARGS__, kExprCallIndirect, static_cast<byte>(sig_index), TABLE_ZERO
-#define WASM_CALL_INDIRECT_TABLE(table, sig_index, ...)         \
-  __VA_ARGS__, kExprCallIndirect, static_cast<byte>(sig_index), \
-      static_cast<byte>(table)
-#define WASM_RETURN_CALL_INDIRECT(sig_index, ...) \
-  __VA_ARGS__, kExprReturnCallIndirect, static_cast<byte>(sig_index), TABLE_ZERO
+  __VA_ARGS__, kExprCallIndirect, static_cast<uint8_t>(sig_index), TABLE_ZERO
+#define WASM_CALL_INDIRECT_TABLE(table, sig_index, ...)            \
+  __VA_ARGS__, kExprCallIndirect, static_cast<uint8_t>(sig_index), \
+      static_cast<uint8_t>(table)
+#define WASM_RETURN_CALL_INDIRECT(sig_index, ...)                        \
+  __VA_ARGS__, kExprReturnCallIndirect, static_cast<uint8_t>(sig_index), \
+      TABLE_ZERO
 
 #define WASM_CALL_REF(func_ref, sig_index, ...) \
   __VA_ARGS__, func_ref, kExprCallRef, sig_index
@@ -639,19 +705,19 @@ inline uint16_t ExtractPrefixedOpcodeBytes(WasmOpcode opcode) {
 #define WASM_WHILE(x, y)                                                      \
   kExprLoop, kVoidCode, x, kExprIf, kVoidCode, y, kExprBr, DEPTH_1, kExprEnd, \
       kExprEnd
-#define WASM_INC_LOCAL(index)                                             \
-  kExprLocalGet, static_cast<byte>(index), kExprI32Const, 1, kExprI32Add, \
-      kExprLocalTee, static_cast<byte>(index)
-#define WASM_INC_LOCAL_BYV(index, count)                    \
-  kExprLocalGet, static_cast<byte>(index), kExprI32Const,   \
-      static_cast<byte>(count), kExprI32Add, kExprLocalTee, \
-      static_cast<byte>(index)
-#define WASM_INC_LOCAL_BY(index, count)                     \
-  kExprLocalGet, static_cast<byte>(index), kExprI32Const,   \
-      static_cast<byte>(count), kExprI32Add, kExprLocalSet, \
-      static_cast<byte>(index)
-#define WASM_UNOP(opcode, x) x, static_cast<byte>(opcode)
-#define WASM_BINOP(opcode, x, y) x, y, static_cast<byte>(opcode)
+#define WASM_INC_LOCAL(index)                                                \
+  kExprLocalGet, static_cast<uint8_t>(index), kExprI32Const, 1, kExprI32Add, \
+      kExprLocalTee, static_cast<uint8_t>(index)
+#define WASM_INC_LOCAL_BYV(index, count)                       \
+  kExprLocalGet, static_cast<uint8_t>(index), kExprI32Const,   \
+      static_cast<uint8_t>(count), kExprI32Add, kExprLocalTee, \
+      static_cast<uint8_t>(index)
+#define WASM_INC_LOCAL_BY(index, count)                        \
+  kExprLocalGet, static_cast<uint8_t>(index), kExprI32Const,   \
+      static_cast<uint8_t>(count), kExprI32Add, kExprLocalSet, \
+      static_cast<uint8_t>(index)
+#define WASM_UNOP(opcode, x) x, static_cast<uint8_t>(opcode)
+#define WASM_BINOP(opcode, x, y) x, y, static_cast<uint8_t>(opcode)
 
 //------------------------------------------------------------------------------
 // Int32 operations
@@ -807,7 +873,7 @@ inline uint16_t ExtractPrefixedOpcodeBytes(WasmOpcode opcode) {
 //------------------------------------------------------------------------------
 // Numeric operations
 //------------------------------------------------------------------------------
-#define WASM_NUMERIC_OP(op) kNumericPrefix, static_cast<byte>(op)
+#define WASM_NUMERIC_OP(op) kNumericPrefix, static_cast<uint8_t>(op)
 #define WASM_I32_SCONVERT_SAT_F32(x) x, WASM_NUMERIC_OP(kExprI32SConvertSatF32)
 #define WASM_I32_UCONVERT_SAT_F32(x) x, WASM_NUMERIC_OP(kExprI32UConvertSatF32)
 #define WASM_I32_SCONVERT_SAT_F64(x) x, WASM_NUMERIC_OP(kExprI32SConvertSatF64)
@@ -828,18 +894,19 @@ inline uint16_t ExtractPrefixedOpcodeBytes(WasmOpcode opcode) {
   dst, val, size, WASM_NUMERIC_OP(kExprMemoryFill), MEMORY_ZERO
 #define WASM_TABLE_INIT(table, seg, dst, src, size)             \
   dst, src, size, WASM_NUMERIC_OP(kExprTableInit), U32V_1(seg), \
-      static_cast<byte>(table)
+      static_cast<uint8_t>(table)
 #define WASM_ELEM_DROP(seg) WASM_NUMERIC_OP(kExprElemDrop), U32V_1(seg)
 #define WASM_TABLE_COPY(table_dst, table_src, dst, src, size) \
   dst, src, size, WASM_NUMERIC_OP(kExprTableCopy),            \
-      static_cast<byte>(table_dst), static_cast<byte>(table_src)
+      static_cast<uint8_t>(table_dst), static_cast<uint8_t>(table_src)
 #define WASM_TABLE_GROW(table, initial_value, delta)     \
   initial_value, delta, WASM_NUMERIC_OP(kExprTableGrow), \
-      static_cast<byte>(table)
+      static_cast<uint8_t>(table)
 #define WASM_TABLE_SIZE(table) \
-  WASM_NUMERIC_OP(kExprTableSize), static_cast<byte>(table)
-#define WASM_TABLE_FILL(table, times, value, start) \
-  times, value, start, WASM_NUMERIC_OP(kExprTableFill), static_cast<byte>(table)
+  WASM_NUMERIC_OP(kExprTableSize), static_cast<uint8_t>(table)
+#define WASM_TABLE_FILL(table, times, value, start)     \
+  times, value, start, WASM_NUMERIC_OP(kExprTableFill), \
+      static_cast<uint8_t>(table)
 
 //------------------------------------------------------------------------------
 // Memory Operations.
@@ -868,28 +935,28 @@ inline uint16_t ExtractPrefixedOpcodeBytes(WasmOpcode opcode) {
 #define SIZEOF_SIG_ENTRY_xx_xx 7
 #define SIZEOF_SIG_ENTRY_x_xxx 7
 
-#define WASM_BRV(depth, ...) __VA_ARGS__, kExprBr, static_cast<byte>(depth)
+#define WASM_BRV(depth, ...) __VA_ARGS__, kExprBr, static_cast<uint8_t>(depth)
 #define WASM_BRV_IF(depth, val, cond) \
-  val, cond, kExprBrIf, static_cast<byte>(depth)
+  val, cond, kExprBrIf, static_cast<uint8_t>(depth)
 #define WASM_BRV_IFD(depth, val, cond) \
-  val, cond, kExprBrIf, static_cast<byte>(depth), kExprDrop
+  val, cond, kExprBrIf, static_cast<uint8_t>(depth), kExprDrop
 
 //------------------------------------------------------------------------------
 // Atomic Operations.
 //------------------------------------------------------------------------------
-#define WASM_ATOMICS_OP(op) kAtomicPrefix, static_cast<byte>(op)
+#define WASM_ATOMICS_OP(op) kAtomicPrefix, static_cast<uint8_t>(op)
 #define WASM_ATOMICS_BINOP(op, x, y, representation) \
   x, y, WASM_ATOMICS_OP(op),                         \
-      static_cast<byte>(ElementSizeLog2Of(representation)), ZERO_OFFSET
+      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
 #define WASM_ATOMICS_TERNARY_OP(op, x, y, z, representation) \
   x, y, z, WASM_ATOMICS_OP(op),                              \
-      static_cast<byte>(ElementSizeLog2Of(representation)), ZERO_OFFSET
+      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
 #define WASM_ATOMICS_LOAD_OP(op, x, representation) \
   x, WASM_ATOMICS_OP(op),                           \
-      static_cast<byte>(ElementSizeLog2Of(representation)), ZERO_OFFSET
+      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
 #define WASM_ATOMICS_STORE_OP(op, x, y, representation) \
   x, y, WASM_ATOMICS_OP(op),                            \
-      static_cast<byte>(ElementSizeLog2Of(representation)), ZERO_OFFSET
+      static_cast<uint8_t>(ElementSizeLog2Of(representation)), ZERO_OFFSET
 #define WASM_ATOMICS_WAIT(op, index, value, timeout, offset) \
   index, value, timeout, WASM_ATOMICS_OP(op), ZERO_ALIGNMENT, offset
 #define WASM_ATOMICS_FENCE WASM_ATOMICS_OP(kExprAtomicFence), ZERO_OFFSET
@@ -906,7 +973,7 @@ inline uint16_t ExtractPrefixedOpcodeBytes(WasmOpcode opcode) {
 //------------------------------------------------------------------------------
 // SIMD Operations.
 //------------------------------------------------------------------------------
-#define TO_BYTE(val) static_cast<byte>(val)
+#define TO_BYTE(val) static_cast<uint8_t>(val)
 // Encode all simd ops as a 2-byte LEB.
 #define WASM_SIMD_OP(op) kSimdPrefix, U32V_2(ExtractPrefixedOpcodeBytes(op))
 #define WASM_SIMD_OPN(op, ...) __VA_ARGS__, WASM_SIMD_OP(op)
diff --git a/test/common/wasm/wasm-module-runner.cc b/test/common/wasm/wasm-module-runner.cc
index 43cf41e000e..585e705280d 100644
--- a/test/common/wasm/wasm-module-runner.cc
+++ b/test/common/wasm/wasm-module-runner.cc
@@ -77,8 +77,8 @@ base::OwnedVector<Handle<Object>> MakeDefaultArguments(Isolate* isolate,
   return arguments;
 }
 
-int32_t CompileAndRunWasmModule(Isolate* isolate, const byte* module_start,
-                                const byte* module_end) {
+int32_t CompileAndRunWasmModule(Isolate* isolate, const uint8_t* module_start,
+                                const uint8_t* module_end) {
   HandleScope scope(isolate);
   ErrorThrower thrower(isolate, "CompileAndRunWasmModule");
   MaybeHandle<WasmInstanceObject> instance = CompileAndInstantiateForTesting(
diff --git a/test/common/wasm/wasm-module-runner.h b/test/common/wasm/wasm-module-runner.h
index 2c50aefb75c..9a582a2eb76 100644
--- a/test/common/wasm/wasm-module-runner.h
+++ b/test/common/wasm/wasm-module-runner.h
@@ -39,8 +39,8 @@ int32_t CallWasmFunctionForTesting(
 
 // Decode, verify, and run the function labeled "main" in the
 // given encoded module. The module should have no imports.
-int32_t CompileAndRunWasmModule(Isolate* isolate, const byte* module_start,
-                                const byte* module_end);
+int32_t CompileAndRunWasmModule(Isolate* isolate, const uint8_t* module_start,
+                                const uint8_t* module_end);
 
 // Decode and compile the given module with no imports.
 MaybeHandle<WasmModuleObject> CompileForTesting(Isolate* isolate,
diff --git a/test/fuzzer/multi-return.cc b/test/fuzzer/multi-return.cc
index 576b42e9117..90a36eda1c6 100644
--- a/test/fuzzer/multi-return.cc
+++ b/test/fuzzer/multi-return.cc
@@ -248,7 +248,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   std::shared_ptr<wasm::NativeModule> module =
       AllocateNativeModule(i_isolate, code->instruction_size());
   wasm::WasmCodeRefScope wasm_code_ref_scope;
-  byte* code_start = module->AddCodeForTesting(code)->instructions().begin();
+  uint8_t* code_start = module->AddCodeForTesting(code)->instructions().begin();
   // Generate wrapper.
   int expect = 0;
 
diff --git a/test/fuzzer/wasm-compile.cc b/test/fuzzer/wasm-compile.cc
index 9dc9bdab8ad..b8b6fcb30e3 100644
--- a/test/fuzzer/wasm-compile.cc
+++ b/test/fuzzer/wasm-compile.cc
@@ -529,7 +529,7 @@ class WasmGenerator {
   void simd_const(DataRange* data) {
     builder_->EmitWithPrefix(kExprS128Const);
     for (int i = 0; i < kSimd128Size; i++) {
-      builder_->EmitByte(data->get<byte>());
+      builder_->EmitByte(data->get<uint8_t>());
     }
   }
 
@@ -537,21 +537,21 @@ class WasmGenerator {
   void simd_lane_op(DataRange* data) {
     Generate<Args...>(data);
     builder_->EmitWithPrefix(Op);
-    builder_->EmitByte(data->get<byte>() % lanes);
+    builder_->EmitByte(data->get<uint8_t>() % lanes);
   }
 
   template <WasmOpcode Op, int lanes, ValueKind... Args>
   void simd_lane_memop(DataRange* data) {
     // Simd load/store instructions that have a lane immediate.
     memop<Op, Args...>(data);
-    builder_->EmitByte(data->get<byte>() % lanes);
+    builder_->EmitByte(data->get<uint8_t>() % lanes);
   }
 
   void simd_shuffle(DataRange* data) {
     Generate<kS128, kS128>(data);
     builder_->EmitWithPrefix(kExprI8x16Shuffle);
     for (int i = 0; i < kSimd128Size; i++) {
-      builder_->EmitByte(static_cast<uint8_t>(data->get<byte>() % 32));
+      builder_->EmitByte(static_cast<uint8_t>(data->get<uint8_t>() % 32));
     }
   }
 
@@ -2366,7 +2366,7 @@ WasmInitExpr GenerateInitExpr(Zone* zone, DataRange& range,
     case kI16:
     case kI32: {
       // 50% to generate a constant, 50% to generate a binary operator.
-      byte choice = range.get<byte>() % 6;
+      uint8_t choice = range.get<uint8_t>() % 6;
       switch (choice) {
         case 0:
         case 1:
@@ -2386,7 +2386,7 @@ WasmInitExpr GenerateInitExpr(Zone* zone, DataRange& range,
     }
     case kI64: {
       // 50% to generate a constant, 50% to generate a binary operator.
-      byte choice = range.get<byte>() % 6;
+      uint8_t choice = range.get<uint8_t>() % 6;
       switch (choice) {
         case 0:
         case 1:
diff --git a/test/unittests/assembler/assembler-x64-unittest.cc b/test/unittests/assembler/assembler-x64-unittest.cc
index fd705e48a6c..eed8afe584d 100644
--- a/test/unittests/assembler/assembler-x64-unittest.cc
+++ b/test/unittests/assembler/assembler-x64-unittest.cc
@@ -662,7 +662,7 @@ TEST_F(AssemblerX64Test, AssemblerX64LabelChaining) {
 }
 
 TEST_F(AssemblerX64Test, AssemblerMultiByteNop) {
-  byte buffer[1024];
+  uint8_t buffer[1024];
   Isolate* isolate = i_isolate();
   Assembler masm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof(buffer)));
@@ -730,7 +730,7 @@ void DoSSE2(const v8::FunctionCallbackInfo<v8::Value>& info) {
   v8::Isolate* isolate = info.GetIsolate();
   v8::HandleScope scope(isolate);
   v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  byte buffer[1024];
+  uint8_t buffer[1024];
 
   CHECK(info[0]->IsArray());
   v8::Local<v8::Array> vec = v8::Local<v8::Array>::Cast(info[0]);
@@ -822,7 +822,7 @@ TEST_F(AssemblerX64Test, StackAlignmentForSSE2) {
 TEST_F(AssemblerX64Test, AssemblerX64Extractps) {
   if (!CpuFeatures::IsSupported(SSE4_1)) return;
 
-  byte buffer[256];
+  uint8_t buffer[256];
   Isolate* isolate = i_isolate();
   Assembler masm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof(buffer)));
@@ -852,7 +852,7 @@ using F6 = int(float x, float y);
 TEST_F(AssemblerX64Test, AssemblerX64SSE) {
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -885,7 +885,7 @@ TEST_F(AssemblerX64Test, AssemblerX64SSE3) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -916,7 +916,7 @@ TEST_F(AssemblerX64Test, AssemblerX64FMA_sd) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1138,7 +1138,7 @@ TEST_F(AssemblerX64Test, AssemblerX64FMA_ss) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1356,7 +1356,7 @@ TEST_F(AssemblerX64Test, AssemblerX64FMA_ss) {
 TEST_F(AssemblerX64Test, AssemblerX64SSE_ss) {
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   Assembler masm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1433,7 +1433,7 @@ TEST_F(AssemblerX64Test, AssemblerX64AVX_ss) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   Assembler masm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1517,7 +1517,7 @@ TEST_F(AssemblerX64Test, AssemblerX64AVX_sd) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   Assembler masm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1755,7 +1755,7 @@ TEST_F(AssemblerX64Test, AssemblerX64BMI1) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[1024];
+  uint8_t buffer[1024];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -1943,7 +1943,7 @@ TEST_F(AssemblerX64Test, AssemblerX64LZCNT) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -2001,7 +2001,7 @@ TEST_F(AssemblerX64Test, AssemblerX64POPCNT) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -2059,7 +2059,7 @@ TEST_F(AssemblerX64Test, AssemblerX64BMI2) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[2048];
+  uint8_t buffer[2048];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -2431,7 +2431,7 @@ TEST_F(AssemblerX64Test, AssemblerX64vmovups) {
 
   Isolate* isolate = i_isolate();
   HandleScope scope(isolate);
-  v8::internal::byte buffer[256];
+  uint8_t buffer[256];
   MacroAssembler masm(isolate, v8::internal::CodeObjectRequired::kYes,
                       ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   {
@@ -2491,38 +2491,39 @@ TEST_F(AssemblerX64Test, AssemblerX64Regmove256bit) {
   code->Print(os);
 #endif
 
-  byte expected[] = {// VMOVDQA
-                     // vmovdqa ymm0,ymm1
-                     0xC5, 0xFD, 0x6F, 0xC1,
-                     // vmovdqa ymm4,YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0xFD, 0x6F, 0xA4, 0x8B, 0x10, 0x27, 0x00, 0x00,
-
-                     // VMOVDQU
-                     // vmovdqu ymm10,ymm11
-                     0xC4, 0x41, 0x7E, 0x7F, 0xDA,
-                     // vmovdqu ymm9,YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0x7E, 0x6F, 0x8C, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vmovdqu YMMWORD PTR [rbx+rcx*4+0x2710],ymm0
-                     0xC5, 0xFE, 0x7F, 0x84, 0x8B, 0x10, 0x27, 0x00, 0x00,
-
-                     // vmovaps ymm3, ymm1
-                     0xC5, 0xFC, 0x28, 0xD9,
-                     // vmovups YMMWORD PTR [rcx+rdx*4+0x2710], ymm2
-                     0xC5, 0xFC, 0x11, 0x94, 0x91, 0x10, 0x27, 0x00, 0x00,
-                     // vmovapd ymm0, ymm5
-                     0xC5, 0xFD, 0x28, 0xC5,
-                     // vmovupd ymm6, YMMWORD PTR [r8+r9*4+0x2710]
-                     0xC4, 0x81, 0x7D, 0x10, 0xB4, 0x88, 0x10, 0x27, 0x00, 0x00,
-
-                     // vbroadcastss ymm7, DWORD PTR [rbx+rcx*4+0x2710]
-                     0xc4, 0xe2, 0x7d, 0x18, 0xbc, 0x8b, 0x10, 0x27, 0x00, 0x00,
-
-                     // vmovddup ymm3, ymm2
-                     0xc5, 0xff, 0x12, 0xda,
-                     // vmovddup ymm4, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xc5, 0xff, 0x12, 0xa4, 0x8b, 0x10, 0x27, 0x00, 0x00,
-                     // vmovshdup ymm1, ymm2
-                     0xc5, 0xfe, 0x16, 0xca};
+  uint8_t expected[] = {
+      // VMOVDQA
+      // vmovdqa ymm0,ymm1
+      0xC5, 0xFD, 0x6F, 0xC1,
+      // vmovdqa ymm4,YMMWORD PTR [rbx+rcx*4+0x2710]
+      0xC5, 0xFD, 0x6F, 0xA4, 0x8B, 0x10, 0x27, 0x00, 0x00,
+
+      // VMOVDQU
+      // vmovdqu ymm10,ymm11
+      0xC4, 0x41, 0x7E, 0x7F, 0xDA,
+      // vmovdqu ymm9,YMMWORD PTR [rbx+rcx*4+0x2710]
+      0xC5, 0x7E, 0x6F, 0x8C, 0x8B, 0x10, 0x27, 0x00, 0x00,
+      // vmovdqu YMMWORD PTR [rbx+rcx*4+0x2710],ymm0
+      0xC5, 0xFE, 0x7F, 0x84, 0x8B, 0x10, 0x27, 0x00, 0x00,
+
+      // vmovaps ymm3, ymm1
+      0xC5, 0xFC, 0x28, 0xD9,
+      // vmovups YMMWORD PTR [rcx+rdx*4+0x2710], ymm2
+      0xC5, 0xFC, 0x11, 0x94, 0x91, 0x10, 0x27, 0x00, 0x00,
+      // vmovapd ymm0, ymm5
+      0xC5, 0xFD, 0x28, 0xC5,
+      // vmovupd ymm6, YMMWORD PTR [r8+r9*4+0x2710]
+      0xC4, 0x81, 0x7D, 0x10, 0xB4, 0x88, 0x10, 0x27, 0x00, 0x00,
+
+      // vbroadcastss ymm7, DWORD PTR [rbx+rcx*4+0x2710]
+      0xc4, 0xe2, 0x7d, 0x18, 0xbc, 0x8b, 0x10, 0x27, 0x00, 0x00,
+
+      // vmovddup ymm3, ymm2
+      0xc5, 0xff, 0x12, 0xda,
+      // vmovddup ymm4, YMMWORD PTR [rbx+rcx*4+0x2710]
+      0xc5, 0xff, 0x12, 0xa4, 0x8b, 0x10, 0x27, 0x00, 0x00,
+      // vmovshdup ymm1, ymm2
+      0xc5, 0xfe, 0x16, 0xca};
 
   CHECK_EQ(0, memcmp(expected, desc.buffer, sizeof(expected)));
 }
@@ -2561,7 +2562,7 @@ TEST_F(AssemblerX64Test, AssemblerX64AVX2Op256bit) {
   code->Print(os);
 #endif
 
-  byte expected[] = {
+  uint8_t expected[] = {
       // vpshufd ymm1, ymm2, 85
       0xC5, 0xFD, 0x70, 0xCA, 0x55,
       // vpshufd ymm1,YMMWORD PTR [rbx+rcx*4+0x2710], 85
@@ -2639,54 +2640,55 @@ TEST_F(AssemblerX64Test, AssemblerX64FloatingPoint256bit) {
   code->Print(os);
 #endif
 
-  byte expected[] = {// vandpd ymm1, ymm3, ymm5
-                     0xC5, 0xE5, 0x54, 0xCD,
-                     // vminpd ymm2, ymm3, YMMWORD PTR [r8+r9*4+0x2710]
-                     0xC4, 0x81, 0x65, 0x5D, 0x94, 0x88, 0x10, 0x27, 0x00, 0x00,
-                     // VSQRTPS
-                     0xC5, 0xFC, 0x51, 0xC1,
-                     // VUNPCKLPS
-                     0xC4, 0xC1, 0x64, 0x14, 0xD6,
-                     // VSUBPS
-                     0xC4, 0x41, 0x24, 0x5C, 0xD4,
-                     // vroundps ymm9, ymm2, 0xA
-                     0xC4, 0x63, 0x7D, 0x08, 0xCA, 0x0A,
-                     // vroundpd ymm9, ymm2, 0x8
-                     0xC4, 0x63, 0x7D, 0x09, 0xCA, 0x08,
-                     // VHADDPS ymm1, ymm2, ymm3
-                     0xC5, 0xEF, 0x7C, 0xCB,
-                     // VHADDPS ymm0, ymm1, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xc5, 0xf7, 0x7c, 0x84, 0x8b, 0x10, 0x27, 0x00, 0x00,
-                     // vblendvps ymm0, ymm3, ymm5, ymm9
-                     0xC4, 0xE3, 0x65, 0x4A, 0xC5, 0x90,
-                     // vblendvpd ymm7, ymm4, ymm3, ymm1
-                     0xC4, 0xE3, 0x5D, 0x4B, 0xFB, 0x10,
-                     // vshufps ymm3, ymm1, ymm2, 0x75
-                     0xC5, 0xF4, 0xC6, 0xDA, 0x75,
-                     // vsqrtpd ymm1, ymm2
-                     0xC5, 0xFD, 0x51, 0xCA,
-                     // vsqrtpd ymm1, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0xFD, 0x51, 0x8C, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vcvtpd2ps xmm1, ymm2
-                     0xC5, 0xFD, 0x5A, 0xCA,
-                     // vcvtpd2ps xmm2, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0xFD, 0x5A, 0x94, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vcvtps2dq ymm3, ymm4
-                     0xC5, 0xFD, 0x5B, 0xDC,
-                     // vcvtps2dq ymm5, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0xFD, 0x5B, 0xAC, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vcvttpd2dq xmm6, ymm8
-                     0xC4, 0xC1, 0x7D, 0xE6, 0xF0,
-                     // vcvttpd2dq xmm10, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0x7D, 0xE6, 0x94, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vcvtdq2pd ymm1, xmm2
-                     0xC5, 0xFE, 0xE6, 0xCA,
-                     // vcvtdq2pd ymm1, XMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0xFE, 0xE6, 0x8C, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vcvttps2dq ymm3, ymm2
-                     0xC5, 0xFE, 0x5B, 0xDA,
-                     // vcvttps2dq ymm3, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0xFE, 0x5B, 0x9C, 0x8B, 0x10, 0x27, 0x00, 0x00};
+  uint8_t expected[] = {// vandpd ymm1, ymm3, ymm5
+                        0xC5, 0xE5, 0x54, 0xCD,
+                        // vminpd ymm2, ymm3, YMMWORD PTR [r8+r9*4+0x2710]
+                        0xC4, 0x81, 0x65, 0x5D, 0x94, 0x88, 0x10, 0x27, 0x00,
+                        0x00,
+                        // VSQRTPS
+                        0xC5, 0xFC, 0x51, 0xC1,
+                        // VUNPCKLPS
+                        0xC4, 0xC1, 0x64, 0x14, 0xD6,
+                        // VSUBPS
+                        0xC4, 0x41, 0x24, 0x5C, 0xD4,
+                        // vroundps ymm9, ymm2, 0xA
+                        0xC4, 0x63, 0x7D, 0x08, 0xCA, 0x0A,
+                        // vroundpd ymm9, ymm2, 0x8
+                        0xC4, 0x63, 0x7D, 0x09, 0xCA, 0x08,
+                        // VHADDPS ymm1, ymm2, ymm3
+                        0xC5, 0xEF, 0x7C, 0xCB,
+                        // VHADDPS ymm0, ymm1, YMMWORD PTR [rbx+rcx*4+0x2710]
+                        0xc5, 0xf7, 0x7c, 0x84, 0x8b, 0x10, 0x27, 0x00, 0x00,
+                        // vblendvps ymm0, ymm3, ymm5, ymm9
+                        0xC4, 0xE3, 0x65, 0x4A, 0xC5, 0x90,
+                        // vblendvpd ymm7, ymm4, ymm3, ymm1
+                        0xC4, 0xE3, 0x5D, 0x4B, 0xFB, 0x10,
+                        // vshufps ymm3, ymm1, ymm2, 0x75
+                        0xC5, 0xF4, 0xC6, 0xDA, 0x75,
+                        // vsqrtpd ymm1, ymm2
+                        0xC5, 0xFD, 0x51, 0xCA,
+                        // vsqrtpd ymm1, YMMWORD PTR [rbx+rcx*4+0x2710]
+                        0xC5, 0xFD, 0x51, 0x8C, 0x8B, 0x10, 0x27, 0x00, 0x00,
+                        // vcvtpd2ps xmm1, ymm2
+                        0xC5, 0xFD, 0x5A, 0xCA,
+                        // vcvtpd2ps xmm2, YMMWORD PTR [rbx+rcx*4+0x2710]
+                        0xC5, 0xFD, 0x5A, 0x94, 0x8B, 0x10, 0x27, 0x00, 0x00,
+                        // vcvtps2dq ymm3, ymm4
+                        0xC5, 0xFD, 0x5B, 0xDC,
+                        // vcvtps2dq ymm5, YMMWORD PTR [rbx+rcx*4+0x2710]
+                        0xC5, 0xFD, 0x5B, 0xAC, 0x8B, 0x10, 0x27, 0x00, 0x00,
+                        // vcvttpd2dq xmm6, ymm8
+                        0xC4, 0xC1, 0x7D, 0xE6, 0xF0,
+                        // vcvttpd2dq xmm10, YMMWORD PTR [rbx+rcx*4+0x2710]
+                        0xC5, 0x7D, 0xE6, 0x94, 0x8B, 0x10, 0x27, 0x00, 0x00,
+                        // vcvtdq2pd ymm1, xmm2
+                        0xC5, 0xFE, 0xE6, 0xCA,
+                        // vcvtdq2pd ymm1, XMMWORD PTR [rbx+rcx*4+0x2710]
+                        0xC5, 0xFE, 0xE6, 0x8C, 0x8B, 0x10, 0x27, 0x00, 0x00,
+                        // vcvttps2dq ymm3, ymm2
+                        0xC5, 0xFE, 0x5B, 0xDA,
+                        // vcvttps2dq ymm3, YMMWORD PTR [rbx+rcx*4+0x2710]
+                        0xC5, 0xFE, 0x5B, 0x9C, 0x8B, 0x10, 0x27, 0x00, 0x00};
   CHECK_EQ(0, memcmp(expected, desc.buffer, sizeof(expected)));
 }
 
@@ -2742,67 +2744,67 @@ TEST_F(AssemblerX64Test, AssemblerX64Integer256bit) {
   code->Print(os);
 #endif
 
-  byte expected[] = {// SSE2_AVX_INSTRUCTION
-                     // vpunpcklbw ymm9, ymm2, ymm0
-                     0xC5, 0x6D, 0x60, 0xC8,
-                     // vpacksswb ymm8, ymm3, ymm1
-                     0xC5, 0x65, 0x63, 0xC1,
-                     // vpcmpgtw ymm2, ymm7, ymm9
-                     0xC4, 0xC1, 0x45, 0x65, 0xD1,
-                     // vpand ymm2, ymm3, ymm4
-                     0xC5, 0xE5, 0xDB, 0xD4,
-                     // vpmaxsw ymm10, ymm11, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC5, 0x25, 0xEE, 0x94, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vpaddb ymm1, ymm2, ymm3
-                     0xC5, 0xED, 0xFC, 0xCB,
-                     // vpsraw ymm7, ymm1, xmm4
-                     0xC5, 0xF5, 0xE1, 0xFC,
-                     // vpsllq ymm3, ymm2, xmm1
-                     0xC5, 0xED, 0xF3, 0xD9,
-
-                     // SSSE3_AVX_INSTRUCTION
-                     // vpshufb ymm1, ymm2, ymm3
-                     0xC4, 0xE2, 0x6D, 0x00, 0xCB,
-                     // vphaddw ymm8, ymm9, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC4, 0x62, 0x35, 0x01, 0x84, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     // vpmaddubsw ymm5, ymm7, ymm9
-                     0xC4, 0xC2, 0x45, 0x04, 0xE9,
-                     // vpsignd ymm7, ymm0, ymm1
-                     0xC4, 0xE2, 0x7D, 0x0A, 0xF9,
-                     // vpmulhrsw ymm4, ymm3, ymm1
-                     0xC4, 0xE2, 0x65, 0x0B, 0xE1,
-                     // vpabsb ymm1, ymm2
-                     0xC4, 0xE2, 0x7D, 0x1C, 0xCA,
-                     // vpabsb ymm3, YMMWORD PTR [rbx+rcx+0x2710]
-                     0xC4, 0xE2, 0x7D, 0x1C, 0x9C, 0x8b, 0x10, 0x27, 0x00, 0x00,
-                     // vpabsw ymm6, ymm5
-                     0xC4, 0xE2, 0x7D, 0x1D, 0xF5,
-                     // vpabsd ymm7, ymm10
-                     0xC4, 0xC2, 0x7D, 0x1E, 0xFA,
-
-                     // SSE4_AVX_INSTRUCTION
-                     // vpmuldq ymm1, ymm5, ymm6
-                     0xC4, 0xE2, 0x55, 0x28, 0xCE,
-                     // vpcmpeqq ymm0, ymm2, ymm3
-                     0xC4, 0xE2, 0x6D, 0x29, 0xC3,
-                     // vpackusdw ymm4, ymm2, ymm0
-                     0xC4, 0xE2, 0x6D, 0x2B, 0xE0,
-                     // vpminud ymm8, ymm9, YMMWORD PTR [rbx+rcx*4+0x2710]
-                     0xC4, 0x62, 0x35, 0x3B, 0x84, 0x8B, 0x10, 0x27, 0x0, 0x0,
-                     // vpmaxsb ymm3, ymm4, ymm7
-                     0xC4, 0xE2, 0x5D, 0x3C, 0xDF,
-                     // vpmulld ymm6, ymm5, ymm3
-                     0xC4, 0xE2, 0x55, 0x40, 0xF3,
-
-                     // SSE4_2_AVX_INSTRUCTION
-                     // vpcmpgtq ymm3, ymm2, ymm0
-                     0xC4, 0xE2, 0x6D, 0x37, 0xD8,
-
-                     // vpermq ymm8, YMMWORD PTR [rbx+rcx*4+0x2710], 0x1e
-                     0xC4, 0x63, 0xFD, 0x00, 0x84, 0x8B, 0x10, 0x27, 0x00, 0x00,
-                     0x1E,
-                     // vpermq ymm5, ymm3, 0xD8
-                     0xC4, 0xE3, 0xFD, 0x00, 0xEB, 0xD8};
+  uint8_t expected[] = {
+      // SSE2_AVX_INSTRUCTION
+      // vpunpcklbw ymm9, ymm2, ymm0
+      0xC5, 0x6D, 0x60, 0xC8,
+      // vpacksswb ymm8, ymm3, ymm1
+      0xC5, 0x65, 0x63, 0xC1,
+      // vpcmpgtw ymm2, ymm7, ymm9
+      0xC4, 0xC1, 0x45, 0x65, 0xD1,
+      // vpand ymm2, ymm3, ymm4
+      0xC5, 0xE5, 0xDB, 0xD4,
+      // vpmaxsw ymm10, ymm11, YMMWORD PTR [rbx+rcx*4+0x2710]
+      0xC5, 0x25, 0xEE, 0x94, 0x8B, 0x10, 0x27, 0x00, 0x00,
+      // vpaddb ymm1, ymm2, ymm3
+      0xC5, 0xED, 0xFC, 0xCB,
+      // vpsraw ymm7, ymm1, xmm4
+      0xC5, 0xF5, 0xE1, 0xFC,
+      // vpsllq ymm3, ymm2, xmm1
+      0xC5, 0xED, 0xF3, 0xD9,
+
+      // SSSE3_AVX_INSTRUCTION
+      // vpshufb ymm1, ymm2, ymm3
+      0xC4, 0xE2, 0x6D, 0x00, 0xCB,
+      // vphaddw ymm8, ymm9, YMMWORD PTR [rbx+rcx*4+0x2710]
+      0xC4, 0x62, 0x35, 0x01, 0x84, 0x8B, 0x10, 0x27, 0x00, 0x00,
+      // vpmaddubsw ymm5, ymm7, ymm9
+      0xC4, 0xC2, 0x45, 0x04, 0xE9,
+      // vpsignd ymm7, ymm0, ymm1
+      0xC4, 0xE2, 0x7D, 0x0A, 0xF9,
+      // vpmulhrsw ymm4, ymm3, ymm1
+      0xC4, 0xE2, 0x65, 0x0B, 0xE1,
+      // vpabsb ymm1, ymm2
+      0xC4, 0xE2, 0x7D, 0x1C, 0xCA,
+      // vpabsb ymm3, YMMWORD PTR [rbx+rcx+0x2710]
+      0xC4, 0xE2, 0x7D, 0x1C, 0x9C, 0x8b, 0x10, 0x27, 0x00, 0x00,
+      // vpabsw ymm6, ymm5
+      0xC4, 0xE2, 0x7D, 0x1D, 0xF5,
+      // vpabsd ymm7, ymm10
+      0xC4, 0xC2, 0x7D, 0x1E, 0xFA,
+
+      // SSE4_AVX_INSTRUCTION
+      // vpmuldq ymm1, ymm5, ymm6
+      0xC4, 0xE2, 0x55, 0x28, 0xCE,
+      // vpcmpeqq ymm0, ymm2, ymm3
+      0xC4, 0xE2, 0x6D, 0x29, 0xC3,
+      // vpackusdw ymm4, ymm2, ymm0
+      0xC4, 0xE2, 0x6D, 0x2B, 0xE0,
+      // vpminud ymm8, ymm9, YMMWORD PTR [rbx+rcx*4+0x2710]
+      0xC4, 0x62, 0x35, 0x3B, 0x84, 0x8B, 0x10, 0x27, 0x0, 0x0,
+      // vpmaxsb ymm3, ymm4, ymm7
+      0xC4, 0xE2, 0x5D, 0x3C, 0xDF,
+      // vpmulld ymm6, ymm5, ymm3
+      0xC4, 0xE2, 0x55, 0x40, 0xF3,
+
+      // SSE4_2_AVX_INSTRUCTION
+      // vpcmpgtq ymm3, ymm2, ymm0
+      0xC4, 0xE2, 0x6D, 0x37, 0xD8,
+
+      // vpermq ymm8, YMMWORD PTR [rbx+rcx*4+0x2710], 0x1e
+      0xC4, 0x63, 0xFD, 0x00, 0x84, 0x8B, 0x10, 0x27, 0x00, 0x00, 0x1E,
+      // vpermq ymm5, ymm3, 0xD8
+      0xC4, 0xE3, 0xFD, 0x00, 0xEB, 0xD8};
   CHECK_EQ(0, memcmp(expected, desc.buffer, sizeof(expected)));
 }
 
@@ -2832,7 +2834,7 @@ TEST_F(AssemblerX64Test, AssemblerX64CmpOperations256bit) {
   code->Print(os);
 #endif
 
-  byte expected[] = {
+  uint8_t expected[] = {
       // vcmpeqps ymm1, ymm2, ymm4
       0xC5, 0xEC, 0xC2, 0xCC, 0x00,
       // vcmpltpd ymm4, ymm7, YMMWORD PTR [rcx+rdx*4+0x2710]
@@ -2878,22 +2880,22 @@ TEST_F(AssemblerX64Test, AssemblerX64ShiftImm128bit) {
   code->Print(os);
 #endif
 
-  byte expected[] = {// vpsrlw xmm8,xmm2,0x4
-                     0XC5, 0xB9, 0x71, 0xD2, 0x04,
-                     // vpsrld xmm11,xmm2,0x4
-                     0xC5, 0xA1, 0x72, 0xD2, 0x04,
-                     // vpsrlq xmm1,xmm2,0x4
-                     0xC5, 0xF1, 0x73, 0xD2, 0x04,
-                     // vpsraw xmm10,xmm8,0x4
-                     0xC4, 0xC1, 0x29, 0x71, 0xE0, 0x04,
-                     // vpsrad xmm6,xmm7,0x4
-                     0xC5, 0xC9, 0x72, 0xE7, 0x04,
-                     // vpsllw xmm1,xmm4,0x4
-                     0xC5, 0xF1, 0x71, 0xF4, 0x04,
-                     // vpslld xmm3,xmm2,0x4
-                     0xC5, 0xE1, 0x72, 0xF2, 0x04,
-                     // vpsllq xmm6,xmm9,0x4
-                     0xC4, 0xC1, 0x49, 0x73, 0xF1, 0x04};
+  uint8_t expected[] = {// vpsrlw xmm8,xmm2,0x4
+                        0XC5, 0xB9, 0x71, 0xD2, 0x04,
+                        // vpsrld xmm11,xmm2,0x4
+                        0xC5, 0xA1, 0x72, 0xD2, 0x04,
+                        // vpsrlq xmm1,xmm2,0x4
+                        0xC5, 0xF1, 0x73, 0xD2, 0x04,
+                        // vpsraw xmm10,xmm8,0x4
+                        0xC4, 0xC1, 0x29, 0x71, 0xE0, 0x04,
+                        // vpsrad xmm6,xmm7,0x4
+                        0xC5, 0xC9, 0x72, 0xE7, 0x04,
+                        // vpsllw xmm1,xmm4,0x4
+                        0xC5, 0xF1, 0x71, 0xF4, 0x04,
+                        // vpslld xmm3,xmm2,0x4
+                        0xC5, 0xE1, 0x72, 0xF2, 0x04,
+                        // vpsllq xmm6,xmm9,0x4
+                        0xC4, 0xC1, 0x49, 0x73, 0xF1, 0x04};
   CHECK_EQ(0, memcmp(expected, desc.buffer, sizeof(expected)));
 }
 
@@ -2923,22 +2925,22 @@ TEST_F(AssemblerX64Test, AssemblerX64ShiftImm256bit) {
   code->Print(os);
 #endif
 
-  byte expected[] = {// vpsrlw ymm0,ymm2,0x4
-                     0XC5, 0xFD, 0x71, 0xD2, 0x04,
-                     // vpsrld ymm11,ymm2,0x4
-                     0xC5, 0xA5, 0x72, 0xD2, 0x04,
-                     // vpsrlq ymm1,ymm2,0x4
-                     0xC5, 0xF5, 0x73, 0xD2, 0x04,
-                     // vpsraw ymm10,ymm8,0x4
-                     0xC4, 0xC1, 0x2D, 0x71, 0xE0, 0x04,
-                     // vpsrad ymm6,ymm7,0x4
-                     0xC5, 0xCD, 0x72, 0xE7, 0x04,
-                     // vpsllw ymm1,ymm4,0x4
-                     0xC5, 0xF5, 0x71, 0xF4, 0x04,
-                     // vpslld ymm3,ymm2,0x4
-                     0xC5, 0xE5, 0x72, 0xF2, 0x04,
-                     // vpsllq ymm6,ymm9,0x4
-                     0xC4, 0xC1, 0x4D, 0x73, 0xF1, 0x04};
+  uint8_t expected[] = {// vpsrlw ymm0,ymm2,0x4
+                        0XC5, 0xFD, 0x71, 0xD2, 0x04,
+                        // vpsrld ymm11,ymm2,0x4
+                        0xC5, 0xA5, 0x72, 0xD2, 0x04,
+                        // vpsrlq ymm1,ymm2,0x4
+                        0xC5, 0xF5, 0x73, 0xD2, 0x04,
+                        // vpsraw ymm10,ymm8,0x4
+                        0xC4, 0xC1, 0x2D, 0x71, 0xE0, 0x04,
+                        // vpsrad ymm6,ymm7,0x4
+                        0xC5, 0xCD, 0x72, 0xE7, 0x04,
+                        // vpsllw ymm1,ymm4,0x4
+                        0xC5, 0xF5, 0x71, 0xF4, 0x04,
+                        // vpslld ymm3,ymm2,0x4
+                        0xC5, 0xE5, 0x72, 0xF2, 0x04,
+                        // vpsllq ymm6,ymm9,0x4
+                        0xC4, 0xC1, 0x4D, 0x73, 0xF1, 0x04};
   CHECK_EQ(0, memcmp(expected, desc.buffer, sizeof(expected)));
 }
 
@@ -2975,24 +2977,22 @@ TEST_F(AssemblerX64Test, AssemblerX64BinOp256bit) {
     code->Print(os);
 #endif
 
-    byte expected[] = {// vaddps ymm0,ymm1,ymm2
-                       0xc5, 0xf4, 0x58, 0xc2,
-                       // vaddpd ymm3,ymm4,ymm5
-                       0xc5, 0xdd, 0x58, 0xdd,
-                       // vsubps ymm0,ymm1,ymm2
-                       0xc5, 0xf4, 0x5c, 0xc2,
-                       // vsubpd ymm3,ymm4,ymm5
-                       0xc5, 0xdd, 0x5c, 0xdd,
-                       // vmulps ymm0,ymm1,ymm2
-                       0xc5, 0xf4, 0x59, 0xc2,
-                       // vmulpd ymm3,ymm4,ymm5
-                       0xc5, 0xdd, 0x59, 0xdd,
-                       // vdivps ymm0,ymm1,ymm2
-                       0xc5, 0xf4, 0x5e, 0xc2,
-                       // vdivpd ymm3,ymm4,ymm5
-                       0xc5, 0xdd, 0x5e, 0xdd
-
-    };
+    uint8_t expected[] = {// vaddps ymm0,ymm1,ymm2
+                          0xc5, 0xf4, 0x58, 0xc2,
+                          // vaddpd ymm3,ymm4,ymm5
+                          0xc5, 0xdd, 0x58, 0xdd,
+                          // vsubps ymm0,ymm1,ymm2
+                          0xc5, 0xf4, 0x5c, 0xc2,
+                          // vsubpd ymm3,ymm4,ymm5
+                          0xc5, 0xdd, 0x5c, 0xdd,
+                          // vmulps ymm0,ymm1,ymm2
+                          0xc5, 0xf4, 0x59, 0xc2,
+                          // vmulpd ymm3,ymm4,ymm5
+                          0xc5, 0xdd, 0x59, 0xdd,
+                          // vdivps ymm0,ymm1,ymm2
+                          0xc5, 0xf4, 0x5e, 0xc2,
+                          // vdivpd ymm3,ymm4,ymm5
+                          0xc5, 0xdd, 0x5e, 0xdd};
     CHECK_EQ(0, memcmp(expected, desc.buffer, sizeof(expected)));
   }
 
@@ -3031,26 +3031,26 @@ TEST_F(AssemblerX64Test, AssemblerX64BinOp256bit) {
     code->Print(os);
 #endif
 
-    byte expected[] = {// vpaddb ymm6,ymm7,ymm8
-                       0xc4, 0xc1, 0x45, 0xfc, 0xf0,
-                       // vpaddw ymm9,ymm10,ymm11
-                       0xc4, 0x41, 0x2d, 0xfd, 0xcb,
-                       // vpaddd ymm12,ymm13,ymm14
-                       0xc4, 0x41, 0x15, 0xfe, 0xe6,
-                       // vpaddq ymm15,ymm1,ymm2
-                       0xc5, 0x75, 0xd4, 0xfa,
-                       // vpsubb ymm6,ymm7,ymm8
-                       0xc4, 0xc1, 0x45, 0xf8, 0xf0,
-                       // vpsubw ymm9,ymm10,ymm11
-                       0xc4, 0x41, 0x2d, 0xf9, 0xcb,
-                       // vpsubd ymm12,ymm13,ymm14
-                       0xc4, 0x41, 0x15, 0xfa, 0xe6,
-                       // vpsubq ymm15,ymm1,ymm2
-                       0xc5, 0x75, 0xfb, 0xfa,
-                       // vpmullw ymm6,ymm7,ymm8
-                       0xc4, 0xc1, 0x45, 0xd5, 0xf0,
-                       // vpmulld ymm15,ymm1,ymm2
-                       0xc4, 0x62, 0x75, 0x40, 0xfa};
+    uint8_t expected[] = {// vpaddb ymm6,ymm7,ymm8
+                          0xc4, 0xc1, 0x45, 0xfc, 0xf0,
+                          // vpaddw ymm9,ymm10,ymm11
+                          0xc4, 0x41, 0x2d, 0xfd, 0xcb,
+                          // vpaddd ymm12,ymm13,ymm14
+                          0xc4, 0x41, 0x15, 0xfe, 0xe6,
+                          // vpaddq ymm15,ymm1,ymm2
+                          0xc5, 0x75, 0xd4, 0xfa,
+                          // vpsubb ymm6,ymm7,ymm8
+                          0xc4, 0xc1, 0x45, 0xf8, 0xf0,
+                          // vpsubw ymm9,ymm10,ymm11
+                          0xc4, 0x41, 0x2d, 0xf9, 0xcb,
+                          // vpsubd ymm12,ymm13,ymm14
+                          0xc4, 0x41, 0x15, 0xfa, 0xe6,
+                          // vpsubq ymm15,ymm1,ymm2
+                          0xc5, 0x75, 0xfb, 0xfa,
+                          // vpmullw ymm6,ymm7,ymm8
+                          0xc4, 0xc1, 0x45, 0xd5, 0xf0,
+                          // vpmulld ymm15,ymm1,ymm2
+                          0xc4, 0x62, 0x75, 0x40, 0xfa};
     CHECK_EQ(0, memcmp(expected, desc.buffer, sizeof(expected)));
   }
 }
diff --git a/test/unittests/assembler/disasm-arm-unittest.cc b/test/unittests/assembler/disasm-arm-unittest.cc
index e0f9c5f90b9..0f36bdd130a 100644
--- a/test/unittests/assembler/disasm-arm-unittest.cc
+++ b/test/unittests/assembler/disasm-arm-unittest.cc
@@ -54,7 +54,7 @@ using DisasmArmTest = TestWithIsolate;
 enum UseRegex { kRawString, kRegexString };
 
 template <typename... S>
-bool DisassembleAndCompare(byte* begin, UseRegex use_regex,
+bool DisassembleAndCompare(uint8_t* begin, UseRegex use_regex,
                            S... expected_strings) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
@@ -62,10 +62,10 @@ bool DisassembleAndCompare(byte* begin, UseRegex use_regex,
 
   std::vector<std::string> expected_disassembly = {expected_strings...};
   size_t n_expected = expected_disassembly.size();
-  byte* end = begin + (n_expected * kInstrSize);
+  uint8_t* end = begin + (n_expected * kInstrSize);
 
   std::vector<std::string> disassembly;
-  for (byte* pc = begin; pc < end;) {
+  for (uint8_t* pc = begin; pc < end;) {
     pc += disasm.InstructionDecode(buffer, pc);
     disassembly.emplace_back(buffer.begin());
   }
@@ -110,11 +110,11 @@ bool DisassembleAndCompare(byte* begin, UseRegex use_regex,
 // Set up V8 to a state where we can at least run the assembler and
 // disassembler. Declare the variables and allocate the data structures used
 // in the rest of the macros.
-#define SET_UP()                                             \
-  HandleScope scope(isolate());                              \
-  byte* buffer = reinterpret_cast<byte*>(malloc(4 * 1024));  \
-  Assembler assm(AssemblerOptions{},                         \
-                 ExternalAssemblerBuffer(buffer, 4 * 1024)); \
+#define SET_UP()                                                  \
+  HandleScope scope(isolate());                                   \
+  uint8_t* buffer = reinterpret_cast<uint8_t*>(malloc(4 * 1024)); \
+  Assembler assm(AssemblerOptions{},                              \
+                 ExternalAssemblerBuffer(buffer, 4 * 1024));      \
   bool failure = false;
 
 // This macro assembles one instruction using the preallocated assembler and
@@ -124,7 +124,7 @@ bool DisassembleAndCompare(byte* begin, UseRegex use_regex,
 #define BASE_COMPARE(asm_, use_regex, ...)                             \
   {                                                                    \
     int pc_offset = assm.pc_offset();                                  \
-    byte* progcounter = &buffer[pc_offset];                            \
+    uint8_t* progcounter = &buffer[pc_offset];                         \
     assm.asm_;                                                         \
     if (!DisassembleAndCompare(progcounter, use_regex, __VA_ARGS__)) { \
       failure = true;                                                  \
@@ -1620,10 +1620,10 @@ TEST_F(DisasmArmTest, LoadStore) {
 }
 
 
-static void TestLoadLiteral(byte* buffer, Assembler* assm, bool* failure,
+static void TestLoadLiteral(uint8_t* buffer, Assembler* assm, bool* failure,
                             int offset) {
   int pc_offset = assm->pc_offset();
-  byte *progcounter = &buffer[pc_offset];
+  uint8_t *progcounter = &buffer[pc_offset];
   assm->ldr_pcrel(r0, offset);
 
   const char *expected_string_template =
diff --git a/test/unittests/assembler/disasm-arm64-unittest.cc b/test/unittests/assembler/disasm-arm64-unittest.cc
index d845144e146..eb33d4b9f33 100644
--- a/test/unittests/assembler/disasm-arm64-unittest.cc
+++ b/test/unittests/assembler/disasm-arm64-unittest.cc
@@ -49,7 +49,7 @@ using DisasmArm64Test = TestWithIsolate;
 #define INSTR_SIZE (1024)
 #define SET_UP_MASM()                                                         \
   HandleScope scope(isolate());                                               \
-  byte* buf = static_cast<byte*>(malloc(INSTR_SIZE));                         \
+  uint8_t* buf = static_cast<uint8_t*>(malloc(INSTR_SIZE));                   \
   uint32_t encoding = 0;                                                      \
   MacroAssembler* assm =                                                      \
       new MacroAssembler((isolate()), v8::internal::CodeObjectRequired::kYes, \
@@ -61,7 +61,7 @@ using DisasmArm64Test = TestWithIsolate;
 
 #define SET_UP_ASM()                                                         \
   HandleScope scope(isolate());                                              \
-  byte* buf = static_cast<byte*>(malloc(INSTR_SIZE));                        \
+  uint8_t* buf = static_cast<uint8_t*>(malloc(INSTR_SIZE));                  \
   uint32_t encoding = 0;                                                     \
   Assembler* assm = new Assembler(AssemblerOptions{},                        \
                                   ExternalAssemblerBuffer(buf, INSTR_SIZE)); \
@@ -2012,7 +2012,7 @@ TEST_F(DisasmArm64Test, debug) {
   for (int i = 0; i < 2; i++) {
     // Loop runs with and without the simulator code enabled.
     HandleScope scope(isolate());
-    byte* buf = static_cast<byte*>(malloc(INSTR_SIZE));
+    uint8_t* buf = static_cast<uint8_t*>(malloc(INSTR_SIZE));
     uint32_t encoding = 0;
     AssemblerOptions options;
 #ifdef USE_SIMULATOR
diff --git a/test/unittests/assembler/disasm-ia32-unittest.cc b/test/unittests/assembler/disasm-ia32-unittest.cc
index 17d89b1e0fa..147d6c3e48e 100644
--- a/test/unittests/assembler/disasm-ia32-unittest.cc
+++ b/test/unittests/assembler/disasm-ia32-unittest.cc
@@ -47,7 +47,7 @@ using DisasmIa320Test = TestWithIsolate;
 
 TEST_F(DisasmIa320Test, DisasmIa320) {
   HandleScope scope(isolate());
-  v8::internal::byte buffer[8192];
+  uint8_t buffer[8192];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
   // Short immediate instructions
@@ -986,8 +986,8 @@ TEST_F(DisasmIa320Test, DisasmIa320) {
   code->Print(os);
   Address begin = code->instruction_start();
   Address end = code->instruction_end();
-  disasm::Disassembler::Disassemble(stdout, reinterpret_cast<byte*>(begin),
-                                    reinterpret_cast<byte*>(end));
+  disasm::Disassembler::Disassemble(stdout, reinterpret_cast<uint8_t*>(begin),
+                                    reinterpret_cast<uint8_t*>(end));
 #endif
 }
 
diff --git a/test/unittests/assembler/disasm-loong64-unittest.cc b/test/unittests/assembler/disasm-loong64-unittest.cc
index 893f82b5683..b2f30c5743f 100644
--- a/test/unittests/assembler/disasm-loong64-unittest.cc
+++ b/test/unittests/assembler/disasm-loong64-unittest.cc
@@ -43,7 +43,7 @@ namespace internal {
 
 using DisasmLoong64Test = TestWithIsolate;
 
-bool DisassembleAndCompare(byte* pc, const char* compare_string) {
+bool DisassembleAndCompare(uint8_t* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
   base::EmbeddedVector<char, 128> disasm_buffer;
@@ -70,11 +70,11 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 // Set up V8 to a state where we can at least run the assembler and
 // disassembler. Declare the variables and allocate the data structures used
 // in the rest of the macros.
-#define SET_UP()                                             \
-  HandleScope scope(isolate());                              \
-  byte* buffer = reinterpret_cast<byte*>(malloc(4 * 1024));  \
-  Assembler assm(AssemblerOptions{},                         \
-                 ExternalAssemblerBuffer(buffer, 4 * 1024)); \
+#define SET_UP()                                                  \
+  HandleScope scope(isolate());                                   \
+  uint8_t* buffer = reinterpret_cast<uint8_t*>(malloc(4 * 1024)); \
+  Assembler assm(AssemblerOptions{},                              \
+                 ExternalAssemblerBuffer(buffer, 4 * 1024));      \
   bool failure = false;
 
 // This macro assembles one instruction using the preallocated assembler and
@@ -84,7 +84,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE(asm_, compare_string)                                        \
   {                                                                          \
     int pc_offset = assm.pc_offset();                                        \
-    byte* progcounter = &buffer[pc_offset];                                  \
+    uint8_t* progcounter = &buffer[pc_offset];                               \
     assm.asm_;                                                               \
     if (!DisassembleAndCompare(progcounter, compare_string)) failure = true; \
   }
@@ -99,7 +99,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE_PC_REL(asm_, compare_string, offset)                           \
   {                                                                            \
     int pc_offset = assm.pc_offset();                                          \
-    byte* progcounter = &buffer[pc_offset];                                    \
+    uint8_t* progcounter = &buffer[pc_offset];                                 \
     char str_with_address[100];                                                \
     printf("%p\n", static_cast<void*>(progcounter));                           \
     snprintf(str_with_address, sizeof(str_with_address), "%s -> %p",           \
diff --git a/test/unittests/assembler/disasm-mips64-unittest.cc b/test/unittests/assembler/disasm-mips64-unittest.cc
index ed6c0ef0462..02def4b133b 100644
--- a/test/unittests/assembler/disasm-mips64-unittest.cc
+++ b/test/unittests/assembler/disasm-mips64-unittest.cc
@@ -44,7 +44,7 @@ using DisasmMips64Test = TestWithIsolate;
 
 bool prev_instr_compact_branch = false;
 
-bool DisassembleAndCompare(byte* pc, const char* compare_string) {
+bool DisassembleAndCompare(uint8_t* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
   base::EmbeddedVector<char, 128> disasm_buffer;
@@ -71,11 +71,11 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 // Set up V8 to a state where we can at least run the assembler and
 // disassembler. Declare the variables and allocate the data structures used
 // in the rest of the macros.
-#define SET_UP()                                             \
-  HandleScope scope(isolate());                              \
-  byte* buffer = reinterpret_cast<byte*>(malloc(4 * 1024));  \
-  Assembler assm(AssemblerOptions{},                         \
-                 ExternalAssemblerBuffer(buffer, 4 * 1024)); \
+#define SET_UP()                                                  \
+  HandleScope scope(isolate());                                   \
+  uint8_t* buffer = reinterpret_cast<uint8_t*>(malloc(4 * 1024)); \
+  Assembler assm(AssemblerOptions{},                              \
+                 ExternalAssemblerBuffer(buffer, 4 * 1024));      \
   bool failure = false;
 
 // This macro assembles one instruction using the preallocated assembler and
@@ -85,7 +85,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE(asm_, compare_string)                                        \
   {                                                                          \
     int pc_offset = assm.pc_offset();                                        \
-    byte* progcounter = &buffer[pc_offset];                                  \
+    uint8_t* progcounter = &buffer[pc_offset];                               \
     assm.asm_;                                                               \
     if (!DisassembleAndCompare(progcounter, compare_string)) failure = true; \
   }
@@ -100,7 +100,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE_PC_REL_COMPACT(asm_, compare_string, offset)                   \
   {                                                                            \
     int pc_offset = assm.pc_offset();                                          \
-    byte* progcounter = &buffer[pc_offset];                                    \
+    uint8_t* progcounter = &buffer[pc_offset];                                 \
     char str_with_address[100];                                                \
     prev_instr_compact_branch = assm.IsPrevInstrCompactBranch();               \
     if (prev_instr_compact_branch) {                                           \
@@ -119,7 +119,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE_PC_REL(asm_, compare_string, offset)                           \
   {                                                                            \
     int pc_offset = assm.pc_offset();                                          \
-    byte* progcounter = &buffer[pc_offset];                                    \
+    uint8_t* progcounter = &buffer[pc_offset];                                 \
     char str_with_address[100];                                                \
     snprintf(str_with_address, sizeof(str_with_address), "%s -> %p",           \
              compare_string, static_cast<void*>(progcounter + (offset * 4)));  \
@@ -130,7 +130,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE_MSA_BRANCH(asm_, compare_string, offset)                       \
   {                                                                            \
     int pc_offset = assm.pc_offset();                                          \
-    byte* progcounter = &buffer[pc_offset];                                    \
+    uint8_t* progcounter = &buffer[pc_offset];                                 \
     char str_with_address[100];                                                \
     snprintf(str_with_address, sizeof(str_with_address), "%s -> %p",           \
              compare_string,                                                   \
@@ -142,7 +142,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE_PC_JUMP(asm_, compare_string, target)                          \
   {                                                                            \
     int pc_offset = assm.pc_offset();                                          \
-    byte* progcounter = &buffer[pc_offset];                                    \
+    uint8_t* progcounter = &buffer[pc_offset];                                 \
     char str_with_address[100];                                                \
     int instr_index = (target >> 2) & kImm26Mask;                              \
     snprintf(                                                                  \
@@ -157,7 +157,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define GET_PC_REGION(pc_region)                                         \
   {                                                                      \
     int pc_offset = assm.pc_offset();                                    \
-    byte* progcounter = &buffer[pc_offset];                              \
+    uint8_t* progcounter = &buffer[pc_offset];                           \
     pc_region = reinterpret_cast<int64_t>(progcounter + 4) & ~0xFFFFFFF; \
   }
 
diff --git a/test/unittests/assembler/disasm-ppc-unittest.cc b/test/unittests/assembler/disasm-ppc-unittest.cc
index 13581673ab8..9ebe3996657 100644
--- a/test/unittests/assembler/disasm-ppc-unittest.cc
+++ b/test/unittests/assembler/disasm-ppc-unittest.cc
@@ -42,7 +42,7 @@ namespace internal {
 
 using DisasmPpcTest = TestWithIsolate;
 
-bool DisassembleAndCompare(byte* pc, const char* compare_string) {
+bool DisassembleAndCompare(uint8_t* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
   base::EmbeddedVector<char, 128> disasm_buffer;
@@ -64,11 +64,11 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 // Set up V8 to a state where we can at least run the assembler and
 // disassembler. Declare the variables and allocate the data structures used
 // in the rest of the macros.
-#define SET_UP()                                             \
-  HandleScope scope(isolate());                              \
-  byte* buffer = reinterpret_cast<byte*>(malloc(4 * 1024));  \
-  Assembler assm(AssemblerOptions{},                         \
-                 ExternalAssemblerBuffer(buffer, 4 * 1024)); \
+#define SET_UP()                                                  \
+  HandleScope scope(isolate());                                   \
+  uint8_t* buffer = reinterpret_cast<uint8_t*>(malloc(4 * 1024)); \
+  Assembler assm(AssemblerOptions{},                              \
+                 ExternalAssemblerBuffer(buffer, 4 * 1024));      \
   bool failure = false;
 
 // This macro assembles one instruction using the preallocated assembler and
@@ -78,7 +78,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE(asm_, compare_string)                                        \
   {                                                                          \
     int pc_offset = assm.pc_offset();                                        \
-    byte* progcounter = &buffer[pc_offset];                                  \
+    uint8_t* progcounter = &buffer[pc_offset];                               \
     assm.asm_;                                                               \
     if (!DisassembleAndCompare(progcounter, compare_string)) failure = true; \
   }
diff --git a/test/unittests/assembler/disasm-riscv-unittest.cc b/test/unittests/assembler/disasm-riscv-unittest.cc
index 7bff5b99252..b94a7c7a559 100644
--- a/test/unittests/assembler/disasm-riscv-unittest.cc
+++ b/test/unittests/assembler/disasm-riscv-unittest.cc
@@ -44,7 +44,7 @@ using DisasmRiscv64Test = TestWithIsolate;
 
 bool prev_instr_compact_branch = false;
 
-bool DisassembleAndCompare(byte* pc, const char* compare_string) {
+bool DisassembleAndCompare(uint8_t* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
   base::EmbeddedVector<char, 128> disasm_buffer;
@@ -71,11 +71,11 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 // Set up V8 to a state where we can at least run the assembler and
 // disassembler. Declare the variables and allocate the data structures used
 // in the rest of the macros.
-#define SET_UP()                                             \
-  HandleScope scope(isolate());                              \
-  byte* buffer = reinterpret_cast<byte*>(malloc(4 * 1024));  \
-  Assembler assm(AssemblerOptions{},                         \
-                 ExternalAssemblerBuffer(buffer, 4 * 1024)); \
+#define SET_UP()                                                  \
+  HandleScope scope(isolate());                                   \
+  uint8_t* buffer = reinterpret_cast<uint8_t*>(malloc(4 * 1024)); \
+  Assembler assm(AssemblerOptions{},                              \
+                 ExternalAssemblerBuffer(buffer, 4 * 1024));      \
   bool failure = false;
 
 // This macro assembles one instruction using the preallocated assembler and
@@ -85,7 +85,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE(asm_, compare_string)                                        \
   {                                                                          \
     int pc_offset = assm.pc_offset();                                        \
-    byte* progcounter = &buffer[pc_offset];                                  \
+    uint8_t* progcounter = &buffer[pc_offset];                               \
     assm.asm_;                                                               \
     if (!DisassembleAndCompare(progcounter, compare_string)) failure = true; \
   }
@@ -93,7 +93,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE_PC_REL(asm_, compare_string, offset)                           \
   {                                                                            \
     int pc_offset = assm.pc_offset();                                          \
-    byte* progcounter = &buffer[pc_offset];                                    \
+    uint8_t* progcounter = &buffer[pc_offset];                                 \
     char str_with_address[100];                                                \
     snprintf(str_with_address, sizeof(str_with_address), "%s -> %p",           \
              compare_string, static_cast<void*>(progcounter + (offset)));      \
diff --git a/test/unittests/assembler/disasm-s390-unittest.cc b/test/unittests/assembler/disasm-s390-unittest.cc
index c484d033846..c2ac69d4d2d 100644
--- a/test/unittests/assembler/disasm-s390-unittest.cc
+++ b/test/unittests/assembler/disasm-s390-unittest.cc
@@ -42,7 +42,7 @@ namespace internal {
 
 using DisasmS390Test = TestWithIsolate;
 
-bool DisassembleAndCompare(byte* pc, const char* compare_string) {
+bool DisassembleAndCompare(uint8_t* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
   base::EmbeddedVector<char, 128> disasm_buffer;
@@ -64,11 +64,11 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 // Set up V8 to a state where we can at least run the assembler and
 // disassembler. Declare the variables and allocate the data structures used
 // in the rest of the macros.
-#define SET_UP()                                             \
-  HandleScope scope(isolate());                              \
-  byte* buffer = reinterpret_cast<byte*>(malloc(4 * 1024));  \
-  Assembler assm(AssemblerOptions{},                         \
-                 ExternalAssemblerBuffer(buffer, 4 * 1024)); \
+#define SET_UP()                                                  \
+  HandleScope scope(isolate());                                   \
+  uint8_t* buffer = reinterpret_cast<uint8_t*>(malloc(4 * 1024)); \
+  Assembler assm(AssemblerOptions{},                              \
+                 ExternalAssemblerBuffer(buffer, 4 * 1024));      \
   bool failure = false;
 
 // This macro assembles one instruction using the preallocated assembler and
@@ -78,7 +78,7 @@ bool DisassembleAndCompare(byte* pc, const char* compare_string) {
 #define COMPARE(asm_, compare_string)                                        \
   {                                                                          \
     int pc_offset = assm.pc_offset();                                        \
-    byte* progcounter = &buffer[pc_offset];                                  \
+    uint8_t* progcounter = &buffer[pc_offset];                               \
     assm.asm_;                                                               \
     if (!DisassembleAndCompare(progcounter, compare_string)) failure = true; \
   }
diff --git a/test/unittests/assembler/disasm-x64-unittest.cc b/test/unittests/assembler/disasm-x64-unittest.cc
index 742d355ab48..d01df3903c1 100644
--- a/test/unittests/assembler/disasm-x64-unittest.cc
+++ b/test/unittests/assembler/disasm-x64-unittest.cc
@@ -50,7 +50,7 @@ using DisasmX64Test = TestWithIsolate;
 namespace {
 
 Handle<Code> CreateDummyCode(Isolate* isolate) {
-  i::byte buffer[128];
+  uint8_t buffer[128];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof(buffer)));
   __ nop();
@@ -66,7 +66,7 @@ Handle<Code> CreateDummyCode(Isolate* isolate) {
 
 TEST_F(DisasmX64Test, DisasmX64) {
   HandleScope handle_scope(isolate());
-  v8::internal::byte buffer[8192];
+  uint8_t buffer[8192];
   Assembler assm(AssemblerOptions{},
                  ExternalAssemblerBuffer(buffer, sizeof buffer));
   // Some instructions are tested in DisasmX64CheckOutput.
@@ -307,8 +307,8 @@ TEST_F(DisasmX64Test, DisasmX64) {
   code->Print(os);
   Address begin = code->instruction_start();
   Address end = code->instruction_start();
-  disasm::Disassembler::Disassemble(stdout, reinterpret_cast<byte*>(begin),
-                                    reinterpret_cast<byte*>(end));
+  disasm::Disassembler::Disassemble(stdout, reinterpret_cast<uint8_t*>(begin),
+                                    reinterpret_cast<uint8_t*>(end));
 #endif
 }
 
@@ -331,7 +331,7 @@ struct DisassemblerTester {
 
   Assembler* assm() { return &assm_; }
 
-  v8::internal::byte buffer_[kAssemblerBufferSize];
+  uint8_t buffer_[kAssemblerBufferSize];
   Assembler assm_;
   disasm::NameConverter converter_;
   disasm::Disassembler disasm;
diff --git a/test/unittests/assembler/macro-assembler-arm-unittest.cc b/test/unittests/assembler/macro-assembler-arm-unittest.cc
index f7ec44e77fd..875d7ba4cba 100644
--- a/test/unittests/assembler/macro-assembler-arm-unittest.cc
+++ b/test/unittests/assembler/macro-assembler-arm-unittest.cc
@@ -162,11 +162,11 @@ TEST_P(MacroAssemblerTestMoveObjectAndSlot, MoveObjectAndSlot) {
 
     buffer->MakeExecutable();
     // We need an isolate here to execute in the simulator.
-    auto f = GeneratedCode<void, byte**, byte*>::FromBuffer(isolate(),
-                                                            buffer->start());
+    auto f = GeneratedCode<void, uint8_t**, uint8_t*>::FromBuffer(
+        isolate(), buffer->start());
 
-    byte* object = new byte[offset];
-    byte* result[] = {nullptr, nullptr};
+    uint8_t* object = new uint8_t[offset];
+    uint8_t* result[] = {nullptr, nullptr};
 
     f.Call(result, object);
 
diff --git a/test/unittests/assembler/macro-assembler-arm64-unittest.cc b/test/unittests/assembler/macro-assembler-arm64-unittest.cc
index 3bbbc490961..c93a06acfe6 100644
--- a/test/unittests/assembler/macro-assembler-arm64-unittest.cc
+++ b/test/unittests/assembler/macro-assembler-arm64-unittest.cc
@@ -226,11 +226,11 @@ TEST_P(MacroAssemblerTestMoveObjectAndSlot, MoveObjectAndSlot) {
     }
 
     // We need an isolate here to execute in the simulator.
-    auto f = GeneratedCode<void, byte**, byte*>::FromBuffer(isolate(),
-                                                            buffer->start());
+    auto f = GeneratedCode<void, uint8_t**, uint8_t*>::FromBuffer(
+        isolate(), buffer->start());
 
-    byte* object = new byte[offset];
-    byte* result[] = {nullptr, nullptr};
+    uint8_t* object = new uint8_t[offset];
+    uint8_t* result[] = {nullptr, nullptr};
 
     f.Call(result, object);
 
diff --git a/test/unittests/base/vlq-unittest.cc b/test/unittests/base/vlq-unittest.cc
index 647873410a4..c4e37de24b6 100644
--- a/test/unittests/base/vlq-unittest.cc
+++ b/test/unittests/base/vlq-unittest.cc
@@ -28,9 +28,9 @@ int ExpectedBytesUsed(int64_t value, bool is_signed) {
 }
 
 void TestVLQUnsignedEquals(uint32_t value) {
-  std::vector<byte> buffer;
+  std::vector<uint8_t> buffer;
   VLQEncodeUnsigned(&buffer, value);
-  byte* data_start = buffer.data();
+  uint8_t* data_start = buffer.data();
   int index = 0;
   int expected_bytes_used = ExpectedBytesUsed(value, false);
   EXPECT_EQ(buffer.size(), static_cast<size_t>(expected_bytes_used));
@@ -39,9 +39,9 @@ void TestVLQUnsignedEquals(uint32_t value) {
 }
 
 void TestVLQEquals(int32_t value) {
-  std::vector<byte> buffer;
+  std::vector<uint8_t> buffer;
   VLQEncode(&buffer, value);
-  byte* data_start = buffer.data();
+  uint8_t* data_start = buffer.data();
   int index = 0;
   int expected_bytes_used = ExpectedBytesUsed(value, true);
   EXPECT_EQ(buffer.size(), static_cast<size_t>(expected_bytes_used));
diff --git a/test/unittests/codegen/code-layout-unittest.cc b/test/unittests/codegen/code-layout-unittest.cc
index d59b0cb6999..7a4b6e3f4e3 100644
--- a/test/unittests/codegen/code-layout-unittest.cc
+++ b/test/unittests/codegen/code-layout-unittest.cc
@@ -18,10 +18,10 @@ TEST_F(CodeLayoutTest, CodeLayoutWithoutUnwindingInfo) {
   HandleScope handle_scope(i_isolate());
 
   // "Hello, World!" in ASCII, padded to kCodeAlignment.
-  byte buffer_array[16] = {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x57,
-                           0x6F, 0x72, 0x6C, 0x64, 0x21, 0xcc, 0xcc, 0xcc};
+  uint8_t buffer_array[16] = {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x57,
+                              0x6F, 0x72, 0x6C, 0x64, 0x21, 0xcc, 0xcc, 0xcc};
 
-  byte* buffer = &buffer_array[0];
+  uint8_t* buffer = &buffer_array[0];
   int buffer_size = sizeof(buffer_array);
 
   CodeDesc code_desc;
@@ -59,16 +59,16 @@ TEST_F(CodeLayoutTest, CodeLayoutWithUnwindingInfo) {
   HandleScope handle_scope(i_isolate());
 
   // "Hello, World!" in ASCII, padded to kCodeAlignment.
-  byte buffer_array[16] = {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x57,
-                           0x6F, 0x72, 0x6C, 0x64, 0x21, 0xcc, 0xcc, 0xcc};
+  uint8_t buffer_array[16] = {0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x2C, 0x20, 0x57,
+                              0x6F, 0x72, 0x6C, 0x64, 0x21, 0xcc, 0xcc, 0xcc};
 
   // "JavaScript" in ASCII.
-  byte unwinding_info_array[10] = {0x4A, 0x61, 0x76, 0x61, 0x53,
-                                   0x63, 0x72, 0x69, 0x70, 0x74};
+  uint8_t unwinding_info_array[10] = {0x4A, 0x61, 0x76, 0x61, 0x53,
+                                      0x63, 0x72, 0x69, 0x70, 0x74};
 
-  byte* buffer = &buffer_array[0];
+  uint8_t* buffer = &buffer_array[0];
   int buffer_size = sizeof(buffer_array);
-  byte* unwinding_info = &unwinding_info_array[0];
+  uint8_t* unwinding_info = &unwinding_info_array[0];
   int unwinding_info_size = sizeof(unwinding_info_array);
 
   CodeDesc code_desc;
diff --git a/test/unittests/codegen/code-pages-unittest.cc b/test/unittests/codegen/code-pages-unittest.cc
index 6c1c458bc39..d191172effd 100644
--- a/test/unittests/codegen/code-pages-unittest.cc
+++ b/test/unittests/codegen/code-pages-unittest.cc
@@ -76,11 +76,11 @@ bool PagesHasExactPage(std::vector<MemoryRange>* pages, Address search_page,
 
 bool PagesContainsRange(std::vector<MemoryRange>* pages, Address search_address,
                         size_t size) {
-  byte* addr = reinterpret_cast<byte*>(search_address);
+  uint8_t* addr = reinterpret_cast<uint8_t*>(search_address);
   auto it =
       std::find_if(pages->begin(), pages->end(), [=](const MemoryRange& r) {
-        const byte* page_start = reinterpret_cast<const byte*>(r.start);
-        const byte* page_end = page_start + r.length_in_bytes;
+        const uint8_t* page_start = reinterpret_cast<const uint8_t*>(r.start);
+        const uint8_t* page_end = page_start + r.length_in_bytes;
         return addr >= page_start && (addr + size) <= page_end;
       });
   return it != pages->end();
@@ -209,7 +209,7 @@ TEST_F(CodePagesTest, OptimizedCodeWithCodePages) {
 
       // Check that the generated code ended up in one of the code pages
       // returned by GetCodePages().
-      byte* foo_code_ptr = reinterpret_cast<byte*>(foo_code.address());
+      uint8_t* foo_code_ptr = reinterpret_cast<uint8_t*>(foo_code.address());
       std::vector<MemoryRange>* pages = i_isolate()->GetCodePages();
 
       // Wait until after we have created the first function to take the initial
@@ -224,8 +224,9 @@ TEST_F(CodePagesTest, OptimizedCodeWithCodePages) {
       // by GetCodePages().
       auto it = std::find_if(
           pages->begin(), pages->end(), [foo_code_ptr](const MemoryRange& r) {
-            const byte* page_start = reinterpret_cast<const byte*>(r.start);
-            const byte* page_end = page_start + r.length_in_bytes;
+            const uint8_t* page_start =
+                reinterpret_cast<const uint8_t*>(r.start);
+            const uint8_t* page_end = page_start + r.length_in_bytes;
             return foo_code_ptr >= page_start && foo_code_ptr < page_end;
           });
       EXPECT_NE(it, pages->end());
@@ -276,7 +277,7 @@ TEST_F(CodePagesTest, LargeCodeObject) {
   // Create a big function that ends up in CODE_LO_SPACE.
   const int instruction_size = Page::kPageSize + 1;
   EXPECT_GT(instruction_size, MemoryChunkLayout::MaxRegularCodeObjectSize());
-  std::unique_ptr<byte[]> instructions(new byte[instruction_size]);
+  std::unique_ptr<uint8_t[]> instructions(new uint8_t[instruction_size]);
 
   CodeDesc desc;
   desc.buffer = instructions.get();
@@ -395,7 +396,7 @@ TEST_F(CodePagesTest, LargeCodeObjectWithSignalHandler) {
   // Create a big function that ends up in CODE_LO_SPACE.
   const int instruction_size = Page::kPageSize + 1;
   EXPECT_GT(instruction_size, MemoryChunkLayout::MaxRegularCodeObjectSize());
-  std::unique_ptr<byte[]> instructions(new byte[instruction_size]);
+  std::unique_ptr<uint8_t[]> instructions(new uint8_t[instruction_size]);
 
   CodeDesc desc;
   desc.buffer = instructions.get();
@@ -475,7 +476,7 @@ TEST_F(CodePagesTest, Sorted) {
   // Create a big function that ends up in CODE_LO_SPACE.
   const int instruction_size = Page::kPageSize + 1;
   EXPECT_GT(instruction_size, MemoryChunkLayout::MaxRegularCodeObjectSize());
-  std::unique_ptr<byte[]> instructions(new byte[instruction_size]);
+  std::unique_ptr<uint8_t[]> instructions(new uint8_t[instruction_size]);
 
   CodeDesc desc;
   desc.buffer = instructions.get();
diff --git a/test/unittests/codegen/factory-unittest.cc b/test/unittests/codegen/factory-unittest.cc
index 7d6f6ea45cd..f49e68631e4 100644
--- a/test/unittests/codegen/factory-unittest.cc
+++ b/test/unittests/codegen/factory-unittest.cc
@@ -21,7 +21,7 @@ TEST_F(FactoryCodeBuilderTest, Factory_CodeBuilder) {
   // Create a big function that ends up in CODE_LO_SPACE.
   const int instruction_size =
       i_isolate()->heap()->MaxRegularHeapObjectSize(AllocationType::kCode) + 1;
-  std::unique_ptr<byte[]> instructions(new byte[instruction_size]);
+  std::unique_ptr<uint8_t[]> instructions(new uint8_t[instruction_size]);
 
   CodeDesc desc;
   desc.buffer = instructions.get();
@@ -73,7 +73,7 @@ class FactoryCodeBuilderOOMTest : public TestWithIsolate {
 };
 
 TEST_F(FactoryCodeBuilderOOMTest, Factory_CodeBuilder_BuildOOM) {
-  std::unique_ptr<byte[]> instructions(new byte[kInstructionSize]);
+  std::unique_ptr<uint8_t[]> instructions(new uint8_t[kInstructionSize]);
   CodeDesc desc;
   desc.instr_size = kInstructionSize;
   desc.buffer = instructions.get();
@@ -86,7 +86,7 @@ TEST_F(FactoryCodeBuilderOOMTest, Factory_CodeBuilder_BuildOOM) {
 }
 
 TEST_F(FactoryCodeBuilderOOMTest, Factory_CodeBuilder_TryBuildOOM) {
-  std::unique_ptr<byte[]> instructions(new byte[kInstructionSize]);
+  std::unique_ptr<uint8_t[]> instructions(new uint8_t[kInstructionSize]);
   CodeDesc desc;
   desc.instr_size = kInstructionSize;
   desc.buffer = instructions.get();
diff --git a/test/unittests/compiler/arm64/instruction-selector-arm64-unittest.cc b/test/unittests/compiler/arm64/instruction-selector-arm64-unittest.cc
index 3fc281f2328..63602be4804 100644
--- a/test/unittests/compiler/arm64/instruction-selector-arm64-unittest.cc
+++ b/test/unittests/compiler/arm64/instruction-selector-arm64-unittest.cc
@@ -5590,7 +5590,7 @@ using InstructionSelectorSIMDConstZeroCmTest =
 
 TEST_P(InstructionSelectorSIMDConstZeroCmTest, ConstZero) {
   const SIMDConstZeroCmTest param = GetParam();
-  byte data[16] = {};
+  uint8_t data[16] = {};
   if (!param.is_zero) data[0] = 0xff;
   // Const node on the left
   {
diff --git a/test/unittests/diagnostics/eh-frame-iterator-unittest.cc b/test/unittests/diagnostics/eh-frame-iterator-unittest.cc
index 3a97c635539..0565769499c 100644
--- a/test/unittests/diagnostics/eh-frame-iterator-unittest.cc
+++ b/test/unittests/diagnostics/eh-frame-iterator-unittest.cc
@@ -20,7 +20,7 @@ class EhFrameIteratorTest : public testing::Test {};
 
 TEST_F(EhFrameIteratorTest, Values) {
   // Assuming little endian.
-  static const byte kEncoded[] = {0xDE, 0xC0, 0xAD, 0xDE, 0xEF, 0xBE, 0xFF};
+  static const uint8_t kEncoded[] = {0xDE, 0xC0, 0xAD, 0xDE, 0xEF, 0xBE, 0xFF};
   EhFrameIterator iterator(&kEncoded[0], &kEncoded[0] + sizeof(kEncoded));
   EXPECT_EQ(0xDEADC0DE, iterator.GetNextUInt32());
   EXPECT_EQ(0xBEEF, iterator.GetNextUInt16());
@@ -29,7 +29,7 @@ TEST_F(EhFrameIteratorTest, Values) {
 }
 
 TEST_F(EhFrameIteratorTest, Skip) {
-  static const byte kEncoded[] = {0xDE, 0xAD, 0xC0, 0xDE};
+  static const uint8_t kEncoded[] = {0xDE, 0xAD, 0xC0, 0xDE};
   EhFrameIterator iterator(&kEncoded[0], &kEncoded[0] + sizeof(kEncoded));
   iterator.Skip(2);
   EXPECT_EQ(2, iterator.GetCurrentOffset());
@@ -39,21 +39,21 @@ TEST_F(EhFrameIteratorTest, Skip) {
 }
 
 TEST_F(EhFrameIteratorTest, ULEB128Decoding) {
-  static const byte kEncoded[] = {0xE5, 0x8E, 0x26};
+  static const uint8_t kEncoded[] = {0xE5, 0x8E, 0x26};
   EhFrameIterator iterator(&kEncoded[0], &kEncoded[0] + sizeof(kEncoded));
   EXPECT_EQ(624485u, iterator.GetNextULeb128());
   EXPECT_TRUE(iterator.Done());
 }
 
 TEST_F(EhFrameIteratorTest, SLEB128DecodingPositive) {
-  static const byte kEncoded[] = {0xE5, 0x8E, 0x26};
+  static const uint8_t kEncoded[] = {0xE5, 0x8E, 0x26};
   EhFrameIterator iterator(&kEncoded[0], &kEncoded[0] + sizeof(kEncoded));
   EXPECT_EQ(624485, iterator.GetNextSLeb128());
   EXPECT_TRUE(iterator.Done());
 }
 
 TEST_F(EhFrameIteratorTest, SLEB128DecodingNegative) {
-  static const byte kEncoded[] = {0x9B, 0xF1, 0x59};
+  static const uint8_t kEncoded[] = {0x9B, 0xF1, 0x59};
   EhFrameIterator iterator(&kEncoded[0], &kEncoded[0] + sizeof(kEncoded));
   EXPECT_EQ(-624485, iterator.GetNextSLeb128());
   EXPECT_TRUE(iterator.Done());
diff --git a/test/unittests/regexp/regexp-unittest.cc b/test/unittests/regexp/regexp-unittest.cc
index 2b84c701eea..2be8d882cd6 100644
--- a/test/unittests/regexp/regexp-unittest.cc
+++ b/test/unittests/regexp/regexp-unittest.cc
@@ -664,8 +664,8 @@ static ArchRegExpMacroAssembler::Result Execute(JSRegExp regexp, String input,
                                                 int* captures) {
   return static_cast<NativeRegExpMacroAssembler::Result>(
       NativeRegExpMacroAssembler::ExecuteForTesting(
-          input, start_offset, reinterpret_cast<byte*>(input_start),
-          reinterpret_cast<byte*>(input_end), captures, 0,
+          input, start_offset, reinterpret_cast<uint8_t*>(input_start),
+          reinterpret_cast<uint8_t*>(input_end), captures, 0,
           reinterpret_cast<i::Isolate*>(v8::Isolate::GetCurrent()), regexp));
 }
 
@@ -1787,12 +1787,12 @@ TEST_F(RegExpTest, PeepholeNoChange) {
   v8_flags.regexp_peephole_optimization = false;
   Handle<ByteArray> array = Handle<ByteArray>::cast(orig.GetCode(source));
   int length = array->length();
-  byte* byte_array = array->GetDataStartAddress();
+  uint8_t* byte_array = array->GetDataStartAddress();
 
   v8_flags.regexp_peephole_optimization = true;
   Handle<ByteArray> array_optimized =
       Handle<ByteArray>::cast(opt.GetCode(source));
-  byte* byte_array_optimized = array_optimized->GetDataStartAddress();
+  uint8_t* byte_array_optimized = array_optimized->GetDataStartAddress();
 
   CHECK_EQ(0, memcmp(byte_array, byte_array_optimized, length));
 }
diff --git a/test/unittests/strings/unicode-unittest.cc b/test/unittests/strings/unicode-unittest.cc
index 5d647279732..0c096984885 100644
--- a/test/unittests/strings/unicode-unittest.cc
+++ b/test/unittests/strings/unicode-unittest.cc
@@ -18,7 +18,7 @@ namespace internal {
 
 namespace {
 
-void DecodeNormally(const std::vector<byte>& bytes,
+void DecodeNormally(const std::vector<uint8_t>& bytes,
                     std::vector<unibrow::uchar>* output) {
   size_t cursor = 0;
   while (cursor < bytes.size()) {
@@ -46,12 +46,12 @@ void DecodeUtf16(const std::vector<uint8_t>& bytes,
   }
 }
 
-void DecodeIncrementally(const std::vector<byte>& bytes,
+void DecodeIncrementally(const std::vector<uint8_t>& bytes,
                          std::vector<unibrow::uchar>* output) {
   unibrow::Utf8::Utf8IncrementalBuffer buffer = 0;
   unibrow::Utf8::State state = unibrow::Utf8::State::kAccept;
-  const byte* cursor = bytes.data();
-  const byte* end = bytes.data() + bytes.size();
+  const uint8_t* cursor = bytes.data();
+  const uint8_t* end = bytes.data() + bytes.size();
   while (cursor < end) {
     unibrow::uchar result =
         unibrow::Utf8::ValueOfIncremental(&cursor, &state, &buffer);
@@ -70,7 +70,7 @@ void DecodeIncrementally(const std::vector<byte>& bytes,
 TEST(UnicodeTest, Utf16BufferReuse) {
   // Not enough continuation bytes before string ends.
   struct TestCase {
-    std::vector<byte> bytes;
+    std::vector<uint8_t> bytes;
     std::vector<unibrow::uchar> unicode_expected;
   };
 
@@ -115,7 +115,7 @@ TEST(UnicodeTest, IncrementalUTF8DecodingVsNonIncrementalUtf8Decoding) {
   // produce the same result. This test was inspired by
   // https://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt .
   struct TestCase {
-    std::vector<byte> bytes;
+    std::vector<uint8_t> bytes;
     std::vector<unibrow::uchar> unicode_expected;
   };
 
diff --git a/test/unittests/wasm/decoder-unittest.cc b/test/unittests/wasm/decoder-unittest.cc
index 3e43729e0e3..ce268f221ce 100644
--- a/test/unittests/wasm/decoder-unittest.cc
+++ b/test/unittests/wasm/decoder-unittest.cc
@@ -22,7 +22,7 @@ class DecoderTest : public TestWithZone {
 
 #define CHECK_UINT32V_INLINE(expected, expected_length, ...)            \
   do {                                                                  \
-    const byte data[] = {__VA_ARGS__};                                  \
+    const uint8_t data[] = {__VA_ARGS__};                               \
     decoder.Reset(data, data + sizeof(data));                           \
     auto [value, length] =                                              \
         decoder.read_u32v<Decoder::FullValidationTag>(decoder.start()); \
@@ -36,7 +36,7 @@ class DecoderTest : public TestWithZone {
 
 #define CHECK_INT32V_INLINE(expected, expected_length, ...)             \
   do {                                                                  \
-    const byte data[] = {__VA_ARGS__};                                  \
+    const uint8_t data[] = {__VA_ARGS__};                               \
     decoder.Reset(data, data + sizeof(data));                           \
     auto [value, length] =                                              \
         decoder.read_i32v<Decoder::FullValidationTag>(decoder.start()); \
@@ -50,7 +50,7 @@ class DecoderTest : public TestWithZone {
 
 #define CHECK_UINT64V_INLINE(expected, expected_length, ...)            \
   do {                                                                  \
-    const byte data[] = {__VA_ARGS__};                                  \
+    const uint8_t data[] = {__VA_ARGS__};                               \
     decoder.Reset(data, data + sizeof(data));                           \
     auto [value, length] =                                              \
         decoder.read_u64v<Decoder::FullValidationTag>(decoder.start()); \
@@ -60,7 +60,7 @@ class DecoderTest : public TestWithZone {
 
 #define CHECK_INT64V_INLINE(expected, expected_length, ...)             \
   do {                                                                  \
-    const byte data[] = {__VA_ARGS__};                                  \
+    const uint8_t data[] = {__VA_ARGS__};                               \
     decoder.Reset(data, data + sizeof(data));                           \
     auto [value, length] =                                              \
         decoder.read_i64v<Decoder::FullValidationTag>(decoder.start()); \
@@ -374,14 +374,14 @@ TEST_F(DecoderTest, ReadI32v_FiveByte) {
 }
 
 TEST_F(DecoderTest, ReadU32v_off_end1) {
-  static const byte data[] = {U32V_1(11)};
+  static const uint8_t data[] = {U32V_1(11)};
   decoder.Reset(data, data);
   decoder.read_u32v<Decoder::FullValidationTag>(decoder.start());
   EXPECT_FALSE(decoder.ok());
 }
 
 TEST_F(DecoderTest, ReadU32v_off_end2) {
-  static const byte data[] = {U32V_2(1111)};
+  static const uint8_t data[] = {U32V_2(1111)};
   for (size_t i = 0; i < sizeof(data); i++) {
     decoder.Reset(data, data + i);
     decoder.read_u32v<Decoder::FullValidationTag>(decoder.start());
@@ -390,7 +390,7 @@ TEST_F(DecoderTest, ReadU32v_off_end2) {
 }
 
 TEST_F(DecoderTest, ReadU32v_off_end3) {
-  static const byte data[] = {U32V_3(111111)};
+  static const uint8_t data[] = {U32V_3(111111)};
   for (size_t i = 0; i < sizeof(data); i++) {
     decoder.Reset(data, data + i);
     decoder.read_u32v<Decoder::FullValidationTag>(decoder.start());
@@ -399,7 +399,7 @@ TEST_F(DecoderTest, ReadU32v_off_end3) {
 }
 
 TEST_F(DecoderTest, ReadU32v_off_end4) {
-  static const byte data[] = {U32V_4(11111111)};
+  static const uint8_t data[] = {U32V_4(11111111)};
   for (size_t i = 0; i < sizeof(data); i++) {
     decoder.Reset(data, data + i);
     decoder.read_u32v<Decoder::FullValidationTag>(decoder.start());
@@ -408,7 +408,7 @@ TEST_F(DecoderTest, ReadU32v_off_end4) {
 }
 
 TEST_F(DecoderTest, ReadU32v_off_end5) {
-  static const byte data[] = {U32V_5(111111111)};
+  static const uint8_t data[] = {U32V_5(111111111)};
   for (size_t i = 0; i < sizeof(data); i++) {
     decoder.Reset(data, data + i);
     decoder.read_u32v<Decoder::FullValidationTag>(decoder.start());
@@ -417,9 +417,9 @@ TEST_F(DecoderTest, ReadU32v_off_end5) {
 }
 
 TEST_F(DecoderTest, ReadU32v_extra_bits) {
-  byte data[] = {0x80, 0x80, 0x80, 0x80, 0x00};
+  uint8_t data[] = {0x80, 0x80, 0x80, 0x80, 0x00};
   for (int i = 1; i < 16; i++) {
-    data[4] = static_cast<byte>(i << 4);
+    data[4] = static_cast<uint8_t>(i << 4);
     decoder.Reset(data, data + sizeof(data));
     decoder.read_u32v<Decoder::FullValidationTag>(decoder.start());
     EXPECT_FALSE(decoder.ok());
@@ -428,7 +428,7 @@ TEST_F(DecoderTest, ReadU32v_extra_bits) {
 
 TEST_F(DecoderTest, ReadI32v_extra_bits_negative) {
   // OK for negative signed values to have extra ones.
-  byte data[] = {0xFF, 0xFF, 0xFF, 0xFF, 0x7F};
+  uint8_t data[] = {0xFF, 0xFF, 0xFF, 0xFF, 0x7F};
   decoder.Reset(data, data + sizeof(data));
   auto [result, length] =
       decoder.read_i32v<Decoder::FullValidationTag>(decoder.start());
@@ -438,7 +438,7 @@ TEST_F(DecoderTest, ReadI32v_extra_bits_negative) {
 
 TEST_F(DecoderTest, ReadI32v_extra_bits_positive) {
   // Not OK for positive signed values to have extra ones.
-  byte data[] = {0x80, 0x80, 0x80, 0x80, 0x77};
+  uint8_t data[] = {0x80, 0x80, 0x80, 0x80, 0x77};
   decoder.Reset(data, data + sizeof(data));
   decoder.read_i32v<Decoder::FullValidationTag>(decoder.start());
   EXPECT_FALSE(decoder.ok());
@@ -453,7 +453,7 @@ TEST_F(DecoderTest, ReadU32v_Bits) {
       0xC4A0CF81, 0x16C6EB85, 0x4206DB8E, 0xF3B089D5, 0xAA2E223E, 0xF99E29C8,
       0x4A4357D8, 0x1890B1C1, 0x8D80A085, 0xACB6AE4C, 0x1B827E10, 0xEB5C7BD9,
       0xBB1BC146, 0xDF57A33l};
-  byte data[kMaxSize];
+  uint8_t data[kMaxSize];
 
   // foreach value in above array
   for (size_t v = 0; v < arraysize(kVals); v++) {
@@ -465,7 +465,7 @@ TEST_F(DecoderTest, ReadU32v_Bits) {
 
       unsigned length = 1 + i / 7;
       for (unsigned j = 0; j < kMaxSize; j++) {
-        data[j] = static_cast<byte>((val >> (7 * j)) & MASK_7);
+        data[j] = static_cast<uint8_t>((val >> (7 * j)) & MASK_7);
       }
       for (unsigned j = 0; j < length - 1; j++) {
         data[j] |= 0x80;
@@ -520,7 +520,7 @@ TEST_F(DecoderTest, ReadI64v_OneByte) {
 
 TEST_F(DecoderTest, ReadU64v_PowerOf2) {
   const int kMaxSize = 10;
-  byte data[kMaxSize];
+  uint8_t data[kMaxSize];
 
   for (unsigned i = 0; i < 64; i++) {
     const uint64_t val = 1ull << i;
@@ -551,7 +551,7 @@ TEST_F(DecoderTest, ReadU64v_Bits) {
       0x123456789ABCDEF0ull, 0x80309488729ED997ull, 0xC4A0CF8116C6EB85ull,
       0x4206DB8EF3B089D5ull, 0xAA2E223EF99E29C8ull, 0x4A4357D81890B1C1ull,
       0x8D80A085ACB6AE4Cull, 0x1B827E10EB5C7BD9ull, 0xBB1BC146DF57A338ull};
-  byte data[kMaxSize];
+  uint8_t data[kMaxSize];
 
   // foreach value in above array
   for (size_t v = 0; v < arraysize(kVals); v++) {
@@ -562,7 +562,7 @@ TEST_F(DecoderTest, ReadU64v_Bits) {
 
       unsigned length = 1 + i / 7;
       for (unsigned j = 0; j < kMaxSize; j++) {
-        data[j] = static_cast<byte>((val >> (7 * j)) & MASK_7);
+        data[j] = static_cast<uint8_t>((val >> (7 * j)) & MASK_7);
       }
       for (unsigned j = 0; j < length - 1; j++) {
         data[j] |= 0x80;
@@ -594,7 +594,7 @@ TEST_F(DecoderTest, ReadI64v_Bits) {
       0x123456789ABCDEF0ull, 0x80309488729ED997ull, 0xC4A0CF8116C6EB85ull,
       0x4206DB8EF3B089D5ull, 0xAA2E223EF99E29C8ull, 0x4A4357D81890B1C1ull,
       0x8D80A085ACB6AE4Cull, 0x1B827E10EB5C7BD9ull, 0xBB1BC146DF57A338ull};
-  byte data[kMaxSize];
+  uint8_t data[kMaxSize];
 
   // foreach value in above array
   for (size_t v = 0; v < arraysize(kVals); v++) {
@@ -605,7 +605,7 @@ TEST_F(DecoderTest, ReadI64v_Bits) {
 
       unsigned length = 1 + i / 7;
       for (unsigned j = 0; j < kMaxSize; j++) {
-        data[j] = static_cast<byte>((val >> (7 * j)) & MASK_7);
+        data[j] = static_cast<uint8_t>((val >> (7 * j)) & MASK_7);
       }
       for (unsigned j = 0; j < length - 1; j++) {
         data[j] |= 0x80;
@@ -629,9 +629,9 @@ TEST_F(DecoderTest, ReadI64v_Bits) {
 }
 
 TEST_F(DecoderTest, ReadU64v_extra_bits) {
-  byte data[] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00};
+  uint8_t data[] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00};
   for (int i = 1; i < 128; i++) {
-    data[9] = static_cast<byte>(i << 1);
+    data[9] = static_cast<uint8_t>(i << 1);
     decoder.Reset(data, data + sizeof(data));
     decoder.read_u64v<Decoder::FullValidationTag>(decoder.start());
     EXPECT_FALSE(decoder.ok());
@@ -640,7 +640,7 @@ TEST_F(DecoderTest, ReadU64v_extra_bits) {
 
 TEST_F(DecoderTest, ReadI64v_extra_bits_negative) {
   // OK for negative signed values to have extra ones.
-  byte data[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F};
+  uint8_t data[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F};
   decoder.Reset(data, data + sizeof(data));
   auto [result, length] =
       decoder.read_i64v<Decoder::FullValidationTag>(decoder.start());
@@ -650,7 +650,7 @@ TEST_F(DecoderTest, ReadI64v_extra_bits_negative) {
 
 TEST_F(DecoderTest, ReadI64v_extra_bits_positive) {
   // Not OK for positive signed values to have extra ones.
-  byte data[] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x77};
+  uint8_t data[] = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x77};
   decoder.Reset(data, data + sizeof(data));
   decoder.read_i64v<Decoder::FullValidationTag>(decoder.start());
   EXPECT_FALSE(decoder.ok());
diff --git a/test/unittests/wasm/function-body-decoder-unittest.cc b/test/unittests/wasm/function-body-decoder-unittest.cc
index 5f9f767ad8b..8391e6eb2e3 100644
--- a/test/unittests/wasm/function-body-decoder-unittest.cc
+++ b/test/unittests/wasm/function-body-decoder-unittest.cc
@@ -37,10 +37,10 @@ namespace v8::internal::wasm {
     }                                                            \
   } while (false)
 
-static const byte kCodeGetLocal0[] = {kExprLocalGet, 0};
-static const byte kCodeGetLocal1[] = {kExprLocalGet, 1};
-static const byte kCodeSetLocal0[] = {WASM_LOCAL_SET(0, WASM_ZERO)};
-static const byte kCodeTeeLocal0[] = {WASM_LOCAL_TEE(0, WASM_ZERO)};
+static const uint8_t kCodeGetLocal0[] = {kExprLocalGet, 0};
+static const uint8_t kCodeGetLocal1[] = {kExprLocalGet, 1};
+static const uint8_t kCodeSetLocal0[] = {WASM_LOCAL_SET(0, WASM_ZERO)};
+static const uint8_t kCodeTeeLocal0[] = {WASM_LOCAL_TEE(0, WASM_ZERO)};
 
 static const ValueType kValueTypes[] = {kWasmI32, kWasmI64, kWasmF32, kWasmF64,
                                         kWasmExternRef};
@@ -57,7 +57,7 @@ static const WasmOpcode kInt32BinopOpcodes[] = {
     kExprI32LeS,  kExprI32LtU,  kExprI32LeU};
 
 #define WASM_BRV_IF_ZERO(depth, val) \
-  val, WASM_ZERO, kExprBrIf, static_cast<byte>(depth)
+  val, WASM_ZERO, kExprBrIf, static_cast<uint8_t>(depth)
 
 constexpr size_t kMaxByteSizedLeb128 = 127;
 
@@ -78,39 +78,40 @@ class TestModuleBuilder {
     // Asm.js functions are valid by design.
     if (is_asmjs_module(&mod)) mod.validated_functions[0] = 0xff;
   }
-  byte AddGlobal(ValueType type, bool mutability = true) {
+  uint8_t AddGlobal(ValueType type, bool mutability = true) {
     mod.globals.push_back({type, mutability, {}, {0}, false, false});
     CHECK_LE(mod.globals.size(), kMaxByteSizedLeb128);
-    return static_cast<byte>(mod.globals.size() - 1);
+    return static_cast<uint8_t>(mod.globals.size() - 1);
   }
-  byte AddSignature(const FunctionSig* sig, uint32_t supertype = kNoSuperType) {
+  uint8_t AddSignature(const FunctionSig* sig,
+                       uint32_t supertype = kNoSuperType) {
     mod.add_signature(sig, supertype, v8_flags.wasm_final_types);
     CHECK_LE(mod.types.size(), kMaxByteSizedLeb128);
     GetTypeCanonicalizer()->AddRecursiveGroup(module(), 1);
-    return static_cast<byte>(mod.types.size() - 1);
+    return static_cast<uint8_t>(mod.types.size() - 1);
   }
-  byte AddFunction(const FunctionSig* sig, bool declared = true) {
-    byte sig_index = AddSignature(sig);
+  uint8_t AddFunction(const FunctionSig* sig, bool declared = true) {
+    uint8_t sig_index = AddSignature(sig);
     return AddFunctionImpl(sig, sig_index, declared);
   }
-  byte AddFunction(uint32_t sig_index, bool declared = true) {
+  uint8_t AddFunction(uint32_t sig_index, bool declared = true) {
     DCHECK(mod.has_signature(sig_index));
     return AddFunctionImpl(mod.types[sig_index].function_sig, sig_index,
                            declared);
   }
-  byte AddImport(const FunctionSig* sig) {
-    byte result = AddFunction(sig);
+  uint8_t AddImport(const FunctionSig* sig) {
+    uint8_t result = AddFunction(sig);
     mod.functions[result].imported = true;
     return result;
   }
-  byte AddException(WasmTagSig* sig) {
+  uint8_t AddException(WasmTagSig* sig) {
     mod.tags.emplace_back(sig, AddSignature(sig));
     CHECK_LE(mod.types.size(), kMaxByteSizedLeb128);
-    return static_cast<byte>(mod.tags.size() - 1);
+    return static_cast<uint8_t>(mod.tags.size() - 1);
   }
 
-  byte AddTable(ValueType type, uint32_t initial_size, bool has_maximum_size,
-                uint32_t maximum_size) {
+  uint8_t AddTable(ValueType type, uint32_t initial_size, bool has_maximum_size,
+                   uint32_t maximum_size) {
     CHECK(type.is_object_reference());
     mod.tables.emplace_back();
     WasmTable& table = mod.tables.back();
@@ -118,11 +119,11 @@ class TestModuleBuilder {
     table.initial_size = initial_size;
     table.has_maximum_size = has_maximum_size;
     table.maximum_size = maximum_size;
-    return static_cast<byte>(mod.tables.size() - 1);
+    return static_cast<uint8_t>(mod.tables.size() - 1);
   }
 
-  byte AddStruct(std::initializer_list<F> fields,
-                 uint32_t supertype = kNoSuperType) {
+  uint8_t AddStruct(std::initializer_list<F> fields,
+                    uint32_t supertype = kNoSuperType) {
     StructType::Builder type_builder(&mod.signature_zone,
                                      static_cast<uint32_t>(fields.size()));
     for (F field : fields) {
@@ -131,14 +132,14 @@ class TestModuleBuilder {
     mod.add_struct_type(type_builder.Build(), supertype,
                         v8_flags.wasm_final_types);
     GetTypeCanonicalizer()->AddRecursiveGroup(module(), 1);
-    return static_cast<byte>(mod.types.size() - 1);
+    return static_cast<uint8_t>(mod.types.size() - 1);
   }
 
-  byte AddArray(ValueType type, bool mutability) {
+  uint8_t AddArray(ValueType type, bool mutability) {
     ArrayType* array = mod.signature_zone.New<ArrayType>(type, mutability);
     mod.add_array_type(array, kNoSuperType, v8_flags.wasm_final_types);
     GetTypeCanonicalizer()->AddRecursiveGroup(module(), 1);
-    return static_cast<byte>(mod.types.size() - 1);
+    return static_cast<uint8_t>(mod.types.size() - 1);
   }
 
   void InitializeMemory(MemoryType mem_type = kMemory32) {
@@ -148,23 +149,23 @@ class TestModuleBuilder {
     mod.maximum_pages = 100;
   }
 
-  byte InitializeTable(wasm::ValueType type) {
+  uint8_t InitializeTable(wasm::ValueType type) {
     mod.tables.emplace_back();
     mod.tables.back().type = type;
-    return static_cast<byte>(mod.tables.size() - 1);
+    return static_cast<uint8_t>(mod.tables.size() - 1);
   }
 
-  byte AddPassiveElementSegment(wasm::ValueType type) {
+  uint8_t AddPassiveElementSegment(wasm::ValueType type) {
     mod.elem_segments.emplace_back(type, WasmElemSegment::kStatusPassive,
                                    WasmElemSegment::kExpressionElements, 0, 0);
-    return static_cast<byte>(mod.elem_segments.size() - 1);
+    return static_cast<uint8_t>(mod.elem_segments.size() - 1);
   }
 
-  byte AddDeclarativeElementSegment() {
+  uint8_t AddDeclarativeElementSegment() {
     mod.elem_segments.emplace_back(kWasmFuncRef,
                                    WasmElemSegment::kStatusDeclarative,
                                    WasmElemSegment::kExpressionElements, 0, 0);
-    return static_cast<byte>(mod.elem_segments.size() - 1);
+    return static_cast<uint8_t>(mod.elem_segments.size() - 1);
   }
 
   // Set the number of data segments as declared by the DataCount section.
@@ -177,8 +178,8 @@ class TestModuleBuilder {
   WasmModule* module() { return &mod; }
 
  private:
-  byte AddFunctionImpl(const FunctionSig* sig, uint32_t sig_index,
-                       bool declared) {
+  uint8_t AddFunctionImpl(const FunctionSig* sig, uint32_t sig_index,
+                          bool declared) {
     mod.functions.push_back(
         {sig,                                          // sig
          static_cast<uint32_t>(mod.functions.size()),  // func_index
@@ -188,7 +189,7 @@ class TestModuleBuilder {
          false,                                        // export
          declared});                                   // declared
     CHECK_LE(mod.functions.size(), kMaxByteSizedLeb128);
-    return static_cast<byte>(mod.functions.size() - 1);
+    return static_cast<uint8_t>(mod.functions.size() - 1);
   }
 
   WasmModule mod;
@@ -213,12 +214,12 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
 
   enum AppendEnd : bool { kAppendEnd, kOmitEnd };
 
-  base::Vector<const byte> PrepareBytecode(base::Vector<const byte> code,
-                                           AppendEnd append_end) {
+  base::Vector<const uint8_t> PrepareBytecode(base::Vector<const uint8_t> code,
+                                              AppendEnd append_end) {
     size_t locals_size = local_decls.Size();
     size_t total_size =
         code.size() + locals_size + (append_end == kAppendEnd ? 1 : 0);
-    byte* buffer = this->zone()->template NewArray<byte>(total_size);
+    uint8_t* buffer = this->zone()->template NewArray<uint8_t>(total_size);
     // Prepend the local decls to the code.
     local_decls.Emit(buffer);
     // Emit the code.
@@ -234,26 +235,26 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
   }
 
   template <size_t N>
-  base::Vector<const byte> CodeToVector(const byte (&code)[N]) {
+  base::Vector<const uint8_t> CodeToVector(const uint8_t (&code)[N]) {
     return base::ArrayVector(code);
   }
 
-  base::Vector<const byte> CodeToVector(
-      const std::initializer_list<const byte>& code) {
+  base::Vector<const uint8_t> CodeToVector(
+      const std::initializer_list<const uint8_t>& code) {
     return base::VectorOf(&*code.begin(), code.size());
   }
 
-  base::Vector<const byte> CodeToVector(base::Vector<const byte> vec) {
+  base::Vector<const uint8_t> CodeToVector(base::Vector<const uint8_t> vec) {
     return vec;
   }
 
   // Prepends local variable declarations and renders nice error messages for
   // verification failures.
-  template <typename Code = std::initializer_list<const byte>>
+  template <typename Code = std::initializer_list<const uint8_t>>
   void Validate(bool expected_success, const FunctionSig* sig, Code&& raw_code,
                 AppendEnd append_end = kAppendEnd,
                 const char* message = nullptr) {
-    base::Vector<const byte> code =
+    base::Vector<const uint8_t> code =
         PrepareBytecode(CodeToVector(std::forward<Code>(raw_code)), append_end);
 
     // Validate the code.
@@ -275,14 +276,14 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
     }
   }
 
-  template <typename Code = std::initializer_list<const byte>>
+  template <typename Code = std::initializer_list<const uint8_t>>
   void ExpectValidates(const FunctionSig* sig, Code&& raw_code,
                        AppendEnd append_end = kAppendEnd,
                        const char* message = nullptr) {
     Validate(true, sig, std::forward<Code>(raw_code), append_end, message);
   }
 
-  template <typename Code = std::initializer_list<const byte>>
+  template <typename Code = std::initializer_list<const uint8_t>>
   void ExpectFailure(const FunctionSig* sig, Code&& raw_code,
                      AppendEnd append_end = kAppendEnd,
                      const char* message = nullptr) {
@@ -291,7 +292,7 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
 
   void TestBinop(WasmOpcode opcode, const FunctionSig* success) {
     // op(local[0], local[1])
-    byte code[] = {WASM_BINOP(opcode, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
+    uint8_t code[] = {WASM_BINOP(opcode, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
     ExpectValidates(success, code);
 
     // Try all combinations of return and parameter types.
@@ -317,7 +318,7 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
 
   void TestUnop(WasmOpcode opcode, ValueType ret_type, ValueType param_type) {
     // Return(op(local[0]))
-    byte code[] = {WASM_UNOP(opcode, WASM_LOCAL_GET(0))};
+    uint8_t code[] = {WASM_UNOP(opcode, WASM_LOCAL_GET(0))};
     {
       ValueType types[] = {ret_type, param_type};
       FunctionSig sig(1, 1, types);
@@ -341,9 +342,9 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
 using FunctionBodyDecoderTest = FunctionBodyDecoderTestBase<TestWithPlatform>;
 
 TEST_F(FunctionBodyDecoderTest, Int32Const1) {
-  byte code[] = {kExprI32Const, 0};
+  uint8_t code[] = {kExprI32Const, 0};
   for (int i = -64; i <= 63; i++) {
-    code[1] = static_cast<byte>(i & 0x7F);
+    code[1] = static_cast<uint8_t>(i & 0x7F);
     ExpectValidates(sigs.i_i(), code);
   }
 }
@@ -360,7 +361,7 @@ TEST_F(FunctionBodyDecoderTest, EmptyFunction) {
 }
 
 TEST_F(FunctionBodyDecoderTest, IncompleteIf1) {
-  byte code[] = {kExprIf};
+  uint8_t code[] = {kExprIf};
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
@@ -390,7 +391,7 @@ TEST_F(FunctionBodyDecoderTest, Int64Const) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Float32Const) {
-  byte code[] = {kExprF32Const, 0, 0, 0, 0};
+  uint8_t code[] = {kExprF32Const, 0, 0, 0, 0};
   Address ptr = reinterpret_cast<Address>(code + 1);
   for (int i = 0; i < 30; i++) {
     base::WriteLittleEndianValue<float>(ptr, i * -7.75f);
@@ -399,7 +400,7 @@ TEST_F(FunctionBodyDecoderTest, Float32Const) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Float64Const) {
-  byte code[] = {kExprF64Const, 0, 0, 0, 0, 0, 0, 0, 0};
+  uint8_t code[] = {kExprF64Const, 0, 0, 0, 0, 0, 0, 0, 0};
   Address ptr = reinterpret_cast<Address>(code + 1);
   for (int i = 0; i < 30; i++) {
     base::WriteLittleEndianValue<double>(ptr, i * 33.45);
@@ -408,7 +409,7 @@ TEST_F(FunctionBodyDecoderTest, Float64Const) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Int32Const_off_end) {
-  byte code[] = {kExprI32Const, 0xAA, 0xBB, 0xCC, 0x44};
+  uint8_t code[] = {kExprI32Const, 0xAA, 0xBB, 0xCC, 0x44};
 
   for (size_t size = 1; size <= 4; ++size) {
     ExpectFailure(sigs.i_i(), base::VectorOf(code, size), kAppendEnd);
@@ -438,9 +439,9 @@ TEST_F(FunctionBodyDecoderTest, GetLocal0_param_n) {
 }
 
 TEST_F(FunctionBodyDecoderTest, GetLocalN_local) {
-  for (byte i = 1; i < 8; i++) {
+  for (uint8_t i = 1; i < 8; i++) {
     AddLocals(kWasmI32, 1);
-    for (byte j = 0; j < i; j++) {
+    for (uint8_t j = 0; j < i; j++) {
       ExpectValidates(sigs.i_v(), {kExprLocalGet, j});
     }
   }
@@ -503,19 +504,19 @@ TEST_F(FunctionBodyDecoderTest, GetLocal_toomany) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Binops_off_end) {
-  byte code1[] = {0};  // [opcode]
+  uint8_t code1[] = {0};  // [opcode]
   for (size_t i = 0; i < arraysize(kInt32BinopOpcodes); i++) {
     code1[0] = kInt32BinopOpcodes[i];
     ExpectFailure(sigs.i_i(), code1);
   }
 
-  byte code3[] = {kExprLocalGet, 0, 0};  // [expr] [opcode]
+  uint8_t code3[] = {kExprLocalGet, 0, 0};  // [expr] [opcode]
   for (size_t i = 0; i < arraysize(kInt32BinopOpcodes); i++) {
     code3[2] = kInt32BinopOpcodes[i];
     ExpectFailure(sigs.i_i(), code3);
   }
 
-  byte code4[] = {kExprLocalGet, 0, 0, 0};  // [expr] [opcode] [opcode]
+  uint8_t code4[] = {kExprLocalGet, 0, 0, 0};  // [expr] [opcode] [opcode]
   for (size_t i = 0; i < arraysize(kInt32BinopOpcodes); i++) {
     code4[2] = kInt32BinopOpcodes[i];
     code4[3] = kInt32BinopOpcodes[i];
@@ -573,9 +574,9 @@ TEST_F(FunctionBodyDecoderTest, TeeLocal0_local) {
 }
 
 TEST_F(FunctionBodyDecoderTest, TeeLocalN_local) {
-  for (byte i = 1; i < 8; i++) {
+  for (uint8_t i = 1; i < 8; i++) {
     AddLocals(kWasmI32, 1);
-    for (byte j = 0; j < i; j++) {
+    for (uint8_t j = 0; j < i; j++) {
       ExpectFailure(sigs.v_v(), {WASM_LOCAL_TEE(j, WASM_I32V_1(i))});
       ExpectValidates(sigs.i_i(), {WASM_LOCAL_TEE(j, WASM_I32V_1(i))});
     }
@@ -584,7 +585,7 @@ TEST_F(FunctionBodyDecoderTest, TeeLocalN_local) {
 
 TEST_F(FunctionBodyDecoderTest, BlockN) {
   constexpr size_t kMaxSize = 200;
-  byte buffer[kMaxSize + 3];
+  uint8_t buffer[kMaxSize + 3];
 
   for (size_t i = 0; i <= kMaxSize; i++) {
     memset(buffer, kExprNop, sizeof(buffer));
@@ -619,7 +620,7 @@ TEST_F(FunctionBodyDecoderTest, Block0_end) {
 #undef WASM_EMPTY_BLOCK
 
 TEST_F(FunctionBodyDecoderTest, Block1) {
-  byte code[] = {WASM_BLOCK_I(WASM_LOCAL_GET(0))};
+  uint8_t code[] = {WASM_BLOCK_I(WASM_LOCAL_GET(0))};
   ExpectValidates(sigs.i_i(), code);
   ExpectFailure(sigs.v_i(), code);
   ExpectFailure(sigs.d_dd(), code);
@@ -628,7 +629,7 @@ TEST_F(FunctionBodyDecoderTest, Block1) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Block1_i) {
-  byte code[] = {WASM_BLOCK_I(WASM_ZERO)};
+  uint8_t code[] = {WASM_BLOCK_I(WASM_ZERO)};
   ExpectValidates(sigs.i_i(), code);
   ExpectFailure(sigs.f_ff(), code);
   ExpectFailure(sigs.d_dd(), code);
@@ -636,7 +637,7 @@ TEST_F(FunctionBodyDecoderTest, Block1_i) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Block1_f) {
-  byte code[] = {WASM_BLOCK_F(WASM_F32(0))};
+  uint8_t code[] = {WASM_BLOCK_F(WASM_F32(0))};
   ExpectFailure(sigs.i_i(), code);
   ExpectValidates(sigs.f_ff(), code);
   ExpectFailure(sigs.d_dd(), code);
@@ -668,7 +669,7 @@ TEST_F(FunctionBodyDecoderTest, Block2) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Block2b) {
-  byte code[] = {WASM_BLOCK_I(WASM_LOCAL_SET(0, WASM_ZERO), WASM_ZERO)};
+  uint8_t code[] = {WASM_BLOCK_I(WASM_LOCAL_SET(0, WASM_ZERO), WASM_ZERO)};
   ExpectValidates(sigs.i_i(), code);
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.f_ff(), code);
@@ -738,14 +739,14 @@ TEST_F(FunctionBodyDecoderTest, BlockType_fail) {
 }
 
 TEST_F(FunctionBodyDecoderTest, BlockF32) {
-  static const byte code[] = {WASM_BLOCK_F(kExprF32Const, 0, 0, 0, 0)};
+  static const uint8_t code[] = {WASM_BLOCK_F(kExprF32Const, 0, 0, 0, 0)};
   ExpectValidates(sigs.f_ff(), code);
   ExpectFailure(sigs.i_i(), code);
   ExpectFailure(sigs.d_dd(), code);
 }
 
 TEST_F(FunctionBodyDecoderTest, BlockN_off_end) {
-  byte code[] = {WASM_BLOCK(kExprNop, kExprNop, kExprNop, kExprNop)};
+  uint8_t code[] = {WASM_BLOCK(kExprNop, kExprNop, kExprNop, kExprNop)};
   ExpectValidates(sigs.v_v(), code);
   for (size_t i = 1; i < arraysize(code); i++) {
     ExpectFailure(sigs.v_v(), base::VectorOf(code, i), kAppendEnd);
@@ -807,25 +808,26 @@ TEST_F(FunctionBodyDecoderTest, If_empty4) {
 }
 
 TEST_F(FunctionBodyDecoderTest, If_empty_stack) {
-  byte code[] = {kExprIf};
+  uint8_t code[] = {kExprIf};
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
 
 TEST_F(FunctionBodyDecoderTest, If_incomplete1) {
-  byte code[] = {kExprI32Const, 0, kExprIf};
+  uint8_t code[] = {kExprI32Const, 0, kExprIf};
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
 
 TEST_F(FunctionBodyDecoderTest, If_incomplete2) {
-  byte code[] = {kExprI32Const, 0, kExprIf, kExprNop};
+  uint8_t code[] = {kExprI32Const, 0, kExprIf, kExprNop};
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
 
 TEST_F(FunctionBodyDecoderTest, If_else_else) {
-  byte code[] = {kExprI32Const, 0, WASM_IF_OP, kExprElse, kExprElse, kExprEnd};
+  uint8_t code[] = {kExprI32Const, 0,         WASM_IF_OP,
+                    kExprElse,     kExprElse, kExprEnd};
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
@@ -859,7 +861,7 @@ TEST_F(FunctionBodyDecoderTest, IfElseUnreachable1) {
 }
 
 TEST_F(FunctionBodyDecoderTest, IfElseUnreachable2) {
-  static const byte code[] = {
+  static const uint8_t code[] = {
       WASM_IF_ELSE_I(WASM_LOCAL_GET(0), WASM_UNREACHABLE, WASM_LOCAL_GET(0))};
 
   for (size_t i = 0; i < arraysize(kValueTypes); i++) {
@@ -871,7 +873,8 @@ TEST_F(FunctionBodyDecoderTest, IfElseUnreachable2) {
 }
 
 TEST_F(FunctionBodyDecoderTest, OneArmedIfWithArity) {
-  static const byte code[] = {WASM_ZERO, kExprIf, kI32Code, WASM_ONE, kExprEnd};
+  static const uint8_t code[] = {WASM_ZERO, kExprIf, kI32Code, WASM_ONE,
+                                 kExprEnd};
   ExpectFailure(sigs.i_v(), code, kAppendEnd,
                 "start-arity and end-arity of one-armed if must match");
 }
@@ -892,7 +895,7 @@ TEST_F(FunctionBodyDecoderTest, IfElseBreak) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Block_else) {
-  byte code[] = {kExprI32Const, 0, kExprBlock, kExprElse, kExprEnd};
+  uint8_t code[] = {kExprI32Const, 0, kExprBlock, kExprElse, kExprEnd};
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
@@ -956,7 +959,7 @@ TEST_F(FunctionBodyDecoderTest, Loop0) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Loop1) {
-  static const byte code[] = {WASM_LOOP(WASM_LOCAL_SET(0, WASM_ZERO))};
+  static const uint8_t code[] = {WASM_LOOP(WASM_LOCAL_SET(0, WASM_ZERO))};
   ExpectValidates(sigs.v_i(), code);
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.f_ff(), code);
@@ -1032,14 +1035,14 @@ TEST_F(FunctionBodyDecoderTest, LoopType_fail) {
 }
 
 TEST_F(FunctionBodyDecoderTest, ReturnVoid1) {
-  static const byte code[] = {kExprNop};
+  static const uint8_t code[] = {kExprNop};
   ExpectValidates(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
   ExpectFailure(sigs.i_f(), code);
 }
 
 TEST_F(FunctionBodyDecoderTest, ReturnVoid2) {
-  static const byte code[] = {WASM_BLOCK(WASM_BR(0))};
+  static const uint8_t code[] = {WASM_BLOCK(WASM_BR(0))};
   ExpectValidates(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
   ExpectFailure(sigs.i_f(), code);
@@ -1107,16 +1110,17 @@ TEST_F(FunctionBodyDecoderTest, UnreachableRefTypes) {
   WASM_FEATURE_SCOPE(gc);
   WASM_FEATURE_SCOPE(return_call);
 
-  byte sig_index = builder.AddSignature(sigs.i_ii());
-  byte function_index = builder.AddFunction(sig_index);
-  byte struct_index = builder.AddStruct({F(kWasmI32, true), F(kWasmI64, true)});
-  byte array_index = builder.AddArray(kWasmI32, true);
+  uint8_t sig_index = builder.AddSignature(sigs.i_ii());
+  uint8_t function_index = builder.AddFunction(sig_index);
+  uint8_t struct_index =
+      builder.AddStruct({F(kWasmI32, true), F(kWasmI64, true)});
+  uint8_t array_index = builder.AddArray(kWasmI32, true);
 
   ValueType struct_type = ValueType::Ref(struct_index);
   ValueType struct_type_null = ValueType::RefNull(struct_index);
   FunctionSig sig_v_s(0, 1, &struct_type);
-  byte struct_consumer = builder.AddFunction(&sig_v_s);
-  byte struct_consumer2 = builder.AddFunction(
+  uint8_t struct_consumer = builder.AddFunction(&sig_v_s);
+  uint8_t struct_consumer2 = builder.AddFunction(
       FunctionSig::Build(zone(), {kWasmI32}, {struct_type, struct_type}));
 
   ExpectValidates(sigs.i_v(), {WASM_UNREACHABLE, kExprRefIsNull});
@@ -1209,7 +1213,7 @@ TEST_F(FunctionBodyDecoderTest, If1) {
 }
 
 TEST_F(FunctionBodyDecoderTest, If_off_end) {
-  static const byte kCode[] = {
+  static const uint8_t kCode[] = {
       WASM_IF_ELSE(WASM_LOCAL_GET(0), WASM_LOCAL_GET(0), WASM_LOCAL_GET(0))};
   for (size_t len = 3; len < arraysize(kCode); len++) {
     ExpectFailure(sigs.i_i(), base::VectorOf(kCode, len), kAppendEnd);
@@ -1219,7 +1223,7 @@ TEST_F(FunctionBodyDecoderTest, If_off_end) {
 
 TEST_F(FunctionBodyDecoderTest, If_type1) {
   // float|double ? 1 : 2
-  static const byte kCode[] = {
+  static const uint8_t kCode[] = {
       WASM_IF_ELSE_I(WASM_LOCAL_GET(0), WASM_I32V_1(0), WASM_I32V_1(2))};
   ExpectValidates(sigs.i_i(), kCode);
   ExpectFailure(sigs.i_f(), kCode);
@@ -1228,7 +1232,7 @@ TEST_F(FunctionBodyDecoderTest, If_type1) {
 
 TEST_F(FunctionBodyDecoderTest, If_type2) {
   // 1 ? float|double : 2
-  static const byte kCode[] = {
+  static const uint8_t kCode[] = {
       WASM_IF_ELSE_I(WASM_I32V_1(1), WASM_LOCAL_GET(0), WASM_I32V_1(1))};
   ExpectValidates(sigs.i_i(), kCode);
   ExpectFailure(sigs.i_f(), kCode);
@@ -1237,7 +1241,7 @@ TEST_F(FunctionBodyDecoderTest, If_type2) {
 
 TEST_F(FunctionBodyDecoderTest, If_type3) {
   // stmt ? 0 : 1
-  static const byte kCode[] = {
+  static const uint8_t kCode[] = {
       WASM_IF_ELSE_I(WASM_NOP, WASM_I32V_1(0), WASM_I32V_1(1))};
   ExpectFailure(sigs.i_i(), kCode);
   ExpectFailure(sigs.i_f(), kCode);
@@ -1246,7 +1250,7 @@ TEST_F(FunctionBodyDecoderTest, If_type3) {
 
 TEST_F(FunctionBodyDecoderTest, If_type4) {
   // 0 ? stmt : 1
-  static const byte kCode[] = {
+  static const uint8_t kCode[] = {
       WASM_IF_ELSE_I(WASM_LOCAL_GET(0), WASM_NOP, WASM_I32V_1(1))};
   ExpectFailure(sigs.i_i(), kCode);
   ExpectFailure(sigs.i_f(), kCode);
@@ -1255,7 +1259,7 @@ TEST_F(FunctionBodyDecoderTest, If_type4) {
 
 TEST_F(FunctionBodyDecoderTest, If_type5) {
   // 0 ? 1 : stmt
-  static const byte kCode[] = {
+  static const uint8_t kCode[] = {
       WASM_IF_ELSE_I(WASM_ZERO, WASM_I32V_1(1), WASM_NOP)};
   ExpectFailure(sigs.i_i(), kCode);
   ExpectFailure(sigs.i_f(), kCode);
@@ -1267,9 +1271,9 @@ TEST_F(FunctionBodyDecoderTest, Int64Local_param) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Int64Locals) {
-  for (byte i = 1; i < 8; i++) {
+  for (uint8_t i = 1; i < 8; i++) {
     AddLocals(kWasmI64, 1);
-    for (byte j = 0; j < i; j++) {
+    for (uint8_t j = 0; j < i; j++) {
       ExpectValidates(sigs.l_v(), {WASM_LOCAL_GET(j)});
     }
   }
@@ -1522,7 +1526,7 @@ TEST_F(FunctionBodyDecoderTest, AllSimpleExpressions) {
 
 TEST_F(FunctionBodyDecoderTest, MemorySize) {
   builder.InitializeMemory();
-  byte code[] = {kExprMemorySize, 0};
+  uint8_t code[] = {kExprMemorySize, 0};
   ExpectValidates(sigs.i_i(), code);
   ExpectFailure(sigs.f_ff(), code);
 }
@@ -1530,8 +1534,8 @@ TEST_F(FunctionBodyDecoderTest, MemorySize) {
 TEST_F(FunctionBodyDecoderTest, LoadMemOffset) {
   builder.InitializeMemory();
   for (int offset = 0; offset < 128; offset += 7) {
-    byte code[] = {kExprI32Const, 0, kExprI32LoadMem, ZERO_ALIGNMENT,
-                   static_cast<byte>(offset)};
+    uint8_t code[] = {kExprI32Const, 0, kExprI32LoadMem, ZERO_ALIGNMENT,
+                      static_cast<uint8_t>(offset)};
     ExpectValidates(sigs.i_i(), code);
   }
 }
@@ -1559,9 +1563,9 @@ TEST_F(FunctionBodyDecoderTest, LoadMemAlignment) {
   };
 
   for (size_t i = 0; i < arraysize(values); i++) {
-    for (byte alignment = 0; alignment <= 4; alignment++) {
-      byte code[] = {WASM_ZERO, static_cast<byte>(values[i].instruction),
-                     alignment, ZERO_OFFSET, WASM_DROP};
+    for (uint8_t alignment = 0; alignment <= 4; alignment++) {
+      uint8_t code[] = {WASM_ZERO, static_cast<uint8_t>(values[i].instruction),
+                        alignment, ZERO_OFFSET, WASM_DROP};
       Validate(alignment <= values[i].maximum_aligment, sigs.v_i(), code);
     }
   }
@@ -1569,9 +1573,9 @@ TEST_F(FunctionBodyDecoderTest, LoadMemAlignment) {
 
 TEST_F(FunctionBodyDecoderTest, StoreMemOffset) {
   builder.InitializeMemory();
-  for (byte offset = 0; offset < 128; offset += 7) {
-    byte code[] = {WASM_STORE_MEM_OFFSET(MachineType::Int32(), offset,
-                                         WASM_ZERO, WASM_ZERO)};
+  for (uint8_t offset = 0; offset < 128; offset += 7) {
+    uint8_t code[] = {WASM_STORE_MEM_OFFSET(MachineType::Int32(), offset,
+                                            WASM_ZERO, WASM_ZERO)};
     ExpectValidates(sigs.v_i(), code);
   }
 }
@@ -1612,7 +1616,7 @@ TEST_F(FunctionBodyDecoderTest, AllLoadMemCombinations) {
     ValueType local_type = kValueTypes[i];
     for (size_t j = 0; j < arraysize(machineTypes); j++) {
       MachineType mem_type = machineTypes[j];
-      byte code[] = {WASM_LOAD_MEM(mem_type, WASM_ZERO)};
+      uint8_t code[] = {WASM_LOAD_MEM(mem_type, WASM_ZERO)};
       FunctionSig sig(1, 0, &local_type);
       Validate(local_type == ValueType::For(mem_type), &sig, code);
     }
@@ -1625,7 +1629,7 @@ TEST_F(FunctionBodyDecoderTest, AllStoreMemCombinations) {
     ValueType local_type = kValueTypes[i];
     for (size_t j = 0; j < arraysize(machineTypes); j++) {
       MachineType mem_type = machineTypes[j];
-      byte code[] = {WASM_STORE_MEM(mem_type, WASM_ZERO, WASM_LOCAL_GET(0))};
+      uint8_t code[] = {WASM_STORE_MEM(mem_type, WASM_ZERO, WASM_LOCAL_GET(0))};
       FunctionSig sig(0, 1, &local_type);
       Validate(local_type == ValueType::For(mem_type), &sig, code);
     }
@@ -1745,9 +1749,9 @@ TEST_F(FunctionBodyDecoderTest, SimpleIndirectReturnCalls) {
   const FunctionSig* sig = sigs.i_i();
   builder.AddTable(kWasmFuncRef, 20, true, 30);
 
-  byte sig0 = builder.AddSignature(sigs.i_v());
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig0 = builder.AddSignature(sigs.i_v());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
 
   ExpectValidates(sig, {WASM_RETURN_CALL_INDIRECT(sig0, WASM_ZERO)});
   ExpectValidates(
@@ -1782,7 +1786,7 @@ TEST_F(FunctionBodyDecoderTest, IndirectReturnCallsWithMismatchedSigs3) {
   const FunctionSig* sig = sigs.i_i();
   builder.InitializeTable(wasm::kWasmVoid);
 
-  byte sig0 = builder.AddSignature(sigs.i_f());
+  uint8_t sig0 = builder.AddSignature(sigs.i_f());
 
   ExpectFailure(sig,
                 {WASM_RETURN_CALL_INDIRECT(sig0, WASM_I32V_1(17), WASM_ZERO)});
@@ -1795,7 +1799,7 @@ TEST_F(FunctionBodyDecoderTest, IndirectReturnCallsWithMismatchedSigs3) {
   ExpectFailure(sig, {WASM_RETURN_CALL_INDIRECT(sig0, WASM_I64V_1(27))});
   ExpectFailure(sig, {WASM_RETURN_CALL_INDIRECT(sig0, WASM_F64(37.2))});
 
-  byte sig1 = builder.AddFunction(sigs.i_d());
+  uint8_t sig1 = builder.AddFunction(sigs.i_d());
 
   ExpectFailure(sig,
                 {WASM_RETURN_CALL_INDIRECT(sig1, WASM_I32V_1(16), WASM_ZERO)});
@@ -1810,9 +1814,9 @@ TEST_F(FunctionBodyDecoderTest, IndirectReturnCallsWithoutTableCrash) {
 
   const FunctionSig* sig = sigs.i_i();
 
-  byte sig0 = builder.AddSignature(sigs.i_v());
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig0 = builder.AddSignature(sigs.i_v());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
 
   ExpectFailure(sig, {WASM_RETURN_CALL_INDIRECT(sig0, WASM_ZERO)});
   ExpectFailure(sig,
@@ -1825,7 +1829,7 @@ TEST_F(FunctionBodyDecoderTest, IncompleteIndirectReturnCall) {
   const FunctionSig* sig = sigs.i_i();
   builder.InitializeTable(wasm::kWasmVoid);
 
-  static byte code[] = {kExprReturnCallIndirect};
+  static uint8_t code[] = {kExprReturnCallIndirect};
   ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
@@ -1874,9 +1878,9 @@ TEST_F(FunctionBodyDecoderTest, SimpleIndirectCalls) {
   const FunctionSig* sig = sigs.i_i();
   builder.AddTable(kWasmFuncRef, 20, false, 20);
 
-  byte sig0 = builder.AddSignature(sigs.i_v());
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig0 = builder.AddSignature(sigs.i_v());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
 
   ExpectValidates(sig, {WASM_CALL_INDIRECT(sig0, WASM_ZERO)});
   ExpectValidates(sig, {WASM_CALL_INDIRECT(sig1, WASM_I32V_1(22), WASM_ZERO)});
@@ -1903,7 +1907,7 @@ TEST_F(FunctionBodyDecoderTest, IndirectCallsWithMismatchedSigs1) {
   const FunctionSig* sig = sigs.i_i();
   builder.InitializeTable(wasm::kWasmVoid);
 
-  byte sig0 = builder.AddSignature(sigs.i_f());
+  uint8_t sig0 = builder.AddSignature(sigs.i_f());
 
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig0, WASM_I32V_1(17), WASM_ZERO)});
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig0, WASM_I64V_1(27), WASM_ZERO)});
@@ -1913,7 +1917,7 @@ TEST_F(FunctionBodyDecoderTest, IndirectCallsWithMismatchedSigs1) {
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig0, WASM_I64V_1(27))});
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig0, WASM_F64(37.2))});
 
-  byte sig1 = builder.AddFunction(sigs.i_d());
+  uint8_t sig1 = builder.AddFunction(sigs.i_d());
 
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig1, WASM_I32V_1(16), WASM_ZERO)});
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig1, WASM_I64V_1(16), WASM_ZERO)});
@@ -1922,15 +1926,15 @@ TEST_F(FunctionBodyDecoderTest, IndirectCallsWithMismatchedSigs1) {
 
 TEST_F(FunctionBodyDecoderTest, IndirectCallsWithMismatchedSigs2) {
   WASM_FEATURE_SCOPE(typed_funcref);
-  byte table_type_index = builder.AddSignature(sigs.i_i());
-  byte table_index =
+  uint8_t table_type_index = builder.AddSignature(sigs.i_i());
+  uint8_t table_index =
       builder.InitializeTable(ValueType::RefNull(table_type_index));
 
   ExpectValidates(sigs.i_v(),
                   {WASM_CALL_INDIRECT_TABLE(table_index, table_type_index,
                                             WASM_I32V_1(42), WASM_ZERO)});
 
-  byte wrong_type_index = builder.AddSignature(sigs.i_ii());
+  uint8_t wrong_type_index = builder.AddSignature(sigs.i_ii());
   ExpectFailure(sigs.i_v(),
                 {WASM_CALL_INDIRECT_TABLE(table_index, wrong_type_index,
                                           WASM_I32V_1(42), WASM_ZERO)},
@@ -1938,7 +1942,7 @@ TEST_F(FunctionBodyDecoderTest, IndirectCallsWithMismatchedSigs2) {
                 "call_indirect: Immediate signature #1 is not a subtype of "
                 "immediate table #0");
 
-  byte non_function_table_index = builder.InitializeTable(kWasmExternRef);
+  uint8_t non_function_table_index = builder.InitializeTable(kWasmExternRef);
   ExpectFailure(
       sigs.i_v(),
       {WASM_CALL_INDIRECT_TABLE(non_function_table_index, table_type_index,
@@ -1952,26 +1956,26 @@ TEST_F(FunctionBodyDecoderTest, TablesWithFunctionSubtyping) {
   WASM_FEATURE_SCOPE(gc);
   EXPERIMENTAL_FLAG_SCOPE(gc);
 
-  byte empty_struct = builder.AddStruct({});
-  byte super_struct = builder.AddStruct({F(kWasmI32, true)}, empty_struct);
-  byte sub_struct =
+  uint8_t empty_struct = builder.AddStruct({});
+  uint8_t super_struct = builder.AddStruct({F(kWasmI32, true)}, empty_struct);
+  uint8_t sub_struct =
       builder.AddStruct({F(kWasmI32, true), F(kWasmF64, true)}, super_struct);
 
-  byte table_supertype = builder.AddSignature(
+  uint8_t table_supertype = builder.AddSignature(
       FunctionSig::Build(zone(), {ValueType::RefNull(empty_struct)},
                          {ValueType::RefNull(sub_struct)}));
-  byte table_type = builder.AddSignature(
+  uint8_t table_type = builder.AddSignature(
       FunctionSig::Build(zone(), {ValueType::RefNull(super_struct)},
                          {ValueType::RefNull(sub_struct)}),
       table_supertype);
   auto function_sig =
       FunctionSig::Build(zone(), {ValueType::RefNull(sub_struct)},
                          {ValueType::RefNull(super_struct)});
-  byte function_type = builder.AddSignature(function_sig, table_type);
+  uint8_t function_type = builder.AddSignature(function_sig, table_type);
 
-  byte function = builder.AddFunction(function_type);
+  uint8_t function = builder.AddFunction(function_type);
 
-  byte table = builder.InitializeTable(ValueType::RefNull(table_type));
+  uint8_t table = builder.InitializeTable(ValueType::RefNull(table_type));
 
   // We can call-indirect from a typed function table with an immediate type
   // that is a subtype of the table type.
@@ -1994,9 +1998,9 @@ TEST_F(FunctionBodyDecoderTest, TablesWithFunctionSubtyping) {
 TEST_F(FunctionBodyDecoderTest, IndirectCallsWithoutTableCrash) {
   const FunctionSig* sig = sigs.i_i();
 
-  byte sig0 = builder.AddSignature(sigs.i_v());
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig0 = builder.AddSignature(sigs.i_v());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
 
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig0, WASM_ZERO)});
   ExpectFailure(sig, {WASM_CALL_INDIRECT(sig1, WASM_I32V_1(22), WASM_ZERO)});
@@ -2008,7 +2012,7 @@ TEST_F(FunctionBodyDecoderTest, IncompleteIndirectCall) {
   const FunctionSig* sig = sigs.i_i();
   builder.InitializeTable(wasm::kWasmVoid);
 
-  static byte code[] = {kExprCallIndirect};
+  static uint8_t code[] = {kExprCallIndirect};
   ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
@@ -2017,7 +2021,7 @@ TEST_F(FunctionBodyDecoderTest, IncompleteStore) {
   builder.InitializeMemory();
   builder.InitializeTable(wasm::kWasmVoid);
 
-  static byte code[] = {kExprI32StoreMem};
+  static uint8_t code[] = {kExprI32StoreMem};
   ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
@@ -2027,17 +2031,17 @@ TEST_F(FunctionBodyDecoderTest, IncompleteI8x16Shuffle) {
   builder.InitializeMemory();
   builder.InitializeTable(wasm::kWasmVoid);
 
-  static byte code[] = {kSimdPrefix,
-                        static_cast<byte>(kExprI8x16Shuffle & 0xff)};
+  static uint8_t code[] = {kSimdPrefix,
+                           static_cast<uint8_t>(kExprI8x16Shuffle & 0xff)};
   ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
 TEST_F(FunctionBodyDecoderTest, SimpleImportCalls) {
   const FunctionSig* sig = sigs.i_i();
 
-  byte f0 = builder.AddImport(sigs.i_v());
-  byte f1 = builder.AddImport(sigs.i_i());
-  byte f2 = builder.AddImport(sigs.i_ii());
+  uint8_t f0 = builder.AddImport(sigs.i_v());
+  uint8_t f1 = builder.AddImport(sigs.i_i());
+  uint8_t f2 = builder.AddImport(sigs.i_ii());
 
   ExpectValidates(sig, {WASM_CALL_FUNCTION0(f0)});
   ExpectValidates(sig, {WASM_CALL_FUNCTION(f1, WASM_I32V_1(22))});
@@ -2048,14 +2052,14 @@ TEST_F(FunctionBodyDecoderTest, SimpleImportCalls) {
 TEST_F(FunctionBodyDecoderTest, ImportCallsWithMismatchedSigs3) {
   const FunctionSig* sig = sigs.i_i();
 
-  byte f0 = builder.AddImport(sigs.i_f());
+  uint8_t f0 = builder.AddImport(sigs.i_f());
 
   ExpectFailure(sig, {WASM_CALL_FUNCTION0(f0)});
   ExpectFailure(sig, {WASM_CALL_FUNCTION(f0, WASM_I32V_1(17))});
   ExpectFailure(sig, {WASM_CALL_FUNCTION(f0, WASM_I64V_1(27))});
   ExpectFailure(sig, {WASM_CALL_FUNCTION(f0, WASM_F64(37.2))});
 
-  byte f1 = builder.AddImport(sigs.i_d());
+  uint8_t f1 = builder.AddImport(sigs.i_d());
 
   ExpectFailure(sig, {WASM_CALL_FUNCTION0(f1)});
   ExpectFailure(sig, {WASM_CALL_FUNCTION(f1, WASM_I32V_1(16))});
@@ -2208,21 +2212,21 @@ TEST_F(FunctionBodyDecoderTest, AllSetGlobalCombinations) {
 TEST_F(FunctionBodyDecoderTest, TableSet) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  byte tab_type = builder.AddSignature(sigs.i_i());
-  byte tab_ref1 = builder.AddTable(kWasmExternRef, 10, true, 20);
-  byte tab_func1 = builder.AddTable(kWasmFuncRef, 20, true, 30);
-  byte tab_func2 = builder.AddTable(kWasmFuncRef, 10, false, 20);
-  byte tab_ref2 = builder.AddTable(kWasmExternRef, 10, false, 20);
-  byte tab_typed_func =
+  uint8_t tab_type = builder.AddSignature(sigs.i_i());
+  uint8_t tab_ref1 = builder.AddTable(kWasmExternRef, 10, true, 20);
+  uint8_t tab_func1 = builder.AddTable(kWasmFuncRef, 20, true, 30);
+  uint8_t tab_func2 = builder.AddTable(kWasmFuncRef, 10, false, 20);
+  uint8_t tab_ref2 = builder.AddTable(kWasmExternRef, 10, false, 20);
+  uint8_t tab_typed_func =
       builder.AddTable(ValueType::RefNull(tab_type), 10, false, 20);
 
   ValueType sig_types[]{kWasmExternRef, kWasmFuncRef, kWasmI32,
                         ValueType::Ref(tab_type)};
   FunctionSig sig(0, 4, sig_types);
-  byte local_ref = 0;
-  byte local_func = 1;
-  byte local_int = 2;
-  byte local_typed_func = 3;
+  uint8_t local_ref = 0;
+  uint8_t local_func = 1;
+  uint8_t local_int = 2;
+  uint8_t local_typed_func = 3;
 
   ExpectValidates(&sig, {WASM_TABLE_SET(tab_ref1, WASM_I32V(6),
                                         WASM_LOCAL_GET(local_ref))});
@@ -2254,7 +2258,7 @@ TEST_F(FunctionBodyDecoderTest, TableSet) {
                                       WASM_LOCAL_GET(local_func))});
 
   // Out-of-bounds table index should fail.
-  byte oob_tab = 37;
+  uint8_t oob_tab = 37;
   ExpectFailure(
       &sig, {WASM_TABLE_SET(oob_tab, WASM_I32V(9), WASM_LOCAL_GET(local_ref))});
   ExpectFailure(&sig, {WASM_TABLE_SET(oob_tab, WASM_I32V(3),
@@ -2264,21 +2268,21 @@ TEST_F(FunctionBodyDecoderTest, TableSet) {
 TEST_F(FunctionBodyDecoderTest, TableGet) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  byte tab_type = builder.AddSignature(sigs.i_i());
-  byte tab_ref1 = builder.AddTable(kWasmExternRef, 10, true, 20);
-  byte tab_func1 = builder.AddTable(kWasmFuncRef, 20, true, 30);
-  byte tab_func2 = builder.AddTable(kWasmFuncRef, 10, false, 20);
-  byte tab_ref2 = builder.AddTable(kWasmExternRef, 10, false, 20);
-  byte tab_typed_func =
+  uint8_t tab_type = builder.AddSignature(sigs.i_i());
+  uint8_t tab_ref1 = builder.AddTable(kWasmExternRef, 10, true, 20);
+  uint8_t tab_func1 = builder.AddTable(kWasmFuncRef, 20, true, 30);
+  uint8_t tab_func2 = builder.AddTable(kWasmFuncRef, 10, false, 20);
+  uint8_t tab_ref2 = builder.AddTable(kWasmExternRef, 10, false, 20);
+  uint8_t tab_typed_func =
       builder.AddTable(ValueType::RefNull(tab_type), 10, false, 20);
 
   ValueType sig_types[]{kWasmExternRef, kWasmFuncRef, kWasmI32,
                         ValueType::RefNull(tab_type)};
   FunctionSig sig(0, 4, sig_types);
-  byte local_ref = 0;
-  byte local_func = 1;
-  byte local_int = 2;
-  byte local_typed_func = 3;
+  uint8_t local_ref = 0;
+  uint8_t local_func = 1;
+  uint8_t local_int = 2;
+  uint8_t local_typed_func = 3;
 
   ExpectValidates(
       &sig,
@@ -2321,7 +2325,7 @@ TEST_F(FunctionBodyDecoderTest, TableGet) {
                                 WASM_TABLE_GET(tab_func1, WASM_I32V(3)))});
 
   // Out-of-bounds table index should fail.
-  byte oob_tab = 37;
+  uint8_t oob_tab = 37;
   ExpectFailure(
       &sig, {WASM_LOCAL_SET(local_ref, WASM_TABLE_GET(oob_tab, WASM_I32V(9)))});
   ExpectFailure(&sig, {WASM_LOCAL_SET(local_func,
@@ -2329,12 +2333,12 @@ TEST_F(FunctionBodyDecoderTest, TableGet) {
 }
 
 TEST_F(FunctionBodyDecoderTest, MultiTableCallIndirect) {
-  byte tab_ref = builder.AddTable(kWasmExternRef, 10, true, 20);
-  byte tab_func = builder.AddTable(kWasmFuncRef, 20, true, 30);
+  uint8_t tab_ref = builder.AddTable(kWasmExternRef, 10, true, 20);
+  uint8_t tab_func = builder.AddTable(kWasmFuncRef, 20, true, 30);
 
   ValueType sig_types[]{kWasmExternRef, kWasmFuncRef, kWasmI32};
   FunctionSig sig(0, 3, sig_types);
-  byte sig_index = builder.AddSignature(sigs.i_v());
+  uint8_t sig_index = builder.AddSignature(sigs.i_v());
 
   // We can store funcref values as externref, but not the other way around.
   ExpectValidates(sigs.i_v(),
@@ -2347,7 +2351,7 @@ TEST_F(FunctionBodyDecoderTest, MultiTableCallIndirect) {
 TEST_F(FunctionBodyDecoderTest, WasmMemoryGrow) {
   builder.InitializeMemory();
 
-  byte code[] = {WASM_LOCAL_GET(0), kExprMemoryGrow, 0};
+  uint8_t code[] = {WASM_LOCAL_GET(0), kExprMemoryGrow, 0};
   ExpectValidates(sigs.i_i(), code);
   ExpectFailure(sigs.i_d(), code);
 }
@@ -2393,7 +2397,7 @@ TEST_F(FunctionBodyDecoderTest, BreakIfUnrNarrow) {
 TEST_F(FunctionBodyDecoderTest, BreakNesting1) {
   for (int i = 0; i < 5; i++) {
     // (block[2] (loop[2] (if (get p) break[N]) (set p 1)) p)
-    byte code[] = {WASM_BLOCK_I(
+    uint8_t code[] = {WASM_BLOCK_I(
         WASM_LOOP(WASM_IF(WASM_LOCAL_GET(0), WASM_BRV(i + 1, WASM_ZERO)),
                   WASM_LOCAL_SET(0, WASM_I32V_1(1))),
         WASM_ZERO)};
@@ -2403,7 +2407,7 @@ TEST_F(FunctionBodyDecoderTest, BreakNesting1) {
 
 TEST_F(FunctionBodyDecoderTest, BreakNesting2) {
   for (int i = 0; i < 7; i++) {
-    byte code[] = {B1(WASM_LOOP(WASM_IF(WASM_ZERO, WASM_BR(i)), WASM_NOP))};
+    uint8_t code[] = {B1(WASM_LOOP(WASM_IF(WASM_ZERO, WASM_BR(i)), WASM_NOP))};
     Validate(i <= 3, sigs.v_v(), code);
   }
 }
@@ -2411,7 +2415,7 @@ TEST_F(FunctionBodyDecoderTest, BreakNesting2) {
 TEST_F(FunctionBodyDecoderTest, BreakNesting3) {
   for (int i = 0; i < 7; i++) {
     // (block[1] (loop[1] (block[1] (if 0 break[N])
-    byte code[] = {
+    uint8_t code[] = {
         WASM_BLOCK(WASM_LOOP(B1(WASM_IF(WASM_ZERO, WASM_BR(i + 1)))))};
     Validate(i < 4, sigs.v_v(), code);
   }
@@ -2434,7 +2438,7 @@ TEST_F(FunctionBodyDecoderTest, BreaksWithMultipleTypes) {
 TEST_F(FunctionBodyDecoderTest, BreakNesting_6_levels) {
   for (int mask = 0; mask < 64; mask++) {
     for (int i = 0; i < 14; i++) {
-      byte code[] = {WASM_BLOCK(WASM_BLOCK(
+      uint8_t code[] = {WASM_BLOCK(WASM_BLOCK(
           WASM_BLOCK(WASM_BLOCK(WASM_BLOCK(WASM_BLOCK(WASM_BR(i)))))))};
 
       int depth = 6;
@@ -2457,7 +2461,7 @@ TEST_F(FunctionBodyDecoderTest, Break_TypeCheck) {
   for (const FunctionSig* sig :
        {sigs.i_i(), sigs.l_l(), sigs.f_ff(), sigs.d_dd()}) {
     // unify X and X => OK
-    byte code[] = {WASM_BLOCK_T(
+    uint8_t code[] = {WASM_BLOCK_T(
         sig->GetReturn(), WASM_IF(WASM_ZERO, WASM_BRV(0, WASM_LOCAL_GET(0))),
         WASM_LOCAL_GET(0))};
     ExpectValidates(sig, code);
@@ -2480,7 +2484,7 @@ TEST_F(FunctionBodyDecoderTest, Break_TypeCheckAll1) {
     for (size_t j = 0; j < arraysize(kValueTypes); j++) {
       ValueType storage[] = {kValueTypes[i], kValueTypes[i], kValueTypes[j]};
       FunctionSig sig(1, 2, storage);
-      byte code[] = {WASM_BLOCK_T(
+      uint8_t code[] = {WASM_BLOCK_T(
           sig.GetReturn(), WASM_IF(WASM_ZERO, WASM_BRV(0, WASM_LOCAL_GET(0))),
           WASM_LOCAL_GET(1))};
 
@@ -2494,9 +2498,9 @@ TEST_F(FunctionBodyDecoderTest, Break_TypeCheckAll2) {
     for (size_t j = 0; j < arraysize(kValueTypes); j++) {
       ValueType storage[] = {kValueTypes[i], kValueTypes[i], kValueTypes[j]};
       FunctionSig sig(1, 2, storage);
-      byte code[] = {WASM_IF_ELSE_T(sig.GetReturn(0), WASM_ZERO,
-                                    WASM_BRV_IF_ZERO(0, WASM_LOCAL_GET(0)),
-                                    WASM_LOCAL_GET(1))};
+      uint8_t code[] = {WASM_IF_ELSE_T(sig.GetReturn(0), WASM_ZERO,
+                                       WASM_BRV_IF_ZERO(0, WASM_LOCAL_GET(0)),
+                                       WASM_LOCAL_GET(1))};
 
       Validate(IsSubtypeOf(kValueTypes[j], kValueTypes[i], module), &sig, code);
     }
@@ -2508,9 +2512,9 @@ TEST_F(FunctionBodyDecoderTest, Break_TypeCheckAll3) {
     for (size_t j = 0; j < arraysize(kValueTypes); j++) {
       ValueType storage[] = {kValueTypes[i], kValueTypes[i], kValueTypes[j]};
       FunctionSig sig(1, 2, storage);
-      byte code[] = {WASM_IF_ELSE_T(sig.GetReturn(), WASM_ZERO,
-                                    WASM_LOCAL_GET(1),
-                                    WASM_BRV_IF_ZERO(0, WASM_LOCAL_GET(0)))};
+      uint8_t code[] = {WASM_IF_ELSE_T(sig.GetReturn(), WASM_ZERO,
+                                       WASM_LOCAL_GET(1),
+                                       WASM_BRV_IF_ZERO(0, WASM_LOCAL_GET(0)))};
 
       Validate(IsSubtypeOf(kValueTypes[j], kValueTypes[i], module), &sig, code);
     }
@@ -2524,7 +2528,7 @@ TEST_F(FunctionBodyDecoderTest, Break_Unify) {
       ValueType storage[] = {kWasmI32, kWasmI32, type};
       FunctionSig sig(1, 2, storage);
 
-      byte code1[] = {WASM_BLOCK_T(
+      uint8_t code1[] = {WASM_BLOCK_T(
           type, WASM_IF(WASM_ZERO, WASM_BRV(1, WASM_LOCAL_GET(which))),
           WASM_LOCAL_GET(which ^ 1))};
 
@@ -2538,7 +2542,7 @@ TEST_F(FunctionBodyDecoderTest, BreakIf_cond_type) {
     for (size_t j = 0; j < arraysize(kValueTypes); j++) {
       ValueType types[] = {kValueTypes[i], kValueTypes[i], kValueTypes[j]};
       FunctionSig sig(1, 2, types);
-      byte code[] = {WASM_BLOCK_T(
+      uint8_t code[] = {WASM_BLOCK_T(
           types[0], WASM_BRV_IF(0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)))};
 
       Validate(types[2] == kWasmI32, &sig, code);
@@ -2552,7 +2556,7 @@ TEST_F(FunctionBodyDecoderTest, BreakIf_val_type) {
       ValueType types[] = {kValueTypes[i], kValueTypes[i], kValueTypes[j],
                            kWasmI32};
       FunctionSig sig(1, 3, types);
-      byte code[] = {WASM_BLOCK_T(
+      uint8_t code[] = {WASM_BLOCK_T(
           types[1], WASM_BRV_IF(0, WASM_LOCAL_GET(1), WASM_LOCAL_GET(2)),
           WASM_DROP, WASM_LOCAL_GET(0))};
 
@@ -2567,8 +2571,8 @@ TEST_F(FunctionBodyDecoderTest, BreakIf_Unify) {
       ValueType type = kValueTypes[i];
       ValueType storage[] = {kWasmI32, kWasmI32, type};
       FunctionSig sig(1, 2, storage);
-      byte code[] = {WASM_BLOCK_I(WASM_BRV_IF_ZERO(0, WASM_LOCAL_GET(which)),
-                                  WASM_DROP, WASM_LOCAL_GET(which ^ 1))};
+      uint8_t code[] = {WASM_BLOCK_I(WASM_BRV_IF_ZERO(0, WASM_LOCAL_GET(which)),
+                                     WASM_DROP, WASM_LOCAL_GET(which ^ 1))};
 
       Validate(type == kWasmI32, &sig, code);
     }
@@ -2580,13 +2584,13 @@ TEST_F(FunctionBodyDecoderTest, BrTable0) {
 }
 
 TEST_F(FunctionBodyDecoderTest, BrTable0b) {
-  static byte code[] = {kExprI32Const, 11, kExprBrTable, 0, BR_TARGET(0)};
+  static uint8_t code[] = {kExprI32Const, 11, kExprBrTable, 0, BR_TARGET(0)};
   ExpectValidates(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
 
 TEST_F(FunctionBodyDecoderTest, BrTable0c) {
-  static byte code[] = {kExprI32Const, 11, kExprBrTable, 0, BR_TARGET(1)};
+  static uint8_t code[] = {kExprI32Const, 11, kExprBrTable, 0, BR_TARGET(1)};
   ExpectFailure(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
 }
@@ -2597,7 +2601,7 @@ TEST_F(FunctionBodyDecoderTest, BrTable1a) {
 }
 
 TEST_F(FunctionBodyDecoderTest, BrTable1b) {
-  static byte code[] = {B1(WASM_BR_TABLE(WASM_ZERO, 0, BR_TARGET(0)))};
+  static uint8_t code[] = {B1(WASM_BR_TABLE(WASM_ZERO, 0, BR_TARGET(0)))};
   ExpectValidates(sigs.v_v(), code);
   ExpectFailure(sigs.i_i(), code);
   ExpectFailure(sigs.f_ff(), code);
@@ -2620,10 +2624,10 @@ TEST_F(FunctionBodyDecoderTest, BrTableSubtyping) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte supertype1 = builder.AddStruct({F(kWasmI8, true)});
-  byte supertype2 =
+  uint8_t supertype1 = builder.AddStruct({F(kWasmI8, true)});
+  uint8_t supertype2 =
       builder.AddStruct({F(kWasmI8, true), F(kWasmI16, false)}, supertype1);
-  byte subtype = builder.AddStruct(
+  uint8_t subtype = builder.AddStruct(
       {F(kWasmI8, true), F(kWasmI16, false), F(kWasmI32, true)}, supertype2);
   ExpectValidates(
       sigs.v_v(),
@@ -2638,7 +2642,8 @@ TEST_F(FunctionBodyDecoderTest, BrTableSubtyping) {
 }
 
 TEST_F(FunctionBodyDecoderTest, BrTable_off_end) {
-  static byte code[] = {B1(WASM_BR_TABLE(WASM_LOCAL_GET(0), 0, BR_TARGET(0)))};
+  static uint8_t code[] = {
+      B1(WASM_BR_TABLE(WASM_LOCAL_GET(0), 0, BR_TARGET(0)))};
   for (size_t len = 1; len < sizeof(code); len++) {
     ExpectFailure(sigs.i_i(), base::VectorOf(code, len), kAppendEnd);
     ExpectFailure(sigs.i_i(), base::VectorOf(code, len), kOmitEnd);
@@ -2647,14 +2652,15 @@ TEST_F(FunctionBodyDecoderTest, BrTable_off_end) {
 
 TEST_F(FunctionBodyDecoderTest, BrTable_invalid_br1) {
   for (int depth = 0; depth < 4; depth++) {
-    byte code[] = {B1(WASM_BR_TABLE(WASM_LOCAL_GET(0), 0, BR_TARGET(depth)))};
+    uint8_t code[] = {
+        B1(WASM_BR_TABLE(WASM_LOCAL_GET(0), 0, BR_TARGET(depth)))};
     Validate(depth <= 1, sigs.v_i(), code);
   }
 }
 
 TEST_F(FunctionBodyDecoderTest, BrTable_invalid_br2) {
   for (int depth = 0; depth < 7; depth++) {
-    byte code[] = {
+    uint8_t code[] = {
         WASM_LOOP(WASM_BR_TABLE(WASM_LOCAL_GET(0), 0, BR_TARGET(depth)))};
     Validate(depth < 2, sigs.v_i(), code);
   }
@@ -2866,9 +2872,9 @@ TEST_F(FunctionBodyDecoderTest, SelectWithType_fail) {
 }
 
 TEST_F(FunctionBodyDecoderTest, Throw) {
-  byte ex1 = builder.AddException(sigs.v_v());
-  byte ex2 = builder.AddException(sigs.v_i());
-  byte ex3 = builder.AddException(sigs.v_ii());
+  uint8_t ex1 = builder.AddException(sigs.v_v());
+  uint8_t ex2 = builder.AddException(sigs.v_i());
+  uint8_t ex3 = builder.AddException(sigs.v_ii());
   ExpectValidates(sigs.v_v(), {kExprThrow, ex1});
   ExpectValidates(sigs.v_v(), {WASM_I32V(0), kExprThrow, ex2});
   ExpectFailure(sigs.v_v(), {WASM_F32(0.0), kExprThrow, ex2});
@@ -2878,8 +2884,8 @@ TEST_F(FunctionBodyDecoderTest, Throw) {
 }
 
 TEST_F(FunctionBodyDecoderTest, ThrowUnreachable) {
-  byte ex1 = builder.AddException(sigs.v_v());
-  byte ex2 = builder.AddException(sigs.v_i());
+  uint8_t ex1 = builder.AddException(sigs.v_v());
+  uint8_t ex2 = builder.AddException(sigs.v_i());
   ExpectValidates(sigs.i_i(), {WASM_LOCAL_GET(0), kExprThrow, ex1, WASM_NOP});
   ExpectValidates(sigs.v_i(), {WASM_LOCAL_GET(0), kExprThrow, ex2, WASM_NOP});
   ExpectValidates(sigs.i_i(), {WASM_LOCAL_GET(0), kExprThrow, ex1, WASM_ZERO});
@@ -2893,7 +2899,7 @@ TEST_F(FunctionBodyDecoderTest, ThrowUnreachable) {
 #define WASM_TRY_OP kExprTry, kVoidCode
 
 TEST_F(FunctionBodyDecoderTest, TryCatch) {
-  byte ex = builder.AddException(sigs.v_v());
+  uint8_t ex = builder.AddException(sigs.v_v());
   ExpectValidates(sigs.v_v(), {WASM_TRY_OP, kExprCatch, ex, kExprEnd});
   ExpectValidates(sigs.v_v(),
                   {WASM_TRY_OP, kExprCatch, ex, kExprCatchAll, kExprEnd});
@@ -2921,7 +2927,7 @@ TEST_F(FunctionBodyDecoderTest, Rethrow) {
 }
 
 TEST_F(FunctionBodyDecoderTest, TryDelegate) {
-  byte ex = builder.AddException(sigs.v_v());
+  uint8_t ex = builder.AddException(sigs.v_v());
 
   ExpectValidates(sigs.v_v(), {WASM_TRY_OP,
                                WASM_TRY_DELEGATE(WASM_STMTS(kExprThrow, ex), 0),
@@ -2958,7 +2964,7 @@ TEST_F(FunctionBodyDecoderTest, TryDelegate) {
 #undef WASM_TRY_OP
 
 TEST_F(FunctionBodyDecoderTest, MultiValBlock1) {
-  byte sig0 = builder.AddSignature(sigs.ii_v());
+  uint8_t sig0 = builder.AddSignature(sigs.ii_v());
   ExpectValidates(
       sigs.i_ii(),
       {WASM_BLOCK_X(sig0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)), kExprI32Add});
@@ -2979,7 +2985,7 @@ TEST_F(FunctionBodyDecoderTest, MultiValBlock1) {
       {WASM_BLOCK_X(sig0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)), kExprF32Add},
       kAppendEnd, "f32.add[1] expected type f32, found block of type i32");
 
-  byte sig1 = builder.AddSignature(sigs.v_i());
+  uint8_t sig1 = builder.AddSignature(sigs.v_i());
   ExpectFailure(
       sigs.v_i(),
       {WASM_LOCAL_GET(0), WASM_BLOCK(WASM_BLOCK_X(sig1, WASM_UNREACHABLE))},
@@ -2988,7 +2994,7 @@ TEST_F(FunctionBodyDecoderTest, MultiValBlock1) {
 }
 
 TEST_F(FunctionBodyDecoderTest, MultiValBlock2) {
-  byte sig0 = builder.AddSignature(sigs.ii_v());
+  uint8_t sig0 = builder.AddSignature(sigs.ii_v());
   ExpectValidates(sigs.i_ii(),
                   {WASM_BLOCK_X(sig0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
                    WASM_I32_ADD(WASM_NOP, WASM_NOP)});
@@ -3006,7 +3012,7 @@ TEST_F(FunctionBodyDecoderTest, MultiValBlock2) {
 }
 
 TEST_F(FunctionBodyDecoderTest, MultiValBlockBr) {
-  byte sig0 = builder.AddSignature(sigs.ii_v());
+  uint8_t sig0 = builder.AddSignature(sigs.ii_v());
   ExpectFailure(sigs.i_ii(), {WASM_BLOCK_X(sig0, WASM_LOCAL_GET(0), WASM_BR(0)),
                               kExprI32Add});
   ExpectValidates(sigs.i_ii(), {WASM_BLOCK_X(sig0, WASM_LOCAL_GET(0),
@@ -3015,7 +3021,7 @@ TEST_F(FunctionBodyDecoderTest, MultiValBlockBr) {
 }
 
 TEST_F(FunctionBodyDecoderTest, MultiValLoop1) {
-  byte sig0 = builder.AddSignature(sigs.ii_v());
+  uint8_t sig0 = builder.AddSignature(sigs.ii_v());
   ExpectValidates(
       sigs.i_ii(),
       {WASM_LOOP_X(sig0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)), kExprI32Add});
@@ -3031,7 +3037,7 @@ TEST_F(FunctionBodyDecoderTest, MultiValLoop1) {
 }
 
 TEST_F(FunctionBodyDecoderTest, MultiValIf) {
-  byte sig0 = builder.AddSignature(sigs.ii_v());
+  uint8_t sig0 = builder.AddSignature(sigs.ii_v());
   ExpectValidates(
       sigs.i_ii(),
       {WASM_IF_ELSE_X(sig0, WASM_LOCAL_GET(0),
@@ -3090,8 +3096,8 @@ TEST_F(FunctionBodyDecoderTest, MultiValIf) {
 }
 
 TEST_F(FunctionBodyDecoderTest, BlockParam) {
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
   ExpectValidates(
       sigs.i_ii(),
       {WASM_LOCAL_GET(0), WASM_BLOCK_X(sig1, WASM_LOCAL_GET(1),
@@ -3116,8 +3122,8 @@ TEST_F(FunctionBodyDecoderTest, BlockParam) {
 }
 
 TEST_F(FunctionBodyDecoderTest, LoopParam) {
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
   ExpectValidates(sigs.i_ii(), {WASM_LOCAL_GET(0),
                                 WASM_LOOP_X(sig1, WASM_LOCAL_GET(1),
                                             WASM_I32_ADD(WASM_NOP, WASM_NOP))});
@@ -3141,8 +3147,8 @@ TEST_F(FunctionBodyDecoderTest, LoopParam) {
 }
 
 TEST_F(FunctionBodyDecoderTest, LoopParamBr) {
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
   ExpectValidates(sigs.i_ii(),
                   {WASM_LOCAL_GET(0), WASM_LOOP_X(sig1, WASM_BR(0))});
   ExpectValidates(
@@ -3162,8 +3168,8 @@ TEST_F(FunctionBodyDecoderTest, LoopParamBr) {
 }
 
 TEST_F(FunctionBodyDecoderTest, IfParam) {
-  byte sig1 = builder.AddSignature(sigs.i_i());
-  byte sig2 = builder.AddSignature(sigs.i_ii());
+  uint8_t sig1 = builder.AddSignature(sigs.i_i());
+  uint8_t sig2 = builder.AddSignature(sigs.i_ii());
   ExpectValidates(sigs.i_ii(),
                   {WASM_LOCAL_GET(0),
                    WASM_IF_X(sig1, WASM_LOCAL_GET(0),
@@ -3191,7 +3197,7 @@ TEST_F(FunctionBodyDecoderTest, IfParam) {
 TEST_F(FunctionBodyDecoderTest, Regression709741) {
   AddLocals(kWasmI32, kV8MaxWasmFunctionLocals - 1);
   ExpectValidates(sigs.v_v(), {WASM_NOP});
-  byte code[] = {WASM_NOP, WASM_END};
+  uint8_t code[] = {WASM_NOP, WASM_END};
 
   for (size_t i = 0; i < arraysize(code); ++i) {
     FunctionBody body(sigs.v_v(), 0, code, code + i);
@@ -3219,8 +3225,8 @@ TEST_F(FunctionBodyDecoderTest, MemoryInitInvalid) {
   builder.InitializeMemory();
   builder.SetDataSegmentCount(1);
 
-  byte code[] = {WASM_MEMORY_INIT(0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
-                 WASM_END};
+  uint8_t code[] = {WASM_MEMORY_INIT(0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
+                    WASM_END};
   for (size_t i = 0; i <= arraysize(code); ++i) {
     Validate(i == arraysize(code), sigs.v_v(), base::VectorOf(code, i),
              kOmitEnd);
@@ -3291,8 +3297,8 @@ TEST_F(FunctionBodyDecoderTest, TableInitInvalid) {
   builder.InitializeTable(wasm::kWasmFuncRef);
   builder.AddPassiveElementSegment(wasm::kWasmFuncRef);
 
-  byte code[] = {WASM_TABLE_INIT(0, 0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
-                 WASM_END};
+  uint8_t code[] = {WASM_TABLE_INIT(0, 0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
+                    WASM_END};
   for (size_t i = 0; i <= arraysize(code); ++i) {
     Validate(i == arraysize(code), sigs.v_v(), base::VectorOf(code, i),
              kOmitEnd);
@@ -3310,8 +3316,8 @@ TEST_F(FunctionBodyDecoderTest, ElemDrop) {
 TEST_F(FunctionBodyDecoderTest, TableInitDeclarativeElem) {
   builder.InitializeTable(wasm::kWasmFuncRef);
   builder.AddDeclarativeElementSegment();
-  byte code[] = {WASM_TABLE_INIT(0, 0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
-                 WASM_END};
+  uint8_t code[] = {WASM_TABLE_INIT(0, 0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
+                    WASM_END};
   for (size_t i = 0; i <= arraysize(code); ++i) {
     Validate(i == arraysize(code), sigs.v_v(), base::VectorOf(code, i),
              kOmitEnd);
@@ -3326,12 +3332,12 @@ TEST_F(FunctionBodyDecoderTest, DeclarativeElemDrop) {
 }
 
 TEST_F(FunctionBodyDecoderTest, RefFuncDeclared) {
-  byte function_index = builder.AddFunction(sigs.v_i());
+  uint8_t function_index = builder.AddFunction(sigs.v_i());
   ExpectValidates(sigs.c_v(), {WASM_REF_FUNC(function_index)});
 }
 
 TEST_F(FunctionBodyDecoderTest, RefFuncUndeclared) {
-  byte function_index = builder.AddFunction(sigs.v_i(), false);
+  uint8_t function_index = builder.AddFunction(sigs.v_i(), false);
   ExpectFailure(sigs.c_v(), {WASM_REF_FUNC(function_index)});
 }
 
@@ -3363,8 +3369,8 @@ TEST_F(FunctionBodyDecoderTest, TableCopyWrongType) {
 }
 
 TEST_F(FunctionBodyDecoderTest, TableGrow) {
-  byte tab_func = builder.AddTable(kWasmFuncRef, 10, true, 20);
-  byte tab_ref = builder.AddTable(kWasmExternRef, 10, true, 20);
+  uint8_t tab_func = builder.AddTable(kWasmFuncRef, 10, true, 20);
+  uint8_t tab_ref = builder.AddTable(kWasmExternRef, 10, true, 20);
 
   ExpectValidates(
       sigs.i_c(),
@@ -3391,8 +3397,8 @@ TEST_F(FunctionBodyDecoderTest, TableSize) {
 }
 
 TEST_F(FunctionBodyDecoderTest, TableFill) {
-  byte tab_func = builder.AddTable(kWasmFuncRef, 10, true, 20);
-  byte tab_ref = builder.AddTable(kWasmExternRef, 10, true, 20);
+  uint8_t tab_func = builder.AddTable(kWasmFuncRef, 10, true, 20);
+  uint8_t tab_ref = builder.AddTable(kWasmExternRef, 10, true, 20);
   ExpectValidates(sigs.v_c(),
                   {WASM_TABLE_FILL(tab_func, WASM_ONE,
                                    WASM_REF_NULL(kFuncRefCode), WASM_ONE)});
@@ -3510,7 +3516,8 @@ TEST_F(FunctionBodyDecoderTest, UnpackPackedTypes) {
   WASM_FEATURE_SCOPE(gc);
   {
     TestModuleBuilder builder;
-    byte type_index = builder.AddStruct({F(kWasmI8, true), F(kWasmI16, false)});
+    uint8_t type_index =
+        builder.AddStruct({F(kWasmI8, true), F(kWasmI16, false)});
     module = builder.module();
     ExpectValidates(sigs.v_v(),
                     {WASM_STRUCT_SET(type_index, 0,
@@ -3520,7 +3527,7 @@ TEST_F(FunctionBodyDecoderTest, UnpackPackedTypes) {
   }
   {
     TestModuleBuilder builder;
-    byte type_index = builder.AddArray(kWasmI8, true);
+    uint8_t type_index = builder.AddArray(kWasmI8, true);
     module = builder.module();
     ExpectValidates(
         sigs.v_v(),
@@ -3530,20 +3537,21 @@ TEST_F(FunctionBodyDecoderTest, UnpackPackedTypes) {
   }
 }
 
-ValueType ref(byte type_index) { return ValueType::Ref(type_index); }
-ValueType refNull(byte type_index) { return ValueType::RefNull(type_index); }
+ValueType ref(uint8_t type_index) { return ValueType::Ref(type_index); }
+ValueType refNull(uint8_t type_index) { return ValueType::RefNull(type_index); }
 
 TEST_F(FunctionBodyDecoderTest, StructOrArrayNewDefault) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
   TestModuleBuilder builder;
-  byte struct_index = builder.AddStruct({F(kWasmI32, true)});
-  byte struct_non_def_index = builder.AddStruct({F(ref(struct_index), true)});
-  byte struct_immutable_index = builder.AddStruct({F(kWasmI32, false)});
-  byte array_index = builder.AddArray(kWasmI32, true);
-  byte array_non_def_index = builder.AddArray(ref(array_index), true);
-  byte array_immutable_index = builder.AddArray(kWasmI32, false);
+  uint8_t struct_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t struct_non_def_index =
+      builder.AddStruct({F(ref(struct_index), true)});
+  uint8_t struct_immutable_index = builder.AddStruct({F(kWasmI32, false)});
+  uint8_t array_index = builder.AddArray(kWasmI32, true);
+  uint8_t array_non_def_index = builder.AddArray(ref(array_index), true);
+  uint8_t array_immutable_index = builder.AddArray(kWasmI32, false);
 
   module = builder.module();
 
@@ -3579,11 +3587,11 @@ TEST_F(FunctionBodyDecoderTest, DefaultableLocal) {
 TEST_F(FunctionBodyDecoderTest, NonDefaultableLocals) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
   ValueType rep = ref(struct_type_index);
   FunctionSig sig(0, 1, &rep);
   AddLocals(rep, 2);
-  byte ex = builder.AddException(sigs.v_v());
+  uint8_t ex = builder.AddException(sigs.v_v());
   // Declaring non-defaultable locals is fine.
   ExpectValidates(&sig, {});
   // Loading from an uninitialized non-defaultable local fails.
@@ -3659,7 +3667,7 @@ TEST_F(FunctionBodyDecoderTest, RefEq) {
   WASM_FEATURE_SCOPE(simd);
   WASM_FEATURE_SCOPE(gc);
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
   ValueType eqref_subtypes[] = {
       kWasmEqRef,  kWasmI31Ref.AsNonNull(), kWasmEqRef.AsNonNull(),
       kWasmI31Ref, ref(struct_type_index),  refNull(struct_type_index)};
@@ -3701,8 +3709,8 @@ TEST_F(FunctionBodyDecoderTest, RefAsNonNull) {
   WASM_FEATURE_SCOPE(simd);
   WASM_FEATURE_SCOPE(gc);
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
-  byte array_type_index = builder.AddArray(kWasmI32, true);
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t array_type_index = builder.AddArray(kWasmI32, true);
   uint32_t heap_types[] = {
       struct_type_index, array_type_index, HeapType::kFunc, HeapType::kEq,
       HeapType::kExtern, HeapType::kAny,   HeapType::kI31};
@@ -3738,8 +3746,8 @@ TEST_F(FunctionBodyDecoderTest, RefNull) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
-  byte array_type_index = builder.AddArray(kWasmI32, true);
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t array_type_index = builder.AddArray(kWasmI32, true);
   uint32_t type_reprs[] = {
       struct_type_index, array_type_index, HeapType::kFunc, HeapType::kEq,
       HeapType::kExtern, HeapType::kAny,   HeapType::kI31,  HeapType::kNone};
@@ -3764,8 +3772,8 @@ TEST_F(FunctionBodyDecoderTest, RefIsNull) {
       sigs.i_i(), {WASM_REF_IS_NULL(WASM_LOCAL_GET(0))}, kAppendEnd,
       "ref.is_null[0] expected reference type, found local.get of type i32");
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
-  byte array_type_index = builder.AddArray(kWasmI32, true);
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t array_type_index = builder.AddArray(kWasmI32, true);
   uint32_t heap_types[] = {
       struct_type_index, array_type_index, HeapType::kFunc, HeapType::kEq,
       HeapType::kExtern, HeapType::kAny,   HeapType::kI31};
@@ -3790,8 +3798,8 @@ TEST_F(FunctionBodyDecoderTest, BrOnNull) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
-  byte array_type_index = builder.AddArray(kWasmI32, true);
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t array_type_index = builder.AddArray(kWasmI32, true);
   uint32_t type_reprs[] = {
       struct_type_index, array_type_index, HeapType::kFunc, HeapType::kEq,
       HeapType::kExtern, HeapType::kAny,   HeapType::kI31,  HeapType::kNone};
@@ -3818,8 +3826,8 @@ TEST_F(FunctionBodyDecoderTest, BrOnNonNull) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
-  byte array_type_index = builder.AddArray(kWasmI32, true);
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t array_type_index = builder.AddArray(kWasmI32, true);
   uint32_t type_reprs[] = {
       struct_type_index, array_type_index, HeapType::kFunc, HeapType::kEq,
       HeapType::kExtern, HeapType::kAny,   HeapType::kI31};
@@ -3852,10 +3860,10 @@ TEST_F(FunctionBodyDecoderTest, GCStruct) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
-  byte array_type_index = builder.AddArray(kWasmI32, true);
-  byte immutable_struct_type_index = builder.AddStruct({F(kWasmI32, false)});
-  byte field_index = 0;
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t array_type_index = builder.AddArray(kWasmI32, true);
+  uint8_t immutable_struct_type_index = builder.AddStruct({F(kWasmI32, false)});
+  uint8_t field_index = 0;
 
   ValueType struct_type = ValueType::Ref(struct_type_index);
   ValueType reps_i_r[] = {kWasmI32, struct_type};
@@ -3963,9 +3971,9 @@ TEST_F(FunctionBodyDecoderTest, GCArray) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte array_type_index = builder.AddArray(kWasmFuncRef, true);
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, false)});
-  byte immutable_array_type_index = builder.AddArray(kWasmI32, false);
+  uint8_t array_type_index = builder.AddArray(kWasmFuncRef, true);
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, false)});
+  uint8_t immutable_array_type_index = builder.AddArray(kWasmI32, false);
 
   ValueType array_type = ValueType::Ref(array_type_index);
   ValueType immutable_array_type = ValueType::Ref(immutable_array_type_index);
@@ -4108,9 +4116,9 @@ TEST_F(FunctionBodyDecoderTest, PackedFields) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte array_type_index = builder.AddArray(kWasmI8, true);
-  byte struct_type_index = builder.AddStruct({F(kWasmI16, true)});
-  byte field_index = 0;
+  uint8_t array_type_index = builder.AddArray(kWasmI8, true);
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI16, true)});
+  uint8_t field_index = 0;
 
   // *.new with packed fields works.
   ExpectValidates(sigs.v_v(),
@@ -4324,8 +4332,8 @@ TEST_F(FunctionBodyDecoderTest, BrOnCastOrCastFail) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte super_struct = builder.AddStruct({F(kWasmI16, true)});
-  byte sub_struct =
+  uint8_t super_struct = builder.AddStruct({F(kWasmI16, true)});
+  uint8_t sub_struct =
       builder.AddStruct({F(kWasmI16, true), F(kWasmI32, false)}, super_struct);
 
   ValueType supertype = ValueType::RefNull(super_struct);
@@ -4526,7 +4534,7 @@ TEST_F(FunctionBodyDecoderTest, LocalTeeTyping) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte array_type = builder.AddArray(kWasmI8, true);
+  uint8_t array_type = builder.AddArray(kWasmI8, true);
 
   ValueType types[] = {ValueType::Ref(array_type)};
   FunctionSig sig(1, 0, types);
@@ -4543,10 +4551,10 @@ TEST_F(FunctionBodyDecoderTest, MergeNullableTypes) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
+  uint8_t struct_type_index = builder.AddStruct({F(kWasmI32, true)});
   ValueType struct_type = refNull(struct_type_index);
   FunctionSig loop_sig(0, 1, &struct_type);
-  byte loop_sig_index = builder.AddSignature(&loop_sig);
+  uint8_t loop_sig_index = builder.AddSignature(&loop_sig);
   // Verifies that when a loop consuming a nullable type is entered with a
   // statically known non-null value on the stack, its {start_merge_} can
   // consume null values later.
@@ -4625,14 +4633,14 @@ TEST_F(FunctionBodyDecoderTest, ExternExternalize) {
 class BranchTableIteratorTest : public TestWithZone {
  public:
   BranchTableIteratorTest() : TestWithZone() {}
-  void CheckBrTableSize(const byte* start, const byte* end) {
+  void CheckBrTableSize(const uint8_t* start, const uint8_t* end) {
     Decoder decoder(start, end);
     BranchTableImmediate operand(&decoder, start + 1, Decoder::kFullValidation);
     BranchTableIterator<Decoder::FullValidationTag> iterator(&decoder, operand);
     EXPECT_EQ(end - start - 1u, iterator.length());
     EXPECT_OK(decoder);
   }
-  void CheckBrTableError(const byte* start, const byte* end) {
+  void CheckBrTableError(const uint8_t* start, const uint8_t* end) {
     Decoder decoder(start, end);
     BranchTableImmediate operand(&decoder, start + 1, Decoder::kFullValidation);
     BranchTableIterator<Decoder::FullValidationTag> iterator(&decoder, operand);
@@ -4641,16 +4649,16 @@ class BranchTableIteratorTest : public TestWithZone {
   }
 };
 
-#define CHECK_BR_TABLE_LENGTH(...)                    \
-  {                                                   \
-    static byte code[] = {kExprBrTable, __VA_ARGS__}; \
-    CheckBrTableSize(code, code + sizeof(code));      \
+#define CHECK_BR_TABLE_LENGTH(...)                       \
+  {                                                      \
+    static uint8_t code[] = {kExprBrTable, __VA_ARGS__}; \
+    CheckBrTableSize(code, code + sizeof(code));         \
   }
 
-#define CHECK_BR_TABLE_ERROR(...)                     \
-  {                                                   \
-    static byte code[] = {kExprBrTable, __VA_ARGS__}; \
-    CheckBrTableError(code, code + sizeof(code));     \
+#define CHECK_BR_TABLE_ERROR(...)                        \
+  {                                                      \
+    static uint8_t code[] = {kExprBrTable, __VA_ARGS__}; \
+    CheckBrTableError(code, code + sizeof(code));        \
   }
 
 TEST_F(BranchTableIteratorTest, count0) {
@@ -4686,14 +4694,14 @@ TEST_F(BranchTableIteratorTest, error0) {
 #undef CHECK_BR_TABLE_ERROR
 
 struct PrintOpcodes {
-  const byte* start;
-  const byte* end;
+  const uint8_t* start;
+  const uint8_t* end;
 };
 std::ostream& operator<<(std::ostream& out, const PrintOpcodes& range) {
   out << "First opcode: \""
       << WasmOpcodes::OpcodeName(static_cast<WasmOpcode>(*range.start))
       << "\"\nall bytes: [";
-  for (const byte* b = range.start; b < range.end; ++b) {
+  for (const uint8_t* b = range.start; b < range.end; ++b) {
     out << (b == range.start ? "" : ", ") << uint32_t{*b} << "/"
         << AsHex(*b, 2, true);
   }
@@ -4706,7 +4714,8 @@ class WasmOpcodeLengthTest : public TestWithZone {
 
   template <typename... Bytes>
   void ExpectLength(unsigned expected, Bytes... bytes) {
-    const byte code[] = {static_cast<byte>(bytes)..., 0, 0, 0, 0, 0, 0, 0, 0};
+    const uint8_t code[] = {
+        static_cast<uint8_t>(bytes)..., 0, 0, 0, 0, 0, 0, 0, 0};
     EXPECT_EQ(expected, OpcodeLength(code, code + sizeof(code)))
         << PrintOpcodes{code, code + sizeof...(bytes)};
   }
@@ -4727,7 +4736,8 @@ class WasmOpcodeLengthTest : public TestWithZone {
 
   template <typename... Bytes>
   void ExpectFailure(Bytes... bytes) {
-    const byte code[] = {static_cast<byte>(bytes)..., 0, 0, 0, 0, 0, 0, 0, 0};
+    const uint8_t code[] = {
+        static_cast<uint8_t>(bytes)..., 0, 0, 0, 0, 0, 0, 0, 0};
     WasmFeatures no_features = WasmFeatures::None();
     WasmDecoder<Decoder::FullValidationTag> decoder(
         this->zone(), nullptr, no_features, &no_features, nullptr, code,
@@ -4738,15 +4748,15 @@ class WasmOpcodeLengthTest : public TestWithZone {
 
   void ExpectNonFailure(WasmOpcode opcode) {
     uint8_t maybe_prefix = WasmOpcodes::ExtractPrefix(opcode);
-    byte bytes[32]{0};
+    uint8_t bytes[32]{0};
     if (WasmOpcodes::IsPrefixOpcode(static_cast<WasmOpcode>(maybe_prefix))) {
       bytes[0] = maybe_prefix;
       uint16_t index = ExtractPrefixedOpcodeBytes(opcode);
-      byte* p = &bytes[1];
+      uint8_t* p = &bytes[1];
       LEBHelper::write_u32v(&p, index);
     } else {
       DCHECK_LE(static_cast<uint32_t>(opcode), 0xFF);
-      bytes[0] = static_cast<byte>(opcode);
+      bytes[0] = static_cast<uint8_t>(opcode);
       // Special case: select_with_type insists on a {1} immediate.
       if (opcode == kExprSelectWithType) {
         bytes[1] = 1;
@@ -4947,7 +4957,7 @@ TEST_F(WasmOpcodeLengthTest, PrefixedOpcodesLEB) {
 
 class TypeReaderTest : public TestWithZone {
  public:
-  HeapType DecodeHeapType(const byte* start, const byte* end) {
+  HeapType DecodeHeapType(const uint8_t* start, const uint8_t* end) {
     Decoder decoder(start, end);
     auto [heap_type, length] =
         value_type_reader::read_heap_type<Decoder::FullValidationTag>(
@@ -4968,34 +4978,34 @@ TEST_F(TypeReaderTest, HeapTypeDecodingTest) {
 
   // 1- to 5-byte representation of kFuncRefCode.
   {
-    const byte data[] = {kFuncRefCode};
+    const uint8_t data[] = {kFuncRefCode};
     HeapType result = DecodeHeapType(data, data + sizeof(data));
     EXPECT_TRUE(result == heap_func);
   }
   {
-    const byte data[] = {kFuncRefCode | 0x80, 0x7F};
+    const uint8_t data[] = {kFuncRefCode | 0x80, 0x7F};
     HeapType result = DecodeHeapType(data, data + sizeof(data));
     EXPECT_EQ(result, heap_func);
   }
   {
-    const byte data[] = {kFuncRefCode | 0x80, 0xFF, 0x7F};
+    const uint8_t data[] = {kFuncRefCode | 0x80, 0xFF, 0x7F};
     HeapType result = DecodeHeapType(data, data + sizeof(data));
     EXPECT_EQ(result, heap_func);
   }
   {
-    const byte data[] = {kFuncRefCode | 0x80, 0xFF, 0xFF, 0x7F};
+    const uint8_t data[] = {kFuncRefCode | 0x80, 0xFF, 0xFF, 0x7F};
     HeapType result = DecodeHeapType(data, data + sizeof(data));
     EXPECT_EQ(result, heap_func);
   }
   {
-    const byte data[] = {kFuncRefCode | 0x80, 0xFF, 0xFF, 0xFF, 0x7F};
+    const uint8_t data[] = {kFuncRefCode | 0x80, 0xFF, 0xFF, 0xFF, 0x7F};
     HeapType result = DecodeHeapType(data, data + sizeof(data));
     EXPECT_EQ(result, heap_func);
   }
 
   {
     // Some negative number.
-    const byte data[] = {0xB4, 0x7F};
+    const uint8_t data[] = {0xB4, 0x7F};
     HeapType result = DecodeHeapType(data, data + sizeof(data));
     EXPECT_EQ(result, heap_bottom);
   }
@@ -5004,7 +5014,7 @@ TEST_F(TypeReaderTest, HeapTypeDecodingTest) {
     // This differs from kFuncRefCode by one bit outside the 1-byte LEB128
     // range. This should therefore NOT be decoded as HeapType::kFunc and
     // instead fail.
-    const byte data[] = {kFuncRefCode | 0x80, 0x6F};
+    const uint8_t data[] = {kFuncRefCode | 0x80, 0x6F};
     HeapType result = DecodeHeapType(data, data + sizeof(data));
     EXPECT_EQ(result, heap_bottom);
   }
@@ -5022,8 +5032,8 @@ class LocalDeclDecoderTest : public TestWithZone {
     return pos;
   }
 
-  bool DecodeLocalDecls(BodyLocalDecls* decls, const byte* start,
-                        const byte* end) {
+  bool DecodeLocalDecls(BodyLocalDecls* decls, const uint8_t* start,
+                        const uint8_t* end) {
     WasmModule module;
     return ValidateAndDecodeLocalDeclsForTesting(enabled_features_, decls,
                                                  &module, start, end, zone());
@@ -5037,7 +5047,7 @@ TEST_F(LocalDeclDecoderTest, EmptyLocals) {
 }
 
 TEST_F(LocalDeclDecoderTest, NoLocals) {
-  static const byte data[] = {0};
+  static const uint8_t data[] = {0};
   BodyLocalDecls decls;
   bool result = DecodeLocalDecls(&decls, data, data + sizeof(data));
   EXPECT_TRUE(result);
@@ -5045,15 +5055,15 @@ TEST_F(LocalDeclDecoderTest, NoLocals) {
 }
 
 TEST_F(LocalDeclDecoderTest, WrongLocalDeclsCount1) {
-  static const byte data[] = {1};
+  static const uint8_t data[] = {1};
   BodyLocalDecls decls;
   bool result = DecodeLocalDecls(&decls, data, data + sizeof(data));
   EXPECT_FALSE(result);
 }
 
 TEST_F(LocalDeclDecoderTest, WrongLocalDeclsCount2) {
-  static const byte data[] = {2, 1,
-                              static_cast<byte>(kWasmI32.value_type_code())};
+  static const uint8_t data[] = {
+      2, 1, static_cast<uint8_t>(kWasmI32.value_type_code())};
   BodyLocalDecls decls;
   bool result = DecodeLocalDecls(&decls, data, data + sizeof(data));
   EXPECT_FALSE(result);
@@ -5062,7 +5072,7 @@ TEST_F(LocalDeclDecoderTest, WrongLocalDeclsCount2) {
 TEST_F(LocalDeclDecoderTest, OneLocal) {
   for (size_t i = 0; i < arraysize(kValueTypes); i++) {
     ValueType type = kValueTypes[i];
-    const byte data[] = {1, 1, static_cast<byte>(type.value_type_code())};
+    const uint8_t data[] = {1, 1, static_cast<uint8_t>(type.value_type_code())};
     BodyLocalDecls decls;
     bool result = DecodeLocalDecls(&decls, data, data + sizeof(data));
     EXPECT_TRUE(result);
@@ -5075,7 +5085,7 @@ TEST_F(LocalDeclDecoderTest, OneLocal) {
 TEST_F(LocalDeclDecoderTest, FiveLocals) {
   for (size_t i = 0; i < arraysize(kValueTypes); i++) {
     ValueType type = kValueTypes[i];
-    const byte data[] = {1, 5, static_cast<byte>(type.value_type_code())};
+    const uint8_t data[] = {1, 5, static_cast<uint8_t>(type.value_type_code())};
     BodyLocalDecls decls;
     bool result = DecodeLocalDecls(&decls, data, data + sizeof(data));
     EXPECT_TRUE(result);
@@ -5086,12 +5096,12 @@ TEST_F(LocalDeclDecoderTest, FiveLocals) {
 }
 
 TEST_F(LocalDeclDecoderTest, MixedLocals) {
-  for (byte a = 0; a < 3; a++) {
-    for (byte b = 0; b < 3; b++) {
-      for (byte c = 0; c < 3; c++) {
-        for (byte d = 0; d < 3; d++) {
-          const byte data[] = {4, a,        kI32Code, b,       kI64Code,
-                               c, kF32Code, d,        kF64Code};
+  for (uint8_t a = 0; a < 3; a++) {
+    for (uint8_t b = 0; b < 3; b++) {
+      for (uint8_t c = 0; c < 3; c++) {
+        for (uint8_t d = 0; d < 3; d++) {
+          const uint8_t data[] = {4, a,        kI32Code, b,       kI64Code,
+                                  c, kF32Code, d,        kF64Code};
           BodyLocalDecls decls;
           bool result = DecodeLocalDecls(&decls, data, data + sizeof(data));
           EXPECT_TRUE(result);
@@ -5110,8 +5120,8 @@ TEST_F(LocalDeclDecoderTest, MixedLocals) {
 }
 
 TEST_F(LocalDeclDecoderTest, UseEncoder) {
-  const byte* data = nullptr;
-  const byte* end = nullptr;
+  const uint8_t* data = nullptr;
+  const uint8_t* end = nullptr;
   LocalDeclEncoder local_decls(zone());
 
   local_decls.AddLocals(5, kWasmF32);
@@ -5133,8 +5143,8 @@ TEST_F(LocalDeclDecoderTest, UseEncoder) {
 TEST_F(LocalDeclDecoderTest, InvalidTypeIndex) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  const byte* data = nullptr;
-  const byte* end = nullptr;
+  const uint8_t* data = nullptr;
+  const uint8_t* end = nullptr;
   LocalDeclEncoder local_decls(zone());
 
   local_decls.AddLocals(1, ValueType::RefNull(0));
@@ -5146,7 +5156,7 @@ TEST_F(LocalDeclDecoderTest, InvalidTypeIndex) {
 class BytecodeIteratorTest : public TestWithZone {};
 
 TEST_F(BytecodeIteratorTest, SimpleForeach) {
-  byte code[] = {WASM_IF_ELSE(WASM_ZERO, WASM_ZERO, WASM_ZERO)};
+  uint8_t code[] = {WASM_IF_ELSE(WASM_ZERO, WASM_ZERO, WASM_ZERO)};
   BytecodeIterator iter(code, code + sizeof(code));
   WasmOpcode expected[] = {kExprI32Const, kExprIf,       kExprI32Const,
                            kExprElse,     kExprI32Const, kExprEnd};
@@ -5162,7 +5172,7 @@ TEST_F(BytecodeIteratorTest, SimpleForeach) {
 }
 
 TEST_F(BytecodeIteratorTest, ForeachTwice) {
-  byte code[] = {WASM_IF_ELSE(WASM_ZERO, WASM_ZERO, WASM_ZERO)};
+  uint8_t code[] = {WASM_IF_ELSE(WASM_ZERO, WASM_ZERO, WASM_ZERO)};
   BytecodeIterator iter(code, code + sizeof(code));
   int count = 0;
 
@@ -5182,7 +5192,7 @@ TEST_F(BytecodeIteratorTest, ForeachTwice) {
 }
 
 TEST_F(BytecodeIteratorTest, ForeachOffset) {
-  byte code[] = {WASM_IF_ELSE(WASM_ZERO, WASM_ZERO, WASM_ZERO)};
+  uint8_t code[] = {WASM_IF_ELSE(WASM_ZERO, WASM_ZERO, WASM_ZERO)};
   BytecodeIterator iter(code, code + sizeof(code));
   int count = 0;
 
@@ -5202,7 +5212,7 @@ TEST_F(BytecodeIteratorTest, ForeachOffset) {
 }
 
 TEST_F(BytecodeIteratorTest, WithLocalDecls) {
-  byte code[] = {1, 1, kI32Code, WASM_I32V_1(9), WASM_I32V_1(11)};
+  uint8_t code[] = {1, 1, kI32Code, WASM_I32V_1(9), WASM_I32V_1(11)};
   BodyLocalDecls decls;
   BytecodeIterator iter(code, code + sizeof(code), &decls, zone());
 
diff --git a/test/unittests/wasm/leb-helper-unittest.cc b/test/unittests/wasm/leb-helper-unittest.cc
index 71faa6f3d5b..ae1235723d8 100644
--- a/test/unittests/wasm/leb-helper-unittest.cc
+++ b/test/unittests/wasm/leb-helper-unittest.cc
@@ -91,8 +91,8 @@ TEST_F(LEBHelperTest, sizeof_i32v) {
 #define DECLARE_ENCODE_DECODE_CHECKER(ctype, name)                         \
   static void CheckEncodeDecode_##name(ctype val) {                        \
     static const int kSize = 16;                                           \
-    static byte buffer[kSize];                                             \
-    byte* ptr = buffer;                                                    \
+    static uint8_t buffer[kSize];                                          \
+    uint8_t* ptr = buffer;                                                 \
     LEBHelper::write_##name(&ptr, val);                                    \
     EXPECT_EQ(LEBHelper::sizeof_##name(val),                               \
               static_cast<size_t>(ptr - buffer));                          \
diff --git a/test/unittests/wasm/loop-assignment-analysis-unittest.cc b/test/unittests/wasm/loop-assignment-analysis-unittest.cc
index 2e7c75c1c94..dc78524e780 100644
--- a/test/unittests/wasm/loop-assignment-analysis-unittest.cc
+++ b/test/unittests/wasm/loop-assignment-analysis-unittest.cc
@@ -26,7 +26,7 @@ class WasmLoopAssignmentAnalyzerTest : public TestWithZone {
   TestSignatures sigs;
   uint32_t num_locals;
 
-  BitVector* Analyze(const byte* start, const byte* end,
+  BitVector* Analyze(const uint8_t* start, const uint8_t* end,
                      bool* loop_is_innermost = nullptr) {
     return AnalyzeLoopAssignmentForTesting(zone(), num_locals, start, end,
                                            loop_is_innermost);
@@ -34,13 +34,13 @@ class WasmLoopAssignmentAnalyzerTest : public TestWithZone {
 };
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, Empty0) {
-  byte code[] = { 0 };
+  uint8_t code[] = {0};
   BitVector* assigned = Analyze(code, code);
   EXPECT_EQ(assigned, nullptr);
 }
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, Empty1) {
-  byte code[] = {kExprLoop, kVoidCode, 0};
+  uint8_t code[] = {kExprLoop, kVoidCode, 0};
   for (int i = 0; i < 5; i++) {
     BitVector* assigned = Analyze(code, code + arraysize(code));
     for (int j = 0; j < assigned->length(); j++) {
@@ -53,7 +53,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, Empty1) {
 TEST_F(WasmLoopAssignmentAnalyzerTest, One) {
   num_locals = 5;
   for (int i = 0; i < 5; i++) {
-    byte code[] = {WASM_LOOP(WASM_SET_ZERO(i))};
+    uint8_t code[] = {WASM_LOOP(WASM_SET_ZERO(i))};
     BitVector* assigned = Analyze(code, code + arraysize(code));
     for (int j = 0; j < assigned->length(); j++) {
       EXPECT_EQ(j == i, assigned->Contains(j));
@@ -64,7 +64,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, One) {
 TEST_F(WasmLoopAssignmentAnalyzerTest, TeeOne) {
   num_locals = 5;
   for (int i = 0; i < 5; i++) {
-    byte code[] = {WASM_LOOP(WASM_LOCAL_TEE(i, WASM_ZERO))};
+    uint8_t code[] = {WASM_LOOP(WASM_LOCAL_TEE(i, WASM_ZERO))};
     BitVector* assigned = Analyze(code, code + arraysize(code));
     for (int j = 0; j < assigned->length(); j++) {
       EXPECT_EQ(j == i, assigned->Contains(j));
@@ -75,7 +75,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, TeeOne) {
 TEST_F(WasmLoopAssignmentAnalyzerTest, OneBeyond) {
   num_locals = 5;
   for (int i = 0; i < 5; i++) {
-    byte code[] = {WASM_LOOP(WASM_SET_ZERO(i)), WASM_SET_ZERO(1)};
+    uint8_t code[] = {WASM_LOOP(WASM_SET_ZERO(i)), WASM_SET_ZERO(1)};
     BitVector* assigned = Analyze(code, code + arraysize(code));
     for (int j = 0; j < assigned->length(); j++) {
       EXPECT_EQ(j == i, assigned->Contains(j));
@@ -87,7 +87,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, Two) {
   num_locals = 5;
   for (int i = 0; i < 5; i++) {
     for (int j = 0; j < 5; j++) {
-      byte code[] = {WASM_LOOP(WASM_SET_ZERO(i), WASM_SET_ZERO(j))};
+      uint8_t code[] = {WASM_LOOP(WASM_SET_ZERO(i), WASM_SET_ZERO(j))};
       BitVector* assigned = Analyze(code, code + arraysize(code));
       for (int k = 0; k < assigned->length(); k++) {
         bool expected = k == i || k == j;
@@ -100,7 +100,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, Two) {
 TEST_F(WasmLoopAssignmentAnalyzerTest, NestedIf) {
   num_locals = 5;
   for (int i = 0; i < 5; i++) {
-    byte code[] = {WASM_LOOP(
+    uint8_t code[] = {WASM_LOOP(
         WASM_IF_ELSE(WASM_SET_ZERO(0), WASM_SET_ZERO(i), WASM_SET_ZERO(1)))};
     BitVector* assigned = Analyze(code, code + arraysize(code));
     for (int j = 0; j < assigned->length(); j++) {
@@ -113,7 +113,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, NestedIf) {
 TEST_F(WasmLoopAssignmentAnalyzerTest, BigLocal) {
   num_locals = 65000;
   for (int i = 13; i < 65000; i = static_cast<int>(i * 1.5)) {
-    byte code[] = {WASM_LOOP(WASM_I32V_1(11), kExprLocalSet, U32V_3(i))};
+    uint8_t code[] = {WASM_LOOP(WASM_I32V_1(11), kExprLocalSet, U32V_3(i))};
 
     BitVector* assigned = Analyze(code, code + arraysize(code));
     for (int j = 0; j < assigned->length(); j++) {
@@ -125,7 +125,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, BigLocal) {
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, Break) {
   num_locals = 3;
-  byte code[] = {
+  uint8_t code[] = {
       WASM_LOOP(WASM_IF(WASM_LOCAL_GET(0), WASM_BRV(1, WASM_SET_ZERO(1)))),
       WASM_SET_ZERO(0)};
 
@@ -138,7 +138,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, Break) {
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, Loop1) {
   num_locals = 5;
-  byte code[] = {
+  uint8_t code[] = {
       WASM_LOOP(WASM_IF(
           WASM_LOCAL_GET(0),
           WASM_BRV(0, WASM_LOCAL_SET(3, WASM_I32_SUB(WASM_LOCAL_GET(0),
@@ -154,10 +154,10 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, Loop1) {
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, Loop2) {
   num_locals = 6;
-  const byte kIter = 0;
-  const byte kSum = 3;
+  const uint8_t kIter = 0;
+  const uint8_t kSum = 3;
 
-  byte code[] = {WASM_BLOCK(
+  uint8_t code[] = {WASM_BLOCK(
       WASM_WHILE(
           WASM_LOCAL_GET(kIter),
           WASM_BLOCK(
@@ -179,7 +179,7 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, Loop2) {
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, NestedLoop) {
   num_locals = 5;
-  byte code[] = {WASM_LOOP(WASM_LOOP(WASM_LOCAL_SET(0, 1)))};
+  uint8_t code[] = {WASM_LOOP(WASM_LOOP(WASM_LOCAL_SET(0, 1)))};
 
   bool outer_is_innermost = false;
   BitVector* outer_assigned =
@@ -201,21 +201,21 @@ TEST_F(WasmLoopAssignmentAnalyzerTest, NestedLoop) {
 }
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, Malformed) {
-  byte code[] = {kExprLoop, kVoidCode, kExprF32Neg, kExprBrTable, 0x0E, 'h',
-                 'e',       'l',       'l',         'o',          ',',  ' ',
-                 'w',       'o',       'r',         'l',          'd',  '!'};
+  uint8_t code[] = {kExprLoop, kVoidCode, kExprF32Neg, kExprBrTable, 0x0E, 'h',
+                    'e',       'l',       'l',         'o',          ',',  ' ',
+                    'w',       'o',       'r',         'l',          'd',  '!'};
   BitVector* assigned = Analyze(code, code + arraysize(code));
   EXPECT_EQ(assigned, nullptr);
 }
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, InvalidOpcode) {
-  byte code[] = {WASM_LOOP(0xFF)};
+  uint8_t code[] = {WASM_LOOP(0xFF)};
   BitVector* assigned = Analyze(code, code + arraysize(code));
   EXPECT_EQ(assigned, nullptr);
 }
 
 TEST_F(WasmLoopAssignmentAnalyzerTest, regress_642867) {
-  static const byte code[] = {
+  static const uint8_t code[] = {
       WASM_LOOP(WASM_ZERO, kExprLocalSet, 0xFA, 0xFF, 0xFF, 0xFF,
                 0x0F)};  // local index LEB128 0xFFFFFFFA
   // Just make sure that the analysis does not crash.
diff --git a/test/unittests/wasm/memory-protection-unittest.cc b/test/unittests/wasm/memory-protection-unittest.cc
index 120197bba0d..892a331ee23 100644
--- a/test/unittests/wasm/memory-protection-unittest.cc
+++ b/test/unittests/wasm/memory-protection-unittest.cc
@@ -88,7 +88,7 @@ class MemoryProtectionTest : public TestWithNativeContext {
  private:
   std::shared_ptr<NativeModule> CompileNativeModule() {
     // Define the bytes for a module with a single empty function.
-    static const byte module_bytes[] = {
+    static const uint8_t module_bytes[] = {
         WASM_MODULE_HEADER, SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_v),
         SECTION(Function, ENTRY_COUNT(1), SIG_INDEX(0)),
         SECTION(Code, ENTRY_COUNT(1), ADD_COUNT(0 /* locals */, kExprEnd))};
diff --git a/test/unittests/wasm/module-decoder-unittest.cc b/test/unittests/wasm/module-decoder-unittest.cc
index 9bc09fb3bea..a6c68d94079 100644
--- a/test/unittests/wasm/module-decoder-unittest.cc
+++ b/test/unittests/wasm/module-decoder-unittest.cc
@@ -203,9 +203,9 @@ class WasmModuleVerifyTest : public TestWithIsolateAndZone {
   ModuleResult DecodeModule(base::Vector<const uint8_t> module_bytes) {
     // Add the wasm magic and version number automatically.
     size_t size = module_bytes.size();
-    byte header[] = {WASM_MODULE_HEADER};
+    uint8_t header[] = {WASM_MODULE_HEADER};
     size_t total = sizeof(header) + size;
-    auto temp = new byte[total];
+    auto temp = new uint8_t[total];
     memcpy(temp, header, sizeof(header));
     if (size > 0) {
       memcpy(temp + sizeof(header), module_bytes.begin(), size);
@@ -222,7 +222,7 @@ class WasmModuleVerifyTest : public TestWithIsolateAndZone {
 
 TEST_F(WasmModuleVerifyTest, WrongMagic) {
   for (uint32_t x = 1; x; x <<= 1) {
-    const byte data[] = {U32_LE(kWasmMagic ^ x), U32_LE(kWasmVersion)};
+    const uint8_t data[] = {U32_LE(kWasmMagic ^ x), U32_LE(kWasmVersion)};
     ModuleResult result = DecodeModuleNoHeader(base::ArrayVector(data));
     EXPECT_FALSE(result.ok());
   }
@@ -230,15 +230,15 @@ TEST_F(WasmModuleVerifyTest, WrongMagic) {
 
 TEST_F(WasmModuleVerifyTest, WrongVersion) {
   for (uint32_t x = 1; x; x <<= 1) {
-    const byte data[] = {U32_LE(kWasmMagic), U32_LE(kWasmVersion ^ x)};
+    const uint8_t data[] = {U32_LE(kWasmMagic), U32_LE(kWasmVersion ^ x)};
     ModuleResult result = DecodeModuleNoHeader(base::ArrayVector(data));
     EXPECT_FALSE(result.ok());
   }
 }
 
 TEST_F(WasmModuleVerifyTest, WrongSection) {
-  constexpr byte kInvalidSection = 0x1c;
-  const byte data[] = {kInvalidSection, 0};
+  constexpr uint8_t kInvalidSection = 0x1c;
+  const uint8_t data[] = {kInvalidSection, 0};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_FALSE(result.ok());
 }
@@ -249,7 +249,7 @@ TEST_F(WasmModuleVerifyTest, DecodeEmpty) {
 }
 
 TEST_F(WasmModuleVerifyTest, OneGlobal) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Global,                     // --
               ENTRY_COUNT(1),             // --
               kI32Code,                   // local type
@@ -279,11 +279,12 @@ TEST_F(WasmModuleVerifyTest, S128Global) {
   WASM_FEATURE_SCOPE(simd);
   std::array<uint8_t, kSimd128Size> v = {1, 2,  3,  4,  5,  6,  7, 8,
                                          9, 10, 11, 12, 13, 14, 15};
-  static const byte data[] = {SECTION(Global,          // --
-                                      ENTRY_COUNT(1),  // --
-                                      kS128Code,       // memory type
-                                      0,               // immutable
-                                      WASM_SIMD_CONSTANT(v.data()), kExprEnd)};
+  static const uint8_t data[] = {SECTION(Global,          // --
+                                         ENTRY_COUNT(1),  // --
+                                         kS128Code,       // memory type
+                                         0,               // immutable
+                                         WASM_SIMD_CONSTANT(v.data()),
+                                         kExprEnd)};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   if (!CheckHardwareSupportsSimd()) {
     EXPECT_NOT_OK(result, "Wasm SIMD unsupported");
@@ -297,7 +298,7 @@ TEST_F(WasmModuleVerifyTest, S128Global) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExternRefGlobal) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -341,7 +342,7 @@ TEST_F(WasmModuleVerifyTest, ExternRefGlobal) {
 }
 
 TEST_F(WasmModuleVerifyTest, FuncRefGlobal) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -384,7 +385,7 @@ TEST_F(WasmModuleVerifyTest, FuncRefGlobal) {
 }
 
 TEST_F(WasmModuleVerifyTest, InvalidFuncRefGlobal) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -399,7 +400,7 @@ TEST_F(WasmModuleVerifyTest, InvalidFuncRefGlobal) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExternRefGlobalWithGlobalInit) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import,           // --
               ENTRY_COUNT(1),   // number of imports
               ADD_COUNT('m'),   // module name
@@ -430,7 +431,7 @@ TEST_F(WasmModuleVerifyTest, ExternRefGlobalWithGlobalInit) {
 }
 
 TEST_F(WasmModuleVerifyTest, NullGlobalWithGlobalInit) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import,           // --
               ENTRY_COUNT(1),   // number of imports
               ADD_COUNT('m'),   // module name
@@ -462,7 +463,7 @@ TEST_F(WasmModuleVerifyTest, NullGlobalWithGlobalInit) {
 }
 
 TEST_F(WasmModuleVerifyTest, GlobalInvalidType) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Global,                      // --
               ENTRY_COUNT(1),              // --
               64,                          // invalid value type
@@ -474,7 +475,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInvalidType) {
 }
 
 TEST_F(WasmModuleVerifyTest, GlobalInvalidType2) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Global,                      // --
               ENTRY_COUNT(1),              // --
               kVoidCode,                   // invalid value type
@@ -486,7 +487,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInvalidType2) {
 }
 
 TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
-  static const byte no_initializer_no_end[] = {
+  static const uint8_t no_initializer_no_end[] = {
       SECTION(Global,          //--
               ENTRY_COUNT(1),  //--
               kI32Code,        // type
@@ -494,7 +495,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
   };
   EXPECT_FAILURE_WITH_MSG(no_initializer_no_end, "Beyond end of code");
 
-  static const byte no_initializer[] = {
+  static const uint8_t no_initializer[] = {
       SECTION(Global,          //--
               ENTRY_COUNT(1),  //--
               kI32Code,        // type
@@ -505,7 +506,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
       no_initializer,
       "expected 1 elements on the stack for constant expression, found 0");
 
-  static const byte too_many_initializers_no_end[] = {
+  static const uint8_t too_many_initializers_no_end[] = {
       SECTION(Global,           // --
               ENTRY_COUNT(1),   // --
               kI32Code,         // type
@@ -516,7 +517,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
   EXPECT_FAILURE_WITH_MSG(too_many_initializers_no_end,
                           "constant expression is missing 'end'");
 
-  static const byte too_many_initializers[] = {
+  static const uint8_t too_many_initializers[] = {
       SECTION(Global,           // --
               ENTRY_COUNT(1),   // --
               kI32Code,         // type
@@ -528,7 +529,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
       too_many_initializers,
       "expected 1 elements on the stack for constant expression, found 2");
 
-  static const byte missing_end_opcode[] = {
+  static const uint8_t missing_end_opcode[] = {
       SECTION(Global,           // --
               ENTRY_COUNT(1),   // --
               kI32Code,         // type
@@ -538,7 +539,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
   EXPECT_FAILURE_WITH_MSG(missing_end_opcode,
                           "constant expression is missing 'end'");
 
-  static const byte referencing_out_of_bounds_global[] = {
+  static const uint8_t referencing_out_of_bounds_global[] = {
       SECTION(Global, ENTRY_COUNT(1),         // --
               kI32Code,                       // type
               1,                              // mutable
@@ -547,7 +548,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
   EXPECT_FAILURE_WITH_MSG(referencing_out_of_bounds_global,
                           "Invalid global index: 42");
 
-  static const byte referencing_undefined_global[] = {
+  static const uint8_t referencing_undefined_global[] = {
       SECTION(Global, ENTRY_COUNT(2),        // --
               kI32Code,                      // type
               0,                             // mutable
@@ -562,7 +563,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
   {
     WASM_FEATURE_SCOPE(typed_funcref);
     WASM_FEATURE_SCOPE(gc);
-    static const byte referencing_undefined_global_nested[] = {
+    static const uint8_t referencing_undefined_global_nested[] = {
         SECTION(Type, ENTRY_COUNT(1), WASM_ARRAY_DEF(kI32Code, true)),
         SECTION(Global, ENTRY_COUNT(2),                      // --
                 kRefCode, 0,                                 // type
@@ -578,7 +579,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
                             "Invalid global index: 1");
   }
 
-  static const byte referencing_mutable_global[] = {
+  static const uint8_t referencing_mutable_global[] = {
       SECTION(Global, ENTRY_COUNT(2),        // --
               kI32Code,                      // type
               1,                             // mutable
@@ -591,7 +592,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
       referencing_mutable_global,
       "mutable globals cannot be used in constant expressions");
 
-  static const byte referencing_mutable_imported_global[] = {
+  static const uint8_t referencing_mutable_imported_global[] = {
       SECTION(Import, ENTRY_COUNT(1),          // --
               ADD_COUNT('m'), ADD_COUNT('n'),  // module, name
               kExternalGlobal,                 // --
@@ -606,7 +607,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
       referencing_mutable_imported_global,
       "mutable globals cannot be used in constant expressions");
 
-  static const byte referencing_immutable_imported_global[] = {
+  static const uint8_t referencing_immutable_imported_global[] = {
       SECTION(Import, ENTRY_COUNT(1),          // --
               ADD_COUNT('m'), ADD_COUNT('n'),  // module, name
               kExternalGlobal,                 // --
@@ -619,7 +620,7 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
   };
   EXPECT_VERIFIES(referencing_immutable_imported_global);
 
-  static const byte referencing_local_global[] = {
+  static const uint8_t referencing_local_global[] = {
       SECTION(Global, ENTRY_COUNT(2),        // --
               kI32Code,                      // type
               0,                             // mutable
@@ -645,14 +646,14 @@ TEST_F(WasmModuleVerifyTest, GlobalInitializer) {
 }
 
 TEST_F(WasmModuleVerifyTest, ZeroGlobals) {
-  static const byte data[] = {SECTION(Global, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Global, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_OK(result);
 }
 
 TEST_F(WasmModuleVerifyTest, ExportMutableGlobal) {
   {
-    static const byte data[] = {
+    static const uint8_t data[] = {
         SECTION(Global,                         // --
                 ENTRY_COUNT(1),                 // --
                 kI32Code,                       // local type
@@ -667,7 +668,7 @@ TEST_F(WasmModuleVerifyTest, ExportMutableGlobal) {
     EXPECT_VERIFIES(data);
   }
   {
-    static const byte data[] = {
+    static const uint8_t data[] = {
         SECTION(Global,                         // --
                 ENTRY_COUNT(1),                 // --
                 kI32Code,                       // local type
@@ -683,31 +684,31 @@ TEST_F(WasmModuleVerifyTest, ExportMutableGlobal) {
   }
 }
 
-static void AppendUint32v(std::vector<byte>* buffer, uint32_t val) {
+static void AppendUint32v(std::vector<uint8_t>* buffer, uint32_t val) {
   while (true) {
     uint32_t next = val >> 7;
     uint32_t out = val & 0x7F;
     if (next) {
-      buffer->push_back(static_cast<byte>(0x80 | out));
+      buffer->push_back(static_cast<uint8_t>(0x80 | out));
       val = next;
     } else {
-      buffer->push_back(static_cast<byte>(out));
+      buffer->push_back(static_cast<uint8_t>(out));
       break;
     }
   }
 }
 
 TEST_F(WasmModuleVerifyTest, NGlobals) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       kF32Code,                 // memory type
       0,                        // immutable
       WASM_INIT_EXPR_F32(7.7),  // init
   };
 
   for (uint32_t i = 0; i < kV8MaxWasmGlobals; i = i * 13 + 1) {
-    std::vector<byte> buffer;
+    std::vector<uint8_t> buffer;
     size_t size = SizeOfVarInt(i) + i * sizeof(data);
-    const byte globals[] = {kGlobalSectionCode, U32V_5(size)};
+    const uint8_t globals[] = {kGlobalSectionCode, U32V_5(size)};
     for (size_t g = 0; g != sizeof(globals); ++g) {
       buffer.push_back(globals[g]);
     }
@@ -722,14 +723,14 @@ TEST_F(WasmModuleVerifyTest, NGlobals) {
 }
 
 TEST_F(WasmModuleVerifyTest, TwoGlobals) {
-  static const byte data[] = {SECTION(Global,                      // --
-                                      ENTRY_COUNT(2),              // --
-                                      kF32Code,                    // type
-                                      0,                           // immutable
-                                      WASM_INIT_EXPR_F32(22.0),    // --
-                                      kF64Code,                    // type
-                                      1,                           // mutable
-                                      WASM_INIT_EXPR_F64(23.0))};  // --
+  static const uint8_t data[] = {SECTION(Global,                    // --
+                                         ENTRY_COUNT(2),            // --
+                                         kF32Code,                  // type
+                                         0,                         // immutable
+                                         WASM_INIT_EXPR_F32(22.0),  // --
+                                         kF64Code,                  // type
+                                         1,                         // mutable
+                                         WASM_INIT_EXPR_F64(23.0))};  // --
 
   {
     // Should decode to exactly two globals.
@@ -756,24 +757,26 @@ TEST_F(WasmModuleVerifyTest, TwoGlobals) {
 }
 
 TEST_F(WasmModuleVerifyTest, RefNullGlobal) {
-  static const byte data[] = {SECTION(Global, ENTRY_COUNT(1), kFuncRefCode, 1,
-                                      WASM_REF_NULL(kFuncRefCode), kExprEnd)};
+  static const uint8_t data[] = {SECTION(Global, ENTRY_COUNT(1), kFuncRefCode,
+                                         1, WASM_REF_NULL(kFuncRefCode),
+                                         kExprEnd)};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_OK(result);
 }
 
 TEST_F(WasmModuleVerifyTest, RefNullGlobalInvalid1) {
   WASM_FEATURE_SCOPE(typed_funcref);
-  static const byte data[] = {SECTION(Global, ENTRY_COUNT(1), kRefNullCode, 0,
-                                      1, WASM_REF_NULL(0), kExprEnd)};
+  static const uint8_t data[] = {SECTION(Global, ENTRY_COUNT(1), kRefNullCode,
+                                         0, 1, WASM_REF_NULL(0), kExprEnd)};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "Type index 0 is out of bounds");
 }
 
 TEST_F(WasmModuleVerifyTest, RefNullGlobalInvalid2) {
   WASM_FEATURE_SCOPE(typed_funcref);
-  static const byte data[] = {SECTION(Global, ENTRY_COUNT(1), kFuncRefCode, 1,
-                                      kExprRefNull, U32V_5(1000001), kExprEnd)};
+  static const uint8_t data[] = {SECTION(Global, ENTRY_COUNT(1), kFuncRefCode,
+                                         1, kExprRefNull, U32V_5(1000001),
+                                         kExprEnd)};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result,
                 "Type index 1000001 is greater than the maximum number 1000000 "
@@ -784,7 +787,7 @@ TEST_F(WasmModuleVerifyTest, StructNewInitExpr) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  static const byte basic[] = {
+  static const uint8_t basic[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true))),
       SECTION(Global, ENTRY_COUNT(1),  // --
@@ -792,7 +795,7 @@ TEST_F(WasmModuleVerifyTest, StructNewInitExpr) {
               WASM_INIT_EXPR_STRUCT_NEW(0, WASM_I32V(42)))};
   EXPECT_VERIFIES(basic);
 
-  static const byte global_args[] = {
+  static const uint8_t global_args[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true))),
       SECTION(Global, ENTRY_COUNT(2),     // --
@@ -802,7 +805,7 @@ TEST_F(WasmModuleVerifyTest, StructNewInitExpr) {
               WASM_INIT_EXPR_STRUCT_NEW(0, WASM_GLOBAL_GET(0)))};
   EXPECT_VERIFIES(global_args);
 
-  static const byte type_error[] = {
+  static const uint8_t type_error[] = {
       SECTION(Type, ENTRY_COUNT(2),  // --
               WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)),
               WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI64Code, true))),
@@ -818,7 +821,7 @@ TEST_F(WasmModuleVerifyTest, ArrayNewFixedInitExpr) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  static const byte basic[] = {
+  static const uint8_t basic[] = {
       SECTION(Type, ENTRY_COUNT(1), WASM_ARRAY_DEF(kI16Code, true)),
       SECTION(Global, ENTRY_COUNT(1),  // --
               kRefCode, 0, 0,          // type, mutability
@@ -826,7 +829,7 @@ TEST_F(WasmModuleVerifyTest, ArrayNewFixedInitExpr) {
                                              WASM_I32V(30)))};
   EXPECT_VERIFIES(basic);
 
-  static const byte basic_static[] = {
+  static const uint8_t basic_static[] = {
       SECTION(Type, ENTRY_COUNT(1), WASM_ARRAY_DEF(kI16Code, true)),
       SECTION(Global, ENTRY_COUNT(1),  // --
               kRefCode, 0, 0,          // type, mutability
@@ -834,7 +837,7 @@ TEST_F(WasmModuleVerifyTest, ArrayNewFixedInitExpr) {
                                              WASM_I32V(30)))};
   EXPECT_VERIFIES(basic_static);
 
-  static const byte basic_immutable[] = {
+  static const uint8_t basic_immutable[] = {
       SECTION(Type, ENTRY_COUNT(1), WASM_ARRAY_DEF(kI32Code, false)),
       SECTION(Global, ENTRY_COUNT(1),  // --
               kRefCode, 0, 0,          // type, mutability
@@ -842,7 +845,7 @@ TEST_F(WasmModuleVerifyTest, ArrayNewFixedInitExpr) {
                                              WASM_I32V(30)))};
   EXPECT_VERIFIES(basic_immutable);
 
-  static const byte type_error[] = {
+  static const uint8_t type_error[] = {
       SECTION(Type, ENTRY_COUNT(2),  // --
               WASM_ARRAY_DEF(kI32Code, true),
               WASM_ARRAY_DEF(WASM_SEQ(kRefCode, 0), true)),
@@ -853,7 +856,7 @@ TEST_F(WasmModuleVerifyTest, ArrayNewFixedInitExpr) {
       type_error,
       "type error in constant expression[0] (expected (ref 1), got (ref 0))");
 
-  static const byte subexpr_type_error[] = {
+  static const uint8_t subexpr_type_error[] = {
       SECTION(Type, ENTRY_COUNT(1), WASM_ARRAY_DEF(kI64Code, true)),
       SECTION(
           Global, ENTRY_COUNT(1),  // --
@@ -863,7 +866,7 @@ TEST_F(WasmModuleVerifyTest, ArrayNewFixedInitExpr) {
                           "array.new_fixed[1] expected type i64, found "
                           "i32.const of type i32");
 
-  static const byte length_error[] = {
+  static const uint8_t length_error[] = {
       SECTION(Type, ENTRY_COUNT(1), WASM_ARRAY_DEF(kI16Code, true)),
       SECTION(Global, ENTRY_COUNT(1),  // --
               kRefCode, 0, 0,          // type, mutability
@@ -877,9 +880,9 @@ TEST_F(WasmModuleVerifyTest, ArrayNewFixedInitExpr) {
 TEST_F(WasmModuleVerifyTest, EmptyStruct) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte empty_struct[] = {SECTION(Type, ENTRY_COUNT(1),  // --
-                                              kWasmStructTypeCode,   // --
-                                              U32V_1(0))};  // field count
+  static const uint8_t empty_struct[] = {SECTION(Type, ENTRY_COUNT(1),  // --
+                                                 kWasmStructTypeCode,   // --
+                                                 U32V_1(0))};  // field count
 
   EXPECT_VERIFIES(empty_struct);
 }
@@ -887,7 +890,7 @@ TEST_F(WasmModuleVerifyTest, EmptyStruct) {
 TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte all_good[] = {
+  static const uint8_t all_good[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
@@ -895,7 +898,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
               1)};                   // mutability
   EXPECT_VERIFIES(all_good);
 
-  static const byte invalid_field_type[] = {
+  static const uint8_t invalid_field_type[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
@@ -903,7 +906,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(invalid_field_type, "invalid value type");
 
-  static const byte field_type_oob_ref[] = {
+  static const uint8_t field_type_oob_ref[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
@@ -912,7 +915,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_oob_ref, "Type index 3 is out of bounds");
 
-  static const byte field_type_invalid_ref[] = {
+  static const uint8_t field_type_invalid_ref[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
@@ -921,7 +924,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref, "greater than the maximum");
 
-  static const byte field_type_invalid_ref2[] = {
+  static const uint8_t field_type_invalid_ref2[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
@@ -930,7 +933,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref2, "Unknown heap type");
 
-  static const byte not_enough_field_types[] = {
+  static const uint8_t not_enough_field_types[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(2),             // field count
@@ -938,7 +941,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
               1)};                   // mutability 1
   EXPECT_FAILURE_WITH_MSG(not_enough_field_types, "expected 1 byte");
 
-  static const byte not_enough_field_types2[] = {
+  static const uint8_t not_enough_field_types2[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(2),             // field count
@@ -947,7 +950,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
               kI32Code)};            // field type 2
   EXPECT_FAILURE_WITH_MSG(not_enough_field_types2, "expected 1 byte");
 
-  static const byte invalid_mutability[] = {
+  static const uint8_t invalid_mutability[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
@@ -959,21 +962,21 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
 TEST_F(WasmModuleVerifyTest, InvalidArrayTypeDef) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte all_good[] = {
+  static const uint8_t all_good[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
               kI32Code,              // perfectly valid field type
               1)};                   // mutability
   EXPECT_VERIFIES(all_good);
 
-  static const byte invalid_field_type[] = {
+  static const uint8_t invalid_field_type[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
               kWasmArrayTypeCode,    // bogus field type
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(invalid_field_type, "invalid value type");
 
-  static const byte field_type_oob_ref[] = {
+  static const uint8_t field_type_oob_ref[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
               kRefNullCode,          // field type: reference...
@@ -981,7 +984,7 @@ TEST_F(WasmModuleVerifyTest, InvalidArrayTypeDef) {
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_oob_ref, "Type index 3 is out of bounds");
 
-  static const byte field_type_invalid_ref[] = {
+  static const uint8_t field_type_invalid_ref[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
               kRefNullCode,          // field type: reference...
@@ -989,7 +992,7 @@ TEST_F(WasmModuleVerifyTest, InvalidArrayTypeDef) {
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref, "Unknown heap type");
 
-  static const byte field_type_invalid_ref2[] = {
+  static const uint8_t field_type_invalid_ref2[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
               kRefNullCode,          // field type: reference...
@@ -997,25 +1000,25 @@ TEST_F(WasmModuleVerifyTest, InvalidArrayTypeDef) {
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref2, "Unknown heap type");
 
-  static const byte invalid_mutability[] = {
+  static const uint8_t invalid_mutability[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
               kI32Code,              // field type
               2)};                   // invalid mutability value
   EXPECT_FAILURE_WITH_MSG(invalid_mutability, "invalid mutability");
 
-  static const byte immutable[] = {SECTION(Type,
-                                           ENTRY_COUNT(1),      // --
-                                           kWasmArrayTypeCode,  // --
-                                           kI32Code,            // field type
-                                           0)};                 // immmutability
+  static const uint8_t immutable[] = {SECTION(Type,
+                                              ENTRY_COUNT(1),      // --
+                                              kWasmArrayTypeCode,  // --
+                                              kI32Code,            // field type
+                                              0)};  // immmutability
   EXPECT_VERIFIES(immutable);
 }
 
 TEST_F(WasmModuleVerifyTest, TypeCanonicalization) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte identical_group[] = {
+  static const uint8_t identical_group[] = {
       SECTION(Type,            // --
               ENTRY_COUNT(2),  // two identical rec. groups
               kWasmRecursiveTypeGroupCode, ENTRY_COUNT(1),  // --
@@ -1031,7 +1034,7 @@ TEST_F(WasmModuleVerifyTest, TypeCanonicalization) {
   // Global initializer should verify as identical type in other group
   EXPECT_VERIFIES(identical_group);
 
-  static const byte non_identical_group[] = {
+  static const uint8_t non_identical_group[] = {
       SECTION(Type,            // --
               ENTRY_COUNT(2),  // two distrinct rec. groups
               kWasmRecursiveTypeGroupCode, ENTRY_COUNT(1),  // --
@@ -1055,7 +1058,7 @@ TEST_F(WasmModuleVerifyTest, TypeCanonicalization) {
 TEST_F(WasmModuleVerifyTest, InvalidSupertypeInRecGroup) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte invalid_supertype[] = {
+  static const uint8_t invalid_supertype[] = {
       SECTION(Type, ENTRY_COUNT(1),                         // --
               kWasmRecursiveTypeGroupCode, ENTRY_COUNT(2),  // --
               kWasmSubtypeCode, 0,              // 0 supertypes, non-final
@@ -1071,7 +1074,7 @@ TEST_F(WasmModuleVerifyTest, InvalidSupertypeInRecGroup) {
 TEST_F(WasmModuleVerifyTest, SuperTypeDeclarationWith0Supertypes) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte zero_supertypes[] = {
+  static const uint8_t zero_supertypes[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmSubtypeCode, 0,   // supertype count
               kWasmArrayTypeCode, kI32Code, 0)};
@@ -1082,7 +1085,7 @@ TEST_F(WasmModuleVerifyTest, SuperTypeDeclarationWith0Supertypes) {
 TEST_F(WasmModuleVerifyTest, NoSupertypeSupertype) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte no_supertype[] = {
+  static const uint8_t no_supertype[] = {
       SECTION(Type, ENTRY_COUNT(1),          // --
               kWasmSubtypeCode, 1,           // supertype count
               0xff, 0xff, 0xff, 0xff, 0x0f,  // supertype = "kNoSuperType"
@@ -1096,7 +1099,7 @@ TEST_F(WasmModuleVerifyTest, NonSpecifiedFinalType) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
   FLAG_SCOPE(wasm_final_types);
-  static const byte final_supertype[] = {
+  static const uint8_t final_supertype[] = {
       SECTION(Type, ENTRY_COUNT(2),                 // --
               kWasmStructTypeCode, 1, kI32Code, 1,  // --
               kWasmSubtypeCode, 1, 0,               // --
@@ -1108,7 +1111,7 @@ TEST_F(WasmModuleVerifyTest, SpecifiedFinalType) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
   FLAG_SCOPE(wasm_final_types);
-  static const byte final_supertype[] = {
+  static const uint8_t final_supertype[] = {
       SECTION(Type, ENTRY_COUNT(2),                 // --
               kWasmSubtypeFinalCode, 0,             // --
               kWasmStructTypeCode, 1, kI32Code, 1,  // --
@@ -1118,14 +1121,14 @@ TEST_F(WasmModuleVerifyTest, SpecifiedFinalType) {
 }
 
 TEST_F(WasmModuleVerifyTest, ZeroExceptions) {
-  static const byte data[] = {SECTION(Tag, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Tag, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_OK(result);
   EXPECT_EQ(0u, result.value()->tags.size());
 }
 
 TEST_F(WasmModuleVerifyTest, OneI32Exception) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_x(kI32Code)),  // sig#0 (i32)
       SECTION(Tag, ENTRY_COUNT(1),
               EXCEPTION_ENTRY(SIG_INDEX(0)))};  // except[0] (sig#0)
@@ -1139,7 +1142,7 @@ TEST_F(WasmModuleVerifyTest, OneI32Exception) {
 }
 
 TEST_F(WasmModuleVerifyTest, TwoExceptions) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(2),
               SIG_ENTRY_v_x(kI32Code),              // sig#0 (i32)
               SIG_ENTRY_v_xx(kF32Code, kI64Code)),  // sig#1 (f32, i64)
@@ -1158,7 +1161,7 @@ TEST_F(WasmModuleVerifyTest, TwoExceptions) {
 }
 
 TEST_F(WasmModuleVerifyTest, Exception_invalid_sig_index) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       SECTION(Tag, ENTRY_COUNT(1),
               EXCEPTION_ENTRY(
@@ -1169,7 +1172,7 @@ TEST_F(WasmModuleVerifyTest, Exception_invalid_sig_index) {
 }
 
 TEST_F(WasmModuleVerifyTest, Exception_invalid_sig_return) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_i_i),
       SECTION(Tag, ENTRY_COUNT(1),
               EXCEPTION_ENTRY(
@@ -1180,7 +1183,7 @@ TEST_F(WasmModuleVerifyTest, Exception_invalid_sig_return) {
 }
 
 TEST_F(WasmModuleVerifyTest, Exception_invalid_attribute) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_i_i),
       SECTION(Tag, ENTRY_COUNT(1), 23,
               SIG_INDEX(0))};  // except[0] (sig#0) [invalid-attribute]
@@ -1190,39 +1193,39 @@ TEST_F(WasmModuleVerifyTest, Exception_invalid_attribute) {
 }
 
 TEST_F(WasmModuleVerifyTest, TagSectionCorrectPlacement) {
-  static const byte data[] = {SECTION(Memory, ENTRY_COUNT(0)),
-                              SECTION(Tag, ENTRY_COUNT(0)),
-                              SECTION(Global, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Memory, ENTRY_COUNT(0)),
+                                 SECTION(Tag, ENTRY_COUNT(0)),
+                                 SECTION(Global, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_OK(result);
 }
 
 TEST_F(WasmModuleVerifyTest, TagSectionAfterGlobal) {
-  static const byte data[] = {SECTION(Global, ENTRY_COUNT(0)),
-                              SECTION(Tag, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Global, ENTRY_COUNT(0)),
+                                 SECTION(Tag, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result,
                 "The Tag section must appear before the Global section");
 }
 
 TEST_F(WasmModuleVerifyTest, TagSectionBeforeMemory) {
-  static const byte data[] = {SECTION(Tag, ENTRY_COUNT(0)),
-                              SECTION(Memory, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Tag, ENTRY_COUNT(0)),
+                                 SECTION(Memory, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "unexpected section <Memory>");
 }
 
 TEST_F(WasmModuleVerifyTest, TagSectionAfterTableBeforeMemory) {
   static_assert(kMemorySectionCode + 1 == kGlobalSectionCode);
-  static const byte data[] = {SECTION(Table, ENTRY_COUNT(0)),
-                              SECTION(Tag, ENTRY_COUNT(0)),
-                              SECTION(Memory, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Table, ENTRY_COUNT(0)),
+                                 SECTION(Tag, ENTRY_COUNT(0)),
+                                 SECTION(Memory, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "unexpected section <Memory>");
 }
 
 TEST_F(WasmModuleVerifyTest, TagImport) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       SECTION(Import,                           // section header
               ENTRY_COUNT(1),                   // number of imports
@@ -1237,7 +1240,7 @@ TEST_F(WasmModuleVerifyTest, TagImport) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExceptionExport) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       SECTION(Tag, ENTRY_COUNT(1),
               EXCEPTION_ENTRY(SIG_INDEX(0))),  // except[0] (sig#0)
@@ -1253,18 +1256,19 @@ TEST_F(WasmModuleVerifyTest, ExceptionExport) {
 
 TEST_F(WasmModuleVerifyTest, OneSignature) {
   {
-    static const byte data[] = {TYPE_SECTION_ONE_SIG_VOID_VOID};
+    static const uint8_t data[] = {TYPE_SECTION_ONE_SIG_VOID_VOID};
     EXPECT_VERIFIES(data);
   }
 
   {
-    static const byte data[] = {SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_i_i)};
+    static const uint8_t data[] = {
+        SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_i_i)};
     EXPECT_VERIFIES(data);
   }
 }
 
 TEST_F(WasmModuleVerifyTest, MultipleSignatures) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type,                                           // --
               ENTRY_COUNT(3),                                 // --
               SIG_ENTRY_v_v,                                  // void -> void
@@ -1292,7 +1296,7 @@ TEST_F(WasmModuleVerifyTest, CanonicalTypeIds) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type,                               // --
               ENTRY_COUNT(5),                     // --
               WASM_STRUCT_DEF(                    // Struct definition
@@ -1320,7 +1324,7 @@ TEST_F(WasmModuleVerifyTest, CanonicalTypeIds) {
 
 TEST_F(WasmModuleVerifyTest, DataSegmentWithImmutableImportedGlobal) {
   // Import 2 globals so that we can initialize data with a global index != 0.
-  const byte data[] = {
+  const uint8_t data[] = {
       SECTION(Import,           // section header
               ENTRY_COUNT(2),   // number of imports
               ADD_COUNT('m'),   // module name
@@ -1345,7 +1349,7 @@ TEST_F(WasmModuleVerifyTest, DataSegmentWithImmutableImportedGlobal) {
 
 TEST_F(WasmModuleVerifyTest, DataSegmentWithMutableImportedGlobal) {
   // Only an immutable imported global can be used as an init_expr.
-  const byte data[] = {
+  const uint8_t data[] = {
       SECTION(Import,           // section header
               ENTRY_COUNT(1),   // number of imports
               ADD_COUNT('m'),   // module name
@@ -1363,7 +1367,7 @@ TEST_F(WasmModuleVerifyTest, DataSegmentWithMutableImportedGlobal) {
 }
 TEST_F(WasmModuleVerifyTest, DataSegmentWithImmutableGlobal) {
   // Only an immutable imported global can be used as an init_expr.
-  const byte data[] = {
+  const uint8_t data[] = {
       SECTION(Memory, ENTRY_COUNT(1), kWithMaximum, 28, 28),
       SECTION(Global, ENTRY_COUNT(1),
               kI32Code,                         // local type
@@ -1378,8 +1382,8 @@ TEST_F(WasmModuleVerifyTest, DataSegmentWithImmutableGlobal) {
 }
 
 TEST_F(WasmModuleVerifyTest, OneDataSegment) {
-  const byte kDataSegmentSourceOffset = 24;
-  const byte data[] = {
+  const uint8_t kDataSegmentSourceOffset = 24;
+  const uint8_t data[] = {
       SECTION(Memory, ENTRY_COUNT(1), kWithMaximum, 28, 28),
       SECTION(Data, ENTRY_COUNT(1), LINEAR_MEMORY_INDEX_0,
               WASM_INIT_EXPR_I32V_3(0x9BBAA),  // dest addr
@@ -1405,10 +1409,10 @@ TEST_F(WasmModuleVerifyTest, OneDataSegment) {
 }
 
 TEST_F(WasmModuleVerifyTest, TwoDataSegments) {
-  const byte kDataSegment0SourceOffset = 24;
-  const byte kDataSegment1SourceOffset = kDataSegment0SourceOffset + 11;
+  const uint8_t kDataSegment0SourceOffset = 24;
+  const uint8_t kDataSegment1SourceOffset = kDataSegment0SourceOffset + 11;
 
-  const byte data[] = {
+  const uint8_t data[] = {
       SECTION(Memory, ENTRY_COUNT(1), kWithMaximum, 28, 28),
       SECTION(Data,
               ENTRY_COUNT(2),  // segment count
@@ -1443,7 +1447,7 @@ TEST_F(WasmModuleVerifyTest, TwoDataSegments) {
 }
 
 TEST_F(WasmModuleVerifyTest, DataWithoutMemory) {
-  const byte data[] = {
+  const uint8_t data[] = {
       SECTION(Data, ENTRY_COUNT(1), LINEAR_MEMORY_INDEX_0,
               WASM_INIT_EXPR_I32V_3(0x9BBAA),  // dest addr
               U32V_1(3),                       // source size
@@ -1454,12 +1458,12 @@ TEST_F(WasmModuleVerifyTest, DataWithoutMemory) {
 
 TEST_F(WasmModuleVerifyTest, MaxMaximumMemorySize) {
   {
-    const byte data[] = {
+    const uint8_t data[] = {
         SECTION(Memory, ENTRY_COUNT(1), kWithMaximum, 0, U32V_3(65536))};
     EXPECT_VERIFIES(data);
   }
   {
-    const byte data[] = {
+    const uint8_t data[] = {
         SECTION(Memory, ENTRY_COUNT(1), kWithMaximum, 0, U32V_3(65537))};
     EXPECT_FAILURE(data);
   }
@@ -1467,15 +1471,15 @@ TEST_F(WasmModuleVerifyTest, MaxMaximumMemorySize) {
 
 TEST_F(WasmModuleVerifyTest, InvalidMemoryLimits) {
   {
-    const byte kInvalidLimits = 0x15;
-    const byte data[] = {
+    const uint8_t kInvalidLimits = 0x15;
+    const uint8_t data[] = {
         SECTION(Memory, ENTRY_COUNT(1), kInvalidLimits, 0, 10)};
     EXPECT_FAILURE_WITH_MSG(data, "invalid memory limits flags 0x15");
   }
 }
 
 TEST_F(WasmModuleVerifyTest, DataSegment_wrong_init_type) {
-  const byte data[] = {
+  const uint8_t data[] = {
       SECTION(Memory, ENTRY_COUNT(1), kWithMaximum, 28, 28),
       SECTION(Data, ENTRY_COUNT(1), LINEAR_MEMORY_INDEX_0,
               WASM_INIT_EXPR_F64(9.9),  // dest addr
@@ -1487,7 +1491,7 @@ TEST_F(WasmModuleVerifyTest, DataSegment_wrong_init_type) {
 }
 
 TEST_F(WasmModuleVerifyTest, DataSegmentEndOverflow) {
-  const byte data[] = {
+  const uint8_t data[] = {
       SECTION(Memory,  // memory section
               ENTRY_COUNT(1), kWithMaximum, 28, 28),
       SECTION(Data,                      // data section
@@ -1501,7 +1505,7 @@ TEST_F(WasmModuleVerifyTest, DataSegmentEndOverflow) {
 }
 
 TEST_F(WasmModuleVerifyTest, OneIndirectFunction) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -1522,7 +1526,7 @@ TEST_F(WasmModuleVerifyTest, OneIndirectFunction) {
 }
 
 TEST_F(WasmModuleVerifyTest, ElementSectionWithInternalTable) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // table ---------------------------------------------------------------
       SECTION(Table, ENTRY_COUNT(1), kFuncRefCode, 0, 1),
       // elements ------------------------------------------------------------
@@ -1532,7 +1536,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionWithInternalTable) {
 }
 
 TEST_F(WasmModuleVerifyTest, ElementSectionWithImportedTable) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // imports -------------------------------------------------------------
       SECTION(Import, ENTRY_COUNT(1),
               ADD_COUNT('m'),  // module name
@@ -1549,7 +1553,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionWithImportedTable) {
 
 TEST_F(WasmModuleVerifyTest, ElementSectionWithoutTable) {
   // Test that an element section without a table causes a validation error.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // elements ------------------------------------------------------------
       SECTION(Element,
               ENTRY_COUNT(1),  // entry count
@@ -1563,7 +1567,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionWithoutTable) {
 
 TEST_F(WasmModuleVerifyTest, Regression_735887) {
   // Test with an invalid function index in the element section.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -1582,7 +1586,7 @@ TEST_F(WasmModuleVerifyTest, Regression_735887) {
 }
 
 TEST_F(WasmModuleVerifyTest, OneIndirectFunction_one_entry) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -1607,7 +1611,7 @@ TEST_F(WasmModuleVerifyTest, OneIndirectFunction_one_entry) {
 }
 
 TEST_F(WasmModuleVerifyTest, MultipleIndirectFunctions) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -------------------------------------------------------
       SECTION(Type,
               ENTRY_COUNT(2),            // --
@@ -1637,7 +1641,7 @@ TEST_F(WasmModuleVerifyTest, MultipleIndirectFunctions) {
 TEST_F(WasmModuleVerifyTest, ElementSectionMultipleTables) {
   // Test that if we have multiple tables, in the element section we can target
   // and initialize all tables.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -1668,7 +1672,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionMultipleTables) {
 TEST_F(WasmModuleVerifyTest, ElementSectionMixedTables) {
   // Test that if we have multiple tables, both imported and module-defined, in
   // the element section we can target and initialize all tables.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // imports -------------------------------------------------------------
@@ -1724,7 +1728,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionMixedTables) {
 TEST_F(WasmModuleVerifyTest, ElementSectionMultipleTablesArbitraryOrder) {
   // Test that the order in which tables are targeted in the element secion
   // can be arbitrary.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -1759,7 +1763,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionMultipleTablesArbitraryOrder) {
 TEST_F(WasmModuleVerifyTest, ElementSectionMixedTablesArbitraryOrder) {
   // Test that the order in which tables are targeted in the element secion can
   // be arbitrary. In this test, tables can be both imported and module-defined.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // imports -------------------------------------------------------------
@@ -1813,7 +1817,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionMixedTablesArbitraryOrder) {
 }
 
 TEST_F(WasmModuleVerifyTest, ElementSectionInitExternRefTableWithFuncRef) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs ---------------------------------------------------------------
@@ -1846,7 +1850,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionInitExternRefTableWithFuncRef) {
 }
 
 TEST_F(WasmModuleVerifyTest, ElementSectionInitFuncRefTableWithFuncRefNull) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // table declaration ---------------------------------------------------
       SECTION(Table, ENTRY_COUNT(1),  // section header
               kFuncRefCode, 0, 9),    // table 0
@@ -1864,7 +1868,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionInitFuncRefTableWithFuncRefNull) {
 }
 
 TEST_F(WasmModuleVerifyTest, ElementSectionInitFuncRefTableWithExternRefNull) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // table declaration ---------------------------------------------------
       SECTION(Table, ENTRY_COUNT(1),  // section header
               kFuncRefCode, 0, 9),    // table 0
@@ -1886,7 +1890,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionInitFuncRefTableWithExternRefNull) {
 TEST_F(WasmModuleVerifyTest, ElementSectionDontInitExternRefImportedTable) {
   // Test that imported tables of type ExternRef cannot be initialized in the
   // elements section.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 ---------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // imports -------------------------------------------------------------
@@ -1928,7 +1932,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionDontInitExternRefImportedTable) {
 }
 
 TEST_F(WasmModuleVerifyTest, ElementSectionGlobalGetOutOfBounds) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Element, ENTRY_COUNT(1),
               0x05,            // Mode: Passive with expressions-as-elements
               kFuncRefCode,    // type
@@ -1939,7 +1943,7 @@ TEST_F(WasmModuleVerifyTest, ElementSectionGlobalGetOutOfBounds) {
 
 // Make sure extended constants do not work without the experimental feature.
 TEST_F(WasmModuleVerifyTest, ExtendedConstantsFail) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import, ENTRY_COUNT(1),         // one import
               0x01, 'm', 0x01, 'g',           // module, name
               kExternalGlobal, kI32Code, 0),  // type, mutability
@@ -1954,7 +1958,7 @@ TEST_F(WasmModuleVerifyTest, ExtendedConstantsFail) {
 
 TEST_F(WasmModuleVerifyTest, ExtendedConstantsI32) {
   WASM_FEATURE_SCOPE(extended_const);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import, ENTRY_COUNT(1),         // one import
               0x01, 'm', 0x01, 'g',           // module, name
               kExternalGlobal, kI32Code, 0),  // type, mutability
@@ -1969,7 +1973,7 @@ TEST_F(WasmModuleVerifyTest, ExtendedConstantsI32) {
 
 TEST_F(WasmModuleVerifyTest, ExtendedConstantsI64) {
   WASM_FEATURE_SCOPE(extended_const);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import, ENTRY_COUNT(1),         // one import
               0x01, 'm', 0x01, 'g',           // module, name
               kExternalGlobal, kI64Code, 0),  // type, mutability
@@ -1984,7 +1988,7 @@ TEST_F(WasmModuleVerifyTest, ExtendedConstantsI64) {
 
 TEST_F(WasmModuleVerifyTest, ExtendedConstantsTypeError) {
   WASM_FEATURE_SCOPE(extended_const);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import, ENTRY_COUNT(1),         // one import
               0x01, 'm', 0x01, 'g',           // module, name
               kExternalGlobal, kI32Code, 0),  // type, mutability
@@ -1997,7 +2001,7 @@ TEST_F(WasmModuleVerifyTest, ExtendedConstantsTypeError) {
 }
 
 TEST_F(WasmModuleVerifyTest, IndirectFunctionNoFunctions) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // indirect table ----------------------------------------------
@@ -2007,7 +2011,7 @@ TEST_F(WasmModuleVerifyTest, IndirectFunctionNoFunctions) {
 }
 
 TEST_F(WasmModuleVerifyTest, IndirectFunctionInvalidIndex) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // functions ---------------------------------------------------
@@ -2019,7 +2023,7 @@ TEST_F(WasmModuleVerifyTest, IndirectFunctionInvalidIndex) {
 }
 
 TEST_F(WasmModuleVerifyTest, MultipleTables) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Table,           // table section
               ENTRY_COUNT(2),  // 2 tables
               kFuncRefCode,    // table 1: type
@@ -2045,7 +2049,7 @@ TEST_F(WasmModuleVerifyTest, MultipleTables) {
 TEST_F(WasmModuleVerifyTest, TypedFunctionTable) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_x(kI32Code)),
       SECTION(Table,            // table section
               ENTRY_COUNT(1),   // 1 table
@@ -2060,7 +2064,7 @@ TEST_F(WasmModuleVerifyTest, TypedFunctionTable) {
 TEST_F(WasmModuleVerifyTest, NullableTableIllegalInitializer) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_v),  // type section
       ONE_EMPTY_FUNCTION(0),                         // function section
       SECTION(Table,                                 // table section
@@ -2078,7 +2082,7 @@ TEST_F(WasmModuleVerifyTest, IllegalTableTypes) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
 
-  using Vec = std::vector<byte>;
+  using Vec = std::vector<uint8_t>;
 
   static Vec table_types[] = {{kI32Code}, {kF64Code}};
 
@@ -2087,13 +2091,13 @@ TEST_F(WasmModuleVerifyTest, IllegalTableTypes) {
         SECTION(Type, ENTRY_COUNT(2),
                 WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)),
                 WASM_ARRAY_DEF(kI32Code, true)),
-        kTableSectionCode, static_cast<byte>(type.size() + 3), byte{1}};
+        kTableSectionCode, static_cast<uint8_t>(type.size() + 3), uint8_t{1}};
     // Last elements are section size and entry count
 
     // Add table type
     data.insert(data.end(), type.begin(), type.end());
     // Add table limits
-    data.insert(data.end(), {byte{0}, byte{10}});
+    data.insert(data.end(), {uint8_t{0}, uint8_t{10}});
 
     auto result = DecodeModule(base::VectorOf(data));
     EXPECT_NOT_OK(result, "Only reference types can be used as table types");
@@ -2103,7 +2107,7 @@ TEST_F(WasmModuleVerifyTest, IllegalTableTypes) {
 TEST_F(WasmModuleVerifyTest, TableWithInitializer) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_v),  // type section
       ONE_EMPTY_FUNCTION(0),                         // function section
       SECTION(Table,                                 // table section
@@ -2122,7 +2126,7 @@ TEST_F(WasmModuleVerifyTest, TableWithInitializer) {
 TEST_F(WasmModuleVerifyTest, NonNullableTable) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_v),  // type section
       ONE_EMPTY_FUNCTION(0),                         // function section
       SECTION(Table,                                 // table section
@@ -2141,7 +2145,7 @@ TEST_F(WasmModuleVerifyTest, NonNullableTable) {
 TEST_F(WasmModuleVerifyTest, NonNullableTableNoInitializer) {
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_x(kI32Code)),
       SECTION(Table,           // table section
               ENTRY_COUNT(2),  // 2 tables
@@ -2156,7 +2160,7 @@ TEST_F(WasmModuleVerifyTest, NonNullableTableNoInitializer) {
 
 TEST_F(WasmModuleVerifyTest, TieringCompilationHints) {
   WASM_FEATURE_SCOPE(compilation_hints);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),
       FUNCTION_SECTION(3, 0, 0, 0),
       SECTION_COMPILATION_HINTS(BASELINE_TIER_BASELINE | TOP_TIER_BASELINE,
@@ -2191,7 +2195,7 @@ TEST_F(WasmModuleVerifyTest, TieringCompilationHints) {
 
 TEST_F(WasmModuleVerifyTest, BranchHinting) {
   WASM_FEATURE_SCOPE(branch_hinting);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v), FUNCTION_SECTION(2, 0, 0),
       SECTION_BRANCH_HINTS(ENTRY_COUNT(2), 0 /*func_index*/, ENTRY_COUNT(1),
                            3 /* if offset*/, 1 /*reserved*/, 1 /*likely*/,
@@ -2237,7 +2241,7 @@ class WasmSignatureDecodeTest : public TestWithZone {
 };
 
 TEST_F(WasmSignatureDecodeTest, Ok_v_v) {
-  static const byte data[] = {SIG_ENTRY_v_v};
+  static const uint8_t data[] = {SIG_ENTRY_v_v};
   v8::internal::AccountingAllocator allocator;
   Zone zone(&allocator, ZONE_NAME);
   const FunctionSig* sig = DecodeSig(base::ArrayVector(data));
@@ -2253,7 +2257,7 @@ TEST_F(WasmSignatureDecodeTest, Ok_t_v) {
   WASM_FEATURE_SCOPE(stringref);
   for (size_t i = 0; i < arraysize(kValueTypes); i++) {
     ValueTypePair ret_type = kValueTypes[i];
-    const byte data[] = {SIG_ENTRY_x(ret_type.code)};
+    const uint8_t data[] = {SIG_ENTRY_x(ret_type.code)};
     const FunctionSig* sig = DecodeSig(base::ArrayVector(data));
 
     SCOPED_TRACE("Return type " + ret_type.type.name());
@@ -2270,7 +2274,7 @@ TEST_F(WasmSignatureDecodeTest, Ok_v_t) {
   WASM_FEATURE_SCOPE(stringref);
   for (size_t i = 0; i < arraysize(kValueTypes); i++) {
     ValueTypePair param_type = kValueTypes[i];
-    const byte data[] = {SIG_ENTRY_v_x(param_type.code)};
+    const uint8_t data[] = {SIG_ENTRY_v_x(param_type.code)};
     const FunctionSig* sig = DecodeSig(base::ArrayVector(data));
 
     SCOPED_TRACE("Param type " + param_type.type.name());
@@ -2289,7 +2293,7 @@ TEST_F(WasmSignatureDecodeTest, Ok_t_t) {
     ValueTypePair ret_type = kValueTypes[i];
     for (size_t j = 0; j < arraysize(kValueTypes); j++) {
       ValueTypePair param_type = kValueTypes[j];
-      const byte data[] = {SIG_ENTRY_x_x(ret_type.code, param_type.code)};
+      const uint8_t data[] = {SIG_ENTRY_x_x(ret_type.code, param_type.code)};
       const FunctionSig* sig = DecodeSig(base::ArrayVector(data));
 
       SCOPED_TRACE("Param type " + param_type.type.name());
@@ -2310,7 +2314,7 @@ TEST_F(WasmSignatureDecodeTest, Ok_i_tt) {
     ValueTypePair p0_type = kValueTypes[i];
     for (size_t j = 0; j < arraysize(kValueTypes); j++) {
       ValueTypePair p1_type = kValueTypes[j];
-      const byte data[] = {
+      const uint8_t data[] = {
           SIG_ENTRY_x_xx(kI32Code, p0_type.code, p1_type.code)};
       const FunctionSig* sig = DecodeSig(base::ArrayVector(data));
 
@@ -2333,8 +2337,8 @@ TEST_F(WasmSignatureDecodeTest, Ok_tt_tt) {
     ValueTypePair p0_type = kValueTypes[i];
     for (size_t j = 0; j < arraysize(kValueTypes); j++) {
       ValueTypePair p1_type = kValueTypes[j];
-      const byte data[] = {SIG_ENTRY_xx_xx(p0_type.code, p1_type.code,
-                                           p0_type.code, p1_type.code)};
+      const uint8_t data[] = {SIG_ENTRY_xx_xx(p0_type.code, p1_type.code,
+                                              p0_type.code, p1_type.code)};
       const FunctionSig* sig = DecodeSig(base::ArrayVector(data));
 
       SCOPED_TRACE("p0 = " + p0_type.type.name() +
@@ -2352,7 +2356,7 @@ TEST_F(WasmSignatureDecodeTest, Ok_tt_tt) {
 
 TEST_F(WasmSignatureDecodeTest, Simd) {
   WASM_FEATURE_SCOPE(simd);
-  const byte data[] = {SIG_ENTRY_x(kS128Code)};
+  const uint8_t data[] = {SIG_ENTRY_x(kS128Code)};
   if (!CheckHardwareSupportsSimd()) {
     EXPECT_TRUE(DecodeSigError(base::ArrayVector(data)))
         << "Type S128 should not be allowed on this hardware";
@@ -2366,25 +2370,25 @@ TEST_F(WasmSignatureDecodeTest, Simd) {
 }
 
 TEST_F(WasmSignatureDecodeTest, TooManyParams) {
-  static const byte data[] = {kWasmFunctionTypeCode,
-                              WASM_I32V_3(kV8MaxWasmFunctionParams + 1),
-                              kI32Code, 0};
+  static const uint8_t data[] = {kWasmFunctionTypeCode,
+                                 WASM_I32V_3(kV8MaxWasmFunctionParams + 1),
+                                 kI32Code, 0};
   EXPECT_TRUE(DecodeSigError(base::ArrayVector(data)));
 }
 
 TEST_F(WasmSignatureDecodeTest, TooManyReturns) {
   for (int i = 0; i < 2; i++) {
-    byte data[] = {kWasmFunctionTypeCode, 0,
-                   WASM_I32V_3(kV8MaxWasmFunctionReturns + 1), kI32Code};
+    uint8_t data[] = {kWasmFunctionTypeCode, 0,
+                      WASM_I32V_3(kV8MaxWasmFunctionReturns + 1), kI32Code};
     EXPECT_TRUE(DecodeSigError(base::ArrayVector(data)));
   }
 }
 
 TEST_F(WasmSignatureDecodeTest, Fail_off_end) {
-  byte data[256];
+  uint8_t data[256];
   for (int p = 0; p <= 255; p = p + 1 + p * 3) {
     for (int i = 0; i <= p; i++) data[i] = kI32Code;
-    data[0] = static_cast<byte>(p);
+    data[0] = static_cast<uint8_t>(p);
 
     for (int i = 0; i < p + 1; i++) {
       // Should fall off the end for all signatures.
@@ -2394,9 +2398,9 @@ TEST_F(WasmSignatureDecodeTest, Fail_off_end) {
 }
 
 TEST_F(WasmSignatureDecodeTest, Fail_invalid_type) {
-  byte kInvalidType = 76;
+  uint8_t kInvalidType = 76;
   for (size_t i = 0;; i++) {
-    byte data[] = {SIG_ENTRY_x_xx(kI32Code, kI32Code, kI32Code)};
+    uint8_t data[] = {SIG_ENTRY_x_xx(kI32Code, kI32Code, kI32Code)};
     if (i >= arraysize(data)) break;
     data[i] = kInvalidType;
     EXPECT_TRUE(DecodeSigError(base::ArrayVector(data)));
@@ -2404,17 +2408,17 @@ TEST_F(WasmSignatureDecodeTest, Fail_invalid_type) {
 }
 
 TEST_F(WasmSignatureDecodeTest, Fail_invalid_ret_type1) {
-  static const byte data[] = {SIG_ENTRY_x_x(kVoidCode, kI32Code)};
+  static const uint8_t data[] = {SIG_ENTRY_x_x(kVoidCode, kI32Code)};
   EXPECT_TRUE(DecodeSigError(base::ArrayVector(data)));
 }
 
 TEST_F(WasmSignatureDecodeTest, Fail_invalid_param_type1) {
-  static const byte data[] = {SIG_ENTRY_x_x(kI32Code, kVoidCode)};
+  static const uint8_t data[] = {SIG_ENTRY_x_x(kI32Code, kVoidCode)};
   EXPECT_TRUE(DecodeSigError(base::ArrayVector(data)));
 }
 
 TEST_F(WasmSignatureDecodeTest, Fail_invalid_param_type2) {
-  static const byte data[] = {SIG_ENTRY_x_xx(kI32Code, kI32Code, kVoidCode)};
+  static const uint8_t data[] = {SIG_ENTRY_x_xx(kI32Code, kI32Code, kVoidCode)};
   EXPECT_TRUE(DecodeSigError(base::ArrayVector(data)));
 }
 
@@ -2429,7 +2433,7 @@ class WasmFunctionVerifyTest : public TestWithIsolateAndZone {
 };
 
 TEST_F(WasmFunctionVerifyTest, Ok_v_v_empty) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SIG_ENTRY_v_v,  // signature entry
       4,              // locals
       3,
@@ -2459,14 +2463,14 @@ TEST_F(WasmFunctionVerifyTest, Ok_v_v_empty) {
 }
 
 TEST_F(WasmModuleVerifyTest, SectionWithoutNameLength) {
-  const byte data[] = {1};
+  const uint8_t data[] = {1};
   EXPECT_FAILURE(data);
 }
 
 TEST_F(WasmModuleVerifyTest, EmptyCustomSectionIsInvalid) {
   // An empty custom section is invalid, because at least one byte for the
   // length of the custom section name is required.
-  const byte data[] = {
+  const uint8_t data[] = {
       0,  // unknown section code.
       0   // section length.
   };
@@ -2474,7 +2478,7 @@ TEST_F(WasmModuleVerifyTest, EmptyCustomSectionIsInvalid) {
 }
 
 TEST_F(WasmModuleVerifyTest, TheLoneliestOfValidModulesTheTrulyEmptyOne) {
-  const byte data[] = {
+  const uint8_t data[] = {
       0,  // unknown section code.
       1,  // section length, only one byte for the name length.
       0,  // string length of 0.
@@ -2484,14 +2488,14 @@ TEST_F(WasmModuleVerifyTest, TheLoneliestOfValidModulesTheTrulyEmptyOne) {
 }
 
 TEST_F(WasmModuleVerifyTest, OnlyUnknownSectionEmpty) {
-  const byte data[] = {
+  const uint8_t data[] = {
       UNKNOWN_SECTION(0),
   };
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, OnlyUnknownSectionNonEmpty) {
-  const byte data[] = {
+  const uint8_t data[] = {
       UNKNOWN_SECTION(5),
       0xFF,
       0xFF,
@@ -2503,7 +2507,7 @@ TEST_F(WasmModuleVerifyTest, OnlyUnknownSectionNonEmpty) {
 }
 
 TEST_F(WasmModuleVerifyTest, SignatureFollowedByEmptyUnknownSection) {
-  const byte data[] = {
+  const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // -----------------------------------------------------------
@@ -2512,7 +2516,7 @@ TEST_F(WasmModuleVerifyTest, SignatureFollowedByEmptyUnknownSection) {
 }
 
 TEST_F(WasmModuleVerifyTest, SignatureFollowedByUnknownSection) {
-  const byte data[] = {
+  const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // -----------------------------------------------------------
@@ -2527,7 +2531,7 @@ TEST_F(WasmModuleVerifyTest, SignatureFollowedByUnknownSection) {
 }
 
 TEST_F(WasmModuleVerifyTest, UnknownSectionOverflow) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       UNKNOWN_SECTION(9),
       1,
       2,
@@ -2544,7 +2548,7 @@ TEST_F(WasmModuleVerifyTest, UnknownSectionOverflow) {
 }
 
 TEST_F(WasmModuleVerifyTest, UnknownSectionUnderflow) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       UNKNOWN_SECTION(333),
       1,
       2,
@@ -2555,7 +2559,7 @@ TEST_F(WasmModuleVerifyTest, UnknownSectionUnderflow) {
 }
 
 TEST_F(WasmModuleVerifyTest, UnknownSectionSkipped) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       UNKNOWN_SECTION(1),
       0,  // one byte section
       SECTION(Global, ENTRY_COUNT(1),
@@ -2577,19 +2581,19 @@ TEST_F(WasmModuleVerifyTest, UnknownSectionSkipped) {
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_empty) {
-  static const byte data[] = {SECTION(Type, ENTRY_COUNT(0)),
-                              SECTION(Import, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Type, ENTRY_COUNT(0)),
+                                 SECTION(Import, ENTRY_COUNT(0))};
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_nosigs1) {
-  static const byte data[] = {SECTION(Import, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Import, ENTRY_COUNT(0))};
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_mutable_global) {
   {
-    static const byte data[] = {
+    static const uint8_t data[] = {
         SECTION(Import,           // section header
                 ENTRY_COUNT(1),   // number of imports
                 ADD_COUNT('m'),   // module name
@@ -2601,7 +2605,7 @@ TEST_F(WasmModuleVerifyTest, ImportTable_mutable_global) {
     EXPECT_VERIFIES(data);
   }
   {
-    static const byte data[] = {
+    static const uint8_t data[] = {
         SECTION(Import,           // section header
                 ENTRY_COUNT(1),   // sig table
                 ADD_COUNT('m'),   // module name
@@ -2615,7 +2619,7 @@ TEST_F(WasmModuleVerifyTest, ImportTable_mutable_global) {
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_mutability_malformed) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import,
               ENTRY_COUNT(1),   // --
               ADD_COUNT('m'),   // module name
@@ -2628,7 +2632,7 @@ TEST_F(WasmModuleVerifyTest, ImportTable_mutability_malformed) {
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_nosigs2) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Import, ENTRY_COUNT(1),  // sig table
               ADD_COUNT('m'),          // module name
               ADD_COUNT('f'),          // function name
@@ -2639,7 +2643,7 @@ TEST_F(WasmModuleVerifyTest, ImportTable_nosigs2) {
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_invalid_sig) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(0)),   // --
       SECTION(Import, ENTRY_COUNT(1),  // --
               ADD_COUNT('m'),          // module name
@@ -2651,7 +2655,7 @@ TEST_F(WasmModuleVerifyTest, ImportTable_invalid_sig) {
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_one_sig) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       SECTION(Import,
@@ -2665,7 +2669,7 @@ TEST_F(WasmModuleVerifyTest, ImportTable_one_sig) {
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_invalid_module) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID,  // --
       SECTION(Import,                  // --
@@ -2680,7 +2684,7 @@ TEST_F(WasmModuleVerifyTest, ImportTable_invalid_module) {
 }
 
 TEST_F(WasmModuleVerifyTest, ImportTable_off_end) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       SECTION(Import, ENTRY_COUNT(1),
@@ -2694,11 +2698,11 @@ TEST_F(WasmModuleVerifyTest, ImportTable_off_end) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExportTable_empty1) {
-  static const byte data[] = {                                 // signatures
-                              TYPE_SECTION_ONE_SIG_VOID_VOID,  // --
-                              ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
-                              SECTION(Export, ENTRY_COUNT(0)),  // --
-                              ONE_EMPTY_BODY};
+  static const uint8_t data[] = {                                 // signatures
+                                 TYPE_SECTION_ONE_SIG_VOID_VOID,  // --
+                                 ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
+                                 SECTION(Export, ENTRY_COUNT(0)),  // --
+                                 ONE_EMPTY_BODY};
 
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_OK(result);
@@ -2708,18 +2712,18 @@ TEST_F(WasmModuleVerifyTest, ExportTable_empty1) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExportTable_empty2) {
-  static const byte data[] = {SECTION(Type, ENTRY_COUNT(0)),
-                              SECTION(Export, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Type, ENTRY_COUNT(0)),
+                                 SECTION(Export, ENTRY_COUNT(0))};
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, ExportTable_NoFunctions2) {
-  static const byte data[] = {SECTION(Export, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Export, ENTRY_COUNT(0))};
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, ExportTableOne) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID, ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
       SECTION(Export,
@@ -2736,7 +2740,7 @@ TEST_F(WasmModuleVerifyTest, ExportTableOne) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExportNameWithInvalidStringLength) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID, ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
       SECTION(Export,
@@ -2752,7 +2756,7 @@ TEST_F(WasmModuleVerifyTest, ExportNameWithInvalidStringLength) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExportTableTwo) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID, ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
       SECTION(Export,
@@ -2773,7 +2777,7 @@ TEST_F(WasmModuleVerifyTest, ExportTableTwo) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExportTableThree) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID, THREE_EMPTY_FUNCTIONS(SIG_INDEX(0)),
       SECTION(Export,
@@ -2797,7 +2801,7 @@ TEST_F(WasmModuleVerifyTest, ExportTableThree) {
 
 TEST_F(WasmModuleVerifyTest, ExportTableThreeOne) {
   for (int i = 0; i < 6; i++) {
-    const byte data[] = {
+    const uint8_t data[] = {
         // signatures
         TYPE_SECTION_ONE_SIG_VOID_VOID, THREE_EMPTY_FUNCTIONS(SIG_INDEX(0)),
         SECTION(Export,
@@ -2816,7 +2820,7 @@ TEST_F(WasmModuleVerifyTest, ExportTableThreeOne) {
 }
 
 TEST_F(WasmModuleVerifyTest, ExportTableOne_off_end) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // signatures
       TYPE_SECTION_ONE_SIG_VOID_VOID, ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
       SECTION(Export,
@@ -2831,7 +2835,7 @@ TEST_F(WasmModuleVerifyTest, ExportTableOne_off_end) {
 }
 
 TEST_F(WasmModuleVerifyTest, Regression_648070) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(0)),         // --
       SECTION(Function, U32V_5(3500228624))  // function count = 3500228624
   };                                         // --
@@ -2840,7 +2844,7 @@ TEST_F(WasmModuleVerifyTest, Regression_648070) {
 
 TEST_F(WasmModuleVerifyTest, Regression_738097) {
   // The function body size caused an integer overflow in the module decoder.
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),  // --
       FUNCTION_SECTION(1, 0),          // --
       SECTION(Code,                    // --
@@ -2855,7 +2859,7 @@ TEST_F(WasmModuleVerifyTest, FunctionBodySizeLimit) {
   const uint32_t delta = 3;
   for (uint32_t body_size = kV8MaxWasmFunctionSize - delta;
        body_size < kV8MaxWasmFunctionSize + delta; body_size++) {
-    byte data[] = {
+    uint8_t data[] = {
         TYPE_SECTION(1, SIG_ENTRY_v_v),  // --
         FUNCTION_SECTION(1, 0),          // --
         kCodeSectionCode,                // code section
@@ -2864,7 +2868,7 @@ TEST_F(WasmModuleVerifyTest, FunctionBodySizeLimit) {
         U32V_5(body_size)                // body size
     };
     size_t total = sizeof(data) + body_size;
-    byte* buffer = reinterpret_cast<byte*>(calloc(1, total));
+    uint8_t* buffer = reinterpret_cast<uint8_t*>(calloc(1, total));
     memcpy(buffer, data, sizeof(data));
     ModuleResult result = DecodeModule(base::VectorOf(buffer, total));
     if (body_size <= kV8MaxWasmFunctionSize) {
@@ -2877,12 +2881,12 @@ TEST_F(WasmModuleVerifyTest, FunctionBodySizeLimit) {
 }
 
 TEST_F(WasmModuleVerifyTest, IllegalTypeCode) {
-  static const byte data[] = {TYPE_SECTION(1, SIG_ENTRY_v_x(0x41))};
+  static const uint8_t data[] = {TYPE_SECTION(1, SIG_ENTRY_v_x(0x41))};
   EXPECT_FAILURE_WITH_MSG(data, "invalid value type");
 }
 
 TEST_F(WasmModuleVerifyTest, FunctionBodies_empty) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       EMPTY_TYPE_SECTION,            // --
       EMPTY_FUNCTION_SECTION,        // --
       EMPTY_FUNCTION_BODIES_SECTION  // --
@@ -2891,7 +2895,7 @@ TEST_F(WasmModuleVerifyTest, FunctionBodies_empty) {
 }
 
 TEST_F(WasmModuleVerifyTest, FunctionBodies_one_empty) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),  // --
       FUNCTION_SECTION(1, 0),          // --
       ONE_EMPTY_BODY                   // --
@@ -2900,7 +2904,7 @@ TEST_F(WasmModuleVerifyTest, FunctionBodies_one_empty) {
 }
 
 TEST_F(WasmModuleVerifyTest, FunctionBodies_one_nop) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),          // --
       FUNCTION_SECTION(1, 0),                  // --
       SECTION(Code, ENTRY_COUNT(1), NOP_BODY)  // --
@@ -2909,7 +2913,7 @@ TEST_F(WasmModuleVerifyTest, FunctionBodies_one_nop) {
 }
 
 TEST_F(WasmModuleVerifyTest, FunctionBodies_count_mismatch1) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),  // --
       FUNCTION_SECTION(2, 0, 0),       // --
       ONE_EMPTY_BODY                   // --
@@ -2918,7 +2922,7 @@ TEST_F(WasmModuleVerifyTest, FunctionBodies_count_mismatch1) {
 }
 
 TEST_F(WasmModuleVerifyTest, FunctionBodies_count_mismatch2) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),                    // --
       FUNCTION_SECTION(1, 0),                            // --
       SECTION(Code, ENTRY_COUNT(2), NOP_BODY, NOP_BODY)  // --
@@ -2927,16 +2931,16 @@ TEST_F(WasmModuleVerifyTest, FunctionBodies_count_mismatch2) {
 }
 
 TEST_F(WasmModuleVerifyTest, Names_empty) {
-  static const byte data[] = {EMPTY_TYPE_SECTION, EMPTY_FUNCTION_SECTION,
-                              EMPTY_FUNCTION_BODIES_SECTION,
-                              EMPTY_NAMES_SECTION};
+  static const uint8_t data[] = {EMPTY_TYPE_SECTION, EMPTY_FUNCTION_SECTION,
+                                 EMPTY_FUNCTION_BODIES_SECTION,
+                                 EMPTY_NAMES_SECTION};
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, Names_one_empty) {
   // TODO(wasm): This test does not test anything (corrupt name section does not
   // fail validation).
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),                            // --
       FUNCTION_SECTION(1, 0),                                    // --
       ONE_EMPTY_BODY,                                            // --
@@ -2948,7 +2952,7 @@ TEST_F(WasmModuleVerifyTest, Names_one_empty) {
 TEST_F(WasmModuleVerifyTest, Names_two_empty) {
   // TODO(wasm): This test does not test anything (corrupt name section does not
   // fail validation).
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),             // --
       FUNCTION_SECTION(2, 0, 0),                  // --
       TWO_EMPTY_BODIES,                           // --
@@ -2960,7 +2964,7 @@ TEST_F(WasmModuleVerifyTest, Names_two_empty) {
 }
 
 TEST_F(WasmModuleVerifyTest, Regression684855) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION_NAMES(0xFB,  // functions count
                     0x27,  // |
                     0x00,  // function name length
@@ -2978,7 +2982,7 @@ TEST_F(WasmModuleVerifyTest, Regression684855) {
 }
 
 TEST_F(WasmModuleVerifyTest, FunctionSectionWithoutCodeSection) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       TYPE_SECTION(1, SIG_ENTRY_v_v),  // Type section.
       FUNCTION_SECTION(1, 0),          // Function section.
   };
@@ -2987,26 +2991,26 @@ TEST_F(WasmModuleVerifyTest, FunctionSectionWithoutCodeSection) {
 }
 
 TEST_F(WasmModuleVerifyTest, CodeSectionWithoutFunctionSection) {
-  static const byte data[] = {ONE_EMPTY_BODY};
+  static const uint8_t data[] = {ONE_EMPTY_BODY};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "function body count 1 mismatch (0 expected)");
 }
 
 TEST_F(WasmModuleVerifyTest, EmptyFunctionSectionWithoutCodeSection) {
-  static const byte data[] = {SECTION(Function, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Function, ENTRY_COUNT(0))};
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, DoubleNonEmptyFunctionSection) {
   // Regression test for https://crbug.com/1342274.
-  static const byte data[] = {TYPE_SECTION(1, SIG_ENTRY_v_v),  // --
-                              FUNCTION_SECTION(1, 0),          // --
-                              FUNCTION_SECTION(1, 0)};
+  static const uint8_t data[] = {TYPE_SECTION(1, SIG_ENTRY_v_v),  // --
+                                 FUNCTION_SECTION(1, 0),          // --
+                                 FUNCTION_SECTION(1, 0)};
   EXPECT_FAILURE(data);
 }
 
 TEST_F(WasmModuleVerifyTest, EmptyCodeSectionWithoutFunctionSection) {
-  static const byte data[] = {SECTION(Code, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Code, ENTRY_COUNT(0))};
   EXPECT_VERIFIES(data);
 }
 
@@ -3015,7 +3019,7 @@ TEST_F(WasmModuleVerifyTest, EmptyCodeSectionWithoutFunctionSection) {
 // form.
 
 TEST_F(WasmModuleVerifyTest, Multiple_Named_Sections) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Unknown, ADD_COUNT('X'), 17, 18),                    // --
       SECTION(Unknown, ADD_COUNT('f', 'o', 'o'), 5, 6, 7, 8, 9),   // --
       SECTION(Unknown, ADD_COUNT('o', 't', 'h', 'e', 'r'), 7, 8),  // --
@@ -3024,7 +3028,7 @@ TEST_F(WasmModuleVerifyTest, Multiple_Named_Sections) {
 }
 
 TEST_F(WasmModuleVerifyTest, Section_Name_No_UTF8) {
-  static const byte data[] = {SECTION(Unknown, 1, 0xFF, 17, 18)};
+  static const uint8_t data[] = {SECTION(Unknown, 1, 0xFF, 17, 18)};
   EXPECT_FAILURE(data);
 }
 
@@ -3053,7 +3057,7 @@ class WasmModuleCustomSectionTest : public TestWithIsolateAndZone {
 };
 
 TEST_F(WasmModuleCustomSectionTest, ThreeUnknownSections) {
-  static constexpr byte data[] = {
+  static constexpr uint8_t data[] = {
       U32_LE(kWasmMagic),                                  // --
       U32_LE(kWasmVersion),                                // --
       SECTION(Unknown, 1, 'X', 17, 18),                    // --
@@ -3072,7 +3076,7 @@ TEST_F(WasmModuleCustomSectionTest, ThreeUnknownSections) {
 }
 
 TEST_F(WasmModuleCustomSectionTest, TwoKnownTwoUnknownSections) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       U32_LE(kWasmMagic),                                          // --
       U32_LE(kWasmVersion),                                        // --
       TYPE_SECTION(2, SIG_ENTRY_v_v, SIG_ENTRY_v_v),               // --
@@ -3091,7 +3095,7 @@ TEST_F(WasmModuleCustomSectionTest, TwoKnownTwoUnknownSections) {
 }
 
 TEST_F(WasmModuleVerifyTest, SourceMappingURLSection) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       WASM_MODULE_HEADER,
       SECTION_SRC_MAP('s', 'r', 'c', '/', 'x', 'y', 'z', '.', 'c')};
   ModuleResult result = DecodeModuleNoHeader(base::ArrayVector(data));
@@ -3105,7 +3109,7 @@ TEST_F(WasmModuleVerifyTest, SourceMappingURLSection) {
 }
 
 TEST_F(WasmModuleVerifyTest, BadSourceMappingURLSection) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       WASM_MODULE_HEADER,
       SECTION_SRC_MAP('s', 'r', 'c', '/', 'x', 0xff, 'z', '.', 'c')};
   ModuleResult result = DecodeModuleNoHeader(base::ArrayVector(data));
@@ -3115,9 +3119,9 @@ TEST_F(WasmModuleVerifyTest, BadSourceMappingURLSection) {
 }
 
 TEST_F(WasmModuleVerifyTest, MultipleSourceMappingURLSections) {
-  static const byte data[] = {WASM_MODULE_HEADER,
-                              SECTION_SRC_MAP('a', 'b', 'c'),
-                              SECTION_SRC_MAP('p', 'q', 'r')};
+  static const uint8_t data[] = {WASM_MODULE_HEADER,
+                                 SECTION_SRC_MAP('a', 'b', 'c'),
+                                 SECTION_SRC_MAP('p', 'q', 'r')};
   ModuleResult result = DecodeModuleNoHeader(base::ArrayVector(data));
   EXPECT_TRUE(result.ok());
   EXPECT_EQ(WasmDebugSymbols::Type::SourceMap,
@@ -3129,7 +3133,7 @@ TEST_F(WasmModuleVerifyTest, MultipleSourceMappingURLSections) {
 }
 
 TEST_F(WasmModuleVerifyTest, MultipleNameSections) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION_NAMES(0, ADD_COUNT(ADD_COUNT('a', 'b', 'c'))),
       SECTION_NAMES(0, ADD_COUNT(ADD_COUNT('p', 'q', 'r', 's')))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
@@ -3138,7 +3142,7 @@ TEST_F(WasmModuleVerifyTest, MultipleNameSections) {
 }
 
 TEST_F(WasmModuleVerifyTest, BadNameSection) {
-  static const byte data[] = {SECTION_NAMES(
+  static const uint8_t data[] = {SECTION_NAMES(
       0, ADD_COUNT(ADD_COUNT('s', 'r', 'c', '/', 'x', 0xff, 'z', '.', 'c')))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_TRUE(result.ok());
@@ -3146,7 +3150,7 @@ TEST_F(WasmModuleVerifyTest, BadNameSection) {
 }
 
 TEST_F(WasmModuleVerifyTest, PassiveDataSegment) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // memory declaration ----------------------------------------------------
       SECTION(Memory, ENTRY_COUNT(1), 0, 1),
       // data segments  --------------------------------------------------------
@@ -3157,7 +3161,7 @@ TEST_F(WasmModuleVerifyTest, PassiveDataSegment) {
 }
 
 TEST_F(WasmModuleVerifyTest, ActiveElementSegmentWithElements) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -----------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs -----------------------------------------------------------------
@@ -3175,7 +3179,7 @@ TEST_F(WasmModuleVerifyTest, ActiveElementSegmentWithElements) {
 }
 
 TEST_F(WasmModuleVerifyTest, PassiveElementSegment) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -----------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs -----------------------------------------------------------------
@@ -3193,7 +3197,7 @@ TEST_F(WasmModuleVerifyTest, PassiveElementSegment) {
 }
 
 TEST_F(WasmModuleVerifyTest, PassiveElementSegmentExternRef) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -----------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs -----------------------------------------------------------------
@@ -3209,7 +3213,7 @@ TEST_F(WasmModuleVerifyTest, PassiveElementSegmentExternRef) {
 }
 
 TEST_F(WasmModuleVerifyTest, PassiveElementSegmentWithIndices) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -----------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs -----------------------------------------------------------------
@@ -3226,7 +3230,7 @@ TEST_F(WasmModuleVerifyTest, PassiveElementSegmentWithIndices) {
 }
 
 TEST_F(WasmModuleVerifyTest, DeclarativeElementSegmentFuncRef) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -----------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs -----------------------------------------------------------------
@@ -3243,7 +3247,7 @@ TEST_F(WasmModuleVerifyTest, DeclarativeElementSegmentFuncRef) {
 }
 
 TEST_F(WasmModuleVerifyTest, DeclarativeElementSegmentWithInvalidIndex) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // sig#0 -----------------------------------------------------------------
       TYPE_SECTION_ONE_SIG_VOID_VOID,
       // funcs -----------------------------------------------------------------
@@ -3262,30 +3266,30 @@ TEST_F(WasmModuleVerifyTest, DeclarativeElementSegmentWithInvalidIndex) {
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSectionCorrectPlacement) {
-  static const byte data[] = {SECTION(Element, ENTRY_COUNT(0)),
-                              SECTION(DataCount, ENTRY_COUNT(0)),
-                              SECTION(Code, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Element, ENTRY_COUNT(0)),
+                                 SECTION(DataCount, ENTRY_COUNT(0)),
+                                 SECTION(Code, ENTRY_COUNT(0))};
   EXPECT_VERIFIES(data);
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSectionAfterCode) {
-  static const byte data[] = {SECTION(Code, ENTRY_COUNT(0)),
-                              SECTION(DataCount, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(Code, ENTRY_COUNT(0)),
+                                 SECTION(DataCount, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result,
                 "The DataCount section must appear before the Code section");
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSectionBeforeElement) {
-  static const byte data[] = {SECTION(DataCount, ENTRY_COUNT(0)),
-                              SECTION(Element, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(DataCount, ENTRY_COUNT(0)),
+                                 SECTION(Element, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "unexpected section <Element>");
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSectionAfterStartBeforeElement) {
   static_assert(kStartSectionCode + 1 == kElementSectionCode);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       // We need the start section for this test, but the start section must
       // reference a valid function, which requires the type and function
       // sections too.
@@ -3300,14 +3304,14 @@ TEST_F(WasmModuleVerifyTest, DataCountSectionAfterStartBeforeElement) {
 }
 
 TEST_F(WasmModuleVerifyTest, MultipleDataCountSections) {
-  static const byte data[] = {SECTION(DataCount, ENTRY_COUNT(0)),
-                              SECTION(DataCount, ENTRY_COUNT(0))};
+  static const uint8_t data[] = {SECTION(DataCount, ENTRY_COUNT(0)),
+                                 SECTION(DataCount, ENTRY_COUNT(0))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "Multiple DataCount sections not allowed");
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSegmentCountMatch) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Memory, ENTRY_COUNT(1), 0, 1),  // Memory section.
       SECTION(DataCount, ENTRY_COUNT(1)),     // DataCount section.
       SECTION(Data, ENTRY_COUNT(1), LINEAR_MEMORY_INDEX_0,  // Data section.
@@ -3317,7 +3321,7 @@ TEST_F(WasmModuleVerifyTest, DataCountSegmentCountMatch) {
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_greater) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Memory, ENTRY_COUNT(1), 0, 1),  // Memory section.
       SECTION(DataCount, ENTRY_COUNT(3)),     // DataCount section.
       SECTION(Data, ENTRY_COUNT(0))};         // Data section.
@@ -3326,7 +3330,7 @@ TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_greater) {
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_less) {
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Memory, ENTRY_COUNT(1), 0, 1),  // Memory section.
       SECTION(DataCount, ENTRY_COUNT(0)),     // DataCount section.
       SECTION(Data, ENTRY_COUNT(1), LINEAR_MEMORY_INDEX_0,  // Data section.
@@ -3336,8 +3340,8 @@ TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_less) {
 }
 
 TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_omitted) {
-  static const byte data[] = {SECTION(Memory, ENTRY_COUNT(1), 0, 1),
-                              SECTION(DataCount, ENTRY_COUNT(1))};
+  static const uint8_t data[] = {SECTION(Memory, ENTRY_COUNT(1), 0, 1),
+                                 SECTION(DataCount, ENTRY_COUNT(1))};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "data segments count 0 mismatch (1 expected)");
 }
@@ -3346,7 +3350,7 @@ TEST_F(WasmModuleVerifyTest, GcStructIdsPass) {
   WASM_FEATURE_SCOPE(gc);
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  static const byte data[] = {SECTION(
+  static const uint8_t data[] = {SECTION(
       Type, ENTRY_COUNT(1),                         // One recursive group...
       kWasmRecursiveTypeGroupCode, ENTRY_COUNT(3),  // with three entries.
       WASM_STRUCT_DEF(FIELD_COUNT(3), STRUCT_FIELD(kI32Code, true),
@@ -3361,7 +3365,7 @@ TEST_F(WasmModuleVerifyTest, GcStructIdsPass) {
 
 TEST_F(WasmModuleVerifyTest, OutOfBoundsTypeInGlobal) {
   WASM_FEATURE_SCOPE(typed_funcref);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Global, ENTRY_COUNT(1), kRefCode, 0, WASM_REF_NULL(0), kExprEnd)};
   ModuleResult result = DecodeModule(base::ArrayVector(data));
   EXPECT_NOT_OK(result, "Type index 0 is out of bounds");
@@ -3370,7 +3374,7 @@ TEST_F(WasmModuleVerifyTest, OutOfBoundsTypeInGlobal) {
 TEST_F(WasmModuleVerifyTest, OutOfBoundsTypeInType) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte data[] = {SECTION(
+  static const uint8_t data[] = {SECTION(
       Type, ENTRY_COUNT(1),
       WASM_STRUCT_DEF(FIELD_COUNT(1),
                       STRUCT_FIELD(WASM_REF_TYPE(ValueType::Ref(1)), true)))};
@@ -3381,7 +3385,7 @@ TEST_F(WasmModuleVerifyTest, OutOfBoundsTypeInType) {
 TEST_F(WasmModuleVerifyTest, RecursiveTypeOutsideRecursiveGroup) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1),
               WASM_STRUCT_DEF(
                   FIELD_COUNT(1),
@@ -3393,7 +3397,7 @@ TEST_F(WasmModuleVerifyTest, RecursiveTypeOutsideRecursiveGroup) {
 TEST_F(WasmModuleVerifyTest, OutOfBoundsSupertype) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), kWasmRecursiveTypeGroupCode, ENTRY_COUNT(1),
               kWasmSubtypeCode, ENTRY_COUNT(1), 1,
               WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)))};
@@ -3404,7 +3408,7 @@ TEST_F(WasmModuleVerifyTest, OutOfBoundsSupertype) {
 TEST_F(WasmModuleVerifyTest, ForwardSupertypeSameType) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), kWasmRecursiveTypeGroupCode, ENTRY_COUNT(1),
               kWasmSubtypeCode, ENTRY_COUNT(1), 0,
               WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)))};
@@ -3415,7 +3419,7 @@ TEST_F(WasmModuleVerifyTest, ForwardSupertypeSameType) {
 TEST_F(WasmModuleVerifyTest, ForwardSupertypeSameRecGroup) {
   WASM_FEATURE_SCOPE(typed_funcref);
   WASM_FEATURE_SCOPE(gc);
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Type, ENTRY_COUNT(1), kWasmRecursiveTypeGroupCode, ENTRY_COUNT(2),
               kWasmSubtypeCode, ENTRY_COUNT(1), 0,
               WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)),
@@ -3428,7 +3432,7 @@ TEST_F(WasmModuleVerifyTest, IllegalPackedFields) {
   WASM_FEATURE_SCOPE(gc);
   WASM_FEATURE_SCOPE(typed_funcref);
 
-  static const byte data[] = {
+  static const uint8_t data[] = {
       SECTION(Global, ENTRY_COUNT(1), kI16Code, 0, WASM_INIT_EXPR_I32V_1(13))};
 
   ModuleResult result = DecodeModule(base::ArrayVector(data));
@@ -3440,8 +3444,8 @@ TEST_F(WasmModuleVerifyTest, Memory64DataSegment) {
   WASM_FEATURE_SCOPE(memory64);
   for (bool enable_memory64 : {false, true}) {
     for (bool use_memory64 : {false, true}) {
-      byte const_opcode = use_memory64 ? kExprI64Const : kExprI32Const;
-      const byte data[] = {
+      uint8_t const_opcode = use_memory64 ? kExprI64Const : kExprI32Const;
+      const uint8_t data[] = {
           SECTION(Memory, ENTRY_COUNT(1),
                   enable_memory64 ? kMemory64WithMaximum : kWithMaximum, 28,
                   28),
diff --git a/test/unittests/wasm/streaming-decoder-unittest.cc b/test/unittests/wasm/streaming-decoder-unittest.cc
index 176088e8179..7fc355bed71 100644
--- a/test/unittests/wasm/streaming-decoder-unittest.cc
+++ b/test/unittests/wasm/streaming-decoder-unittest.cc
@@ -30,7 +30,7 @@ struct MockStreamingResult {
 
 class NoTracer {
  public:
-  void Bytes(const byte* start, uint32_t count) {}
+  void Bytes(const uint8_t* start, uint32_t count) {}
   void Description(const char* desc) {}
 };
 
diff --git a/test/unittests/wasm/wasm-disassembler-unittest.cc b/test/unittests/wasm/wasm-disassembler-unittest.cc
index de10a363da2..3e1120f30e1 100644
--- a/test/unittests/wasm/wasm-disassembler-unittest.cc
+++ b/test/unittests/wasm/wasm-disassembler-unittest.cc
@@ -20,7 +20,7 @@ class WasmDisassemblerTest : public ::v8::TestWithPlatform {};
 
 // Code that is shared for all tests, the only difference is the input module
 // and expected disassembler output.
-void CheckDisassemblerOutput(base::Vector<const byte> module_bytes,
+void CheckDisassemblerOutput(base::Vector<const uint8_t> module_bytes,
                              std::string expected_output) {
   AccountingAllocator allocator;
 
@@ -62,7 +62,7 @@ TEST_F(WasmDisassemblerTest, Mvp) {
   // wat2wasm wasm-disassembler-unittest-mvp.wat.inc --output=-
   // | wami --full-hexdump
   // | head -n-1 | tail -n+2 > wasm-disassembler-unittest-mvp.wasm.inc
-  constexpr byte module_bytes[] = {
+  constexpr uint8_t module_bytes[] = {
 #include "wasm-disassembler-unittest-mvp.wasm.inc"
   };
 
@@ -84,7 +84,7 @@ TEST_F(WasmDisassemblerTest, Mvp) {
 TEST_F(WasmDisassemblerTest, Names) {
   // You can create a binary with a custom name section from the text format via
   // `wat2wasm --debug-names`.
-  constexpr byte module_bytes[] = {
+  constexpr uint8_t module_bytes[] = {
 #include "wasm-disassembler-unittest-names.wasm.inc"
   };
   std::string expected;
@@ -93,7 +93,7 @@ TEST_F(WasmDisassemblerTest, Names) {
 }
 
 TEST_F(WasmDisassemblerTest, InvalidNameSection) {
-  constexpr byte module_bytes[] = {
+  constexpr uint8_t module_bytes[] = {
 #include "wasm-disassembler-unittest-bad-name-section.wasm.inc"
   };
   std::string expected(
@@ -104,7 +104,7 @@ TEST_F(WasmDisassemblerTest, InvalidNameSection) {
 }
 
 TEST_F(WasmDisassemblerTest, Simd) {
-  constexpr byte module_bytes[] = {
+  constexpr uint8_t module_bytes[] = {
 #include "wasm-disassembler-unittest-simd.wasm.inc"
   };
   std::string expected;
@@ -115,7 +115,7 @@ TEST_F(WasmDisassemblerTest, Simd) {
 TEST_F(WasmDisassemblerTest, Gc) {
   // Since WABT's `wat2wasm` didn't support some GC features yet, I used
   // Binaryen's `wasm-as --enable-gc --hybrid` here to produce the binary.
-  constexpr byte module_bytes[] = {
+  constexpr uint8_t module_bytes[] = {
 #include "wasm-disassembler-unittest-gc.wasm.inc"
   };
   std::string expected;
@@ -124,7 +124,7 @@ TEST_F(WasmDisassemblerTest, Gc) {
 }
 
 TEST_F(WasmDisassemblerTest, TooManyends) {
-  constexpr byte module_bytes[] = {
+  constexpr uint8_t module_bytes[] = {
 #include "wasm-disassembler-unittest-too-many-ends.wasm.inc"
   };
   std::string expected;
@@ -133,7 +133,7 @@ TEST_F(WasmDisassemblerTest, TooManyends) {
 }
 
 TEST_F(WasmDisassemblerTest, Stringref) {
-  constexpr byte module_bytes[] = {
+  constexpr uint8_t module_bytes[] = {
 #include "wasm-disassembler-unittest-stringref.wasm.inc"
   };
   std::string expected;
diff --git a/test/unittests/wasm/wasm-macro-gen-unittest.cc b/test/unittests/wasm/wasm-macro-gen-unittest.cc
index 3a308d46d86..338b01bf23a 100644
--- a/test/unittests/wasm/wasm-macro-gen-unittest.cc
+++ b/test/unittests/wasm/wasm-macro-gen-unittest.cc
@@ -14,7 +14,7 @@ class WasmMacroGenTest : public TestWithZone {};
 
 #define EXPECT_SIZE(size, ...)                          \
   do {                                                  \
-    byte code[] = {__VA_ARGS__};                        \
+    uint8_t code[] = {__VA_ARGS__};                     \
     USE(code);                                          \
     EXPECT_EQ(static_cast<size_t>(size), sizeof(code)); \
   } while (false)
diff --git a/test/unittests/wasm/wasm-module-builder-unittest.cc b/test/unittests/wasm/wasm-module-builder-unittest.cc
index 2bfe2b6df5e..cb26e713f3e 100644
--- a/test/unittests/wasm/wasm-module-builder-unittest.cc
+++ b/test/unittests/wasm/wasm-module-builder-unittest.cc
@@ -28,7 +28,7 @@ TEST_F(WasmModuleBuilderTest, Regression_647329) {
   // Test crashed with asan.
   ZoneBuffer buffer(zone());
   const size_t kSize = ZoneBuffer::kInitialSize * 3 + 4096 + 100;
-  byte data[kSize] = {0};
+  uint8_t data[kSize] = {0};
   buffer.write(data, kSize);
 }
 
diff --git a/test/wasm-api-tests/callbacks.cc b/test/wasm-api-tests/callbacks.cc
index 55de2db0104..5e4acf7add6 100644
--- a/test/wasm-api-tests/callbacks.cc
+++ b/test/wasm-api-tests/callbacks.cc
@@ -43,14 +43,14 @@ class WasmCapiCallbacksTest : public WasmCapiTest {
     // int32 stage1(int32 arg0) { return stage2(arg0); }
     uint32_t stage2_index =
         builder()->AddImport(base::CStrVector("stage2"), wasm_i_i_sig());
-    byte code[] = {WASM_CALL_FUNCTION(stage2_index, WASM_LOCAL_GET(0))};
+    uint8_t code[] = {WASM_CALL_FUNCTION(stage2_index, WASM_LOCAL_GET(0))};
     AddExportedFunction(base::CStrVector("stage1"), code, sizeof(code));
 
     stage2_ = Func::make(store(), cpp_i_i_sig(), Stage2, this);
   }
 
   Func* stage2() { return stage2_.get(); }
-  void AddExportedFunction(base::Vector<const char> name, byte code[],
+  void AddExportedFunction(base::Vector<const char> name, uint8_t code[],
                            size_t code_size) {
     WasmCapiTest::AddExportedFunction(name, code, code_size, wasm_i_i_sig());
   }
@@ -64,7 +64,7 @@ class WasmCapiCallbacksTest : public WasmCapiTest {
 TEST_F(WasmCapiCallbacksTest, Trap) {
   // Build the following function:
   // int32 stage3_trap(int32 arg0) { unreachable(); }
-  byte code[] = {WASM_UNREACHABLE};
+  uint8_t code[] = {WASM_UNREACHABLE};
   AddExportedFunction(base::CStrVector("stage3_trap"), code, sizeof(code));
 
   Extern* imports[] = {stage2()};
@@ -81,7 +81,7 @@ TEST_F(WasmCapiCallbacksTest, GC) {
   // int32 stage3_to4(int32 arg0) { return stage4(arg0); }
   uint32_t stage4_index =
       builder()->AddImport(base::CStrVector("stage4"), wasm_i_i_sig());
-  byte code[] = {WASM_CALL_FUNCTION(stage4_index, WASM_LOCAL_GET(0))};
+  uint8_t code[] = {WASM_CALL_FUNCTION(stage4_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("stage3_to4"), code, sizeof(code));
 
   i::Isolate* isolate =
@@ -134,7 +134,7 @@ TEST_F(WasmCapiTest, Recursion) {
   // }
   uint32_t fibo_c_index =
       builder()->AddImport(base::CStrVector("fibonacci_c"), wasm_i_i_sig());
-  byte code_fibo[] = {
+  uint8_t code_fibo[] = {
       WASM_IF(WASM_I32_EQ(WASM_LOCAL_GET(0), WASM_ZERO),
               WASM_RETURN(WASM_ZERO)),
       WASM_IF(WASM_I32_EQ(WASM_LOCAL_GET(0), WASM_ONE), WASM_RETURN(WASM_ONE)),
diff --git a/test/wasm-api-tests/finalize.cc b/test/wasm-api-tests/finalize.cc
index 77cd5884491..06a01aa86b2 100644
--- a/test/wasm-api-tests/finalize.cc
+++ b/test/wasm-api-tests/finalize.cc
@@ -40,7 +40,7 @@ void RunInStore(Store* store, base::Vector<const uint8_t> wire_bytes,
                 int iterations) {
   vec<byte_t> binary = vec<byte_t>::make(
       wire_bytes.size(),
-      reinterpret_cast<byte_t*>(const_cast<byte*>(wire_bytes.begin())));
+      reinterpret_cast<byte_t*>(const_cast<uint8_t*>(wire_bytes.begin())));
   own<Module> module = Module::make(store, binary);
   module->set_host_info(reinterpret_cast<void*>(kModuleMagic), &FinalizeModule);
   for (int iteration = 0; iteration < iterations; iteration++) {
@@ -66,7 +66,7 @@ void RunInStore(Store* store, base::Vector<const uint8_t> wire_bytes,
 
 TEST_F(WasmCapiTest, InstanceFinalization) {
   // Add a dummy function: f(x) { return x; }
-  byte code[] = {WASM_RETURN(WASM_LOCAL_GET(0))};
+  uint8_t code[] = {WASM_RETURN(WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("f"), code, sizeof(code),
                       wasm_i_i_sig());
   Compile();
diff --git a/test/wasm-api-tests/globals.cc b/test/wasm-api-tests/globals.cc
index 7f693d9cebe..f5e844a5278 100644
--- a/test/wasm-api-tests/globals.cc
+++ b/test/wasm-api-tests/globals.cc
@@ -47,45 +47,45 @@ TEST_F(WasmCapiTest, Globals) {
   ValueType i64_type[] = {kWasmI64};
   FunctionSig return_f32(1, 0, f32_type);
   FunctionSig return_i64(1, 0, i64_type);
-  byte gcfi[] = {WASM_GLOBAL_GET(cfi_index)};
+  uint8_t gcfi[] = {WASM_GLOBAL_GET(cfi_index)};
   AddExportedFunction(base::CStrVector("get const f32 import"), gcfi,
                       sizeof(gcfi), &return_f32);
-  byte gcii[] = {WASM_GLOBAL_GET(cii_index)};
+  uint8_t gcii[] = {WASM_GLOBAL_GET(cii_index)};
   AddExportedFunction(base::CStrVector("get const i64 import"), gcii,
                       sizeof(gcii), &return_i64);
-  byte gvfi[] = {WASM_GLOBAL_GET(vfi_index)};
+  uint8_t gvfi[] = {WASM_GLOBAL_GET(vfi_index)};
   AddExportedFunction(base::CStrVector("get var f32 import"), gvfi,
                       sizeof(gvfi), &return_f32);
-  byte gvii[] = {WASM_GLOBAL_GET(vii_index)};
+  uint8_t gvii[] = {WASM_GLOBAL_GET(vii_index)};
   AddExportedFunction(base::CStrVector("get var i64 import"), gvii,
                       sizeof(gvii), &return_i64);
 
-  byte gcfe[] = {WASM_GLOBAL_GET(cfe_index)};
+  uint8_t gcfe[] = {WASM_GLOBAL_GET(cfe_index)};
   AddExportedFunction(base::CStrVector("get const f32 export"), gcfe,
                       sizeof(gcfe), &return_f32);
-  byte gcie[] = {WASM_GLOBAL_GET(cie_index)};
+  uint8_t gcie[] = {WASM_GLOBAL_GET(cie_index)};
   AddExportedFunction(base::CStrVector("get const i64 export"), gcie,
                       sizeof(gcie), &return_i64);
-  byte gvfe[] = {WASM_GLOBAL_GET(vfe_index)};
+  uint8_t gvfe[] = {WASM_GLOBAL_GET(vfe_index)};
   AddExportedFunction(base::CStrVector("get var f32 export"), gvfe,
                       sizeof(gvfe), &return_f32);
-  byte gvie[] = {WASM_GLOBAL_GET(vie_index)};
+  uint8_t gvie[] = {WASM_GLOBAL_GET(vie_index)};
   AddExportedFunction(base::CStrVector("get var i64 export"), gvie,
                       sizeof(gvie), &return_i64);
 
   // Define functions for manipulating globals.
   FunctionSig param_f32(0, 1, f32_type);
   FunctionSig param_i64(0, 1, i64_type);
-  byte svfi[] = {WASM_GLOBAL_SET(vfi_index, WASM_LOCAL_GET(0))};
+  uint8_t svfi[] = {WASM_GLOBAL_SET(vfi_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("set var f32 import"), svfi,
                       sizeof(svfi), &param_f32);
-  byte svii[] = {WASM_GLOBAL_SET(vii_index, WASM_LOCAL_GET(0))};
+  uint8_t svii[] = {WASM_GLOBAL_SET(vii_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("set var i64 import"), svii,
                       sizeof(svii), &param_i64);
-  byte svfe[] = {WASM_GLOBAL_SET(vfe_index, WASM_LOCAL_GET(0))};
+  uint8_t svfe[] = {WASM_GLOBAL_SET(vfe_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("set var f32 export"), svfe,
                       sizeof(svfe), &param_f32);
-  byte svie[] = {WASM_GLOBAL_SET(vie_index, WASM_LOCAL_GET(0))};
+  uint8_t svie[] = {WASM_GLOBAL_SET(vie_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("set var i64 export"), svie,
                       sizeof(svie), &param_i64);
 
diff --git a/test/wasm-api-tests/hostref.cc b/test/wasm-api-tests/hostref.cc
index fb6181b26aa..09b722a795e 100644
--- a/test/wasm-api-tests/hostref.cc
+++ b/test/wasm-api-tests/hostref.cc
@@ -39,20 +39,22 @@ TEST_F(WasmCapiTest, HostRef) {
       base::CStrVector("global"));
   uint32_t table_index = builder()->AddTable(kWasmExternRef, 10);
   builder()->AddExport(base::CStrVector("table"), kExternalTable, table_index);
-  byte global_set_code[] = {WASM_GLOBAL_SET(global_index, WASM_LOCAL_GET(0))};
+  uint8_t global_set_code[] = {
+      WASM_GLOBAL_SET(global_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("global.set"), global_set_code,
                       sizeof(global_set_code), &v_r_sig);
-  byte global_get_code[] = {WASM_GLOBAL_GET(global_index)};
+  uint8_t global_get_code[] = {WASM_GLOBAL_GET(global_index)};
   AddExportedFunction(base::CStrVector("global.get"), global_get_code,
                       sizeof(global_get_code), &r_v_sig);
-  byte table_set_code[] = {
+  uint8_t table_set_code[] = {
       WASM_TABLE_SET(table_index, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
   AddExportedFunction(base::CStrVector("table.set"), table_set_code,
                       sizeof(table_set_code), &v_ir_sig);
-  byte table_get_code[] = {WASM_TABLE_GET(table_index, WASM_LOCAL_GET(0))};
+  uint8_t table_get_code[] = {WASM_TABLE_GET(table_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("table.get"), table_get_code,
                       sizeof(table_get_code), &r_i_sig);
-  byte func_call_code[] = {WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0))};
+  uint8_t func_call_code[] = {
+      WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("func.call"), func_call_code,
                       sizeof(func_call_code), &r_r_sig);
 
diff --git a/test/wasm-api-tests/memory.cc b/test/wasm-api-tests/memory.cc
index 43da93b357e..cd4217c103c 100644
--- a/test/wasm-api-tests/memory.cc
+++ b/test/wasm-api-tests/memory.cc
@@ -20,18 +20,18 @@ TEST_F(WasmCapiTest, Memory) {
   FunctionSig return_i32(1, 0, i32_type);
   FunctionSig param_i32_return_i32(1, 1, i32_type);
   FunctionSig param_i32_i32(0, 2, i32_type);
-  byte size_code[] = {WASM_MEMORY_SIZE};
+  uint8_t size_code[] = {WASM_MEMORY_SIZE};
   AddExportedFunction(base::CStrVector("size"), size_code, sizeof(size_code),
                       &return_i32);
-  byte load_code[] = {WASM_LOAD_MEM(MachineType::Int8(), WASM_LOCAL_GET(0))};
+  uint8_t load_code[] = {WASM_LOAD_MEM(MachineType::Int8(), WASM_LOCAL_GET(0))};
   AddExportedFunction(base::CStrVector("load"), load_code, sizeof(load_code),
                       &param_i32_return_i32);
-  byte store_code[] = {WASM_STORE_MEM(MachineType::Int8(), WASM_LOCAL_GET(0),
-                                      WASM_LOCAL_GET(1))};
+  uint8_t store_code[] = {WASM_STORE_MEM(MachineType::Int8(), WASM_LOCAL_GET(0),
+                                         WASM_LOCAL_GET(1))};
   AddExportedFunction(base::CStrVector("store"), store_code, sizeof(store_code),
                       &param_i32_i32);
 
-  byte data[] = {0x1, 0x2, 0x3, 0x4};
+  uint8_t data[] = {0x1, 0x2, 0x3, 0x4};
   builder()->AddDataSegment(data, sizeof(data), 0x1000);
 
   Instantiate(nullptr);
diff --git a/test/wasm-api-tests/multi-return.cc b/test/wasm-api-tests/multi-return.cc
index 51fdfbfe0f1..c3e30fa8f88 100644
--- a/test/wasm-api-tests/multi-return.cc
+++ b/test/wasm-api-tests/multi-return.cc
@@ -28,9 +28,9 @@ TEST_F(WasmCapiTest, MultiReturn) {
                       kWasmI32, kWasmI64, kWasmI64, kWasmI32};
   FunctionSig sig(4, 4, reps);
   uint32_t func_index = builder()->AddImport(base::CStrVector("f"), &sig);
-  byte code[] = {WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0),
-                                    WASM_LOCAL_GET(2), WASM_LOCAL_GET(1),
-                                    WASM_LOCAL_GET(3))};
+  uint8_t code[] = {WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0),
+                                       WASM_LOCAL_GET(2), WASM_LOCAL_GET(1),
+                                       WASM_LOCAL_GET(3))};
   AddExportedFunction(base::CStrVector("g"), code, sizeof(code), &sig);
 
   ownvec<ValType> types =
diff --git a/test/wasm-api-tests/reflect.cc b/test/wasm-api-tests/reflect.cc
index 9831e693bb6..994ff844492 100644
--- a/test/wasm-api-tests/reflect.cc
+++ b/test/wasm-api-tests/reflect.cc
@@ -34,7 +34,7 @@ void ExpectName(const char* expected, const ::wasm::Name& name) {
 
 TEST_F(WasmCapiTest, Reflect) {
   // Create a module exporting a function, a global, a table, and a memory.
-  byte code[] = {WASM_UNREACHABLE};
+  uint8_t code[] = {WASM_UNREACHABLE};
   ValueType types[] = {kWasmI32, kWasmExternRef, kWasmI32,
                        kWasmI64, kWasmF32,       kWasmF64};
   FunctionSig sig(2, 4, types);
diff --git a/test/wasm-api-tests/regressions.cc b/test/wasm-api-tests/regressions.cc
index ba5e98ba9f5..12babfc0169 100644
--- a/test/wasm-api-tests/regressions.cc
+++ b/test/wasm-api-tests/regressions.cc
@@ -10,7 +10,7 @@ namespace wasm {
 
 TEST_F(WasmCapiTest, Regressions) {
   FunctionSig sig(0, 0, nullptr);
-  byte code[] = {WASM_UNREACHABLE};
+  uint8_t code[] = {WASM_UNREACHABLE};
   WasmFunctionBuilder* start_func = builder()->AddFunction(&sig);
   start_func->EmitCode(code, static_cast<uint32_t>(sizeof(code)));
   start_func->Emit(kExprEnd);
diff --git a/test/wasm-api-tests/serialize.cc b/test/wasm-api-tests/serialize.cc
index 80af51855d3..8036555c2e5 100644
--- a/test/wasm-api-tests/serialize.cc
+++ b/test/wasm-api-tests/serialize.cc
@@ -25,7 +25,7 @@ TEST_F(WasmCapiTest, Serialize) {
   FunctionSig sig(0, 0, nullptr);
   uint32_t callback_index =
       builder()->AddImport(base::CStrVector("callback"), &sig);
-  byte code[] = {WASM_CALL_FUNCTION0(callback_index)};
+  uint8_t code[] = {WASM_CALL_FUNCTION0(callback_index)};
   AddExportedFunction(base::CStrVector("run"), code, sizeof(code), &sig);
   Compile();
 
diff --git a/test/wasm-api-tests/startup-errors.cc b/test/wasm-api-tests/startup-errors.cc
index 26fdbfc6c7f..a1dba58ef18 100644
--- a/test/wasm-api-tests/startup-errors.cc
+++ b/test/wasm-api-tests/startup-errors.cc
@@ -16,7 +16,7 @@ own<Trap> DummyCallback(const Val args[], Val results[]) { return nullptr; }
 
 TEST_F(WasmCapiTest, StartupErrors) {
   FunctionSig sig(0, 0, nullptr);
-  byte code[] = {WASM_UNREACHABLE};
+  uint8_t code[] = {WASM_UNREACHABLE};
   WasmFunctionBuilder* start_func = builder()->AddFunction(&sig);
   start_func->EmitCode(code, static_cast<uint32_t>(sizeof(code)));
   start_func->Emit(kExprEnd);
diff --git a/test/wasm-api-tests/table.cc b/test/wasm-api-tests/table.cc
index 4425a678f08..9ffad8ee145 100644
--- a/test/wasm-api-tests/table.cc
+++ b/test/wasm-api-tests/table.cc
@@ -42,14 +42,14 @@ TEST_F(WasmCapiTest, Table) {
   const uint32_t sig_i_i_index = builder()->AddSignature(wasm_i_i_sig(), true);
   ValueType reps[] = {kWasmI32, kWasmI32, kWasmI32};
   FunctionSig call_sig(1, 2, reps);
-  byte call_code[] = {
+  uint8_t call_code[] = {
       WASM_CALL_INDIRECT(sig_i_i_index, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
   AddExportedFunction(base::CStrVector("call_indirect"), call_code,
                       sizeof(call_code), &call_sig);
-  byte f_code[] = {WASM_LOCAL_GET(0)};
+  uint8_t f_code[] = {WASM_LOCAL_GET(0)};
   AddExportedFunction(base::CStrVector("f"), f_code, sizeof(f_code),
                       wasm_i_i_sig());
-  byte g_code[] = {WASM_I32V_1(42)};
+  uint8_t g_code[] = {WASM_I32V_1(42)};
   AddExportedFunction(base::CStrVector("g"), g_code, sizeof(g_code),
                       wasm_i_i_sig());
   // Set table[1] to {f}, which has function index 1.
diff --git a/test/wasm-api-tests/threads.cc b/test/wasm-api-tests/threads.cc
index c85a773f0d1..14b9b03fd3f 100644
--- a/test/wasm-api-tests/threads.cc
+++ b/test/wasm-api-tests/threads.cc
@@ -65,7 +65,7 @@ TEST_F(WasmCapiTest, Threads) {
   uint32_t global_index =
       builder()->AddGlobalImport(base::CStrVector("id"), kWasmI32, false);
 
-  byte code[] = {
+  uint8_t code[] = {
       WASM_CALL_FUNCTION(callback_index, WASM_GLOBAL_GET(global_index))};
   FunctionSig empty_sig(0, 0, nullptr);
   AddExportedFunction(base::CStrVector("run"), code, sizeof(code), &empty_sig);
diff --git a/test/wasm-api-tests/traps.cc b/test/wasm-api-tests/traps.cc
index e5f71a13aab..27f17c6207b 100644
--- a/test/wasm-api-tests/traps.cc
+++ b/test/wasm-api-tests/traps.cc
@@ -39,19 +39,19 @@ TEST_F(WasmCapiTest, Traps) {
   FunctionSig sig(1, 0, i32_type);
   uint32_t callback_index =
       builder()->AddImport(base::CStrVector("callback"), &sig);
-  byte code[] = {WASM_CALL_FUNCTION0(callback_index)};
+  uint8_t code[] = {WASM_CALL_FUNCTION0(callback_index)};
   AddExportedFunction(base::CStrVector("callback"), code, sizeof(code), &sig);
 
-  byte code2[] = {WASM_CALL_FUNCTION0(3)};
+  uint8_t code2[] = {WASM_CALL_FUNCTION0(3)};
   AddExportedFunction(base::CStrVector("unreachable"), code2, sizeof(code2),
                       &sig);
   // The first constant is a 4-byte dummy so that the {unreachable} trap
   // has a more interesting offset. This is called by code2.
-  byte code3[] = {WASM_I32V_3(0), WASM_UNREACHABLE, WASM_I32V_1(1)};
+  uint8_t code3[] = {WASM_I32V_3(0), WASM_UNREACHABLE, WASM_I32V_1(1)};
   AddFunction(code3, sizeof(code3), &sig);
 
   // Check that traps returned from a C callback are uncatchable in Wasm.
-  byte code4[] = {WASM_TRY_CATCH_ALL_T(
+  uint8_t code4[] = {WASM_TRY_CATCH_ALL_T(
       kWasmI32, WASM_CALL_FUNCTION0(callback_index), WASM_I32V(42))};
   AddExportedFunction(base::CStrVector("uncatchable"), code4, sizeof(code4),
                       &sig);
diff --git a/test/wasm-api-tests/wasm-api-test.h b/test/wasm-api-tests/wasm-api-test.h
index 31c7fc1b021..4b45f40450f 100644
--- a/test/wasm-api-tests/wasm-api-test.h
+++ b/test/wasm-api-tests/wasm-api-test.h
@@ -60,7 +60,7 @@ class WasmCapiTest : public ::testing::Test {
       size_t size = wire_bytes_.end() - wire_bytes_.begin();
       binary_ = vec<byte_t>::make(
           size,
-          reinterpret_cast<byte_t*>(const_cast<byte*>(wire_bytes_.begin())));
+          reinterpret_cast<byte_t*>(const_cast<uint8_t*>(wire_bytes_.begin())));
     }
 
     return Module::validate(store_.get(), binary_);
@@ -72,7 +72,7 @@ class WasmCapiTest : public ::testing::Test {
       size_t size = wire_bytes_.end() - wire_bytes_.begin();
       binary_ = vec<byte_t>::make(
           size,
-          reinterpret_cast<byte_t*>(const_cast<byte*>(wire_bytes_.begin())));
+          reinterpret_cast<byte_t*>(const_cast<uint8_t*>(wire_bytes_.begin())));
     }
 
     module_ = Module::make(store_.get(), binary_);
@@ -86,7 +86,7 @@ class WasmCapiTest : public ::testing::Test {
     exports_ = instance_->exports();
   }
 
-  void AddExportedFunction(base::Vector<const char> name, byte code[],
+  void AddExportedFunction(base::Vector<const char> name, uint8_t code[],
                            size_t code_size, FunctionSig* sig) {
     WasmFunctionBuilder* fun = builder()->AddFunction(sig);
     fun->EmitCode(code, static_cast<uint32_t>(code_size));
@@ -94,7 +94,7 @@ class WasmCapiTest : public ::testing::Test {
     builder()->AddExport(name, fun);
   }
 
-  void AddFunction(byte code[], size_t code_size, FunctionSig* sig) {
+  void AddFunction(uint8_t code[], size_t code_size, FunctionSig* sig) {
     WasmFunctionBuilder* fun = builder()->AddFunction(sig);
     fun->EmitCode(code, static_cast<uint32_t>(code_size));
     fun->Emit(kExprEnd);
-- 
2.35.1


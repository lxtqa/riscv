From 04b8124b343271eb8ee590aa7382ee194d659a06 Mon Sep 17 00:00:00 2001
From: Thibaud Michaud <thibaudm@chromium.org>
Date: Fri, 8 Apr 2022 11:33:42 +0200
Subject: [PATCH] [wasm] Clean up type size computation

Rename element_size_bytes() to value_kind_size(), and add
the uncompressed version: value_kind_full_size().

R=clemensb@chromium.org

Change-Id: I956142937fd1134ecbdaaa617c402ed8fff2cf17
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3568477
Reviewed-by: Clemens Backes <clemensb@chromium.org>
Commit-Queue: Thibaud Michaud <thibaudm@chromium.org>
Cr-Commit-Position: refs/heads/main@{#79884}
---
 src/compiler/wasm-compiler.cc                 | 33 +++++++++---------
 src/heap/factory.cc                           |  2 +-
 src/runtime/runtime-wasm.cc                   |  2 +-
 src/wasm/baseline/arm/liftoff-assembler-arm.h |  4 +--
 .../baseline/arm64/liftoff-assembler-arm64.h  |  4 +--
 .../baseline/ia32/liftoff-assembler-ia32.h    |  8 ++---
 src/wasm/baseline/liftoff-assembler.cc        |  4 +--
 src/wasm/baseline/liftoff-compiler.cc         | 28 ++++++++-------
 .../loong64/liftoff-assembler-loong64.h       |  4 +--
 .../baseline/mips/liftoff-assembler-mips.h    |  4 +--
 .../mips64/liftoff-assembler-mips64.h         |  4 +--
 src/wasm/baseline/ppc/liftoff-assembler-ppc.h |  4 +--
 .../riscv64/liftoff-assembler-riscv64.h       |  4 +--
 .../baseline/s390/liftoff-assembler-s390.h    |  4 +--
 src/wasm/baseline/x64/liftoff-assembler-x64.h | 17 ++++------
 src/wasm/function-body-decoder-impl.h         |  2 +-
 src/wasm/init-expr-interface.cc               |  2 +-
 src/wasm/module-decoder.cc                    |  2 +-
 src/wasm/module-instantiate.cc                |  2 +-
 src/wasm/struct-types.h                       |  4 +--
 src/wasm/value-type.h                         | 34 +++++++++++++------
 src/wasm/wasm-arguments.h                     |  4 +--
 src/wasm/wasm-external-refs.cc                |  2 +-
 src/wasm/wasm-objects-inl.h                   |  4 +--
 src/wasm/wasm-objects.cc                      |  6 ++--
 src/wasm/wasm-objects.h                       |  2 +-
 src/wasm/wasm-value.h                         |  6 ++--
 test/cctest/wasm/wasm-run-utils.cc            |  2 +-
 28 files changed, 103 insertions(+), 95 deletions(-)

diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 5ac75f32ca6..6dda13e53cd 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -482,8 +482,7 @@ class WasmGraphAssembler : public GraphAssembler {
         mcgraph()->machine()->Is64() ? ChangeUint32ToUint64(index) : index;
     return IntAdd(
         IntPtrConstant(wasm::ObjectAccess::ToTagged(WasmArray::kHeaderSize)),
-        IntMul(index_intptr,
-               IntPtrConstant(element_type.element_size_bytes())));
+        IntMul(index_intptr, IntPtrConstant(element_type.value_kind_size())));
   }
 
   Node* LoadWasmArrayLength(Node* array) {
@@ -1637,7 +1636,7 @@ Node* WasmGraphBuilder::BuildChangeEndiannessStore(
   Node* result;
   Node* value = node;
   MachineOperatorBuilder* m = mcgraph()->machine();
-  int valueSizeInBytes = wasmtype.element_size_bytes();
+  int valueSizeInBytes = wasmtype.value_kind_size();
   int valueSizeInBits = 8 * valueSizeInBytes;
   bool isFloat = false;
 
@@ -1671,7 +1670,7 @@ Node* WasmGraphBuilder::BuildChangeEndiannessStore(
     // In case we store lower part of WasmI64 expression, we can truncate
     // upper 32bits
     value = gasm_->TruncateInt64ToInt32(value);
-    valueSizeInBytes = wasm::kWasmI32.element_size_bytes();
+    valueSizeInBytes = wasm::kWasmI32.value_kind_size();
     valueSizeInBits = 8 * valueSizeInBytes;
     if (mem_rep == MachineRepresentation::kWord16) {
       value = gasm_->Word32Shl(value, Int32Constant(16));
@@ -3885,7 +3884,7 @@ WasmGraphBuilder::BoundsCheckMem(uint8_t access_size, Node* index,
 
 const Operator* WasmGraphBuilder::GetSafeLoadOperator(int offset,
                                                       wasm::ValueType type) {
-  int alignment = offset % type.element_size_bytes();
+  int alignment = offset % type.value_kind_size();
   MachineType mach_type = type.machine_type();
   if (COMPRESS_POINTERS_BOOL && mach_type.IsTagged()) {
     // We are loading tagged value from off-heap location, so we need to load
@@ -3901,7 +3900,7 @@ const Operator* WasmGraphBuilder::GetSafeLoadOperator(int offset,
 
 const Operator* WasmGraphBuilder::GetSafeStoreOperator(int offset,
                                                        wasm::ValueType type) {
-  int alignment = offset % type.element_size_bytes();
+  int alignment = offset % type.value_kind_size();
   MachineRepresentation rep = type.machine_representation();
   if (COMPRESS_POINTERS_BOOL && IsAnyTagged(rep)) {
     // We are storing tagged value to off-heap location, so we need to store
@@ -5638,9 +5637,9 @@ Node* WasmGraphBuilder::ArrayNewWithRtt(uint32_t array_index,
   // Do NOT mark this as Operator::kEliminatable, because that would cause the
   // Call node to have no control inputs, which means it could get scheduled
   // before the check/trap above.
-  Node* a = gasm_->CallBuiltin(
-      stub, Operator::kNoDeopt | Operator::kNoThrow, rtt, length,
-      Int32Constant(element_type.element_size_bytes()));
+  Node* a =
+      gasm_->CallBuiltin(stub, Operator::kNoDeopt | Operator::kNoThrow, rtt,
+                         length, Int32Constant(element_type.value_kind_size()));
   if (initial_value != nullptr) {
     // TODO(manoskouk): If the loop is ever removed here, we have to update
     // ArrayNewWithRtt() in graph-builder-interface.cc to not mark the current
@@ -5649,7 +5648,7 @@ Node* WasmGraphBuilder::ArrayNewWithRtt(uint32_t array_index,
     auto done = gasm_->MakeLabel();
     Node* start_offset =
         Int32Constant(wasm::ObjectAccess::ToTagged(WasmArray::kHeaderSize));
-    Node* element_size = Int32Constant(element_type.element_size_bytes());
+    Node* element_size = Int32Constant(element_type.value_kind_size());
     Node* end_offset =
         gasm_->Int32Add(start_offset, gasm_->Int32Mul(element_size, length));
     gasm_->Goto(&loop, start_offset);
@@ -5676,7 +5675,7 @@ Node* WasmGraphBuilder::ArrayInit(const wasm::ArrayType* type, Node* rtt,
       gasm_->CallBuiltin(Builtin::kWasmAllocateArray_Uninitialized,
                          Operator::kNoDeopt | Operator::kNoThrow, rtt,
                          Int32Constant(static_cast<int32_t>(elements.size())),
-                         Int32Constant(element_type.element_size_bytes()));
+                         Int32Constant(element_type.value_kind_size()));
   for (int i = 0; i < static_cast<int>(elements.size()); i++) {
     Node* offset =
         gasm_->WasmArrayElementOffset(Int32Constant(i), element_type);
@@ -7261,11 +7260,11 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     // Store arguments on our stack, then align the stack for calling to C.
     int param_bytes = 0;
     for (wasm::ValueType type : sig_->parameters()) {
-      param_bytes += type.element_size_bytes();
+      param_bytes += type.value_kind_size();
     }
     int return_bytes = 0;
     for (wasm::ValueType type : sig_->returns()) {
-      return_bytes += type.element_size_bytes();
+      return_bytes += type.value_kind_size();
     }
 
     int stack_slot_bytes = std::max(param_bytes, return_bytes);
@@ -7284,7 +7283,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
       SetEffect(graph()->NewNode(GetSafeStoreOperator(offset, type), values,
                                  Int32Constant(offset), Param(i + 1), effect(),
                                  control()));
-      offset += type.element_size_bytes();
+      offset += type.value_kind_size();
     }
 
     Node* function_node = gasm_->Load(
@@ -7349,7 +7348,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
             graph()->NewNode(GetSafeLoadOperator(offset, type), values,
                              Int32Constant(offset), effect(), control()));
         returns[i] = val;
-        offset += type.element_size_bytes();
+        offset += type.value_kind_size();
       }
       Return(base::VectorOf(returns));
     }
@@ -7571,7 +7570,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
           graph()->NewNode(GetSafeLoadOperator(offset, type), arg_buffer,
                            Int32Constant(offset), effect(), control()));
       args[pos++] = arg_load;
-      offset += type.element_size_bytes();
+      offset += type.value_kind_size();
     }
 
     args[pos++] = effect();
@@ -7603,7 +7602,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
       SetEffect(graph()->NewNode(GetSafeStoreOperator(offset, type), arg_buffer,
                                  Int32Constant(offset), value, effect(),
                                  control()));
-      offset += type.element_size_bytes();
+      offset += type.value_kind_size();
       pos++;
     }
 
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index 264bda0d7a4..1ddacae0a58 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -1680,7 +1680,7 @@ Handle<WasmArray> Factory::NewWasmArrayFromMemory(uint32_t length,
   result.set_length(length);
   MemCopy(reinterpret_cast<void*>(result.ElementAddress(0)),
           reinterpret_cast<void*>(source),
-          length * element_type.element_size_bytes());
+          length * element_type.value_kind_size());
 
   return handle(result, isolate());
 }
diff --git a/src/runtime/runtime-wasm.cc b/src/runtime/runtime-wasm.cc
index 2e8bd84a202..08ed0616424 100644
--- a/src/runtime/runtime-wasm.cc
+++ b/src/runtime/runtime-wasm.cc
@@ -676,7 +676,7 @@ RUNTIME_FUNCTION(Runtime_WasmArrayCopy) {
                                  UPDATE_WRITE_BARRIER);
     }
   } else {
-    int element_size_bytes = element_type.element_size_bytes();
+    int element_size_bytes = element_type.value_kind_size();
     void* dst = ArrayElementAddress(dst_array, dst_index, element_size_bytes);
     void* src = ArrayElementAddress(src_array, src_index, element_size_bytes);
     size_t copy_size = length * element_size_bytes;
diff --git a/src/wasm/baseline/arm/liftoff-assembler-arm.h b/src/wasm/baseline/arm/liftoff-assembler-arm.h
index a085c60539e..bd28a6f7b62 100644
--- a/src/wasm/baseline/arm/liftoff-assembler-arm.h
+++ b/src/wasm/baseline/arm/liftoff-assembler-arm.h
@@ -565,7 +565,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -4177,7 +4177,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
         UNREACHABLE();
     }
     args++;
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/baseline/arm64/liftoff-assembler-arm64.h b/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
index b31e7c96086..d883cc345e6 100644
--- a/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
+++ b/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
@@ -395,7 +395,7 @@ int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   // some performance testing to see how big an effect it will take.
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -3186,7 +3186,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
   int arg_bytes = 0;
   for (ValueKind param_kind : sig->parameters()) {
     Poke(liftoff::GetRegFromType(*args++, param_kind), arg_bytes);
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
index 23614a25318..25666642b24 100644
--- a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
+++ b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
@@ -318,7 +318,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 }
 
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
-  return is_reference(kind) ? kSystemPointerSize : element_size_bytes(kind);
+  return value_kind_full_size(kind);
 }
 
 bool LiftoffAssembler::NeedsAlignment(ValueKind kind) {
@@ -1158,8 +1158,8 @@ void LiftoffAssembler::StoreCallerFrameSlot(LiftoffRegister src,
 
 void LiftoffAssembler::MoveStackValue(uint32_t dst_offset, uint32_t src_offset,
                                       ValueKind kind) {
-  DCHECK_EQ(0, element_size_bytes(kind) % kSystemPointerSize);
-  int words = element_size_bytes(kind) / kSystemPointerSize;
+  DCHECK_EQ(0, SlotSizeForType(kind) % kSystemPointerSize);
+  int words = SlotSizeForType(kind) / kSystemPointerSize;
   DCHECK_LE(1, words);
   // Make sure we move the words in the correct order in case there is an
   // overlap between src and dst.
@@ -4542,7 +4542,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
   int arg_bytes = 0;
   for (ValueKind param_kind : sig->parameters()) {
     liftoff::Store(this, esp, arg_bytes, *args++, param_kind);
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/baseline/liftoff-assembler.cc b/src/wasm/baseline/liftoff-assembler.cc
index aa3d346891b..191fb71b2f8 100644
--- a/src/wasm/baseline/liftoff-assembler.cc
+++ b/src/wasm/baseline/liftoff-assembler.cc
@@ -739,8 +739,8 @@ void LiftoffAssembler::MaterializeMergedConstants(uint32_t arity) {
 namespace {
 bool SlotInterference(const VarState& a, const VarState& b) {
   return a.is_stack() && b.is_stack() &&
-         b.offset() > a.offset() - element_size_bytes(a.kind()) &&
-         b.offset() - element_size_bytes(b.kind()) < a.offset();
+         b.offset() > a.offset() - value_kind_size(a.kind()) &&
+         b.offset() - value_kind_size(b.kind()) < a.offset();
 }
 
 bool SlotInterference(const VarState& a, base::Vector<const VarState> v) {
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index 87dabfddb5a..9d9509c7772 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -1495,10 +1495,10 @@ class LiftoffCompiler {
     // Store arguments on our stack, then align the stack for calling to C.
     int param_bytes = 0;
     for (ValueKind param_kind : sig->parameters()) {
-      param_bytes += element_size_bytes(param_kind);
+      param_bytes += value_kind_size(param_kind);
     }
     int out_arg_bytes =
-        out_argument_kind == kVoid ? 0 : element_size_bytes(out_argument_kind);
+        out_argument_kind == kVoid ? 0 : value_kind_size(out_argument_kind);
     int stack_bytes = std::max(param_bytes, out_arg_bytes);
     __ CallC(sig, arg_regs, result_regs, out_argument_kind, stack_bytes,
              ext_ref);
@@ -4619,11 +4619,11 @@ class LiftoffCompiler {
                   const MemoryAccessImmediate<validate>& imm) {
     LiftoffRegister full_index = __ PeekToRegister(2, {});
     Register index_reg =
-        BoundsCheckMem(decoder, element_size_bytes(kind), imm.offset,
-                       full_index, {}, kDoForceCheck);
+        BoundsCheckMem(decoder, value_kind_size(kind), imm.offset, full_index,
+                       {}, kDoForceCheck);
     if (index_reg == no_reg) return;
     LiftoffRegList pinned = {index_reg};
-    AlignmentCheckMem(decoder, element_size_bytes(kind), imm.offset, index_reg,
+    AlignmentCheckMem(decoder, value_kind_size(kind), imm.offset, index_reg,
                       pinned);
 
     uintptr_t offset = imm.offset;
@@ -4926,7 +4926,8 @@ class LiftoffCompiler {
     LiftoffRegister seg_index =
         pinned.set(__ GetUnusedRegister(kGpReg, pinned));
     // Scale the seg_index for the array access.
-    __ LoadConstant(seg_index, WasmValue(imm.index << element_size_log2(kI32)));
+    __ LoadConstant(seg_index,
+                    WasmValue(imm.index << value_kind_size_log2(kI32)));
 
     // Set the length of the segment to '0' to drop it.
     LiftoffRegister null_reg = pinned.set(__ GetUnusedRegister(kGpReg, pinned));
@@ -5261,7 +5262,7 @@ class LiftoffCompiler {
                              WasmArray::MaxLength(imm.array_type));
     }
     ValueKind elem_kind = imm.array_type->element_type().kind();
-    int elem_size = element_size_bytes(elem_kind);
+    int elem_size = value_kind_size(elem_kind);
     // Allocate the array.
     {
       LiftoffRegister elem_size_reg = __ GetUnusedRegister(kGpReg, {});
@@ -5296,9 +5297,9 @@ class LiftoffCompiler {
           offset,
           WasmValue(wasm::ObjectAccess::ToTagged(WasmArray::kHeaderSize)));
       LiftoffRegister end_offset = length;
-      if (element_size_log2(elem_kind) != 0) {
+      if (value_kind_size_log2(elem_kind) != 0) {
         __ emit_i32_shli(end_offset.gp(), length.gp(),
-                         element_size_log2(elem_kind));
+                         value_kind_size_log2(elem_kind));
       }
       __ emit_i32_add(end_offset.gp(), end_offset.gp(), offset.gp());
       Label loop, done;
@@ -5341,7 +5342,7 @@ class LiftoffCompiler {
     BoundsCheckArray(decoder, array, index, pinned);
     ValueKind elem_kind = imm.array_type->element_type().kind();
     if (!CheckSupportedType(decoder, elem_kind, "array load")) return;
-    int elem_size_shift = element_size_log2(elem_kind);
+    int elem_size_shift = value_kind_size_log2(elem_kind);
     if (elem_size_shift != 0) {
       __ emit_i32_shli(index.gp(), index.gp(), elem_size_shift);
     }
@@ -5365,7 +5366,7 @@ class LiftoffCompiler {
     MaybeEmitNullCheck(decoder, array.gp(), pinned, array_obj.type);
     BoundsCheckArray(decoder, array, index, pinned);
     ValueKind elem_kind = imm.array_type->element_type().kind();
-    int elem_size_shift = element_size_log2(elem_kind);
+    int elem_size_shift = value_kind_size_log2(elem_kind);
     if (elem_size_shift != 0) {
       __ emit_i32_shli(index.gp(), index.gp(), elem_size_shift);
     }
@@ -5415,7 +5416,7 @@ class LiftoffCompiler {
       LiftoffRegister elem_size_reg =
           pinned.set(__ GetUnusedRegister(kGpReg, pinned));
 
-      __ LoadConstant(elem_size_reg, WasmValue(element_size_bytes(elem_kind)));
+      __ LoadConstant(elem_size_reg, WasmValue(value_kind_size(elem_kind)));
       LiftoffAssembler::VarState elem_size_var(kI32, elem_size_reg, 0);
 
       LiftoffRegister length_reg =
@@ -5443,7 +5444,8 @@ class LiftoffCompiler {
       LiftoffRegister element = pinned.set(__ PopToRegister(pinned));
       LiftoffRegister offset_reg =
           pinned.set(__ GetUnusedRegister(kGpReg, pinned));
-      __ LoadConstant(offset_reg, WasmValue(i << element_size_log2(elem_kind)));
+      __ LoadConstant(offset_reg,
+                      WasmValue(i << value_kind_size_log2(elem_kind)));
       StoreObjectField(array.gp(), offset_reg.gp(),
                        wasm::ObjectAccess::ToTagged(WasmArray::kHeaderSize),
                        element, pinned, elem_kind);
diff --git a/src/wasm/baseline/loong64/liftoff-assembler-loong64.h b/src/wasm/baseline/loong64/liftoff-assembler-loong64.h
index 7407810a31c..77ec04c00e6 100644
--- a/src/wasm/baseline/loong64/liftoff-assembler-loong64.h
+++ b/src/wasm/baseline/loong64/liftoff-assembler-loong64.h
@@ -299,7 +299,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -2954,7 +2954,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
   int arg_bytes = 0;
   for (ValueKind param_kind : sig->parameters()) {
     liftoff::Store(this, sp, arg_bytes, *args++, param_kind);
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/baseline/mips/liftoff-assembler-mips.h b/src/wasm/baseline/mips/liftoff-assembler-mips.h
index 17437afe1ba..66224bd4121 100644
--- a/src/wasm/baseline/mips/liftoff-assembler-mips.h
+++ b/src/wasm/baseline/mips/liftoff-assembler-mips.h
@@ -428,7 +428,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -2979,7 +2979,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
   int arg_bytes = 0;
   for (ValueKind param_kind : sig->parameters()) {
     liftoff::Store(this, sp, arg_bytes, *args++, param_kind);
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/baseline/mips64/liftoff-assembler-mips64.h b/src/wasm/baseline/mips64/liftoff-assembler-mips64.h
index 7936ee8bd0a..d35fa232294 100644
--- a/src/wasm/baseline/mips64/liftoff-assembler-mips64.h
+++ b/src/wasm/baseline/mips64/liftoff-assembler-mips64.h
@@ -415,7 +415,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -3524,7 +3524,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
   int arg_bytes = 0;
   for (ValueKind param_kind : sig->parameters()) {
     liftoff::Store(this, sp, arg_bytes, *args++, param_kind);
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/baseline/ppc/liftoff-assembler-ppc.h b/src/wasm/baseline/ppc/liftoff-assembler-ppc.h
index adf3fb46673..796ddaa4d17 100644
--- a/src/wasm/baseline/ppc/liftoff-assembler-ppc.h
+++ b/src/wasm/baseline/ppc/liftoff-assembler-ppc.h
@@ -228,7 +228,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -2970,7 +2970,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
         UNREACHABLE();
     }
     args++;
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
 
   DCHECK_LE(arg_bytes, stack_bytes);
diff --git a/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h b/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h
index 6d66f93c2b6..49659b781d8 100644
--- a/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h
+++ b/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h
@@ -399,7 +399,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -3706,7 +3706,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
   int arg_bytes = 0;
   for (ValueKind param_kind : sig->parameters()) {
     liftoff::Store(this, sp, arg_bytes, *args++, param_kind);
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/baseline/s390/liftoff-assembler-s390.h b/src/wasm/baseline/s390/liftoff-assembler-s390.h
index 138702bbb25..65bb3435adc 100644
--- a/src/wasm/baseline/s390/liftoff-assembler-s390.h
+++ b/src/wasm/baseline/s390/liftoff-assembler-s390.h
@@ -206,7 +206,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
   switch (kind) {
     case kS128:
-      return element_size_bytes(kind);
+      return value_kind_size(kind);
     default:
       return kStackSlotSize;
   }
@@ -2980,7 +2980,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
         UNREACHABLE();
     }
     args++;
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
 
   DCHECK_LE(arg_bytes, stack_bytes);
diff --git a/src/wasm/baseline/x64/liftoff-assembler-x64.h b/src/wasm/baseline/x64/liftoff-assembler-x64.h
index 4f49166fded..fd3c6bc883d 100644
--- a/src/wasm/baseline/x64/liftoff-assembler-x64.h
+++ b/src/wasm/baseline/x64/liftoff-assembler-x64.h
@@ -293,7 +293,7 @@ constexpr int LiftoffAssembler::StaticStackFrameSize() {
 }
 
 int LiftoffAssembler::SlotSizeForType(ValueKind kind) {
-  return is_reference(kind) ? kSystemPointerSize : element_size_bytes(kind);
+  return value_kind_full_size(kind);
 }
 
 bool LiftoffAssembler::NeedsAlignment(ValueKind kind) {
@@ -871,21 +871,16 @@ void LiftoffAssembler::MoveStackValue(uint32_t dst_offset, uint32_t src_offset,
   DCHECK_NE(dst_offset, src_offset);
   Operand dst = liftoff::GetStackSlot(dst_offset);
   Operand src = liftoff::GetStackSlot(src_offset);
-  size_t size = element_size_log2(kind);
-  if (kind == kRef || kind == kOptRef || kind == kRtt) {
-    // Pointers are uncompressed on the stack!
-    size = kSystemPointerSizeLog2;
-  }
-  switch (size) {
-    case 2:
+  switch (SlotSizeForType(kind)) {
+    case 4:
       movl(kScratchRegister, src);
       movl(dst, kScratchRegister);
       break;
-    case 3:
+    case 8:
       movq(kScratchRegister, src);
       movq(dst, kScratchRegister);
       break;
-    case 4:
+    case 16:
       Movdqu(kScratchDoubleReg, src);
       Movdqu(dst, kScratchDoubleReg);
       break;
@@ -4095,7 +4090,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
   int arg_bytes = 0;
   for (ValueKind param_kind : sig->parameters()) {
     liftoff::Store(this, Operand(rsp, arg_bytes), *args++, param_kind);
-    arg_bytes += element_size_bytes(param_kind);
+    arg_bytes += value_kind_size(param_kind);
   }
   DCHECK_LE(arg_bytes, stack_bytes);
 
diff --git a/src/wasm/function-body-decoder-impl.h b/src/wasm/function-body-decoder-impl.h
index 5b7201abb6e..cbb7b4f630b 100644
--- a/src/wasm/function-body-decoder-impl.h
+++ b/src/wasm/function-body-decoder-impl.h
@@ -4233,7 +4233,7 @@ class WasmFullDecoder : public WasmDecoder<validate, decoding_mode> {
         // Byte sequences in data segments are interpreted as little endian for
         // the purposes of this instruction. This means that those will have to
         // be transformed in big endian architectures. TODO(7748): Implement.
-        if (element_type.element_size_bytes() > 1) {
+        if (element_type.value_kind_size() > 1) {
           UNIMPLEMENTED();
         }
 #endif
diff --git a/src/wasm/init-expr-interface.cc b/src/wasm/init-expr-interface.cc
index 685dab463b5..bd0d0336420 100644
--- a/src/wasm/init-expr-interface.cc
+++ b/src/wasm/init-expr-interface.cc
@@ -198,7 +198,7 @@ void InitExprInterface::ArrayInitFromData(
   const WasmDataSegment& data_segment =
       module_->data_segments[data_segment_imm.index];
   uint32_t length_in_bytes =
-      length * array_imm.array_type->element_type().element_size_bytes();
+      length * array_imm.array_type->element_type().value_kind_size();
 
   // Error handling.
   if (length >
diff --git a/src/wasm/module-decoder.cc b/src/wasm/module-decoder.cc
index 0e6d0bb5695..0d378675109 100644
--- a/src/wasm/module-decoder.cc
+++ b/src/wasm/module-decoder.cc
@@ -1649,7 +1649,7 @@ class ModuleDecoderImpl : public Decoder {
         // All entries in the tagged_globals_buffer have size 1.
         tagged_offset++;
       } else {
-        int size = global.type.element_size_bytes();
+        int size = global.type.value_kind_size();
         untagged_offset = (untagged_offset + size - 1) & ~(size - 1);  // align
         global.offset = untagged_offset;
         untagged_offset += size;
diff --git a/src/wasm/module-instantiate.cc b/src/wasm/module-instantiate.cc
index 16ae664252c..b03903cc57e 100644
--- a/src/wasm/module-instantiate.cc
+++ b/src/wasm/module-instantiate.cc
@@ -188,7 +188,7 @@ Handle<Map> CreateArrayMap(Isolate* isolate, const WasmModule* module,
   map->SetInstanceDescriptors(isolate, *descriptors,
                               descriptors->number_of_descriptors());
   map->set_is_extensible(false);
-  WasmArray::EncodeElementSizeInMap(type->element_type().element_size_bytes(),
+  WasmArray::EncodeElementSizeInMap(type->element_type().value_kind_size(),
                                     *map);
   return map;
 }
diff --git a/src/wasm/struct-types.h b/src/wasm/struct-types.h
index 8bdfc22dd50..44c492d3270 100644
--- a/src/wasm/struct-types.h
+++ b/src/wasm/struct-types.h
@@ -71,9 +71,9 @@ class StructType : public ZoneObject {
 
   void InitializeOffsets() {
     if (field_count() == 0) return;
-    uint32_t offset = field(0).element_size_bytes();
+    uint32_t offset = field(0).value_kind_size();
     for (uint32_t i = 1; i < field_count(); i++) {
-      uint32_t field_size = field(i).element_size_bytes();
+      uint32_t field_size = field(i).value_kind_size();
       // TODO(jkummerow): Don't round up to more than kTaggedSize-alignment.
       offset = RoundUp(offset, field_size);
       field_offsets_[i - 1] = offset;
diff --git a/src/wasm/value-type.h b/src/wasm/value-type.h
index 3a1ebdd1f3c..6c4b56ee5d3 100644
--- a/src/wasm/value-type.h
+++ b/src/wasm/value-type.h
@@ -208,19 +208,19 @@ constexpr bool is_object_reference(ValueKind kind) {
   return kind == kRef || kind == kOptRef;
 }
 
-constexpr int element_size_log2(ValueKind kind) {
-  constexpr int8_t kElementSizeLog2[] = {
-#define ELEM_SIZE_LOG2(kind, log2Size, ...) log2Size,
-      FOREACH_VALUE_TYPE(ELEM_SIZE_LOG2)
-#undef ELEM_SIZE_LOG2
+constexpr int value_kind_size_log2(ValueKind kind) {
+  constexpr int8_t kValueKindSizeLog2[] = {
+#define VALUE_KIND_SIZE_LOG2(kind, log2Size, ...) log2Size,
+      FOREACH_VALUE_TYPE(VALUE_KIND_SIZE_LOG2)
+#undef VALUE_KIND_SIZE_LOG2
   };
 
-  int size_log_2 = kElementSizeLog2[kind];
+  int size_log_2 = kValueKindSizeLog2[kind];
   DCHECK_LE(0, size_log_2);
   return size_log_2;
 }
 
-constexpr int element_size_bytes(ValueKind kind) {
+constexpr int value_kind_size(ValueKind kind) {
   constexpr int8_t kElementSize[] = {
 #define ELEM_SIZE_LOG2(kind, log2Size, ...) \
   log2Size == -1 ? -1 : (1 << std::max(0, log2Size)),
@@ -233,6 +233,14 @@ constexpr int element_size_bytes(ValueKind kind) {
   return size;
 }
 
+constexpr int value_kind_full_size(ValueKind kind) {
+  if (is_reference(kind)) {
+    // Uncompressed pointer size.
+    return kSystemPointerSize;
+  }
+  return value_kind_size(kind);
+}
+
 constexpr char short_name(ValueKind kind) {
   constexpr char kShortName[] = {
 #define SHORT_NAME(kind, log2Size, code, machineType, shortName, ...) shortName,
@@ -395,12 +403,16 @@ class ValueType {
     return offsetof(ValueType, bit_field_);
   }
 
-  constexpr int element_size_log2() const {
-    return wasm::element_size_log2(kind());
+  constexpr int value_kind_size_log2() const {
+    return wasm::value_kind_size_log2(kind());
+  }
+
+  constexpr int value_kind_size() const {
+    return wasm::value_kind_size(kind());
   }
 
-  constexpr int element_size_bytes() const {
-    return wasm::element_size_bytes(kind());
+  constexpr int value_kind_full_size() const {
+    return wasm::value_kind_full_size(kind());
   }
 
   /*************************** Machine-type related ***************************/
diff --git a/src/wasm/wasm-arguments.h b/src/wasm/wasm-arguments.h
index 4e59a232641..305d7cc361b 100644
--- a/src/wasm/wasm-arguments.h
+++ b/src/wasm/wasm-arguments.h
@@ -52,11 +52,11 @@ class CWasmArgumentsPacker {
   static int TotalSize(const FunctionSig* sig) {
     int return_size = 0;
     for (ValueType t : sig->returns()) {
-      return_size += t.element_size_bytes();
+      return_size += t.value_kind_size();
     }
     int param_size = 0;
     for (ValueType t : sig->parameters()) {
-      param_size += t.element_size_bytes();
+      param_size += t.value_kind_size();
     }
     return std::max(return_size, param_size);
   }
diff --git a/src/wasm/wasm-external-refs.cc b/src/wasm/wasm-external-refs.cc
index 27e022bdb8b..73f25dbcca2 100644
--- a/src/wasm/wasm-external-refs.cc
+++ b/src/wasm/wasm-external-refs.cc
@@ -573,7 +573,7 @@ void array_copy_wrapper(Address raw_instance, Address raw_dst_array,
                                  UPDATE_WRITE_BARRIER);
     }
   } else {
-    int element_size_bytes = element_type.element_size_bytes();
+    int element_size_bytes = element_type.value_kind_size();
     void* dst = ArrayElementAddress(dst_array, dst_index, element_size_bytes);
     void* src = ArrayElementAddress(src_array, src_index, element_size_bytes);
     size_t copy_size = length * element_size_bytes;
diff --git a/src/wasm/wasm-objects-inl.h b/src/wasm/wasm-objects-inl.h
index caaeafbffb3..3d5164beb37 100644
--- a/src/wasm/wasm-objects-inl.h
+++ b/src/wasm/wasm-objects-inl.h
@@ -120,7 +120,7 @@ void WasmGlobalObject::set_type(wasm::ValueType value) {
   set_raw_type(static_cast<int>(value.raw_bit_field()));
 }
 
-int WasmGlobalObject::type_size() const { return type().element_size_bytes(); }
+int WasmGlobalObject::type_size() const { return type().value_kind_size(); }
 
 Address WasmGlobalObject::address() const {
   DCHECK_NE(type(), wasm::kWasmAnyRef);
@@ -590,7 +590,7 @@ int WasmArray::SizeFor(Map map, int length) {
 uint32_t WasmArray::element_offset(uint32_t index) {
   DCHECK_LE(index, length());
   return WasmArray::kHeaderSize +
-         index * type()->element_type().element_size_bytes();
+         index * type()->element_type().value_kind_size();
 }
 
 Address WasmArray::ElementAddress(uint32_t index) {
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index deeab21028b..986c7748c64 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1054,7 +1054,7 @@ MaybeHandle<WasmGlobalObject> WasmGlobalObject::New(
     global_obj->set_tagged_buffer(*tagged_buffer);
   } else {
     DCHECK(maybe_tagged_buffer.is_null());
-    uint32_t type_size = type.element_size_bytes();
+    uint32_t type_size = type.value_kind_size();
 
     Handle<JSArrayBuffer> untagged_buffer;
     if (!maybe_untagged_buffer.ToHandle(&untagged_buffer)) {
@@ -1594,7 +1594,7 @@ wasm::WasmValue WasmStruct::GetFieldValue(uint32_t index) {
 wasm::WasmValue WasmArray::GetElement(uint32_t index) {
   wasm::ValueType element_type = type()->element_type();
   int element_offset =
-      WasmArray::kHeaderSize + index * element_type.element_size_bytes();
+      WasmArray::kHeaderSize + index * element_type.value_kind_size();
   Address element_address = GetFieldAddress(element_offset);
   using wasm::Simd128;
   switch (element_type.kind()) {
@@ -1820,7 +1820,7 @@ namespace {
 constexpr uint32_t kBytesPerExceptionValuesArrayElement = 2;
 
 size_t ComputeEncodedElementSize(wasm::ValueType type) {
-  size_t byte_size = type.element_size_bytes();
+  size_t byte_size = type.value_kind_size();
   DCHECK_EQ(byte_size % kBytesPerExceptionValuesArrayElement, 0);
   DCHECK_LE(1, byte_size / kBytesPerExceptionValuesArrayElement);
   return byte_size / kBytesPerExceptionValuesArrayElement;
diff --git a/src/wasm/wasm-objects.h b/src/wasm/wasm-objects.h
index dd3c5180d91..7cfd82f323b 100644
--- a/src/wasm/wasm-objects.h
+++ b/src/wasm/wasm-objects.h
@@ -986,7 +986,7 @@ class WasmArray : public TorqueGeneratedWasmArray<WasmArray, WasmObject> {
   }
 
   static int MaxLength(const wasm::ArrayType* type) {
-    return MaxLength(type->element_type().element_size_bytes());
+    return MaxLength(type->element_type().value_kind_size());
   }
 
   static inline void EncodeElementSizeInMap(int element_size, Map map);
diff --git a/src/wasm/wasm-value.h b/src/wasm/wasm-value.h
index 1192da1bea6..a27905b6cda 100644
--- a/src/wasm/wasm-value.h
+++ b/src/wasm/wasm-value.h
@@ -116,7 +116,7 @@ class WasmValue {
 
   WasmValue(byte* raw_bytes, ValueType type) : type_(type), bit_pattern_{} {
     DCHECK(type_.is_numeric());
-    memcpy(bit_pattern_, raw_bytes, type.element_size_bytes());
+    memcpy(bit_pattern_, raw_bytes, type.value_kind_size());
   }
 
   WasmValue(Handle<Object> ref, ValueType type) : type_(type), bit_pattern_{} {
@@ -140,14 +140,14 @@ class WasmValue {
     return type_ == other.type_ &&
            !memcmp(bit_pattern_, other.bit_pattern_,
                    type_.is_reference() ? sizeof(Handle<Object>)
-                                        : type_.element_size_bytes());
+                                        : type_.value_kind_size());
   }
 
   void CopyTo(byte* to) const {
     STATIC_ASSERT(sizeof(float) == sizeof(Float32));
     STATIC_ASSERT(sizeof(double) == sizeof(Float64));
     DCHECK(type_.is_numeric());
-    memcpy(to, bit_pattern_, type_.element_size_bytes());
+    memcpy(to, bit_pattern_, type_.value_kind_size());
   }
 
   // If {packed_type.is_packed()}, create a new value of {packed_type()}.
diff --git a/test/cctest/wasm/wasm-run-utils.cc b/test/cctest/wasm/wasm-run-utils.cc
index 142ba2d8e23..71a1e77e3d7 100644
--- a/test/cctest/wasm/wasm-run-utils.cc
+++ b/test/cctest/wasm/wasm-run-utils.cc
@@ -348,7 +348,7 @@ CompilationEnv TestingModuleBuilder::CreateCompilationEnv() {
 }
 
 const WasmGlobal* TestingModuleBuilder::AddGlobal(ValueType type) {
-  byte size = type.element_size_bytes();
+  byte size = type.value_kind_size();
   global_offset = (global_offset + size - 1) & ~(size - 1);  // align
   test_module_->globals.push_back(
       {type, true, {}, {global_offset}, false, false});
-- 
2.35.1


From ecffcf956a8fb62173905593ca6203cd682b2a66 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Tue, 21 Mar 2023 20:05:22 +0800
Subject: [PATCH] [riscv]Allocate builtin Code objects in RO space

Port commit 0600991a1ad20340db26b9f0785cbbdc1aa332da

Change-Id: Id6b72c7c778a26fdd256019ad0501f5225116f59
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4355044
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Reviewed-by: Ji Qiu <qiuji@iscas.ac.cn>
Commit-Queue: Ji Qiu <qiuji@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#86618}
---
 test/cctest/test-assembler-riscv32.cc       | 22 ++++++++---------
 test/cctest/test-assembler-riscv64.cc       | 26 ++++++++++-----------
 test/cctest/test-helper-riscv32.cc          |  5 ++--
 test/cctest/test-helper-riscv32.h           | 24 +++++++++++--------
 test/cctest/test-helper-riscv64.cc          |  5 ++--
 test/cctest/test-helper-riscv64.h           | 24 +++++++++++--------
 test/cctest/test-macro-assembler-riscv32.cc | 22 ++++++++---------
 test/cctest/test-macro-assembler-riscv64.cc | 24 +++++++++----------
 test/cctest/test-simple-riscv32.cc          | 12 +++++-----
 test/cctest/test-simple-riscv64.cc          | 12 +++++-----
 10 files changed, 91 insertions(+), 85 deletions(-)

diff --git a/test/cctest/test-assembler-riscv32.cc b/test/cctest/test-assembler-riscv32.cc
index 83428eb2f10..0bcbd5fae41 100644
--- a/test/cctest/test-assembler-riscv32.cc
+++ b/test/cctest/test-assembler-riscv32.cc
@@ -724,7 +724,7 @@ TEST(RISCV3) {
     __ fsqrt_s(ft5, ft4);
     __ fsw(ft5, a0, offsetof(T, fg));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   // Double test values.
   t.a = 1.5e14;
@@ -796,7 +796,7 @@ TEST(RISCV4) {
 
     __ sw(a4, a0, offsetof(T, e));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e22;
   t.b = 2.75e11;
@@ -847,7 +847,7 @@ TEST(RISCV5) {
     __ fcvt_d_w(fa1, a5);
     __ fsd(fa1, a0, offsetof(T, b));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e4;
   t.b = 2.75e4;
@@ -905,7 +905,7 @@ TEST(RISCV6) {
     __ lhu(t1, a0, offsetof(T, si));
     __ sh(t1, a0, offsetof(T, r6));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.ui = 0x11223344;
   t.si = 0x99AABBCC;
@@ -1023,7 +1023,7 @@ TEST(RISCV7) {
     __ bind(&outa_here);
   };
 
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e14;
   t.b = 2.75e11;
@@ -1102,7 +1102,7 @@ TEST(NAN_BOX) {
     // Check only transfer low 32bits when fsw
     __ fsw(fa0, a0, offsetof(T, res));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = -123.45;
   t.box = 0;
@@ -1284,7 +1284,7 @@ TEST(RVC_LOAD_STORE_COMPRESSED) {
       __ add(a3, a1, a2);
       __ c_sw(a3, a0, offsetof(S, c));  // c = a + b.
     };
-    auto f = AssembleCode<F3>(fn);
+    auto f = AssembleCode<F3>(isolate, fn);
 
     s.a = 1;
     s.b = 2;
@@ -1400,7 +1400,7 @@ TEST(RVC_CB_BRANCH) {
     __ bind(&outa_here);
   };
 
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e14;
   t.b = 2.75e11;
@@ -1613,7 +1613,7 @@ TEST(jump_tables1) {
 
     CHECK_EQ(0, assm.UnboundLabelsCount());
   };
-  auto f = AssembleCode<F1>(fn);
+  auto f = AssembleCode<F1>(isolate, fn);
 
   for (int i = 0; i < kNumCases; ++i) {
     int32_t res = reinterpret_cast<int32_t>(f.Call(i, 0, 0, 0, 0));
@@ -1663,7 +1663,7 @@ TEST(jump_tables2) {
     __ Lw(ra, MemOperand(sp));
     __ addi(sp, sp, 4);
   };
-  auto f = AssembleCode<F1>(fn);
+  auto f = AssembleCode<F1>(isolate, fn);
 
   for (int i = 0; i < kNumCases; ++i) {
     int32_t res = reinterpret_cast<int32_t>(f.Call(i, 0, 0, 0, 0));
@@ -1723,7 +1723,7 @@ TEST(jump_tables3) {
     __ Lw(ra, MemOperand(sp));
     __ addi(sp, sp, 4);
   };
-  auto f = AssembleCode<F1>(fn);
+  auto f = AssembleCode<F1>(isolate, fn);
 
   for (int i = 0; i < kNumCases; ++i) {
     Handle<Object> result(
diff --git a/test/cctest/test-assembler-riscv64.cc b/test/cctest/test-assembler-riscv64.cc
index 36d1cc3749f..c5a937d0e64 100644
--- a/test/cctest/test-assembler-riscv64.cc
+++ b/test/cctest/test-assembler-riscv64.cc
@@ -859,7 +859,7 @@ TEST(RISCV3) {
     __ fsqrt_s(ft5, ft4);
     __ fsw(ft5, a0, offsetof(T, fg));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   // Double test values.
   t.a = 1.5e14;
@@ -932,7 +932,7 @@ TEST(RISCV4) {
 
     __ sd(a4, a0, offsetof(T, e));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e22;
   t.b = 2.75e11;
@@ -983,7 +983,7 @@ TEST(RISCV5) {
     __ fcvt_d_l(fa1, a5);
     __ fsd(fa1, a0, offsetof(T, b));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e4;
   t.b = 2.75e8;
@@ -1041,7 +1041,7 @@ TEST(RISCV6) {
     __ lhu(t1, a0, offsetof(T, si));
     __ sh(t1, a0, offsetof(T, r6));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.ui = 0x11223344;
   t.si = 0x99AABBCC;
@@ -1157,7 +1157,7 @@ TEST(RISCV7) {
     __ bind(&outa_here);
   };
 
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e14;
   t.b = 2.75e11;
@@ -1254,7 +1254,7 @@ TEST(NAN_BOX) {
     // Check only transfer low 32bits when fsw
     __ fsw(fa0, a0, offsetof(T, res));
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = -123.45;
   t.box = 0;
@@ -1473,7 +1473,7 @@ TEST(RVC_LOAD_STORE_COMPRESSED) {
       __ fadd_d(fa2, fa1, fa0);
       __ c_fsd(fa2, a0, offsetof(T, c));  // c = a + b.
     };
-    auto f = AssembleCode<F3>(fn);
+    auto f = AssembleCode<F3>(isolate, fn);
 
     t.a = 1.5e14;
     t.b = 1.5e14;
@@ -1498,7 +1498,7 @@ TEST(RVC_LOAD_STORE_COMPRESSED) {
       __ add(a3, a1, a2);
       __ c_sw(a3, a0, offsetof(S, c));  // c = a + b.
     };
-    auto f = AssembleCode<F3>(fn);
+    auto f = AssembleCode<F3>(isolate, fn);
 
     s.a = 1;
     s.b = 2;
@@ -1522,7 +1522,7 @@ TEST(RVC_LOAD_STORE_COMPRESSED) {
       __ add(a3, a1, a2);
       __ c_sd(a3, a0, offsetof(U, c));  // c = a + b.
     };
-    auto f = AssembleCode<F3>(fn);
+    auto f = AssembleCode<F3>(isolate, fn);
 
     u.a = 1;
     u.b = 2;
@@ -1638,7 +1638,7 @@ TEST(RVC_CB_BRANCH) {
     __ bind(&outa_here);
   };
 
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   t.a = 1.5e14;
   t.b = 2.75e11;
@@ -1889,7 +1889,7 @@ TEST(jump_tables1) {
 
     CHECK_EQ(0, assm.UnboundLabelsCount());
   };
-  auto f = AssembleCode<F1>(fn);
+  auto f = AssembleCode<F1>(isolate, fn);
 
   for (int i = 0; i < kNumCases; ++i) {
     int64_t res = reinterpret_cast<int64_t>(f.Call(i, 0, 0, 0, 0));
@@ -1939,7 +1939,7 @@ TEST(jump_tables2) {
     __ Ld(ra, MemOperand(sp));
     __ addi(sp, sp, 8);
   };
-  auto f = AssembleCode<F1>(fn);
+  auto f = AssembleCode<F1>(isolate, fn);
 
   for (int i = 0; i < kNumCases; ++i) {
     int64_t res = reinterpret_cast<int64_t>(f.Call(i, 0, 0, 0, 0));
@@ -1999,7 +1999,7 @@ TEST(jump_tables3) {
     __ Ld(ra, MemOperand(sp));
     __ addi(sp, sp, 8);
   };
-  auto f = AssembleCode<F1>(fn);
+  auto f = AssembleCode<F1>(isolate, fn);
 
   for (int i = 0; i < kNumCases; ++i) {
     Handle<Object> result(
diff --git a/test/cctest/test-helper-riscv32.cc b/test/cctest/test-helper-riscv32.cc
index 0e9738a7b78..79468c73734 100644
--- a/test/cctest/test-helper-riscv32.cc
+++ b/test/cctest/test-helper-riscv32.cc
@@ -24,12 +24,11 @@ int32_t GenAndRunTest(Func test_generator) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<int32_t()>::FromCode(*code);
+  auto f = GeneratedCode<int32_t()>::FromCode(isolate, *code);
   return f.Call();
 }
 
-Handle<Code> AssembleCodeImpl(Func assemble) {
-  Isolate* isolate = CcTest::i_isolate();
+Handle<Code> AssembleCodeImpl(Isolate* isolate, Func assemble) {
   MacroAssembler assm(isolate, CodeObjectRequired::kYes);
 
   assemble(assm);
diff --git a/test/cctest/test-helper-riscv32.h b/test/cctest/test-helper-riscv32.h
index b5c2f7730b9..91fe1835dcd 100644
--- a/test/cctest/test-helper-riscv32.h
+++ b/test/cctest/test-helper-riscv32.h
@@ -70,7 +70,7 @@ OUTPUT_T GenAndRunTest(INPUT_T input0, Func test_generator) {
       typename std::conditional<sizeof(INPUT_T) == 4, int32_t,
                                 int64_t>::type>::type;
 
-  auto f = GeneratedCode<OINT_T(IINT_T)>::FromCode(*code);
+  auto f = GeneratedCode<OINT_T(IINT_T)>::FromCode(isolate, *code);
 
   auto res = f.Call(base::bit_cast<IINT_T>(input0));
   return base::bit_cast<OUTPUT_T>(res);
@@ -116,7 +116,7 @@ OUTPUT_T GenAndRunTest(INPUT_T input0, INPUT_T input1, Func test_generator) {
       std::is_integral<INPUT_T>::value, INPUT_T,
       typename std::conditional<sizeof(INPUT_T) == 4, int32_t,
                                 int64_t>::type>::type;
-  auto f = GeneratedCode<OINT_T(IINT_T, IINT_T)>::FromCode(*code);
+  auto f = GeneratedCode<OINT_T(IINT_T, IINT_T)>::FromCode(isolate, *code);
 
   auto res =
       f.Call(base::bit_cast<IINT_T>(input0), base::bit_cast<IINT_T>(input1));
@@ -165,7 +165,8 @@ OUTPUT_T GenAndRunTest(INPUT_T input0, INPUT_T input1, INPUT_T input2,
       std::is_integral<INPUT_T>::value, INPUT_T,
       typename std::conditional<sizeof(INPUT_T) == 4, int32_t,
                                 int64_t>::type>::type;
-  auto f = GeneratedCode<OINT_T(IINT_T, IINT_T, IINT_T)>::FromCode(*code);
+  auto f =
+      GeneratedCode<OINT_T(IINT_T, IINT_T, IINT_T)>::FromCode(isolate, *code);
 
   auto res =
       f.Call(base::bit_cast<IINT_T>(input0), base::bit_cast<IINT_T>(input1),
@@ -206,7 +207,8 @@ void GenAndRunTestForLoadStore(T value, Func test_generator) {
       std::is_integral<T>::value, T,
       typename std::conditional<sizeof(T) == 4, int32_t, int64_t>::type>::type;
 
-  auto f = GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(*code);
+  auto f =
+      GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(isolate, *code);
 
   int64_t tmp = 0;
   auto res = f.Call(&tmp, base::bit_cast<INT_T>(value));
@@ -253,7 +255,8 @@ void GenAndRunTestForLRSC(T value, Func test_generator) {
       typename std::conditional<sizeof(T) == 4, int32_t, int64_t>::type;
 
   T tmp = 0;
-  auto f = GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(*code);
+  auto f =
+      GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(isolate, *code);
   auto res = f.Call(&tmp, base::bit_cast<T>(value));
   CHECK_EQ(base::bit_cast<T>(res), static_cast<T>(0));
 }
@@ -312,18 +315,19 @@ OUTPUT_T GenAndRunTestForAMO(INPUT_T input0, INPUT_T input1,
   code->Print();
 #endif
   OUTPUT_T tmp = 0;
-  auto f =
-      GeneratedCode<OUTPUT_T(void* base, INPUT_T, INPUT_T)>::FromCode(*code);
+  auto f = GeneratedCode<OUTPUT_T(void* base, INPUT_T, INPUT_T)>::FromCode(
+      isolate, *code);
   auto res = f.Call(&tmp, base::bit_cast<INPUT_T>(input0),
                     base::bit_cast<INPUT_T>(input1));
   return base::bit_cast<OUTPUT_T>(res);
 }
 
-Handle<Code> AssembleCodeImpl(Func assemble);
+Handle<Code> AssembleCodeImpl(Isolate* isolate, Func assemble);
 
 template <typename Signature>
-GeneratedCode<Signature> AssembleCode(Func assemble) {
-  return GeneratedCode<Signature>::FromCode(*AssembleCodeImpl(assemble));
+GeneratedCode<Signature> AssembleCode(Isolate* isolate, Func assemble) {
+  return GeneratedCode<Signature>::FromCode(
+      isolate, *AssembleCodeImpl(isolate, assemble));
 }
 
 template <typename T>
diff --git a/test/cctest/test-helper-riscv64.cc b/test/cctest/test-helper-riscv64.cc
index 75263d35f5f..e4cf6bd29b8 100644
--- a/test/cctest/test-helper-riscv64.cc
+++ b/test/cctest/test-helper-riscv64.cc
@@ -23,12 +23,11 @@ int64_t GenAndRunTest(Func test_generator) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<int64_t()>::FromCode(*code);
+  auto f = GeneratedCode<int64_t()>::FromCode(isolate, *code);
   return f.Call();
 }
 
-Handle<Code> AssembleCodeImpl(Func assemble) {
-  Isolate* isolate = CcTest::i_isolate();
+Handle<Code> AssembleCodeImpl(Isolate* isolate, Func assemble) {
   MacroAssembler assm(isolate, CodeObjectRequired::kYes);
 
   assemble(assm);
diff --git a/test/cctest/test-helper-riscv64.h b/test/cctest/test-helper-riscv64.h
index 6bd2c996e5e..a6914e20c28 100644
--- a/test/cctest/test-helper-riscv64.h
+++ b/test/cctest/test-helper-riscv64.h
@@ -67,7 +67,7 @@ OUTPUT_T GenAndRunTest(INPUT_T input0, Func test_generator) {
       typename std::conditional<sizeof(INPUT_T) == 4, int32_t,
                                 int64_t>::type>::type;
 
-  auto f = GeneratedCode<OINT_T(IINT_T)>::FromCode(*code);
+  auto f = GeneratedCode<OINT_T(IINT_T)>::FromCode(isolate, *code);
 
   auto res = f.Call(base::bit_cast<IINT_T>(input0));
   return base::bit_cast<OUTPUT_T>(res);
@@ -114,7 +114,7 @@ OUTPUT_T GenAndRunTest(INPUT_T input0, INPUT_T input1, Func test_generator) {
       std::is_integral<INPUT_T>::value, INPUT_T,
       typename std::conditional<sizeof(INPUT_T) == 4, int32_t,
                                 int64_t>::type>::type;
-  auto f = GeneratedCode<OINT_T(IINT_T, IINT_T)>::FromCode(*code);
+  auto f = GeneratedCode<OINT_T(IINT_T, IINT_T)>::FromCode(isolate, *code);
 
   auto res =
       f.Call(base::bit_cast<IINT_T>(input0), base::bit_cast<IINT_T>(input1));
@@ -165,7 +165,8 @@ OUTPUT_T GenAndRunTest(INPUT_T input0, INPUT_T input1, INPUT_T input2,
       std::is_integral<INPUT_T>::value, INPUT_T,
       typename std::conditional<sizeof(INPUT_T) == 4, int32_t,
                                 int64_t>::type>::type;
-  auto f = GeneratedCode<OINT_T(IINT_T, IINT_T, IINT_T)>::FromCode(*code);
+  auto f =
+      GeneratedCode<OINT_T(IINT_T, IINT_T, IINT_T)>::FromCode(isolate, *code);
 
   auto res =
       f.Call(base::bit_cast<IINT_T>(input0), base::bit_cast<IINT_T>(input1),
@@ -211,7 +212,8 @@ void GenAndRunTestForLoadStore(T value, Func test_generator) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 
-  auto f = GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(*code);
+  auto f =
+      GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(isolate, *code);
 
   int64_t tmp = 0;
   auto res = f.Call(&tmp, base::bit_cast<INT_T>(value));
@@ -258,7 +260,8 @@ void GenAndRunTestForLRSC(T value, Func test_generator) {
       typename std::conditional<sizeof(T) == 4, int32_t, int64_t>::type;
 
   T tmp = 0;
-  auto f = GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(*code);
+  auto f =
+      GeneratedCode<INT_T(void* base, INT_T val)>::FromCode(isolate, *code);
   auto res = f.Call(&tmp, base::bit_cast<T>(value));
   CHECK_EQ(base::bit_cast<T>(res), static_cast<T>(0));
 }
@@ -318,18 +321,19 @@ OUTPUT_T GenAndRunTestForAMO(INPUT_T input0, INPUT_T input1,
   code->Print();
 #endif
   OUTPUT_T tmp = 0;
-  auto f =
-      GeneratedCode<OUTPUT_T(void* base, INPUT_T, INPUT_T)>::FromCode(*code);
+  auto f = GeneratedCode<OUTPUT_T(void* base, INPUT_T, INPUT_T)>::FromCode(
+      isolate, *code);
   auto res = f.Call(&tmp, base::bit_cast<INPUT_T>(input0),
                     base::bit_cast<INPUT_T>(input1));
   return base::bit_cast<OUTPUT_T>(res);
 }
 
-Handle<Code> AssembleCodeImpl(Func assemble);
+Handle<Code> AssembleCodeImpl(Isolate* isolate, Func assemble);
 
 template <typename Signature>
-GeneratedCode<Signature> AssembleCode(Func assemble) {
-  return GeneratedCode<Signature>::FromCode(*AssembleCodeImpl(assemble));
+GeneratedCode<Signature> AssembleCode(Isolate* isolate, Func assemble) {
+  return GeneratedCode<Signature>::FromCode(
+      isolate, *AssembleCodeImpl(isolate, assemble));
 }
 
 template <typename T>
diff --git a/test/cctest/test-macro-assembler-riscv32.cc b/test/cctest/test-macro-assembler-riscv32.cc
index 64928a5eba0..533e1ac0434 100644
--- a/test/cctest/test-macro-assembler-riscv32.cc
+++ b/test/cctest/test-macro-assembler-riscv32.cc
@@ -69,7 +69,7 @@ static uint32_t run_CalcScaledAddress(uint32_t rt, uint32_t rs, int8_t sa) {
   auto fn = [sa](MacroAssembler& masm) {
     __ CalcScaledAddress(a0, a0, a1, sa);
   };
-  auto f = AssembleCode<FV>(fn);
+  auto f = AssembleCode<FV>(isolate, fn);
 
   uint32_t res = reinterpret_cast<uint32_t>(f.Call(rt, rs, 0, 0, 0));
 
@@ -86,7 +86,7 @@ VTYPE run_Unaligned(char* memory_buffer, int32_t in_offset, int32_t out_offset,
              GenerateUnalignedInstructionFunc](MacroAssembler& masm) {
     GenerateUnalignedInstructionFunc(masm, in_offset, out_offset);
   };
-  auto f = AssembleCode<int32_t(char*)>(fn);
+  auto f = AssembleCode<int32_t(char*)>(isolate, fn);
 
   MemCopy(memory_buffer + in_offset, &value, sizeof(VTYPE));
   f.Call(memory_buffer);
@@ -130,7 +130,7 @@ TEST(LoadConstants) {
       __ AddWord(a4, a4, Operand(kSystemPointerSize));
     }
   };
-  auto f = AssembleCode<FV>(fn);
+  auto f = AssembleCode<FV>(isolate, fn);
 
   (void)f.Call(reinterpret_cast<int32_t>(result), 0, 0, 0, 0);
   // Check results.
@@ -175,7 +175,7 @@ TEST(LoadAddress) {
   masm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<FV>::FromCode(*code);
+  auto f = GeneratedCode<FV>::FromCode(isolate, *code);
 
   (void)f.Call(0, 0, 0, 0, 0);
   // Check results.
@@ -232,7 +232,7 @@ TEST(jump_tables4) {
 #ifdef OBJECT_PRINT
   code->Print(std::cout);
 #endif
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kNumCases; ++i) {
     int32_t res = reinterpret_cast<int32_t>(f.Call(i, 0, 0, 0, 0));
     // ::printf("f(%d) = %" PRId64 "\n", i, res);
@@ -319,7 +319,7 @@ TEST(jump_tables6) {
 #ifdef OBJECT_PRINT
   code->Print(std::cout);
 #endif
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kSwitchTableCases; ++i) {
     int32_t res = reinterpret_cast<int32_t>(f.Call(i, 0, 0, 0, 0));
     ::printf("f(%d) = %" PRId32 "\n", i, res);
@@ -522,7 +522,7 @@ TEST(OverflowInstructions) {
         __ Sw(t0, MemOperand(a0, offsetof(T, output_mul2)));
         __ Sw(a1, MemOperand(a0, offsetof(T, overflow_mul2)));
       };
-      auto f = AssembleCode<F3>(fn);
+      auto f = AssembleCode<F3>(isolate, fn);
 
       t.lhs = ii;
       t.rhs = jj;
@@ -614,7 +614,7 @@ TEST(min_max_nan) {
     __ StoreFloat(fa0, MemOperand(a0, offsetof(TestFloat, h)));
     __ pop(s6);
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   for (int i = 0; i < kTableLength; i++) {
     test.a = inputsa[i];
@@ -890,7 +890,7 @@ TEST(macro_float_minmax_f32) {
   };
 
   auto f = AssembleCode<F4>(
-      GenerateMacroFloat32MinMax<FPURegister, Inputs, Results>);
+      isolate, GenerateMacroFloat32MinMax<FPURegister, Inputs, Results>);
 
 #define CHECK_MINMAX(src1, src2, min, max)                                \
   do {                                                                    \
@@ -990,7 +990,7 @@ TEST(macro_float_minmax_f64) {
   };
 
   auto f = AssembleCode<F4>(
-      GenerateMacroFloat64MinMax<DoubleRegister, Inputs, Results>);
+      isolate, GenerateMacroFloat64MinMax<DoubleRegister, Inputs, Results>);
 
 #define CHECK_MINMAX(src1, src2, min, max)                          \
   do {                                                              \
@@ -1247,7 +1247,7 @@ TEST(Popcnt) {
     __ Sw(a5, MemOperand(a4));
     __ AddWord(a4, a4, Operand(kSystemPointerSize));
   };
-  auto f = AssembleCode<FV>(fn);
+  auto f = AssembleCode<FV>(isolate, fn);
 
   (void)f.Call(reinterpret_cast<uint32_t>(result), 0, 0, 0, 0);
   // Check results.
diff --git a/test/cctest/test-macro-assembler-riscv64.cc b/test/cctest/test-macro-assembler-riscv64.cc
index 6769223a08e..d88b2912f77 100644
--- a/test/cctest/test-macro-assembler-riscv64.cc
+++ b/test/cctest/test-macro-assembler-riscv64.cc
@@ -67,7 +67,7 @@ static uint64_t run_CalcScaledAddress(uint64_t rt, uint64_t rs, int8_t sa) {
   auto fn = [sa](MacroAssembler& masm) {
     __ CalcScaledAddress(a0, a0, a1, sa);
   };
-  auto f = AssembleCode<FV>(fn);
+  auto f = AssembleCode<FV>(isolate, fn);
 
   uint64_t res = reinterpret_cast<uint64_t>(f.Call(rt, rs, 0, 0, 0));
 
@@ -84,7 +84,7 @@ VTYPE run_Unaligned(char* memory_buffer, int32_t in_offset, int32_t out_offset,
              GenerateUnalignedInstructionFunc](MacroAssembler& masm) {
     GenerateUnalignedInstructionFunc(masm, in_offset, out_offset);
   };
-  auto f = AssembleCode<int32_t(char*)>(fn);
+  auto f = AssembleCode<int32_t(char*)>(isolate, fn);
 
   MemCopy(memory_buffer + in_offset, &value, sizeof(VTYPE));
   f.Call(memory_buffer);
@@ -128,7 +128,7 @@ TEST(LoadConstants) {
       __ Add64(a4, a4, Operand(kSystemPointerSize));
     }
   };
-  auto f = AssembleCode<FV>(fn);
+  auto f = AssembleCode<FV>(isolate, fn);
 
   (void)f.Call(reinterpret_cast<int64_t>(result), 0, 0, 0, 0);
   // Check results.
@@ -173,7 +173,7 @@ TEST(LoadAddress) {
   masm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<FV>::FromCode(*code);
+  auto f = GeneratedCode<FV>::FromCode(isolate, *code);
 
   (void)f.Call(0, 0, 0, 0, 0);
   // Check results.
@@ -230,7 +230,7 @@ TEST(jump_tables4) {
 #ifdef OBJECT_PRINT
   code->Print(std::cout);
 #endif
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kNumCases; ++i) {
     int64_t res = reinterpret_cast<int64_t>(f.Call(i, 0, 0, 0, 0));
     // ::printf("f(%d) = %" PRId64 "\n", i, res);
@@ -317,7 +317,7 @@ TEST(jump_tables6) {
 #ifdef OBJECT_PRINT
   code->Print(std::cout);
 #endif
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kSwitchTableCases; ++i) {
     int64_t res = reinterpret_cast<int64_t>(f.Call(i, 0, 0, 0, 0));
     // ::printf("f(%d) = %" PRId64 "\n", i, res);
@@ -582,7 +582,7 @@ TEST(OverflowInstructions) {
         __ Sd(t0, MemOperand(a0, offsetof(T, output_mul2)));
         __ Sd(a1, MemOperand(a0, offsetof(T, overflow_mul2)));
       };
-      auto f = AssembleCode<F3>(fn);
+      auto f = AssembleCode<F3>(isolate, fn);
 
       t.lhs = ii;
       t.rhs = jj;
@@ -674,7 +674,7 @@ TEST(min_max_nan) {
     __ StoreFloat(fa0, MemOperand(a0, offsetof(TestFloat, h)));
     __ pop(s6);
   };
-  auto f = AssembleCode<F3>(fn);
+  auto f = AssembleCode<F3>(isolate, fn);
 
   for (int i = 0; i < kTableLength; i++) {
     test.a = inputsa[i];
@@ -1054,7 +1054,7 @@ TEST(macro_float_minmax_f32) {
   };
 
   auto f = AssembleCode<F4>(
-      GenerateMacroFloat32MinMax<FPURegister, Inputs, Results>);
+      isolate, GenerateMacroFloat32MinMax<FPURegister, Inputs, Results>);
 
 #define CHECK_MINMAX(src1, src2, min, max)                                \
   do {                                                                    \
@@ -1154,7 +1154,7 @@ TEST(macro_float_minmax_f64) {
   };
 
   auto f = AssembleCode<F4>(
-      GenerateMacroFloat64MinMax<DoubleRegister, Inputs, Results>);
+      isolate, GenerateMacroFloat64MinMax<DoubleRegister, Inputs, Results>);
 
 #define CHECK_MINMAX(src1, src2, min, max)                          \
   do {                                                              \
@@ -1433,7 +1433,7 @@ TEST(Dpopcnt) {
     __ Sd(a5, MemOperand(a4));
     __ Add64(a4, a4, Operand(kSystemPointerSize));
   };
-  auto f = AssembleCode<FV>(fn);
+  auto f = AssembleCode<FV>(isolate, fn);
 
   (void)f.Call(reinterpret_cast<int64_t>(result), 0, 0, 0, 0);
   // Check results.
@@ -1485,7 +1485,7 @@ TEST(Popcnt) {
     __ Sd(a5, MemOperand(a4));
     __ Add64(a4, a4, Operand(kSystemPointerSize));
   };
-  auto f = AssembleCode<FV>(fn);
+  auto f = AssembleCode<FV>(isolate, fn);
 
   (void)f.Call(reinterpret_cast<int64_t>(result), 0, 0, 0, 0);
   // Check results.
diff --git a/test/cctest/test-simple-riscv32.cc b/test/cctest/test-simple-riscv32.cc
index 7a81643d420..be8919f0c73 100644
--- a/test/cctest/test-simple-riscv32.cc
+++ b/test/cctest/test-simple-riscv32.cc
@@ -64,7 +64,7 @@ TEST(RISCV_SIMPLE0) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F2>::FromCode(*code);
+  auto f = GeneratedCode<F2>::FromCode(isolate, *code);
   int32_t res = reinterpret_cast<int32_t>(f.Call(0xAB0, 0xC, 0, 0, 0));
   CHECK_EQ(0xABCL, res);
 }
@@ -84,7 +84,7 @@ TEST(RISCV_SIMPLE1) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int32_t res = reinterpret_cast<int32_t>(f.Call(100, 0, 0, 0, 0));
   CHECK_EQ(99L, res);
 }
@@ -118,7 +118,7 @@ TEST(RISCV_SIMPLE2) {
 #ifdef DEBUG
   code->Print();
 #endif
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int32_t res = reinterpret_cast<int32_t>(f.Call(100, 0, 0, 0, 0));
   CHECK_EQ(5050, res);
 }
@@ -139,7 +139,7 @@ TEST(RISCV_SIMPLE3) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int32_t res = reinterpret_cast<int32_t>(f.Call(255, 0, 0, 0, 0));
   CHECK_EQ(-1, res);
 }
@@ -179,7 +179,7 @@ TEST(LI) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int32_t res = reinterpret_cast<int32_t>(f.Call(0xDEADBEEF, 0, 0, 0, 0));
   CHECK_EQ(0L, res);
 }
@@ -218,7 +218,7 @@ TEST(LI_CONST) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int32_t res = reinterpret_cast<int32_t>(f.Call(0xDEADBEEF, 0, 0, 0, 0));
   CHECK_EQ(0L, res);
 }
diff --git a/test/cctest/test-simple-riscv64.cc b/test/cctest/test-simple-riscv64.cc
index c5feda47df1..3cb1dddcec4 100644
--- a/test/cctest/test-simple-riscv64.cc
+++ b/test/cctest/test-simple-riscv64.cc
@@ -64,7 +64,7 @@ TEST(RISCV_SIMPLE0) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F2>::FromCode(*code);
+  auto f = GeneratedCode<F2>::FromCode(isolate, *code);
   int64_t res = reinterpret_cast<int64_t>(f.Call(0xAB0, 0xC, 0, 0, 0));
   CHECK_EQ(0xABCL, res);
 }
@@ -84,7 +84,7 @@ TEST(RISCV_SIMPLE1) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int64_t res = reinterpret_cast<int64_t>(f.Call(100, 0, 0, 0, 0));
   CHECK_EQ(99L, res);
 }
@@ -118,7 +118,7 @@ TEST(RISCV_SIMPLE2) {
 #ifdef DEBUG
   code->Print();
 #endif
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int64_t res = reinterpret_cast<int64_t>(f.Call(100, 0, 0, 0, 0));
   CHECK_EQ(5050, res);
 }
@@ -139,7 +139,7 @@ TEST(RISCV_SIMPLE3) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int64_t res = reinterpret_cast<int64_t>(f.Call(255, 0, 0, 0, 0));
   CHECK_EQ(-1, res);
 }
@@ -191,7 +191,7 @@ TEST(LI) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int64_t res = reinterpret_cast<int64_t>(f.Call(0xDEADBEEF, 0, 0, 0, 0));
   CHECK_EQ(0L, res);
 }
@@ -242,7 +242,7 @@ TEST(LI_CONST) {
   assm.GetCode(isolate, &desc);
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
-  auto f = GeneratedCode<F1>::FromCode(*code);
+  auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int64_t res = reinterpret_cast<int64_t>(f.Call(0xDEADBEEF, 0, 0, 0, 0));
   CHECK_EQ(0L, res);
 }
-- 
2.35.1


From bdb20626c106aa144ab06b624990dd8dccb085bc Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Thu, 26 May 2022 13:19:31 +0800
Subject: [PATCH] [riscv64] Fix return value of lazy compile runtime function

Port commit 22a16bda86492deea2f5a33fd89c63df162ed809

Change-Id: I1a6815ca22f4b931ffd2468d8aeb82dc7a1e2bc5
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3669661
Commit-Queue: ji qiu <qiuji@iscas.ac.cn>
Reviewed-by: ji qiu <qiuji@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#80759}
---
 src/builtins/riscv64/builtins-riscv64.cc      | 67 +++++++++++--------
 .../riscv64/frame-constants-riscv64.h         |  5 +-
 2 files changed, 42 insertions(+), 30 deletions(-)

diff --git a/src/builtins/riscv64/builtins-riscv64.cc b/src/builtins/riscv64/builtins-riscv64.cc
index b6a1f6dcb0..f79e2997b5 100644
--- a/src/builtins/riscv64/builtins-riscv64.cc
+++ b/src/builtins/riscv64/builtins-riscv64.cc
@@ -2772,37 +2772,40 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
   // The function index was put in t0 by the jump table trampoline.
   // Convert to Smi for the runtime call
   __ SmiTag(kWasmCompileLazyFuncIndexRegister);
-  {
-    HardAbortScope hard_abort(masm);  // Avoid calls to Abort.
-    FrameScope scope(masm, StackFrame::WASM_COMPILE_LAZY);
 
-    // Save all parameter registers (see kGpParamRegisters in wasm-linkage.cc).
-    // They might be overwritten in the runtime call below. We don't have any
-    // callee-saved registers in wasm, so no need to store anything else.
-    RegList gp_regs;
+  RegList kSavedGpRegs = ([]() constexpr {
+    RegList saved_gp_regs;
     for (Register gp_param_reg : wasm::kGpParamRegisters) {
-      gp_regs.set(gp_param_reg);
+      saved_gp_regs.set(gp_param_reg);
     }
-    // Also push a1, because we must push multiples of 16 bytes (see
-    // {TurboAssembler::PushCPURegList}.
-    CHECK_EQ(1, gp_regs.Count() % 2);
-    gp_regs.set(a1);
-    // Ensure that A1 will not be repeated.
-    CHECK_EQ(0, gp_regs.Count() % 2);
-
-    DoubleRegList fp_regs;
+
+    // All set registers were unique.
+    CHECK_EQ(saved_gp_regs.Count(), arraysize(wasm::kGpParamRegisters));
+    // The Wasm instance must be part of the saved registers.
+    CHECK(saved_gp_regs.has(kWasmInstanceRegister));
+    CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
+             saved_gp_regs.Count());
+    return saved_gp_regs;
+  })();
+
+  DoubleRegList kSavedFpRegs = ([]() constexpr {
+    DoubleRegList saved_fp_regs;
     for (DoubleRegister fp_param_reg : wasm::kFpParamRegisters) {
-      fp_regs.set(fp_param_reg);
+      saved_fp_regs.set(fp_param_reg);
     }
 
-    CHECK_EQ(gp_regs.Count(), arraysize(wasm::kGpParamRegisters) + 1);
-    CHECK_EQ(fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
-    CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedGpParamRegs,
-             gp_regs.Count());
+    CHECK_EQ(saved_fp_regs.Count(), arraysize(wasm::kFpParamRegisters));
     CHECK_EQ(WasmCompileLazyFrameConstants::kNumberOfSavedFpParamRegs,
-             fp_regs.Count());
-    __ MultiPush(gp_regs);
-    __ MultiPushFPU(fp_regs);
+             saved_fp_regs.Count());
+    return saved_fp_regs;
+  })();
+
+  {
+    HardAbortScope hard_abort(masm);  // Avoid calls to Abort.
+    FrameScope scope(masm, StackFrame::WASM_COMPILE_LAZY);
+
+    __ MultiPush(kSavedGpRegs);
+    __ MultiPushFPU(kSavedFpRegs);
 
     // Pass instance and function index as an explicit arguments to the runtime
     // function.
@@ -2812,13 +2815,21 @@ void Builtins::Generate_WasmCompileLazy(MacroAssembler* masm) {
     __ Move(kContextRegister, Smi::zero());
     __ CallRuntime(Runtime::kWasmCompileLazy, 2);
 
-    __ Move(s1, a0);  // move return value to s1 since a0 will be restored to
-                      // the value before the call
+    __ SmiUntag(s1, a0);  // move return value to s1 since a0 will be restored
+                          // to the value before the call
+    CHECK(!kSavedGpRegs.has(s1));
 
     // Restore registers.
-    __ MultiPopFPU(fp_regs);
-    __ MultiPop(gp_regs);
+    __ MultiPopFPU(kSavedFpRegs);
+    __ MultiPop(kSavedGpRegs);
   }
+
+  // The runtime function returned the jump table slot offset as a Smi (now in
+  // x17). Use that to compute the jump target.
+  __ Ld(kScratchReg,
+        MemOperand(kWasmInstanceRegister,
+                   WasmInstanceObject::kJumpTableStartOffset - kHeapObjectTag));
+  __ Add64(s1, s1, Operand(kScratchReg));
   // Finally, jump to the entrypoint.
   __ Jump(s1);
 }
diff --git a/src/execution/riscv64/frame-constants-riscv64.h b/src/execution/riscv64/frame-constants-riscv64.h
index 6b70815ea4..d5e3165956 100644
--- a/src/execution/riscv64/frame-constants-riscv64.h
+++ b/src/execution/riscv64/frame-constants-riscv64.h
@@ -24,14 +24,15 @@ class EntryFrameConstants : public AllStatic {
 class WasmCompileLazyFrameConstants : public TypedFrameConstants {
  public:
   static constexpr int kNumberOfSavedGpParamRegs =
-      arraysize(wasm::kGpParamRegisters) + 1;
+      arraysize(wasm::kGpParamRegisters);
   static constexpr int kNumberOfSavedFpParamRegs =
       arraysize(wasm::kFpParamRegisters);
   static constexpr int kNumberOfSavedAllParamRegs =
       kNumberOfSavedGpParamRegs + kNumberOfSavedFpParamRegs;
 
   // FP-relative.
-  // See Generate_WasmCompileLazy in builtins-mips64.cc.
+  // See Generate_WasmCompileLazy in builtins-riscv64.cc.
+  // TODO(riscv): add rvv v reg save
   static constexpr int kWasmInstanceOffset =
       TYPED_FRAME_PUSHED_VALUE_OFFSET(kNumberOfSavedAllParamRegs);
   static constexpr int kFixedFrameSizeFromFp =
-- 
2.35.1


From 9e76247ae826dc307c418ed6f6e8dc46735d458f Mon Sep 17 00:00:00 2001
From: Andreas Haas <ahaas@chromium.org>
Date: Tue, 13 Apr 2021 11:30:43 +0200
Subject: [PATCH] [wasm][x64] Use the cmov instruction for WebAssembly's Select

R=thibaudm@chromium.org, jgruber@chromium.org

Bug: v8:10740
Change-Id: Iceb20f00f6f8505885856400a0c0228708ff3979
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2807610
Commit-Queue: Andreas Haas <ahaas@chromium.org>
Reviewed-by: Thibaud Michaud <thibaudm@chromium.org>
Reviewed-by: Georg Neis <neis@chromium.org>
Cr-Commit-Position: refs/heads/master@{#73933}
---
 .../backend/arm/instruction-selector-arm.cc   |  6 ++
 .../arm64/instruction-selector-arm64.cc       |  6 ++
 .../backend/ia32/instruction-selector-ia32.cc |  6 ++
 .../backend/instruction-selector-impl.h       | 10 +-
 src/compiler/backend/instruction-selector.cc  | 14 ++-
 src/compiler/backend/instruction-selector.h   |  3 +
 src/compiler/backend/instruction.cc           |  4 +-
 src/compiler/backend/instruction.h            | 18 +++-
 .../backend/mips/instruction-selector-mips.cc |  6 ++
 .../mips64/instruction-selector-mips64.cc     |  6 ++
 .../backend/ppc/instruction-selector-ppc.cc   |  6 ++
 .../backend/register-allocator-verifier.cc    | 22 +++--
 .../backend/register-allocator-verifier.h     |  2 +-
 src/compiler/backend/register-allocator.cc    |  2 +-
 .../riscv64/instruction-selector-riscv64.cc   |  6 ++
 .../backend/s390/instruction-selector-s390.cc |  6 ++
 .../backend/x64/code-generator-x64.cc         | 21 ++++-
 .../backend/x64/instruction-selector-x64.cc   | 25 ++++-
 src/compiler/graph-visualizer.cc              |  5 +-
 src/compiler/machine-operator.cc              |  2 +
 src/compiler/machine-operator.h               | 10 +-
 src/compiler/opcodes.h                        |  2 +
 src/compiler/raw-machine-assembler.h          |  9 ++
 src/compiler/verifier.cc                      |  2 +
 src/compiler/wasm-compiler.cc                 |  8 ++
 test/cctest/compiler/test-run-machops.cc      | 92 +++++++++++++++++++
 .../backend/instruction-selector-unittest.cc  |  8 ++
 .../backend/instruction-selector-unittest.h   |  2 +
 .../backend/instruction-sequence-unittest.cc  |  4 +-
 .../backend/instruction-sequence-unittest.h   |  4 +-
 .../compiler/machine-operator-unittest.cc     |  2 +
 .../x64/instruction-selector-x64-unittest.cc  | 28 ++++++
 32 files changed, 315 insertions(+), 32 deletions(-)

diff --git a/src/compiler/backend/arm/instruction-selector-arm.cc b/src/compiler/backend/arm/instruction-selector-arm.cc
index 0e32ec42522..9084b53c10c 100644
--- a/src/compiler/backend/arm/instruction-selector-arm.cc
+++ b/src/compiler/backend/arm/instruction-selector-arm.cc
@@ -3173,6 +3173,12 @@ void InstructionSelector::VisitF64x2PromoteLowF32x4(Node* node) {
        g.UseFixed(node->InputAt(0), q0));
 }
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  UNREACHABLE();
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/arm64/instruction-selector-arm64.cc b/src/compiler/backend/arm64/instruction-selector-arm64.cc
index 7df58a405d4..ec72cd3ae66 100644
--- a/src/compiler/backend/arm64/instruction-selector-arm64.cc
+++ b/src/compiler/backend/arm64/instruction-selector-arm64.cc
@@ -4037,6 +4037,12 @@ void InstructionSelector::VisitI8x16Popcnt(Node* node) {
   VisitRR(this, code, node);
 }
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  continuation_outputs_.push_back(g->DefineAsRegister(node));
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/ia32/instruction-selector-ia32.cc b/src/compiler/backend/ia32/instruction-selector-ia32.cc
index 31edd07e1cc..3fbdebd6e65 100644
--- a/src/compiler/backend/ia32/instruction-selector-ia32.cc
+++ b/src/compiler/backend/ia32/instruction-selector-ia32.cc
@@ -3162,6 +3162,12 @@ void InstructionSelector::VisitI64x2Abs(Node* node) {
   VisitRRSimd(this, node, kIA32I64x2Abs, kIA32I64x2Abs);
 }
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  UNREACHABLE();
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/instruction-selector-impl.h b/src/compiler/backend/instruction-selector-impl.h
index 7e1f183fb71..539ba5dc255 100644
--- a/src/compiler/backend/instruction-selector-impl.h
+++ b/src/compiler/backend/instruction-selector-impl.h
@@ -85,10 +85,12 @@ class OperandGenerator {
                                      GetVReg(node)));
   }
 
+  InstructionOperand DefineSameAsInput(Node* node, int input_index) {
+    return Define(node, UnallocatedOperand(GetVReg(node), input_index));
+  }
+
   InstructionOperand DefineSameAsFirst(Node* node) {
-    return Define(node,
-                  UnallocatedOperand(UnallocatedOperand::SAME_AS_FIRST_INPUT,
-                                     GetVReg(node)));
+    return DefineSameAsInput(node, 0);
   }
 
   InstructionOperand DefineAsFixed(Node* node, Register reg) {
@@ -224,7 +226,7 @@ class OperandGenerator {
   int AllocateVirtualRegister() { return sequence()->NextVirtualRegister(); }
 
   InstructionOperand DefineSameAsFirstForVreg(int vreg) {
-    return UnallocatedOperand(UnallocatedOperand::SAME_AS_FIRST_INPUT, vreg);
+    return UnallocatedOperand(UnallocatedOperand::SAME_AS_INPUT, vreg);
   }
 
   InstructionOperand DefineAsRegistertForVreg(int vreg) {
diff --git a/src/compiler/backend/instruction-selector.cc b/src/compiler/backend/instruction-selector.cc
index c4cfa4756ed..5a383288321 100644
--- a/src/compiler/backend/instruction-selector.cc
+++ b/src/compiler/backend/instruction-selector.cc
@@ -880,8 +880,16 @@ Instruction* InstructionSelector::EmitWithContinuation(
     AppendDeoptimizeArguments(&continuation_inputs_, cont->kind(),
                               cont->reason(), cont->feedback(),
                               FrameState{cont->frame_state()});
-  } else if (cont->IsSet() || cont->IsSelect()) {
+  } else if (cont->IsSet()) {
     continuation_outputs_.push_back(g.DefineAsRegister(cont->result()));
+  } else if (cont->IsSelect()) {
+    // The {Select} should put one of two values into the output register,
+    // depending on the result of the condition. The two result values are in
+    // the last two input slots, the {false_value} in {input_count - 2}, and the
+    // true_value in {input_count - 1}. The other inputs are used for the
+    // condition.
+    AddOutputToSelectContinuation(&g, static_cast<int>(input_count) - 2,
+                                  cont->result());
   } else if (cont->IsTrap()) {
     int trap_id = static_cast<int>(cont->trap_id());
     continuation_inputs_.push_back(g.UseImmediate(trap_id));
@@ -1554,6 +1562,8 @@ void InstructionSelector::VisitNode(Node* node) {
       return MarkAsWord32(node), VisitWord32Popcnt(node);
     case IrOpcode::kWord64Popcnt:
       return MarkAsWord32(node), VisitWord64Popcnt(node);
+    case IrOpcode::kWord32Select:
+      return MarkAsWord32(node), VisitSelect(node);
     case IrOpcode::kWord64And:
       return MarkAsWord64(node), VisitWord64And(node);
     case IrOpcode::kWord64Or:
@@ -1584,6 +1594,8 @@ void InstructionSelector::VisitNode(Node* node) {
       return MarkAsWord64(node), VisitInt64AbsWithOverflow(node);
     case IrOpcode::kWord64Equal:
       return VisitWord64Equal(node);
+    case IrOpcode::kWord64Select:
+      return MarkAsWord64(node), VisitSelect(node);
     case IrOpcode::kInt32Add:
       return MarkAsWord32(node), VisitInt32Add(node);
     case IrOpcode::kInt32AddWithOverflow:
diff --git a/src/compiler/backend/instruction-selector.h b/src/compiler/backend/instruction-selector.h
index 9f60954ef43..d3285822cc4 100644
--- a/src/compiler/backend/instruction-selector.h
+++ b/src/compiler/backend/instruction-selector.h
@@ -680,6 +680,9 @@ class V8_EXPORT_PRIVATE InstructionSelector final {
 
   bool CanProduceSignalingNaN(Node* node);
 
+  void AddOutputToSelectContinuation(OperandGenerator* g, int first_input_index,
+                                     Node* node);
+
   // ===========================================================================
   // ============= Vector instruction (SIMD) helper fns. =======================
   // ===========================================================================
diff --git a/src/compiler/backend/instruction.cc b/src/compiler/backend/instruction.cc
index f00d4dd034c..f90a249d9a3 100644
--- a/src/compiler/backend/instruction.cc
+++ b/src/compiler/backend/instruction.cc
@@ -155,8 +155,8 @@ std::ostream& operator<<(std::ostream& os, const InstructionOperand& op) {
           return os << "(R)";
         case UnallocatedOperand::MUST_HAVE_SLOT:
           return os << "(S)";
-        case UnallocatedOperand::SAME_AS_FIRST_INPUT:
-          return os << "(1)";
+        case UnallocatedOperand::SAME_AS_INPUT:
+          return os << "(" << unalloc->input_index() << ")";
         case UnallocatedOperand::REGISTER_OR_SLOT:
           return os << "(-)";
         case UnallocatedOperand::REGISTER_OR_SLOT_OR_CONSTANT:
diff --git a/src/compiler/backend/instruction.h b/src/compiler/backend/instruction.h
index 850dd71ae22..33146f3c4f0 100644
--- a/src/compiler/backend/instruction.h
+++ b/src/compiler/backend/instruction.h
@@ -185,7 +185,7 @@ class UnallocatedOperand final : public InstructionOperand {
     FIXED_FP_REGISTER,
     MUST_HAVE_REGISTER,
     MUST_HAVE_SLOT,
-    SAME_AS_FIRST_INPUT
+    SAME_AS_INPUT
   };
 
   // Lifetime of operand inside the instruction.
@@ -208,6 +208,14 @@ class UnallocatedOperand final : public InstructionOperand {
     value_ |= LifetimeField::encode(USED_AT_END);
   }
 
+  UnallocatedOperand(int virtual_register, int input_index)
+      : UnallocatedOperand(virtual_register) {
+    value_ |= BasicPolicyField::encode(EXTENDED_POLICY);
+    value_ |= ExtendedPolicyField::encode(SAME_AS_INPUT);
+    value_ |= LifetimeField::encode(USED_AT_END);
+    value_ |= InputIndexField::encode(input_index);
+  }
+
   UnallocatedOperand(BasicPolicy policy, int index, int virtual_register)
       : UnallocatedOperand(virtual_register) {
     DCHECK(policy == FIXED_SLOT);
@@ -270,7 +278,7 @@ class UnallocatedOperand final : public InstructionOperand {
   }
   bool HasSameAsInputPolicy() const {
     return basic_policy() == EXTENDED_POLICY &&
-           extended_policy() == SAME_AS_FIRST_INPUT;
+           extended_policy() == SAME_AS_INPUT;
   }
   bool HasFixedSlotPolicy() const { return basic_policy() == FIXED_SLOT; }
   bool HasFixedRegisterPolicy() const {
@@ -300,6 +308,11 @@ class UnallocatedOperand final : public InstructionOperand {
     return ExtendedPolicyField::decode(value_);
   }
 
+  int input_index() const {
+    DCHECK(HasSameAsInputPolicy());
+    return InputIndexField::decode(value_);
+  }
+
   // [fixed_slot_index]: Only for FIXED_SLOT.
   int fixed_slot_index() const {
     DCHECK(HasFixedSlotPolicy());
@@ -362,6 +375,7 @@ class UnallocatedOperand final : public InstructionOperand {
   using HasSecondaryStorageField = base::BitField64<bool, 40, 1>;
   using FixedRegisterField = base::BitField64<int, 41, 6>;
   using SecondaryStorageField = base::BitField64<int, 47, 3>;
+  using InputIndexField = base::BitField64<int, 50, 3>;
 
  private:
   explicit UnallocatedOperand(int virtual_register)
diff --git a/src/compiler/backend/mips/instruction-selector-mips.cc b/src/compiler/backend/mips/instruction-selector-mips.cc
index 04e72a4233b..d2ed6655985 100644
--- a/src/compiler/backend/mips/instruction-selector-mips.cc
+++ b/src/compiler/backend/mips/instruction-selector-mips.cc
@@ -2503,6 +2503,12 @@ void InstructionSelector::VisitF64x2Pmax(Node* node) {
   VisitUniqueRRR(this, kMipsF64x2Pmax, node);
 }
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  UNREACHABLE();
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/mips64/instruction-selector-mips64.cc b/src/compiler/backend/mips64/instruction-selector-mips64.cc
index 2e921a61153..b019374659c 100644
--- a/src/compiler/backend/mips64/instruction-selector-mips64.cc
+++ b/src/compiler/backend/mips64/instruction-selector-mips64.cc
@@ -3294,6 +3294,12 @@ VISIT_EXTADD_PAIRWISE(I32x4ExtAddPairwiseI16x8S, MSAS16)
 VISIT_EXTADD_PAIRWISE(I32x4ExtAddPairwiseI16x8U, MSAU16)
 #undef VISIT_EXTADD_PAIRWISE
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  UNREACHABLE();
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/ppc/instruction-selector-ppc.cc b/src/compiler/backend/ppc/instruction-selector-ppc.cc
index 24c2d6c160c..26a24163dcd 100644
--- a/src/compiler/backend/ppc/instruction-selector-ppc.cc
+++ b/src/compiler/backend/ppc/instruction-selector-ppc.cc
@@ -2644,6 +2644,12 @@ void InstructionSelector::VisitStoreLane(Node* node) {
   Emit(opcode | AddressingModeField::encode(kMode_MRR), 0, nullptr, 4, inputs);
 }
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  UNREACHABLE();
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/register-allocator-verifier.cc b/src/compiler/backend/register-allocator-verifier.cc
index 1587f0ee182..b4099c5fad5 100644
--- a/src/compiler/backend/register-allocator-verifier.cc
+++ b/src/compiler/backend/register-allocator-verifier.cc
@@ -72,7 +72,7 @@ RegisterAllocatorVerifier::RegisterAllocatorVerifier(
   constraints_.reserve(sequence->instructions().size());
   // TODO(dcarney): model unique constraints.
   // Construct OperandConstraints for all InstructionOperands, eliminating
-  // kSameAsFirst along the way.
+  // kSameAsInput along the way.
   for (const Instruction* instr : sequence->instructions()) {
     // All gaps should be totally unallocated at this point.
     VerifyEmptyGaps(instr);
@@ -90,10 +90,11 @@ RegisterAllocatorVerifier::RegisterAllocatorVerifier(
     }
     for (size_t i = 0; i < instr->OutputCount(); ++i, ++count) {
       BuildConstraint(instr->OutputAt(i), &op_constraints[count]);
-      if (op_constraints[count].type_ == kSameAsFirst) {
-        CHECK_LT(0, instr->InputCount());
-        op_constraints[count].type_ = op_constraints[0].type_;
-        op_constraints[count].value_ = op_constraints[0].value_;
+      if (op_constraints[count].type_ == kSameAsInput) {
+        int input_index = op_constraints[count].value_;
+        CHECK_LT(input_index, instr->InputCount());
+        op_constraints[count].type_ = op_constraints[input_index].type_;
+        op_constraints[count].value_ = op_constraints[input_index].value_;
       }
       VerifyOutput(op_constraints[count]);
     }
@@ -105,7 +106,7 @@ RegisterAllocatorVerifier::RegisterAllocatorVerifier(
 
 void RegisterAllocatorVerifier::VerifyInput(
     const OperandConstraint& constraint) {
-  CHECK_NE(kSameAsFirst, constraint.type_);
+  CHECK_NE(kSameAsInput, constraint.type_);
   if (constraint.type_ != kImmediate) {
     CHECK_NE(InstructionOperand::kInvalidVirtualRegister,
              constraint.virtual_register_);
@@ -114,7 +115,7 @@ void RegisterAllocatorVerifier::VerifyInput(
 
 void RegisterAllocatorVerifier::VerifyTemp(
     const OperandConstraint& constraint) {
-  CHECK_NE(kSameAsFirst, constraint.type_);
+  CHECK_NE(kSameAsInput, constraint.type_);
   CHECK_NE(kImmediate, constraint.type_);
   CHECK_NE(kConstant, constraint.type_);
 }
@@ -212,8 +213,9 @@ void RegisterAllocatorVerifier::BuildConstraint(const InstructionOperand* op,
           constraint->value_ =
               ElementSizeLog2Of(sequence()->GetRepresentation(vreg));
           break;
-        case UnallocatedOperand::SAME_AS_FIRST_INPUT:
-          constraint->type_ = kSameAsFirst;
+        case UnallocatedOperand::SAME_AS_INPUT:
+          constraint->type_ = kSameAsInput;
+          constraint->value_ = unallocated->input_index();
           break;
       }
     }
@@ -269,7 +271,7 @@ void RegisterAllocatorVerifier::CheckConstraint(
       CHECK_WITH_MSG(op->IsRegister() || op->IsStackSlot() || op->IsConstant(),
                      caller_info_);
       return;
-    case kSameAsFirst:
+    case kSameAsInput:
       CHECK_WITH_MSG(false, caller_info_);
       return;
   }
diff --git a/src/compiler/backend/register-allocator-verifier.h b/src/compiler/backend/register-allocator-verifier.h
index 11bd4924f4e..c812642d338 100644
--- a/src/compiler/backend/register-allocator-verifier.h
+++ b/src/compiler/backend/register-allocator-verifier.h
@@ -219,7 +219,7 @@ class RegisterAllocatorVerifier final : public ZoneObject {
     kRegisterOrSlot,
     kRegisterOrSlotFP,
     kRegisterOrSlotOrConstant,
-    kSameAsFirst,
+    kSameAsInput,
     kRegisterAndSlot
   };
 
diff --git a/src/compiler/backend/register-allocator.cc b/src/compiler/backend/register-allocator.cc
index 4ced4056677..dc3509e08da 100644
--- a/src/compiler/backend/register-allocator.cc
+++ b/src/compiler/backend/register-allocator.cc
@@ -1792,7 +1792,7 @@ void ConstraintBuilder::MeetConstraintsBefore(int instr_index) {
     if (!second_output->HasSameAsInputPolicy()) continue;
     DCHECK_EQ(0, i);  // Only valid for first output.
     UnallocatedOperand* cur_input =
-        UnallocatedOperand::cast(second->InputAt(0));
+        UnallocatedOperand::cast(second->InputAt(second_output->input_index()));
     int output_vreg = second_output->virtual_register();
     int input_vreg = cur_input->virtual_register();
     UnallocatedOperand input_copy(UnallocatedOperand::REGISTER_OR_SLOT,
diff --git a/src/compiler/backend/riscv64/instruction-selector-riscv64.cc b/src/compiler/backend/riscv64/instruction-selector-riscv64.cc
index 2fd03b56bfb..a240c6a6575 100644
--- a/src/compiler/backend/riscv64/instruction-selector-riscv64.cc
+++ b/src/compiler/backend/riscv64/instruction-selector-riscv64.cc
@@ -3016,6 +3016,12 @@ VISIT_EXT_MUL(I16x8, I8x16S)
 VISIT_EXT_MUL(I16x8, I8x16U)
 #undef VISIT_EXT_MUL
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  UNREACHABLE();
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/s390/instruction-selector-s390.cc b/src/compiler/backend/s390/instruction-selector-s390.cc
index 72e9ac64ff1..3b04e42f96b 100644
--- a/src/compiler/backend/s390/instruction-selector-s390.cc
+++ b/src/compiler/backend/s390/instruction-selector-s390.cc
@@ -2851,6 +2851,12 @@ void InstructionSelector::VisitTruncateFloat32ToUint32(Node* node) {
   Emit(opcode, g.DefineAsRegister(node), g.UseRegister(node->InputAt(0)));
 }
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  UNREACHABLE();
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
diff --git a/src/compiler/backend/x64/code-generator-x64.cc b/src/compiler/backend/x64/code-generator-x64.cc
index 814f14fb4af..3d5b5982723 100644
--- a/src/compiler/backend/x64/code-generator-x64.cc
+++ b/src/compiler/backend/x64/code-generator-x64.cc
@@ -4451,7 +4451,26 @@ void CodeGenerator::AssembleArchTableSwitch(Instruction* instr) {
 
 void CodeGenerator::AssembleArchSelect(Instruction* instr,
                                        FlagsCondition condition) {
-  UNIMPLEMENTED();
+  X64OperandConverter i(this, instr);
+  MachineRepresentation rep =
+      LocationOperand::cast(instr->OutputAt(0))->representation();
+  Condition cc = FlagsConditionToCondition(condition);
+  DCHECK_EQ(i.OutputRegister(), i.InputRegister(instr->InputCount() - 2));
+  size_t last_input = instr->InputCount() - 1;
+  if (rep == MachineRepresentation::kWord32) {
+    if (HasRegisterInput(instr, last_input)) {
+      __ cmovl(cc, i.OutputRegister(), i.InputRegister(last_input));
+    } else {
+      __ cmovl(cc, i.OutputRegister(), i.InputOperand(last_input));
+    }
+  } else {
+    DCHECK_EQ(rep, MachineRepresentation::kWord64);
+    if (HasRegisterInput(instr, last_input)) {
+      __ cmovq(cc, i.OutputRegister(), i.InputRegister(last_input));
+    } else {
+      __ cmovq(cc, i.OutputRegister(), i.InputOperand(last_input));
+    }
+  }
 }
 
 namespace {
diff --git a/src/compiler/backend/x64/instruction-selector-x64.cc b/src/compiler/backend/x64/instruction-selector-x64.cc
index 6c04e98828a..5859cf27b74 100644
--- a/src/compiler/backend/x64/instruction-selector-x64.cc
+++ b/src/compiler/backend/x64/instruction-selector-x64.cc
@@ -1877,11 +1877,15 @@ void VisitCompareWithMemoryOperand(InstructionSelector* selector,
   DCHECK_EQ(IrOpcode::kLoad, left->opcode());
   X64OperandGenerator g(selector);
   size_t input_count = 0;
-  InstructionOperand inputs[4];
+  InstructionOperand inputs[6];
   AddressingMode addressing_mode =
       g.GetEffectiveAddressMemoryOperand(left, inputs, &input_count);
   opcode |= AddressingModeField::encode(addressing_mode);
   inputs[input_count++] = right;
+  if (cont->IsSelect()) {
+    inputs[input_count++] = g.UseRegister(cont->false_value());
+    inputs[input_count++] = g.Use(cont->true_value());
+  }
 
   selector->EmitWithContinuation(opcode, 0, nullptr, input_count, inputs, cont);
 }
@@ -1890,6 +1894,14 @@ void VisitCompareWithMemoryOperand(InstructionSelector* selector,
 void VisitCompare(InstructionSelector* selector, InstructionCode opcode,
                   InstructionOperand left, InstructionOperand right,
                   FlagsContinuation* cont) {
+  if (cont->IsSelect()) {
+    X64OperandGenerator g(selector);
+    InstructionOperand inputs[] = {left, right,
+                                   g.UseRegister(cont->false_value()),
+                                   g.Use(cont->true_value())};
+    selector->EmitWithContinuation(opcode, 0, nullptr, 4, inputs, cont);
+    return;
+  }
   selector->EmitWithContinuation(opcode, left, right, cont);
 }
 
@@ -3712,13 +3724,22 @@ void InstructionSelector::VisitI64x2Abs(Node* node) {
   }
 }
 
+void InstructionSelector::AddOutputToSelectContinuation(OperandGenerator* g,
+                                                        int first_input_index,
+                                                        Node* node) {
+  continuation_outputs_.push_back(
+      g->DefineSameAsInput(node, first_input_index));
+}
+
 // static
 MachineOperatorBuilder::Flags
 InstructionSelector::SupportedMachineOperatorFlags() {
   MachineOperatorBuilder::Flags flags =
       MachineOperatorBuilder::kWord32ShiftIsSafe |
       MachineOperatorBuilder::kWord32Ctz | MachineOperatorBuilder::kWord64Ctz |
-      MachineOperatorBuilder::kWord32Rol | MachineOperatorBuilder::kWord64Rol;
+      MachineOperatorBuilder::kWord32Rol | MachineOperatorBuilder::kWord64Rol |
+      MachineOperatorBuilder::kWord32Select |
+      MachineOperatorBuilder::kWord64Select;
   if (CpuFeatures::IsSupported(POPCNT)) {
     flags |= MachineOperatorBuilder::kWord32Popcnt |
              MachineOperatorBuilder::kWord64Popcnt;
diff --git a/src/compiler/graph-visualizer.cc b/src/compiler/graph-visualizer.cc
index eb3e4168f9a..e8b78e5762e 100644
--- a/src/compiler/graph-visualizer.cc
+++ b/src/compiler/graph-visualizer.cc
@@ -1132,8 +1132,9 @@ std::ostream& operator<<(std::ostream& os, const InstructionOperandAsJSON& o) {
           os << ",\"tooltip\": \"MUST_HAVE_SLOT\"";
           break;
         }
-        case UnallocatedOperand::SAME_AS_FIRST_INPUT: {
-          os << ",\"tooltip\": \"SAME_AS_FIRST_INPUT\"";
+        case UnallocatedOperand::SAME_AS_INPUT: {
+          os << ",\"tooltip\": \"SAME_AS_INPUT: " << unalloc->input_index()
+             << "\"";
           break;
         }
         case UnallocatedOperand::REGISTER_OR_SLOT: {
diff --git a/src/compiler/machine-operator.cc b/src/compiler/machine-operator.cc
index b0eee7951b4..3a5bb6dfb8c 100644
--- a/src/compiler/machine-operator.cc
+++ b/src/compiler/machine-operator.cc
@@ -583,6 +583,8 @@ std::ostream& operator<<(std::ostream& os, TruncateKind kind) {
   V(Float64RoundTiesAway, Operator::kNoProperties, 1, 0, 1) \
   V(Float32RoundTiesEven, Operator::kNoProperties, 1, 0, 1) \
   V(Float64RoundTiesEven, Operator::kNoProperties, 1, 0, 1) \
+  V(Word32Select, Operator::kNoProperties, 3, 0, 1)         \
+  V(Word64Select, Operator::kNoProperties, 3, 0, 1)         \
   V(Float32Select, Operator::kNoProperties, 3, 0, 1)        \
   V(Float64Select, Operator::kNoProperties, 3, 0, 1)
 
diff --git a/src/compiler/machine-operator.h b/src/compiler/machine-operator.h
index aed3f1b1d42..2a72b2f8c1d 100644
--- a/src/compiler/machine-operator.h
+++ b/src/compiler/machine-operator.h
@@ -278,6 +278,8 @@ class V8_EXPORT_PRIVATE MachineOperatorBuilder final
     kWord32Rol = 1u << 22,
     kWord64Rol = 1u << 23,
     kSatConversionIsSafe = 1u << 24,
+    kWord32Select = 1u << 25,
+    kWord64Select = 1u << 26,
     kAllOptionalOps =
         kFloat32RoundDown | kFloat64RoundDown | kFloat32RoundUp |
         kFloat64RoundUp | kFloat32RoundTruncate | kFloat64RoundTruncate |
@@ -285,7 +287,7 @@ class V8_EXPORT_PRIVATE MachineOperatorBuilder final
         kWord32Ctz | kWord64Ctz | kWord32Popcnt | kWord64Popcnt |
         kWord32ReverseBits | kWord64ReverseBits | kInt32AbsWithOverflow |
         kInt64AbsWithOverflow | kWord32Rol | kWord64Rol | kSatConversionIsSafe |
-        kFloat32Select | kFloat64Select
+        kFloat32Select | kFloat64Select | kWord32Select | kWord64Select
   };
   using Flags = base::Flags<Flag, unsigned>;
 
@@ -581,7 +583,11 @@ class V8_EXPORT_PRIVATE MachineOperatorBuilder final
   const OptionalOperator Float32RoundTiesEven();
   const OptionalOperator Float64RoundTiesEven();
 
-  // Floating point conditional selects.
+  // Conditional selects. Input 1 is the condition, Input 2 is the result value
+  // if the condition is {true}, Input 3 is the result value if the condition is
+  // false.
+  const OptionalOperator Word32Select();
+  const OptionalOperator Word64Select();
   const OptionalOperator Float32Select();
   const OptionalOperator Float64Select();
 
diff --git a/src/compiler/opcodes.h b/src/compiler/opcodes.h
index 3e5314d8574..471c2e99414 100644
--- a/src/compiler/opcodes.h
+++ b/src/compiler/opcodes.h
@@ -734,6 +734,8 @@
   V(Float64ExtractHighWord32)            \
   V(Float64InsertLowWord32)              \
   V(Float64InsertHighWord32)             \
+  V(Word32Select)                        \
+  V(Word64Select)                        \
   V(Float32Select)                       \
   V(Float64Select)                       \
   V(TaggedPoisonOnSpeculation)           \
diff --git a/src/compiler/raw-machine-assembler.h b/src/compiler/raw-machine-assembler.h
index cc5234d52fa..9f6eee94889 100644
--- a/src/compiler/raw-machine-assembler.h
+++ b/src/compiler/raw-machine-assembler.h
@@ -574,6 +574,15 @@ class V8_EXPORT_PRIVATE RawMachineAssembler {
   }
   Node* Word32Ctz(Node* a) { return AddNode(machine()->Word32Ctz().op(), a); }
   Node* Word64Ctz(Node* a) { return AddNode(machine()->Word64Ctz().op(), a); }
+
+  Node* Word32Select(Node* condition, Node* b, Node* c) {
+    return AddNode(machine()->Word32Select().op(), condition, b, c);
+  }
+
+  Node* Word64Select(Node* condition, Node* b, Node* c) {
+    return AddNode(machine()->Word64Select().op(), condition, b, c);
+  }
+
   Node* StackPointerGreaterThan(Node* value) {
     return AddNode(
         machine()->StackPointerGreaterThan(StackCheckKind::kCodeStubAssembler),
diff --git a/src/compiler/verifier.cc b/src/compiler/verifier.cc
index b5b3ab5a981..4335991ed8d 100644
--- a/src/compiler/verifier.cc
+++ b/src/compiler/verifier.cc
@@ -1791,6 +1791,8 @@ void Verifier::Visitor::Check(Node* node, const AllNodes& all) {
     case IrOpcode::kFloat64ExtractHighWord32:
     case IrOpcode::kFloat64InsertLowWord32:
     case IrOpcode::kFloat64InsertHighWord32:
+    case IrOpcode::kWord32Select:
+    case IrOpcode::kWord64Select:
     case IrOpcode::kFloat32Select:
     case IrOpcode::kFloat64Select:
     case IrOpcode::kInt32PairAdd:
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index df657c883eb..244e3de5c93 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -1310,6 +1310,14 @@ Node* WasmGraphBuilder::Select(Node *cond, Node* true_node,
     return mcgraph()->graph()->NewNode(m->Float64Select().op(), cond,
                                        true_node, false_node);
   }
+  if (kind == wasm::kI32 && m->Word32Select().IsSupported()) {
+    return mcgraph()->graph()->NewNode(m->Word32Select().op(), cond, true_node,
+                                       false_node);
+  }
+  if (kind == wasm::kI64 && m->Word64Select().IsSupported()) {
+    return mcgraph()->graph()->NewNode(m->Word64Select().op(), cond, true_node,
+                                       false_node);
+  }
   // Default to control-flow.
   Node* controls[2];
   BranchNoHint(cond, &controls[0], &controls[1]);
diff --git a/test/cctest/compiler/test-run-machops.cc b/test/cctest/compiler/test-run-machops.cc
index 3160848b680..75fad93d320 100644
--- a/test/cctest/compiler/test-run-machops.cc
+++ b/test/cctest/compiler/test-run-machops.cc
@@ -400,6 +400,98 @@ TEST(RunWord64Popcnt) {
 
 #endif  // V8_TARGET_ARCH_64_BIT
 
+TEST(RunWord32Select) {
+  BufferedRawMachineAssemblerTester<int32_t> m(
+      MachineType::Int32(), MachineType::Int32(), MachineType::Int32());
+  if (!m.machine()->Word32Select().IsSupported()) {
+    return;
+  }
+
+  Node* cmp = m.Word32Equal(m.Parameter(2), m.Int32Constant(0));
+  m.Return(m.Word32Select(cmp, m.Parameter(0), m.Parameter(1)));
+  constexpr int input1 = 16;
+  constexpr int input2 = 3443;
+
+  for (int i = 0; i < 2; ++i) {
+    int expected = i == 0 ? input1 : input2;
+    CHECK_EQ(expected, m.Call(input1, input2, i));
+  }
+}
+
+TEST(RunWord64Select) {
+  BufferedRawMachineAssemblerTester<int64_t> m(
+      MachineType::Int64(), MachineType::Int64(), MachineType::Int32());
+  if (!m.machine()->Word64Select().IsSupported()) {
+    return;
+  }
+
+  Node* cmp = m.Word32Equal(m.Parameter(2), m.Int32Constant(0));
+  m.Return(m.Word64Select(cmp, m.Parameter(0), m.Parameter(1)));
+  constexpr int64_t input1 = 16;
+  constexpr int64_t input2 = 0x123456789abc;
+
+  for (int i = 0; i < 2; ++i) {
+    int64_t expected = i == 0 ? input1 : input2;
+    CHECK_EQ(expected, m.Call(input1, input2, i));
+  }
+}
+
+namespace {
+void FooForSelect() {}
+}  // namespace
+
+TEST(RunWord32SelectWithMemoryInput) {
+  BufferedRawMachineAssemblerTester<int32_t> m(MachineType::Int32(),
+                                               MachineType::Int32());
+  if (!m.machine()->Word32Select().IsSupported()) {
+    return;
+  }
+
+  // Test that the generated code also works with values spilled on the stack.
+
+  auto* foo_ptr = &FooForSelect;
+  constexpr int input1 = 16;
+  int input2 = 3443;
+  // Load {value2} before the function call so that it gets spilled.
+  Node* value2 = m.LoadFromPointer(&input2, MachineType::Int32());
+  Node* function = m.LoadFromPointer(&foo_ptr, MachineType::Pointer());
+  // Call a function so that {value2} gets spilled on the stack.
+  m.CallCFunction(function, MachineType::Int32());
+  Node* cmp = m.Word32Equal(m.Parameter(1), m.Int32Constant(0));
+  m.Return(m.Word32Select(cmp, m.Parameter(0), value2));
+
+  for (int i = 0; i < 2; ++i) {
+    int32_t expected = i == 0 ? input1 : input2;
+    CHECK_EQ(expected, m.Call(input1, i));
+  }
+}
+
+TEST(RunWord64SelectWithMemoryInput) {
+  BufferedRawMachineAssemblerTester<int64_t> m(MachineType::Int64(),
+                                               MachineType::Int32());
+  if (!m.machine()->Word64Select().IsSupported()) {
+    return;
+  }
+
+  // Test that the generated code also works with values spilled on the stack.
+
+  auto* foo_ptr = &FooForSelect;
+  constexpr int64_t input1 = 16;
+  int64_t input2 = 0x12345678ABCD;
+  // Load {value2} before the function call so that it gets spilled.
+  Node* value2 = m.LoadFromPointer(&input2, MachineType::Int64());
+  Node* function = m.LoadFromPointer(&foo_ptr, MachineType::Pointer());
+  // Call a function so that {value2} gets spilled on the stack.
+  m.CallCFunction(function, MachineType::Int32());
+  Node* cmp = m.Word32Equal(m.Parameter(1), m.Int32Constant(0));
+  m.Return(m.Word64Select(cmp, m.Parameter(0), value2));
+
+  for (int i = 0; i < 2; ++i) {
+    int64_t expected = i == 0 ? input1 : input2;
+    CHECK_EQ(expected, m.Call(input1, i));
+  }
+}
+
 TEST(RunFloat32SelectRegFloatCompare) {
   BufferedRawMachineAssemblerTester<float> m(MachineType::Float32(),
                                              MachineType::Float32());
diff --git a/test/unittests/compiler/backend/instruction-selector-unittest.cc b/test/unittests/compiler/backend/instruction-selector-unittest.cc
index 60ba115713c..11ee5d20759 100644
--- a/test/unittests/compiler/backend/instruction-selector-unittest.cc
+++ b/test/unittests/compiler/backend/instruction-selector-unittest.cc
@@ -138,6 +138,14 @@ bool InstructionSelectorTest::Stream::IsSameAsFirst(
   return unallocated->HasSameAsInputPolicy();
 }
 
+bool InstructionSelectorTest::Stream::IsSameAsInput(
+    const InstructionOperand* operand, int input_index) const {
+  if (!operand->IsUnallocated()) return false;
+  const UnallocatedOperand* unallocated = UnallocatedOperand::cast(operand);
+  return unallocated->HasSameAsInputPolicy() &&
+         unallocated->input_index() == input_index;
+}
+
 bool InstructionSelectorTest::Stream::IsUsedAtStart(
     const InstructionOperand* operand) const {
   if (!operand->IsUnallocated()) return false;
diff --git a/test/unittests/compiler/backend/instruction-selector-unittest.h b/test/unittests/compiler/backend/instruction-selector-unittest.h
index 203daca69fb..3af4f7b5875 100644
--- a/test/unittests/compiler/backend/instruction-selector-unittest.h
+++ b/test/unittests/compiler/backend/instruction-selector-unittest.h
@@ -234,6 +234,8 @@ class InstructionSelectorTest : public TestWithNativeContextAndZone {
 
     bool IsFixed(const InstructionOperand* operand, Register reg) const;
     bool IsSameAsFirst(const InstructionOperand* operand) const;
+    bool IsSameAsInput(const InstructionOperand* operand,
+                       int input_index) const;
     bool IsUsedAtStart(const InstructionOperand* operand) const;
 
     FrameStateDescriptor* GetFrameStateDescriptor(int deoptimization_id) {
diff --git a/test/unittests/compiler/backend/instruction-sequence-unittest.cc b/test/unittests/compiler/backend/instruction-sequence-unittest.cc
index 3cfb050c798..d644906f1ce 100644
--- a/test/unittests/compiler/backend/instruction-sequence-unittest.cc
+++ b/test/unittests/compiler/backend/instruction-sequence-unittest.cc
@@ -394,8 +394,8 @@ InstructionOperand InstructionSequenceTest::ConvertOutputOp(VReg vreg,
   CHECK_EQ(op.vreg_.value_, kNoValue);
   op.vreg_ = vreg;
   switch (op.type_) {
-    case kSameAsFirst:
-      return Unallocated(op, UnallocatedOperand::SAME_AS_FIRST_INPUT);
+    case kSameAsInput:
+      return Unallocated(op, UnallocatedOperand::SAME_AS_INPUT);
     case kRegister:
       return Unallocated(op, UnallocatedOperand::MUST_HAVE_REGISTER);
     case kFixedSlot:
diff --git a/test/unittests/compiler/backend/instruction-sequence-unittest.h b/test/unittests/compiler/backend/instruction-sequence-unittest.h
index 988bc37281a..0a8768d0632 100644
--- a/test/unittests/compiler/backend/instruction-sequence-unittest.h
+++ b/test/unittests/compiler/backend/instruction-sequence-unittest.h
@@ -42,7 +42,7 @@ class InstructionSequenceTest : public TestWithIsolateAndZone {
 
   enum TestOperandType {
     kInvalid,
-    kSameAsFirst,
+    kSameAsInput,
     kRegister,
     kFixedRegister,
     kSlot,
@@ -73,7 +73,7 @@ class InstructionSequenceTest : public TestWithIsolateAndZone {
     MachineRepresentation rep_;
   };
 
-  static TestOperand Same() { return TestOperand(kSameAsFirst); }
+  static TestOperand Same() { return TestOperand(kSameAsInput); }
 
   static TestOperand Reg(VReg vreg, int index = kNoValue) {
     TestOperandType type = (index == kNoValue) ? kRegister : kFixedRegister;
diff --git a/test/unittests/compiler/machine-operator-unittest.cc b/test/unittests/compiler/machine-operator-unittest.cc
index edb29420849..a3caf72369d 100644
--- a/test/unittests/compiler/machine-operator-unittest.cc
+++ b/test/unittests/compiler/machine-operator-unittest.cc
@@ -308,6 +308,8 @@ const OptionalOperatorEntry kOptionalOperators[] = {
     OPTIONAL_ENTRY(Float64RoundTiesAway, 1, 0, 1),  // --
     OPTIONAL_ENTRY(Float64Select, 3, 0, 1),         // --
     OPTIONAL_ENTRY(Float32Select, 3, 0, 1),         // --
+    OPTIONAL_ENTRY(Word32Select, 3, 0, 1),          // --
+    OPTIONAL_ENTRY(Word64Select, 3, 0, 1),          // --
 #undef OPTIONAL_ENTRY
 };
 
diff --git a/test/unittests/compiler/x64/instruction-selector-x64-unittest.cc b/test/unittests/compiler/x64/instruction-selector-x64-unittest.cc
index ffd1854bc4c..430adff65c5 100644
--- a/test/unittests/compiler/x64/instruction-selector-x64-unittest.cc
+++ b/test/unittests/compiler/x64/instruction-selector-x64-unittest.cc
@@ -77,6 +77,34 @@ TEST_F(InstructionSelectorTest, TruncateInt64ToInt32WithParameter) {
   EXPECT_EQ(kX64Movl, s[0]->arch_opcode());
 }
 
+TEST_F(InstructionSelectorTest, SelectWord32) {
+  StreamBuilder m(this, MachineType::Int32(), MachineType::Int32(),
+                  MachineType::Int32());
+  Node* cond = m.Int32Constant(1);
+  m.Return(m.Word32Select(cond, m.Parameter(0), m.Parameter(1)));
+  Stream s = m.Build();
+  EXPECT_EQ(kX64Cmp32, s[0]->arch_opcode());
+  EXPECT_EQ(4U, s[0]->InputCount());
+  EXPECT_EQ(1U, s[0]->OutputCount());
+  EXPECT_EQ(kFlags_select, s[0]->flags_mode());
+  EXPECT_EQ(kNotEqual, s[0]->flags_condition());
+  EXPECT_TRUE(s.IsSameAsInput(s[0]->Output(), 2));
+}
+
+TEST_F(InstructionSelectorTest, SelectWord64) {
+  StreamBuilder m(this, MachineType::Int64(), MachineType::Int64(),
+                  MachineType::Int64());
+  Node* cond = m.Int32Constant(1);
+  m.Return(m.Word64Select(cond, m.Parameter(0), m.Parameter(1)));
+  Stream s = m.Build();
+  EXPECT_EQ(kX64Cmp32, s[0]->arch_opcode());
+  EXPECT_EQ(4U, s[0]->InputCount());
+  EXPECT_EQ(1U, s[0]->OutputCount());
+  EXPECT_EQ(kFlags_select, s[0]->flags_mode());
+  EXPECT_EQ(kNotEqual, s[0]->flags_condition());
+  EXPECT_TRUE(s.IsSameAsInput(s[0]->Output(), 2));
+}
+
 namespace {
 struct LoadWithToInt64Extension {
   MachineType type;
-- 
2.35.1


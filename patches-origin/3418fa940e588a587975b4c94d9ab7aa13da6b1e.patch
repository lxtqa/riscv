From 3418fa940e588a587975b4c94d9ab7aa13da6b1e Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Wed, 5 Jul 2023 15:11:11 +0800
Subject: [PATCH] [riscv][liftoff] Use VarState for C-Calls

Port commit a782748a830116583e5d33723d46a82aed50c67e

Bug: v8:13918
Change-Id: Ia7fa037cbaa1ef3463951410fe0139f8ac998f2f
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4664790
Commit-Queue: Ji Qiu <qiuji@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Reviewed-by: Ji Qiu <qiuji@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#88659}
---
 .../riscv/liftoff-assembler-riscv32.h         | 33 +++++++++--
 .../riscv/liftoff-assembler-riscv64.h         | 59 +++++++++++++++++--
 2 files changed, 80 insertions(+), 12 deletions(-)

diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
index 4a76868e3ac..6918be06e25 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
@@ -2000,19 +2000,40 @@ void LiftoffAssembler::emit_i16x8_extadd_pairwise_i8x16_u(LiftoffRegister dst,
   vwaddu_vv(dst.fp().toV(), kSimd128ScratchReg, kSimd128ScratchReg2);
 }
 
-void LiftoffAssembler::CallC(const ValueKindSig* sig,
-                             const LiftoffRegister* args,
+void LiftoffAssembler::CallC(const ValueKindSig* sig, const VarState* args,
                              const LiftoffRegister* rets,
                              ValueKind out_argument_kind, int stack_bytes,
                              ExternalReference ext_ref) {
   AddWord(sp, sp, Operand(-stack_bytes));
 
-  int arg_bytes = 0;
+  int arg_offset = 0;
+  const VarState* current_arg = args;
   for (ValueKind param_kind : sig->parameters()) {
-    liftoff::Store(this, sp, arg_bytes, *args++, param_kind);
-    arg_bytes += value_kind_size(param_kind);
+    UseScratchRegisterScope temps(this);
+    Register src = no_reg;
+    MemOperand dst{sp, arg_offset};
+    if (current_arg->is_reg()) {
+      liftoff::Store(this, sp, arg_offset, current_arg->reg(), param_kind);
+    } else if (current_arg->is_const()) {
+      DCHECK_EQ(kI32, param_kind);
+      if (current_arg->i32_const() == 0) {
+        src = zero_reg;
+      } else {
+        src = temps.Acquire();
+        li(src, current_arg->i32_const());
+      }
+      StoreWord(src, dst);
+    } else {
+      DCHECK(value_kind_size(current_arg->kind()) == 4);
+      MemOperand src = liftoff::GetStackSlot(current_arg->offset());
+      auto scratch = temps.Acquire();
+      Lw(scratch, src);
+      Sw(scratch, dst);
+    }
+    ++current_arg;
+    arg_offset += value_kind_size(param_kind);
   }
-  DCHECK_LE(arg_bytes, stack_bytes);
+  DCHECK_LE(arg_offset, stack_bytes);
 
   // Pass a pointer to the buffer with the arguments to the C function.
   // On RISC-V, the first argument is passed in {a0}.
diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h
index e71f2255b59..0162b6e3b00 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv64.h
@@ -1631,19 +1631,66 @@ void LiftoffAssembler::emit_i16x8_extadd_pairwise_i8x16_u(LiftoffRegister dst,
   vwaddu_vv(dst.fp().toV(), kSimd128ScratchReg, kSimd128ScratchReg2);
 }
 
-void LiftoffAssembler::CallC(const ValueKindSig* sig,
-                             const LiftoffRegister* args,
+void LiftoffAssembler::CallC(const ValueKindSig* sig, const VarState* args,
                              const LiftoffRegister* rets,
                              ValueKind out_argument_kind, int stack_bytes,
                              ExternalReference ext_ref) {
   AddWord(sp, sp, Operand(-stack_bytes));
 
-  int arg_bytes = 0;
+  int arg_offset = 0;
+  const VarState* current_arg = args;
   for (ValueKind param_kind : sig->parameters()) {
-    liftoff::Store(this, sp, arg_bytes, *args++, param_kind);
-    arg_bytes += value_kind_size(param_kind);
+    UseScratchRegisterScope temps(this);
+    Register src = no_reg;
+    MemOperand dst{sp, arg_offset};
+    if (current_arg->is_reg()) {
+      switch (param_kind) {
+        case kI32:
+          Sw(current_arg->reg().gp(), dst);
+          break;
+        case kI64:
+          StoreWord(current_arg->reg().gp(), dst);
+          break;
+        case kF32:
+          StoreFloat(current_arg->reg().fp(), dst);
+          break;
+        case kF64:
+          StoreDouble(current_arg->reg().fp(), dst);
+          break;
+        case kS128: {
+          auto scratch = temps.Acquire();
+          AddWord(scratch, sp, Operand(arg_offset));
+          vs(current_arg->reg().fp().toV(), scratch, 0, VSew::E8);
+          break;
+        }
+        default:
+          UNREACHABLE();
+      }
+    } else if (current_arg->is_const()) {
+      DCHECK_EQ(kI32, param_kind);
+      if (current_arg->i32_const() == 0) {
+        src = zero_reg;
+      } else {
+        src = temps.Acquire();
+        li(src, current_arg->i32_const());
+      }
+      StoreWord(src, dst);
+    } else if (value_kind_size(current_arg->kind()) == 4) {
+      MemOperand src = liftoff::GetStackSlot(current_arg->offset());
+      auto scratch = temps.Acquire();
+      Lw(scratch, src);
+      Sw(scratch, dst);
+    } else {
+      DCHECK_EQ(8, value_kind_size(current_arg->kind()));
+      MemOperand src = liftoff::GetStackSlot(current_arg->offset());
+      auto scratch = temps.Acquire();
+      Ld(scratch, src);
+      Sd(scratch, dst);
+    }
+    ++current_arg;
+    arg_offset += value_kind_size(param_kind);
   }
-  DCHECK_LE(arg_bytes, stack_bytes);
+  DCHECK_LE(arg_offset, stack_bytes);
 
   // Pass a pointer to the buffer with the arguments to the C function.
   // On RISC-V, the first argument is passed in {a0}.
-- 
2.35.1


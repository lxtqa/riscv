From 6bd67711694dc683c16513ed3fd52b51e20a2d0a Mon Sep 17 00:00:00 2001
From: Matthias Liedtke <mliedtke@chromium.org>
Date: Tue, 14 Mar 2023 12:01:54 +0100
Subject: [PATCH] [wasm-gc] Inlining: Annotate inlined frames on wasm frames

Prior to this CL inlined stack frames were not visible e.g. on wasm
traps caught in JS. With this CL we add frame summaries for inlined
frames based on source information stored in the WasmCode object.
This change does not add insert these frames for wasm functions
inlined into JavaScript.

Bug: v8:7748
Change-Id: If73485a7f6cfdf92fe44644346fea65ee602e358
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4322194
Reviewed-by: Jakob Linke <jgruber@chromium.org>
Reviewed-by: Nico Hartmann <nicohartmann@chromium.org>
Reviewed-by: Manos Koukoutos <manoskouk@chromium.org>
Commit-Queue: Matthias Liedtke <mliedtke@chromium.org>
Cr-Commit-Position: refs/heads/main@{#86403}
---
 src/codegen/source-position.h                 |   7 ++
 src/compiler/pipeline.cc                      |  39 +++++--
 src/compiler/pipeline.h                       |   7 +-
 src/compiler/wasm-compiler.cc                 |  13 ++-
 src/compiler/wasm-compiler.h                  |   6 +
 src/compiler/wasm-inlining.cc                 |   7 ++
 src/compiler/wasm-inlining.h                  |  10 +-
 .../wasm/gdb-server/wasm-module-debug.cc      |   2 +-
 src/execution/frames.cc                       |  49 ++++++---
 src/execution/frames.h                        |  16 +--
 src/objects/call-site-info.cc                 |   4 +-
 src/objects/call-site-info.h                  |   2 +-
 src/wasm/function-compiler.h                  |   1 +
 src/wasm/wasm-code-manager.cc                 |  46 ++++++--
 src/wasm/wasm-code-manager.h                  |  28 +++--
 src/wasm/wasm-debug.cc                        |   4 +-
 src/wasm/wasm-module.cc                       |   4 +-
 src/wasm/wasm-serialization.cc                |  11 +-
 test/cctest/wasm/test-wasm-breakpoints.cc     |   2 +-
 test/mjsunit/wasm/inlining.js                 | 104 +++++++++++++++++-
 20 files changed, 290 insertions(+), 72 deletions(-)

diff --git a/src/codegen/source-position.h b/src/codegen/source-position.h
index 8794926c256..04320b260d3 100644
--- a/src/codegen/source-position.h
+++ b/src/codegen/source-position.h
@@ -175,6 +175,13 @@ struct InliningPosition {
   int inlined_function_id;
 };
 
+struct WasmInliningPosition {
+  // Non-canonicalized (module-specific) index of the inlined function.
+  int inlinee_func_index;
+  // Source location of the caller.
+  SourcePosition caller_pos;
+};
+
 struct SourcePositionInfo {
   SourcePositionInfo(SourcePosition pos, Handle<SharedFunctionInfo> f);
 
diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index c19600c9330..579027f4e2f 100644
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -1725,7 +1725,8 @@ struct WasmInliningPhase {
 
   void Run(PipelineData* data, Zone* temp_zone, wasm::CompilationEnv* env,
            uint32_t function_index, const wasm::WireBytesStorage* wire_bytes,
-           std::vector<compiler::WasmLoopInfo>* loop_info) {
+           std::vector<compiler::WasmLoopInfo>* loop_info,
+           ZoneVector<WasmInliningPosition>* inlining_positions) {
     if (!WasmInliner::graph_size_allows_inlining(data->graph()->NodeCount())) {
       return;
     }
@@ -1738,7 +1739,7 @@ struct WasmInliningPhase {
     WasmInliner inliner(&graph_reducer, env, function_index,
                         data->source_positions(), data->node_origins(),
                         data->mcgraph(), wire_bytes, loop_info,
-                        debug_name.get());
+                        debug_name.get(), inlining_positions);
     AddReducer(data, &graph_reducer, &dead);
     AddReducer(data, &graph_reducer, &inliner);
     graph_reducer.ReduceGraph();
@@ -2719,8 +2720,7 @@ class WasmHeapStubCompilationJob final : public TurbofanCompilationJob {
   WasmHeapStubCompilationJob(Isolate* isolate, CallDescriptor* call_descriptor,
                              std::unique_ptr<Zone> zone, Graph* graph,
                              CodeKind kind, std::unique_ptr<char[]> debug_name,
-                             const AssemblerOptions& options,
-                             SourcePositionTable* source_positions)
+                             const AssemblerOptions& options)
       // Note that the OptimizedCompilationInfo is not initialized at the time
       // we pass it to the CompilationJob constructor, but it is not
       // dereferenced there.
@@ -2732,7 +2732,7 @@ class WasmHeapStubCompilationJob final : public TurbofanCompilationJob {
         zone_(std::move(zone)),
         graph_(graph),
         data_(&zone_stats_, &info_, isolate, wasm::GetWasmEngine()->allocator(),
-              graph_, nullptr, nullptr, source_positions,
+              graph_, nullptr, nullptr, nullptr,
               zone_->New<NodeOriginTable>(graph_), nullptr, options, nullptr),
         pipeline_(&data_) {}
 
@@ -2761,11 +2761,10 @@ class WasmHeapStubCompilationJob final : public TurbofanCompilationJob {
 std::unique_ptr<TurbofanCompilationJob> Pipeline::NewWasmHeapStubCompilationJob(
     Isolate* isolate, CallDescriptor* call_descriptor,
     std::unique_ptr<Zone> zone, Graph* graph, CodeKind kind,
-    std::unique_ptr<char[]> debug_name, const AssemblerOptions& options,
-    SourcePositionTable* source_positions) {
+    std::unique_ptr<char[]> debug_name, const AssemblerOptions& options) {
   return std::make_unique<WasmHeapStubCompilationJob>(
       isolate, call_descriptor, std::move(zone), graph, kind,
-      std::move(debug_name), options, source_positions);
+      std::move(debug_name), options);
 }
 
 CompilationJob::Status WasmHeapStubCompilationJob::PrepareJobImpl(
@@ -3413,6 +3412,24 @@ void LowerInt64(const wasm::FunctionSig* sig, MachineGraph* mcgraph,
   pipeline.RunPrintAndVerify("V8.Int64Lowering", true);
 }
 
+base::OwnedVector<byte> SerializeInliningPositions(
+    const ZoneVector<WasmInliningPosition>& positions) {
+  const size_t entry_size =
+      sizeof positions[0].inlinee_func_index + sizeof positions[0].caller_pos;
+  auto result = base::OwnedVector<byte>::New(positions.size() * entry_size);
+  byte* iter = result.begin();
+  for (const auto& [func_index, caller_pos] : positions) {
+    size_t index_size = sizeof func_index;
+    std::memcpy(iter, &func_index, index_size);
+    iter += index_size;
+    size_t pos_size = sizeof caller_pos;
+    std::memcpy(iter, &caller_pos, pos_size);
+    iter += pos_size;
+  }
+  DCHECK_EQ(iter, result.end());
+  return result;
+}
+
 }  // namespace
 
 // static
@@ -3423,7 +3440,8 @@ void Pipeline::GenerateCodeForWasmFunction(
     NodeOriginTable* node_origins, wasm::FunctionBody function_body,
     const wasm::WasmModule* module, int function_index,
     std::vector<compiler::WasmLoopInfo>* loop_info,
-    wasm::AssemblerBufferCache* buffer_cache) {
+    wasm::AssemblerBufferCache* buffer_cache,
+    ZoneVector<WasmInliningPosition>* inlining_positions) {
   auto* wasm_engine = wasm::GetWasmEngine();
   base::TimeTicks start_time;
   if (V8_UNLIKELY(v8_flags.trace_wasm_compilation_times)) {
@@ -3458,7 +3476,7 @@ void Pipeline::GenerateCodeForWasmFunction(
   data.BeginPhaseKind("V8.WasmOptimization");
   if (v8_flags.wasm_inlining) {
     pipeline.Run<WasmInliningPhase>(env, function_index, wire_bytes_storage,
-                                    loop_info);
+                                    loop_info, inlining_positions);
     pipeline.RunPrintAndVerify(WasmInliningPhase::phase_name(), true);
   }
   if (v8_flags.wasm_loop_peeling) {
@@ -3582,6 +3600,7 @@ void Pipeline::GenerateCodeForWasmFunction(
   result->frame_slot_count = code_generator->frame()->GetTotalFrameSlotCount();
   result->tagged_parameter_slots = call_descriptor->GetTaggedParameterSlots();
   result->source_positions = code_generator->GetSourcePositionTable();
+  result->inlining_positions = SerializeInliningPositions(*inlining_positions);
   result->protected_instructions_data =
       code_generator->GetProtectedInstructionsData();
   result->result_tier = wasm::ExecutionTier::kTurbofan;
diff --git a/src/compiler/pipeline.h b/src/compiler/pipeline.h
index ba1decfafc8..62ce72b7d02 100644
--- a/src/compiler/pipeline.h
+++ b/src/compiler/pipeline.h
@@ -20,6 +20,7 @@ class OptimizedCompilationInfo;
 class TurbofanCompilationJob;
 class ProfileDataFromFile;
 class RegisterConfiguration;
+struct WasmInliningPosition;
 
 namespace wasm {
 class AssemblerBufferCache;
@@ -59,7 +60,8 @@ class Pipeline : public AllStatic {
       NodeOriginTable* node_origins, wasm::FunctionBody function_body,
       const wasm::WasmModule* module, int function_index,
       std::vector<compiler::WasmLoopInfo>* loop_infos,
-      wasm::AssemblerBufferCache* buffer_cache);
+      wasm::AssemblerBufferCache* buffer_cache,
+      ZoneVector<WasmInliningPosition>* inlining_positions);
 
   // Run the pipeline on a machine graph and generate code.
   static wasm::WasmCompilationResult GenerateCodeForWasmNativeStub(
@@ -71,8 +73,7 @@ class Pipeline : public AllStatic {
   static std::unique_ptr<TurbofanCompilationJob> NewWasmHeapStubCompilationJob(
       Isolate* isolate, CallDescriptor* call_descriptor,
       std::unique_ptr<Zone> zone, Graph* graph, CodeKind kind,
-      std::unique_ptr<char[]> debug_name, const AssemblerOptions& options,
-      SourcePositionTable* source_positions = nullptr);
+      std::unique_ptr<char[]> debug_name, const AssemblerOptions& options);
 
   // Run the pipeline on a machine graph and generate code.
   static MaybeHandle<Code> GenerateCodeForCodeStub(
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 37a8b025a99..ce4a0fa0877 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -4110,7 +4110,8 @@ void WasmGraphBuilder::SetSourcePosition(Node* node,
                                          wasm::WasmCodePosition position) {
   DCHECK_NE(position, wasm::kNoCodePosition);
   if (source_position_table_) {
-    source_position_table_->SetSourcePosition(node, SourcePosition(position));
+    source_position_table_->SetSourcePosition(
+        node, SourcePosition(position, inlining_id_));
   }
 }
 
@@ -5583,6 +5584,7 @@ Node* WasmGraphBuilder::RefTestAbstract(Node* object, wasm::HeapType type,
 Node* WasmGraphBuilder::RefCast(Node* object, Node* rtt,
                                 WasmTypeCheckConfig config,
                                 wasm::WasmCodePosition position) {
+  // TODO(mliedtke): What should happen with the position?
   return gasm_->WasmTypeCast(object, rtt, config);
 }
 
@@ -8776,6 +8778,7 @@ wasm::WasmCompilationResult ExecuteTurbofanWasmCompilation(
                               : nullptr;
   SourcePositionTable* source_positions =
       mcgraph->zone()->New<SourcePositionTable>(mcgraph->graph());
+  ZoneVector<WasmInliningPosition> inlining_positions(&zone);
 
   std::vector<WasmLoopInfo> loop_infos;
 
@@ -8799,10 +8802,10 @@ wasm::WasmCompilationResult ExecuteTurbofanWasmCompilation(
     return wasm::WasmCompilationResult{};
   }
 
-  Pipeline::GenerateCodeForWasmFunction(&info, env, wire_byte_storage, mcgraph,
-                                        call_descriptor, source_positions,
-                                        node_origins, func_body, env->module,
-                                        func_index, &loop_infos, buffer_cache);
+  Pipeline::GenerateCodeForWasmFunction(
+      &info, env, wire_byte_storage, mcgraph, call_descriptor, source_positions,
+      node_origins, func_body, env->module, func_index, &loop_infos,
+      buffer_cache, &inlining_positions);
 
   if (counters) {
     int zone_bytes =
diff --git a/src/compiler/wasm-compiler.h b/src/compiler/wasm-compiler.h
index 923f6d6d67b..555133a73e3 100644
--- a/src/compiler/wasm-compiler.h
+++ b/src/compiler/wasm-compiler.h
@@ -635,6 +635,11 @@ class WasmGraphBuilder {
   void StoreCallCount(Node* call, int count);
   void ReserveCallCounts(size_t num_call_instructions);
 
+  void set_inlining_id(int inlining_id) {
+    DCHECK_NE(inlining_id, -1);
+    inlining_id_ = inlining_id;
+  }
+
  protected:
   Node* NoContextConstant();
 
@@ -872,6 +877,7 @@ class WasmGraphBuilder {
   compiler::WasmDecorator* decorator_ = nullptr;
 
   compiler::SourcePositionTable* const source_position_table_ = nullptr;
+  int inlining_id_ = -1;
   Parameter0Mode parameter_mode_;
   Isolate* const isolate_;
   SetOncePointer<Node> instance_node_;
diff --git a/src/compiler/wasm-inlining.cc b/src/compiler/wasm-inlining.cc
index c0350a8dc58..9894ae61326 100644
--- a/src/compiler/wasm-inlining.cc
+++ b/src/compiler/wasm-inlining.cc
@@ -200,8 +200,15 @@ void WasmInliner::Finalize() {
     size_t subgraph_min_node_id = graph()->NodeCount();
     Node* inlinee_start;
     Node* inlinee_end;
+    SourcePosition caller_pos =
+        source_positions_->GetSourcePosition(candidate.node);
+    inlining_positions_->push_back(
+        {static_cast<int>(candidate.inlinee_index), caller_pos});
+    int inlining_position_id =
+        static_cast<int>(inlining_positions_->size()) - 1;
     WasmGraphBuilder builder(env_, zone(), mcgraph_, inlinee_body.sig,
                              source_positions_);
+    builder.set_inlining_id(inlining_position_id);
     {
       Graph::SubgraphScope scope(graph());
       wasm::BuildTFGraph(zone()->allocator(), env_->enabled_features, module(),
diff --git a/src/compiler/wasm-inlining.h b/src/compiler/wasm-inlining.h
index d25f52ad37d..30f480081c3 100644
--- a/src/compiler/wasm-inlining.h
+++ b/src/compiler/wasm-inlining.h
@@ -15,6 +15,9 @@
 namespace v8 {
 namespace internal {
 
+class SourcePosition;
+struct WasmInliningPosition;
+
 namespace wasm {
 struct CompilationEnv;
 struct DanglingExceptions;
@@ -40,7 +43,8 @@ class WasmInliner final : public AdvancedReducer {
               uint32_t function_index, SourcePositionTable* source_positions,
               NodeOriginTable* node_origins, MachineGraph* mcgraph,
               const wasm::WireBytesStorage* wire_bytes,
-              std::vector<WasmLoopInfo>* loop_infos, const char* debug_name)
+              std::vector<WasmLoopInfo>* loop_infos, const char* debug_name,
+              ZoneVector<WasmInliningPosition>* inlining_positions)
       : AdvancedReducer(editor),
         env_(env),
         function_index_(function_index),
@@ -52,7 +56,8 @@ class WasmInliner final : public AdvancedReducer {
         debug_name_(debug_name),
         initial_graph_size_(mcgraph->graph()->NodeCount()),
         current_graph_size_(initial_graph_size_),
-        inlining_candidates_() {}
+        inlining_candidates_(),
+        inlining_positions_(inlining_positions) {}
 
   const char* reducer_name() const override { return "WasmInliner"; }
 
@@ -118,6 +123,7 @@ class WasmInliner final : public AdvancedReducer {
       inlining_candidates_;
   std::unordered_set<Node*> seen_;
   std::unordered_map<uint32_t, int> function_inlining_count_;
+  ZoneVector<WasmInliningPosition>* inlining_positions_;
 };
 
 }  // namespace compiler
diff --git a/src/debug/wasm/gdb-server/wasm-module-debug.cc b/src/debug/wasm/gdb-server/wasm-module-debug.cc
index 07ad3af36c3..8e0580028a4 100644
--- a/src/debug/wasm/gdb-server/wasm-module-debug.cc
+++ b/src/debug/wasm/gdb-server/wasm-module-debug.cc
@@ -116,7 +116,7 @@ std::vector<wasm_addr_t> WasmModuleDebug::GetCallStack(
             FrameSummary::WasmFrameSummary const& wasm = summary.AsWasm();
             offset = GetWasmFunctionOffset(wasm.wasm_instance()->module(),
                                            wasm.function_index()) +
-                     wasm.byte_offset();
+                     wasm.code_offset();
             script = wasm.script();
 
             bool zeroth_frame = call_stack.empty();
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 47aed7d307a..1c30844f650 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -2017,28 +2017,25 @@ FrameSummary::JavaScriptFrameSummary::CreateStackFrameInfo() const {
 #if V8_ENABLE_WEBASSEMBLY
 FrameSummary::WasmFrameSummary::WasmFrameSummary(
     Isolate* isolate, Handle<WasmInstanceObject> instance, wasm::WasmCode* code,
-    int code_offset, bool at_to_number_conversion)
+    int byte_offset, int function_index, bool at_to_number_conversion)
     : FrameSummaryBase(isolate, WASM),
       wasm_instance_(instance),
       at_to_number_conversion_(at_to_number_conversion),
       code_(code),
-      code_offset_(code_offset) {}
+      byte_offset_(byte_offset),
+      function_index_(function_index) {}
 
 Handle<Object> FrameSummary::WasmFrameSummary::receiver() const {
   return wasm_instance_->GetIsolate()->global_proxy();
 }
 
 uint32_t FrameSummary::WasmFrameSummary::function_index() const {
-  return code()->index();
-}
-
-int FrameSummary::WasmFrameSummary::byte_offset() const {
-  return code_->GetSourcePositionBefore(code_offset());
+  return function_index_;
 }
 
 int FrameSummary::WasmFrameSummary::SourcePosition() const {
   const wasm::WasmModule* module = wasm_instance()->module_object().module();
-  return GetSourcePosition(module, function_index(), byte_offset(),
+  return GetSourcePosition(module, function_index(), code_offset(),
                            at_to_number_conversion());
 }
 
@@ -2536,14 +2533,14 @@ Script WasmFrame::script() const { return module_object().script(); }
 int WasmFrame::position() const {
   wasm::WasmCodeRefScope code_ref_scope;
   const wasm::WasmModule* module = wasm_instance().module_object().module();
-  return GetSourcePosition(module, function_index(), byte_offset(),
+  return GetSourcePosition(module, function_index(), generated_code_offset(),
                            at_to_number_conversion());
 }
 
-int WasmFrame::byte_offset() const {
+int WasmFrame::generated_code_offset() const {
   wasm::WasmCode* code = wasm_code();
   int offset = static_cast<int>(pc() - code->instruction_start());
-  return code->GetSourcePositionBefore(offset);
+  return code->GetSourceOffsetBefore(offset);
 }
 
 bool WasmFrame::is_inspectable() const {
@@ -2561,9 +2558,33 @@ void WasmFrame::Summarize(std::vector<FrameSummary>* functions) const {
   wasm::WasmCode* code = wasm_code();
   int offset = static_cast<int>(pc() - code->instruction_start());
   Handle<WasmInstanceObject> instance(wasm_instance(), isolate());
-  FrameSummary::WasmFrameSummary summary(isolate(), instance, code, offset,
-                                         at_to_number_conversion());
+  // Push regular non-inlined summary.
+  SourcePosition pos = code->GetSourcePositionBefore(offset);
+  bool at_conversion = at_to_number_conversion();
+  // Add summaries for each inlined function at the current location.
+  while (pos.isInlined()) {
+    // Use current pc offset as the code offset for inlined functions.
+    // This is not fully correct but there isn't a real code offset of a stack
+    // frame for an inlined function as the inlined function is not a true
+    // function with a defined start and end in the generated code.
+    //
+    const auto [func_index, caller_pos] =
+        code->GetInliningPosition(pos.InliningId());
+    FrameSummary::WasmFrameSummary summary(isolate(), instance, code,
+                                           pos.ScriptOffset(), func_index,
+                                           at_conversion);
+    functions->push_back(summary);
+    pos = caller_pos;
+    at_conversion = false;
+  }
+
+  int func_index = code->index();
+  FrameSummary::WasmFrameSummary summary(
+      isolate(), instance, code, pos.ScriptOffset(), func_index, at_conversion);
   functions->push_back(summary);
+
+  // The caller has to be on top.
+  std::reverse(functions->begin(), functions->end());
 }
 
 bool WasmFrame::at_to_number_conversion() const {
@@ -2575,7 +2596,7 @@ bool WasmFrame::at_to_number_conversion() const {
           : nullptr;
   if (!code || code->kind() != wasm::WasmCode::kWasmToJsWrapper) return false;
   int offset = static_cast<int>(callee_pc() - code->instruction_start());
-  int pos = code->GetSourcePositionBefore(offset);
+  int pos = code->GetSourceOffsetBefore(offset);
   // The imported call has position 0, ToNumber has position 1.
   // If there is no source position available, this is also not a ToNumber call.
   DCHECK(pos == wasm::kNoCodePosition || pos == 0 || pos == 1);
diff --git a/src/execution/frames.h b/src/execution/frames.h
index 6e6c0ee0827..03ab9d0e8dc 100644
--- a/src/execution/frames.h
+++ b/src/execution/frames.h
@@ -424,13 +424,14 @@ class V8_EXPORT_PRIVATE FrameSummary {
   class WasmFrameSummary : public FrameSummaryBase {
    public:
     WasmFrameSummary(Isolate*, Handle<WasmInstanceObject>, wasm::WasmCode*,
-                     int code_offset, bool at_to_number_conversion);
+                     int byte_offset, int function_index,
+                     bool at_to_number_conversion);
 
     Handle<Object> receiver() const;
     uint32_t function_index() const;
     wasm::WasmCode* code() const { return code_; }
-    int code_offset() const { return code_offset_; }
-    V8_EXPORT_PRIVATE int byte_offset() const;
+    // Returns the wire bytes offset relative to the function entry.
+    int code_offset() const { return byte_offset_; }
     bool is_constructor() const { return false; }
     bool is_subject_to_debugging() const { return true; }
     int SourcePosition() const;
@@ -444,8 +445,9 @@ class V8_EXPORT_PRIVATE FrameSummary {
    private:
     Handle<WasmInstanceObject> wasm_instance_;
     bool at_to_number_conversion_;
-    wasm::WasmCode* const code_;
-    int code_offset_;
+    wasm::WasmCode* code_;
+    int byte_offset_;
+    int function_index_;
   };
 #endif  // V8_ENABLE_WEBASSEMBLY
 
@@ -1025,8 +1027,8 @@ class WasmFrame : public TypedFrame {
   int position() const override;
   Object context() const override;
   bool at_to_number_conversion() const;
-  // Byte offset in the function.
-  int byte_offset() const;
+  // Generated code byte offset in the function.
+  int generated_code_offset() const;
   bool is_inspectable() const;
 
   void Summarize(std::vector<FrameSummary>* frames) const override;
diff --git a/src/objects/call-site-info.cc b/src/objects/call-site-info.cc
index 4b57bcbfdf4..688143b3232 100644
--- a/src/objects/call-site-info.cc
+++ b/src/objects/call-site-info.cc
@@ -570,11 +570,9 @@ int CallSiteInfo::ComputeSourcePosition(Handle<CallSiteInfo> info, int offset) {
   Isolate* isolate = info->GetIsolate();
 #if V8_ENABLE_WEBASSEMBLY
   if (info->IsWasm()) {
-    auto code_ref = Managed<wasm::GlobalWasmCodeRef>::cast(info->code_object());
-    int byte_offset = code_ref.get()->code()->GetSourcePositionBefore(offset);
     auto module = info->GetWasmInstance().module();
     uint32_t func_index = info->GetWasmFunctionIndex();
-    return wasm::GetSourcePosition(module, func_index, byte_offset,
+    return wasm::GetSourcePosition(module, func_index, offset,
                                    info->IsAsmJsAtNumberConversion());
   }
 #endif  // V8_ENABLE_WEBASSEMBLY
diff --git a/src/objects/call-site-info.h b/src/objects/call-site-info.h
index bb3ebbeb15b..72ff3cb08a0 100644
--- a/src/objects/call-site-info.h
+++ b/src/objects/call-site-info.h
@@ -84,7 +84,7 @@ class CallSiteInfo : public TorqueGeneratedCallSiteInfo<CallSiteInfo, Struct> {
 #endif  // V8_ENABLE_WEBASSEMBLY
 
   // Returns the 0-based source position, which is the offset into the
-  // Script in case of JavaScript and Asm.js, and the bytecode offset
+  // Script in case of JavaScript and Asm.js, and the wire byte offset
   // in the module in case of actual Wasm. In case of async promise
   // combinator frames, this returns the index of the promise.
   static int GetSourcePosition(Handle<CallSiteInfo> info);
diff --git a/src/wasm/function-compiler.h b/src/wasm/function-compiler.h
index 48d651a6152..e6f38e50110 100644
--- a/src/wasm/function-compiler.h
+++ b/src/wasm/function-compiler.h
@@ -51,6 +51,7 @@ struct WasmCompilationResult {
   uint32_t frame_slot_count = 0;
   uint32_t tagged_parameter_slots = 0;
   base::OwnedVector<byte> source_positions;
+  base::OwnedVector<byte> inlining_positions;
   base::OwnedVector<byte> protected_instructions_data;
   int func_index = kAnonymousFuncIndex;
   ExecutionTier requested_tier;
diff --git a/src/wasm/wasm-code-manager.cc b/src/wasm/wasm-code-manager.cc
index 91eb17a3fd2..3920c09e47c 100644
--- a/src/wasm/wasm-code-manager.cc
+++ b/src/wasm/wasm-code-manager.cc
@@ -505,16 +505,32 @@ void WasmCode::DecrementRefCount(base::Vector<WasmCode* const> code_vec) {
   GetWasmEngine()->FreeDeadCode(dead_code);
 }
 
-int WasmCode::GetSourcePositionBefore(int offset) {
-  int position = kNoSourcePosition;
+SourcePosition WasmCode::GetSourcePositionBefore(int code_offset) {
+  SourcePosition position;
   for (SourcePositionTableIterator iterator(source_positions());
-       !iterator.done() && iterator.code_offset() < offset;
+       !iterator.done() && iterator.code_offset() < code_offset;
        iterator.Advance()) {
-    position = iterator.source_position().ScriptOffset();
+    position = iterator.source_position();
   }
   return position;
 }
 
+int WasmCode::GetSourceOffsetBefore(int code_offset) {
+  return GetSourcePositionBefore(code_offset).ScriptOffset();
+}
+
+std::pair<int, SourcePosition> WasmCode::GetInliningPosition(
+    int inlining_id) const {
+  const size_t elem_size = sizeof(int) + sizeof(SourcePosition);
+  const byte* start = inlining_positions().begin() + elem_size * inlining_id;
+  DCHECK_LE(start, inlining_positions().end());
+  std::pair<int, SourcePosition> result;
+  std::memcpy(&result.first, start, sizeof result.first);
+  std::memcpy(&result.second, start + sizeof result.first,
+              sizeof result.second);
+  return result;
+}
+
 WasmCodeAllocator::WasmCodeAllocator(std::shared_ptr<Counters> async_counters)
     : async_counters_(std::move(async_counters)) {
   owned_code_space_.reserve(4);
@@ -952,6 +968,7 @@ WasmCode* NativeModule::AddCodeForTesting(Handle<InstructionStream> code) {
   // Flush the i-cache after relocation.
   FlushInstructionCache(dst_code_bytes.begin(), dst_code_bytes.size());
 
+  // FIXME(mliedtke): Get inlining positions from input.
   std::unique_ptr<WasmCode> new_code{
       new WasmCode{this,                     // native_module
                    kAnonymousFuncIndex,      // index
@@ -966,6 +983,7 @@ WasmCode* NativeModule::AddCodeForTesting(Handle<InstructionStream> code) {
                    {},                       // protected_instructions
                    reloc_info.as_vector(),   // reloc_info
                    source_pos.as_vector(),   // source positions
+                   {},                       // inlining positions
                    WasmCode::kWasmFunction,  // kind
                    ExecutionTier::kNone,     // tier
                    kNotForDebugging}};       // for_debugging
@@ -1030,6 +1048,7 @@ std::unique_ptr<WasmCode> NativeModule::AddCode(
     base::Vector<const byte> source_position_table, WasmCode::Kind kind,
     ExecutionTier tier, ForDebugging for_debugging) {
   base::Vector<byte> code_space;
+  base::Vector<byte> inlining_positions;
   NativeModule::JumpTablesRef jump_table_ref;
   {
     base::RecursiveMutexGuard guard{&allocation_mutex_};
@@ -1039,15 +1058,16 @@ std::unique_ptr<WasmCode> NativeModule::AddCode(
   }
   return AddCodeWithCodeSpace(index, desc, stack_slots, tagged_parameter_slots,
                               protected_instructions_data,
-                              source_position_table, kind, tier, for_debugging,
-                              code_space, jump_table_ref);
+                              source_position_table, inlining_positions, kind,
+                              tier, for_debugging, code_space, jump_table_ref);
 }
 
 std::unique_ptr<WasmCode> NativeModule::AddCodeWithCodeSpace(
     int index, const CodeDesc& desc, int stack_slots,
     uint32_t tagged_parameter_slots,
     base::Vector<const byte> protected_instructions_data,
-    base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+    base::Vector<const byte> source_position_table,
+    base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
     ExecutionTier tier, ForDebugging for_debugging,
     base::Vector<uint8_t> dst_code_bytes, const JumpTablesRef& jump_tables) {
   base::Vector<byte> reloc_info{
@@ -1105,7 +1125,7 @@ std::unique_ptr<WasmCode> NativeModule::AddCodeWithCodeSpace(
       this, index, dst_code_bytes, stack_slots, tagged_parameter_slots,
       safepoint_table_offset, handler_table_offset, constant_pool_offset,
       code_comments_offset, instr_size, protected_instructions_data, reloc_info,
-      source_position_table, kind, tier, for_debugging}};
+      source_position_table, inlining_positions, kind, tier, for_debugging}};
 
   code->MaybePrint();
   code->Validate();
@@ -1276,7 +1296,8 @@ std::unique_ptr<WasmCode> NativeModule::AddDeserializedCode(
     int code_comments_offset, int unpadded_binary_size,
     base::Vector<const byte> protected_instructions_data,
     base::Vector<const byte> reloc_info,
-    base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+    base::Vector<const byte> source_position_table,
+    base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
     ExecutionTier tier) {
   UpdateCodeSize(instructions.size(), tier, kNotForDebugging);
 
@@ -1284,7 +1305,8 @@ std::unique_ptr<WasmCode> NativeModule::AddDeserializedCode(
       this, index, instructions, stack_slots, tagged_parameter_slots,
       safepoint_table_offset, handler_table_offset, constant_pool_offset,
       code_comments_offset, unpadded_binary_size, protected_instructions_data,
-      reloc_info, source_position_table, kind, tier, kNotForDebugging}};
+      reloc_info, source_position_table, inlining_positions, kind, tier,
+      kNotForDebugging}};
 }
 
 std::vector<WasmCode*> NativeModule::SnapshotCodeTable() const {
@@ -1365,6 +1387,7 @@ WasmCode* NativeModule::CreateEmptyJumpTableInRegionLocked(
                    {},                    // protected_instructions
                    {},                    // reloc_info
                    {},                    // source_pos
+                   {},                    // inlining pos
                    WasmCode::kJumpTable,  // kind
                    ExecutionTier::kNone,  // tier
                    kNotForDebugging}};    // for_debugging
@@ -2215,7 +2238,8 @@ std::vector<std::unique_ptr<WasmCode>> NativeModule::AddCompiledCode(
         result.func_index, result.code_desc, result.frame_slot_count,
         result.tagged_parameter_slots,
         result.protected_instructions_data.as_vector(),
-        result.source_positions.as_vector(), GetCodeKind(result),
+        result.source_positions.as_vector(),
+        result.inlining_positions.as_vector(), GetCodeKind(result),
         result.result_tier, result.for_debugging, this_code_space,
         jump_tables));
   }
diff --git a/src/wasm/wasm-code-manager.h b/src/wasm/wasm-code-manager.h
index dd2128173c2..dbff47c4eb8 100644
--- a/src/wasm/wasm-code-manager.h
+++ b/src/wasm/wasm-code-manager.h
@@ -21,6 +21,7 @@
 #include "src/base/macros.h"
 #include "src/base/vector.h"
 #include "src/builtins/builtins.h"
+#include "src/codegen/source-position.h"
 #include "src/common/code-memory-access.h"
 #include "src/handles/handles.h"
 #include "src/tasks/operations-barrier.h"
@@ -282,6 +283,10 @@ class V8_EXPORT_PRIVATE WasmCode final {
   base::Vector<const byte> source_positions() const {
     return {reloc_info().end(), static_cast<size_t>(source_positions_size_)};
   }
+  base::Vector<const byte> inlining_positions() const {
+    return {source_positions().end(),
+            static_cast<size_t>(inlining_positions_size_)};
+  }
 
   int index() const { return index_; }
   // Anonymous functions are functions that don't carry an index.
@@ -388,7 +393,10 @@ class V8_EXPORT_PRIVATE WasmCode final {
   static void DecrementRefCount(base::Vector<WasmCode* const>);
 
   // Returns the last source position before {offset}.
-  int GetSourcePositionBefore(int offset);
+  SourcePosition GetSourcePositionBefore(int code_offset);
+  int GetSourceOffsetBefore(int code_offset);
+
+  std::pair<int, SourcePosition> GetInliningPosition(int inlining_id) const;
 
   // Returns whether this code was generated for debugging. If this returns
   // {kForDebugging}, but {tier()} is not {kLiftoff}, then Liftoff compilation
@@ -409,17 +417,20 @@ class V8_EXPORT_PRIVATE WasmCode final {
            int code_comments_offset, int unpadded_binary_size,
            base::Vector<const byte> protected_instructions_data,
            base::Vector<const byte> reloc_info,
-           base::Vector<const byte> source_position_table, Kind kind,
+           base::Vector<const byte> source_position_table,
+           base::Vector<const byte> inlining_positions, Kind kind,
            ExecutionTier tier, ForDebugging for_debugging)
       : native_module_(native_module),
         instructions_(instructions.begin()),
         flags_(KindField::encode(kind) | ExecutionTierField::encode(tier) |
                ForDebuggingField::encode(for_debugging)),
-        meta_data_(ConcatenateBytes(
-            {protected_instructions_data, reloc_info, source_position_table})),
+        meta_data_(
+            ConcatenateBytes({protected_instructions_data, reloc_info,
+                              source_position_table, inlining_positions})),
         instructions_size_(instructions.length()),
         reloc_info_size_(reloc_info.length()),
         source_positions_size_(source_position_table.length()),
+        inlining_positions_size_(inlining_positions.length()),
         protected_instructions_size_(protected_instructions_data.length()),
         index_(index),
         constant_pool_offset_(constant_pool_offset),
@@ -475,6 +486,7 @@ class V8_EXPORT_PRIVATE WasmCode final {
   const int instructions_size_;
   const int reloc_info_size_;
   const int source_positions_size_;
+  const int inlining_positions_size_;
   const int protected_instructions_size_;
   const int index_;
   const int constant_pool_offset_;
@@ -514,7 +526,7 @@ class V8_EXPORT_PRIVATE WasmCode final {
 // Increase the limit if needed, but first check if the size increase is
 // justified.
 #ifndef V8_GC_MOLE
-static_assert(sizeof(WasmCode) <= 88);
+static_assert(sizeof(WasmCode) <= 96);
 #endif
 
 WasmCode::Kind GetCodeKind(const WasmCompilationResult& result);
@@ -637,7 +649,8 @@ class V8_EXPORT_PRIVATE NativeModule final {
       int code_comments_offset, int unpadded_binary_size,
       base::Vector<const byte> protected_instructions_data,
       base::Vector<const byte> reloc_info,
-      base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+      base::Vector<const byte> source_position_table,
+      base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
       ExecutionTier tier);
 
   // Adds anonymous code for testing purposes.
@@ -859,7 +872,8 @@ class V8_EXPORT_PRIVATE NativeModule final {
       int index, const CodeDesc& desc, int stack_slots,
       uint32_t tagged_parameter_slots,
       base::Vector<const byte> protected_instructions_data,
-      base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+      base::Vector<const byte> source_position_table,
+      base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
       ExecutionTier tier, ForDebugging for_debugging,
       base::Vector<uint8_t> code_space, const JumpTablesRef& jump_tables_ref);
 
diff --git a/src/wasm/wasm-debug.cc b/src/wasm/wasm-debug.cc
index 81cf24beb77..6071774e1a0 100644
--- a/src/wasm/wasm-debug.cc
+++ b/src/wasm/wasm-debug.cc
@@ -648,8 +648,8 @@ class DebugInfoImpl {
     DCHECK_EQ(frame->function_index(), new_code->index());
     DCHECK_EQ(frame->native_module(), new_code->native_module());
     DCHECK(frame->wasm_code()->is_liftoff());
-    Address new_pc =
-        FindNewPC(frame, new_code, frame->byte_offset(), return_location);
+    Address new_pc = FindNewPC(frame, new_code, frame->generated_code_offset(),
+                               return_location);
 #ifdef DEBUG
     int old_position = frame->position();
 #endif
diff --git a/src/wasm/wasm-module.cc b/src/wasm/wasm-module.cc
index ef38c1f0e74..fc27ec2ac9d 100644
--- a/src/wasm/wasm-module.cc
+++ b/src/wasm/wasm-module.cc
@@ -599,8 +599,8 @@ Handle<JSArray> GetCustomSections(Isolate* isolate,
   return array_object;
 }
 
-// Get the source position from a given function index and byte offset,
-// for either asm.js or pure Wasm modules.
+// Get the source position from a given function index and wire bytes offset
+// (relative to the function entry), for either asm.js or pure Wasm modules.
 int GetSourcePosition(const WasmModule* module, uint32_t func_index,
                       uint32_t byte_offset, bool is_at_number_conversion) {
   DCHECK_EQ(is_asmjs_module(module),
diff --git a/src/wasm/wasm-serialization.cc b/src/wasm/wasm-serialization.cc
index 11a827eefec..db6385b6385 100644
--- a/src/wasm/wasm-serialization.cc
+++ b/src/wasm/wasm-serialization.cc
@@ -201,6 +201,7 @@ constexpr size_t kCodeHeaderSize = sizeof(uint8_t) +  // code kind
                                    sizeof(int) +  // code size
                                    sizeof(int) +  // reloc size
                                    sizeof(int) +  // source positions size
+                                   sizeof(int) +  // inlining positions size
                                    sizeof(int) +  // protected instructions size
                                    sizeof(WasmCode::Kind) +  // code kind
                                    sizeof(ExecutionTier);    // tier
@@ -312,6 +313,7 @@ size_t NativeModuleSerializer::MeasureCode(const WasmCode* code) const {
   }
   return kCodeHeaderSize + code->instructions().size() +
          code->reloc_info().size() + code->source_positions().size() +
+         code->inlining_positions().size() +
          code->protected_instructions_data().size();
 }
 
@@ -386,6 +388,7 @@ void NativeModuleSerializer::WriteCode(const WasmCode* code, Writer* writer) {
   writer->Write(code->instructions().length());
   writer->Write(code->reloc_info().length());
   writer->Write(code->source_positions().length());
+  writer->Write(code->inlining_positions().length());
   writer->Write(code->protected_instructions_data().length());
   writer->Write(code->kind());
   writer->Write(code->tier());
@@ -395,9 +398,11 @@ void NativeModuleSerializer::WriteCode(const WasmCode* code, Writer* writer) {
   byte* code_start = serialized_code_start;
   size_t code_size = code->instructions().size();
   writer->Skip(code_size);
-  // Write the reloc info, source positions, and protected code.
+  // Write the reloc info, source positions, inlining positions and protected
+  // code.
   writer->WriteVector(code->reloc_info());
   writer->WriteVector(code->source_positions());
+  writer->WriteVector(code->inlining_positions());
   writer->WriteVector(code->protected_instructions_data());
 #if V8_TARGET_ARCH_MIPS64 || V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_PPC ||      \
     V8_TARGET_ARCH_PPC64 || V8_TARGET_ARCH_S390X || V8_TARGET_ARCH_RISCV32 || \
@@ -763,6 +768,7 @@ DeserializationUnit NativeModuleDeserializer::ReadCode(int fn_index,
   int code_size = reader->Read<int>();
   int reloc_size = reader->Read<int>();
   int source_position_size = reader->Read<int>();
+  int inlining_position_size = reader->Read<int>();
   int protected_instructions_size = reader->Read<int>();
   WasmCode::Kind kind = reader->Read<WasmCode::Kind>();
   ExecutionTier tier = reader->Read<ExecutionTier>();
@@ -785,6 +791,7 @@ DeserializationUnit NativeModuleDeserializer::ReadCode(int fn_index,
   unit.src_code_buffer = reader->ReadVector<byte>(code_size);
   auto reloc_info = reader->ReadVector<byte>(reloc_size);
   auto source_pos = reader->ReadVector<byte>(source_position_size);
+  auto inlining_pos = reader->ReadVector<byte>(inlining_position_size);
   auto protected_instructions =
       reader->ReadVector<byte>(protected_instructions_size);
 
@@ -797,7 +804,7 @@ DeserializationUnit NativeModuleDeserializer::ReadCode(int fn_index,
       fn_index, instructions, stack_slot_count, tagged_parameter_slots,
       safepoint_table_offset, handler_table_offset, constant_pool_offset,
       code_comment_offset, unpadded_binary_size, protected_instructions,
-      reloc_info, source_pos, kind, tier);
+      reloc_info, source_pos, inlining_pos, kind, tier);
   unit.jump_tables = current_jump_tables_;
   return unit;
 }
diff --git a/test/cctest/wasm/test-wasm-breakpoints.cc b/test/cctest/wasm/test-wasm-breakpoints.cc
index ab745f690d3..a070dab4e4b 100644
--- a/test/cctest/wasm/test-wasm-breakpoints.cc
+++ b/test/cctest/wasm/test-wasm-breakpoints.cc
@@ -118,7 +118,7 @@ class BreakHandler : public debug::DebugDelegate {
     // Check the current position.
     DebuggableStackFrameIterator frame_it(isolate_);
     auto summ = FrameSummary::GetTop(frame_it.frame()).AsWasm();
-    CHECK_EQ(expected_breaks_[count_].position, summ.byte_offset());
+    CHECK_EQ(expected_breaks_[count_].position, summ.code_offset());
 
     expected_breaks_[count_].pre_action();
     Action next_action = expected_breaks_[count_].action;
diff --git a/test/mjsunit/wasm/inlining.js b/test/mjsunit/wasm/inlining.js
index 4835265384d..7045b6a99a8 100644
--- a/test/mjsunit/wasm/inlining.js
+++ b/test/mjsunit/wasm/inlining.js
@@ -3,7 +3,7 @@
 // found in the LICENSE file.
 
 // Flags: --wasm-inlining --no-liftoff --experimental-wasm-return-call
-// Flags: --experimental-wasm-gc
+// Flags: --experimental-wasm-gc --allow-natives-syntax
 
 d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
@@ -531,3 +531,105 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
   builder.instantiate({});
 })();
+
+(function InliningTrapFromCallee() {
+  print(arguments.callee.name);
+  let builder = new WasmModuleBuilder();
+
+  // Add some types to have an index offset.
+  for (let i = 0; i < 10; ++i) {
+    builder.addFunction(null, makeSig([], [])).addBody([]);
+  }
+
+  let callee = builder.addFunction('callee', kSig_i_ii)
+    .addBody([
+      kExprLocalGet, 0,
+      kExprLocalGet, 1,
+      kExprI32DivU,
+    ]);
+
+  let intermediate = builder.addFunction('intermediate', kSig_i_ii)
+    .addBody([
+      // Some nops, so that the call doesn't have the same offset as the div
+      // in the callee.
+      kExprNop, kExprNop,
+      kExprLocalGet, 0,
+      kExprLocalGet, 1,
+      kExprCallFunction, callee.index,
+    ])
+    .exportFunc();
+
+  let caller = builder.addFunction('main', kSig_ii_ii)
+    .addBody([
+      // Some nops, so that the call doesn't have the same offset as the div
+      // in the callee.
+      kExprNop, kExprNop, kExprNop, kExprNop, kExprNop,
+      kExprLocalGet, 0,
+      kExprLocalGet, 1,
+      kExprCallFunction, intermediate.index,
+      // If it didn't trap, call it again without intermediate function and with
+      // swapped arguments.
+      kExprLocalGet, 1,
+      kExprLocalGet, 0,
+      kExprCallFunction, callee.index,
+    ])
+    .exportFunc();
+
+  let wire_bytes = builder.toBuffer();
+  let module = new WebAssembly.Module(wire_bytes);
+  let instance = new WebAssembly.Instance(module, {});
+  TestStackTrace(instance.exports.main);
+  // Serialize and deserialize the module to verify that the inlining positions
+  // are properly "transformed" here.
+  print("Repeat test with serialized module.")
+  module = %DeserializeWasmModule(%SerializeWasmModule(module), wire_bytes);
+  instance = new WebAssembly.Instance(module, {});
+  TestStackTrace(instance.exports.main);
+
+  function TestStackTrace(main) {
+    assertEquals([7, 0], main(21, 3));
+    assertTraps(kTrapDivByZero, () => main(1, 0));
+    // Test stack trace for trap.
+    try {
+      main(1, 0);
+      assertUnreachable();
+    } catch(e) {
+      assertMatches(/RuntimeError: divide by zero/, e.stack);
+      let expected_entries = [
+        // [name, index, offset]
+        ['callee', '' + callee.index, '0x8c'],
+        ['intermediate', '' + intermediate.index, '0x96'],
+        ['main', '' + caller.index, '0xa4'],
+      ];
+      CheckCallStack(e, expected_entries);
+    }
+
+    try {
+      main(0, 1);
+      assertUnreachable();
+    } catch(e) {
+      assertMatches(/RuntimeError: divide by zero/, e.stack);
+      let expected_entries = [
+        // [name, index, offset]
+        ['callee', '' + callee.index, '0x8c'],
+        ['main', '' + caller.index, '0xaa'],
+      ];
+      CheckCallStack(e, expected_entries);
+    }
+  }
+
+  function CheckCallStack(error, expected_entries) {
+    print(error.stack);
+    let regex = /at ([^ ]+) \(wasm[^\[]+\[([0-9]+)\]:(0x[0-9a-f]+)\)/g;
+    let entries = [...error.stack.matchAll(regex)];
+    for (let i = 0; i < expected_entries.length; ++i) {
+      let actual = entries[i];
+      print(`match = ${actual[0]}`);
+      let expected = expected_entries[i];
+      assertEquals(expected[0], actual[1]);
+      assertEquals(expected[1], actual[2]);
+      assertEquals(expected[2], actual[3]);
+    }
+    assertEquals(expected_entries.length, entries.length);
+  }
+})();
-- 
2.35.1


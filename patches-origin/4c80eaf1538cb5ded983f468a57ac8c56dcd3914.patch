From 4c80eaf1538cb5ded983f468a57ac8c56dcd3914 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Wed, 26 Jul 2023 17:16:01 +0800
Subject: [PATCH] [riscv][riscv32] Fix incorrectly read and push src in
 Construct. Bug: v8:14224

Change-Id: I98d15407bafec91288441a5fb785ac1ac1af706b
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4720305
Reviewed-by: Ji Qiu <qiuji@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Commit-Queue: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#89231}
---
 .../riscv/interface-descriptors-riscv-inl.h   |  2 +-
 .../riscv/liftoff-assembler-riscv32.h         | 53 ++++++++++++-------
 2 files changed, 35 insertions(+), 20 deletions(-)

diff --git a/src/codegen/riscv/interface-descriptors-riscv-inl.h b/src/codegen/riscv/interface-descriptors-riscv-inl.h
index f6fe9b48fef..6be1cb785b1 100644
--- a/src/codegen/riscv/interface-descriptors-riscv-inl.h
+++ b/src/codegen/riscv/interface-descriptors-riscv-inl.h
@@ -363,7 +363,7 @@ constexpr auto RunMicrotasksEntryDescriptor::registers() {
 
 constexpr auto WasmNewJSToWasmWrapperDescriptor::registers() {
   // Arbitrarily picked register.
-  return RegisterArray(a7);
+  return RegisterArray(t0);
 }
 
 }  // namespace internal
diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
index 98607d39ad0..60d62d47d0a 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
@@ -2150,25 +2150,40 @@ void LiftoffStackSlots::Construct(int param_slots) {
     const LiftoffAssembler::VarState& src = slot.src_;
     switch (src.loc()) {
       case LiftoffAssembler::VarState::kStack: {
-        if (src.kind() == kF64) {
-          asm_->AllocateStackSpace(stack_decrement - kDoubleSize);
-          DCHECK_EQ(kLowWord, slot.half_);
-          asm_->Lw(kScratchReg,
-                   liftoff::GetHalfStackSlot(slot.src_offset_, kHighWord));
-          asm_->push(kScratchReg);
-          asm_->Lw(kScratchReg,
-                   liftoff::GetHalfStackSlot(slot.src_offset_, kLowWord));
-          asm_->push(kScratchReg);
-        } else if (src.kind() != kS128) {
-          asm_->AllocateStackSpace(stack_decrement - kSystemPointerSize);
-          asm_->Lw(kScratchReg, liftoff::GetStackSlot(slot.src_offset_));
-          asm_->push(kScratchReg);
-        } else {
-          asm_->AllocateStackSpace(stack_decrement - kSimd128Size);
-          asm_->Lw(kScratchReg, liftoff::GetStackSlot(slot.src_offset_ - 8));
-          asm_->push(kScratchReg);
-          asm_->Lw(kScratchReg, liftoff::GetStackSlot(slot.src_offset_));
-          asm_->push(kScratchReg);
+        switch (src.kind()) {
+          // i32 and i64 can be treated as similar cases, i64 being previously
+          // split into two i32 registers
+          case kI32:
+          case kI64:
+          case kF32:
+          case kRef:
+          case kRefNull: {
+            asm_->AllocateStackSpace(stack_decrement - kSystemPointerSize);
+            UseScratchRegisterScope temps(asm_);
+            Register scratch = temps.Acquire();
+            asm_->Lw(scratch,
+                     liftoff::GetHalfStackSlot(slot.src_offset_, slot.half_));
+            asm_->Push(scratch);
+          } break;
+          case kF64: {
+            asm_->AllocateStackSpace(stack_decrement - kDoubleSize);
+            DCHECK_EQ(kLowWord, slot.half_);
+            asm_->Lw(kScratchReg,
+                     liftoff::GetHalfStackSlot(slot.src_offset_, kHighWord));
+            asm_->push(kScratchReg);
+            asm_->Lw(kScratchReg,
+                     liftoff::GetHalfStackSlot(slot.src_offset_, kLowWord));
+            asm_->push(kScratchReg);
+          } break;
+          case kS128: {
+            asm_->AllocateStackSpace(stack_decrement - kSimd128Size);
+            asm_->Lw(kScratchReg, liftoff::GetStackSlot(slot.src_offset_ - 8));
+            asm_->push(kScratchReg);
+            asm_->Lw(kScratchReg, liftoff::GetStackSlot(slot.src_offset_));
+            asm_->push(kScratchReg);
+          } break;
+          default:
+            UNREACHABLE();
         }
         break;
       }
-- 
2.35.1


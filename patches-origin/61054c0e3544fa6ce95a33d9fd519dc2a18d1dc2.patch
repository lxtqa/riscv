From 61054c0e3544fa6ce95a33d9fd519dc2a18d1dc2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E6=9D=A8=E6=96=87=E6=98=8E?= <yangwenming@bytedance.com>
Date: Thu, 13 Jul 2023 17:40:33 +0800
Subject: [PATCH] [riscv,wasm,atomic] fix i64 compare&exchange for riscv32.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This CL refactor codes before and after calling a c function to
implement atomic compare&exchange on riscv32. Necessary values are moved
to registers according to the calling conv and the formerly reported
bad memory access is avoided.

Bug: v8:14116
Change-Id: I0e0ad0a7d1b6cb875c4fd44201c9471f7046ed61
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4680539
Auto-Submit: 杨文明 <yangwenming@bytedance.com>
Reviewed-by: Thibaud Michaud <thibaudm@chromium.org>
Commit-Queue: Thibaud Michaud <thibaudm@chromium.org>
Cr-Commit-Position: refs/heads/main@{#89011}
---
 .../riscv/liftoff-assembler-riscv32.h         | 23 +++++++---
 test/mjsunit/regress/wasm/regress-14116.js    | 43 +++++++++++++++++++
 2 files changed, 61 insertions(+), 5 deletions(-)
 create mode 100644 test/mjsunit/regress/wasm/regress-14116.js

diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
index fd89398c09b..28810064600 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv32.h
@@ -850,15 +850,28 @@ void LiftoffAssembler::AtomicCompareExchange(
   if (type.value() == StoreType::kI64Store) {
     Register actual_addr = liftoff::CalculateActualAddress(
         this, dst_addr, offset_reg, offset_imm, kScratchReg);
-    Mv(a0, actual_addr);
     FrameScope scope(this, StackFrame::MANUAL);
-    PushCallerSaved(SaveFPRegsMode::kIgnore, a0, a1);
+    // NOTE:
+    // a0~a4 are caller-saved registers and also used
+    // to pass parameters for C functions.
+    RegList c_params = {arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4, a4};
+    RegList result_list = {result.low_gp(), result.high_gp()};
+    MultiPush(c_params - result_list);
+
+    Mv(a0, actual_addr);
+    Mv(a1, expected.low_gp());
+    Mv(a2, expected.high_gp());
+    Mv(a3, new_value.low_gp());
+    Mv(a4, new_value.high_gp());
+
+    MultiPush(kJSCallerSaved - c_params - result_list);
     PrepareCallCFunction(5, 0, kScratchReg);
     CallCFunction(ExternalReference::atomic_pair_compare_exchange_function(), 5,
                   0);
-    PopCallerSaved(SaveFPRegsMode::kIgnore, a0, a1);
-    Mv(result.low_gp(), a0);
-    Mv(result.high_gp(), a1);
+    MultiPop(kJSCallerSaved - c_params - result_list);
+    Mv(result.low_gp(), kReturnRegister0);
+    Mv(result.high_gp(), kReturnRegister1);
+    MultiPop(c_params - result_list);
     return;
   }
   // Make sure that {result} is unique.
diff --git a/test/mjsunit/regress/wasm/regress-14116.js b/test/mjsunit/regress/wasm/regress-14116.js
new file mode 100644
index 00000000000..78ddadf16e1
--- /dev/null
+++ b/test/mjsunit/regress/wasm/regress-14116.js
@@ -0,0 +1,43 @@
+// Copyright 2023 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Flags: --liftoff --no-wasm-tier-up
+
+d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');
+
+(function () {
+  const builder = new WasmModuleBuilder();
+  builder.addImportedMemory("imports", "mem", 1);
+  builder.addType(makeSig([kWasmI32, kWasmI64, kWasmI64], [kWasmI64]));
+  // Generate function 1 (out of 1).
+  builder.addFunction(undefined, 0 /* sig */).addBodyWithEnd([
+    kExprLocalGet, 0,
+    kExprLocalGet, 1,
+    kExprLocalGet, 2,
+    kAtomicPrefix, kExprI64AtomicCompareExchange, 0x03, 0x00,
+    kExprEnd
+  ]);
+  builder.addExport('run', 0);
+  var mem = new WebAssembly.Memory({ initial: 1 });
+
+  let i64arr = new BigUint64Array(mem.buffer);
+  let dv = new DataView(mem.buffer);
+  dv.setBigUint64(0, 0n, true)
+  dv.setBigUint64(8, 0x8eeeffffffffn, true)
+
+  const instance = builder.instantiate({ imports: { mem: mem } });
+  // Equal, new value is stored and old value returned.
+  assertEquals(0n, instance.exports.run(0, 0n, 1n));
+  assertEquals(1n, i64arr[0]);
+  // Not equal, old value stays.
+  assertEquals(1n, instance.exports.run(0, 0n, 2n));
+  assertEquals(1n, i64arr[0]);
+
+  // Equal, new value is stored and old value returned.
+  assertEquals(0x8eeeffffffffn, instance.exports.run(8, 0x8eeeffffffffn, 0x1000ffffffffn));
+  assertEquals(0x1000ffffffffn, i64arr[1]);
+  // Not equal, old value stays.
+  assertEquals(0x1000ffffffffn, instance.exports.run(8, 0x8eeeffffffffn, 0x1n));
+  assertEquals(0x1000ffffffffn, i64arr[1]);
+})();
-- 
2.35.1


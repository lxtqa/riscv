From 9bd7c5e1bdd01c5af7923b3d8387ddae461249cd Mon Sep 17 00:00:00 2001
From: Victor Gomes <victorgomes@chromium.org>
Date: Tue, 17 Jan 2023 10:44:46 +0100
Subject: [PATCH] [maglev] Fix visiting stack in StackGuard call

The RegisterInput (NewTarget) was not correctly visited by the GC.
This:
- Creates a sentinel safepoint to indicate that the stack is not
fully created (we are in the stack guard call).
- Generalises RegisterInputs (we assumed only NewTarget before) and
save them in the graph.
- Pass the register input count via tagged_register_indexes in
this case.

Fixed: chromium:1407606
Bug: v8:7700
Change-Id: I8f599f8c1a992ee6fd886eec1e289454649dfec8
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4171626
Auto-Submit: Victor Gomes <victorgomes@chromium.org>
Reviewed-by: Leszek Swirski <leszeks@chromium.org>
Commit-Queue: Leszek Swirski <leszeks@chromium.org>
Cr-Commit-Position: refs/heads/main@{#85331}
---
 src/codegen/maglev-safepoint-table.h          | 15 +++++++
 src/execution/arm/frame-constants-arm.cc      |  6 +++
 src/execution/arm64/frame-constants-arm64.cc  | 10 +++++
 src/execution/frames.cc                       | 40 ++++++-------------
 src/execution/frames.h                        |  2 +
 src/execution/ia32/frame-constants-ia32.cc    |  6 +++
 .../loong64/frame-constants-loong64.cc        |  6 +++
 .../mips64/frame-constants-mips64.cc          |  6 +++
 src/execution/ppc/frame-constants-ppc.cc      |  6 +++
 src/execution/riscv/frame-constants-riscv.cc  |  6 +++
 src/execution/s390/frame-constants-s390.cc    |  6 +++
 src/execution/x64/frame-constants-x64.cc      |  8 ++++
 src/maglev/arm64/maglev-assembler-arm64.cc    | 23 ++++++-----
 src/maglev/maglev-assembler.h                 |  4 ++
 src/maglev/maglev-graph-builder.cc            |  6 +--
 src/maglev/maglev-graph-builder.h             |  6 +++
 src/maglev/maglev-graph.h                     |  3 ++
 src/maglev/maglev-ir.h                        |  7 +---
 src/maglev/x64/maglev-assembler-x64.cc        | 15 ++++---
 test/mjsunit/maglev/regress-1407606.js        | 18 +++++++++
 20 files changed, 147 insertions(+), 52 deletions(-)
 create mode 100644 test/mjsunit/maglev/regress-1407606.js

diff --git a/src/codegen/maglev-safepoint-table.h b/src/codegen/maglev-safepoint-table.h
index cc0d3186b34..522fac7a90d 100644
--- a/src/codegen/maglev-safepoint-table.h
+++ b/src/codegen/maglev-safepoint-table.h
@@ -21,6 +21,7 @@ class MaglevSafepointEntry : public SafepointEntryBase {
  public:
   static constexpr int kNoDeoptIndex = -1;
   static constexpr int kNoTrampolinePC = -1;
+  static constexpr uint8_t kStackGuardCallSentinel = 255;
 
   MaglevSafepointEntry() = default;
 
@@ -49,6 +50,14 @@ class MaglevSafepointEntry : public SafepointEntryBase {
   uint8_t num_pushed_registers() const { return num_pushed_registers_; }
   uint32_t tagged_register_indexes() const { return tagged_register_indexes_; }
 
+  bool is_stack_guard_call() const {
+    return num_pushed_registers_ == kStackGuardCallSentinel;
+  }
+  uint32_t register_input_count() const {
+    DCHECK(is_stack_guard_call());
+    return tagged_register_indexes_;
+  }
+
  private:
   uint32_t num_tagged_slots_ = 0;
   uint32_t num_untagged_slots_ = 0;
@@ -208,6 +217,12 @@ class MaglevSafepointTableBuilder : public SafepointTableBuilderBase {
       entry_->num_pushed_registers = num_registers;
     }
 
+    void DefineStackGuardSafepoint(int register_input_count) {
+      entry_->num_pushed_registers =
+          MaglevSafepointEntry::kStackGuardCallSentinel;
+      entry_->tagged_register_indexes = register_input_count;
+    }
+
    private:
     friend class MaglevSafepointTableBuilder;
     explicit Safepoint(EntryBuilder* entry) : entry_(entry) {}
diff --git a/src/execution/arm/frame-constants-arm.cc b/src/execution/arm/frame-constants-arm.cc
index 7a72dab870a..bcf26f489ae 100644
--- a/src/execution/arm/frame-constants-arm.cc
+++ b/src/execution/arm/frame-constants-arm.cc
@@ -26,6 +26,12 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  USE(register_input_count);
+  UNREACHABLE();
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/arm64/frame-constants-arm64.cc b/src/execution/arm64/frame-constants-arm64.cc
index 96f6f25e757..c7f61b3fc42 100644
--- a/src/execution/arm64/frame-constants-arm64.cc
+++ b/src/execution/arm64/frame-constants-arm64.cc
@@ -35,6 +35,16 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return rounded_slot_count - slot_count;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  // Include any paddings from kFixedFrameSizeFromFp, an extra slot + padding
+  // for the single argument into StackGuardWithGap and finally padded register
+  // input count.
+  int slot_count = RoundUp(StandardFrameConstants::kFixedSlotCountFromFp, 2) +
+                   2 /* argument */ + RoundUp(register_input_count, 2);
+  return slot_count * kSystemPointerSize;
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index a5decf1df17..93ed91a3d9f 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -1458,41 +1458,26 @@ void MaglevFrame::Iterate(RootVisitor* v) const {
                 maglev_safepoint_entry.num_tagged_slots() +
                 maglev_safepoint_entry.num_untagged_slots());
 
-  // Check that our frame size is big enough for our spill slots and pushed
-  // registers.
-  intptr_t actual_frame_size = static_cast<intptr_t>(fp() - sp());
-  intptr_t expected_frame_size_excl_outgoing_params =
-      StandardFrameConstants::kFixedFrameSizeFromFp +
-      (spill_slot_count + maglev_safepoint_entry.num_pushed_registers()) *
-          kSystemPointerSize;
-  if (actual_frame_size < expected_frame_size_excl_outgoing_params) {
-    // If the frame size is smaller than the expected size, then we must be in
-    // the stack guard in the prologue of the maglev function. This means that
-    // we've set up the frame header, but not the spill slots yet.
-
+  // Check if we are calling the stack guard in the prologue.
+  if (maglev_safepoint_entry.is_stack_guard_call()) {
+    // We don't have a complete frame in this case.
+    uint32_t register_input_count =
+        maglev_safepoint_entry.register_input_count();
     if (v8_flags.maglev_ool_prologue) {
       // DCHECK the frame setup under the above assumption. The
       // MaglevOutOfLinePrologue builtin creates an INTERNAL frame for the
       // StackGuardWithGap call (where extra slots and args are), so the MAGLEV
       // frame itself is exactly kFixedFrameSizeFromFp.
-      DCHECK_EQ(actual_frame_size,
+      DCHECK_EQ(static_cast<intptr_t>(fp() - sp()),
                 StandardFrameConstants::kFixedFrameSizeFromFp);
-      DCHECK_EQ(isolate()->c_function(),
-                Runtime::FunctionForId(Runtime::kStackGuardWithGap)->entry);
-      DCHECK_EQ(maglev_safepoint_entry.num_pushed_registers(), 0);
     } else {
-      // DCHECK the frame setup under the above assumption. Include one extra
-      // slot for the single argument into StackGuardWithGap, and another for
-      // the saved new.target register.
-      DCHECK_EQ(actual_frame_size,
-                StandardFrameConstants::kFixedFrameSizeFromFp +
-                    2 * kSystemPointerSize);
-      DCHECK_EQ(isolate()->c_function(),
-                Runtime::FunctionForId(Runtime::kStackGuardWithGap)->entry);
-      DCHECK_EQ(maglev_safepoint_entry.num_pushed_registers(), 0);
+      // DCHECK the frame setup under the above assumption.
+      DCHECK_EQ(static_cast<intptr_t>(fp() - sp()),
+                MaglevFrame::StackGuardFrameSize(register_input_count));
     }
     spill_slot_count = 0;
-    tagged_slot_count = 0;
+    // We visit the saved register inputs as if they were tagged slots.
+    tagged_slot_count = register_input_count;
   }
 
   // Visit the outgoing parameters if they are tagged.
@@ -1508,7 +1493,8 @@ void MaglevFrame::Iterate(RootVisitor* v) const {
   // a call. These are distinct from normal spill slots and live between the
   // normal spill slots and the pushed parameters. Some of these are tagged,
   // as indicated by the tagged register indexes, and should be visited too.
-  if (maglev_safepoint_entry.num_pushed_registers() > 0) {
+  if (!maglev_safepoint_entry.is_stack_guard_call() &&
+      maglev_safepoint_entry.num_pushed_registers() > 0) {
     FullObjectSlot pushed_register_base =
         frame_header_base - spill_slot_count - 1;
     uint32_t tagged_register_indexes =
diff --git a/src/execution/frames.h b/src/execution/frames.h
index c1990fbc854..f9c610beb64 100644
--- a/src/execution/frames.h
+++ b/src/execution/frames.h
@@ -974,6 +974,8 @@ class MaglevFrame : public OptimizedFrame {
 
   BytecodeOffset GetBytecodeOffsetForOSR() const;
 
+  static intptr_t StackGuardFrameSize(int register_input_count);
+
  protected:
   inline explicit MaglevFrame(StackFrameIteratorBase* iterator);
 
diff --git a/src/execution/ia32/frame-constants-ia32.cc b/src/execution/ia32/frame-constants-ia32.cc
index 16e9e75a440..bdf48e2b8f2 100644
--- a/src/execution/ia32/frame-constants-ia32.cc
+++ b/src/execution/ia32/frame-constants-ia32.cc
@@ -27,6 +27,12 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  USE(register_input_count);
+  UNREACHABLE();
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/loong64/frame-constants-loong64.cc b/src/execution/loong64/frame-constants-loong64.cc
index 4bd809266c6..86d271d207c 100644
--- a/src/execution/loong64/frame-constants-loong64.cc
+++ b/src/execution/loong64/frame-constants-loong64.cc
@@ -26,6 +26,12 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  USE(register_input_count);
+  UNREACHABLE();
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/mips64/frame-constants-mips64.cc b/src/execution/mips64/frame-constants-mips64.cc
index cfe899730ca..66f14f85167 100644
--- a/src/execution/mips64/frame-constants-mips64.cc
+++ b/src/execution/mips64/frame-constants-mips64.cc
@@ -26,6 +26,12 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  USE(register_input_count);
+  UNREACHABLE();
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/ppc/frame-constants-ppc.cc b/src/execution/ppc/frame-constants-ppc.cc
index 45a53b07b6d..f4256a0e63e 100644
--- a/src/execution/ppc/frame-constants-ppc.cc
+++ b/src/execution/ppc/frame-constants-ppc.cc
@@ -29,6 +29,12 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  USE(register_input_count);
+  UNREACHABLE();
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/riscv/frame-constants-riscv.cc b/src/execution/riscv/frame-constants-riscv.cc
index 833af91e7e6..3fbbc7ab64a 100644
--- a/src/execution/riscv/frame-constants-riscv.cc
+++ b/src/execution/riscv/frame-constants-riscv.cc
@@ -23,5 +23,11 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  USE(register_input_count);
+  UNREACHABLE();
+}
+
 }  // namespace internal
 }  // namespace v8
diff --git a/src/execution/s390/frame-constants-s390.cc b/src/execution/s390/frame-constants-s390.cc
index 50f3445556c..86071459617 100644
--- a/src/execution/s390/frame-constants-s390.cc
+++ b/src/execution/s390/frame-constants-s390.cc
@@ -26,6 +26,12 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  USE(register_input_count);
+  UNREACHABLE();
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/execution/x64/frame-constants-x64.cc b/src/execution/x64/frame-constants-x64.cc
index fb242505dd0..df612a08cfd 100644
--- a/src/execution/x64/frame-constants-x64.cc
+++ b/src/execution/x64/frame-constants-x64.cc
@@ -26,6 +26,14 @@ int BuiltinContinuationFrameConstants::PaddingSlotCount(int register_count) {
   return 0;
 }
 
+// static
+intptr_t MaglevFrame::StackGuardFrameSize(int register_input_count) {
+  // Include one extra slot for the single argument into StackGuardWithGap +
+  // register input count.
+  return StandardFrameConstants::kFixedFrameSizeFromFp +
+         (1 + register_input_count) * kSystemPointerSize;
+}
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/maglev/arm64/maglev-assembler-arm64.cc b/src/maglev/arm64/maglev-assembler-arm64.cc
index 841b2ffd3cd..6ca8a0b0830 100644
--- a/src/maglev/arm64/maglev-assembler-arm64.cc
+++ b/src/maglev/arm64/maglev-assembler-arm64.cc
@@ -245,19 +245,24 @@ void MaglevAssembler::Prologue(Graph* graph) {
     ZoneLabelRef deferred_call_stack_guard_return(this);
     JumpToDeferredIf(
         lo,
-        [](MaglevAssembler* masm, ZoneLabelRef done, int max_stack_size) {
+        [](MaglevAssembler* masm, ZoneLabelRef done, RegList register_inputs,
+           int max_stack_size) {
           ASM_CODE_COMMENT_STRING(masm, "Stack/interrupt call");
-          // Save any registers that can be referenced by RegisterInput.
-          // TODO(leszeks): Only push those that are used by the graph.
-          __ PushAll(RegisterInput::kAllowedRegisters);
-          // Push the frame size
-          __ Mov(ip0, Smi::FromInt(max_stack_size * kSystemPointerSize));
-          __ PushArgument(ip0);
+          __ PushAll(register_inputs);
+          UseScratchRegisterScope temps(masm);
+          Register scratch = temps.AcquireX();
+          __ Mov(scratch, Smi::FromInt(max_stack_size * kSystemPointerSize));
+          __ PushArgument(scratch);
           __ CallRuntime(Runtime::kStackGuardWithGap, 1);
-          __ PopAll(RegisterInput::kAllowedRegisters);
+          auto safepoint =
+              masm->safepoint_table_builder()->DefineSafepoint(masm);
+          safepoint.DefineStackGuardSafepoint(
+              RoundUp<2>(register_inputs.Count()));
+          __ PopAll(register_inputs);
           __ B(*done);
         },
-        deferred_call_stack_guard_return, max_stack_size);
+        deferred_call_stack_guard_return, graph->register_inputs(),
+        max_stack_size);
     bind(*deferred_call_stack_guard_return);
   }
 
diff --git a/src/maglev/maglev-assembler.h b/src/maglev/maglev-assembler.h
index d2ac2fda967..bdb75747f5c 100644
--- a/src/maglev/maglev-assembler.h
+++ b/src/maglev/maglev-assembler.h
@@ -350,6 +350,10 @@ struct CopyForDeferredHelper<EagerDeoptInfo*>
 template <>
 struct CopyForDeferredHelper<ZoneLabelRef>
     : public CopyForDeferredByValue<ZoneLabelRef> {};
+// RegList are copied by value.
+template <>
+struct CopyForDeferredHelper<RegList> : public CopyForDeferredByValue<RegList> {
+};
 // Register snapshots are copied by value.
 template <>
 struct CopyForDeferredHelper<RegisterSnapshot>
diff --git a/src/maglev/maglev-graph-builder.cc b/src/maglev/maglev-graph-builder.cc
index 160e7cad04a..f5f332f5d67 100644
--- a/src/maglev/maglev-graph-builder.cc
+++ b/src/maglev/maglev-graph-builder.cc
@@ -285,10 +285,8 @@ void MaglevGraphBuilder::BuildRegisterFrameInitialization() {
     for (; register_index < new_target_index; register_index++) {
       StoreRegister(interpreter::Register(register_index), undefined_value);
     }
-    StoreRegister(
-        new_target_or_generator_register,
-        // TODO(leszeks): Expose in Graph.
-        AddNewNode<RegisterInput>({}, kJavaScriptCallNewTargetRegister));
+    StoreRegister(new_target_or_generator_register,
+                  GetRegisterInput(kJavaScriptCallNewTargetRegister));
     register_index++;
   }
   for (; register_index < register_count(); register_index++) {
diff --git a/src/maglev/maglev-graph-builder.h b/src/maglev/maglev-graph-builder.h
index 3c97bcacd59..f084c09590c 100644
--- a/src/maglev/maglev-graph-builder.h
+++ b/src/maglev/maglev-graph-builder.h
@@ -663,6 +663,12 @@ class MaglevGraphBuilder {
     return it->second;
   }
 
+  ValueNode* GetRegisterInput(Register reg) {
+    DCHECK(!graph_->register_inputs().has(reg));
+    graph_->register_inputs().set(reg);
+    return AddNewNode<RegisterInput>({}, reg);
+  }
+
 #define DEFINE_IS_ROOT_OBJECT(type, name, CamelName)               \
   bool Is##CamelName(ValueNode* value) const {                     \
     if (RootConstant* constant = value->TryCast<RootConstant>()) { \
diff --git a/src/maglev/maglev-graph.h b/src/maglev/maglev-graph.h
index 29998a39728..f07ffae883e 100644
--- a/src/maglev/maglev-graph.h
+++ b/src/maglev/maglev-graph.h
@@ -34,6 +34,7 @@ class Graph final : public ZoneObject {
         float_(zone),
         external_references_(zone),
         parameters_(zone),
+        register_inputs_(),
         constants_(zone) {}
 
   BasicBlock* operator[](int i) { return blocks_[i]; }
@@ -83,6 +84,7 @@ class Graph final : public ZoneObject {
     return external_references_;
   }
   ZoneVector<InitialValue*>& parameters() { return parameters_; }
+  RegList& register_inputs() { return register_inputs_; }
   compiler::ZoneRefMap<compiler::ObjectRef, Constant*>& constants() {
     return constants_;
   }
@@ -104,6 +106,7 @@ class Graph final : public ZoneObject {
   ZoneMap<double, Float64Constant*> float_;
   ZoneMap<Address, ExternalConstant*> external_references_;
   ZoneVector<InitialValue*> parameters_;
+  RegList register_inputs_;
   compiler::ZoneRefMap<compiler::ObjectRef, Constant*> constants_;
   Float64Constant* nan_ = nullptr;
 };
diff --git a/src/maglev/maglev-ir.h b/src/maglev/maglev-ir.h
index 94b18acc499..1367f9337a3 100644
--- a/src/maglev/maglev-ir.h
+++ b/src/maglev/maglev-ir.h
@@ -3033,13 +3033,8 @@ class RegisterInput : public FixedInputValueNodeT<0, RegisterInput> {
   using Base = FixedInputValueNodeT<0, RegisterInput>;
 
  public:
-  static constexpr RegList kAllowedRegisters = {
-      kJavaScriptCallNewTargetRegister};
-
   explicit RegisterInput(uint64_t bitfield, Register input)
-      : Base(bitfield), input_(input) {
-    DCHECK(kAllowedRegisters.has(input));
-  }
+      : Base(bitfield), input_(input) {}
 
   Register input() const { return input_; }
 
diff --git a/src/maglev/x64/maglev-assembler-x64.cc b/src/maglev/x64/maglev-assembler-x64.cc
index 1f3a6f0b1fb..b314cd4deba 100644
--- a/src/maglev/x64/maglev-assembler-x64.cc
+++ b/src/maglev/x64/maglev-assembler-x64.cc
@@ -438,18 +438,21 @@ void MaglevAssembler::Prologue(Graph* graph) {
     ZoneLabelRef deferred_call_stack_guard_return(this);
     JumpToDeferredIf(
         below_equal,
-        [](MaglevAssembler* masm, ZoneLabelRef done, int max_stack_size) {
+        [](MaglevAssembler* masm, ZoneLabelRef done, RegList register_inputs,
+           int max_stack_size) {
           ASM_CODE_COMMENT_STRING(masm, "Stack/interrupt call");
-          // Save any registers that can be referenced by RegisterInput.
-          // TODO(leszeks): Only push those that are used by the graph.
-          __ PushAll(RegisterInput::kAllowedRegisters);
+          __ PushAll(register_inputs);
           // Push the frame size
           __ Push(Immediate(Smi::FromInt(max_stack_size)));
           __ CallRuntime(Runtime::kStackGuardWithGap, 1);
-          __ PopAll(RegisterInput::kAllowedRegisters);
+          auto safepoint =
+              masm->safepoint_table_builder()->DefineSafepoint(masm);
+          safepoint.DefineStackGuardSafepoint(register_inputs.Count());
+          __ PopAll(register_inputs);
           __ jmp(*done);
         },
-        deferred_call_stack_guard_return, max_stack_size);
+        deferred_call_stack_guard_return, graph->register_inputs(),
+        max_stack_size);
     bind(*deferred_call_stack_guard_return);
   }
 
diff --git a/test/mjsunit/maglev/regress-1407606.js b/test/mjsunit/maglev/regress-1407606.js
new file mode 100644
index 00000000000..f44142c008c
--- /dev/null
+++ b/test/mjsunit/maglev/regress-1407606.js
@@ -0,0 +1,18 @@
+// Copyright 2022 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// Flags: --allow-natives-syntax --maglev
+
+for (let v0 = 0; v0 < 100; v0++) {
+    for (let v1 = 0; v1 < 100; v1++) {
+        const v4 = new Float64Array(33519);
+    }
+    for (let v5 = 0; v5 < 100; v5++) {
+        function F8(  a12) {
+            if (!new.target) { throw 'must be called with new'; }
+            a12--;
+        }
+        const v14 = new F8(- -1000000.0);
+    }
+}
-- 
2.35.1


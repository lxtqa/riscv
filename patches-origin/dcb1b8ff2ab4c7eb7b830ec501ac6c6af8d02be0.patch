From dcb1b8ff2ab4c7eb7b830ec501ac6c6af8d02be0 Mon Sep 17 00:00:00 2001
From: Clemens Backes <clemensb@chromium.org>
Date: Wed, 3 May 2023 15:11:18 +0200
Subject: [PATCH] [wasm][cleanup] Use uint8_t instead of byte

Byte is an alias for the standard uint8_t type (defined in
src/common/globals.h).
For readability, avoid the alias and use the uint8_t directly.

R=ahaas@chromium.org

Change-Id: Id7ac954ee955c9c1b9e8e11d3f3a83e007872c2a
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4503229
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#87408}
---
 src/compiler/wasm-compiler.cc                 |   2 +-
 src/runtime/runtime-wasm.cc                   |  10 +-
 .../baseline/ia32/liftoff-assembler-ia32.h    |  14 +-
 src/wasm/baseline/liftoff-compiler.cc         |   2 +-
 src/wasm/baseline/x64/liftoff-assembler-x64.h |   8 +-
 src/wasm/constant-expression-interface.cc     |   2 +-
 src/wasm/constant-expression.cc               |   6 +-
 src/wasm/decoder.h                            |  75 +++----
 src/wasm/function-body-decoder-impl.h         | 192 ++++++++++--------
 src/wasm/function-body-decoder.cc             |  23 ++-
 src/wasm/function-body-decoder.h              |  40 ++--
 src/wasm/function-compiler.h                  |   6 +-
 src/wasm/jump-table-assembler.cc              |  16 +-
 src/wasm/local-decl-encoder.cc                |  11 +-
 src/wasm/local-decl-encoder.h                 |   4 +-
 src/wasm/module-decoder-impl.h                |  78 +++----
 src/wasm/module-decoder.cc                    |   4 +-
 src/wasm/module-instantiate.cc                |  17 +-
 src/wasm/names-provider.cc                    |   6 +-
 src/wasm/stacks.cc                            |   6 +-
 src/wasm/stacks.h                             |   4 +-
 src/wasm/string-builder.h                     |   2 +-
 src/wasm/wasm-code-manager.cc                 |  62 +++---
 src/wasm/wasm-code-manager.h                  |  52 ++---
 src/wasm/wasm-debug.cc                        |   6 +-
 src/wasm/wasm-disassembler-impl.h             |   6 +-
 src/wasm/wasm-disassembler.cc                 |  38 ++--
 src/wasm/wasm-engine.cc                       |   2 +-
 src/wasm/wasm-engine.h                        |   2 +-
 src/wasm/wasm-external-refs.cc                |   6 +-
 src/wasm/wasm-module-builder.cc               |  25 +--
 src/wasm/wasm-module-builder.h                |  42 ++--
 src/wasm/wasm-module.cc                       |   2 +-
 src/wasm/wasm-module.h                        |  22 +-
 src/wasm/wasm-objects-inl.h                   |   6 +-
 src/wasm/wasm-objects.cc                      |  16 +-
 src/wasm/wasm-objects.h                       |   6 +-
 src/wasm/wasm-opcodes-inl.h                   |  16 +-
 src/wasm/wasm-opcodes.h                       |   2 +-
 src/wasm/wasm-serialization.cc                |  68 +++----
 src/wasm/wasm-serialization.h                 |   9 +-
 src/wasm/wasm-value.h                         |  10 +-
 42 files changed, 477 insertions(+), 449 deletions(-)

diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index caef9b87f1..fac7eb65d3 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -178,7 +178,7 @@ bool WasmGraphBuilder::TryWasmInlining(int fct_index,
     // Inlining of imported functions is not supported.
     return false;
   }
-  base::Vector<const byte> bytes(native_module->wire_bytes().SubVector(
+  base::Vector<const uint8_t> bytes(native_module->wire_bytes().SubVector(
       inlinee.code.offset(), inlinee.code.end_offset()));
   const wasm::FunctionBody inlinee_body(inlinee.sig, inlinee.code.offset(),
                                         bytes.begin(), bytes.end());
diff --git a/src/runtime/runtime-wasm.cc b/src/runtime/runtime-wasm.cc
index a3f3d03920..cadb62b822 100644
--- a/src/runtime/runtime-wasm.cc
+++ b/src/runtime/runtime-wasm.cc
@@ -1123,7 +1123,7 @@ RUNTIME_FUNCTION(Runtime_WasmStringNewWtf16) {
     return ThrowWasmError(isolate, MessageTemplate::kWasmTrapUnalignedAccess);
   }
 
-  const byte* bytes = instance.memory0_start() + offset;
+  const uint8_t* bytes = instance.memory0_start() + offset;
   const base::uc16* codeunits = reinterpret_cast<const base::uc16*>(bytes);
   RETURN_RESULT_OR_TRAP(isolate->factory()->NewStringFromTwoByteLittleEndian(
       {codeunits, size_in_codeunits}));
@@ -1439,10 +1439,10 @@ RUNTIME_FUNCTION(Runtime_WasmStringViewWtf8Encode) {
     return ThrowWasmError(isolate, MessageTemplate::kWasmTrapMemOutOfBounds);
   }
 
-  byte* memory_start = reinterpret_cast<byte*>(instance.memory0_start());
-  const byte* src =
-      reinterpret_cast<const byte*>(array->GetDataStartAddress() + start);
-  byte* dst = memory_start + addr;
+  uint8_t* memory_start = reinterpret_cast<uint8_t*>(instance.memory0_start());
+  const uint8_t* src =
+      reinterpret_cast<const uint8_t*>(array->GetDataStartAddress() + start);
+  uint8_t* dst = memory_start + addr;
 
   std::vector<size_t> surrogates;
   if (utf8_variant != unibrow::Utf8Variant::kWtf8) {
diff --git a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
index c3ecfcaab7..bd761b2890 100644
--- a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
+++ b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
@@ -2711,12 +2711,12 @@ void EmitSimdShiftOp(LiftoffAssembler* assm, LiftoffRegister dst,
   }
 }
 
-template <void (Assembler::*avx_op)(XMMRegister, XMMRegister, byte),
-          void (Assembler::*sse_op)(XMMRegister, byte), uint8_t width>
+template <void (Assembler::*avx_op)(XMMRegister, XMMRegister, uint8_t),
+          void (Assembler::*sse_op)(XMMRegister, uint8_t), uint8_t width>
 void EmitSimdShiftOpImm(LiftoffAssembler* assm, LiftoffRegister dst,
                         LiftoffRegister operand, int32_t count) {
   constexpr int mask = (1 << width) - 1;
-  byte shift = static_cast<byte>(count & mask);
+  uint8_t shift = static_cast<uint8_t>(count & mask);
   if (CpuFeatures::IsSupported(AVX)) {
     CpuFeatureScope scope(assm, AVX);
     (assm->*avx_op)(dst.fp(), operand.fp(), shift);
@@ -4278,10 +4278,10 @@ void LiftoffAssembler::emit_f32x4_uconvert_i32x4(LiftoffRegister dst,
     psubd(dst.fp(), liftoff::kScratchDoubleReg);
   }
   Cvtdq2ps(liftoff::kScratchDoubleReg,
-           liftoff::kScratchDoubleReg);  // Convert lo exactly.
-  Psrld(dst.fp(), dst.fp(), byte{1});   // Divide by 2 to get in unsigned range.
-  Cvtdq2ps(dst.fp(), dst.fp());         // Convert hi, exactly.
-  Addps(dst.fp(), dst.fp(), dst.fp());  // Double hi, exactly.
+           liftoff::kScratchDoubleReg);   // Convert lo exactly.
+  Psrld(dst.fp(), dst.fp(), uint8_t{1});  // Div by 2 to get in unsigned range.
+  Cvtdq2ps(dst.fp(), dst.fp());           // Convert hi, exactly.
+  Addps(dst.fp(), dst.fp(), dst.fp());    // Double hi, exactly.
   Addps(dst.fp(), dst.fp(),
         liftoff::kScratchDoubleReg);  // Add hi and lo, may round.
 }
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index af99000335..ee6800bd23 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -8341,7 +8341,7 @@ std::unique_ptr<DebugSideTable> GenerateLiftoffDebugSideTable(
   auto* native_module = code->native_module();
   auto* function = &native_module->module()->functions[code->index()];
   ModuleWireBytes wire_bytes{native_module->wire_bytes()};
-  base::Vector<const byte> function_bytes =
+  base::Vector<const uint8_t> function_bytes =
       wire_bytes.GetFunctionBytes(function);
   CompilationEnv env = native_module->CreateCompilationEnv();
   FunctionBody func_body{function->sig, 0, function_bytes.begin(),
diff --git a/src/wasm/baseline/x64/liftoff-assembler-x64.h b/src/wasm/baseline/x64/liftoff-assembler-x64.h
index d5106c0401..18d94fd8a6 100644
--- a/src/wasm/baseline/x64/liftoff-assembler-x64.h
+++ b/src/wasm/baseline/x64/liftoff-assembler-x64.h
@@ -2363,12 +2363,12 @@ void EmitSimdShiftOp(LiftoffAssembler* assm, LiftoffRegister dst,
   }
 }
 
-template <void (Assembler::*avx_op)(XMMRegister, XMMRegister, byte),
-          void (Assembler::*sse_op)(XMMRegister, byte), uint8_t width>
+template <void (Assembler::*avx_op)(XMMRegister, XMMRegister, uint8_t),
+          void (Assembler::*sse_op)(XMMRegister, uint8_t), uint8_t width>
 void EmitSimdShiftOpImm(LiftoffAssembler* assm, LiftoffRegister dst,
                         LiftoffRegister operand, int32_t count) {
   constexpr int mask = (1 << width) - 1;
-  byte shift = static_cast<byte>(count & mask);
+  uint8_t shift = static_cast<uint8_t>(count & mask);
   if (CpuFeatures::IsSupported(AVX)) {
     CpuFeatureScope scope(assm, AVX);
     (assm->*avx_op)(dst.fp(), operand.fp(), shift);
@@ -3855,7 +3855,7 @@ void LiftoffAssembler::emit_f32x4_uconvert_i32x4(LiftoffRegister dst,
     psubd(dst.fp(), kScratchDoubleReg);
   }
   Cvtdq2ps(kScratchDoubleReg, kScratchDoubleReg);  // Convert lo exactly.
-  Psrld(dst.fp(), byte{1});            // Divide by 2 to get in unsigned range.
+  Psrld(dst.fp(), uint8_t{1});         // Divide by 2 to get in unsigned range.
   Cvtdq2ps(dst.fp(), dst.fp());        // Convert hi, exactly.
   Addps(dst.fp(), dst.fp());           // Double hi, exactly.
   Addps(dst.fp(), kScratchDoubleReg);  // Add hi and lo, may round.
diff --git a/src/wasm/constant-expression-interface.cc b/src/wasm/constant-expression-interface.cc
index e75bbfbb46..ae04a41c4b 100644
--- a/src/wasm/constant-expression-interface.cc
+++ b/src/wasm/constant-expression-interface.cc
@@ -136,7 +136,7 @@ void ConstantExpressionInterface::GlobalGet(FullDecoder* decoder, Value* result,
   result->runtime_value =
       global.type.is_numeric()
           ? WasmValue(
-                reinterpret_cast<byte*>(
+                reinterpret_cast<uint8_t*>(
                     instance_->untagged_globals_buffer().backing_store()) +
                     global.offset,
                 global.type)
diff --git a/src/wasm/constant-expression.cc b/src/wasm/constant-expression.cc
index 0459d2240a..45229c3711 100644
--- a/src/wasm/constant-expression.cc
+++ b/src/wasm/constant-expression.cc
@@ -50,11 +50,11 @@ ValueOrError EvaluateConstantExpression(Zone* zone, ConstantExpression expr,
     case ConstantExpression::kWireBytesRef: {
       WireBytesRef ref = expr.wire_bytes_ref();
 
-      base::Vector<const byte> module_bytes =
+      base::Vector<const uint8_t> module_bytes =
           instance->module_object().native_module()->wire_bytes();
 
-      const byte* start = module_bytes.begin() + ref.offset();
-      const byte* end = module_bytes.begin() + ref.end_offset();
+      const uint8_t* start = module_bytes.begin() + ref.offset();
+      const uint8_t* end = module_bytes.begin() + ref.end_offset();
 
       auto sig = FixedSizeSignature<ValueType>::Returns(expected);
       FunctionBody body(&sig, ref.offset(), start, end);
diff --git a/src/wasm/decoder.h b/src/wasm/decoder.h
index d6454ac201..4e630eed49 100644
--- a/src/wasm/decoder.h
+++ b/src/wasm/decoder.h
@@ -58,7 +58,7 @@ class ITracer {
   virtual void StringOffset(uint32_t offset) = 0;
 
   // Hooks for annotated hex dumps.
-  virtual void Bytes(const byte* start, uint32_t count) = 0;
+  virtual void Bytes(const uint8_t* start, uint32_t count) = 0;
 
   virtual void Description(const char* desc) = 0;
   virtual void Description(const char* desc, size_t length) = 0;
@@ -71,11 +71,11 @@ class ITracer {
   virtual void NextLineIfFull() = 0;
   virtual void NextLineIfNonEmpty() = 0;
 
-  virtual void InitializerExpression(const byte* start, const byte* end,
+  virtual void InitializerExpression(const uint8_t* start, const uint8_t* end,
                                      ValueType expected_type) = 0;
-  virtual void FunctionBody(const WasmFunction* func, const byte* start) = 0;
+  virtual void FunctionBody(const WasmFunction* func, const uint8_t* start) = 0;
   virtual void FunctionName(uint32_t func_index) = 0;
-  virtual void NameSection(const byte* start, const byte* end,
+  virtual void NameSection(const uint8_t* start, const uint8_t* end,
                            uint32_t offset) = 0;
 
   virtual ~ITracer() = default;
@@ -118,12 +118,12 @@ class Decoder {
 
   enum TraceFlag : bool { kTrace = true, kNoTrace = false };
 
-  Decoder(const byte* start, const byte* end, uint32_t buffer_offset = 0)
+  Decoder(const uint8_t* start, const uint8_t* end, uint32_t buffer_offset = 0)
       : Decoder(start, start, end, buffer_offset) {}
-  explicit Decoder(const base::Vector<const byte> bytes,
+  explicit Decoder(const base::Vector<const uint8_t> bytes,
                    uint32_t buffer_offset = 0)
       : Decoder(bytes.begin(), bytes.begin() + bytes.length(), buffer_offset) {}
-  Decoder(const byte* start, const byte* pc, const byte* end,
+  Decoder(const uint8_t* start, const uint8_t* pc, const uint8_t* end,
           uint32_t buffer_offset = 0)
       : start_(start), pc_(pc), end_(end), buffer_offset_(buffer_offset) {
     DCHECK_LE(start, pc);
@@ -135,27 +135,28 @@ class Decoder {
 
   // Reads an 8-bit unsigned integer.
   template <typename ValidationTag>
-  uint8_t read_u8(const byte* pc, Name<ValidationTag> msg = "expected 1 byte") {
+  uint8_t read_u8(const uint8_t* pc,
+                  Name<ValidationTag> msg = "expected 1 byte") {
     return read_little_endian<uint8_t, ValidationTag>(pc, msg);
   }
 
   // Reads a 16-bit unsigned integer (little endian).
   template <typename ValidationTag>
-  uint16_t read_u16(const byte* pc,
+  uint16_t read_u16(const uint8_t* pc,
                     Name<ValidationTag> msg = "expected 2 bytes") {
     return read_little_endian<uint16_t, ValidationTag>(pc, msg);
   }
 
   // Reads a 32-bit unsigned integer (little endian).
   template <typename ValidationTag>
-  uint32_t read_u32(const byte* pc,
+  uint32_t read_u32(const uint8_t* pc,
                     Name<ValidationTag> msg = "expected 4 bytes") {
     return read_little_endian<uint32_t, ValidationTag>(pc, msg);
   }
 
   // Reads a 64-bit unsigned integer (little endian).
   template <typename ValidationTag>
-  uint64_t read_u64(const byte* pc,
+  uint64_t read_u64(const uint8_t* pc,
                     Name<ValidationTag> msg = "expected 8 bytes") {
     return read_little_endian<uint64_t, ValidationTag>(pc, msg);
   }
@@ -163,7 +164,7 @@ class Decoder {
   // Reads a variable-length unsigned integer (little endian). Returns the read
   // value and the number of bytes read.
   template <typename ValidationTag>
-  std::pair<uint32_t, uint32_t> read_u32v(const byte* pc,
+  std::pair<uint32_t, uint32_t> read_u32v(const uint8_t* pc,
                                           Name<ValidationTag> name = "LEB32") {
     return read_leb<uint32_t, ValidationTag, kNoTrace>(pc, name);
   }
@@ -172,14 +173,14 @@ class Decoder {
   // value and the number of bytes read.
   template <typename ValidationTag>
   std::pair<int32_t, uint32_t> read_i32v(
-      const byte* pc, Name<ValidationTag> name = "signed LEB32") {
+      const uint8_t* pc, Name<ValidationTag> name = "signed LEB32") {
     return read_leb<int32_t, ValidationTag, kNoTrace>(pc, name);
   }
 
   // Reads a variable-length unsigned integer (little endian). Returns the read
   // value and the number of bytes read.
   template <typename ValidationTag>
-  std::pair<uint64_t, uint32_t> read_u64v(const byte* pc,
+  std::pair<uint64_t, uint32_t> read_u64v(const uint8_t* pc,
                                           Name<ValidationTag> name = "LEB64") {
     return read_leb<uint64_t, ValidationTag, kNoTrace>(pc, name);
   }
@@ -188,7 +189,7 @@ class Decoder {
   // value and the number of bytes read.
   template <typename ValidationTag>
   std::pair<int64_t, uint32_t> read_i64v(
-      const byte* pc, Name<ValidationTag> name = "signed LEB64") {
+      const uint8_t* pc, Name<ValidationTag> name = "signed LEB64") {
     return read_leb<int64_t, ValidationTag, kNoTrace>(pc, name);
   }
 
@@ -196,7 +197,7 @@ class Decoder {
   // read value and the number of bytes read.
   template <typename ValidationTag>
   std::pair<int64_t, uint32_t> read_i33v(
-      const byte* pc, Name<ValidationTag> name = "signed LEB33") {
+      const uint8_t* pc, Name<ValidationTag> name = "signed LEB33") {
     return read_leb<int64_t, ValidationTag, kNoTrace, 33>(pc, name);
   }
 
@@ -205,7 +206,7 @@ class Decoder {
   // *including* the prefix byte. For most opcodes, it will be 2.
   template <typename ValidationTag>
   std::pair<WasmOpcode, uint32_t> read_prefixed_opcode(
-      const byte* pc, Name<ValidationTag> name = "prefixed opcode") {
+      const uint8_t* pc, Name<ValidationTag> name = "prefixed opcode") {
     // Prefixed opcodes all use LEB128 encoding.
     auto [index, index_length] =
         read_u32v<ValidationTag>(pc + 1, "prefixed opcode index");
@@ -375,9 +376,9 @@ class Decoder {
   virtual void onFirstError() {}
 
   // Debugging helper to print a bytes range as hex bytes.
-  void traceByteRange(const byte* start, const byte* end) {
+  void traceByteRange(const uint8_t* start, const uint8_t* end) {
     DCHECK_LE(start, end);
-    for (const byte* p = start; p < end; ++p) TRACE("%02x ", *p);
+    for (const uint8_t* p = start; p < end; ++p) TRACE("%02x ", *p);
   }
 
   // Debugging helper to print bytes up to the end.
@@ -397,7 +398,8 @@ class Decoder {
   }
 
   // Resets the boundaries of this decoder.
-  void Reset(const byte* start, const byte* end, uint32_t buffer_offset = 0) {
+  void Reset(const uint8_t* start, const uint8_t* end,
+             uint32_t buffer_offset = 0) {
     DCHECK_LE(start, end);
     DCHECK_EQ(static_cast<uint32_t>(end - start), end - start);
     start_ = start;
@@ -416,8 +418,8 @@ class Decoder {
   bool more() const { return pc_ < end_; }
   const WasmError& error() const { return error_; }
 
-  const byte* start() const { return start_; }
-  const byte* pc() const { return pc_; }
+  const uint8_t* start() const { return start_; }
+  const uint8_t* pc() const { return pc_; }
   uint32_t V8_INLINE position() const {
     return static_cast<uint32_t>(pc_ - start_);
   }
@@ -435,19 +437,19 @@ class Decoder {
     DCHECK_LE(buffer_offset_, offset);
     return offset - buffer_offset_;
   }
-  const byte* end() const { return end_; }
-  void set_end(const byte* end) { end_ = end; }
+  const uint8_t* end() const { return end_; }
+  void set_end(const uint8_t* end) { end_ = end; }
 
-  // Check if the byte at {offset} from the current pc equals {expected}.
-  bool lookahead(int offset, byte expected) {
+  // Check if the uint8_t at {offset} from the current pc equals {expected}.
+  bool lookahead(int offset, uint8_t expected) {
     DCHECK_LE(pc_, end_);
     return end_ - pc_ > offset && pc_[offset] == expected;
   }
 
  protected:
-  const byte* start_;
-  const byte* pc_;
-  const byte* end_;
+  const uint8_t* start_;
+  const uint8_t* pc_;
+  const uint8_t* end_;
   // The offset of the current buffer in the module. Needed for streaming.
   uint32_t buffer_offset_;
   WasmError error_;
@@ -469,7 +471,7 @@ class Decoder {
   }
 
   template <typename IntType, typename ValidationTag>
-  IntType read_little_endian(const byte* pc, Name<ValidationTag> msg) {
+  IntType read_little_endian(const uint8_t* pc, Name<ValidationTag> msg) {
     DCHECK_LE(start_, pc);
 
     if (!ValidationTag::validate) {
@@ -506,7 +508,7 @@ class Decoder {
   template <typename IntType, typename ValidationTag, TraceFlag trace,
             size_t size_in_bits = 8 * sizeof(IntType)>
   V8_INLINE std::pair<IntType, uint32_t> read_leb(
-      const byte* pc, Name<ValidationTag> name = "varint") {
+      const uint8_t* pc, Name<ValidationTag> name = "varint") {
     static_assert(size_in_bits <= 8 * sizeof(IntType),
                   "leb does not fit in type");
     TRACE_IF(trace, "  +%u  %-20s: ", pc_offset(),
@@ -536,7 +538,7 @@ class Decoder {
   template <typename IntType, typename ValidationTag, TraceFlag trace,
             size_t size_in_bits = 8 * sizeof(IntType)>
   V8_NOINLINE V8_PRESERVE_MOST std::pair<IntType, uint32_t> read_leb_slowpath(
-      const byte* pc, Name<ValidationTag> name) {
+      const uint8_t* pc, Name<ValidationTag> name) {
     // Create an unrolled LEB decoding function per integer type.
     return read_leb_tail<IntType, ValidationTag, trace, size_in_bits, 0>(
         pc, name, 0);
@@ -545,14 +547,15 @@ class Decoder {
   template <typename IntType, typename ValidationTag, TraceFlag trace,
             size_t size_in_bits, int byte_index>
   V8_INLINE std::pair<IntType, uint32_t> read_leb_tail(
-      const byte* pc, Name<ValidationTag> name, IntType intermediate_result) {
+      const uint8_t* pc, Name<ValidationTag> name,
+      IntType intermediate_result) {
     constexpr bool is_signed = std::is_signed<IntType>::value;
     constexpr int kMaxLength = (size_in_bits + 6) / 7;
     static_assert(byte_index < kMaxLength, "invalid template instantiation");
     constexpr int shift = byte_index * 7;
     constexpr bool is_last_byte = byte_index == kMaxLength - 1;
     const bool at_end = ValidationTag::validate && pc >= end_;
-    byte b = 0;
+    uint8_t b = 0;
     if (V8_LIKELY(!at_end)) {
       DCHECK_LT(pc, end_);
       b = *pc;
@@ -588,8 +591,8 @@ class Decoder {
       // either be 0, or all ones.
       constexpr int kExtraBits = size_in_bits - ((kMaxLength - 1) * 7);
       constexpr int kSignExtBits = kExtraBits - (is_signed ? 1 : 0);
-      const byte checked_bits = b & (0xFF << kSignExtBits);
-      constexpr byte kSignExtendedExtraBits = 0x7f & (0xFF << kSignExtBits);
+      const uint8_t checked_bits = b & (0xFF << kSignExtBits);
+      constexpr uint8_t kSignExtendedExtraBits = 0x7f & (0xFF << kSignExtBits);
       const bool valid_extra_bits =
           checked_bits == 0 ||
           (is_signed && checked_bits == kSignExtendedExtraBits);
diff --git a/src/wasm/function-body-decoder-impl.h b/src/wasm/function-body-decoder-impl.h
index d3c3a5c75d..3b1bd1896b 100644
--- a/src/wasm/function-body-decoder-impl.h
+++ b/src/wasm/function-body-decoder-impl.h
@@ -180,7 +180,7 @@ static constexpr StoreType GetStoreType(WasmOpcode opcode) {
 // Depending on the validation tag and the number of arguments, this forwards to
 // a V8_NOINLINE and V8_PRESERVE_MOST method of the decoder.
 template <typename ValidationTag, typename... Args>
-V8_INLINE void DecodeError(Decoder* decoder, const byte* pc, const char* str,
+V8_INLINE void DecodeError(Decoder* decoder, const uint8_t* pc, const char* str,
                            Args&&... args) {
   // Decode errors can only happen if we are validating; the compiler should
   // know this e.g. from the VALIDATE macro, but this assumption tells it again
@@ -216,7 +216,8 @@ V8_INLINE void DecodeError(Decoder* decoder, const char* str, Args&&... args) {
 namespace value_type_reader {
 
 template <typename ValidationTag>
-std::pair<HeapType, uint32_t> read_heap_type(Decoder* decoder, const byte* pc,
+std::pair<HeapType, uint32_t> read_heap_type(Decoder* decoder,
+                                             const uint8_t* pc,
                                              const WasmFeatures& enabled) {
   auto [heap_index, length] =
       decoder->read_i33v<ValidationTag>(pc, "heap type");
@@ -287,9 +288,10 @@ std::pair<HeapType, uint32_t> read_heap_type(Decoder* decoder, const byte* pc,
 // No bytes are consumed.
 // Returns the read value type and the number of bytes read (a.k.a. length).
 template <typename ValidationTag>
-std::pair<ValueType, uint32_t> read_value_type(Decoder* decoder, const byte* pc,
+std::pair<ValueType, uint32_t> read_value_type(Decoder* decoder,
+                                               const uint8_t* pc,
                                                const WasmFeatures& enabled) {
-  byte val = decoder->read_u8<ValidationTag>(pc, "value type opcode");
+  uint8_t val = decoder->read_u8<ValidationTag>(pc, "value type opcode");
   if (!VALIDATE(decoder->ok())) {
     return {kWasmBottom, 0};
   }
@@ -376,7 +378,7 @@ std::pair<ValueType, uint32_t> read_value_type(Decoder* decoder, const byte* pc,
 }
 
 template <typename ValidationTag>
-bool ValidateHeapType(Decoder* decoder, const byte* pc,
+bool ValidateHeapType(Decoder* decoder, const uint8_t* pc,
                       const WasmModule* module, HeapType type) {
   if (!type.is_index()) return true;
   // A {nullptr} module is accepted if we are not validating anyway (e.g. for
@@ -391,7 +393,7 @@ bool ValidateHeapType(Decoder* decoder, const byte* pc,
 }
 
 template <typename ValidationTag>
-bool ValidateValueType(Decoder* decoder, const byte* pc,
+bool ValidateValueType(Decoder* decoder, const uint8_t* pc,
                        const WasmModule* module, ValueType type) {
   if (V8_LIKELY(!type.is_object_reference())) return true;
   return ValidateHeapType<ValidationTag>(decoder, pc, module, type.heap_type());
@@ -407,7 +409,7 @@ struct ImmI32Immediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  ImmI32Immediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  ImmI32Immediate(Decoder* decoder, const uint8_t* pc, ValidationTag = {}) {
     std::tie(value, length) = decoder->read_i32v<ValidationTag>(pc, "immi32");
   }
 };
@@ -417,7 +419,7 @@ struct ImmI64Immediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  ImmI64Immediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  ImmI64Immediate(Decoder* decoder, const uint8_t* pc, ValidationTag = {}) {
     std::tie(value, length) = decoder->read_i64v<ValidationTag>(pc, "immi64");
   }
 };
@@ -427,7 +429,7 @@ struct ImmF32Immediate {
   uint32_t length = 4;
 
   template <typename ValidationTag>
-  ImmF32Immediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  ImmF32Immediate(Decoder* decoder, const uint8_t* pc, ValidationTag = {}) {
     // We can't use base::bit_cast here because calling any helper function
     // that returns a float would potentially flip NaN bits per C++ semantics,
     // so we have to inline the memcpy call directly.
@@ -441,7 +443,7 @@ struct ImmF64Immediate {
   uint32_t length = 8;
 
   template <typename ValidationTag>
-  ImmF64Immediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  ImmF64Immediate(Decoder* decoder, const uint8_t* pc, ValidationTag = {}) {
     // Avoid base::bit_cast because it might not preserve the signalling bit
     // of a NaN.
     uint64_t tmp = decoder->read_u64<ValidationTag>(pc, "immf64");
@@ -454,7 +456,8 @@ struct MemoryIndexImmediate {
   uint32_t length = 1;
 
   template <typename ValidationTag>
-  MemoryIndexImmediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  MemoryIndexImmediate(Decoder* decoder, const uint8_t* pc,
+                       ValidationTag = {}) {
     index = decoder->read_u8<ValidationTag>(pc, "memory index");
   }
 };
@@ -482,7 +485,7 @@ struct BrOnCastImmediate {
   uint32_t length = 1;
 
   template <typename ValidationTag>
-  BrOnCastImmediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  BrOnCastImmediate(Decoder* decoder, const uint8_t* pc, ValidationTag = {}) {
     raw_value = decoder->read_u8<ValidationTag>(pc, "br_on_cast flags");
     if (raw_value > (BrOnCastFlags::SRC_IS_NULL | BrOnCastFlags::RES_IS_NULL)) {
       if constexpr (ValidationTag::full_validation) {
@@ -503,7 +506,7 @@ struct IndexImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  IndexImmediate(Decoder* decoder, const byte* pc, const char* name,
+  IndexImmediate(Decoder* decoder, const uint8_t* pc, const char* name,
                  ValidationTag = {}) {
     std::tie(index, length) = decoder->read_u32v<ValidationTag>(pc, name);
   }
@@ -513,7 +516,7 @@ struct TagIndexImmediate : public IndexImmediate {
   const WasmTag* tag = nullptr;
 
   template <typename ValidationTag>
-  TagIndexImmediate(Decoder* decoder, const byte* pc,
+  TagIndexImmediate(Decoder* decoder, const uint8_t* pc,
                     ValidationTag validate = {})
       : IndexImmediate(decoder, pc, "tag index", validate) {}
 };
@@ -522,7 +525,7 @@ struct GlobalIndexImmediate : public IndexImmediate {
   const WasmGlobal* global = nullptr;
 
   template <typename ValidationTag>
-  GlobalIndexImmediate(Decoder* decoder, const byte* pc,
+  GlobalIndexImmediate(Decoder* decoder, const uint8_t* pc,
                        ValidationTag validate = {})
       : IndexImmediate(decoder, pc, "global index", validate) {}
 };
@@ -531,7 +534,7 @@ struct SigIndexImmediate : public IndexImmediate {
   const FunctionSig* sig = nullptr;
 
   template <typename ValidationTag>
-  SigIndexImmediate(Decoder* decoder, const byte* pc,
+  SigIndexImmediate(Decoder* decoder, const uint8_t* pc,
                     ValidationTag validate = {})
       : IndexImmediate(decoder, pc, "signature index", validate) {}
 };
@@ -540,7 +543,7 @@ struct StructIndexImmediate : public IndexImmediate {
   const StructType* struct_type = nullptr;
 
   template <typename ValidationTag>
-  StructIndexImmediate(Decoder* decoder, const byte* pc,
+  StructIndexImmediate(Decoder* decoder, const uint8_t* pc,
                        ValidationTag validate = {})
       : IndexImmediate(decoder, pc, "struct index", validate) {}
 };
@@ -549,7 +552,7 @@ struct ArrayIndexImmediate : public IndexImmediate {
   const ArrayType* array_type = nullptr;
 
   template <typename ValidationTag>
-  ArrayIndexImmediate(Decoder* decoder, const byte* pc,
+  ArrayIndexImmediate(Decoder* decoder, const uint8_t* pc,
                       ValidationTag validate = {})
       : IndexImmediate(decoder, pc, "array index", validate) {}
 };
@@ -558,7 +561,7 @@ struct CallFunctionImmediate : public IndexImmediate {
   const FunctionSig* sig = nullptr;
 
   template <typename ValidationTag>
-  CallFunctionImmediate(Decoder* decoder, const byte* pc,
+  CallFunctionImmediate(Decoder* decoder, const uint8_t* pc,
                         ValidationTag validate = {})
       : IndexImmediate(decoder, pc, "function index", validate) {}
 };
@@ -569,7 +572,7 @@ struct SelectTypeImmediate {
 
   template <typename ValidationTag>
   SelectTypeImmediate(const WasmFeatures& enabled, Decoder* decoder,
-                      const byte* pc, ValidationTag = {}) {
+                      const uint8_t* pc, ValidationTag = {}) {
     uint8_t num_types;
     std::tie(num_types, length) =
         decoder->read_u32v<ValidationTag>(pc, "number of select types");
@@ -645,7 +648,8 @@ struct BranchDepthImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  BranchDepthImmediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  BranchDepthImmediate(Decoder* decoder, const uint8_t* pc,
+                       ValidationTag = {}) {
     std::tie(depth, length) =
         decoder->read_u32v<ValidationTag>(pc, "branch depth");
   }
@@ -657,7 +661,8 @@ struct FieldImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  FieldImmediate(Decoder* decoder, const byte* pc, ValidationTag validate = {})
+  FieldImmediate(Decoder* decoder, const uint8_t* pc,
+                 ValidationTag validate = {})
       : struct_imm(decoder, pc, validate),
         field_imm(decoder, pc + struct_imm.length, "field index", validate),
         length(struct_imm.length + field_imm.length) {}
@@ -670,7 +675,7 @@ struct CallIndirectImmediate {
   const FunctionSig* sig = nullptr;
 
   template <typename ValidationTag>
-  CallIndirectImmediate(Decoder* decoder, const byte* pc,
+  CallIndirectImmediate(Decoder* decoder, const uint8_t* pc,
                         ValidationTag validate = {})
       : sig_imm(decoder, pc, "singature index", validate),
         table_imm(decoder, pc + sig_imm.length, "table index", validate),
@@ -679,11 +684,12 @@ struct CallIndirectImmediate {
 
 struct BranchTableImmediate {
   uint32_t table_count;
-  const byte* start;
-  const byte* table;
+  const uint8_t* start;
+  const uint8_t* table;
 
   template <typename ValidationTag>
-  BranchTableImmediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  BranchTableImmediate(Decoder* decoder, const uint8_t* pc,
+                       ValidationTag = {}) {
     start = pc;
     uint32_t len;
     std::tie(table_count, len) =
@@ -712,7 +718,7 @@ class BranchTableIterator {
     while (has_next()) next();
     return static_cast<uint32_t>(pc_ - start_);
   }
-  const byte* pc() { return pc_; }
+  const uint8_t* pc() { return pc_; }
 
   BranchTableIterator(Decoder* decoder, const BranchTableImmediate& imm)
       : decoder_(decoder),
@@ -722,8 +728,8 @@ class BranchTableIterator {
 
  private:
   Decoder* const decoder_;
-  const byte* start_;
-  const byte* pc_;
+  const uint8_t* start_;
+  const uint8_t* pc_;
   uint32_t index_ = 0;          // the current index.
   const uint32_t table_count_;  // the count of entries, not including default.
 };
@@ -734,7 +740,7 @@ struct MemoryAccessImmediate {
   uint32_t length = 0;
 
   template <typename ValidationTag>
-  V8_INLINE MemoryAccessImmediate(Decoder* decoder, const byte* pc,
+  V8_INLINE MemoryAccessImmediate(Decoder* decoder, const uint8_t* pc,
                                   uint32_t max_alignment, bool is_memory64,
                                   ValidationTag = {}) {
     // Check for the fast path (two single-byte LEBs).
@@ -759,7 +765,7 @@ struct MemoryAccessImmediate {
  private:
   template <typename ValidationTag>
   V8_NOINLINE V8_PRESERVE_MOST void ConstructSlow(Decoder* decoder,
-                                                  const byte* pc,
+                                                  const uint8_t* pc,
                                                   uint32_t max_alignment,
                                                   bool is_memory64) {
     uint32_t alignment_length;
@@ -783,7 +789,7 @@ struct SimdLaneImmediate {
   uint32_t length = 1;
 
   template <typename ValidationTag>
-  SimdLaneImmediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  SimdLaneImmediate(Decoder* decoder, const uint8_t* pc, ValidationTag = {}) {
     lane = decoder->read_u8<ValidationTag>(pc, "lane");
   }
 };
@@ -793,7 +799,7 @@ struct Simd128Immediate {
   uint8_t value[kSimd128Size] = {0};
 
   template <typename ValidationTag>
-  Simd128Immediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  Simd128Immediate(Decoder* decoder, const uint8_t* pc, ValidationTag = {}) {
     for (uint32_t i = 0; i < kSimd128Size; ++i) {
       value[i] = decoder->read_u8<ValidationTag>(pc + i, "value");
     }
@@ -806,7 +812,7 @@ struct MemoryInitImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  MemoryInitImmediate(Decoder* decoder, const byte* pc,
+  MemoryInitImmediate(Decoder* decoder, const uint8_t* pc,
                       ValidationTag validate = {})
       : data_segment(decoder, pc, "data segment index", validate),
         memory(decoder, pc + data_segment.length, validate),
@@ -819,7 +825,7 @@ struct MemoryCopyImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  MemoryCopyImmediate(Decoder* decoder, const byte* pc,
+  MemoryCopyImmediate(Decoder* decoder, const uint8_t* pc,
                       ValidationTag validate = {})
       : memory_src(decoder, pc, validate),
         memory_dst(decoder, pc + memory_src.length, validate),
@@ -832,7 +838,7 @@ struct TableInitImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  TableInitImmediate(Decoder* decoder, const byte* pc,
+  TableInitImmediate(Decoder* decoder, const uint8_t* pc,
                      ValidationTag validate = {})
       : element_segment(decoder, pc, "element segment index", validate),
         table(decoder, pc + element_segment.length, "table index", validate),
@@ -845,7 +851,7 @@ struct TableCopyImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  TableCopyImmediate(Decoder* decoder, const byte* pc,
+  TableCopyImmediate(Decoder* decoder, const uint8_t* pc,
                      ValidationTag validate = {})
       : table_dst(decoder, pc, "table index", validate),
         table_src(decoder, pc + table_dst.length, "table index", validate),
@@ -858,7 +864,7 @@ struct HeapTypeImmediate {
 
   template <typename ValidationTag>
   HeapTypeImmediate(const WasmFeatures& enabled, Decoder* decoder,
-                    const byte* pc, ValidationTag = {}) {
+                    const uint8_t* pc, ValidationTag = {}) {
     std::tie(type, length) =
         value_type_reader::read_heap_type<ValidationTag>(decoder, pc, enabled);
   }
@@ -869,7 +875,8 @@ struct StringConstImmediate {
   uint32_t length;
 
   template <typename ValidationTag>
-  StringConstImmediate(Decoder* decoder, const byte* pc, ValidationTag = {}) {
+  StringConstImmediate(Decoder* decoder, const uint8_t* pc,
+                       ValidationTag = {}) {
     std::tie(index, length) =
         decoder->read_u32v<ValidationTag>(pc, "stringref literal index");
   }
@@ -878,18 +885,18 @@ struct StringConstImmediate {
 template <bool full_validation>
 struct PcForErrors {
   static_assert(full_validation == false);
-  explicit PcForErrors(const byte* /* pc */) {}
+  explicit PcForErrors(const uint8_t* /* pc */) {}
 
-  const byte* pc() const { return nullptr; }
+  const uint8_t* pc() const { return nullptr; }
 };
 
 template <>
 struct PcForErrors<true> {
-  const byte* pc_for_errors = nullptr;
+  const uint8_t* pc_for_errors = nullptr;
 
-  explicit PcForErrors(const byte* pc) : pc_for_errors(pc) {}
+  explicit PcForErrors(const uint8_t* pc) : pc_for_errors(pc) {}
 
-  const byte* pc() const { return pc_for_errors; }
+  const uint8_t* pc() const { return pc_for_errors; }
 };
 
 // An entry on the value stack.
@@ -897,7 +904,7 @@ template <typename ValidationTag>
 struct ValueBase : public PcForErrors<ValidationTag::full_validation> {
   ValueType type = kWasmVoid;
 
-  ValueBase(const byte* pc, ValueType type)
+  ValueBase(const uint8_t* pc, ValueType type)
       : PcForErrors<ValidationTag::full_validation>(pc), type(type) {}
 };
 
@@ -1359,8 +1366,9 @@ class WasmDecoder : public Decoder {
 
  public:
   WasmDecoder(Zone* zone, const WasmModule* module, WasmFeatures enabled,
-              WasmFeatures* detected, const FunctionSig* sig, const byte* start,
-              const byte* end, uint32_t buffer_offset = 0)
+              WasmFeatures* detected, const FunctionSig* sig,
+              const uint8_t* start, const uint8_t* end,
+              uint32_t buffer_offset = 0)
       : Decoder(start, end, buffer_offset),
         zone_(zone),
         module_(module),
@@ -1396,7 +1404,7 @@ class WasmDecoder : public Decoder {
   // The decoded locals will be appended to {this->local_types_}.
   // The decoder's pc is not advanced.
   // The total length of decoded locals is returned.
-  uint32_t DecodeLocals(const byte* pc) {
+  uint32_t DecodeLocals(const uint8_t* pc) {
     DCHECK_NULL(local_types_);
     DCHECK_EQ(0, num_locals_);
 
@@ -1491,7 +1499,8 @@ class WasmDecoder : public Decoder {
   // variables that are assigned in the loop starting at {pc}. The additional
   // position at the end of the vector represents possible assignments to
   // the instance cache.
-  static BitVector* AnalyzeLoopAssignment(WasmDecoder* decoder, const byte* pc,
+  static BitVector* AnalyzeLoopAssignment(WasmDecoder* decoder,
+                                          const uint8_t* pc,
                                           uint32_t locals_count, Zone* zone,
                                           bool* loop_is_innermost = nullptr) {
     if (pc >= decoder->end()) return nullptr;
@@ -1540,7 +1549,7 @@ class WasmDecoder : public Decoder {
     return VALIDATE(decoder->ok()) ? assigned : nullptr;
   }
 
-  bool Validate(const byte* pc, TagIndexImmediate& imm) {
+  bool Validate(const uint8_t* pc, TagIndexImmediate& imm) {
     size_t num_tags = module_->tags.size();
     if (!VALIDATE(imm.index < num_tags)) {
       DecodeError(pc, "Invalid tag index: %u", imm.index);
@@ -1551,7 +1560,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, GlobalIndexImmediate& imm) {
+  bool Validate(const uint8_t* pc, GlobalIndexImmediate& imm) {
     // We compare with the current size of the globals vector. This is important
     // if we are decoding a constant expression in the global section.
     size_t num_globals = module_->globals.size();
@@ -1579,7 +1588,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, SigIndexImmediate& imm) {
+  bool Validate(const uint8_t* pc, SigIndexImmediate& imm) {
     if (!VALIDATE(module_->has_signature(imm.index))) {
       DecodeError(pc, "invalid signature index: %u", imm.index);
       return false;
@@ -1588,7 +1597,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, StructIndexImmediate& imm) {
+  bool Validate(const uint8_t* pc, StructIndexImmediate& imm) {
     if (!VALIDATE(module_->has_struct(imm.index))) {
       DecodeError(pc, "invalid struct index: %u", imm.index);
       return false;
@@ -1597,7 +1606,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, FieldImmediate& imm) {
+  bool Validate(const uint8_t* pc, FieldImmediate& imm) {
     if (!Validate(pc, imm.struct_imm)) return false;
     if (!VALIDATE(imm.field_imm.index <
                   imm.struct_imm.struct_type->field_count())) {
@@ -1608,7 +1617,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, ArrayIndexImmediate& imm) {
+  bool Validate(const uint8_t* pc, ArrayIndexImmediate& imm) {
     if (!VALIDATE(module_->has_array(imm.index))) {
       DecodeError(pc, "invalid array index: %u", imm.index);
       return false;
@@ -1626,7 +1635,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, CallFunctionImmediate& imm) {
+  bool Validate(const uint8_t* pc, CallFunctionImmediate& imm) {
     size_t num_functions = module_->functions.size();
     if (!VALIDATE(imm.index < num_functions)) {
       DecodeError(pc, "function index #%u is out of bounds", imm.index);
@@ -1637,7 +1646,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, CallIndirectImmediate& imm) {
+  bool Validate(const uint8_t* pc, CallIndirectImmediate& imm) {
     if (!ValidateSignature(pc, imm.sig_imm)) return false;
     if (!ValidateTable(pc + imm.sig_imm.length, imm.table_imm)) {
       return false;
@@ -1665,7 +1674,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, BranchDepthImmediate& imm,
+  bool Validate(const uint8_t* pc, BranchDepthImmediate& imm,
                 size_t control_depth) {
     if (!VALIDATE(imm.depth < control_depth)) {
       DecodeError(pc, "invalid branch depth: %u", imm.depth);
@@ -1674,7 +1683,8 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, BranchTableImmediate& imm, size_t block_depth) {
+  bool Validate(const uint8_t* pc, BranchTableImmediate& imm,
+                size_t block_depth) {
     if (!VALIDATE(imm.table_count <= kV8MaxWasmFunctionBrTableSize)) {
       DecodeError(pc, "invalid table count (> max br_table size): %u",
                   imm.table_count);
@@ -1683,7 +1693,7 @@ class WasmDecoder : public Decoder {
     return checkAvailable(imm.table_count);
   }
 
-  bool Validate(const byte* pc, WasmOpcode opcode, SimdLaneImmediate& imm) {
+  bool Validate(const uint8_t* pc, WasmOpcode opcode, SimdLaneImmediate& imm) {
     uint8_t num_lanes = 0;
     switch (opcode) {
       case kExprF64x2ExtractLane:
@@ -1728,7 +1738,7 @@ class WasmDecoder : public Decoder {
     }
   }
 
-  bool Validate(const byte* pc, Simd128Immediate& imm) {
+  bool Validate(const uint8_t* pc, Simd128Immediate& imm) {
     uint8_t max_lane = 0;
     for (uint32_t i = 0; i < kSimd128Size; ++i) {
       max_lane = std::max(max_lane, imm.value[i]);
@@ -1741,7 +1751,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, BlockTypeImmediate& imm) {
+  bool Validate(const uint8_t* pc, BlockTypeImmediate& imm) {
     if (imm.sig.all().begin() == nullptr) {
       // Then use {sig_index} to initialize the signature.
       if (!VALIDATE(module_->has_signature(imm.sig_index))) {
@@ -1761,7 +1771,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, MemoryIndexImmediate& imm) {
+  bool Validate(const uint8_t* pc, MemoryIndexImmediate& imm) {
     if (!VALIDATE(this->module_->has_memory)) {
       this->DecodeError(pc, "memory instruction with no memory");
       return false;
@@ -1773,7 +1783,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, MemoryAccessImmediate& imm) {
+  bool Validate(const uint8_t* pc, MemoryAccessImmediate& imm) {
     if (!VALIDATE(this->module_->has_memory)) {
       this->DecodeError(pc, "memory instruction with no memory");
       return false;
@@ -1781,17 +1791,17 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, MemoryInitImmediate& imm) {
+  bool Validate(const uint8_t* pc, MemoryInitImmediate& imm) {
     return ValidateDataSegment(pc, imm.data_segment) &&
            Validate(pc + imm.data_segment.length, imm.memory);
   }
 
-  bool Validate(const byte* pc, MemoryCopyImmediate& imm) {
+  bool Validate(const uint8_t* pc, MemoryCopyImmediate& imm) {
     return Validate(pc, imm.memory_src) &&
            Validate(pc + imm.memory_src.length, imm.memory_dst);
   }
 
-  bool Validate(const byte* pc, TableInitImmediate& imm) {
+  bool Validate(const uint8_t* pc, TableInitImmediate& imm) {
     if (!ValidateElementSegment(pc, imm.element_segment)) return false;
     if (!ValidateTable(pc + imm.element_segment.length, imm.table)) {
       return false;
@@ -1807,7 +1817,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, TableCopyImmediate& imm) {
+  bool Validate(const uint8_t* pc, TableCopyImmediate& imm) {
     if (!ValidateTable(pc, imm.table_src)) return false;
     if (!ValidateTable(pc + imm.table_src.length, imm.table_dst)) return false;
     size_t num_tables = module_->tables.size();
@@ -1823,7 +1833,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, StringConstImmediate& imm) {
+  bool Validate(const uint8_t* pc, StringConstImmediate& imm) {
     if (!VALIDATE(imm.index < module_->stringref_literals.size())) {
       DecodeError(pc, "Invalid string literal index: %u", imm.index);
       return false;
@@ -1833,7 +1843,7 @@ class WasmDecoder : public Decoder {
 
   // The following Validate* functions all validate an IndexImmediate, albeit
   // differently according to context.
-  bool ValidateTable(const byte* pc, IndexImmediate& imm) {
+  bool ValidateTable(const uint8_t* pc, IndexImmediate& imm) {
     if (imm.index > 0 || imm.length > 1) {
       this->detected_->Add(kFeature_reftypes);
     }
@@ -1846,7 +1856,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool ValidateElementSegment(const byte* pc, IndexImmediate& imm) {
+  bool ValidateElementSegment(const uint8_t* pc, IndexImmediate& imm) {
     size_t num_elem_segments = module_->elem_segments.size();
     if (!VALIDATE(imm.index < num_elem_segments)) {
       DecodeError(pc, "invalid element segment index: %u", imm.index);
@@ -1856,7 +1866,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool ValidateLocal(const byte* pc, IndexImmediate& imm) {
+  bool ValidateLocal(const uint8_t* pc, IndexImmediate& imm) {
     if (!VALIDATE(imm.index < num_locals())) {
       DecodeError(pc, "invalid local index: %u", imm.index);
       return false;
@@ -1864,7 +1874,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool ValidateType(const byte* pc, IndexImmediate& imm) {
+  bool ValidateType(const uint8_t* pc, IndexImmediate& imm) {
     if (!VALIDATE(module_->has_type(imm.index))) {
       DecodeError(pc, "invalid type index: %u", imm.index);
       return false;
@@ -1872,7 +1882,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool ValidateSignature(const byte* pc, IndexImmediate& imm) {
+  bool ValidateSignature(const uint8_t* pc, IndexImmediate& imm) {
     if (!VALIDATE(module_->has_signature(imm.index))) {
       DecodeError(pc, "invalid signature index: %u", imm.index);
       return false;
@@ -1880,7 +1890,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool ValidateFunction(const byte* pc, IndexImmediate& imm) {
+  bool ValidateFunction(const uint8_t* pc, IndexImmediate& imm) {
     size_t num_functions = module_->functions.size();
     if (!VALIDATE(imm.index < num_functions)) {
       DecodeError(pc, "function index #%u is out of bounds", imm.index);
@@ -1895,7 +1905,7 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool ValidateDataSegment(const byte* pc, IndexImmediate& imm) {
+  bool ValidateDataSegment(const uint8_t* pc, IndexImmediate& imm) {
     if (!VALIDATE(imm.index < module_->num_declared_data_segments)) {
       DecodeError(pc, "invalid data segment index: %u", imm.index);
       return false;
@@ -1903,27 +1913,27 @@ class WasmDecoder : public Decoder {
     return true;
   }
 
-  bool Validate(const byte* pc, SelectTypeImmediate& imm) {
+  bool Validate(const uint8_t* pc, SelectTypeImmediate& imm) {
     return ValidateValueType(pc, imm.type);
   }
 
-  bool Validate(const byte* pc, HeapTypeImmediate& imm) {
+  bool Validate(const uint8_t* pc, HeapTypeImmediate& imm) {
     return ValidateHeapType(pc, imm.type);
   }
 
-  bool ValidateValueType(const byte* pc, ValueType type) {
+  bool ValidateValueType(const uint8_t* pc, ValueType type) {
     return value_type_reader::ValidateValueType<ValidationTag>(this, pc,
                                                                module_, type);
   }
 
-  bool ValidateHeapType(const byte* pc, HeapType type) {
+  bool ValidateHeapType(const uint8_t* pc, HeapType type) {
     return value_type_reader::ValidateHeapType<ValidationTag>(this, pc, module_,
                                                               type);
   }
 
   // Returns the length of the opcode under {pc}.
   template <typename... ImmediateObservers>
-  static uint32_t OpcodeLength(WasmDecoder* decoder, const byte* pc,
+  static uint32_t OpcodeLength(WasmDecoder* decoder, const uint8_t* pc,
                                ImmediateObservers&... ios) {
     WasmOpcode opcode = static_cast<WasmOpcode>(*pc);
     // We don't have information about the module here, so we just assume that
@@ -2560,7 +2570,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
     }
   }
 
-  const char* SafeOpcodeNameAt(const byte* pc) {
+  const char* SafeOpcodeNameAt(const uint8_t* pc) {
     if (!pc) return "<null>";
     if (pc >= this->end_) return "<end>";
     WasmOpcode opcode = static_cast<WasmOpcode>(*pc);
@@ -3335,7 +3345,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
 
     while (iterator.has_next()) {
       const uint32_t index = iterator.cur_index();
-      const byte* pos = iterator.pc();
+      const uint8_t* pos = iterator.pc();
       const uint32_t target = iterator.next();
       if (!VALIDATE(target < control_depth())) {
         this->DecodeError(pos, "invalid branch depth: %u", target);
@@ -3906,7 +3916,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
   // Initializes start- and end-merges of {c} with values according to the
   // in- and out-types of {c} respectively.
   void SetBlockType(Control* c, BlockTypeImmediate& imm, Value* args) {
-    const byte* pc = this->pc_;
+    const uint8_t* pc = this->pc_;
     InitMerge(&c->end_merge, imm.out_arity(), [pc, &imm](uint32_t i) {
       return Value{pc, imm.out_type(i)};
     });
@@ -4550,7 +4560,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
           UNIMPLEMENTED();
         }
 #endif
-        const byte* data_index_pc =
+        const uint8_t* data_index_pc =
             this->pc_ + opcode_length + array_imm.length;
         IndexImmediate data_segment(this, data_index_pc, "data segment",
                                     validate);
@@ -4585,7 +4595,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
               array_imm.index);
           return 0;
         }
-        const byte* elem_index_pc =
+        const uint8_t* elem_index_pc =
             this->pc_ + opcode_length + array_imm.length;
         IndexImmediate elem_segment(this, elem_index_pc, "element segment",
                                     validate);
@@ -4647,7 +4657,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
           UNIMPLEMENTED();
         }
 #endif
-        const byte* data_index_pc =
+        const uint8_t* data_index_pc =
             this->pc_ + opcode_length + array_imm.length;
         IndexImmediate data_segment(this, data_index_pc, "data segment",
                                     validate);
@@ -4683,7 +4693,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
               array_imm.index);
           return 0;
         }
-        const byte* elem_index_pc =
+        const uint8_t* elem_index_pc =
             this->pc_ + opcode_length + array_imm.length;
         IndexImmediate elem_segment(this, elem_index_pc, "element segment",
                                     validate);
@@ -6290,7 +6300,7 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
       ATOMIC_OP_LIST(CASE_ATOMIC_OP)
 #undef CASE_ATOMIC_OP
       case kExprAtomicFence: {
-        byte zero = this->template read_u8<ValidationTag>(
+        uint8_t zero = this->template read_u8<ValidationTag>(
             this->pc_ + opcode_length, "zero");
         if (!VALIDATE(zero == 0)) {
           this->DecodeError(this->pc_ + opcode_length,
@@ -6720,7 +6730,9 @@ class WasmFullDecoder : public WasmDecoder<ValidationTag, decoding_mode> {
     return true;
   }
 
-  int startrel(const byte* ptr) { return static_cast<int>(ptr - this->start_); }
+  int startrel(const uint8_t* ptr) {
+    return static_cast<int>(ptr - this->start_);
+  }
 
   void FallThrough() {
     Control* c = &control_.back();
diff --git a/src/wasm/function-body-decoder.cc b/src/wasm/function-body-decoder.cc
index ddc05f96cd..0af32f22c9 100644
--- a/src/wasm/function-body-decoder.cc
+++ b/src/wasm/function-body-decoder.cc
@@ -19,8 +19,8 @@ namespace wasm {
 
 template <typename ValidationTag>
 bool DecodeLocalDecls(WasmFeatures enabled, BodyLocalDecls* decls,
-                      const WasmModule* module, const byte* start,
-                      const byte* end, Zone* zone) {
+                      const WasmModule* module, const uint8_t* start,
+                      const uint8_t* end, Zone* zone) {
   if constexpr (ValidationTag::validate) DCHECK_NOT_NULL(module);
   WasmFeatures no_features = WasmFeatures::None();
   constexpr FixedSizeSignature<ValueType, 0, 0> kNoSig;
@@ -40,7 +40,7 @@ bool DecodeLocalDecls(WasmFeatures enabled, BodyLocalDecls* decls,
 }
 
 void DecodeLocalDecls(WasmFeatures enabled, BodyLocalDecls* decls,
-                      const byte* start, const byte* end, Zone* zone) {
+                      const uint8_t* start, const uint8_t* end, Zone* zone) {
   constexpr WasmModule* kNoModule = nullptr;
   DecodeLocalDecls<Decoder::NoValidationTag>(enabled, decls, kNoModule, start,
                                              end, zone);
@@ -49,16 +49,16 @@ void DecodeLocalDecls(WasmFeatures enabled, BodyLocalDecls* decls,
 bool ValidateAndDecodeLocalDeclsForTesting(WasmFeatures enabled,
                                            BodyLocalDecls* decls,
                                            const WasmModule* module,
-                                           const byte* start, const byte* end,
-                                           Zone* zone) {
+                                           const uint8_t* start,
+                                           const uint8_t* end, Zone* zone) {
   return DecodeLocalDecls<Decoder::BooleanValidationTag>(enabled, decls, module,
                                                          start, end, zone);
 }
 
-BytecodeIterator::BytecodeIterator(const byte* start, const byte* end)
+BytecodeIterator::BytecodeIterator(const uint8_t* start, const uint8_t* end)
     : Decoder(start, end) {}
 
-BytecodeIterator::BytecodeIterator(const byte* start, const byte* end,
+BytecodeIterator::BytecodeIterator(const uint8_t* start, const uint8_t* end,
                                    BodyLocalDecls* decls, Zone* zone)
     : Decoder(start, end) {
   DCHECK_NOT_NULL(decls);
@@ -81,7 +81,7 @@ DecodeResult ValidateFunctionBody(const WasmFeatures& enabled,
   return decoder.toResult(nullptr);
 }
 
-unsigned OpcodeLength(const byte* pc, const byte* end) {
+unsigned OpcodeLength(const uint8_t* pc, const uint8_t* end) {
   WasmFeatures unused_detected_features;
   Zone* no_zone = nullptr;
   WasmModule* no_module = nullptr;
@@ -94,7 +94,7 @@ unsigned OpcodeLength(const byte* pc, const byte* end) {
 
 bool CheckHardwareSupportsSimd() { return CpuFeatures::SupportsWasmSimd128(); }
 
-void PrintRawWasmCode(const byte* start, const byte* end) {
+void PrintRawWasmCode(const uint8_t* start, const uint8_t* end) {
   AccountingAllocator allocator;
   PrintRawWasmCode(&allocator, FunctionBody{nullptr, 0, start, end}, nullptr,
                    kPrintLocals);
@@ -173,7 +173,7 @@ bool PrintRawWasmCode(AccountingAllocator* allocator, const FunctionBody& body,
     if (line_numbers) line_numbers->push_back(kNoByteCode);
     ++line_nr;
 
-    for (const byte* locals = body.start; locals < i.pc(); locals++) {
+    for (const uint8_t* locals = body.start; locals < i.pc(); locals++) {
       os << (locals == body.start ? "0x" : " 0x") << AsHex(*locals, 2) << ",";
     }
     os << std::endl;
@@ -311,7 +311,8 @@ bool PrintRawWasmCode(AccountingAllocator* allocator, const FunctionBody& body,
 }
 
 BitVector* AnalyzeLoopAssignmentForTesting(Zone* zone, uint32_t num_locals,
-                                           const byte* start, const byte* end,
+                                           const uint8_t* start,
+                                           const uint8_t* end,
                                            bool* loop_is_innermost) {
   WasmFeatures no_features = WasmFeatures::None();
   WasmDecoder<Decoder::FullValidationTag> decoder(
diff --git a/src/wasm/function-body-decoder.h b/src/wasm/function-body-decoder.h
index a07761238b..41bc074f49 100644
--- a/src/wasm/function-body-decoder.h
+++ b/src/wasm/function-body-decoder.h
@@ -31,11 +31,11 @@ struct WasmModule;  // forward declaration of module interface.
 struct FunctionBody {
   const FunctionSig* sig;  // function signature
   uint32_t offset;         // offset in the module bytes, for error reporting
-  const byte* start;       // start of the function body
-  const byte* end;         // end of the function body
+  const uint8_t* start;    // start of the function body
+  const uint8_t* end;      // end of the function body
 
-  FunctionBody(const FunctionSig* sig, uint32_t offset, const byte* start,
-               const byte* end)
+  FunctionBody(const FunctionSig* sig, uint32_t offset, const uint8_t* start,
+               const uint8_t* end)
       : sig(sig), offset(offset), start(start), end(end) {}
 };
 
@@ -58,7 +58,7 @@ bool PrintRawWasmCode(AccountingAllocator* allocator, const FunctionBody& body,
                       std::vector<int>* line_numbers = nullptr);
 
 // A simplified form of AST printing, e.g. from a debugger.
-void PrintRawWasmCode(const byte* start, const byte* end);
+void PrintRawWasmCode(const uint8_t* start, const uint8_t* end);
 
 struct BodyLocalDecls {
   // The size of the encoded declarations.
@@ -71,20 +71,20 @@ struct BodyLocalDecls {
 // Decode locals; validation is not performed.
 V8_EXPORT_PRIVATE void DecodeLocalDecls(WasmFeatures enabled,
                                         BodyLocalDecls* decls,
-                                        const byte* start, const byte* end,
-                                        Zone* zone);
+                                        const uint8_t* start,
+                                        const uint8_t* end, Zone* zone);
 
 // Decode locals, including validation.
 V8_EXPORT_PRIVATE bool ValidateAndDecodeLocalDeclsForTesting(
     WasmFeatures enabled, BodyLocalDecls* decls, const WasmModule* module,
-    const byte* start, const byte* end, Zone* zone);
+    const uint8_t* start, const uint8_t* end, Zone* zone);
 
 V8_EXPORT_PRIVATE BitVector* AnalyzeLoopAssignmentForTesting(
-    Zone* zone, uint32_t num_locals, const byte* start, const byte* end,
+    Zone* zone, uint32_t num_locals, const uint8_t* start, const uint8_t* end,
     bool* loop_is_innermost);
 
 // Computes the length of the opcode at the given address.
-V8_EXPORT_PRIVATE unsigned OpcodeLength(const byte* pc, const byte* end);
+V8_EXPORT_PRIVATE unsigned OpcodeLength(const uint8_t* pc, const uint8_t* end);
 
 // Checks if the underlying hardware supports the Wasm SIMD proposal.
 V8_EXPORT_PRIVATE bool CheckHardwareSupportsSimd();
@@ -107,9 +107,10 @@ class V8_EXPORT_PRIVATE BytecodeIterator : public NON_EXPORTED_BASE(Decoder) {
     }
 
    protected:
-    const byte* ptr_;
-    const byte* end_;
-    iterator_base(const byte* ptr, const byte* end) : ptr_(ptr), end_(end) {}
+    const uint8_t* ptr_;
+    const uint8_t* end_;
+    iterator_base(const uint8_t* ptr, const uint8_t* end)
+        : ptr_(ptr), end_(end) {}
   };
 
  public:
@@ -125,7 +126,7 @@ class V8_EXPORT_PRIVATE BytecodeIterator : public NON_EXPORTED_BASE(Decoder) {
 
    private:
     friend class BytecodeIterator;
-    opcode_iterator(const byte* ptr, const byte* end)
+    opcode_iterator(const uint8_t* ptr, const uint8_t* end)
         : iterator_base(ptr, end) {}
   };
   // If one wants to iterate over the instruction offsets without looking at
@@ -140,18 +141,19 @@ class V8_EXPORT_PRIVATE BytecodeIterator : public NON_EXPORTED_BASE(Decoder) {
     }
 
    private:
-    const byte* start_;
+    const uint8_t* start_;
     friend class BytecodeIterator;
-    offset_iterator(const byte* start, const byte* ptr, const byte* end)
+    offset_iterator(const uint8_t* start, const uint8_t* ptr,
+                    const uint8_t* end)
         : iterator_base(ptr, end), start_(start) {}
   };
 
   // Create a new {BytecodeIterator}, starting after the locals declarations.
-  BytecodeIterator(const byte* start, const byte* end);
+  BytecodeIterator(const uint8_t* start, const uint8_t* end);
 
   // Create a new {BytecodeIterator}, starting with locals declarations.
-  BytecodeIterator(const byte* start, const byte* end, BodyLocalDecls* decls,
-                   Zone* zone);
+  BytecodeIterator(const uint8_t* start, const uint8_t* end,
+                   BodyLocalDecls* decls, Zone* zone);
 
   base::iterator_range<opcode_iterator> opcodes() {
     return base::iterator_range<opcode_iterator>(opcode_iterator(pc_, end_),
diff --git a/src/wasm/function-compiler.h b/src/wasm/function-compiler.h
index 6304f36670..b3cdb02b35 100644
--- a/src/wasm/function-compiler.h
+++ b/src/wasm/function-compiler.h
@@ -75,9 +75,9 @@ struct WasmCompilationResult {
   std::unique_ptr<AssemblerBuffer> instr_buffer;
   uint32_t frame_slot_count = 0;
   uint32_t tagged_parameter_slots = 0;
-  base::OwnedVector<byte> source_positions;
-  base::OwnedVector<byte> inlining_positions;
-  base::OwnedVector<byte> protected_instructions_data;
+  base::OwnedVector<uint8_t> source_positions;
+  base::OwnedVector<uint8_t> inlining_positions;
+  base::OwnedVector<uint8_t> protected_instructions_data;
   std::unique_ptr<AssumptionsJournal> assumptions;
   int func_index = kAnonymousFuncIndex;
   ExecutionTier requested_tier;
diff --git a/src/wasm/jump-table-assembler.cc b/src/wasm/jump-table-assembler.cc
index d31870264e..80e9d53f7d 100644
--- a/src/wasm/jump-table-assembler.cc
+++ b/src/wasm/jump-table-assembler.cc
@@ -59,7 +59,7 @@ void JumpTableAssembler::EmitLazyCompileJumpSlot(uint32_t func_index,
 
 bool JumpTableAssembler::EmitJumpSlot(Address target) {
   intptr_t displacement = static_cast<intptr_t>(
-      reinterpret_cast<byte*>(target) - pc_ - kNearJmpInstrSize);
+      reinterpret_cast<uint8_t*>(target) - pc_ - kNearJmpInstrSize);
   if (!is_int32(displacement)) return false;
   near_jmp(displacement, RelocInfo::NO_INFO);  // 5 bytes
   return true;
@@ -199,8 +199,8 @@ bool JumpTableAssembler::EmitJumpSlot(Address target) {
   static constexpr ptrdiff_t kCodeEntryMarkerSize = 0;
 #endif
 
-  byte* jump_pc = pc_ + kCodeEntryMarkerSize;
-  ptrdiff_t jump_distance = reinterpret_cast<byte*>(target) - jump_pc;
+  uint8_t* jump_pc = pc_ + kCodeEntryMarkerSize;
+  ptrdiff_t jump_distance = reinterpret_cast<uint8_t*>(target) - jump_pc;
   DCHECK_EQ(0, jump_distance % kInstrSize);
   int64_t instr_offset = jump_distance / kInstrSize;
   if (!MacroAssembler::IsNearCallOffset(instr_offset)) {
@@ -280,7 +280,7 @@ void JumpTableAssembler::EmitLazyCompileJumpSlot(uint32_t func_index,
 }
 
 bool JumpTableAssembler::EmitJumpSlot(Address target) {
-  intptr_t relative_target = reinterpret_cast<byte*>(target) - pc_;
+  intptr_t relative_target = reinterpret_cast<uint8_t*>(target) - pc_;
 
   if (!is_int32(relative_target / 2)) {
     return false;
@@ -377,7 +377,7 @@ void JumpTableAssembler::EmitLazyCompileJumpSlot(uint32_t func_index,
   for (int i = 0; i < nop_bytes; i += kInstrSize) nop();
 }
 bool JumpTableAssembler::EmitJumpSlot(Address target) {
-  intptr_t relative_target = reinterpret_cast<byte*>(target) - pc_;
+  intptr_t relative_target = reinterpret_cast<uint8_t*>(target) - pc_;
   DCHECK_EQ(relative_target % 4, 0);
   intptr_t instr_offset = relative_target / kInstrSize;
   if (!is_int26(instr_offset)) {
@@ -431,7 +431,7 @@ void JumpTableAssembler::EmitLazyCompileJumpSlot(uint32_t func_index,
 }
 
 bool JumpTableAssembler::EmitJumpSlot(Address target) {
-  intptr_t relative_target = reinterpret_cast<byte*>(target) - pc_;
+  intptr_t relative_target = reinterpret_cast<uint8_t*>(target) - pc_;
 
   if (!is_int26(relative_target)) {
     return false;
@@ -442,13 +442,13 @@ bool JumpTableAssembler::EmitJumpSlot(Address target) {
 }
 
 void JumpTableAssembler::EmitFarJumpSlot(Address target) {
-  byte* start = pc_;
+  uint8_t* start = pc_;
   mov(ip, Operand(reinterpret_cast<Address>(start + kFarJumpTableSlotSize -
                                             8)));  // 5 instr
   LoadU64(ip, MemOperand(ip));
   mtctr(ip);
   bctr();
-  byte* end = pc_;
+  uint8_t* end = pc_;
   int used = end - start;
   CHECK(used < kFarJumpTableSlotSize - 8);
   NopBytes(kFarJumpTableSlotSize - 8 - used);
diff --git a/src/wasm/local-decl-encoder.cc b/src/wasm/local-decl-encoder.cc
index b903e349e6..8ebb98ea26 100644
--- a/src/wasm/local-decl-encoder.cc
+++ b/src/wasm/local-decl-encoder.cc
@@ -14,10 +14,11 @@ namespace wasm {
 // This struct is just a type tag for Zone::NewArray<T>(size_t) call.
 struct LocalDeclEncoderBuffer {};
 
-void LocalDeclEncoder::Prepend(Zone* zone, const byte** start,
-                               const byte** end) const {
+void LocalDeclEncoder::Prepend(Zone* zone, const uint8_t** start,
+                               const uint8_t** end) const {
   size_t size = (*end - *start);
-  byte* buffer = zone->NewArray<byte, LocalDeclEncoderBuffer>(Size() + size);
+  uint8_t* buffer =
+      zone->NewArray<uint8_t, LocalDeclEncoderBuffer>(Size() + size);
   size_t pos = Emit(buffer);
   if (size > 0) {
     memcpy(buffer + pos, *start, size);
@@ -27,8 +28,8 @@ void LocalDeclEncoder::Prepend(Zone* zone, const byte** start,
   *end = buffer + pos;
 }
 
-size_t LocalDeclEncoder::Emit(byte* buffer) const {
-  byte* pos = buffer;
+size_t LocalDeclEncoder::Emit(uint8_t* buffer) const {
+  uint8_t* pos = buffer;
   LEBHelper::write_u32v(&pos, static_cast<uint32_t>(local_decls.size()));
   for (auto& local_decl : local_decls) {
     uint32_t locals_count = local_decl.first;
diff --git a/src/wasm/local-decl-encoder.h b/src/wasm/local-decl-encoder.h
index 987807cf29..28784bff7e 100644
--- a/src/wasm/local-decl-encoder.h
+++ b/src/wasm/local-decl-encoder.h
@@ -26,9 +26,9 @@ class V8_EXPORT_PRIVATE LocalDeclEncoder {
 
   // Prepend local declarations by creating a new buffer and copying data
   // over. The new buffer must be delete[]'d by the caller.
-  void Prepend(Zone* zone, const byte** start, const byte** end) const;
+  void Prepend(Zone* zone, const uint8_t** start, const uint8_t** end) const;
 
-  size_t Emit(byte* buffer) const;
+  size_t Emit(uint8_t* buffer) const;
 
   // Add locals declarations to this helper. Return the index of the newly added
   // local(s), with an optional adjustment for the parameters.
diff --git a/src/wasm/module-decoder-impl.h b/src/wasm/module-decoder-impl.h
index a8a6670fbf..2cb1c62bd4 100644
--- a/src/wasm/module-decoder-impl.h
+++ b/src/wasm/module-decoder-impl.h
@@ -71,7 +71,7 @@ inline WireBytesRef consume_string(Decoder* decoder,
     tracer->NextLine();
   }
   uint32_t offset = decoder->pc_offset();
-  const byte* string_start = decoder->pc();
+  const uint8_t* string_start = decoder->pc();
   // Consume bytes before validation to guarantee that the string is not oob.
   if (length > 0) {
     if (tracer) {
@@ -121,7 +121,7 @@ inline SectionCode IdentifyUnknownSectionInternal(Decoder* decoder,
   if (decoder->failed()) {
     return kUnknownSectionCode;
   }
-  const byte* section_name_start =
+  const uint8_t* section_name_start =
       decoder->start() + decoder->GetBufferRelativeOffset(string.offset());
 
   TRACE("  +%d  section name        : \"%.*s\"\n",
@@ -167,7 +167,7 @@ class WasmSectionIterator {
 
   SectionCode section_code() const { return section_code_; }
 
-  const byte* section_start() const { return section_start_; }
+  const uint8_t* section_start() const { return section_start_; }
 
   uint32_t section_length() const {
     return static_cast<uint32_t>(section_end_ - section_start_);
@@ -177,13 +177,13 @@ class WasmSectionIterator {
     return {payload_start_, payload_length()};
   }
 
-  const byte* payload_start() const { return payload_start_; }
+  const uint8_t* payload_start() const { return payload_start_; }
 
   uint32_t payload_length() const {
     return static_cast<uint32_t>(section_end_ - payload_start_);
   }
 
-  const byte* section_end() const { return section_end_; }
+  const uint8_t* section_end() const { return section_end_; }
 
   // Advances to the next section, checking that decoding the current section
   // stopped at {section_end_}.
@@ -207,9 +207,9 @@ class WasmSectionIterator {
   Decoder* decoder_;
   ITracer* tracer_;
   SectionCode section_code_;
-  const byte* section_start_;
-  const byte* payload_start_;
-  const byte* section_end_;
+  const uint8_t* section_start_;
+  const uint8_t* payload_start_;
+  const uint8_t* section_end_;
 
   // Reads the section code/name at the current position and sets up
   // the embedder fields.
@@ -250,7 +250,7 @@ class WasmSectionIterator {
       // To identify the unknown section we set the end of the decoder bytes to
       // the end of the custom section, so that we do not read the section name
       // beyond the end of the section.
-      const byte* module_end = decoder_->end();
+      const uint8_t* module_end = decoder_->end();
       decoder_->set_end(section_end_);
       section_code = IdentifyUnknownSectionInternal(decoder_, tracer_);
       if (decoder_->ok()) decoder_->set_end(module_end);
@@ -272,7 +272,8 @@ class WasmSectionIterator {
   }
 };
 
-inline void DumpModule(const base::Vector<const byte> module_bytes, bool ok) {
+inline void DumpModule(const base::Vector<const uint8_t> module_bytes,
+                       bool ok) {
   std::string path;
   if (v8_flags.dump_wasm_module_path) {
     path = v8_flags.dump_wasm_module_path;
@@ -318,7 +319,7 @@ class ModuleDecoderImpl : public Decoder {
     if (failed()) return;
     Reset(bytes);
 
-    const byte* pos = pc_;
+    const uint8_t* pos = pc_;
     uint32_t magic_word = consume_u32("wasm magic", tracer_);
     if (tracer_) tracer_->NextLine();
 #define BYTES(x) (x & 0xFF), (x >> 8) & 0xFF, (x >> 16) & 0xFF, (x >> 24) & 0xFF
@@ -734,7 +735,7 @@ class ModuleDecoderImpl : public Decoder {
           0                   // index
       });
       WasmImport* import = &module_->import_table.back();
-      const byte* pos = pc_;
+      const uint8_t* pos = pc_;
       import->module_name = consume_utf8_string(this, "module name", tracer_);
       import->field_name = consume_utf8_string(this, "field name", tracer_);
       import->kind =
@@ -764,7 +765,7 @@ class ModuleDecoderImpl : public Decoder {
           module_->tables.emplace_back();
           WasmTable* table = &module_->tables.back();
           table->imported = true;
-          const byte* type_position = pc();
+          const uint8_t* type_position = pc();
           ValueType type = consume_value_type();
           if (!type.is_object_reference()) {
             errorf(type_position, "Invalid table type %s", type.name().c_str());
@@ -865,7 +866,7 @@ class ModuleDecoderImpl : public Decoder {
       if (tracer_) tracer_->TableOffset(pc_offset());
       module_->tables.emplace_back();
       WasmTable* table = &module_->tables.back();
-      const byte* type_position = pc();
+      const uint8_t* type_position = pc();
 
       bool has_initializer = false;
       if (enabled_features_.has_typed_funcref() &&
@@ -978,7 +979,7 @@ class ModuleDecoderImpl : public Decoder {
 
       exp->name = consume_utf8_string(this, "field name", tracer_);
 
-      const byte* pos = pc();
+      const uint8_t* pos = pc();
       exp->kind =
           static_cast<ImportExportKindCode>(consume_u8("kind: ", tracer_));
       if (tracer_) {
@@ -1044,8 +1045,10 @@ class ModuleDecoderImpl : public Decoder {
         if (a.name.length() != b.name.length()) {
           return a.name.length() < b.name.length();
         }
-        const byte* left = start() + GetBufferRelativeOffset(a.name.offset());
-        const byte* right = start() + GetBufferRelativeOffset(b.name.offset());
+        const uint8_t* left =
+            start() + GetBufferRelativeOffset(a.name.offset());
+        const uint8_t* right =
+            start() + GetBufferRelativeOffset(b.name.offset());
         return memcmp(left, right, a.name.length()) < 0;
       };
       std::stable_sort(sorted_exports.begin(), sorted_exports.end(), cmp_less);
@@ -1055,7 +1058,8 @@ class ModuleDecoderImpl : public Decoder {
       for (auto end = sorted_exports.end(); it != end; last = &*it++) {
         DCHECK(!cmp_less(*it, *last));  // Vector must be sorted.
         if (!cmp_less(*last, *it)) {
-          const byte* pc = start() + GetBufferRelativeOffset(it->name.offset());
+          const uint8_t* pc =
+              start() + GetBufferRelativeOffset(it->name.offset());
           TruncatedUserString<> name(pc, it->name.length());
           errorf(pc, "Duplicate export name '%.*s' for %s %d and %s %d",
                  name.length(), name.start(), ExternalKindName(last->kind),
@@ -1069,7 +1073,7 @@ class ModuleDecoderImpl : public Decoder {
   void DecodeStartSection() {
     if (tracer_) tracer_->StartOffset(pc_offset());
     WasmFunction* func;
-    const byte* pos = pc_;
+    const uint8_t* pos = pc_;
     module_->start_function_index = consume_func_index(module_.get(), &func);
     if (tracer_) tracer_->NextLine();
     if (func &&
@@ -1121,7 +1125,7 @@ class ModuleDecoderImpl : public Decoder {
         tracer_->FunctionName(function_index);
         tracer_->NextLine();
       }
-      const byte* pos = pc();
+      const uint8_t* pos = pc();
       uint32_t size = consume_u32v("body size", tracer_);
       if (tracer_) {
         tracer_->Description(size);
@@ -1204,7 +1208,7 @@ class ModuleDecoderImpl : public Decoder {
 
     module_->data_segments.reserve(data_segments_count);
     for (uint32_t i = 0; ok() && i < data_segments_count; ++i) {
-      const byte* pos = pc();
+      const uint8_t* pos = pc();
       TRACE("DecodeDataSegment[%d] module+%d\n", i,
             static_cast<int>(pc_ - start_));
       if (tracer_) tracer_->DataOffset(pc_offset());
@@ -1632,7 +1636,7 @@ class ModuleDecoderImpl : public Decoder {
   ModuleResult DecodeModule(bool validate_functions) {
     // Keep a reference to the wire bytes, in case this decoder gets reset on
     // error.
-    base::Vector<const byte> wire_bytes(start_, end_ - start_);
+    base::Vector<const uint8_t> wire_bytes(start_, end_ - start_);
     size_t max_size = max_module_size();
     if (wire_bytes.size() > max_size) {
       return ModuleResult{WasmError{0, "size > maximum module size (%zu): %zu",
@@ -1705,7 +1709,7 @@ class ModuleDecoderImpl : public Decoder {
   }
 
   // Decodes a single function signature at {start}.
-  const FunctionSig* DecodeFunctionSignature(Zone* zone, const byte* start) {
+  const FunctionSig* DecodeFunctionSignature(Zone* zone, const uint8_t* start) {
     pc_ = start;
     if (!expect_u8("type form", kWasmFunctionTypeCode)) return nullptr;
     const FunctionSig* result = consume_sig(zone);
@@ -1739,7 +1743,7 @@ class ModuleDecoderImpl : public Decoder {
     seen_unordered_sections_ |= 1 << section_code;
   }
 
-  uint32_t off(const byte* ptr) {
+  uint32_t off(const uint8_t* ptr) {
     return static_cast<uint32_t>(ptr - start_) + buffer_offset_;
   }
 
@@ -1788,7 +1792,7 @@ class ModuleDecoderImpl : public Decoder {
   }
 
   uint32_t consume_sig_index(WasmModule* module, const FunctionSig** sig) {
-    const byte* pos = pc_;
+    const uint8_t* pos = pc_;
     uint32_t sig_index = consume_u32v("signature index");
     if (tracer_) tracer_->Bytes(pos, static_cast<uint32_t>(pc_ - pos));
     if (!module->has_signature(sig_index)) {
@@ -1807,7 +1811,7 @@ class ModuleDecoderImpl : public Decoder {
   }
 
   uint32_t consume_tag_sig_index(WasmModule* module, const FunctionSig** sig) {
-    const byte* pos = pc_;
+    const uint8_t* pos = pc_;
     uint32_t sig_index = consume_sig_index(module, sig);
     if (*sig && (*sig)->return_count() != 0) {
       errorf(pos, "tag signature %u has non-void return", sig_index);
@@ -1818,7 +1822,7 @@ class ModuleDecoderImpl : public Decoder {
   }
 
   uint32_t consume_count(const char* name, size_t maximum) {
-    const byte* p = pc_;
+    const uint8_t* p = pc_;
     uint32_t count = consume_u32v(name, tracer_);
     if (tracer_) {
       tracer_->Description(count);
@@ -1853,7 +1857,7 @@ class ModuleDecoderImpl : public Decoder {
 
   template <typename T>
   uint32_t consume_index(const char* name, std::vector<T>* vector, T** ptr) {
-    const byte* pos = pc_;
+    const uint8_t* pos = pc_;
     uint32_t index = consume_u32v("index:", tracer_);
     if (tracer_) tracer_->Description(index);
     if (index >= vector->size()) {
@@ -1926,7 +1930,7 @@ class ModuleDecoderImpl : public Decoder {
                                 uint32_t max_initial, uint32_t* initial,
                                 bool has_maximum, uint32_t max_maximum,
                                 uint32_t* maximum, ResizableLimitsType type) {
-    const byte* pos = pc();
+    const uint8_t* pos = pc();
     // Note that even if we read the values as 64-bit value, all V8 limits are
     // still within uint32_t range.
     uint64_t initial_64 = type == k64BitLimits
@@ -1971,7 +1975,7 @@ class ModuleDecoderImpl : public Decoder {
 
   // Consumes a byte, and emits an error if it does not equal {expected}.
   bool expect_u8(const char* name, uint8_t expected) {
-    const byte* pos = pc();
+    const uint8_t* pos = pc();
     uint8_t value = consume_u8(name);
     if (value != expected) {
       errorf(pos, "expected %s 0x%02x, got 0x%02x", name, expected, value);
@@ -2096,7 +2100,7 @@ class ModuleDecoderImpl : public Decoder {
   // Read a mutability flag
   bool consume_mutability() {
     if (tracer_) tracer_->Bytes(pc_, 1);
-    byte val = consume_u8("mutability");
+    uint8_t val = consume_u8("mutability");
     if (tracer_) {
       tracer_->Description(val == 0   ? " immutable"
                            : val == 1 ? " mutable"
@@ -2201,7 +2205,7 @@ class ModuleDecoderImpl : public Decoder {
 
   // Consume the attribute field of an exception.
   uint32_t consume_exception_attribute() {
-    const byte* pos = pc_;
+    const uint8_t* pos = pc_;
     uint32_t attribute = consume_u32v("exception attribute");
     if (tracer_) tracer_->Bytes(pos, static_cast<uint32_t>(pc_ - pos));
     if (attribute != kExceptionAttribute) {
@@ -2212,7 +2216,7 @@ class ModuleDecoderImpl : public Decoder {
   }
 
   WasmElemSegment consume_element_segment_header() {
-    const byte* pos = pc();
+    const uint8_t* pos = pc();
 
     // The mask for the bit in the flag which indicates if the segment is
     // active or not (0 is active).
@@ -2347,7 +2351,7 @@ class ModuleDecoderImpl : public Decoder {
 
   void consume_data_segment_header(bool* is_active, uint32_t* index,
                                    ConstantExpression* offset) {
-    const byte* pos = pc();
+    const uint8_t* pos = pc();
     uint32_t flag = consume_u32v("flag: ", tracer_);
     if (tracer_) {
       tracer_->Description(
@@ -2388,7 +2392,7 @@ class ModuleDecoderImpl : public Decoder {
 
   uint32_t consume_element_func_index(WasmModule* module, ValueType expected) {
     WasmFunction* func = nullptr;
-    const byte* initial_pc = pc();
+    const uint8_t* initial_pc = pc();
     uint32_t index = consume_func_index(module, &func);
     if (tracer_) tracer_->NextLine();
     if (failed()) return index;
@@ -2407,8 +2411,8 @@ class ModuleDecoderImpl : public Decoder {
 
   const WasmFeatures enabled_features_;
   const std::shared_ptr<WasmModule> module_;
-  const byte* module_start_ = nullptr;
-  const byte* module_end_ = nullptr;
+  const uint8_t* module_start_ = nullptr;
+  const uint8_t* module_end_ = nullptr;
   ITracer* tracer_;
   // The type section is the first section in a module.
   uint8_t next_ordered_section_ = kFirstSectionInModule;
diff --git a/src/wasm/module-decoder.cc b/src/wasm/module-decoder.cc
index 8918e00605..36011e0f9b 100644
--- a/src/wasm/module-decoder.cc
+++ b/src/wasm/module-decoder.cc
@@ -220,7 +220,7 @@ AsmJsOffsetsResult DecodeAsmJsOffsets(
       continue;
     }
     DCHECK(decoder.checkAvailable(size));
-    const byte* table_end = decoder.pc() + size;
+    const uint8_t* table_end = decoder.pc() + size;
     uint32_t locals_size = decoder.consume_u32v("locals size");
     int function_start_position = decoder.consume_u32v("function start pos");
     int function_end_position = function_start_position;
@@ -268,7 +268,7 @@ std::vector<CustomSectionOffset> DecodeCustomSections(
   std::vector<CustomSectionOffset> result;
 
   while (decoder.more()) {
-    byte section_code = decoder.consume_u8("section code");
+    uint8_t section_code = decoder.consume_u8("section code");
     uint32_t section_length = decoder.consume_u32v("section length");
     uint32_t section_start = decoder.pc_offset();
     if (section_code != 0) {
diff --git a/src/wasm/module-instantiate.cc b/src/wasm/module-instantiate.cc
index 1195175997..a12431f818 100644
--- a/src/wasm/module-instantiate.cc
+++ b/src/wasm/module-instantiate.cc
@@ -41,8 +41,9 @@ namespace wasm {
 
 namespace {
 
-byte* raw_buffer_ptr(MaybeHandle<JSArrayBuffer> buffer, int offset) {
-  return static_cast<byte*>(buffer.ToHandleChecked()->backing_store()) + offset;
+uint8_t* raw_buffer_ptr(MaybeHandle<JSArrayBuffer> buffer, int offset) {
+  return static_cast<uint8_t*>(buffer.ToHandleChecked()->backing_store()) +
+         offset;
 }
 
 using ImportWrapperQueue =
@@ -993,7 +994,7 @@ MaybeHandle<WasmInstanceObject> InstanceBuilder::Build() {
 
     instance->set_untagged_globals_buffer(*untagged_globals_);
     instance->set_globals_start(
-        reinterpret_cast<byte*>(untagged_globals_->backing_store()));
+        reinterpret_cast<uint8_t*>(untagged_globals_->backing_store()));
   }
 
   uint32_t tagged_globals_buffer_size = module_->tagged_globals_buffer_size;
@@ -1436,12 +1437,12 @@ void InstanceBuilder::WriteGlobalValue(const WasmGlobal& global,
                                        const WasmValue& value) {
   TRACE("init [globals_start=%p + %u] = %s, type = %s\n",
         global.type.is_reference()
-            ? reinterpret_cast<byte*>(tagged_globals_->address())
+            ? reinterpret_cast<uint8_t*>(tagged_globals_->address())
             : raw_buffer_ptr(untagged_globals_, 0),
         global.offset, value.to_string().c_str(), global.type.name().c_str());
   DCHECK(IsSubtypeOf(value.type(), global.type, module_));
   if (global.type.is_numeric()) {
-    value.CopyTo(GetRawUntaggedGlobalPtr<byte>(global));
+    value.CopyTo(GetRawUntaggedGlobalPtr<uint8_t>(global));
   } else {
     tagged_globals_->set(global.offset, *value.to_ref());
   }
@@ -2135,7 +2136,7 @@ void InstanceBuilder::InitGlobals(Handle<WasmInstanceObject> instance) {
     if (global.type.is_reference()) {
       tagged_globals_->set(global.offset, *to_value(result).to_ref());
     } else {
-      to_value(result).CopyTo(GetRawUntaggedGlobalPtr<byte>(global));
+      to_value(result).CopyTo(GetRawUntaggedGlobalPtr<uint8_t>(global));
     }
   }
 }
@@ -2497,7 +2498,7 @@ base::Optional<MessageTemplate> InitializeElementSegment(
   const WasmElemSegment& elem_segment =
       instance->module()->elem_segments[segment_index];
 
-  base::Vector<const byte> module_bytes =
+  base::Vector<const uint8_t> module_bytes =
       instance->module_object().native_module()->wire_bytes();
 
   Decoder decoder(module_bytes);
@@ -2543,7 +2544,7 @@ void InstanceBuilder::LoadTableSegments(Handle<WasmInstanceObject> instance) {
       return;
     }
 
-    base::Vector<const byte> module_bytes =
+    base::Vector<const uint8_t> module_bytes =
         instance->module_object().native_module()->wire_bytes();
     Decoder decoder(module_bytes);
     decoder.consume_bytes(elem_segment.elements_wire_bytes_offset);
diff --git a/src/wasm/names-provider.cc b/src/wasm/names-provider.cc
index 03b687db76..b7c71507de 100644
--- a/src/wasm/names-provider.cc
+++ b/src/wasm/names-provider.cc
@@ -118,7 +118,7 @@ static constexpr char kIdentifierChar[] = {
 // code unit.
 // We could decide that we don't care much how exactly non-ASCII names are
 // rendered and simplify this to "one '_' per invalid UTF8 byte".
-void SanitizeUnicodeName(StringBuilder& out, const byte* utf8_src,
+void SanitizeUnicodeName(StringBuilder& out, const uint8_t* utf8_src,
                          size_t length) {
   base::Vector<const uint8_t> utf8_data(utf8_src, length);
   Utf8Decoder decoder(utf8_data);
@@ -136,9 +136,9 @@ void SanitizeUnicodeName(StringBuilder& out, const byte* utf8_src,
 
 void NamesProvider::ComputeImportName(const WasmImport& import,
                                       std::map<uint32_t, std::string>& target) {
-  const byte* mod_start = wire_bytes_.begin() + import.module_name.offset();
+  const uint8_t* mod_start = wire_bytes_.begin() + import.module_name.offset();
   size_t mod_length = import.module_name.length();
-  const byte* field_start = wire_bytes_.begin() + import.field_name.offset();
+  const uint8_t* field_start = wire_bytes_.begin() + import.field_name.offset();
   size_t field_length = import.field_name.length();
   StringBuilder buffer;
   buffer << '$';
diff --git a/src/wasm/stacks.cc b/src/wasm/stacks.cc
index 360b53551a..19d243c48d 100644
--- a/src/wasm/stacks.cc
+++ b/src/wasm/stacks.cc
@@ -14,7 +14,7 @@ StackMemory* StackMemory::GetCurrentStackView(Isolate* isolate) {
   uintptr_t stack_start = base::Stack::GetStackStart();
   DCHECK_LE(limit, stack_start);
   size_t size = stack_start - limit;
-  return new StackMemory(isolate, reinterpret_cast<byte*>(limit), size);
+  return new StackMemory(isolate, reinterpret_cast<uint8_t*>(limit), size);
 }
 
 StackMemory::~StackMemory() {
@@ -45,7 +45,7 @@ StackMemory::StackMemory(Isolate* isolate) : isolate_(isolate), owned_(true) {
   int kJsStackSizeKB = v8_flags.wasm_stack_switching_stack_size;
   size_ = (kJsStackSizeKB + kJSLimitOffsetKB) * KB;
   size_ = RoundUp(size_, allocator->AllocatePageSize());
-  limit_ = static_cast<byte*>(
+  limit_ = static_cast<uint8_t*>(
       allocator->AllocatePages(nullptr, size_, allocator->AllocatePageSize(),
                                PageAllocator::kReadWrite));
   if (v8_flags.trace_wasm_stack_switching) {
@@ -55,7 +55,7 @@ StackMemory::StackMemory(Isolate* isolate) : isolate_(isolate), owned_(true) {
 }
 
 // Overload to represent a view of the libc stack.
-StackMemory::StackMemory(Isolate* isolate, byte* limit, size_t size)
+StackMemory::StackMemory(Isolate* isolate, uint8_t* limit, size_t size)
     : isolate_(isolate), limit_(limit), size_(size), owned_(false) {
   id_ = 0;
 }
diff --git a/src/wasm/stacks.h b/src/wasm/stacks.h
index 516d7bb426..031ee69400 100644
--- a/src/wasm/stacks.h
+++ b/src/wasm/stacks.h
@@ -63,10 +63,10 @@ class StackMemory {
   explicit StackMemory(Isolate* isolate);
 
   // Overload to represent a view of the libc stack.
-  StackMemory(Isolate* isolate, byte* limit, size_t size);
+  StackMemory(Isolate* isolate, uint8_t* limit, size_t size);
 
   Isolate* isolate_;
-  byte* limit_;
+  uint8_t* limit_;
   size_t size_;
   bool owned_;
   JumpBuffer jmpbuf_;
diff --git a/src/wasm/string-builder.h b/src/wasm/string-builder.h
index 804494d078..e5dc009573 100644
--- a/src/wasm/string-builder.h
+++ b/src/wasm/string-builder.h
@@ -46,7 +46,7 @@ class StringBuilder {
     return result;
   }
   // Convenience wrappers.
-  void write(const byte* data, size_t n) {
+  void write(const uint8_t* data, size_t n) {
     char* ptr = allocate(n);
     memcpy(ptr, data, n);
   }
diff --git a/src/wasm/wasm-code-manager.cc b/src/wasm/wasm-code-manager.cc
index 56d98b8754..92a31c8b38 100644
--- a/src/wasm/wasm-code-manager.cc
+++ b/src/wasm/wasm-code-manager.cc
@@ -187,13 +187,13 @@ int WasmCode::code_comments_size() const {
   return static_cast<int>(unpadded_binary_size_ - code_comments_offset_);
 }
 
-std::unique_ptr<const byte[]> WasmCode::ConcatenateBytes(
-    std::initializer_list<base::Vector<const byte>> vectors) {
+std::unique_ptr<const uint8_t[]> WasmCode::ConcatenateBytes(
+    std::initializer_list<base::Vector<const uint8_t>> vectors) {
   size_t total_size = 0;
   for (auto& vec : vectors) total_size += vec.size();
   // Use default-initialization (== no initialization).
-  std::unique_ptr<byte[]> result{new byte[total_size]};
-  byte* ptr = result.get();
+  std::unique_ptr<uint8_t[]> result{new uint8_t[total_size]};
+  uint8_t* ptr = result.get();
   for (auto& vec : vectors) {
     if (vec.empty()) continue;  // Avoid nullptr in {memcpy}.
     memcpy(ptr, vec.begin(), vec.size());
@@ -529,7 +529,7 @@ int WasmCode::GetSourceOffsetBefore(int code_offset) {
 std::pair<int, SourcePosition> WasmCode::GetInliningPosition(
     int inlining_id) const {
   const size_t elem_size = sizeof(int) + sizeof(SourcePosition);
-  const byte* start = inlining_positions().begin() + elem_size * inlining_id;
+  const uint8_t* start = inlining_positions().begin() + elem_size * inlining_id;
   DCHECK_LE(start, inlining_positions().end());
   std::pair<int, SourcePosition> result;
   std::memcpy(&result.first, start, sizeof result.first);
@@ -673,12 +673,12 @@ constexpr base::AddressRegion kUnrestrictedRegion{
 
 }  // namespace
 
-base::Vector<byte> WasmCodeAllocator::AllocateForCode(
+base::Vector<uint8_t> WasmCodeAllocator::AllocateForCode(
     NativeModule* native_module, size_t size) {
   return AllocateForCodeInRegion(native_module, size, kUnrestrictedRegion);
 }
 
-base::Vector<byte> WasmCodeAllocator::AllocateForCodeInRegion(
+base::Vector<uint8_t> WasmCodeAllocator::AllocateForCodeInRegion(
     NativeModule* native_module, size_t size, base::AddressRegion region) {
   DCHECK_LT(0, size);
   auto* code_manager = GetWasmCodeManager();
@@ -756,7 +756,7 @@ base::Vector<byte> WasmCodeAllocator::AllocateForCodeInRegion(
 
   TRACE_HEAP("Code alloc for %p: 0x%" PRIxPTR ",+%zu\n", this,
              code_space.begin(), size);
-  return {reinterpret_cast<byte*>(code_space.begin()), code_space.size()};
+  return {reinterpret_cast<uint8_t*>(code_space.begin()), code_space.size()};
 }
 
 void WasmCodeAllocator::FreeCode(base::Vector<WasmCode* const> codes) {
@@ -909,22 +909,22 @@ CompilationEnv NativeModule::CreateCompilationEnv() const {
 WasmCode* NativeModule::AddCodeForTesting(Handle<Code> code) {
   CodeSpaceWriteScope code_space_write_scope(this);
   const size_t relocation_size = code->relocation_size();
-  base::OwnedVector<byte> reloc_info;
+  base::OwnedVector<uint8_t> reloc_info;
   if (relocation_size > 0) {
-    reloc_info = base::OwnedVector<byte>::Of(
-        base::Vector<byte>{code->relocation_start(), relocation_size});
+    reloc_info = base::OwnedVector<uint8_t>::Of(
+        base::Vector<uint8_t>{code->relocation_start(), relocation_size});
   }
   Handle<ByteArray> source_pos_table(code->source_position_table(),
                                      code->instruction_stream().GetIsolate());
-  base::OwnedVector<byte> source_pos =
-      base::OwnedVector<byte>::NewForOverwrite(source_pos_table->length());
+  base::OwnedVector<uint8_t> source_pos =
+      base::OwnedVector<uint8_t>::NewForOverwrite(source_pos_table->length());
   if (source_pos_table->length() > 0) {
     source_pos_table->copy_out(0, source_pos.begin(),
                                source_pos_table->length());
   }
   static_assert(InstructionStream::kOnHeapBodyIsContiguous);
-  base::Vector<const byte> instructions(
-      reinterpret_cast<byte*>(code->body_start()),
+  base::Vector<const uint8_t> instructions(
+      reinterpret_cast<uint8_t*>(code->body_start()),
       static_cast<size_t>(code->body_size()));
   const int stack_slots = code->stack_slots();
 
@@ -1051,11 +1051,11 @@ void NativeModule::UseLazyStubLocked(uint32_t func_index) {
 std::unique_ptr<WasmCode> NativeModule::AddCode(
     int index, const CodeDesc& desc, int stack_slots,
     uint32_t tagged_parameter_slots,
-    base::Vector<const byte> protected_instructions_data,
-    base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+    base::Vector<const uint8_t> protected_instructions_data,
+    base::Vector<const uint8_t> source_position_table, WasmCode::Kind kind,
     ExecutionTier tier, ForDebugging for_debugging) {
-  base::Vector<byte> code_space;
-  base::Vector<byte> inlining_positions;
+  base::Vector<uint8_t> code_space;
+  base::Vector<uint8_t> inlining_positions;
   NativeModule::JumpTablesRef jump_table_ref;
   {
     base::RecursiveMutexGuard guard{&allocation_mutex_};
@@ -1076,13 +1076,13 @@ std::unique_ptr<WasmCode> NativeModule::AddCode(
 std::unique_ptr<WasmCode> NativeModule::AddCodeWithCodeSpace(
     int index, const CodeDesc& desc, int stack_slots,
     uint32_t tagged_parameter_slots,
-    base::Vector<const byte> protected_instructions_data,
-    base::Vector<const byte> source_position_table,
-    base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
+    base::Vector<const uint8_t> protected_instructions_data,
+    base::Vector<const uint8_t> source_position_table,
+    base::Vector<const uint8_t> inlining_positions, WasmCode::Kind kind,
     ExecutionTier tier, ForDebugging for_debugging,
     bool frame_has_feedback_slot, base::Vector<uint8_t> dst_code_bytes,
     const JumpTablesRef& jump_tables) {
-  base::Vector<byte> reloc_info{
+  base::Vector<uint8_t> reloc_info{
       desc.buffer + desc.buffer_size - desc.reloc_size,
       static_cast<size_t>(desc.reloc_size)};
   UpdateCodeSize(desc.instr_size, tier, for_debugging);
@@ -1319,14 +1319,14 @@ NativeModule::AllocateForDeserializedCode(size_t total_code_size) {
 }
 
 std::unique_ptr<WasmCode> NativeModule::AddDeserializedCode(
-    int index, base::Vector<byte> instructions, int stack_slots,
+    int index, base::Vector<uint8_t> instructions, int stack_slots,
     uint32_t tagged_parameter_slots, int safepoint_table_offset,
     int handler_table_offset, int constant_pool_offset,
     int code_comments_offset, int unpadded_binary_size,
-    base::Vector<const byte> protected_instructions_data,
-    base::Vector<const byte> reloc_info,
-    base::Vector<const byte> source_position_table,
-    base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
+    base::Vector<const uint8_t> protected_instructions_data,
+    base::Vector<const uint8_t> reloc_info,
+    base::Vector<const uint8_t> source_position_table,
+    base::Vector<const uint8_t> inlining_positions, WasmCode::Kind kind,
     ExecutionTier tier) {
   UpdateCodeSize(instructions.size(), tier, kNotForDebugging);
 
@@ -1492,7 +1492,7 @@ void NativeModule::AddCodeSpaceLocked(base::AddressRegion region) {
   if (WasmCodeManager::CanRegisterUnwindInfoForNonABICompliantCodeRange()) {
     size_t size = Heap::GetCodeRangeReservedAreaSize();
     DCHECK_LT(0, size);
-    base::Vector<byte> padding =
+    base::Vector<uint8_t> padding =
         code_allocator_.AllocateForCodeInRegion(this, size, region);
     CHECK_EQ(reinterpret_cast<Address>(padding.begin()), region.begin());
     win64_unwindinfo::RegisterNonABICompliantCodeRange(
@@ -2246,7 +2246,7 @@ std::vector<std::unique_ptr<WasmCode>> NativeModule::AddCompiledCode(
     }
     total_code_space += new_code_space;
   }
-  base::Vector<byte> code_space;
+  base::Vector<uint8_t> code_space;
   NativeModule::JumpTablesRef jump_tables;
   CodeSpaceWriteScope code_space_write_scope(this);
   {
@@ -2266,7 +2266,7 @@ std::vector<std::unique_ptr<WasmCode>> NativeModule::AddCompiledCode(
   for (auto& result : results) {
     DCHECK_EQ(result.code_desc.buffer, result.instr_buffer->start());
     size_t code_size = RoundUp<kCodeAlignment>(result.code_desc.instr_size);
-    base::Vector<byte> this_code_space = code_space.SubVector(0, code_size);
+    base::Vector<uint8_t> this_code_space = code_space.SubVector(0, code_size);
     code_space += code_size;
     generated_code.emplace_back(AddCodeWithCodeSpace(
         result.func_index, result.code_desc, result.frame_slot_count,
diff --git a/src/wasm/wasm-code-manager.h b/src/wasm/wasm-code-manager.h
index fce45c6122..3e8f252c9a 100644
--- a/src/wasm/wasm-code-manager.h
+++ b/src/wasm/wasm-code-manager.h
@@ -273,21 +273,21 @@ class V8_EXPORT_PRIVATE WasmCode final {
   }
 #endif  // V8_IS_TSAN
 
-  base::Vector<byte> instructions() const {
+  base::Vector<uint8_t> instructions() const {
     return base::VectorOf(instructions_,
                           static_cast<size_t>(instructions_size_));
   }
   Address instruction_start() const {
     return reinterpret_cast<Address>(instructions_);
   }
-  base::Vector<const byte> reloc_info() const {
+  base::Vector<const uint8_t> reloc_info() const {
     return {protected_instructions_data().end(),
             static_cast<size_t>(reloc_info_size_)};
   }
-  base::Vector<const byte> source_positions() const {
+  base::Vector<const uint8_t> source_positions() const {
     return {reloc_info().end(), static_cast<size_t>(source_positions_size_)};
   }
-  base::Vector<const byte> inlining_positions() const {
+  base::Vector<const uint8_t> inlining_positions() const {
     return {source_positions().end(),
             static_cast<size_t>(inlining_positions_size_)};
   }
@@ -422,14 +422,14 @@ class V8_EXPORT_PRIVATE WasmCode final {
   friend class NativeModule;
 
   WasmCode(NativeModule* native_module, int index,
-           base::Vector<byte> instructions, int stack_slots,
+           base::Vector<uint8_t> instructions, int stack_slots,
            uint32_t tagged_parameter_slots, int safepoint_table_offset,
            int handler_table_offset, int constant_pool_offset,
            int code_comments_offset, int unpadded_binary_size,
-           base::Vector<const byte> protected_instructions_data,
-           base::Vector<const byte> reloc_info,
-           base::Vector<const byte> source_position_table,
-           base::Vector<const byte> inlining_positions, Kind kind,
+           base::Vector<const uint8_t> protected_instructions_data,
+           base::Vector<const uint8_t> reloc_info,
+           base::Vector<const uint8_t> source_position_table,
+           base::Vector<const uint8_t> inlining_positions, Kind kind,
            ExecutionTier tier, ForDebugging for_debugging,
            bool frame_has_feedback_slot = false)
       : native_module_(native_module),
@@ -459,8 +459,8 @@ class V8_EXPORT_PRIVATE WasmCode final {
     DCHECK_LE(constant_pool_offset, unpadded_binary_size);
   }
 
-  std::unique_ptr<const byte[]> ConcatenateBytes(
-      std::initializer_list<base::Vector<const byte>>);
+  std::unique_ptr<const uint8_t[]> ConcatenateBytes(
+      std::initializer_list<base::Vector<const uint8_t>>);
 
   // Tries to get a reasonable name. Lazily looks up the name section, and falls
   // back to the function index. Return value is guaranteed to not be empty.
@@ -488,13 +488,13 @@ class V8_EXPORT_PRIVATE WasmCode final {
   V8_NOINLINE bool DecRefOnPotentiallyDeadCode();
 
   NativeModule* const native_module_ = nullptr;
-  byte* const instructions_;
+  uint8_t* const instructions_;
   // {meta_data_} contains several byte vectors concatenated into one:
   //  - protected instructions data of size {protected_instructions_size_}
   //  - relocation info of size {reloc_info_size_}
   //  - source positions of size {source_positions_size_}
   // Note that the protected instructions come first to ensure alignment.
-  std::unique_ptr<const byte[]> meta_data_;
+  std::unique_ptr<const uint8_t[]> meta_data_;
   const int instructions_size_;
   const int reloc_info_size_;
   const int source_positions_size_;
@@ -561,13 +561,13 @@ class WasmCodeAllocator {
 
   // Allocate code space. Returns a valid buffer or fails with OOM (crash).
   // Hold the {NativeModule}'s {allocation_mutex_} when calling this method.
-  base::Vector<byte> AllocateForCode(NativeModule*, size_t size);
+  base::Vector<uint8_t> AllocateForCode(NativeModule*, size_t size);
 
   // Allocate code space within a specific region. Returns a valid buffer or
   // fails with OOM (crash).
   // Hold the {NativeModule}'s {allocation_mutex_} when calling this method.
-  base::Vector<byte> AllocateForCodeInRegion(NativeModule*, size_t size,
-                                             base::AddressRegion);
+  base::Vector<uint8_t> AllocateForCodeInRegion(NativeModule*, size_t size,
+                                                base::AddressRegion);
 
   // Free memory pages of all given code objects. Used for wasm code GC.
   // Hold the {NativeModule}'s {allocation_mutex_} when calling this method.
@@ -621,8 +621,8 @@ class V8_EXPORT_PRIVATE NativeModule final {
   std::unique_ptr<WasmCode> AddCode(
       int index, const CodeDesc& desc, int stack_slots,
       uint32_t tagged_parameter_slots,
-      base::Vector<const byte> protected_instructions,
-      base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+      base::Vector<const uint8_t> protected_instructions,
+      base::Vector<const uint8_t> source_position_table, WasmCode::Kind kind,
       ExecutionTier tier, ForDebugging for_debugging);
 
   // {PublishCode} makes the code available to the system by entering it into
@@ -652,14 +652,14 @@ class V8_EXPORT_PRIVATE NativeModule final {
       size_t total_code_size);
 
   std::unique_ptr<WasmCode> AddDeserializedCode(
-      int index, base::Vector<byte> instructions, int stack_slots,
+      int index, base::Vector<uint8_t> instructions, int stack_slots,
       uint32_t tagged_parameter_slots, int safepoint_table_offset,
       int handler_table_offset, int constant_pool_offset,
       int code_comments_offset, int unpadded_binary_size,
-      base::Vector<const byte> protected_instructions_data,
-      base::Vector<const byte> reloc_info,
-      base::Vector<const byte> source_position_table,
-      base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
+      base::Vector<const uint8_t> protected_instructions_data,
+      base::Vector<const uint8_t> reloc_info,
+      base::Vector<const uint8_t> source_position_table,
+      base::Vector<const uint8_t> inlining_positions, WasmCode::Kind kind,
       ExecutionTier tier);
 
   // Adds anonymous code for testing purposes.
@@ -882,9 +882,9 @@ class V8_EXPORT_PRIVATE NativeModule final {
   std::unique_ptr<WasmCode> AddCodeWithCodeSpace(
       int index, const CodeDesc& desc, int stack_slots,
       uint32_t tagged_parameter_slots,
-      base::Vector<const byte> protected_instructions_data,
-      base::Vector<const byte> source_position_table,
-      base::Vector<const byte> inlining_positions, WasmCode::Kind kind,
+      base::Vector<const uint8_t> protected_instructions_data,
+      base::Vector<const uint8_t> source_position_table,
+      base::Vector<const uint8_t> inlining_positions, WasmCode::Kind kind,
       ExecutionTier tier, ForDebugging for_debugging,
       bool frame_has_feedback_slot, base::Vector<uint8_t> code_space,
       const JumpTablesRef& jump_tables_ref);
diff --git a/src/wasm/wasm-debug.cc b/src/wasm/wasm-debug.cc
index 3386b0f6ea..0b131e0e0d 100644
--- a/src/wasm/wasm-debug.cc
+++ b/src/wasm/wasm-debug.cc
@@ -788,14 +788,14 @@ namespace {
 
 // Return the next breakable position at or after {offset_in_func} in function
 // {func_index}, or 0 if there is none.
-// Note that 0 is never a breakable position in wasm, since the first byte
+// Note that 0 is never a breakable position in wasm, since the first uint8_t
 // contains the locals count for the function.
 int FindNextBreakablePosition(wasm::NativeModule* native_module, int func_index,
                               int offset_in_func) {
   AccountingAllocator alloc;
   Zone tmp(&alloc, ZONE_NAME);
   wasm::BodyLocalDecls locals;
-  const byte* module_start = native_module->wire_bytes().begin();
+  const uint8_t* module_start = native_module->wire_bytes().begin();
   const wasm::WasmFunction& func =
       native_module->module()->functions[func_index];
   wasm::BytecodeIterator iterator(module_start + func.code.offset(),
@@ -1103,7 +1103,7 @@ bool WasmScript::GetPossibleBreakpoints(
     return false;
   AccountingAllocator alloc;
   Zone tmp(&alloc, ZONE_NAME);
-  const byte* module_start = native_module->wire_bytes().begin();
+  const uint8_t* module_start = native_module->wire_bytes().begin();
 
   for (int func_idx = start_func_index; func_idx <= end_func_index;
        ++func_idx) {
diff --git a/src/wasm/wasm-disassembler-impl.h b/src/wasm/wasm-disassembler-impl.h
index 56f9a3433f..cbb80ec93b 100644
--- a/src/wasm/wasm-disassembler-impl.h
+++ b/src/wasm/wasm-disassembler-impl.h
@@ -81,8 +81,8 @@ class V8_EXPORT_PRIVATE FunctionBodyDisassembler
 
   FunctionBodyDisassembler(Zone* zone, const WasmModule* module,
                            uint32_t func_index, WasmFeatures* detected,
-                           const FunctionSig* sig, const byte* start,
-                           const byte* end, uint32_t offset,
+                           const FunctionSig* sig, const uint8_t* start,
+                           const uint8_t* end, uint32_t offset,
                            const ModuleWireBytes wire_bytes,
                            NamesProvider* names)
       : WasmDecoder<ValidationTag>(zone, module, WasmFeatures::All(), detected,
@@ -165,7 +165,7 @@ class ModuleDisassembler {
   const WasmModule* module_;
   NamesProvider* names_;
   const ModuleWireBytes wire_bytes_;
-  const byte* start_;
+  const uint8_t* start_;
   Zone zone_;
   std::unique_ptr<OffsetsProvider> offsets_;
   std::vector<int>* function_body_offsets_;
diff --git a/src/wasm/wasm-disassembler.cc b/src/wasm/wasm-disassembler.cc
index 46a5ac4f4c..be6c5c4a84 100644
--- a/src/wasm/wasm-disassembler.cc
+++ b/src/wasm/wasm-disassembler.cc
@@ -145,9 +145,10 @@ void PrintSignatureOneLine(StringBuilder& out, const FunctionSig* sig,
   }
 }
 
-void PrintStringRaw(StringBuilder& out, const byte* start, const byte* end) {
-  for (const byte* ptr = start; ptr < end; ptr++) {
-    byte b = *ptr;
+void PrintStringRaw(StringBuilder& out, const uint8_t* start,
+                    const uint8_t* end) {
+  for (const uint8_t* ptr = start; ptr < end; ptr++) {
+    uint8_t b = *ptr;
     if (b < 32 || b >= 127 || b == '"' || b == '\\') {
       out << '\\' << kHexChars[b >> 4] << kHexChars[b & 0xF];
     } else {
@@ -348,7 +349,7 @@ class ImmediatesPrinter {
   void BranchDepth(BranchDepthImmediate& imm) { PrintDepthAsLabel(imm.depth); }
 
   void BranchTable(BranchTableImmediate& imm) {
-    const byte* pc = imm.table;
+    const uint8_t* pc = imm.table;
     for (uint32_t i = 0; i <= imm.table_count; i++) {
       auto [target, length] = owner_->read_u32v<ValidationTag>(pc);
       PrintDepthAsLabel(target);
@@ -523,13 +524,14 @@ class ImmediatesPrinter {
     out_ << " \"";
     const WasmStringRefLiteral& lit =
         owner_->module_->stringref_literals[imm.index];
-    const byte* start = owner_->wire_bytes_.start() + lit.source.offset();
+    const uint8_t* start = owner_->wire_bytes_.start() + lit.source.offset();
     static constexpr uint32_t kMaxCharsPrinted = 40;
     if (lit.source.length() <= kMaxCharsPrinted) {
-      const byte* end = owner_->wire_bytes_.start() + lit.source.end_offset();
+      const uint8_t* end =
+          owner_->wire_bytes_.start() + lit.source.end_offset();
       PrintStringRaw(out_, start, end);
     } else {
-      const byte* end = start + kMaxCharsPrinted - 1;
+      const uint8_t* end = start + kMaxCharsPrinted - 1;
       PrintStringRaw(out_, start, end);
       out_ << "";
     }
@@ -652,7 +654,7 @@ class OffsetsProvider : public ITracer {
 
   // Unused by this tracer:
   void ImportsDone() override {}
-  void Bytes(const byte* start, uint32_t count) override {}
+  void Bytes(const uint8_t* start, uint32_t count) override {}
   void Description(const char* desc) override {}
   void Description(const char* desc, size_t length) override {}
   void Description(uint32_t number) override {}
@@ -662,11 +664,11 @@ class OffsetsProvider : public ITracer {
   void NextLine() override {}
   void NextLineIfFull() override {}
   void NextLineIfNonEmpty() override {}
-  void InitializerExpression(const byte* start, const byte* end,
+  void InitializerExpression(const uint8_t* start, const uint8_t* end,
                              ValueType expected_type) override {}
-  void FunctionBody(const WasmFunction* func, const byte* start) override {}
+  void FunctionBody(const WasmFunction* func, const uint8_t* start) override {}
   void FunctionName(uint32_t func_index) override {}
-  void NameSection(const byte* start, const byte* end,
+  void NameSection(const uint8_t* start, const uint8_t* end,
                    uint32_t offset) override {}
 
 #define GETTER(name)                       \
@@ -812,7 +814,7 @@ void ModuleDisassembler::PrintModule(Indentation indentation, size_t max_mb) {
   out_ << indentation << "(module";
   if (module_->name.is_set()) {
     out_ << " $";
-    const byte* name_start = start_ + module_->name.offset();
+    const uint8_t* name_start = start_ + module_->name.offset();
     out_.write(name_start, module_->name.length());
   }
   indentation.increase();
@@ -1007,7 +1009,7 @@ void ModuleDisassembler::PrintModule(Indentation indentation, size_t max_mb) {
     PrintSignatureOneLine(out_, func->sig, i, names_, true, kIndicesAsComments);
     out_.NextLine(func->code.offset());
     WasmFeatures detected;
-    base::Vector<const byte> code = wire_bytes_.GetFunctionBytes(func);
+    base::Vector<const uint8_t> code = wire_bytes_.GetFunctionBytes(func);
     FunctionBodyDisassembler d(&zone_, module_, i, &detected, func->sig,
                                code.begin(), code.end(), func->code.offset(),
                                wire_bytes_, names_);
@@ -1116,8 +1118,8 @@ void ModuleDisassembler::PrintInitExpression(const ConstantExpression& init,
       break;
     case ConstantExpression::kWireBytesRef:
       WireBytesRef ref = init.wire_bytes_ref();
-      const byte* start = start_ + ref.offset();
-      const byte* end = start_ + ref.end_offset();
+      const uint8_t* start = start_ + ref.offset();
+      const uint8_t* end = start_ + ref.end_offset();
 
       auto sig = FixedSizeSignature<ValueType>::Returns(expected_type);
       WasmFeatures detected;
@@ -1143,9 +1145,9 @@ void ModuleDisassembler::PrintString(WireBytesRef ref) {
 // This mimics legacy wasmparser behavior. It might be a questionable choice,
 // but we'll follow suit for now.
 void ModuleDisassembler::PrintStringAsJSON(WireBytesRef ref) {
-  for (const byte* ptr = start_ + ref.offset(); ptr < start_ + ref.end_offset();
-       ptr++) {
-    byte b = *ptr;
+  for (const uint8_t* ptr = start_ + ref.offset();
+       ptr < start_ + ref.end_offset(); ptr++) {
+    uint8_t b = *ptr;
     if (b <= 34) {
       switch (b) {
         // clang-format off
diff --git a/src/wasm/wasm-engine.cc b/src/wasm/wasm-engine.cc
index 1712e534cd..f2f7672615 100644
--- a/src/wasm/wasm-engine.cc
+++ b/src/wasm/wasm-engine.cc
@@ -483,7 +483,7 @@ bool WasmEngine::SyncValidate(Isolate* isolate, const WasmFeatures& enabled,
 
 MaybeHandle<AsmWasmData> WasmEngine::SyncCompileTranslatedAsmJs(
     Isolate* isolate, ErrorThrower* thrower, ModuleWireBytes bytes,
-    base::Vector<const byte> asm_js_offset_table_bytes,
+    base::Vector<const uint8_t> asm_js_offset_table_bytes,
     Handle<HeapNumber> uses_bitset, LanguageMode language_mode) {
   int compilation_id = next_compilation_id_.fetch_add(1);
   TRACE_EVENT1("v8.wasm", "wasm.SyncCompileTranslatedAsmJs", "id",
diff --git a/src/wasm/wasm-engine.h b/src/wasm/wasm-engine.h
index e941958e47..a6b3b0e7e3 100644
--- a/src/wasm/wasm-engine.h
+++ b/src/wasm/wasm-engine.h
@@ -156,7 +156,7 @@ class V8_EXPORT_PRIVATE WasmEngine {
   // asm.js module.
   MaybeHandle<AsmWasmData> SyncCompileTranslatedAsmJs(
       Isolate* isolate, ErrorThrower* thrower, ModuleWireBytes bytes,
-      base::Vector<const byte> asm_js_offset_table_bytes,
+      base::Vector<const uint8_t> asm_js_offset_table_bytes,
       Handle<HeapNumber> uses_bitset, LanguageMode language_mode);
   Handle<WasmModuleObject> FinalizeTranslatedAsmJs(
       Isolate* isolate, Handle<AsmWasmData> asm_wasm_data,
diff --git a/src/wasm/wasm-external-refs.cc b/src/wasm/wasm-external-refs.cc
index 7ebd6afebb..ee474961e2 100644
--- a/src/wasm/wasm-external-refs.cc
+++ b/src/wasm/wasm-external-refs.cc
@@ -459,7 +459,7 @@ class V8_NODISCARD ThreadNotInWasmScope {
 #endif
 };
 
-inline byte* EffectiveAddress(WasmInstanceObject instance, uintptr_t index) {
+inline uint8_t* EffectiveAddress(WasmInstanceObject instance, uintptr_t index) {
   // TODO(13918): Support multiple memories.
   return instance.memory0_start() + index;
 }
@@ -493,8 +493,8 @@ int32_t memory_init_wrapper(Address data) {
   uint32_t seg_size = instance.data_segment_sizes().get(seg_index);
   if (!base::IsInBounds<uint32_t>(src, size, seg_size)) return kOutOfBounds;
 
-  byte* seg_start =
-      reinterpret_cast<byte*>(instance.data_segment_starts().get(seg_index));
+  uint8_t* seg_start =
+      reinterpret_cast<uint8_t*>(instance.data_segment_starts().get(seg_index));
   std::memcpy(EffectiveAddress(instance, dst), seg_start + src, size);
   return kSuccess;
 }
diff --git a/src/wasm/wasm-module-builder.cc b/src/wasm/wasm-module-builder.cc
index ec838f4b12..26d02d1e14 100644
--- a/src/wasm/wasm-module-builder.cc
+++ b/src/wasm/wasm-module-builder.cc
@@ -48,7 +48,7 @@ WasmFunctionBuilder::WasmFunctionBuilder(WasmModuleBuilder* builder)
       direct_calls_(builder->zone()),
       asm_offsets_(builder->zone(), 8) {}
 
-void WasmFunctionBuilder::EmitByte(byte val) { body_.write_u8(val); }
+void WasmFunctionBuilder::EmitByte(uint8_t val) { body_.write_u8(val); }
 
 void WasmFunctionBuilder::EmitI32V(int32_t val) { body_.write_i32v(val); }
 
@@ -84,7 +84,7 @@ void WasmFunctionBuilder::EmitTeeLocal(uint32_t local_index) {
   EmitWithU32V(kExprLocalTee, local_index);
 }
 
-void WasmFunctionBuilder::EmitCode(const byte* code, uint32_t code_size) {
+void WasmFunctionBuilder::EmitCode(const uint8_t* code, uint32_t code_size) {
   body_.write(code, code_size);
 }
 
@@ -105,13 +105,14 @@ void WasmFunctionBuilder::EmitWithPrefix(WasmOpcode opcode) {
   }
 }
 
-void WasmFunctionBuilder::EmitWithU8(WasmOpcode opcode, const byte immediate) {
+void WasmFunctionBuilder::EmitWithU8(WasmOpcode opcode,
+                                     const uint8_t immediate) {
   body_.write_u8(opcode);
   body_.write_u8(immediate);
 }
 
-void WasmFunctionBuilder::EmitWithU8U8(WasmOpcode opcode, const byte imm1,
-                                       const byte imm2) {
+void WasmFunctionBuilder::EmitWithU8U8(WasmOpcode opcode, const uint8_t imm1,
+                                       const uint8_t imm2) {
   body_.write_u8(opcode);
   body_.write_u8(imm1);
   body_.write_u8(imm2);
@@ -167,7 +168,7 @@ void WasmFunctionBuilder::EmitDirectCallIndex(uint32_t index) {
   call.offset = body_.size();
   call.direct_index = index;
   direct_calls_.push_back(call);
-  byte placeholder_bytes[kMaxVarInt32Size] = {0};
+  uint8_t placeholder_bytes[kMaxVarInt32Size] = {0};
   EmitCode(placeholder_bytes, arraysize(placeholder_bytes));
 }
 
@@ -229,7 +230,7 @@ void WasmFunctionBuilder::WriteBody(ZoneBuffer* buffer) const {
   size_t locals_size = locals_.Size();
   buffer->write_size(locals_size + body_.size());
   buffer->EnsureSpace(locals_size);
-  byte** ptr = buffer->pos_ptr();
+  uint8_t** ptr = buffer->pos_ptr();
   locals_.Emit(*ptr);
   (*ptr) += locals_size;  // UGLY: manual bump of position pointer
   if (body_.size() > 0) {
@@ -295,10 +296,10 @@ WasmFunctionBuilder* WasmModuleBuilder::AddFunction(uint32_t sig_index) {
   return functions_.back();
 }
 
-void WasmModuleBuilder::AddDataSegment(const byte* data, uint32_t size,
+void WasmModuleBuilder::AddDataSegment(const uint8_t* data, uint32_t size,
                                        uint32_t dest) {
-  data_segments_.push_back({ZoneVector<byte>(zone()), dest});
-  ZoneVector<byte>& vec = data_segments_.back().data;
+  data_segments_.push_back({ZoneVector<uint8_t>(zone()), dest});
+  ZoneVector<uint8_t>& vec = data_segments_.back().data;
   for (uint32_t i = 0; i < size; i++) {
     vec.push_back(data[i]);
   }
@@ -555,8 +556,8 @@ void WriteInitializerExpressionWithEnd(ZoneBuffer* buffer,
           buffer->write_i32v(type.heap_type().code());
           break;
         case kS128:
-          buffer->write_u8(static_cast<byte>(kSimdPrefix));
-          buffer->write_u8(static_cast<byte>(kExprS128Const & 0xff));
+          buffer->write_u8(static_cast<uint8_t>(kSimdPrefix));
+          buffer->write_u8(static_cast<uint8_t>(kExprS128Const & 0xff));
           for (int i = 0; i < kSimd128Size; i++) buffer->write_u8(0);
           break;
         case kI8:
diff --git a/src/wasm/wasm-module-builder.h b/src/wasm/wasm-module-builder.h
index dbf29bd429..9df3486137 100644
--- a/src/wasm/wasm-module-builder.h
+++ b/src/wasm/wasm-module-builder.h
@@ -32,7 +32,7 @@ class ZoneBuffer : public ZoneObject {
 
   static constexpr size_t kInitialSize = 1024;
   explicit ZoneBuffer(Zone* zone, size_t initial = kInitialSize)
-      : zone_(zone), buffer_(zone->NewArray<byte, Buffer>(initial)) {
+      : zone_(zone), buffer_(zone->NewArray<uint8_t, Buffer>(initial)) {
     pos_ = buffer_;
     end_ = buffer_ + initial;
   }
@@ -90,7 +90,7 @@ class ZoneBuffer : public ZoneObject {
 
   void write_f64(double val) { write_u64(base::bit_cast<uint64_t>(val)); }
 
-  void write(const byte* data, size_t size) {
+  void write(const uint8_t* data, size_t size) {
     if (size == 0) return;
     EnsureSpace(size);
     memcpy(pos_, data, size);
@@ -99,7 +99,7 @@ class ZoneBuffer : public ZoneObject {
 
   void write_string(base::Vector<const char> name) {
     write_size(name.length());
-    write(reinterpret_cast<const byte*>(name.begin()), name.length());
+    write(reinterpret_cast<const uint8_t*>(name.begin()), name.length());
   }
 
   size_t reserve_u32v() {
@@ -111,10 +111,10 @@ class ZoneBuffer : public ZoneObject {
 
   // Patch a (padded) u32v at the given offset to be the given value.
   void patch_u32v(size_t offset, uint32_t val) {
-    byte* ptr = buffer_ + offset;
+    uint8_t* ptr = buffer_ + offset;
     for (size_t pos = 0; pos != kPaddedVarInt32Size; ++pos) {
       uint32_t next = val >> 7;
-      byte out = static_cast<byte>(val & 0x7f);
+      uint8_t out = static_cast<uint8_t>(val & 0x7f);
       if (pos != kPaddedVarInt32Size - 1) {
         *(ptr++) = 0x80 | out;
         val = next;
@@ -124,21 +124,21 @@ class ZoneBuffer : public ZoneObject {
     }
   }
 
-  void patch_u8(size_t offset, byte val) {
+  void patch_u8(size_t offset, uint8_t val) {
     DCHECK_GE(size(), offset);
     buffer_[offset] = val;
   }
 
   size_t offset() const { return static_cast<size_t>(pos_ - buffer_); }
   size_t size() const { return static_cast<size_t>(pos_ - buffer_); }
-  const byte* data() const { return buffer_; }
-  const byte* begin() const { return buffer_; }
-  const byte* end() const { return pos_; }
+  const uint8_t* data() const { return buffer_; }
+  const uint8_t* begin() const { return buffer_; }
+  const uint8_t* end() const { return pos_; }
 
   void EnsureSpace(size_t size) {
     if ((pos_ + size) > end_) {
       size_t new_size = size + (end_ - buffer_) * 2;
-      byte* new_buffer = zone_->NewArray<byte, Buffer>(new_size);
+      uint8_t* new_buffer = zone_->NewArray<uint8_t, Buffer>(new_size);
       memcpy(new_buffer, buffer_, (pos_ - buffer_));
       pos_ = new_buffer + (pos_ - buffer_);
       buffer_ = new_buffer;
@@ -152,13 +152,13 @@ class ZoneBuffer : public ZoneObject {
     pos_ = buffer_ + size;
   }
 
-  byte** pos_ptr() { return &pos_; }
+  uint8_t** pos_ptr() { return &pos_; }
 
  private:
   Zone* zone_;
-  byte* buffer_;
-  byte* pos_;
-  byte* end_;
+  uint8_t* buffer_;
+  uint8_t* pos_;
+  uint8_t* end_;
 };
 
 class WasmModuleBuilder;
@@ -169,10 +169,10 @@ class V8_EXPORT_PRIVATE WasmFunctionBuilder : public ZoneObject {
   void SetSignature(const FunctionSig* sig);
   void SetSignature(uint32_t sig_index);
   uint32_t AddLocal(ValueType type);
-  void EmitByte(byte b);
+  void EmitByte(uint8_t b);
   void EmitI32V(int32_t val);
   void EmitU32V(uint32_t val);
-  void EmitCode(const byte* code, uint32_t code_size);
+  void EmitCode(const uint8_t* code, uint32_t code_size);
   void Emit(WasmOpcode opcode);
   void EmitWithPrefix(WasmOpcode opcode);
   void EmitGetLocal(uint32_t index);
@@ -183,8 +183,8 @@ class V8_EXPORT_PRIVATE WasmFunctionBuilder : public ZoneObject {
   void EmitF32Const(float val);
   void EmitF64Const(double val);
   void EmitS128Const(Simd128 val);
-  void EmitWithU8(WasmOpcode opcode, const byte immediate);
-  void EmitWithU8U8(WasmOpcode opcode, const byte imm1, const byte imm2);
+  void EmitWithU8(WasmOpcode opcode, const uint8_t immediate);
+  void EmitWithU8U8(WasmOpcode opcode, const uint8_t imm1, const uint8_t imm2);
   void EmitWithI32V(WasmOpcode opcode, int32_t immediate);
   void EmitWithU32V(WasmOpcode opcode, uint32_t immediate);
   void EmitValueType(ValueType type);
@@ -197,7 +197,7 @@ class V8_EXPORT_PRIVATE WasmFunctionBuilder : public ZoneObject {
                           WasmCompilationHintTier top_tier);
 
   size_t GetPosition() const { return body_.size(); }
-  void FixupByte(size_t position, byte value) {
+  void FixupByte(size_t position, uint8_t value) {
     body_.patch_u8(position, value);
   }
   void DeleteCodeAfter(size_t position);
@@ -319,7 +319,7 @@ class V8_EXPORT_PRIVATE WasmModuleBuilder : public ZoneObject {
   uint32_t AddGlobalImport(base::Vector<const char> name, ValueType type,
                            bool mutability,
                            base::Vector<const char> module = {});
-  void AddDataSegment(const byte* data, uint32_t size, uint32_t dest);
+  void AddDataSegment(const uint8_t* data, uint32_t size, uint32_t dest);
   // Add an element segment to this {WasmModuleBuilder}. {segment}'s enties
   // have to be initialized.
   void AddElementSegment(WasmElemSegment segment);
@@ -456,7 +456,7 @@ class V8_EXPORT_PRIVATE WasmModuleBuilder : public ZoneObject {
   };
 
   struct WasmDataSegment {
-    ZoneVector<byte> data;
+    ZoneVector<uint8_t> data;
     uint32_t dest;
   };
 
diff --git a/src/wasm/wasm-module.cc b/src/wasm/wasm-module.cc
index ffcefc9b93..ec3f49c525 100644
--- a/src/wasm/wasm-module.cc
+++ b/src/wasm/wasm-module.cc
@@ -133,7 +133,7 @@ void LazilyGeneratedNames::AddForTesting(int function_index,
 }
 
 AsmJsOffsetInformation::AsmJsOffsetInformation(
-    base::Vector<const byte> encoded_offsets)
+    base::Vector<const uint8_t> encoded_offsets)
     : encoded_offsets_(base::OwnedVector<const uint8_t>::Of(encoded_offsets)) {}
 
 AsmJsOffsetInformation::~AsmJsOffsetInformation() = default;
diff --git a/src/wasm/wasm-module.h b/src/wasm/wasm-module.h
index bc96893274..6046d1b884 100644
--- a/src/wasm/wasm-module.h
+++ b/src/wasm/wasm-module.h
@@ -318,7 +318,7 @@ class V8_EXPORT_PRIVATE LazilyGeneratedNames {
 
 class V8_EXPORT_PRIVATE AsmJsOffsetInformation {
  public:
-  explicit AsmJsOffsetInformation(base::Vector<const byte> encoded_offsets);
+  explicit AsmJsOffsetInformation(base::Vector<const uint8_t> encoded_offsets);
 
   // Destructor defined in wasm-module.cc, where the definition of
   // {AsmJsOffsets} is available.
@@ -760,12 +760,12 @@ V8_EXPORT_PRIVATE int GetSubtypingDepth(const WasmModule* module,
 // It is illegal for anyone receiving a ModuleWireBytes to store pointers based
 // on module_bytes, as this storage is only guaranteed to be alive as long as
 // this struct is alive.
-// As {ModuleWireBytes} is just a wrapper around a {base::Vector<const byte>},
-// it should generally be passed by value.
+// As {ModuleWireBytes} is just a wrapper around a {base::Vector<const
+// uint8_t>}, it should generally be passed by value.
 struct V8_EXPORT_PRIVATE ModuleWireBytes {
-  explicit ModuleWireBytes(base::Vector<const byte> module_bytes)
+  explicit ModuleWireBytes(base::Vector<const uint8_t> module_bytes)
       : module_bytes_(module_bytes) {}
-  ModuleWireBytes(const byte* start, const byte* end)
+  ModuleWireBytes(const uint8_t* start, const uint8_t* end)
       : module_bytes_(start, static_cast<int>(end - start)) {
     DCHECK_GE(kMaxInt, end - start);
   }
@@ -782,19 +782,19 @@ struct V8_EXPORT_PRIVATE ModuleWireBytes {
     return ref.offset() <= size && ref.length() <= size - ref.offset();
   }
 
-  base::Vector<const byte> GetFunctionBytes(
+  base::Vector<const uint8_t> GetFunctionBytes(
       const WasmFunction* function) const {
     return module_bytes_.SubVector(function->code.offset(),
                                    function->code.end_offset());
   }
 
-  base::Vector<const byte> module_bytes() const { return module_bytes_; }
-  const byte* start() const { return module_bytes_.begin(); }
-  const byte* end() const { return module_bytes_.end(); }
+  base::Vector<const uint8_t> module_bytes() const { return module_bytes_; }
+  const uint8_t* start() const { return module_bytes_.begin(); }
+  const uint8_t* end() const { return module_bytes_.end(); }
   size_t length() const { return module_bytes_.length(); }
 
  private:
-  base::Vector<const byte> module_bytes_;
+  base::Vector<const uint8_t> module_bytes_;
 };
 ASSERT_TRIVIALLY_COPYABLE(ModuleWireBytes);
 
@@ -862,7 +862,7 @@ class TruncatedUserString {
   explicit TruncatedUserString(base::Vector<T> name)
       : TruncatedUserString(name.begin(), name.length()) {}
 
-  TruncatedUserString(const byte* start, size_t len)
+  TruncatedUserString(const uint8_t* start, size_t len)
       : TruncatedUserString(reinterpret_cast<const char*>(start), len) {}
 
   TruncatedUserString(const char* start, size_t len)
diff --git a/src/wasm/wasm-objects-inl.h b/src/wasm/wasm-objects-inl.h
index 8682180fcc..5f2b6c8664 100644
--- a/src/wasm/wasm-objects-inl.h
+++ b/src/wasm/wasm-objects-inl.h
@@ -146,8 +146,8 @@ double WasmGlobalObject::GetF64() {
   return base::ReadUnalignedValue<double>(address());
 }
 
-byte* WasmGlobalObject::GetS128RawBytes() {
-  return reinterpret_cast<byte*>(address());
+uint8_t* WasmGlobalObject::GetS128RawBytes() {
+  return reinterpret_cast<uint8_t*>(address());
 }
 
 Handle<Object> WasmGlobalObject::GetRef() {
@@ -196,7 +196,7 @@ PRIMITIVE_ACCESSORS(WasmInstanceObject, old_allocation_top_address, Address*,
                     kOldAllocationTopAddressOffset)
 PRIMITIVE_ACCESSORS(WasmInstanceObject, isorecursive_canonical_types,
                     const uint32_t*, kIsorecursiveCanonicalTypesOffset)
-SANDBOXED_POINTER_ACCESSORS(WasmInstanceObject, globals_start, byte*,
+SANDBOXED_POINTER_ACCESSORS(WasmInstanceObject, globals_start, uint8_t*,
                             kGlobalsStartOffset)
 ACCESSORS(WasmInstanceObject, imported_mutable_globals, FixedAddressArray,
           kImportedMutableGlobalsOffset)
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 660089e771..3ff6da806f 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -720,17 +720,17 @@ void SetInstanceMemory(Handle<WasmInstanceObject> instance,
                 buffer->GetBackingStore()->has_guard_regions());
 
   // TODO(13918): Support multiple memories.
-  instance->SetRawMemory(0, reinterpret_cast<byte*>(buffer->backing_store()),
+  instance->SetRawMemory(0, reinterpret_cast<uint8_t*>(buffer->backing_store()),
                          buffer->byte_length());
 #if DEBUG
   if (!v8_flags.mock_arraybuffer_allocator) {
     // To flush out bugs earlier, in DEBUG mode, check that all pages of the
     // memory are accessible by reading and writing one byte on each page.
     // Don't do this if the mock ArrayBuffer allocator is enabled.
-    byte* mem_start = instance->memory0_start();
+    uint8_t* mem_start = instance->memory0_start();
     size_t mem_size = instance->memory0_size();
     for (size_t offset = 0; offset < mem_size; offset += wasm::kWasmPageSize) {
-      byte val = mem_start[offset];
+      uint8_t val = mem_start[offset];
       USE(val);
       mem_start[offset] = val;
     }
@@ -1103,7 +1103,7 @@ bool WasmInstanceObject::EnsureIndirectFunctionTableWithMinimumSize(
   return true;
 }
 
-void WasmInstanceObject::SetRawMemory(int memory_index, byte* mem_start,
+void WasmInstanceObject::SetRawMemory(int memory_index, uint8_t* mem_start,
                                       size_t mem_size) {
   // TODO(13918): Support multiple memories.
   CHECK_EQ(0, memory_index);
@@ -1172,7 +1172,7 @@ Handle<WasmInstanceObject> WasmInstanceObject::New(
   instance->set_old_allocation_top_address(
       isolate->heap()->OldSpaceAllocationTopAddress());
   instance->set_globals_start(
-      reinterpret_cast<byte*>(EmptyBackingStoreBuffer()));
+      reinterpret_cast<uint8_t*>(EmptyBackingStoreBuffer()));
   instance->set_indirect_function_table_size(0);
   instance->set_indirect_function_table_refs(
       ReadOnlyRoots(isolate).empty_fixed_array());
@@ -1194,8 +1194,8 @@ Handle<WasmInstanceObject> WasmInstanceObject::New(
   instance->set_tiering_budget_array(
       module_object->native_module()->tiering_budget_array());
   instance->set_break_on_entry(module_object->script().break_on_entry());
-  instance->SetRawMemory(0, reinterpret_cast<byte*>(EmptyBackingStoreBuffer()),
-                         0);
+  instance->SetRawMemory(
+      0, reinterpret_cast<uint8_t*>(EmptyBackingStoreBuffer()), 0);
 
   // Insert the new instance into the scripts weak list of instances. This list
   // is used for breakpoints affecting all instances belonging to the script.
@@ -1527,7 +1527,7 @@ uint8_t* WasmInstanceObject::GetGlobalStorage(
     Handle<WasmInstanceObject> instance, const wasm::WasmGlobal& global) {
   DCHECK(!global.type.is_reference());
   if (global.mutability && global.imported) {
-    return reinterpret_cast<byte*>(
+    return reinterpret_cast<uint8_t*>(
         instance->imported_mutable_globals().get_sandboxed_pointer(
             global.index));
   } else {
diff --git a/src/wasm/wasm-objects.h b/src/wasm/wasm-objects.h
index 42deac47df..b0469cc24e 100644
--- a/src/wasm/wasm-objects.h
+++ b/src/wasm/wasm-objects.h
@@ -304,7 +304,7 @@ class WasmGlobalObject
   inline int64_t GetI64();
   inline float GetF32();
   inline double GetF64();
-  inline byte* GetS128RawBytes();
+  inline uint8_t* GetS128RawBytes();
   inline Handle<Object> GetRef();
 
   inline void SetI32(int32_t value);
@@ -356,7 +356,7 @@ class V8_EXPORT_PRIVATE WasmInstanceObject : public JSObject {
   DECL_PRIMITIVE_ACCESSORS(old_allocation_limit_address, Address*)
   DECL_PRIMITIVE_ACCESSORS(old_allocation_top_address, Address*)
   DECL_PRIMITIVE_ACCESSORS(isorecursive_canonical_types, const uint32_t*)
-  DECL_SANDBOXED_POINTER_ACCESSORS(globals_start, byte*)
+  DECL_SANDBOXED_POINTER_ACCESSORS(globals_start, uint8_t*)
   DECL_PRIMITIVE_ACCESSORS(indirect_function_table_size, uint32_t)
   DECL_PRIMITIVE_ACCESSORS(jump_table_start, Address)
   DECL_PRIMITIVE_ACCESSORS(hook_on_function_call_address, Address)
@@ -469,7 +469,7 @@ class V8_EXPORT_PRIVATE WasmInstanceObject : public JSObject {
       Handle<WasmInstanceObject> instance, int table_index,
       uint32_t minimum_size);
 
-  void SetRawMemory(int memory_index, byte* mem_start, size_t mem_size);
+  void SetRawMemory(int memory_index, uint8_t* mem_start, size_t mem_size);
 
   static Handle<WasmInstanceObject> New(Isolate*, Handle<WasmModuleObject>);
 
diff --git a/src/wasm/wasm-opcodes-inl.h b/src/wasm/wasm-opcodes-inl.h
index 1b1c9ae238..6af3e83765 100644
--- a/src/wasm/wasm-opcodes-inl.h
+++ b/src/wasm/wasm-opcodes-inl.h
@@ -136,7 +136,7 @@ constexpr bool WasmOpcodes::IsRelaxedSimdOpcode(WasmOpcode opcode) {
   return (opcode & 0xfff00) == 0xfd100;
 }
 
-constexpr byte WasmOpcodes::ExtractPrefix(WasmOpcode opcode) {
+constexpr uint8_t WasmOpcodes::ExtractPrefix(WasmOpcode opcode) {
   // See comment on {WasmOpcode} for the encoding.
   return (opcode > 0xffff) ? opcode >> 12 : opcode >> 8;
 }
@@ -144,7 +144,7 @@ constexpr byte WasmOpcodes::ExtractPrefix(WasmOpcode opcode) {
 namespace impl {
 
 #define DECLARE_SIG_ENUM(name, ...) kSigEnum_##name,
-enum WasmOpcodeSig : byte {
+enum WasmOpcodeSig : uint8_t {
   kSigEnum_None,
   FOREACH_SIGNATURE(DECLARE_SIG_ENUM)
 };
@@ -163,40 +163,40 @@ constexpr const FunctionSig* kCachedSigs[] = {
     nullptr, FOREACH_SIGNATURE(DECLARE_SIG_ENTRY)};
 #undef DECLARE_SIG_ENTRY
 
-constexpr WasmOpcodeSig GetShortOpcodeSigIndex(byte opcode) {
+constexpr WasmOpcodeSig GetShortOpcodeSigIndex(uint8_t opcode) {
 #define CASE(name, opc, sig, ...) opcode == opc ? kSigEnum_##sig:
   return FOREACH_SIMPLE_OPCODE(CASE) FOREACH_SIMPLE_PROTOTYPE_OPCODE(CASE)
       kSigEnum_None;
 #undef CASE
 }
 
-constexpr WasmOpcodeSig GetAsmJsOpcodeSigIndex(byte opcode) {
+constexpr WasmOpcodeSig GetAsmJsOpcodeSigIndex(uint8_t opcode) {
 #define CASE(name, opc, sig, ...) opcode == opc ? kSigEnum_##sig:
   return FOREACH_ASMJS_COMPAT_OPCODE(CASE) kSigEnum_None;
 #undef CASE
 }
 
-constexpr WasmOpcodeSig GetSimdOpcodeSigIndex(byte opcode) {
+constexpr WasmOpcodeSig GetSimdOpcodeSigIndex(uint8_t opcode) {
 #define CASE(name, opc, sig, ...) opcode == (opc & 0xFF) ? kSigEnum_##sig:
   return FOREACH_SIMD_MVP_0_OPERAND_OPCODE(CASE) FOREACH_SIMD_MEM_OPCODE(CASE)
       FOREACH_SIMD_MEM_1_OPERAND_OPCODE(CASE) kSigEnum_None;
 #undef CASE
 }
 
-constexpr WasmOpcodeSig GetRelaxedSimdOpcodeSigIndex(byte opcode) {
+constexpr WasmOpcodeSig GetRelaxedSimdOpcodeSigIndex(uint8_t opcode) {
 #define CASE(name, opc, sig, ...) opcode == (opc & 0xFF) ? kSigEnum_##sig:
   return FOREACH_RELAXED_SIMD_OPCODE(CASE) kSigEnum_None;
 #undef CASE
 }
 
-constexpr WasmOpcodeSig GetAtomicOpcodeSigIndex(byte opcode) {
+constexpr WasmOpcodeSig GetAtomicOpcodeSigIndex(uint8_t opcode) {
 #define CASE(name, opc, sig, ...) opcode == (opc & 0xFF) ? kSigEnum_##sig:
   return FOREACH_ATOMIC_OPCODE(CASE) FOREACH_ATOMIC_0_OPERAND_OPCODE(CASE)
       kSigEnum_None;
 #undef CASE
 }
 
-constexpr WasmOpcodeSig GetNumericOpcodeSigIndex(byte opcode) {
+constexpr WasmOpcodeSig GetNumericOpcodeSigIndex(uint8_t opcode) {
 #define CASE(name, opc, sig, ...) opcode == (opc & 0xFF) ? kSigEnum_##sig:
   return FOREACH_NUMERIC_OPCODE_WITH_SIG(CASE) kSigEnum_None;
 #undef CASE
diff --git a/src/wasm/wasm-opcodes.h b/src/wasm/wasm-opcodes.h
index 141308e16c..1be61a2e7f 100644
--- a/src/wasm/wasm-opcodes.h
+++ b/src/wasm/wasm-opcodes.h
@@ -915,7 +915,7 @@ class V8_EXPORT_PRIVATE WasmOpcodes {
   static constexpr TrapReason MessageIdToTrapReason(MessageTemplate message);
 
   // Extract the prefix byte (or 0x00) from a {WasmOpcode}.
-  static constexpr byte ExtractPrefix(WasmOpcode);
+  static constexpr uint8_t ExtractPrefix(WasmOpcode);
   static inline const char* TrapReasonMessage(TrapReason);
 };
 
diff --git a/src/wasm/wasm-serialization.cc b/src/wasm/wasm-serialization.cc
index 083e931978..61f53a3ebb 100644
--- a/src/wasm/wasm-serialization.cc
+++ b/src/wasm/wasm-serialization.cc
@@ -36,13 +36,13 @@ constexpr uint8_t kTurboFanFunction = 4;
 // in Wasm, e.g. StreamProcessor and ZoneBuffer, with these.
 class Writer {
  public:
-  explicit Writer(base::Vector<byte> buffer)
+  explicit Writer(base::Vector<uint8_t> buffer)
       : start_(buffer.begin()), end_(buffer.end()), pos_(buffer.begin()) {}
 
   size_t bytes_written() const { return pos_ - start_; }
-  byte* current_location() const { return pos_; }
+  uint8_t* current_location() const { return pos_; }
   size_t current_size() const { return end_ - pos_; }
-  base::Vector<byte> current_buffer() const {
+  base::Vector<uint8_t> current_buffer() const {
     return {current_location(), current_size()};
   }
 
@@ -59,7 +59,7 @@ class Writer {
 
   template <typename T>
   void WriteVector(const base::Vector<T> v) {
-    base::Vector<const byte> bytes = base::Vector<const byte>::cast(v);
+    base::Vector<const uint8_t> bytes = base::Vector<const uint8_t>::cast(v);
     DCHECK_GE(current_size(), bytes.size());
     if (bytes.size() > 0) {
       memcpy(current_location(), bytes.begin(), bytes.size());
@@ -75,20 +75,20 @@ class Writer {
   void Skip(size_t size) { pos_ += size; }
 
  private:
-  byte* const start_;
-  byte* const end_;
-  byte* pos_;
+  uint8_t* const start_;
+  uint8_t* const end_;
+  uint8_t* pos_;
 };
 
 class Reader {
  public:
-  explicit Reader(base::Vector<const byte> buffer)
+  explicit Reader(base::Vector<const uint8_t> buffer)
       : start_(buffer.begin()), end_(buffer.end()), pos_(buffer.begin()) {}
 
   size_t bytes_read() const { return pos_ - start_; }
-  const byte* current_location() const { return pos_; }
+  const uint8_t* current_location() const { return pos_; }
   size_t current_size() const { return end_ - pos_; }
-  base::Vector<const byte> current_buffer() const {
+  base::Vector<const uint8_t> current_buffer() const {
     return {current_location(), current_size()};
   }
 
@@ -108,7 +108,7 @@ class Reader {
   template <typename T>
   base::Vector<const T> ReadVector(size_t size) {
     DCHECK_GE(current_size(), size);
-    base::Vector<const byte> bytes{pos_, size * sizeof(T)};
+    base::Vector<const uint8_t> bytes{pos_, size * sizeof(T)};
     pos_ += size * sizeof(T);
     if (v8_flags.trace_wasm_serialization) {
       StdoutStream{} << "read vector of " << size << " elements of size "
@@ -121,9 +121,9 @@ class Reader {
   void Skip(size_t size) { pos_ += size; }
 
  private:
-  const byte* const start_;
-  const byte* const end_;
-  const byte* pos_;
+  const uint8_t* const start_;
+  const uint8_t* const end_;
+  const uint8_t* pos_;
 };
 
 void WriteHeader(Writer* writer) {
@@ -407,8 +407,8 @@ void NativeModuleSerializer::WriteCode(const WasmCode* code, Writer* writer) {
   writer->Write(code->tier());
 
   // Get a pointer to the destination buffer, to hold relocated code.
-  byte* serialized_code_start = writer->current_buffer().begin();
-  byte* code_start = serialized_code_start;
+  uint8_t* serialized_code_start = writer->current_buffer().begin();
+  uint8_t* code_start = serialized_code_start;
   size_t code_size = code->instructions().size();
   writer->Skip(code_size);
   // Write the reloc info, source positions, inlining positions and protected
@@ -422,12 +422,12 @@ void NativeModuleSerializer::WriteCode(const WasmCode* code, Writer* writer) {
     V8_TARGET_ARCH_RISCV64
   // On platforms that don't support misaligned word stores, copy to an aligned
   // buffer if necessary so we can relocate the serialized code.
-  std::unique_ptr<byte[]> aligned_buffer;
+  std::unique_ptr<uint8_t[]> aligned_buffer;
   if (!IsAligned(reinterpret_cast<Address>(serialized_code_start),
                  kSystemPointerSize)) {
-    // 'byte' does not guarantee an alignment but seems to work well enough in
-    // practice.
-    aligned_buffer.reset(new byte[code_size]);
+    // 'uint8_t' does not guarantee an alignment but seems to work well enough
+    // in practice.
+    aligned_buffer.reset(new uint8_t[code_size]);
     code_start = aligned_buffer.get();
   }
 #endif
@@ -526,7 +526,7 @@ size_t WasmSerializer::GetSerializedNativeModuleSize() const {
   return kHeaderSize + serializer.Measure();
 }
 
-bool WasmSerializer::SerializeNativeModule(base::Vector<byte> buffer) const {
+bool WasmSerializer::SerializeNativeModule(base::Vector<uint8_t> buffer) const {
   NativeModuleSerializer serializer(native_module_, base::VectorOf(code_table_),
                                     base::VectorOf(import_statuses_));
   size_t measured_size = kHeaderSize + serializer.Measure();
@@ -541,7 +541,7 @@ bool WasmSerializer::SerializeNativeModule(base::Vector<byte> buffer) const {
 }
 
 struct DeserializationUnit {
-  base::Vector<const byte> src_code_buffer;
+  base::Vector<const uint8_t> src_code_buffer;
   std::unique_ptr<WasmCode> code;
   NativeModule::JumpTablesRef jump_tables;
 };
@@ -618,7 +618,7 @@ class V8_EXPORT_PRIVATE NativeModuleDeserializer {
   // Updated in {ReadCode}.
   size_t remaining_code_size_ = 0;
   bool all_functions_validated_ = false;
-  base::Vector<byte> current_code_space_;
+  base::Vector<uint8_t> current_code_space_;
   NativeModule::JumpTablesRef current_jump_tables_;
   std::vector<int> lazy_functions_;
   std::vector<int> eager_functions_;
@@ -810,12 +810,12 @@ DeserializationUnit NativeModuleDeserializer::ReadCode(int fn_index,
   }
 
   DeserializationUnit unit;
-  unit.src_code_buffer = reader->ReadVector<byte>(code_size);
-  auto reloc_info = reader->ReadVector<byte>(reloc_size);
-  auto source_pos = reader->ReadVector<byte>(source_position_size);
-  auto inlining_pos = reader->ReadVector<byte>(inlining_position_size);
+  unit.src_code_buffer = reader->ReadVector<uint8_t>(code_size);
+  auto reloc_info = reader->ReadVector<uint8_t>(reloc_size);
+  auto source_pos = reader->ReadVector<uint8_t>(source_position_size);
+  auto inlining_pos = reader->ReadVector<uint8_t>(inlining_position_size);
   auto protected_instructions =
-      reader->ReadVector<byte>(protected_instructions_size);
+      reader->ReadVector<uint8_t>(protected_instructions_size);
 
   base::Vector<uint8_t> instructions =
       current_code_space_.SubVector(0, code_size);
@@ -892,8 +892,8 @@ void NativeModuleDeserializer::ReadTieringBudget(Reader* reader) {
   if (size_of_tiering_budget > reader->current_size()) {
     return;
   }
-  base::Vector<const byte> serialized_budget =
-      reader->ReadVector<const byte>(size_of_tiering_budget);
+  base::Vector<const uint8_t> serialized_budget =
+      reader->ReadVector<const uint8_t>(size_of_tiering_budget);
 
   memcpy(native_module_->tiering_budget_array(), serialized_budget.begin(),
          size_of_tiering_budget);
@@ -913,9 +913,9 @@ void NativeModuleDeserializer::Publish(std::vector<DeserializationUnit> batch) {
   }
 }
 
-bool IsSupportedVersion(base::Vector<const byte> header) {
+bool IsSupportedVersion(base::Vector<const uint8_t> header) {
   if (header.size() < WasmSerializer::kHeaderSize) return false;
-  byte current_version[WasmSerializer::kHeaderSize];
+  uint8_t current_version[WasmSerializer::kHeaderSize];
   Writer writer({current_version, WasmSerializer::kHeaderSize});
   WriteHeader(&writer);
   return memcmp(header.begin(), current_version, WasmSerializer::kHeaderSize) ==
@@ -923,8 +923,8 @@ bool IsSupportedVersion(base::Vector<const byte> header) {
 }
 
 MaybeHandle<WasmModuleObject> DeserializeNativeModule(
-    Isolate* isolate, base::Vector<const byte> data,
-    base::Vector<const byte> wire_bytes_vec,
+    Isolate* isolate, base::Vector<const uint8_t> data,
+    base::Vector<const uint8_t> wire_bytes_vec,
     base::Vector<const char> source_url) {
   if (!IsWasmCodegenAllowed(isolate, isolate->native_context())) return {};
   if (!IsSupportedVersion(data)) return {};
diff --git a/src/wasm/wasm-serialization.h b/src/wasm/wasm-serialization.h
index 9613e9951c..fd52212560 100644
--- a/src/wasm/wasm-serialization.h
+++ b/src/wasm/wasm-serialization.h
@@ -28,7 +28,7 @@ class V8_EXPORT_PRIVATE WasmSerializer {
 
   // Serialize the {NativeModule} into the provided {buffer}. Returns true on
   // success and false if the given buffer it too small for serialization.
-  bool SerializeNativeModule(base::Vector<byte> buffer) const;
+  bool SerializeNativeModule(base::Vector<uint8_t> buffer) const;
 
   // The data header consists of uint32_t-sized entries (see {WriteVersion}):
   // [0] magic number
@@ -55,12 +55,13 @@ class V8_EXPORT_PRIVATE WasmSerializer {
 
 // Support for deserializing WebAssembly {NativeModule} objects.
 // Checks the version header of the data against the current version.
-bool IsSupportedVersion(base::Vector<const byte> data);
+bool IsSupportedVersion(base::Vector<const uint8_t> data);
 
 // Deserializes the given data to create a Wasm module object.
 V8_EXPORT_PRIVATE MaybeHandle<WasmModuleObject> DeserializeNativeModule(
-    Isolate*, base::Vector<const byte> data,
-    base::Vector<const byte> wire_bytes, base::Vector<const char> source_url);
+    Isolate*, base::Vector<const uint8_t> data,
+    base::Vector<const uint8_t> wire_bytes,
+    base::Vector<const char> source_url);
 
 }  // namespace wasm
 }  // namespace internal
diff --git a/src/wasm/wasm-value.h b/src/wasm/wasm-value.h
index 5878732d0b..1a5a862f03 100644
--- a/src/wasm/wasm-value.h
+++ b/src/wasm/wasm-value.h
@@ -47,7 +47,7 @@ class Simd128 {
   FOREACH_SIMD_TYPE(DEFINE_SIMD_TYPE_SPECIFIC_METHODS)
 #undef DEFINE_SIMD_TYPE_SPECIFIC_METHODS
 
-  explicit Simd128(byte* bytes) {
+  explicit Simd128(uint8_t* bytes) {
     memcpy(static_cast<void*>(val_), reinterpret_cast<void*>(bytes),
            kSimd128Size);
   }
@@ -143,7 +143,7 @@ class WasmValue {
                                         : type_.value_kind_size());
   }
 
-  void CopyTo(byte* to) const {
+  void CopyTo(uint8_t* to) const {
     static_assert(sizeof(float) == sizeof(Float32));
     static_assert(sizeof(double) == sizeof(Float64));
     DCHECK(type_.is_numeric());
@@ -193,9 +193,9 @@ class WasmValue {
       case kS128: {
         std::stringstream stream;
         stream << "0x" << std::hex;
-        for (int8_t byte : bit_pattern_) {
-          if (!(byte & 0xf0)) stream << '0';
-          stream << byte;
+        for (int8_t uint8_t : bit_pattern_) {
+          if (!(uint8_t & 0xf0)) stream << '0';
+          stream << uint8_t;
         }
         return stream.str();
       }
-- 
2.35.1


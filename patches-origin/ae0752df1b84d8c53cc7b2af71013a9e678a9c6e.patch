From ae0752df1b84d8c53cc7b2af71013a9e678a9c6e Mon Sep 17 00:00:00 2001
From: Leszek Swirski <leszeks@chromium.org>
Date: Thu, 15 Apr 2021 15:21:39 +0200
Subject: [PATCH] [codegen] Add static interface descriptors

Add a new CRTP StaticCallInterfaceDescriptor class, which provides
static constexpr getters for a descriptor's registers, parameter counts,
and so on. Each CallInterfaceDescriptor subclass is changed to extend
StaticCallInterfaceDescriptor, with StaticCallInterfaceDescriptor itself
extending CallInterfaceDescriptor to still provide a dynamic lookup
where needed.

StaticCallInterfaceDescriptor provides a couple of customisation points,
where it reads its CRTP derived descriptor's static fields and
functions, with default fallbacks where appropriate. With these
customisation points, the definition of CallInterfaceDescriptor
subclasses is simplified to:

    a) Providing parameter names (as before)
    b) Providing parameter types (as before)
    c) Optionally setting flags (like kNoContext or kAllowVarArgs) as
       static booleans on the class.
    d) Optionally providing a `registers()` method that returns a
       std::array<Register, N> of registers that may be used for
       parameters (if not provided, this defaults to the implementation
       specific default register set).

Parameter registers (and register count) are automagically set based on
the number of parameters and number of given registers, with extra magic
to ignore no_reg registers (to reduce ia32 special casing). The
CallInterfaceDescriptorData is initialized based on these static
functions, rather than manual per-descriptor initializers.

This allows us to skip loading descriptors dynamically for CallBuiltin
in Sparkplug, and instead lets us use a bit of template magic to
statically set up arguments for the calls. Any other users of statically
known descriptors will also benefit, thanks to C++ picking the static
methods over the dynamic methods on the base class when available.

Because we can remove various virtual functions and trigger heavier
inlining of constantly known values, binary size slightly decreases with
this change.

Note that torque-generated descriptors are changed to use the same magic,
rather than having Torque-specific magic, for consistency.

Bug: v8:11420
Change-Id: Icc5e238b6313a08734feb564204a13226b450c22
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2814518
Auto-Submit: Leszek Swirski <leszeks@chromium.org>
Reviewed-by: Nico Hartmann <nicohartmann@chromium.org>
Reviewed-by: Clemens Backes <clemensb@chromium.org>
Reviewed-by: Igor Sheludko <ishell@chromium.org>
Reviewed-by: Jakob Gruber <jgruber@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/master@{#73996}
---
 BUILD.gn                                      |    9 +-
 src/baseline/arm/baseline-compiler-arm-inl.h  |    6 +-
 .../arm64/baseline-compiler-arm64-inl.h       |    6 +-
 src/baseline/baseline-assembler-inl.h         |    1 +
 src/baseline/baseline-compiler.cc             |  782 +++++-----
 src/baseline/baseline-compiler.h              |   22 +-
 .../ia32/baseline-compiler-ia32-inl.h         |    6 +-
 src/baseline/x64/baseline-assembler-x64-inl.h |    1 -
 src/baseline/x64/baseline-compiler-x64-inl.h  |    6 +-
 src/builtins/arm/builtins-arm.cc              |    1 +
 src/builtins/arm64/builtins-arm64.cc          |    1 +
 src/builtins/builtins-array-gen.cc            |    1 +
 src/builtins/builtins-internal-gen.cc         |    1 +
 src/builtins/ia32/builtins-ia32.cc            |    3 +-
 src/builtins/x64/builtins-x64.cc              |    5 +-
 .../arm/interface-descriptors-arm-inl.h       |  261 ++++
 src/codegen/arm/interface-descriptors-arm.cc  |  306 ----
 src/codegen/arm/macro-assembler-arm.cc        |    1 +
 .../arm64/interface-descriptors-arm64-inl.h   |  270 ++++
 .../arm64/interface-descriptors-arm64.cc      |  310 ----
 src/codegen/arm64/macro-assembler-arm64.cc    |    1 +
 .../ia32/interface-descriptors-ia32-inl.h     |  272 ++++
 .../ia32/interface-descriptors-ia32.cc        |  318 ----
 src/codegen/ia32/macro-assembler-ia32.cc      |    2 +-
 src/codegen/interface-descriptors-inl.h       |  471 ++++++
 src/codegen/interface-descriptors.cc          |  557 +------
 src/codegen/interface-descriptors.h           | 1325 +++++++++--------
 src/codegen/register-arch.h                   |   21 +
 src/codegen/turbo-assembler.h                 |   21 -
 .../x64/interface-descriptors-x64-inl.h       |  263 ++++
 src/codegen/x64/interface-descriptors-x64.cc  |  309 ----
 src/codegen/x64/macro-assembler-x64.cc        |    1 +
 src/compiler/backend/instruction-selector.cc  |    1 +
 src/compiler/code-assembler.cc                |    2 +-
 src/compiler/effect-control-linearizer.cc     |    1 +
 src/compiler/js-generic-lowering.cc           |    1 +
 src/compiler/js-typed-lowering.cc             |    1 +
 src/compiler/memory-lowering.cc               |    2 +-
 src/compiler/wasm-compiler.cc                 |    2 +-
 src/ic/accessor-assembler.cc                  |    2 +-
 src/interpreter/interpreter-assembler.cc      |    2 +-
 src/snapshot/embedded/embedded-data.cc        |   10 +-
 src/torque/implementation-visitor.cc          |   62 +-
 src/wasm/baseline/liftoff-compiler.cc         |    2 +-
 test/cctest/test-code-stub-assembler.cc       |    3 +-
 .../codegen/code-stub-assembler-unittest.cc   |    2 +-
 .../compiler/int64-lowering-unittest.cc       |   38 +-
 47 files changed, 2793 insertions(+), 2898 deletions(-)
 create mode 100644 src/codegen/arm/interface-descriptors-arm-inl.h
 delete mode 100644 src/codegen/arm/interface-descriptors-arm.cc
 create mode 100644 src/codegen/arm64/interface-descriptors-arm64-inl.h
 delete mode 100644 src/codegen/arm64/interface-descriptors-arm64.cc
 create mode 100644 src/codegen/ia32/interface-descriptors-ia32-inl.h
 delete mode 100644 src/codegen/ia32/interface-descriptors-ia32.cc
 create mode 100644 src/codegen/interface-descriptors-inl.h
 create mode 100644 src/codegen/x64/interface-descriptors-x64-inl.h
 delete mode 100644 src/codegen/x64/interface-descriptors-x64.cc

diff --git a/BUILD.gn b/BUILD.gn
index 6fc9f920e01..263e5668bbc 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -2337,6 +2337,7 @@ v8_header_set("v8_internal_headers") {
     "src/codegen/external-reference.h",
     "src/codegen/flush-instruction-cache.h",
     "src/codegen/handler-table.h",
+    "src/codegen/interface-descriptors-inl.h",
     "src/codegen/interface-descriptors.h",
     "src/codegen/label.h",
     "src/codegen/machine-type.h",
@@ -4057,7 +4058,7 @@ v8_source_set("v8_base_without_compiler") {
     sources += [  ### gcmole(arch:ia32) ###
       "src/codegen/ia32/assembler-ia32.cc",
       "src/codegen/ia32/cpu-ia32.cc",
-      "src/codegen/ia32/interface-descriptors-ia32.cc",
+      "src/codegen/ia32/interface-descriptors-ia32-inl.h",
       "src/codegen/ia32/macro-assembler-ia32.cc",
       "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.cc",
       "src/compiler/backend/ia32/code-generator-ia32.cc",
@@ -4075,7 +4076,7 @@ v8_source_set("v8_base_without_compiler") {
       "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.cc",
       "src/codegen/x64/assembler-x64.cc",
       "src/codegen/x64/cpu-x64.cc",
-      "src/codegen/x64/interface-descriptors-x64.cc",
+      "src/codegen/x64/interface-descriptors-x64-inl.h",
       "src/codegen/x64/macro-assembler-x64.cc",
       "src/compiler/backend/x64/code-generator-x64.cc",
       "src/compiler/backend/x64/instruction-scheduler-x64.cc",
@@ -4110,7 +4111,7 @@ v8_source_set("v8_base_without_compiler") {
       "src/codegen/arm/assembler-arm.cc",
       "src/codegen/arm/constants-arm.cc",
       "src/codegen/arm/cpu-arm.cc",
-      "src/codegen/arm/interface-descriptors-arm.cc",
+      "src/codegen/arm/interface-descriptors-arm-inl.h",
       "src/codegen/arm/macro-assembler-arm.cc",
       "src/compiler/backend/arm/code-generator-arm.cc",
       "src/compiler/backend/arm/instruction-scheduler-arm.cc",
@@ -4132,7 +4133,7 @@ v8_source_set("v8_base_without_compiler") {
       "src/codegen/arm64/decoder-arm64.cc",
       "src/codegen/arm64/instructions-arm64-constants.cc",
       "src/codegen/arm64/instructions-arm64.cc",
-      "src/codegen/arm64/interface-descriptors-arm64.cc",
+      "src/codegen/arm64/interface-descriptors-arm64-inl.h",
       "src/codegen/arm64/macro-assembler-arm64.cc",
       "src/codegen/arm64/register-arm64.cc",
       "src/codegen/arm64/utils-arm64.cc",
diff --git a/src/baseline/arm/baseline-compiler-arm-inl.h b/src/baseline/arm/baseline-compiler-arm-inl.h
index ff2b6d1a831..d7f0a606d3b 100644
--- a/src/baseline/arm/baseline-compiler-arm-inl.h
+++ b/src/baseline/arm/baseline-compiler-arm-inl.h
@@ -19,9 +19,9 @@ void BaselineCompiler::Prologue() {
   __ masm()->EnterFrame(StackFrame::BASELINE);
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
-              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   PrologueFillFrame();
 }
diff --git a/src/baseline/arm64/baseline-compiler-arm64-inl.h b/src/baseline/arm64/baseline-compiler-arm64-inl.h
index e567be41d24..0807c5434ac 100644
--- a/src/baseline/arm64/baseline-compiler-arm64-inl.h
+++ b/src/baseline/arm64/baseline-compiler-arm64-inl.h
@@ -18,9 +18,9 @@ void BaselineCompiler::Prologue() {
   __ masm()->EnterFrame(StackFrame::BASELINE);
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
-              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   __ masm()->AssertSpAligned();
   PrologueFillFrame();
diff --git a/src/baseline/baseline-assembler-inl.h b/src/baseline/baseline-assembler-inl.h
index cbce3ba7b8b..6a3f86632b1 100644
--- a/src/baseline/baseline-assembler-inl.h
+++ b/src/baseline/baseline-assembler-inl.h
@@ -14,6 +14,7 @@
 #include <unordered_map>
 
 #include "src/baseline/baseline-assembler.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/interpreter/bytecode-register.h"
 #include "src/objects/feedback-cell.h"
 #include "src/objects/js-function.h"
diff --git a/src/baseline/baseline-compiler.cc b/src/baseline/baseline-compiler.cc
index e5ab1f14912..ac6880ecb59 100644
--- a/src/baseline/baseline-compiler.cc
+++ b/src/baseline/baseline-compiler.cc
@@ -19,7 +19,7 @@
 #include "src/builtins/builtins.h"
 #include "src/codegen/assembler.h"
 #include "src/codegen/compiler.h"
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/common/globals.h"
@@ -70,6 +70,7 @@ bool Clobbers(Register target, TaggedIndex index) { return false; }
 bool Clobbers(Register target, int32_t imm) { return false; }
 bool Clobbers(Register target, RootIndex index) { return false; }
 bool Clobbers(Register target, interpreter::Register reg) { return false; }
+bool Clobbers(Register target, interpreter::RegisterList list) { return false; }
 
 // We don't know what's inside machine registers or operands, so assume they
 // match.
@@ -99,130 +100,132 @@ bool MachineTypeMatches(MachineType type, interpreter::Register reg) {
   return type.IsTagged();
 }
 
-template <typename... Args>
+template <typename Descriptor, typename... Args>
 struct CheckArgsHelper;
 
-template <>
-struct CheckArgsHelper<> {
-  static void Check(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
-                    int i) {
-    if (descriptor.AllowVarArgs()) {
-      CHECK_GE(i, descriptor.GetParameterCount());
+template <typename Descriptor>
+struct CheckArgsHelper<Descriptor> {
+  static void Check(BaselineAssembler* masm, int i) {
+    if (Descriptor::AllowVarArgs()) {
+      CHECK_GE(i, Descriptor::GetParameterCount());
     } else {
-      CHECK_EQ(i, descriptor.GetParameterCount());
+      CHECK_EQ(i, Descriptor::GetParameterCount());
     }
   }
 };
 
-template <typename Arg, typename... Args>
-struct CheckArgsHelper<Arg, Args...> {
-  static void Check(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
-                    int i, Arg arg, Args... args) {
-    if (i >= descriptor.GetParameterCount()) {
-      CHECK(descriptor.AllowVarArgs());
+template <typename Descriptor, typename Arg, typename... Args>
+struct CheckArgsHelper<Descriptor, Arg, Args...> {
+  static void Check(BaselineAssembler* masm, int i, Arg arg, Args... args) {
+    if (i >= Descriptor::GetParameterCount()) {
+      CHECK(Descriptor::AllowVarArgs());
       return;
     }
-    CHECK(MachineTypeMatches(descriptor.GetParameterType(i), arg));
-    CheckArgsHelper<Args...>::Check(masm, descriptor, i + 1, args...);
+    CHECK(MachineTypeMatches(Descriptor().GetParameterType(i), arg));
+    CheckArgsHelper<Descriptor, Args...>::Check(masm, i + 1, args...);
   }
 };
 
-template <typename... Args>
-struct CheckArgsHelper<interpreter::RegisterList, Args...> {
-  static void Check(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
-                    int i, interpreter::RegisterList list, Args... args) {
+template <typename Descriptor, typename... Args>
+struct CheckArgsHelper<Descriptor, interpreter::RegisterList, Args...> {
+  static void Check(BaselineAssembler* masm, int i,
+                    interpreter::RegisterList list, Args... args) {
     for (int reg_index = 0; reg_index < list.register_count();
          ++reg_index, ++i) {
-      if (i >= descriptor.GetParameterCount()) {
-        CHECK(descriptor.AllowVarArgs());
+      if (i >= Descriptor::GetParameterCount()) {
+        CHECK(Descriptor::AllowVarArgs());
         return;
       }
-      CHECK(
-          MachineTypeMatches(descriptor.GetParameterType(i), list[reg_index]));
+      CHECK(MachineTypeMatches(Descriptor().GetParameterType(i),
+                               list[reg_index]));
     }
-    CheckArgsHelper<Args...>::Check(masm, descriptor, i, args...);
+    CheckArgsHelper<Descriptor, Args...>::Check(masm, i, args...);
   }
 };
 
-template <typename... Args>
-void CheckArgs(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
-               Args... args) {
-  CheckArgsHelper<Args...>::Check(masm, descriptor, 0, args...);
+template <typename Descriptor, typename... Args>
+void CheckArgs(BaselineAssembler* masm, Args... args) {
+  CheckArgsHelper<Descriptor, Args...>::Check(masm, 0, args...);
+}
+
+void CheckSettingDoesntClobber(Register target) {}
+template <typename Arg, typename... Args>
+void CheckSettingDoesntClobber(Register target, Arg arg, Args... args) {
+  DCHECK(!Clobbers(target, arg));
+  CheckSettingDoesntClobber(target, args...);
 }
 
 #else  // DEBUG
 
-template <typename... Args>
+template <typename Descriptor, typename... Args>
 void CheckArgs(Args... args) {}
 
+template <typename... Args>
+void CheckSettingDoesntClobber(Register target, Args... args) {}
+
 #endif  // DEBUG
 
-template <typename... Args>
+template <typename Descriptor, int ArgIndex, bool kIsRegister, typename... Args>
 struct ArgumentSettingHelper;
 
-template <>
-struct ArgumentSettingHelper<> {
-  static void Set(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
-                  int i) {}
-  static void CheckSettingDoesntClobber(Register target, int arg_index) {}
+template <typename Descriptor, int ArgIndex, bool kIsRegister>
+struct ArgumentSettingHelper<Descriptor, ArgIndex, kIsRegister> {
+  static void Set(BaselineAssembler* masm) {
+    // Should only ever be called for the end of register arguments.
+    STATIC_ASSERT(ArgIndex == Descriptor::GetRegisterParameterCount());
+  }
 };
 
-template <typename Arg, typename... Args>
-struct ArgumentSettingHelper<Arg, Args...> {
-  static void Set(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
-                  int i, Arg arg, Args... args) {
-    if (i < descriptor.GetRegisterParameterCount()) {
-      Register target = descriptor.GetRegisterParameter(i);
-      ArgumentSettingHelper<Args...>::CheckSettingDoesntClobber(target, i + 1,
-                                                                args...);
-      masm->Move(target, arg);
-      ArgumentSettingHelper<Args...>::Set(masm, descriptor, i + 1, args...);
-    } else if (descriptor.GetStackArgumentOrder() ==
-               StackArgumentOrder::kDefault) {
-      masm->Push(arg, args...);
-    } else {
-      masm->PushReverse(arg, args...);
-    }
+template <typename Descriptor, int ArgIndex, typename Arg, typename... Args>
+struct ArgumentSettingHelper<Descriptor, ArgIndex, true, Arg, Args...> {
+  static void Set(BaselineAssembler* masm, Arg arg, Args... args) {
+    STATIC_ASSERT(ArgIndex < Descriptor::GetRegisterParameterCount());
+    Register target = Descriptor::GetRegisterParameter(ArgIndex);
+    CheckSettingDoesntClobber(target, args...);
+    masm->Move(target, arg);
+    ArgumentSettingHelper<Descriptor, ArgIndex + 1,
+                          (ArgIndex + 1 <
+                           Descriptor::GetRegisterParameterCount()),
+                          Args...>::Set(masm, args...);
   }
-  static void CheckSettingDoesntClobber(Register target, int arg_index, Arg arg,
-                                        Args... args) {
-    DCHECK(!Clobbers(target, arg));
-    ArgumentSettingHelper<Args...>::CheckSettingDoesntClobber(
-        target, arg_index + 1, args...);
+};
+
+template <typename Descriptor, int ArgIndex>
+struct ArgumentSettingHelper<Descriptor, ArgIndex, true,
+                             interpreter::RegisterList> {
+  static void Set(BaselineAssembler* masm, interpreter::RegisterList list) {
+    STATIC_ASSERT(ArgIndex < Descriptor::GetRegisterParameterCount());
+    DCHECK_EQ(ArgIndex + list.register_count(),
+              Descriptor::GetRegisterParameterCount());
+    for (int i = 0; ArgIndex + i < Descriptor::GetRegisterParameterCount();
+         ++i) {
+      Register target = Descriptor::GetRegisterParameter(ArgIndex + i);
+      masm->Move(target, masm->RegisterFrameOperand(list[i]));
+    }
   }
 };
 
-// Specialization for interpreter::RegisterList which iterates it.
-// RegisterLists are only allowed to be the last argument.
-template <>
-struct ArgumentSettingHelper<interpreter::RegisterList> {
-  static void Set(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
-                  int i, interpreter::RegisterList list) {
-    // Either all the values are in machine registers, or they're all on the
-    // stack.
-    if (i < descriptor.GetRegisterParameterCount()) {
-      for (int reg_index = 0; reg_index < list.register_count();
-           ++reg_index, ++i) {
-        Register target = descriptor.GetRegisterParameter(i);
-        masm->Move(target, masm->RegisterFrameOperand(list[reg_index]));
-      }
-    } else if (descriptor.GetStackArgumentOrder() ==
-               StackArgumentOrder::kDefault) {
-      masm->Push(list);
+template <typename Descriptor, int ArgIndex, typename Arg, typename... Args>
+struct ArgumentSettingHelper<Descriptor, ArgIndex, false, Arg, Args...> {
+  static void Set(BaselineAssembler* masm, Arg arg, Args... args) {
+    if (Descriptor::kStackArgumentOrder == StackArgumentOrder::kDefault) {
+      masm->Push(arg, args...);
     } else {
-      masm->PushReverse(list);
+      masm->PushReverse(arg, args...);
     }
   }
-  static void CheckSettingDoesntClobber(Register target, int arg_index,
-                                        interpreter::RegisterList arg) {}
 };
 
-template <typename... Args>
-void MoveArgumentsForDescriptor(BaselineAssembler* masm,
-                                CallInterfaceDescriptor descriptor,
-                                Args... args) {
-  CheckArgs(masm, descriptor, args...);
-  ArgumentSettingHelper<Args...>::Set(masm, descriptor, 0, args...);
+template <Builtins::Name kBuiltin, typename... Args>
+void MoveArgumentsForBuiltin(BaselineAssembler* masm, Args... args) {
+  using Descriptor = typename CallInterfaceDescriptorFor<kBuiltin>::type;
+  CheckArgs<Descriptor>(masm, args...);
+  ArgumentSettingHelper<Descriptor, 0,
+                        (0 < Descriptor::GetRegisterParameterCount()),
+                        Args...>::Set(masm, args...);
+  if (Descriptor::HasContextParameter()) {
+    masm->LoadContext(Descriptor::ContextRegister());
+  }
 }
 
 }  // namespace detail
@@ -552,28 +555,18 @@ Label* BaselineCompiler::BuildForwardJumpLabel() {
   return &threaded_label->label;
 }
 
-template <typename... Args>
-void BaselineCompiler::CallBuiltin(Builtins::Name builtin, Args... args) {
+template <Builtins::Name kBuiltin, typename... Args>
+void BaselineCompiler::CallBuiltin(Args... args) {
   __ RecordComment("[ CallBuiltin");
-  CallInterfaceDescriptor descriptor =
-      Builtins::CallInterfaceDescriptorFor(builtin);
-  detail::MoveArgumentsForDescriptor(&basm_, descriptor, args...);
-  if (descriptor.HasContextParameter()) {
-    __ LoadContext(descriptor.ContextRegister());
-  }
-  __ CallBuiltin(builtin);
+  detail::MoveArgumentsForBuiltin<kBuiltin>(&basm_, args...);
+  __ CallBuiltin(kBuiltin);
   __ RecordComment("]");
 }
 
-template <typename... Args>
-void BaselineCompiler::TailCallBuiltin(Builtins::Name builtin, Args... args) {
-  CallInterfaceDescriptor descriptor =
-      Builtins::CallInterfaceDescriptorFor(builtin);
-  detail::MoveArgumentsForDescriptor(&basm_, descriptor, args...);
-  if (descriptor.HasContextParameter()) {
-    __ LoadContext(descriptor.ContextRegister());
-  }
-  __ TailCallBuiltin(builtin);
+template <Builtins::Name kBuiltin, typename... Args>
+void BaselineCompiler::TailCallBuiltin(Args... args) {
+  detail::MoveArgumentsForBuiltin<kBuiltin>(&basm_, args...);
+  __ TailCallBuiltin(kBuiltin);
 }
 
 template <typename... Args>
@@ -598,7 +591,7 @@ void BaselineCompiler::JumpIfToBoolean(bool do_jump_if_true, Register reg,
   Register to_boolean = scratch_scope.AcquireScratch();
   {
     SaveAccumulatorScope accumulator_scope(&basm_);
-    CallBuiltin(Builtins::kToBoolean, reg);
+    CallBuiltin<Builtins::kToBoolean>(reg);
     __ Move(to_boolean, kInterpreterAccumulatorRegister);
   }
   __ JumpIfRoot(to_boolean, RootIndex::kTrueValue, true_label, true_distance);
@@ -641,22 +634,21 @@ void BaselineCompiler::VisitLdaConstant() {
 }
 
 void BaselineCompiler::VisitLdaGlobal() {
-  CallBuiltin(Builtins::kLoadGlobalICBaseline,
-              Constant<Name>(0),  // name
-              IndexAsTagged(1));  // slot
+  CallBuiltin<Builtins::kLoadGlobalICBaseline>(Constant<Name>(0),  // name
+                                               IndexAsTagged(1));  // slot
 }
 
 void BaselineCompiler::VisitLdaGlobalInsideTypeof() {
-  CallBuiltin(Builtins::kLoadGlobalICInsideTypeofBaseline,
-              Constant<Name>(0),  // name
-              IndexAsTagged(1));  // slot
+  CallBuiltin<Builtins::kLoadGlobalICInsideTypeofBaseline>(
+      Constant<Name>(0),  // name
+      IndexAsTagged(1));  // slot
 }
 
 void BaselineCompiler::VisitStaGlobal() {
-  CallBuiltin(Builtins::kStoreGlobalICBaseline,
-              Constant<Name>(0),                // name
-              kInterpreterAccumulatorRegister,  // value
-              IndexAsTagged(1));                // slot
+  CallBuiltin<Builtins::kStoreGlobalICBaseline>(
+      Constant<Name>(0),                // name
+      kInterpreterAccumulatorRegister,  // value
+      IndexAsTagged(1));                // slot
 }
 
 void BaselineCompiler::VisitPushContext() {
@@ -730,13 +722,13 @@ void BaselineCompiler::VisitLdaLookupSlot() {
 }
 
 void BaselineCompiler::VisitLdaLookupContextSlot() {
-  CallBuiltin(Builtins::kLookupContextBaseline, Constant<Name>(0),
-              UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin<Builtins::kLookupContextBaseline>(
+      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupGlobalSlot() {
-  CallBuiltin(Builtins::kLookupGlobalICBaseline, Constant<Name>(0),
-              UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin<Builtins::kLookupGlobalICBaseline>(
+      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupSlotInsideTypeof() {
@@ -744,13 +736,13 @@ void BaselineCompiler::VisitLdaLookupSlotInsideTypeof() {
 }
 
 void BaselineCompiler::VisitLdaLookupContextSlotInsideTypeof() {
-  CallBuiltin(Builtins::kLookupContextInsideTypeofBaseline, Constant<Name>(0),
-              UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin<Builtins::kLookupContextInsideTypeofBaseline>(
+      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupGlobalSlotInsideTypeof() {
-  CallBuiltin(Builtins::kLookupGlobalICInsideTypeofBaseline, Constant<Name>(0),
-              UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin<Builtins::kLookupGlobalICInsideTypeofBaseline>(
+      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitStaLookupSlot() {
@@ -793,14 +785,13 @@ void BaselineCompiler::VisitMov() {
 }
 
 void BaselineCompiler::VisitLdaNamedProperty() {
-  CallBuiltin(Builtins::kLoadICBaseline,
-              RegisterOperand(0),  // object
-              Constant<Name>(1),   // name
-              IndexAsTagged(2));   // slot
+  CallBuiltin<Builtins::kLoadICBaseline>(RegisterOperand(0),  // object
+                                         Constant<Name>(1),   // name
+                                         IndexAsTagged(2));   // slot
 }
 
 void BaselineCompiler::VisitLdaNamedPropertyNoFeedback() {
-  CallBuiltin(Builtins::kGetProperty, RegisterOperand(0), Constant<Name>(1));
+  CallBuiltin<Builtins::kGetProperty>(RegisterOperand(0), Constant<Name>(1));
 }
 
 void BaselineCompiler::VisitLdaNamedPropertyFromSuper() {
@@ -808,19 +799,19 @@ void BaselineCompiler::VisitLdaNamedPropertyFromSuper() {
       LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister(),
       kInterpreterAccumulatorRegister);
 
-  CallBuiltin(Builtins::kLoadSuperICBaseline,
-              RegisterOperand(0),  // object
-              LoadWithReceiverAndVectorDescriptor::
-                  LookupStartObjectRegister(),  // lookup start
-              Constant<Name>(1),                // name
-              IndexAsTagged(2));                // slot
+  CallBuiltin<Builtins::kLoadSuperICBaseline>(
+      RegisterOperand(0),  // object
+      LoadWithReceiverAndVectorDescriptor::
+          LookupStartObjectRegister(),  // lookup start
+      Constant<Name>(1),                // name
+      IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitLdaKeyedProperty() {
-  CallBuiltin(Builtins::kKeyedLoadICBaseline,
-              RegisterOperand(0),               // object
-              kInterpreterAccumulatorRegister,  // key
-              IndexAsTagged(1));                // slot
+  CallBuiltin<Builtins::kKeyedLoadICBaseline>(
+      RegisterOperand(0),               // object
+      kInterpreterAccumulatorRegister,  // key
+      IndexAsTagged(1));                // slot
 }
 
 void BaselineCompiler::VisitLdaModuleVariable() {
@@ -878,11 +869,11 @@ void BaselineCompiler::VisitStaModuleVariable() {
 }
 
 void BaselineCompiler::VisitStaNamedProperty() {
-  CallBuiltin(Builtins::kStoreICBaseline,
-              RegisterOperand(0),               // object
-              Constant<Name>(1),                // name
-              kInterpreterAccumulatorRegister,  // value
-              IndexAsTagged(2));                // slot
+  CallBuiltin<Builtins::kStoreICBaseline>(
+      RegisterOperand(0),               // object
+      Constant<Name>(1),                // name
+      kInterpreterAccumulatorRegister,  // value
+      IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitStaNamedPropertyNoFeedback() {
@@ -900,19 +891,19 @@ void BaselineCompiler::VisitStaNamedOwnProperty() {
 }
 
 void BaselineCompiler::VisitStaKeyedProperty() {
-  CallBuiltin(Builtins::kKeyedStoreICBaseline,
-              RegisterOperand(0),               // object
-              RegisterOperand(1),               // key
-              kInterpreterAccumulatorRegister,  // value
-              IndexAsTagged(2));                // slot
+  CallBuiltin<Builtins::kKeyedStoreICBaseline>(
+      RegisterOperand(0),               // object
+      RegisterOperand(1),               // key
+      kInterpreterAccumulatorRegister,  // value
+      IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitStaInArrayLiteral() {
-  CallBuiltin(Builtins::kStoreInArrayLiteralICBaseline,
-              RegisterOperand(0),               // object
-              RegisterOperand(1),               // name
-              kInterpreterAccumulatorRegister,  // value
-              IndexAsTagged(2));                // slot
+  CallBuiltin<Builtins::kStoreInArrayLiteralICBaseline>(
+      RegisterOperand(0),               // object
+      RegisterOperand(1),               // name
+      kInterpreterAccumulatorRegister,  // value
+      IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitStaDataPropertyInLiteral() {
@@ -934,132 +925,143 @@ void BaselineCompiler::VisitCollectTypeProfile() {
 }
 
 void BaselineCompiler::VisitAdd() {
-  CallBuiltin(Builtins::kAdd_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kAdd_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitSub() {
-  CallBuiltin(Builtins::kSubtract_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kSubtract_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitMul() {
-  CallBuiltin(Builtins::kMultiply_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kMultiply_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitDiv() {
-  CallBuiltin(Builtins::kDivide_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kDivide_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitMod() {
-  CallBuiltin(Builtins::kModulus_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kModulus_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitExp() {
-  CallBuiltin(Builtins::kExponentiate_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kExponentiate_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseOr() {
-  CallBuiltin(Builtins::kBitwiseOr_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kBitwiseOr_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseXor() {
-  CallBuiltin(Builtins::kBitwiseXor_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kBitwiseXor_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseAnd() {
-  CallBuiltin(Builtins::kBitwiseAnd_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kBitwiseAnd_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftLeft() {
-  CallBuiltin(Builtins::kShiftLeft_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kShiftLeft_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftRight() {
-  CallBuiltin(Builtins::kShiftRight_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin<Builtins::kShiftRight_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftRightLogical() {
-  CallBuiltin(Builtins::kShiftRightLogical_Baseline, RegisterOperand(0),
-              kInterpreterAccumulatorRegister, Index(1));
-}
-
-void BaselineCompiler::BuildBinopWithConstant(Builtins::Name builtin_name) {
-  CallBuiltin(builtin_name, kInterpreterAccumulatorRegister, IntAsSmi(0),
-              Index(1));
+  CallBuiltin<Builtins::kShiftRightLogical_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitAddSmi() {
-  BuildBinopWithConstant(Builtins::kAdd_Baseline);
+  CallBuiltin<Builtins::kAdd_Baseline>(kInterpreterAccumulatorRegister,
+                                       IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitSubSmi() {
-  BuildBinopWithConstant(Builtins::kSubtract_Baseline);
+  CallBuiltin<Builtins::kSubtract_Baseline>(kInterpreterAccumulatorRegister,
+                                            IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitMulSmi() {
-  BuildBinopWithConstant(Builtins::kMultiply_Baseline);
+  CallBuiltin<Builtins::kMultiply_Baseline>(kInterpreterAccumulatorRegister,
+                                            IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitDivSmi() {
-  BuildBinopWithConstant(Builtins::kDivide_Baseline);
+  CallBuiltin<Builtins::kDivide_Baseline>(kInterpreterAccumulatorRegister,
+                                          IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitModSmi() {
-  BuildBinopWithConstant(Builtins::kModulus_Baseline);
+  CallBuiltin<Builtins::kModulus_Baseline>(kInterpreterAccumulatorRegister,
+                                           IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitExpSmi() {
-  BuildBinopWithConstant(Builtins::kExponentiate_Baseline);
+  CallBuiltin<Builtins::kExponentiate_Baseline>(kInterpreterAccumulatorRegister,
+                                                IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseOrSmi() {
-  BuildBinopWithConstant(Builtins::kBitwiseOr_Baseline);
+  CallBuiltin<Builtins::kBitwiseOr_Baseline>(kInterpreterAccumulatorRegister,
+                                             IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseXorSmi() {
-  BuildBinopWithConstant(Builtins::kBitwiseXor_Baseline);
+  CallBuiltin<Builtins::kBitwiseXor_Baseline>(kInterpreterAccumulatorRegister,
+                                              IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseAndSmi() {
-  BuildBinopWithConstant(Builtins::kBitwiseAnd_Baseline);
+  CallBuiltin<Builtins::kBitwiseAnd_Baseline>(kInterpreterAccumulatorRegister,
+                                              IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitShiftLeftSmi() {
-  BuildBinopWithConstant(Builtins::kShiftLeft_Baseline);
+  CallBuiltin<Builtins::kShiftLeft_Baseline>(kInterpreterAccumulatorRegister,
+                                             IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitShiftRightSmi() {
-  BuildBinopWithConstant(Builtins::kShiftRight_Baseline);
+  CallBuiltin<Builtins::kShiftRight_Baseline>(kInterpreterAccumulatorRegister,
+                                              IntAsSmi(0), Index(1));
 }
 
 void BaselineCompiler::VisitShiftRightLogicalSmi() {
-  BuildBinopWithConstant(Builtins::kShiftRightLogical_Baseline);
+  CallBuiltin<Builtins::kShiftRightLogical_Baseline>(
+      kInterpreterAccumulatorRegister, IntAsSmi(0), Index(1));
 }
 
-void BaselineCompiler::BuildUnop(Builtins::Name builtin_name) {
-  CallBuiltin(builtin_name,
-              kInterpreterAccumulatorRegister,  // value
-              Index(0));                        // slot
+void BaselineCompiler::VisitInc() {
+  CallBuiltin<Builtins::kIncrement_Baseline>(kInterpreterAccumulatorRegister,
+                                             Index(0));
 }
 
-void BaselineCompiler::VisitInc() { BuildUnop(Builtins::kIncrement_Baseline); }
-
-void BaselineCompiler::VisitDec() { BuildUnop(Builtins::kDecrement_Baseline); }
+void BaselineCompiler::VisitDec() {
+  CallBuiltin<Builtins::kDecrement_Baseline>(kInterpreterAccumulatorRegister,
+                                             Index(0));
+}
 
-void BaselineCompiler::VisitNegate() { BuildUnop(Builtins::kNegate_Baseline); }
+void BaselineCompiler::VisitNegate() {
+  CallBuiltin<Builtins::kNegate_Baseline>(kInterpreterAccumulatorRegister,
+                                          Index(0));
+}
 
 void BaselineCompiler::VisitBitwiseNot() {
-  BuildUnop(Builtins::kBitwiseNot_Baseline);
+  CallBuiltin<Builtins::kBitwiseNot_Baseline>(kInterpreterAccumulatorRegister,
+                                              Index(0));
 }
 
 void BaselineCompiler::VisitToBooleanLogicalNot() {
@@ -1081,23 +1083,23 @@ void BaselineCompiler::VisitLogicalNot() {
 }
 
 void BaselineCompiler::VisitTypeOf() {
-  CallBuiltin(Builtins::kTypeof, kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtins::kTypeof>(kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitDeletePropertyStrict() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register scratch = scratch_scope.AcquireScratch();
   __ Move(scratch, kInterpreterAccumulatorRegister);
-  CallBuiltin(Builtins::kDeleteProperty, RegisterOperand(0), scratch,
-              Smi::FromEnum(LanguageMode::kStrict));
+  CallBuiltin<Builtins::kDeleteProperty>(RegisterOperand(0), scratch,
+                                         Smi::FromEnum(LanguageMode::kStrict));
 }
 
 void BaselineCompiler::VisitDeletePropertySloppy() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register scratch = scratch_scope.AcquireScratch();
   __ Move(scratch, kInterpreterAccumulatorRegister);
-  CallBuiltin(Builtins::kDeleteProperty, RegisterOperand(0), scratch,
-              Smi::FromEnum(LanguageMode::kSloppy));
+  CallBuiltin<Builtins::kDeleteProperty>(RegisterOperand(0), scratch,
+                                         Smi::FromEnum(LanguageMode::kSloppy));
 }
 
 void BaselineCompiler::VisitGetSuperConstructor() {
@@ -1106,87 +1108,94 @@ void BaselineCompiler::VisitGetSuperConstructor() {
   __ LoadPrototype(prototype, kInterpreterAccumulatorRegister);
   StoreRegister(0, prototype);
 }
-template <typename... Args>
-void BaselineCompiler::BuildCall(ConvertReceiverMode mode, uint32_t slot,
-                                 uint32_t arg_count, Args... args) {
-  Builtins::Name builtin;
+
+namespace {
+constexpr Builtins::Name ConvertReceiverModeToBuiltin(
+    ConvertReceiverMode mode) {
   switch (mode) {
     case ConvertReceiverMode::kAny:
-      builtin = Builtins::kCall_ReceiverIsAny_Baseline;
+      return Builtins::kCall_ReceiverIsAny_Baseline;
       break;
     case ConvertReceiverMode::kNullOrUndefined:
-      builtin = Builtins::kCall_ReceiverIsNullOrUndefined_Baseline;
+      return Builtins::kCall_ReceiverIsNullOrUndefined_Baseline;
       break;
     case ConvertReceiverMode::kNotNullOrUndefined:
-      builtin = Builtins::kCall_ReceiverIsNotNullOrUndefined_Baseline;
+      return Builtins::kCall_ReceiverIsNotNullOrUndefined_Baseline;
       break;
     default:
       UNREACHABLE();
   }
-  CallBuiltin(builtin,
-              RegisterOperand(0),  // kFunction
-              arg_count,           // kActualArgumentsCount
-              slot,                // kSlot
-              args...);            // Arguments
+}
+}  // namespace
+
+template <ConvertReceiverMode kMode, typename... Args>
+void BaselineCompiler::BuildCall(uint32_t slot, uint32_t arg_count,
+                                 Args... args) {
+  CallBuiltin<ConvertReceiverModeToBuiltin(kMode)>(
+      RegisterOperand(0),  // kFunction
+      arg_count,           // kActualArgumentsCount
+      slot,                // kSlot
+      args...);            // Arguments
 }
 
 void BaselineCompiler::VisitCallAnyReceiver() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count() - 1;  // Remove receiver.
-  BuildCall(ConvertReceiverMode::kAny, Index(3), arg_count, args);
+  BuildCall<ConvertReceiverMode::kAny>(Index(3), arg_count, args);
 }
 
 void BaselineCompiler::VisitCallProperty() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count() - 1;  // Remove receiver.
-  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(3), arg_count,
-            args);
+  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(Index(3), arg_count,
+                                                      args);
 }
 
 void BaselineCompiler::VisitCallProperty0() {
-  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(2), 0,
-            RegisterOperand(1));
+  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(Index(2), 0,
+                                                      RegisterOperand(1));
 }
 
 void BaselineCompiler::VisitCallProperty1() {
-  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(3), 1,
-            RegisterOperand(1), RegisterOperand(2));
+  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(
+      Index(3), 1, RegisterOperand(1), RegisterOperand(2));
 }
 
 void BaselineCompiler::VisitCallProperty2() {
-  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(4), 2,
-            RegisterOperand(1), RegisterOperand(2), RegisterOperand(3));
+  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(
+      Index(4), 2, RegisterOperand(1), RegisterOperand(2), RegisterOperand(3));
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count();
-  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(3), arg_count,
-            RootIndex::kUndefinedValue, args);
+  BuildCall<ConvertReceiverMode::kNullOrUndefined>(
+      Index(3), arg_count, RootIndex::kUndefinedValue, args);
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver0() {
-  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(1), 0,
-            RootIndex::kUndefinedValue);
+  BuildCall<ConvertReceiverMode::kNullOrUndefined>(Index(1), 0,
+                                                   RootIndex::kUndefinedValue);
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver1() {
-  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(2), 1,
-            RootIndex::kUndefinedValue, RegisterOperand(1));
+  BuildCall<ConvertReceiverMode::kNullOrUndefined>(
+      Index(2), 1, RootIndex::kUndefinedValue, RegisterOperand(1));
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver2() {
-  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(3), 2,
-            RootIndex::kUndefinedValue, RegisterOperand(1), RegisterOperand(2));
+  BuildCall<ConvertReceiverMode::kNullOrUndefined>(
+      Index(3), 2, RootIndex::kUndefinedValue, RegisterOperand(1),
+      RegisterOperand(2));
 }
 
 void BaselineCompiler::VisitCallNoFeedback() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count();
-  CallBuiltin(Builtins::kCall_ReceiverIsAny,
-              RegisterOperand(0),  // kFunction
-              arg_count - 1,       // kActualArgumentsCount
-              args);
+  CallBuiltin<Builtins::kCall_ReceiverIsAny>(
+      RegisterOperand(0),  // kFunction
+      arg_count - 1,       // kActualArgumentsCount
+      args);
 }
 
 void BaselineCompiler::VisitCallWithSpread() {
@@ -1198,12 +1207,12 @@ void BaselineCompiler::VisitCallWithSpread() {
 
   uint32_t arg_count = args.register_count() - 1;  // Remove receiver.
 
-  CallBuiltin(Builtins::kCallWithSpread_Baseline,
-              RegisterOperand(0),  // kFunction
-              arg_count,           // kActualArgumentsCount
-              spread_register,     // kSpread
-              Index(3),            // kSlot
-              args);
+  CallBuiltin<Builtins::kCallWithSpread_Baseline>(
+      RegisterOperand(0),  // kFunction
+      arg_count,           // kActualArgumentsCount
+      spread_register,     // kSpread
+      Index(3),            // kSlot
+      args);
 }
 
 void BaselineCompiler::VisitCallRuntime() {
@@ -1226,11 +1235,11 @@ void BaselineCompiler::VisitCallJSRuntime() {
   __ LoadContext(kContextRegister);
   __ LoadNativeContextSlot(kJavaScriptCallTargetRegister,
                            iterator().GetNativeContextIndexOperand(0));
-  CallBuiltin(Builtins::kCall_ReceiverIsNullOrUndefined,
-              kJavaScriptCallTargetRegister,  // kFunction
-              arg_count,                      // kActualArgumentsCount
-              RootIndex::kUndefinedValue,     // kReceiver
-              args);
+  CallBuiltin<Builtins::kCall_ReceiverIsNullOrUndefined>(
+      kJavaScriptCallTargetRegister,  // kFunction
+      arg_count,                      // kActualArgumentsCount
+      RootIndex::kUndefinedValue,     // kReceiver
+      args);
 }
 
 void BaselineCompiler::VisitInvokeIntrinsic() {
@@ -1301,29 +1310,29 @@ void BaselineCompiler::VisitIntrinsicIsSmi(interpreter::RegisterList args) {
 
 void BaselineCompiler::VisitIntrinsicCopyDataProperties(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kCopyDataProperties, args);
+  CallBuiltin<Builtins::kCopyDataProperties>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateIterResultObject(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kCreateIterResultObject, args);
+  CallBuiltin<Builtins::kCreateIterResultObject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicHasProperty(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kHasProperty, args);
+  CallBuiltin<Builtins::kHasProperty>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicToString(interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kToString, args);
+  CallBuiltin<Builtins::kToString>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicToLength(interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kToLength, args);
+  CallBuiltin<Builtins::kToLength>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicToObject(interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kToObject, args);
+  CallBuiltin<Builtins::kToObject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicCall(interpreter::RegisterList args) {
@@ -1335,20 +1344,20 @@ void BaselineCompiler::VisitIntrinsicCall(interpreter::RegisterList args) {
   args = args.PopLeft();
 
   uint32_t arg_count = args.register_count();
-  CallBuiltin(Builtins::kCall_ReceiverIsAny,
-              kJavaScriptCallTargetRegister,  // kFunction
-              arg_count - 1,                  // kActualArgumentsCount
-              args);
+  CallBuiltin<Builtins::kCall_ReceiverIsAny>(
+      kJavaScriptCallTargetRegister,  // kFunction
+      arg_count - 1,                  // kActualArgumentsCount
+      args);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateAsyncFromSyncIterator(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kCreateAsyncFromSyncIteratorBaseline, args[0]);
+  CallBuiltin<Builtins::kCreateAsyncFromSyncIteratorBaseline>(args[0]);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateJSGeneratorObject(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kCreateGeneratorObject, args);
+  CallBuiltin<Builtins::kCreateGeneratorObject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicGeneratorGetResumeMode(
@@ -1370,69 +1379,69 @@ void BaselineCompiler::VisitIntrinsicGeneratorClose(
 
 void BaselineCompiler::VisitIntrinsicGetImportMetaObject(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kGetImportMetaObjectBaseline);
+  CallBuiltin<Builtins::kGetImportMetaObjectBaseline>();
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionAwaitCaught(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncFunctionAwaitCaught, args);
+  CallBuiltin<Builtins::kAsyncFunctionAwaitCaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionAwaitUncaught(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncFunctionAwaitUncaught, args);
+  CallBuiltin<Builtins::kAsyncFunctionAwaitUncaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionEnter(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncFunctionEnter, args);
+  CallBuiltin<Builtins::kAsyncFunctionEnter>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionReject(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncFunctionReject, args);
+  CallBuiltin<Builtins::kAsyncFunctionReject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionResolve(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncFunctionResolve, args);
+  CallBuiltin<Builtins::kAsyncFunctionResolve>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorAwaitCaught(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncGeneratorAwaitCaught, args);
+  CallBuiltin<Builtins::kAsyncGeneratorAwaitCaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorAwaitUncaught(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncGeneratorAwaitUncaught, args);
+  CallBuiltin<Builtins::kAsyncGeneratorAwaitUncaught>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorReject(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncGeneratorReject, args);
+  CallBuiltin<Builtins::kAsyncGeneratorReject>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorResolve(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncGeneratorResolve, args);
+  CallBuiltin<Builtins::kAsyncGeneratorResolve>(args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorYield(
     interpreter::RegisterList args) {
-  CallBuiltin(Builtins::kAsyncGeneratorYield, args);
+  CallBuiltin<Builtins::kAsyncGeneratorYield>(args);
 }
 
 void BaselineCompiler::VisitConstruct() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count();
-  CallBuiltin(Builtins::kConstruct_Baseline,
-              RegisterOperand(0),               // kFunction
-              kInterpreterAccumulatorRegister,  // kNewTarget
-              arg_count,                        // kActualArgumentsCount
-              Index(3),                         // kSlot
-              RootIndex::kUndefinedValue,       // kReceiver
-              args);
+  CallBuiltin<Builtins::kConstruct_Baseline>(
+      RegisterOperand(0),               // kFunction
+      kInterpreterAccumulatorRegister,  // kNewTarget
+      arg_count,                        // kActualArgumentsCount
+      Index(3),                         // kSlot
+      RootIndex::kUndefinedValue,       // kReceiver
+      args);
 }
 
 void BaselineCompiler::VisitConstructWithSpread() {
@@ -1444,51 +1453,50 @@ void BaselineCompiler::VisitConstructWithSpread() {
 
   uint32_t arg_count = args.register_count();
 
+  using Descriptor =
+      CallInterfaceDescriptorFor<Builtins::kConstructWithSpread_Baseline>::type;
   Register new_target =
-      Builtins::CallInterfaceDescriptorFor(
-          Builtins::kConstructWithSpread_Baseline)
-          .GetRegisterParameter(
-              ConstructWithSpread_BaselineDescriptor::kNewTarget);
+      Descriptor::GetRegisterParameter(Descriptor::kNewTarget);
   __ Move(new_target, kInterpreterAccumulatorRegister);
 
-  CallBuiltin(Builtins::kConstructWithSpread_Baseline,
-              RegisterOperand(0),          // kFunction
-              new_target,                  // kNewTarget
-              arg_count,                   // kActualArgumentsCount
-              Index(3),                    // kSlot
-              spread_register,             // kSpread
-              RootIndex::kUndefinedValue,  // kReceiver
-              args);
-}
-
-void BaselineCompiler::BuildCompare(Builtins::Name builtin_name) {
-  CallBuiltin(builtin_name, RegisterOperand(0),  // lhs
-              kInterpreterAccumulatorRegister,   // rhs
-              Index(1));                         // slot
+  CallBuiltin<Builtins::kConstructWithSpread_Baseline>(
+      RegisterOperand(0),          // kFunction
+      new_target,                  // kNewTarget
+      arg_count,                   // kActualArgumentsCount
+      Index(3),                    // kSlot
+      spread_register,             // kSpread
+      RootIndex::kUndefinedValue,  // kReceiver
+      args);
 }
 
 void BaselineCompiler::VisitTestEqual() {
-  BuildCompare(Builtins::kEqual_Baseline);
+  CallBuiltin<Builtins::kEqual_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestEqualStrict() {
-  BuildCompare(Builtins::kStrictEqual_Baseline);
+  CallBuiltin<Builtins::kStrictEqual_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestLessThan() {
-  BuildCompare(Builtins::kLessThan_Baseline);
+  CallBuiltin<Builtins::kLessThan_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestGreaterThan() {
-  BuildCompare(Builtins::kGreaterThan_Baseline);
+  CallBuiltin<Builtins::kGreaterThan_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestLessThanOrEqual() {
-  BuildCompare(Builtins::kLessThanOrEqual_Baseline);
+  CallBuiltin<Builtins::kLessThanOrEqual_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestGreaterThanOrEqual() {
-  BuildCompare(Builtins::kGreaterThanOrEqual_Baseline);
+  CallBuiltin<Builtins::kGreaterThanOrEqual_Baseline>(
+      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitTestReferenceEqual() {
@@ -1502,21 +1510,21 @@ void BaselineCompiler::VisitTestReferenceEqual() {
 }
 
 void BaselineCompiler::VisitTestInstanceOf() {
-  Register callable =
-      Builtins::CallInterfaceDescriptorFor(Builtins::kInstanceOf_Baseline)
-          .GetRegisterParameter(Compare_BaselineDescriptor::kRight);
+  using Descriptor =
+      CallInterfaceDescriptorFor<Builtins::kInstanceOf_Baseline>::type;
+  Register callable = Descriptor::GetRegisterParameter(Descriptor::kRight);
   __ Move(callable, kInterpreterAccumulatorRegister);
-  CallBuiltin(Builtins::kInstanceOf_Baseline,
-              RegisterOperand(0),  // object
-              callable,            // callable
-              Index(1));           // slot
+
+  CallBuiltin<Builtins::kInstanceOf_Baseline>(RegisterOperand(0),  // object
+                                              callable,            // callable
+                                              Index(1));           // slot
 }
 
 void BaselineCompiler::VisitTestIn() {
-  CallBuiltin(Builtins::kKeyedHasICBaseline,
-              kInterpreterAccumulatorRegister,  // object
-              RegisterOperand(0),               // name
-              IndexAsTagged(1));                // slot
+  CallBuiltin<Builtins::kKeyedHasICBaseline>(
+      kInterpreterAccumulatorRegister,  // object
+      RegisterOperand(0),               // name
+      IndexAsTagged(1));                // slot
 }
 
 void BaselineCompiler::VisitTestUndetectable() {
@@ -1727,36 +1735,36 @@ void BaselineCompiler::VisitTestTypeOf() {
 
 void BaselineCompiler::VisitToName() {
   SaveAccumulatorScope save_accumulator(&basm_);
-  CallBuiltin(Builtins::kToName, kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtins::kToName>(kInterpreterAccumulatorRegister);
   StoreRegister(0, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitToNumber() {
-  CallBuiltin(Builtins::kToNumber_Baseline, kInterpreterAccumulatorRegister,
-              Index(0));
+  CallBuiltin<Builtins::kToNumber_Baseline>(kInterpreterAccumulatorRegister,
+                                            Index(0));
 }
 
 void BaselineCompiler::VisitToNumeric() {
-  CallBuiltin(Builtins::kToNumeric_Baseline, kInterpreterAccumulatorRegister,
-              Index(0));
+  CallBuiltin<Builtins::kToNumeric_Baseline>(kInterpreterAccumulatorRegister,
+                                             Index(0));
 }
 
 void BaselineCompiler::VisitToObject() {
   SaveAccumulatorScope save_accumulator(&basm_);
-  CallBuiltin(Builtins::kToObject, kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtins::kToObject>(kInterpreterAccumulatorRegister);
   StoreRegister(0, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitToString() {
-  CallBuiltin(Builtins::kToString, kInterpreterAccumulatorRegister);
+  CallBuiltin<Builtins::kToString>(kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitCreateRegExpLiteral() {
-  CallBuiltin(Builtins::kCreateRegExpLiteral,
-              FeedbackVector(),         // feedback vector
-              IndexAsTagged(1),         // slot
-              Constant<HeapObject>(0),  // pattern
-              FlagAsSmi(2));            // flags
+  CallBuiltin<Builtins::kCreateRegExpLiteral>(
+      FeedbackVector(),         // feedback vector
+      IndexAsTagged(1),         // slot
+      Constant<HeapObject>(0),  // pattern
+      FlagAsSmi(2));            // flags
 }
 
 void BaselineCompiler::VisitCreateArrayLiteral() {
@@ -1765,11 +1773,11 @@ void BaselineCompiler::VisitCreateArrayLiteral() {
       interpreter::CreateArrayLiteralFlags::FlagsBits::decode(flags));
   if (flags &
       interpreter::CreateArrayLiteralFlags::FastCloneSupportedBit::kMask) {
-    CallBuiltin(Builtins::kCreateShallowArrayLiteral,
-                FeedbackVector(),          // feedback vector
-                IndexAsTagged(1),          // slot
-                Constant<HeapObject>(0),   // constant elements
-                Smi::FromInt(flags_raw));  // flags
+    CallBuiltin<Builtins::kCreateShallowArrayLiteral>(
+        FeedbackVector(),          // feedback vector
+        IndexAsTagged(1),          // slot
+        Constant<HeapObject>(0),   // constant elements
+        Smi::FromInt(flags_raw));  // flags
   } else {
     CallRuntime(Runtime::kCreateArrayLiteral,
                 FeedbackVector(),          // feedback vector
@@ -1780,13 +1788,13 @@ void BaselineCompiler::VisitCreateArrayLiteral() {
 }
 
 void BaselineCompiler::VisitCreateArrayFromIterable() {
-  CallBuiltin(Builtins::kIterableToListWithSymbolLookup,
-              kInterpreterAccumulatorRegister);  // iterable
+  CallBuiltin<Builtins::kIterableToListWithSymbolLookup>(
+      kInterpreterAccumulatorRegister);  // iterable
 }
 
 void BaselineCompiler::VisitCreateEmptyArrayLiteral() {
-  CallBuiltin(Builtins::kCreateEmptyArrayLiteral, FeedbackVector(),
-              IndexAsTagged(0));
+  CallBuiltin<Builtins::kCreateEmptyArrayLiteral>(FeedbackVector(),
+                                                  IndexAsTagged(0));
 }
 
 void BaselineCompiler::VisitCreateObjectLiteral() {
@@ -1795,11 +1803,11 @@ void BaselineCompiler::VisitCreateObjectLiteral() {
       interpreter::CreateObjectLiteralFlags::FlagsBits::decode(flags));
   if (flags &
       interpreter::CreateObjectLiteralFlags::FastCloneSupportedBit::kMask) {
-    CallBuiltin(Builtins::kCreateShallowObjectLiteral,
-                FeedbackVector(),                           // feedback vector
-                IndexAsTagged(1),                           // slot
-                Constant<ObjectBoilerplateDescription>(0),  // boilerplate
-                Smi::FromInt(flags_raw));                   // flags
+    CallBuiltin<Builtins::kCreateShallowObjectLiteral>(
+        FeedbackVector(),                           // feedback vector
+        IndexAsTagged(1),                           // slot
+        Constant<ObjectBoilerplateDescription>(0),  // boilerplate
+        Smi::FromInt(flags_raw));                   // flags
   } else {
     CallRuntime(Runtime::kCreateObjectLiteral,
                 FeedbackVector(),                           // feedback vector
@@ -1810,39 +1818,40 @@ void BaselineCompiler::VisitCreateObjectLiteral() {
 }
 
 void BaselineCompiler::VisitCreateEmptyObjectLiteral() {
-  CallBuiltin(Builtins::kCreateEmptyLiteralObject);
+  CallBuiltin<Builtins::kCreateEmptyLiteralObject>();
 }
 
 void BaselineCompiler::VisitCloneObject() {
   uint32_t flags = Flag(1);
   int32_t raw_flags =
       interpreter::CreateObjectLiteralFlags::FlagsBits::decode(flags);
-  CallBuiltin(Builtins::kCloneObjectICBaseline,
-              RegisterOperand(0),       // source
-              Smi::FromInt(raw_flags),  // flags
-              IndexAsTagged(2));        // slot
+  CallBuiltin<Builtins::kCloneObjectICBaseline>(
+      RegisterOperand(0),       // source
+      Smi::FromInt(raw_flags),  // flags
+      IndexAsTagged(2));        // slot
 }
 
 void BaselineCompiler::VisitGetTemplateObject() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
-  CallBuiltin(Builtins::kGetTemplateObject,
-              shared_function_info_,    // shared function info
-              Constant<HeapObject>(0),  // description
-              Index(1),                 // slot
-              FeedbackVector());        // feedback_vector
+  CallBuiltin<Builtins::kGetTemplateObject>(
+      shared_function_info_,    // shared function info
+      Constant<HeapObject>(0),  // description
+      Index(1),                 // slot
+      FeedbackVector());        // feedback_vector
 }
 
 void BaselineCompiler::VisitCreateClosure() {
+  using Descriptor =
+      CallInterfaceDescriptorFor<Builtins::kFastNewClosure>::type;
   Register feedback_cell =
-      Builtins::CallInterfaceDescriptorFor(Builtins::kFastNewClosure)
-          .GetRegisterParameter(FastNewClosureDescriptor::kFeedbackCell);
+      Descriptor::GetRegisterParameter(Descriptor::kFeedbackCell);
   LoadClosureFeedbackArray(feedback_cell);
   __ LoadFixedArrayElement(feedback_cell, feedback_cell, Index(1));
 
   uint32_t flags = Flag(2);
   if (interpreter::CreateClosureFlags::FastNewClosureBit::decode(flags)) {
-    CallBuiltin(Builtins::kFastNewClosure, Constant<SharedFunctionInfo>(0),
-                feedback_cell);
+    CallBuiltin<Builtins::kFastNewClosure>(Constant<SharedFunctionInfo>(0),
+                                           feedback_cell);
   } else {
     Runtime::FunctionId function_id =
         interpreter::CreateClosureFlags::PretenuredBit::decode(flags)
@@ -1868,7 +1877,7 @@ void BaselineCompiler::VisitCreateFunctionContext() {
   if (slot_count < static_cast<uint32_t>(
                        ConstructorBuiltins::MaximumFunctionContextSlots())) {
     DCHECK_EQ(info->scope_type(), ScopeType::FUNCTION_SCOPE);
-    CallBuiltin(Builtins::kFastNewFunctionContextFunction, info, slot_count);
+    CallBuiltin<Builtins::kFastNewFunctionContextFunction>(info, slot_count);
   } else {
     CallRuntime(Runtime::kNewFunctionContext, Constant<ScopeInfo>(0));
   }
@@ -1880,7 +1889,7 @@ void BaselineCompiler::VisitCreateEvalContext() {
   if (slot_count < static_cast<uint32_t>(
                        ConstructorBuiltins::MaximumFunctionContextSlots())) {
     DCHECK_EQ(info->scope_type(), ScopeType::EVAL_SCOPE);
-    CallBuiltin(Builtins::kFastNewFunctionContextEval, info, slot_count);
+    CallBuiltin<Builtins::kFastNewFunctionContextEval>(info, slot_count);
   } else {
     CallRuntime(Runtime::kNewFunctionContext, Constant<ScopeInfo>(0));
   }
@@ -1896,16 +1905,16 @@ void BaselineCompiler::VisitCreateMappedArguments() {
   if (shared_function_info_->has_duplicate_parameters()) {
     CallRuntime(Runtime::kNewSloppyArguments, __ FunctionOperand());
   } else {
-    CallBuiltin(Builtins::kFastNewSloppyArguments, __ FunctionOperand());
+    CallBuiltin<Builtins::kFastNewSloppyArguments>(__ FunctionOperand());
   }
 }
 
 void BaselineCompiler::VisitCreateUnmappedArguments() {
-  CallBuiltin(Builtins::kFastNewStrictArguments, __ FunctionOperand());
+  CallBuiltin<Builtins::kFastNewStrictArguments>(__ FunctionOperand());
 }
 
 void BaselineCompiler::VisitCreateRestParameter() {
-  CallBuiltin(Builtins::kFastNewRestArguments, __ FunctionOperand());
+  CallBuiltin<Builtins::kFastNewRestArguments>(__ FunctionOperand());
 }
 
 void BaselineCompiler::VisitJumpLoop() {
@@ -1919,7 +1928,7 @@ void BaselineCompiler::VisitJumpLoop() {
   int loop_depth = iterator().GetImmediateOperand(1);
   __ CompareByte(osr_level, loop_depth);
   __ JumpIf(Condition::kUnsignedLessThanEqual, &osr_not_armed);
-  CallBuiltin(Builtins::kBaselineOnStackReplacement);
+  CallBuiltin<Builtins::kBaselineOnStackReplacement>();
   __ RecordComment("]");
 
   __ Bind(&osr_not_armed);
@@ -2057,13 +2066,13 @@ void BaselineCompiler::VisitSwitchOnSmiNoFeedback() {
 }
 
 void BaselineCompiler::VisitForInEnumerate() {
-  CallBuiltin(Builtins::kForInEnumerate, RegisterOperand(0));
+  CallBuiltin<Builtins::kForInEnumerate>(RegisterOperand(0));
 }
 
 void BaselineCompiler::VisitForInPrepare() {
   StoreRegister(0, kInterpreterAccumulatorRegister);
-  CallBuiltin(Builtins::kForInPrepare, kInterpreterAccumulatorRegister,
-              IndexAsTagged(1), FeedbackVector());
+  CallBuiltin<Builtins::kForInPrepare>(kInterpreterAccumulatorRegister,
+                                       IndexAsTagged(1), FeedbackVector());
   interpreter::Register first = iterator().GetRegisterOperand(0);
   interpreter::Register second(first.index() + 1);
   interpreter::Register third(first.index() + 2);
@@ -2085,13 +2094,12 @@ void BaselineCompiler::VisitForInContinue() {
 void BaselineCompiler::VisitForInNext() {
   interpreter::Register cache_type, cache_array;
   std::tie(cache_type, cache_array) = iterator().GetRegisterPairOperand(2);
-  CallBuiltin(Builtins::kForInNext,
-              Index(3),            // vector slot
-              RegisterOperand(0),  // object
-              cache_array,         // cache array
-              cache_type,          // cache type
-              RegisterOperand(1),  // index
-              FeedbackVector());   // feedback vector
+  CallBuiltin<Builtins::kForInNext>(Index(3),            // vector slot
+                                    RegisterOperand(0),  // object
+                                    cache_array,         // cache array
+                                    cache_type,          // cache type
+                                    RegisterOperand(1),  // index
+                                    FeedbackVector());   // feedback vector
 }
 
 void BaselineCompiler::VisitForInStep() {
@@ -2131,8 +2139,8 @@ void BaselineCompiler::VisitReturn() {
   int parameter_count_without_receiver =
       parameter_count - 1;  // Exclude the receiver to simplify the
                             // computation. We'll account for it at the end.
-  TailCallBuiltin(Builtins::kBaselineLeaveFrame,
-                  parameter_count_without_receiver, -profiling_weight);
+  TailCallBuiltin<Builtins::kBaselineLeaveFrame>(
+      parameter_count_without_receiver, -profiling_weight);
   __ RecordComment("]");
 }
 
@@ -2235,10 +2243,11 @@ void BaselineCompiler::VisitSuspendGenerator() {
 
     int bytecode_offset =
         BytecodeArray::kHeaderSize + iterator().current_offset();
-    CallBuiltin(Builtins::kSuspendGeneratorBaseline, generator_object,
-                static_cast<int>(Uint(3)),  // suspend_id
-                bytecode_offset,
-                static_cast<int>(RegisterCount(2)));  // register_count
+    CallBuiltin<Builtins::kSuspendGeneratorBaseline>(
+        generator_object,
+        static_cast<int>(Uint(3)),  // suspend_id
+        bytecode_offset,
+        static_cast<int>(RegisterCount(2)));  // register_count
   }
   VisitReturn();
 }
@@ -2248,26 +2257,27 @@ void BaselineCompiler::VisitResumeGenerator() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register generator_object = scratch_scope.AcquireScratch();
   LoadRegister(generator_object, 0);
-  CallBuiltin(Builtins::kResumeGeneratorBaseline, generator_object,
-              static_cast<int>(RegisterCount(2)));  // register_count
+  CallBuiltin<Builtins::kResumeGeneratorBaseline>(
+      generator_object,
+      static_cast<int>(RegisterCount(2)));  // register_count
 }
 
 void BaselineCompiler::VisitGetIterator() {
-  CallBuiltin(Builtins::kGetIteratorBaseline,
-              RegisterOperand(0),  // receiver
-              IndexAsTagged(1),    // load_slot
-              IndexAsTagged(2));   // call_slot
+  CallBuiltin<Builtins::kGetIteratorBaseline>(RegisterOperand(0),  // receiver
+                                              IndexAsTagged(1),    // load_slot
+                                              IndexAsTagged(2));   // call_slot
 }
 
 void BaselineCompiler::VisitDebugger() {
   SaveAccumulatorScope accumulator_scope(&basm_);
-  CallBuiltin(Builtins::kHandleDebuggerStatement);
+  CallBuiltin<Builtins::kHandleDebuggerStatement>();
 }
 
 void BaselineCompiler::VisitIncBlockCounter() {
   SaveAccumulatorScope accumulator_scope(&basm_);
-  CallBuiltin(Builtins::kIncBlockCounter, __ FunctionOperand(),
-              IndexAsSmi(0));  // coverage array slot
+  CallBuiltin<Builtins::kIncBlockCounter>(
+      __ FunctionOperand(),
+      IndexAsSmi(0));  // coverage array slot
 }
 
 void BaselineCompiler::VisitAbort() {
diff --git a/src/baseline/baseline-compiler.h b/src/baseline/baseline-compiler.h
index 2a625a9aac4..458b8a0bb55 100644
--- a/src/baseline/baseline-compiler.h
+++ b/src/baseline/baseline-compiler.h
@@ -126,26 +126,16 @@ class BaselineCompiler {
                        Label::Distance distance = Label::kFar);
 
   // Call helpers.
-  template <typename... Args>
-  void CallBuiltin(Builtins::Name builtin, Args... args);
+  template <Builtins::Name kBuiltin, typename... Args>
+  void CallBuiltin(Args... args);
   template <typename... Args>
   void CallRuntime(Runtime::FunctionId function, Args... args);
 
-  template <typename... Args>
-  void TailCallBuiltin(Builtins::Name builtin, Args... args);
-
-  void BuildBinop(
-      Builtins::Name builtin_name, bool fast_path = false,
-      bool check_overflow = false,
-      std::function<void(Register, Register)> instruction = [](Register,
-                                                               Register) {});
-  void BuildUnop(Builtins::Name builtin_name);
-  void BuildCompare(Builtins::Name builtin_name);
-  void BuildBinopWithConstant(Builtins::Name builtin_name);
+  template <Builtins::Name kBuiltin, typename... Args>
+  void TailCallBuiltin(Args... args);
 
-  template <typename... Args>
-  void BuildCall(ConvertReceiverMode mode, uint32_t slot, uint32_t arg_count,
-                 Args... args);
+  template <ConvertReceiverMode kMode, typename... Args>
+  void BuildCall(uint32_t slot, uint32_t arg_count, Args... args);
 
 #ifdef V8_TRACE_UNOPTIMIZED
   void TraceBytecode(Runtime::FunctionId function_id);
diff --git a/src/baseline/ia32/baseline-compiler-ia32-inl.h b/src/baseline/ia32/baseline-compiler-ia32-inl.h
index 733c05fe185..4d09f536653 100644
--- a/src/baseline/ia32/baseline-compiler-ia32-inl.h
+++ b/src/baseline/ia32/baseline-compiler-ia32-inl.h
@@ -18,9 +18,9 @@ namespace baseline {
 void BaselineCompiler::Prologue() {
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
-              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   PrologueFillFrame();
 }
diff --git a/src/baseline/x64/baseline-assembler-x64-inl.h b/src/baseline/x64/baseline-assembler-x64-inl.h
index 202f83c7615..7c59f380e3e 100644
--- a/src/baseline/x64/baseline-assembler-x64-inl.h
+++ b/src/baseline/x64/baseline-assembler-x64-inl.h
@@ -7,7 +7,6 @@
 
 #include "src/base/macros.h"
 #include "src/baseline/baseline-assembler.h"
-#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/x64/register-x64.h"
 
 namespace v8 {
diff --git a/src/baseline/x64/baseline-compiler-x64-inl.h b/src/baseline/x64/baseline-compiler-x64-inl.h
index 73b43770e56..a4d547b0671 100644
--- a/src/baseline/x64/baseline-compiler-x64-inl.h
+++ b/src/baseline/x64/baseline-compiler-x64-inl.h
@@ -18,9 +18,9 @@ namespace baseline {
 void BaselineCompiler::Prologue() {
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
-              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
+      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   PrologueFillFrame();
 }
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index 37e0bb352bd..33627dc656a 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -6,6 +6,7 @@
 
 #include "src/api/api-arguments.h"
 #include "src/codegen/code-factory.h"
+#include "src/codegen/interface-descriptors-inl.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index 09733abc3aa..8856b6d0d29 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -6,6 +6,7 @@
 
 #include "src/api/api-arguments.h"
 #include "src/codegen/code-factory.h"
+#include "src/codegen/interface-descriptors-inl.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.cc
index 6b522fda6c0..833627c7b41 100644
--- a/src/builtins/builtins-array-gen.cc
+++ b/src/builtins/builtins-array-gen.cc
@@ -10,6 +10,7 @@
 #include "src/builtins/builtins-utils-gen.h"
 #include "src/builtins/builtins.h"
 #include "src/codegen/code-stub-assembler.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/execution/frame-constants.h"
 #include "src/heap/factory-inl.h"
 #include "src/objects/allocation-site-inl.h"
diff --git a/src/builtins/builtins-internal-gen.cc b/src/builtins/builtins-internal-gen.cc
index a2015e0d0b3..c2e9767f30a 100644
--- a/src/builtins/builtins-internal-gen.cc
+++ b/src/builtins/builtins-internal-gen.cc
@@ -7,6 +7,7 @@
 #include "src/builtins/builtins-utils-gen.h"
 #include "src/builtins/builtins.h"
 #include "src/codegen/code-stub-assembler.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/execution/frame-constants.h"
 #include "src/heap/memory-chunk.h"
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 4008c01c59a..30fa3ebcc73 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -8,6 +8,7 @@
 #include "src/base/bits-iterator.h"
 #include "src/base/iterator.h"
 #include "src/codegen/code-factory.h"
+#include "src/codegen/interface-descriptors-inl.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
@@ -1458,7 +1459,7 @@ void Builtins::Generate_InterpreterPushArgsThenConstructImpl(
   // and edi are used as scratch registers.
   Generate_InterpreterPushZeroAndArgsAndReturnAddress(
       masm, eax, ecx, edx, edi,
-      InterpreterPushArgsThenConstructDescriptor::kStackArgumentsCount,
+      InterpreterPushArgsThenConstructDescriptor::GetStackParameterCount(),
       &stack_overflow);
 
   // Call the appropriate constructor. eax and ecx already contain intended
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index 48398cf9faa..d2dff202d2b 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -8,18 +8,19 @@
 #include "src/base/bits-iterator.h"
 #include "src/base/iterator.h"
 #include "src/codegen/code-factory.h"
-#include "src/common/globals.h"
-#include "src/objects/code.h"
+#include "src/codegen/interface-descriptors-inl.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
 #include "src/codegen/x64/assembler-x64.h"
+#include "src/common/globals.h"
 #include "src/deoptimizer/deoptimizer.h"
 #include "src/execution/frame-constants.h"
 #include "src/execution/frames.h"
 #include "src/heap/heap-inl.h"
 #include "src/logging/counters.h"
 #include "src/objects/cell.h"
+#include "src/objects/code.h"
 #include "src/objects/debug-objects.h"
 #include "src/objects/foreign.h"
 #include "src/objects/heap-number.h"
diff --git a/src/codegen/arm/interface-descriptors-arm-inl.h b/src/codegen/arm/interface-descriptors-arm-inl.h
new file mode 100644
index 00000000000..d2ce1204f15
--- /dev/null
+++ b/src/codegen/arm/interface-descriptors-arm-inl.h
@@ -0,0 +1,261 @@
+// Copyright 2021 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_ARM_INTERFACE_DESCRIPTORS_ARM_INL_H_
+#define V8_CODEGEN_ARM_INTERFACE_DESCRIPTORS_ARM_INL_H_
+
+#if V8_TARGET_ARCH_ARM
+
+#include "src/codegen/interface-descriptors.h"
+#include "src/execution/frames.h"
+
+namespace v8 {
+namespace internal {
+
+constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
+  auto registers = RegisterArray(r0, r1, r2, r3, r4);
+  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
+  return registers;
+}
+
+// static
+constexpr auto RecordWriteDescriptor::registers() {
+  return RegisterArray(r0, r1, r2, r3, r4, kReturnRegister0);
+}
+
+// static
+constexpr auto DynamicCheckMapsDescriptor::registers() {
+  return RegisterArray(r0, r1, r2, r3, cp);
+}
+
+// static
+constexpr auto EphemeronKeyBarrierDescriptor::registers() {
+  return RegisterArray(r0, r1, r2, r3, r4, kReturnRegister0);
+}
+
+// static
+constexpr Register LoadDescriptor::ReceiverRegister() { return r1; }
+// static
+constexpr Register LoadDescriptor::NameRegister() { return r2; }
+// static
+constexpr Register LoadDescriptor::SlotRegister() { return r0; }
+
+// static
+constexpr Register LoadWithVectorDescriptor::VectorRegister() { return r3; }
+
+// static
+constexpr Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return r4;
+}
+
+// static
+constexpr Register StoreDescriptor::ReceiverRegister() { return r1; }
+// static
+constexpr Register StoreDescriptor::NameRegister() { return r2; }
+// static
+constexpr Register StoreDescriptor::ValueRegister() { return r0; }
+// static
+constexpr Register StoreDescriptor::SlotRegister() { return r4; }
+
+// static
+constexpr Register StoreWithVectorDescriptor::VectorRegister() { return r3; }
+
+// static
+constexpr Register StoreTransitionDescriptor::MapRegister() { return r5; }
+
+// static
+constexpr Register ApiGetterDescriptor::HolderRegister() { return r0; }
+// static
+constexpr Register ApiGetterDescriptor::CallbackRegister() { return r3; }
+
+// static
+constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return r0; }
+// static
+constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return r3; }
+
+// static
+constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
+  return r3;
+}
+// static
+constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() { return r4; }
+
+// static
+// static
+constexpr Register TypeConversionDescriptor::ArgumentRegister() { return r0; }
+
+// static
+constexpr auto TypeofDescriptor::registers() { return RegisterArray(r3); }
+
+// static
+constexpr auto CallTrampolineDescriptor::registers() {
+  // r0 : number of arguments
+  // r1 : the target to call
+  return RegisterArray(r1, r0);
+}
+
+// static
+constexpr auto CallVarargsDescriptor::registers() {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r4 : arguments list length (untagged)
+  // r2 : arguments list (FixedArray)
+  return RegisterArray(r1, r0, r4, r2);
+}
+
+// static
+constexpr auto CallForwardVarargsDescriptor::registers() {
+  // r0 : number of arguments
+  // r2 : start index (to support rest parameters)
+  // r1 : the target to call
+  return RegisterArray(r1, r0, r2);
+}
+
+// static
+constexpr auto CallFunctionTemplateDescriptor::registers() {
+  // r1 : function template info
+  // r2 : number of arguments (on the stack, not including receiver)
+  return RegisterArray(r1, r2);
+}
+
+// static
+constexpr auto CallWithSpreadDescriptor::registers() {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r2 : the object to spread
+  return RegisterArray(r1, r0, r2);
+}
+
+// static
+constexpr auto CallWithArrayLikeDescriptor::registers() {
+  // r1 : the target to call
+  // r2 : the arguments list
+  return RegisterArray(r1, r2);
+}
+
+// static
+constexpr auto ConstructVarargsDescriptor::registers() {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r3 : the new target
+  // r4 : arguments list length (untagged)
+  // r2 : arguments list (FixedArray)
+  return RegisterArray(r1, r3, r0, r4, r2);
+}
+
+// static
+constexpr auto ConstructForwardVarargsDescriptor::registers() {
+  // r0 : number of arguments
+  // r3 : the new target
+  // r2 : start index (to support rest parameters)
+  // r1 : the target to call
+  return RegisterArray(r1, r3, r0, r2);
+}
+
+// static
+constexpr auto ConstructWithSpreadDescriptor::registers() {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r3 : the new target
+  // r2 : the object to spread
+  return RegisterArray(r1, r3, r0, r2);
+}
+
+// static
+constexpr auto ConstructWithArrayLikeDescriptor::registers() {
+  // r1 : the target to call
+  // r3 : the new target
+  // r2 : the arguments list
+  return RegisterArray(r1, r3, r2);
+}
+
+// static
+constexpr auto ConstructStubDescriptor::registers() {
+  // r0 : number of arguments
+  // r1 : the target to call
+  // r3 : the new target
+  // r2 : allocation site or undefined
+  return RegisterArray(r1, r3, r0, r2);
+}
+
+// static
+constexpr auto AbortDescriptor::registers() { return RegisterArray(r1); }
+
+// static
+constexpr auto CompareDescriptor::registers() { return RegisterArray(r1, r0); }
+
+// static
+constexpr auto Compare_BaselineDescriptor::registers() {
+  // r1: left operand
+  // r0: right operand
+  // r2: feedback slot
+  return RegisterArray(r1, r0, r2);
+}
+
+// static
+constexpr auto BinaryOpDescriptor::registers() { return RegisterArray(r1, r0); }
+
+// static
+constexpr auto BinaryOp_BaselineDescriptor::registers() {
+  // r1: left operand
+  // r0: right operand
+  // r2: feedback slot
+  return RegisterArray(r1, r0, r2);
+}
+
+// static
+constexpr auto ApiCallbackDescriptor::registers() {
+  return RegisterArray(r1,   // kApiFunctionAddress
+                       r2,   // kArgc
+                       r3,   // kCallData
+                       r0);  // kHolder
+}
+
+// static
+constexpr auto InterpreterDispatchDescriptor::registers() {
+  return RegisterArray(
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
+}
+
+// static
+constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
+  return RegisterArray(r0,   // argument count (not including receiver)
+                       r2,   // address of first argument
+                       r1);  // the target callable to be call
+}
+
+// static
+constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
+  return RegisterArray(
+      r0,   // argument count (not including receiver)
+      r4,   // address of the first argument
+      r1,   // constructor to call
+      r3,   // new target
+      r2);  // allocation site feedback if available, undefined otherwise
+}
+
+// static
+constexpr auto ResumeGeneratorDescriptor::registers() {
+  return RegisterArray(r0,   // the value to pass to the generator
+                       r1);  // the JSGeneratorObject to resume
+}
+
+// static
+constexpr auto FrameDropperTrampolineDescriptor::registers() {
+  return RegisterArray(r1);  // loaded new FP
+}
+
+// static
+constexpr auto RunMicrotasksEntryDescriptor::registers() {
+  return RegisterArray(r0, r1);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_ARM
+
+#endif  // V8_CODEGEN_ARM_INTERFACE_DESCRIPTORS_ARM_INL_H_
diff --git a/src/codegen/arm/interface-descriptors-arm.cc b/src/codegen/arm/interface-descriptors-arm.cc
deleted file mode 100644
index 53992227ab3..00000000000
--- a/src/codegen/arm/interface-descriptors-arm.cc
+++ /dev/null
@@ -1,306 +0,0 @@
-// Copyright 2012 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#if V8_TARGET_ARCH_ARM
-
-#include "src/codegen/interface-descriptors.h"
-
-#include "src/execution/frames.h"
-
-namespace v8 {
-namespace internal {
-
-const Register CallInterfaceDescriptor::ContextRegister() { return cp; }
-
-void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
-    CallInterfaceDescriptorData* data, int register_parameter_count) {
-  const Register default_stub_registers[] = {r0, r1, r2, r3, r4};
-  CHECK_LE(static_cast<size_t>(register_parameter_count),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(register_parameter_count,
-                                   default_stub_registers);
-}
-
-void RecordWriteDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  const Register default_stub_registers[] = {r0, r1, r2, r3, r4};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register default_stub_registers[] = {r0, r1, r2, r3, cp};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  const Register default_stub_registers[] = {r0, r1, r2, r3, r4};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-const Register LoadDescriptor::ReceiverRegister() { return r1; }
-const Register LoadDescriptor::NameRegister() { return r2; }
-const Register LoadDescriptor::SlotRegister() { return r0; }
-
-const Register LoadWithVectorDescriptor::VectorRegister() { return r3; }
-
-const Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return r4;
-}
-
-const Register StoreDescriptor::ReceiverRegister() { return r1; }
-const Register StoreDescriptor::NameRegister() { return r2; }
-const Register StoreDescriptor::ValueRegister() { return r0; }
-const Register StoreDescriptor::SlotRegister() { return r4; }
-
-const Register StoreWithVectorDescriptor::VectorRegister() { return r3; }
-
-const Register StoreTransitionDescriptor::SlotRegister() { return r4; }
-const Register StoreTransitionDescriptor::VectorRegister() { return r3; }
-const Register StoreTransitionDescriptor::MapRegister() { return r5; }
-
-const Register ApiGetterDescriptor::HolderRegister() { return r0; }
-const Register ApiGetterDescriptor::CallbackRegister() { return r3; }
-
-const Register GrowArrayElementsDescriptor::ObjectRegister() { return r0; }
-const Register GrowArrayElementsDescriptor::KeyRegister() { return r3; }
-
-const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() { return r3; }
-const Register BaselineLeaveFrameDescriptor::WeightRegister() { return r4; }
-
-// static
-const Register TypeConversionDescriptor::ArgumentRegister() { return r0; }
-
-void TypeofDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {r3};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments
-  // r1 : the target to call
-  Register registers[] = {r1, r0};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r4 : arguments list length (untagged)
-  // r2 : arguments list (FixedArray)
-  Register registers[] = {r1, r0, r4, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments
-  // r2 : start index (to support rest parameters)
-  // r1 : the target to call
-  Register registers[] = {r1, r0, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r1 : function template info
-  // r2 : number of arguments (on the stack, not including receiver)
-  Register registers[] = {r1, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r2 : the object to spread
-  Register registers[] = {r1, r0, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r1 : the target to call
-  // r2 : the arguments list
-  Register registers[] = {r1, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r3 : the new target
-  // r4 : arguments list length (untagged)
-  // r2 : arguments list (FixedArray)
-  Register registers[] = {r1, r3, r0, r4, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments
-  // r3 : the new target
-  // r2 : start index (to support rest parameters)
-  // r1 : the target to call
-  Register registers[] = {r1, r3, r0, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r3 : the new target
-  // r2 : the object to spread
-  Register registers[] = {r1, r3, r0, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r1 : the target to call
-  // r3 : the new target
-  // r2 : the arguments list
-  Register registers[] = {r1, r3, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructStubDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r0 : number of arguments
-  // r1 : the target to call
-  // r3 : the new target
-  // r2 : allocation site or undefined
-  Register registers[] = {r1, r3, r0, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void AbortDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {r1};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CompareDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {r1, r0};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void Compare_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r1: left operand
-  // r0: right operand
-  // r2: feedback slot
-  Register registers[] = {r1, r0, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOpDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {r1, r0};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // r1: left operand
-  // r0: right operand
-  // r2: feedback slot
-  Register registers[] = {r1, r0, r2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ApiCallbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      r1,  // kApiFunctionAddress
-      r2,  // kArgc
-      r3,  // kCallData
-      r0,  // kHolder
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterDispatchDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      r0,  // argument count (not including receiver)
-      r2,  // address of first argument
-      r1   // the target callable to be call
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      r0,  // argument count (not including receiver)
-      r4,  // address of the first argument
-      r1,  // constructor to call
-      r3,  // new target
-      r2,  // allocation site feedback if available, undefined otherwise
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ResumeGeneratorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      r0,  // the value to pass to the generator
-      r1   // the JSGeneratorObject to resume
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      r1,  // loaded new FP
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {r0, r1};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_ARM
diff --git a/src/codegen/arm/macro-assembler-arm.cc b/src/codegen/arm/macro-assembler-arm.cc
index f83eee4a919..34929119997 100644
--- a/src/codegen/arm/macro-assembler-arm.cc
+++ b/src/codegen/arm/macro-assembler-arm.cc
@@ -13,6 +13,7 @@
 #include "src/codegen/callable.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/external-reference-table.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/register-configuration.h"
 #include "src/debug/debug.h"
diff --git a/src/codegen/arm64/interface-descriptors-arm64-inl.h b/src/codegen/arm64/interface-descriptors-arm64-inl.h
new file mode 100644
index 00000000000..0ac1d2adca2
--- /dev/null
+++ b/src/codegen/arm64/interface-descriptors-arm64-inl.h
@@ -0,0 +1,270 @@
+// Copyright 2021 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_ARM64_INTERFACE_DESCRIPTORS_ARM64_INL_H_
+#define V8_CODEGEN_ARM64_INTERFACE_DESCRIPTORS_ARM64_INL_H_
+
+#if V8_TARGET_ARCH_ARM64
+
+#include "src/base/template-utils.h"
+#include "src/codegen/interface-descriptors.h"
+#include "src/execution/frames.h"
+
+namespace v8 {
+namespace internal {
+
+constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
+  auto registers = RegisterArray(x0, x1, x2, x3, x4);
+  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
+  return registers;
+}
+
+// static
+constexpr auto RecordWriteDescriptor::registers() {
+  return RegisterArray(x0, x1, x2, x3, x4, kReturnRegister0);
+}
+
+// static
+constexpr auto DynamicCheckMapsDescriptor::registers() {
+  return RegisterArray(x0, x1, x2, x3, cp);
+}
+
+// static
+constexpr auto EphemeronKeyBarrierDescriptor::registers() {
+  return RegisterArray(x0, x1, x2, x3, x4, kReturnRegister0);
+}
+
+// static
+constexpr Register LoadDescriptor::ReceiverRegister() { return x1; }
+// static
+constexpr Register LoadDescriptor::NameRegister() { return x2; }
+// static
+constexpr Register LoadDescriptor::SlotRegister() { return x0; }
+
+// static
+constexpr Register LoadWithVectorDescriptor::VectorRegister() { return x3; }
+
+// static
+constexpr Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return x4;
+}
+
+// static
+constexpr Register StoreDescriptor::ReceiverRegister() { return x1; }
+// static
+constexpr Register StoreDescriptor::NameRegister() { return x2; }
+// static
+constexpr Register StoreDescriptor::ValueRegister() { return x0; }
+// static
+constexpr Register StoreDescriptor::SlotRegister() { return x4; }
+
+// static
+constexpr Register StoreWithVectorDescriptor::VectorRegister() { return x3; }
+
+// static
+constexpr Register StoreTransitionDescriptor::MapRegister() { return x5; }
+
+// static
+constexpr Register ApiGetterDescriptor::HolderRegister() { return x0; }
+// static
+constexpr Register ApiGetterDescriptor::CallbackRegister() { return x3; }
+
+// static
+constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return x0; }
+// static
+constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return x3; }
+
+// static
+constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
+  return x3;
+}
+// static
+constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() { return x4; }
+
+// static
+// static
+constexpr Register TypeConversionDescriptor::ArgumentRegister() { return x0; }
+
+// static
+constexpr auto TypeofDescriptor::registers() { return RegisterArray(x3); }
+
+// static
+constexpr auto CallTrampolineDescriptor::registers() {
+  // x1: target
+  // x0: number of arguments
+  return RegisterArray(x1, x0);
+}
+
+// static
+constexpr auto CallVarargsDescriptor::registers() {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x4 : arguments list length (untagged)
+  // x2 : arguments list (FixedArray)
+  return RegisterArray(x1, x0, x4, x2);
+}
+
+// static
+constexpr auto CallForwardVarargsDescriptor::registers() {
+  // x1: target
+  // x0: number of arguments
+  // x2: start index (to supported rest parameters)
+  return RegisterArray(x1, x0, x2);
+}
+
+// static
+constexpr auto CallFunctionTemplateDescriptor::registers() {
+  // x1 : function template info
+  // x2 : number of arguments (on the stack, not including receiver)
+  return RegisterArray(x1, x2);
+}
+
+// static
+constexpr auto CallWithSpreadDescriptor::registers() {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x2 : the object to spread
+  return RegisterArray(x1, x0, x2);
+}
+
+// static
+constexpr auto CallWithArrayLikeDescriptor::registers() {
+  // x1 : the target to call
+  // x2 : the arguments list
+  return RegisterArray(x1, x2);
+}
+
+// static
+constexpr auto ConstructVarargsDescriptor::registers() {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x3 : the new target
+  // x4 : arguments list length (untagged)
+  // x2 : arguments list (FixedArray)
+  return RegisterArray(x1, x3, x0, x4, x2);
+}
+
+// static
+constexpr auto ConstructForwardVarargsDescriptor::registers() {
+  // x3: new target
+  // x1: target
+  // x0: number of arguments
+  // x2: start index (to supported rest parameters)
+  return RegisterArray(x1, x3, x0, x2);
+}
+
+// static
+constexpr auto ConstructWithSpreadDescriptor::registers() {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x3 : the new target
+  // x2 : the object to spread
+  return RegisterArray(x1, x3, x0, x2);
+}
+
+// static
+constexpr auto ConstructWithArrayLikeDescriptor::registers() {
+  // x1 : the target to call
+  // x3 : the new target
+  // x2 : the arguments list
+  return RegisterArray(x1, x3, x2);
+}
+
+// static
+constexpr auto ConstructStubDescriptor::registers() {
+  // x3: new target
+  // x1: target
+  // x0: number of arguments
+  // x2: allocation site or undefined
+  return RegisterArray(x1, x3, x0, x2);
+}
+
+// static
+constexpr auto AbortDescriptor::registers() { return RegisterArray(x1); }
+
+// static
+constexpr auto CompareDescriptor::registers() {
+  // x1: left operand
+  // x0: right operand
+  return RegisterArray(x1, x0);
+}
+
+// static
+constexpr auto Compare_BaselineDescriptor::registers() {
+  // x1: left operand
+  // x0: right operand
+  // x2: feedback slot
+  return RegisterArray(x1, x0, x2);
+}
+
+// static
+constexpr auto BinaryOpDescriptor::registers() {
+  // x1: left operand
+  // x0: right operand
+  return RegisterArray(x1, x0);
+}
+
+// static
+constexpr auto BinaryOp_BaselineDescriptor::registers() {
+  // x1: left operand
+  // x0: right operand
+  // x2: feedback slot
+  return RegisterArray(x1, x0, x2);
+}
+
+// static
+constexpr auto ApiCallbackDescriptor::registers() {
+  return RegisterArray(x1,   // kApiFunctionAddress
+                       x2,   // kArgc
+                       x3,   // kCallData
+                       x0);  // kHolder
+}
+
+// static
+constexpr auto InterpreterDispatchDescriptor::registers() {
+  return RegisterArray(
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
+}
+
+// static
+constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
+  return RegisterArray(x0,   // argument count (not including receiver)
+                       x2,   // address of first argument
+                       x1);  // the target callable to be call
+}
+
+// static
+constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
+  return RegisterArray(
+      x0,   // argument count (not including receiver)
+      x4,   // address of the first argument
+      x1,   // constructor to call
+      x3,   // new target
+      x2);  // allocation site feedback if available, undefined otherwise
+}
+
+// static
+constexpr auto ResumeGeneratorDescriptor::registers() {
+  return RegisterArray(x0,   // the value to pass to the generator
+                       x1);  // the JSGeneratorObject to resume
+}
+
+// static
+constexpr auto FrameDropperTrampolineDescriptor::registers() {
+  return RegisterArray(x1);  // loaded new FP
+}
+
+// static
+constexpr auto RunMicrotasksEntryDescriptor::registers() {
+  return RegisterArray(x0, x1);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_ARM64
+
+#endif  // V8_CODEGEN_ARM64_INTERFACE_DESCRIPTORS_ARM64_INL_H_
diff --git a/src/codegen/arm64/interface-descriptors-arm64.cc b/src/codegen/arm64/interface-descriptors-arm64.cc
deleted file mode 100644
index 246d6fc9610..00000000000
--- a/src/codegen/arm64/interface-descriptors-arm64.cc
+++ /dev/null
@@ -1,310 +0,0 @@
-// Copyright 2012 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#if V8_TARGET_ARCH_ARM64
-
-#include "src/codegen/interface-descriptors.h"
-
-#include "src/execution/frames.h"
-
-namespace v8 {
-namespace internal {
-
-const Register CallInterfaceDescriptor::ContextRegister() { return cp; }
-
-void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
-    CallInterfaceDescriptorData* data, int register_parameter_count) {
-  const Register default_stub_registers[] = {x0, x1, x2, x3, x4};
-  CHECK_LE(static_cast<size_t>(register_parameter_count),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(register_parameter_count,
-                                   default_stub_registers);
-}
-
-void RecordWriteDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  const Register default_stub_registers[] = {x0, x1, x2, x3, x4};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register default_stub_registers[] = {x0, x1, x2, x3, cp};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  const Register default_stub_registers[] = {x0, x1, x2, x3, x4};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-const Register LoadDescriptor::ReceiverRegister() { return x1; }
-const Register LoadDescriptor::NameRegister() { return x2; }
-const Register LoadDescriptor::SlotRegister() { return x0; }
-
-const Register LoadWithVectorDescriptor::VectorRegister() { return x3; }
-
-const Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return x4;
-}
-
-const Register StoreDescriptor::ReceiverRegister() { return x1; }
-const Register StoreDescriptor::NameRegister() { return x2; }
-const Register StoreDescriptor::ValueRegister() { return x0; }
-const Register StoreDescriptor::SlotRegister() { return x4; }
-
-const Register StoreWithVectorDescriptor::VectorRegister() { return x3; }
-
-const Register StoreTransitionDescriptor::SlotRegister() { return x4; }
-const Register StoreTransitionDescriptor::VectorRegister() { return x3; }
-const Register StoreTransitionDescriptor::MapRegister() { return x5; }
-
-const Register ApiGetterDescriptor::HolderRegister() { return x0; }
-const Register ApiGetterDescriptor::CallbackRegister() { return x3; }
-
-const Register GrowArrayElementsDescriptor::ObjectRegister() { return x0; }
-const Register GrowArrayElementsDescriptor::KeyRegister() { return x3; }
-
-const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() { return x3; }
-const Register BaselineLeaveFrameDescriptor::WeightRegister() { return x4; }
-
-// static
-const Register TypeConversionDescriptor::ArgumentRegister() { return x0; }
-
-void TypeofDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {x3};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1: target
-  // x0: number of arguments
-  Register registers[] = {x1, x0};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x4 : arguments list length (untagged)
-  // x2 : arguments list (FixedArray)
-  Register registers[] = {x1, x0, x4, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1: target
-  // x0: number of arguments
-  // x2: start index (to supported rest parameters)
-  Register registers[] = {x1, x0, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1 : function template info
-  // x2 : number of arguments (on the stack, not including receiver)
-  Register registers[] = {x1, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x2 : the object to spread
-  Register registers[] = {x1, x0, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1 : the target to call
-  // x2 : the arguments list
-  Register registers[] = {x1, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x3 : the new target
-  // x4 : arguments list length (untagged)
-  // x2 : arguments list (FixedArray)
-  Register registers[] = {x1, x3, x0, x4, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x3: new target
-  // x1: target
-  // x0: number of arguments
-  // x2: start index (to supported rest parameters)
-  Register registers[] = {x1, x3, x0, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x3 : the new target
-  // x2 : the object to spread
-  Register registers[] = {x1, x3, x0, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1 : the target to call
-  // x3 : the new target
-  // x2 : the arguments list
-  Register registers[] = {x1, x3, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructStubDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x3: new target
-  // x1: target
-  // x0: number of arguments
-  // x2: allocation site or undefined
-  Register registers[] = {x1, x3, x0, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void AbortDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {x1};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CompareDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1: left operand
-  // x0: right operand
-  Register registers[] = {x1, x0};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void Compare_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1: left operand
-  // x0: right operand
-  // x2: feedback slot
-  Register registers[] = {x1, x0, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOpDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1: left operand
-  // x0: right operand
-  Register registers[] = {x1, x0};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // x1: left operand
-  // x0: right operand
-  // x2: feedback slot
-  Register registers[] = {x1, x0, x2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ApiCallbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      x1,  // kApiFunctionAddress
-      x2,  // kArgc
-      x3,  // kCallData
-      x0,  // kHolder
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterDispatchDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      x0,  // argument count (not including receiver)
-      x2,  // address of first argument
-      x1   // the target callable to be call
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      x0,  // argument count (not including receiver)
-      x4,  // address of the first argument
-      x1,  // constructor to call
-      x3,  // new target
-      x2,  // allocation site feedback if available, undefined otherwise
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ResumeGeneratorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      x0,  // the value to pass to the generator
-      x1   // the JSGeneratorObject to resume
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      x1,  // loaded new FP
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {x0, x1};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_ARM64
diff --git a/src/codegen/arm64/macro-assembler-arm64.cc b/src/codegen/arm64/macro-assembler-arm64.cc
index ce41f3dfadc..4d7bd7ad762 100644
--- a/src/codegen/arm64/macro-assembler-arm64.cc
+++ b/src/codegen/arm64/macro-assembler-arm64.cc
@@ -10,6 +10,7 @@
 #include "src/codegen/callable.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/external-reference-table.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
 #include "src/codegen/reloc-info.h"
diff --git a/src/codegen/ia32/interface-descriptors-ia32-inl.h b/src/codegen/ia32/interface-descriptors-ia32-inl.h
new file mode 100644
index 00000000000..3731f5ba396
--- /dev/null
+++ b/src/codegen/ia32/interface-descriptors-ia32-inl.h
@@ -0,0 +1,272 @@
+// Copyright 2021 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_IA32_INTERFACE_DESCRIPTORS_IA32_INL_H_
+#define V8_CODEGEN_IA32_INTERFACE_DESCRIPTORS_IA32_INL_H_
+
+#if V8_TARGET_ARCH_IA32
+
+#include "src/codegen/interface-descriptors.h"
+
+namespace v8 {
+namespace internal {
+
+constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
+  auto registers = RegisterArray(eax, ecx, edx, edi);
+  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
+  return registers;
+}
+
+// static
+constexpr auto RecordWriteDescriptor::registers() {
+  return RegisterArray(ecx, edx, esi, edi, kReturnRegister0);
+}
+
+// static
+constexpr auto DynamicCheckMapsDescriptor::registers() {
+  return RegisterArray(eax, ecx, edx, edi, esi);
+}
+
+// static
+constexpr auto EphemeronKeyBarrierDescriptor::registers() {
+  return RegisterArray(ecx, edx, esi, edi, kReturnRegister0);
+}
+
+// static
+constexpr Register LoadDescriptor::ReceiverRegister() { return edx; }
+// static
+constexpr Register LoadDescriptor::NameRegister() { return ecx; }
+// static
+constexpr Register LoadDescriptor::SlotRegister() { return eax; }
+
+// static
+constexpr Register LoadWithVectorDescriptor::VectorRegister() { return no_reg; }
+
+// static
+constexpr Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return edi;
+}
+
+// static
+constexpr Register StoreDescriptor::ReceiverRegister() { return edx; }
+// static
+constexpr Register StoreDescriptor::NameRegister() { return ecx; }
+// static
+constexpr Register StoreDescriptor::ValueRegister() { return no_reg; }
+// static
+constexpr Register StoreDescriptor::SlotRegister() { return no_reg; }
+
+// static
+constexpr Register StoreWithVectorDescriptor::VectorRegister() {
+  return no_reg;
+}
+
+// static
+constexpr Register StoreTransitionDescriptor::MapRegister() { return edi; }
+
+// static
+constexpr Register ApiGetterDescriptor::HolderRegister() { return ecx; }
+// static
+constexpr Register ApiGetterDescriptor::CallbackRegister() { return eax; }
+
+// static
+constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return eax; }
+// static
+constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return ecx; }
+
+// static
+constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
+  return esi;
+}
+// static
+constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() {
+  return edi;
+}
+
+// static
+constexpr Register TypeConversionDescriptor::ArgumentRegister() { return eax; }
+
+// static
+constexpr auto TypeofDescriptor::registers() { return RegisterArray(ecx); }
+
+// static
+constexpr auto CallTrampolineDescriptor::registers() {
+  // eax : number of arguments
+  // edi : the target to call
+  return RegisterArray(edi, eax);
+}
+
+// static
+constexpr auto CallVarargsDescriptor::registers() {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // ecx : arguments list length (untagged)
+  // On the stack : arguments list (FixedArray)
+  return RegisterArray(edi, eax, ecx);
+}
+
+// static
+constexpr auto CallForwardVarargsDescriptor::registers() {
+  // eax : number of arguments
+  // ecx : start index (to support rest parameters)
+  // edi : the target to call
+  return RegisterArray(edi, eax, ecx);
+}
+
+// static
+constexpr auto CallFunctionTemplateDescriptor::registers() {
+  // edx : function template info
+  // ecx : number of arguments (on the stack, not including receiver)
+  return RegisterArray(edx, ecx);
+}
+
+// static
+constexpr auto CallWithSpreadDescriptor::registers() {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // ecx : the object to spread
+  return RegisterArray(edi, eax, ecx);
+}
+
+// static
+constexpr auto CallWithArrayLikeDescriptor::registers() {
+  // edi : the target to call
+  // edx : the arguments list
+  return RegisterArray(edi, edx);
+}
+
+// static
+constexpr auto ConstructVarargsDescriptor::registers() {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // edx : the new target
+  // ecx : arguments list length (untagged)
+  // On the stack : arguments list (FixedArray)
+  return RegisterArray(edi, edx, eax, ecx);
+}
+
+// static
+constexpr auto ConstructForwardVarargsDescriptor::registers() {
+  // eax : number of arguments
+  // edx : the new target
+  // ecx : start index (to support rest parameters)
+  // edi : the target to call
+  return RegisterArray(edi, edx, eax, ecx);
+}
+
+// static
+constexpr auto ConstructWithSpreadDescriptor::registers() {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // edx : the new target
+  // ecx : the object to spread
+  return RegisterArray(edi, edx, eax, ecx);
+}
+
+// static
+constexpr auto ConstructWithArrayLikeDescriptor::registers() {
+  // edi : the target to call
+  // edx : the new target
+  // ecx : the arguments list
+  return RegisterArray(edi, edx, ecx);
+}
+
+// static
+constexpr auto ConstructStubDescriptor::registers() {
+  // eax : number of arguments
+  // edx : the new target
+  // edi : the target to call
+  // ecx : allocation site or undefined
+  // TODO(jgruber): Remove the unused allocation site parameter.
+  return RegisterArray(edi, edx, eax, ecx);
+}
+
+// static
+constexpr auto AbortDescriptor::registers() { return RegisterArray(edx); }
+
+// static
+constexpr auto CompareDescriptor::registers() {
+  return RegisterArray(edx, eax);
+}
+
+// static
+constexpr auto Compare_BaselineDescriptor::registers() {
+  return RegisterArray(edx, eax, ecx);
+}
+
+// static
+constexpr auto BinaryOpDescriptor::registers() {
+  return RegisterArray(edx, eax);
+}
+
+// static
+constexpr auto BinaryOp_BaselineDescriptor::registers() {
+  return RegisterArray(edx, eax, ecx);
+}
+
+// static
+constexpr auto ApiCallbackDescriptor::registers() {
+  return RegisterArray(edx,   // kApiFunctionAddress
+                       ecx,   // kArgc
+                       eax,   // kCallData
+                       edi);  // kHolder
+}
+
+// static
+constexpr auto InterpreterDispatchDescriptor::registers() {
+  return RegisterArray(
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
+}
+
+// static
+constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
+  return RegisterArray(eax,   // argument count (not including receiver)
+                       ecx,   // address of first argument
+                       edi);  // the target callable to be call
+}
+
+// static
+constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
+  return RegisterArray(eax,   // argument count (not including receiver)
+                       ecx);  // address of first argument
+}
+
+// static
+constexpr auto ResumeGeneratorDescriptor::registers() {
+  return RegisterArray(eax,   // the value to pass to the generator
+                       edx);  // the JSGeneratorObject to resume
+}
+
+// static
+constexpr auto FrameDropperTrampolineDescriptor::registers() {
+  return RegisterArray(eax);  // loaded new FP
+}
+
+// static
+constexpr auto RunMicrotasksEntryDescriptor::registers() {
+  return RegisterArray();
+}
+
+// static
+constexpr auto WasmFloat32ToNumberDescriptor::registers() {
+  // Work around using eax, whose register code is 0, and leads to the FP
+  // parameter being passed via xmm0, which is not allocatable on ia32.
+  return RegisterArray(ecx);
+}
+
+// static
+constexpr auto WasmFloat64ToNumberDescriptor::registers() {
+  // Work around using eax, whose register code is 0, and leads to the FP
+  // parameter being passed via xmm0, which is not allocatable on ia32.
+  return RegisterArray(ecx);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_IA32
+
+#endif  // V8_CODEGEN_IA32_INTERFACE_DESCRIPTORS_IA32_INL_H_
diff --git a/src/codegen/ia32/interface-descriptors-ia32.cc b/src/codegen/ia32/interface-descriptors-ia32.cc
deleted file mode 100644
index fd76e01590b..00000000000
--- a/src/codegen/ia32/interface-descriptors-ia32.cc
+++ /dev/null
@@ -1,318 +0,0 @@
-// Copyright 2012 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#if V8_TARGET_ARCH_IA32
-
-#include "src/codegen/interface-descriptors.h"
-
-#include "src/execution/frames.h"
-
-namespace v8 {
-namespace internal {
-
-const Register CallInterfaceDescriptor::ContextRegister() { return esi; }
-
-void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
-    CallInterfaceDescriptorData* data, int register_parameter_count) {
-  constexpr Register default_stub_registers[] = {eax, ecx, edx, edi};
-  STATIC_ASSERT(arraysize(default_stub_registers) == kMaxBuiltinRegisterParams);
-  CHECK_LE(static_cast<size_t>(register_parameter_count),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(register_parameter_count,
-                                   default_stub_registers);
-}
-
-void RecordWriteDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  static const Register default_stub_registers[] = {ecx, edx, esi, edi,
-                                                    kReturnRegister0};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register default_stub_registers[] = {eax, ecx, edx, edi, esi};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  static const Register default_stub_registers[] = {ecx, edx, esi, edi,
-                                                    kReturnRegister0};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-const Register LoadDescriptor::ReceiverRegister() { return edx; }
-const Register LoadDescriptor::NameRegister() { return ecx; }
-const Register LoadDescriptor::SlotRegister() { return eax; }
-
-const Register LoadWithVectorDescriptor::VectorRegister() { return no_reg; }
-
-const Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return edi;
-}
-
-const Register StoreDescriptor::ReceiverRegister() { return edx; }
-const Register StoreDescriptor::NameRegister() { return ecx; }
-const Register StoreDescriptor::ValueRegister() { return no_reg; }
-const Register StoreDescriptor::SlotRegister() { return no_reg; }
-
-const Register StoreWithVectorDescriptor::VectorRegister() { return no_reg; }
-
-const Register StoreTransitionDescriptor::SlotRegister() { return no_reg; }
-const Register StoreTransitionDescriptor::VectorRegister() { return no_reg; }
-const Register StoreTransitionDescriptor::MapRegister() { return edi; }
-
-const Register ApiGetterDescriptor::HolderRegister() { return ecx; }
-const Register ApiGetterDescriptor::CallbackRegister() { return eax; }
-
-const Register GrowArrayElementsDescriptor::ObjectRegister() { return eax; }
-const Register GrowArrayElementsDescriptor::KeyRegister() { return ecx; }
-
-const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
-  return esi;
-}
-const Register BaselineLeaveFrameDescriptor::WeightRegister() { return edi; }
-
-// static
-const Register TypeConversionDescriptor::ArgumentRegister() { return eax; }
-
-void TypeofDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments
-  // edi : the target to call
-  Register registers[] = {edi, eax};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // ecx : arguments list length (untagged)
-  // On the stack : arguments list (FixedArray)
-  Register registers[] = {edi, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments
-  // ecx : start index (to support rest parameters)
-  // edi : the target to call
-  Register registers[] = {edi, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // edx : function template info
-  // ecx : number of arguments (on the stack, not including receiver)
-  Register registers[] = {edx, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // ecx : the object to spread
-  Register registers[] = {edi, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // edi : the target to call
-  // edx : the arguments list
-  Register registers[] = {edi, edx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // edx : the new target
-  // ecx : arguments list length (untagged)
-  // On the stack : arguments list (FixedArray)
-  Register registers[] = {edi, edx, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments
-  // edx : the new target
-  // ecx : start index (to support rest parameters)
-  // edi : the target to call
-  Register registers[] = {edi, edx, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // edx : the new target
-  // ecx : the object to spread
-  Register registers[] = {edi, edx, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // edi : the target to call
-  // edx : the new target
-  // ecx : the arguments list
-  Register registers[] = {edi, edx, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructStubDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // eax : number of arguments
-  // edx : the new target
-  // edi : the target to call
-  // ecx : allocation site or undefined
-  // TODO(jgruber): Remove the unused allocation site parameter.
-  Register registers[] = {edi, edx, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void AbortDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {edx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CompareDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {edx, eax};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void Compare_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {edx, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOpDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {edx, eax};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {edx, eax, ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ApiCallbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      edx,  // kApiFunctionAddress
-      ecx,  // kArgc
-      eax,  // kCallData
-      edi,  // kHolder
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterDispatchDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      eax,  // argument count (not including receiver)
-      ecx,  // address of first argument
-      edi   // the target callable to be call
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      eax,  // argument count (not including receiver)
-      ecx,  // address of first argument
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ResumeGeneratorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      eax,  // the value to pass to the generator
-      edx   // the JSGeneratorObject to resume
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      eax,  // loaded new FP
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  data->InitializePlatformSpecific(0, nullptr);
-}
-
-void WasmFloat32ToNumberDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  Register registers[] = {ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void WasmFloat64ToNumberDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  Register registers[] = {ecx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_IA32
diff --git a/src/codegen/ia32/macro-assembler-ia32.cc b/src/codegen/ia32/macro-assembler-ia32.cc
index ff856dc8fc3..0863b9e828f 100644
--- a/src/codegen/ia32/macro-assembler-ia32.cc
+++ b/src/codegen/ia32/macro-assembler-ia32.cc
@@ -19,7 +19,7 @@
 #include "src/codegen/external-reference.h"
 #include "src/codegen/ia32/assembler-ia32.h"
 #include "src/codegen/ia32/register-ia32.h"
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/label.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/register.h"
diff --git a/src/codegen/interface-descriptors-inl.h b/src/codegen/interface-descriptors-inl.h
new file mode 100644
index 00000000000..d352626f528
--- /dev/null
+++ b/src/codegen/interface-descriptors-inl.h
@@ -0,0 +1,471 @@
+// Copyright 2021 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_INTERFACE_DESCRIPTORS_INL_H_
+#define V8_CODEGEN_INTERFACE_DESCRIPTORS_INL_H_
+
+#include <utility>
+
+#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/register-arch.h"
+
+#if V8_TARGET_ARCH_X64
+#include "src/codegen/x64/interface-descriptors-x64-inl.h"
+#elif V8_TARGET_ARCH_ARM64
+#include "src/codegen/arm64/interface-descriptors-arm64-inl.h"
+#elif V8_TARGET_ARCH_IA32
+#include "src/codegen/ia32/interface-descriptors-ia32-inl.h"
+#elif V8_TARGET_ARCH_ARM
+#include "src/codegen/arm/interface-descriptors-arm-inl.h"
+#else
+#error Unsupported target architecture.
+#endif
+
+namespace v8 {
+namespace internal {
+
+// static
+constexpr std::array<Register, kJSBuiltinRegisterParams>
+CallInterfaceDescriptor::DefaultJSRegisterArray() {
+  return RegisterArray(
+      kJavaScriptCallTargetRegister, kJavaScriptCallNewTargetRegister,
+      kJavaScriptCallArgCountRegister, kJavaScriptCallExtraArg1Register);
+}
+
+// static
+template <typename DerivedDescriptor>
+constexpr auto StaticCallInterfaceDescriptor<DerivedDescriptor>::registers() {
+  return CallInterfaceDescriptor::DefaultRegisterArray();
+}
+
+// static
+template <typename DerivedDescriptor>
+constexpr auto StaticJSCallInterfaceDescriptor<DerivedDescriptor>::registers() {
+  return CallInterfaceDescriptor::DefaultJSRegisterArray();
+}
+
+template <typename DerivedDescriptor>
+void StaticCallInterfaceDescriptor<DerivedDescriptor>::Initialize(
+    CallInterfaceDescriptorData* data) {
+  // Static local copy of the Registers array, for platform-specific
+  // initialization
+  static auto registers = DerivedDescriptor::registers();
+
+  // The passed pointer should be a modifiable pointer to our own data.
+  DCHECK_EQ(data, this->data());
+  DCHECK(!data->IsInitialized());
+
+  if (DerivedDescriptor::kRestrictAllocatableRegisters) {
+    data->RestrictAllocatableRegisters(registers.data(), registers.size());
+  }
+
+  data->InitializeRegisters(
+      DerivedDescriptor::flags(), DerivedDescriptor::kReturnCount,
+      DerivedDescriptor::GetParameterCount(),
+      DerivedDescriptor::kStackArgumentOrder,
+      DerivedDescriptor::GetRegisterParameterCount(), registers.data());
+
+  // InitializeTypes is customizable by the DerivedDescriptor subclass.
+  DerivedDescriptor::InitializeTypes(data);
+
+  DCHECK(data->IsInitialized());
+  DCHECK(this->CheckFloatingPointParameters(data));
+}
+
+// static
+template <typename DerivedDescriptor>
+constexpr int
+StaticCallInterfaceDescriptor<DerivedDescriptor>::GetReturnCount() {
+  static_assert(
+      DerivedDescriptor::kReturnCount >= 0,
+      "DerivedDescriptor subclass should override return count with a value "
+      "that is greater than 0");
+
+  return DerivedDescriptor::kReturnCount;
+}
+
+// static
+template <typename DerivedDescriptor>
+constexpr int
+StaticCallInterfaceDescriptor<DerivedDescriptor>::GetParameterCount() {
+  static_assert(
+      DerivedDescriptor::kParameterCount >= 0,
+      "DerivedDescriptor subclass should override parameter count with a "
+      "value that is greater than 0");
+
+  return DerivedDescriptor::kParameterCount;
+}
+
+namespace detail {
+
+// Helper trait for statically checking if a type is a std::array<Register,N>.
+template <typename T>
+struct IsRegisterArray : std::false_type {};
+template <int i>
+struct IsRegisterArray<std::array<Register, i>> : std::true_type {};
+template <>
+struct IsRegisterArray<EmptyRegisterArray> : std::true_type {};
+
+// Helper for finding the index of the first invalid register in a register
+// array.
+template <size_t N, size_t Index>
+struct FirstInvalidRegisterHelper {
+  static constexpr int Call(std::array<Register, N> regs) {
+    if (!std::get<Index>(regs).is_valid()) {
+      // All registers after the first invalid one have to also be invalid (this
+      // DCHECK will be checked recursively).
+      CONSTEXPR_DCHECK((FirstInvalidRegisterHelper<N, Index + 1>::Call(regs)) ==
+                       Index + 1);
+      return Index;
+    }
+    return FirstInvalidRegisterHelper<N, Index + 1>::Call(regs);
+  }
+};
+template <size_t N>
+struct FirstInvalidRegisterHelper<N, N> {
+  static constexpr int Call(std::array<Register, N> regs) { return N; }
+};
+template <size_t N, size_t Index = 0>
+constexpr size_t FirstInvalidRegister(std::array<Register, N> regs) {
+  return FirstInvalidRegisterHelper<N, 0>::Call(regs);
+}
+constexpr size_t FirstInvalidRegister(EmptyRegisterArray regs) { return 0; }
+
+}  // namespace detail
+
+// static
+template <typename DerivedDescriptor>
+constexpr int
+StaticCallInterfaceDescriptor<DerivedDescriptor>::GetRegisterParameterCount() {
+  static_assert(
+      detail::IsRegisterArray<decltype(DerivedDescriptor::registers())>::value,
+      "DerivedDescriptor subclass should define a registers() function "
+      "returning a std::array<Register>");
+
+  // The register parameter count is the minimum of:
+  //   1. The number of named parameters in the descriptor, and
+  //   2. The number of valid registers the descriptor provides with its
+  //      registers() function, e.g. for {rax, rbx, no_reg} this number is 2.
+  //   3. The maximum number of register parameters allowed (
+  //      kMaxBuiltinRegisterParams for most builtins,
+  //      kMaxTFSBuiltinRegisterParams for TFS builtins, customizable by the
+  //      subclass otherwise).
+  return std::min<int>({DerivedDescriptor::GetParameterCount(),
+                        static_cast<int>(detail::FirstInvalidRegister(
+                            DerivedDescriptor::registers())),
+                        DerivedDescriptor::kMaxRegisterParams});
+}
+
+// static
+template <typename DerivedDescriptor>
+constexpr int
+StaticCallInterfaceDescriptor<DerivedDescriptor>::GetStackParameterCount() {
+  return DerivedDescriptor::GetParameterCount() -
+         DerivedDescriptor::GetRegisterParameterCount();
+}
+
+// static
+constexpr Register FastNewObjectDescriptor::TargetRegister() {
+  return kJSFunctionRegister;
+}
+
+// static
+constexpr Register FastNewObjectDescriptor::NewTargetRegister() {
+  return kJavaScriptCallNewTargetRegister;
+}
+
+// static
+constexpr Register ApiGetterDescriptor::ReceiverRegister() {
+  return LoadDescriptor::ReceiverRegister();
+}
+
+// static
+constexpr Register LoadGlobalNoFeedbackDescriptor::ICKindRegister() {
+  return LoadDescriptor::SlotRegister();
+}
+
+// static
+constexpr Register LoadNoFeedbackDescriptor::ICKindRegister() {
+  return LoadGlobalNoFeedbackDescriptor::ICKindRegister();
+}
+
+#if V8_TARGET_ARCH_IA32
+// On ia32, LoadWithVectorDescriptor passes vector on the stack and thus we
+// need to choose a new register here.
+// static
+constexpr Register LoadGlobalWithVectorDescriptor::VectorRegister() {
+  STATIC_ASSERT(!LoadWithVectorDescriptor::VectorRegister().is_valid());
+  return LoadDescriptor::ReceiverRegister();
+}
+#else
+// static
+constexpr Register LoadGlobalWithVectorDescriptor::VectorRegister() {
+  return LoadWithVectorDescriptor::VectorRegister();
+}
+#endif
+
+// static
+constexpr auto LoadDescriptor::registers() {
+  return RegisterArray(ReceiverRegister(), NameRegister(), SlotRegister());
+}
+
+// static
+constexpr auto LoadBaselineDescriptor::registers() {
+  return LoadDescriptor::registers();
+}
+
+// static
+constexpr auto LoadGlobalDescriptor::registers() {
+  return RegisterArray(LoadDescriptor::NameRegister(),
+                       LoadDescriptor::SlotRegister());
+}
+
+// static
+constexpr auto LoadGlobalBaselineDescriptor::registers() {
+  return LoadGlobalDescriptor::registers();
+}
+
+// static
+constexpr auto StoreDescriptor::registers() {
+  return RegisterArray(ReceiverRegister(), NameRegister(), ValueRegister(),
+                       SlotRegister());
+}
+
+// static
+constexpr auto StoreBaselineDescriptor::registers() {
+  return StoreDescriptor::registers();
+}
+
+// static
+constexpr auto StoreGlobalDescriptor::registers() {
+  return RegisterArray(StoreDescriptor::NameRegister(),
+                       StoreDescriptor::ValueRegister(),
+                       StoreDescriptor::SlotRegister());
+}
+
+// static
+constexpr auto StoreGlobalBaselineDescriptor::registers() {
+  return StoreGlobalDescriptor::registers();
+}
+
+// static
+constexpr auto LoadWithReceiverBaselineDescriptor::registers() {
+  return RegisterArray(
+      LoadDescriptor::ReceiverRegister(),
+      LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister(),
+      LoadDescriptor::NameRegister(), LoadDescriptor::SlotRegister());
+}
+
+// static
+constexpr auto BaselineOutOfLinePrologueDescriptor::registers() {
+  // TODO(v8:11421): Implement on other platforms.
+#if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_IA32 || \
+    V8_TARGET_ARCH_ARM
+  return RegisterArray(
+      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+      kJavaScriptCallExtraArg1Register, kJavaScriptCallNewTargetRegister,
+      kInterpreterBytecodeArrayRegister);
+#else
+  return DefaultRegisterArray();
+#endif
+}
+
+// static
+constexpr auto BaselineLeaveFrameDescriptor::registers() {
+  // TODO(v8:11421): Implement on other platforms.
+#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || \
+    V8_TARGET_ARCH_ARM
+  return RegisterArray(ParamsSizeRegister(), WeightRegister());
+#else
+  return DefaultRegisterArray();
+#endif
+}
+
+// static
+constexpr auto VoidDescriptor::registers() { return RegisterArray(); }
+
+// static
+constexpr auto AllocateDescriptor::registers() {
+  return RegisterArray(kAllocateSizeRegister);
+}
+
+// static
+constexpr auto CEntry1ArgvOnStackDescriptor::registers() {
+  return RegisterArray(kRuntimeCallArgCountRegister,
+                       kRuntimeCallFunctionRegister);
+}
+
+// static
+constexpr auto InterpreterCEntry1Descriptor::registers() {
+  return RegisterArray(kRuntimeCallArgCountRegister, kRuntimeCallArgvRegister,
+                       kRuntimeCallFunctionRegister);
+}
+
+// static
+constexpr auto InterpreterCEntry2Descriptor::registers() {
+  return RegisterArray(kRuntimeCallArgCountRegister, kRuntimeCallArgvRegister,
+                       kRuntimeCallFunctionRegister);
+}
+
+// static
+constexpr auto FastNewObjectDescriptor::registers() {
+  return RegisterArray(TargetRegister(), NewTargetRegister());
+}
+
+// static
+constexpr auto TailCallOptimizedCodeSlotDescriptor::registers() {
+  return RegisterArray(kJavaScriptCallCodeStartRegister);
+}
+
+// static
+constexpr auto LoadNoFeedbackDescriptor::registers() {
+  return RegisterArray(LoadDescriptor::ReceiverRegister(),
+                       LoadDescriptor::NameRegister(), ICKindRegister());
+}
+
+// static
+constexpr auto LoadGlobalNoFeedbackDescriptor::registers() {
+  return RegisterArray(LoadDescriptor::NameRegister(), ICKindRegister());
+}
+
+// static
+constexpr auto LoadGlobalWithVectorDescriptor::registers() {
+  return RegisterArray(LoadDescriptor::NameRegister(),
+                       LoadDescriptor::SlotRegister(), VectorRegister());
+}
+
+// static
+constexpr auto LoadWithReceiverAndVectorDescriptor::registers() {
+  return RegisterArray(
+      LoadDescriptor::ReceiverRegister(), LookupStartObjectRegister(),
+      LoadDescriptor::NameRegister(), LoadDescriptor::SlotRegister(),
+      LoadWithVectorDescriptor::VectorRegister());
+}
+
+// static
+constexpr auto StoreGlobalWithVectorDescriptor::registers() {
+  return RegisterArray(StoreDescriptor::NameRegister(),
+                       StoreDescriptor::ValueRegister(),
+                       StoreDescriptor::SlotRegister(),
+                       StoreWithVectorDescriptor::VectorRegister());
+}
+
+// static
+constexpr auto StoreTransitionDescriptor::registers() {
+  return RegisterArray(StoreDescriptor::ReceiverRegister(),
+                       StoreDescriptor::NameRegister(), MapRegister(),
+                       StoreDescriptor::ValueRegister(),
+                       StoreDescriptor::SlotRegister(),
+                       StoreWithVectorDescriptor::VectorRegister());
+}
+
+// static
+constexpr auto TypeConversionDescriptor::registers() {
+  return RegisterArray(ArgumentRegister());
+}
+
+// static
+constexpr auto TypeConversionNoContextDescriptor::registers() {
+  return RegisterArray(TypeConversionDescriptor::ArgumentRegister());
+}
+
+// static
+constexpr auto SingleParameterOnStackDescriptor::registers() {
+  return RegisterArray();
+}
+
+// static
+constexpr auto AsyncFunctionStackParameterDescriptor::registers() {
+  return RegisterArray();
+}
+
+// static
+constexpr auto GetIteratorStackParameterDescriptor::registers() {
+  return RegisterArray();
+}
+
+// static
+constexpr auto LoadWithVectorDescriptor::registers() {
+  return RegisterArray(LoadDescriptor::ReceiverRegister(),
+                       LoadDescriptor::NameRegister(),
+                       LoadDescriptor::SlotRegister(), VectorRegister());
+}
+
+// static
+constexpr auto StoreWithVectorDescriptor::registers() {
+  return RegisterArray(StoreDescriptor::ReceiverRegister(),
+                       StoreDescriptor::NameRegister(),
+                       StoreDescriptor::ValueRegister(),
+                       StoreDescriptor::SlotRegister(), VectorRegister());
+}
+
+// static
+constexpr auto ApiGetterDescriptor::registers() {
+  return RegisterArray(ReceiverRegister(), HolderRegister(),
+                       CallbackRegister());
+}
+
+// static
+constexpr auto ContextOnlyDescriptor::registers() { return RegisterArray(); }
+
+// static
+constexpr auto NoContextDescriptor::registers() { return RegisterArray(); }
+
+// static
+constexpr auto GrowArrayElementsDescriptor::registers() {
+  return RegisterArray(ObjectRegister(), KeyRegister());
+}
+
+// static
+constexpr auto ArrayNArgumentsConstructorDescriptor::registers() {
+  // Keep the arguments on the same registers as they were in
+  // ArrayConstructorDescriptor to avoid unnecessary register moves.
+  // kFunction, kAllocationSite, kActualArgumentsCount
+  return RegisterArray(kJavaScriptCallTargetRegister,
+                       kJavaScriptCallExtraArg1Register,
+                       kJavaScriptCallArgCountRegister);
+}
+
+// static
+constexpr auto ArrayNoArgumentConstructorDescriptor::registers() {
+  // This descriptor must use the same set of registers as the
+  // ArrayNArgumentsConstructorDescriptor.
+  return ArrayNArgumentsConstructorDescriptor::registers();
+}
+
+// static
+constexpr auto ArraySingleArgumentConstructorDescriptor::registers() {
+  // This descriptor must use the same set of registers as the
+  // ArrayNArgumentsConstructorDescriptor.
+  return ArrayNArgumentsConstructorDescriptor::registers();
+}
+
+// static
+// static
+constexpr Register RunMicrotasksDescriptor::MicrotaskQueueRegister() {
+  return GetRegisterParameter(0);
+}
+
+#define DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER(Name, DescriptorName) \
+  template <>                                                         \
+  struct CallInterfaceDescriptorFor<Builtins::k##Name> {              \
+    using type = DescriptorName##Descriptor;                          \
+  };
+BUILTIN_LIST(IGNORE_BUILTIN, IGNORE_BUILTIN,
+             /*TFC*/ DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER, IGNORE_BUILTIN,
+             /*TFH*/ DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER, IGNORE_BUILTIN,
+             /*ASM*/ DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER)
+#undef DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER
+#define DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER(Name, ...) \
+  template <>                                              \
+  struct CallInterfaceDescriptorFor<Builtins::k##Name> {   \
+    using type = Name##Descriptor;                         \
+  };
+BUILTIN_LIST_TFS(DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER)
+#undef DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_CODEGEN_INTERFACE_DESCRIPTORS_INL_H_
diff --git a/src/codegen/interface-descriptors.cc b/src/codegen/interface-descriptors.cc
index 920aea63d74..d6d7b0dd0a9 100644
--- a/src/codegen/interface-descriptors.cc
+++ b/src/codegen/interface-descriptors.cc
@@ -4,49 +4,48 @@
 
 #include "src/codegen/interface-descriptors.h"
 
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 
 namespace v8 {
 namespace internal {
 
-void CallInterfaceDescriptorData::InitializePlatformSpecific(
-    int register_parameter_count, const Register* registers) {
-  DCHECK(!IsInitializedPlatformIndependent());
-
-  register_param_count_ = register_parameter_count;
-
-  // UBSan doesn't like creating zero-length arrays.
-  if (register_parameter_count == 0) return;
+void CallInterfaceDescriptorData::InitializeRegisters(
+    Flags flags, int return_count, int parameter_count,
+    StackArgumentOrder stack_order, int register_parameter_count,
+    const Register* registers) {
+  DCHECK(!IsInitializedTypes());
 
-  // InterfaceDescriptor owns a copy of the registers array.
-  register_params_ = NewArray<Register>(register_parameter_count, no_reg);
-  for (int i = 0; i < register_parameter_count; i++) {
-    // The value of the root register must be reserved, thus any uses
-    // within the calling convention are disallowed.
 #ifdef DEBUG
-    CHECK_NE(registers[i], kRootRegister);
+  {
+    // Make sure that the registers are all valid, and don't alias each other.
+    RegList reglist = 0;
+    for (int i = 0; i < register_parameter_count; ++i) {
+      Register reg = registers[i];
+      DCHECK(reg.is_valid());
+      DCHECK_EQ(reglist & reg.bit(), 0);
+      DCHECK_NE(reg, kRootRegister);
 #ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE
-    CHECK_NE(registers[i], kPtrComprCageBaseRegister);
+      DCHECK_NE(reg, kPtrComprCageBaseRegister);
 #endif
-    // Check for duplicated registers.
-    for (int j = i + 1; j < register_parameter_count; j++) {
-      CHECK_NE(registers[i], registers[j]);
+      reglist = CombineRegLists(reglist, reg.bit());
     }
-#endif
-    register_params_[i] = registers[i];
   }
-}
-
-void CallInterfaceDescriptorData::InitializePlatformIndependent(
-    Flags flags, int return_count, int parameter_count,
-    const MachineType* machine_types, int machine_types_length,
-    StackArgumentOrder stack_order) {
-  DCHECK(IsInitializedPlatformSpecific());
+#endif
 
   flags_ = flags;
   stack_order_ = stack_order;
   return_count_ = return_count;
   param_count_ = parameter_count;
+  register_param_count_ = register_parameter_count;
+
+  // The caller owns the the registers array, so we just set the pointer.
+  register_params_ = registers;
+}
+
+void CallInterfaceDescriptorData::InitializeTypes(
+    const MachineType* machine_types, int machine_types_length) {
+  DCHECK(IsInitializedRegisters());
   const int types_length = return_count_ + param_count_;
 
   // Machine types are either fully initialized or null.
@@ -77,7 +76,6 @@ bool CallInterfaceDescriptorData::AllStackParametersAreTagged() const {
 void CallInterfaceDescriptorData::Reset() {
   delete[] machine_types_;
   machine_types_ = nullptr;
-  delete[] register_params_;
   register_params_ = nullptr;
 }
 
@@ -105,27 +103,6 @@ void CallDescriptors::TearDown() {
   }
 }
 
-void CallInterfaceDescriptor::JSDefaultInitializePlatformSpecific(
-    CallInterfaceDescriptorData* data, int non_js_register_parameter_count) {
-  DCHECK_LE(static_cast<unsigned>(non_js_register_parameter_count), 1);
-
-  // 3 is for kTarget, kNewTarget and kActualArgumentsCount
-  int register_parameter_count = 3 + non_js_register_parameter_count;
-
-  DCHECK(!AreAliased(
-      kJavaScriptCallTargetRegister, kJavaScriptCallNewTargetRegister,
-      kJavaScriptCallArgCountRegister, kJavaScriptCallExtraArg1Register));
-
-  const Register default_js_stub_registers[] = {
-      kJavaScriptCallTargetRegister, kJavaScriptCallNewTargetRegister,
-      kJavaScriptCallArgCountRegister, kJavaScriptCallExtraArg1Register};
-
-  CHECK_LE(static_cast<size_t>(register_parameter_count),
-           arraysize(default_js_stub_registers));
-  data->InitializePlatformSpecific(register_parameter_count,
-                                   default_js_stub_registers);
-}
-
 const char* CallInterfaceDescriptor::DebugName() const {
   CallDescriptors::Key key = CallDescriptors::GetKey(data_);
   switch (key) {
@@ -146,487 +123,5 @@ bool CallInterfaceDescriptor::IsValidFloatParameterRegister(Register reg) {
 }
 #endif
 
-void VoidDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  data->InitializePlatformSpecific(0, nullptr);
-}
-
-void AllocateDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {kAllocateSizeRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CEntry1ArgvOnStackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {kRuntimeCallArgCountRegister,
-                          kRuntimeCallFunctionRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-namespace {
-
-void InterpreterCEntryDescriptor_InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {kRuntimeCallArgCountRegister,
-                          kRuntimeCallArgvRegister,
-                          kRuntimeCallFunctionRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-}  // namespace
-
-void InterpreterCEntry1Descriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);
-}
-
-void InterpreterCEntry2Descriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);
-}
-
-void FastNewObjectDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {TargetRegister(), NewTargetRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-const Register FastNewObjectDescriptor::TargetRegister() {
-  return kJSFunctionRegister;
-}
-
-const Register FastNewObjectDescriptor::NewTargetRegister() {
-  return kJavaScriptCallNewTargetRegister;
-}
-
-void TailCallOptimizedCodeSlotDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {kJavaScriptCallCodeStartRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LoadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ReceiverRegister(), NameRegister(), SlotRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LoadBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {LoadDescriptor::ReceiverRegister(),
-                          LoadDescriptor::NameRegister(),
-                          LoadDescriptor::SlotRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LoadNoFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ReceiverRegister(), NameRegister(), ICKindRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LoadGlobalDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {NameRegister(), SlotRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LoadGlobalBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {LoadGlobalDescriptor::NameRegister(),
-                          LoadGlobalDescriptor::SlotRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LookupBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void LoadGlobalNoFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {NameRegister(), ICKindRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LoadGlobalWithVectorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {NameRegister(), SlotRegister(), VectorRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void LoadWithReceiverAndVectorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DCHECK(!AreAliased(ReceiverRegister(), LookupStartObjectRegister(),
-                     NameRegister(), SlotRegister(), VectorRegister()));
-  Register registers[] = {ReceiverRegister(), LookupStartObjectRegister(),
-                          NameRegister(), SlotRegister(), VectorRegister()};
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void LoadWithReceiverBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      LoadWithReceiverAndVectorDescriptor::ReceiverRegister(),
-      LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister(),
-      LoadWithReceiverAndVectorDescriptor::NameRegister(),
-      LoadWithReceiverAndVectorDescriptor::SlotRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void StoreGlobalDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {NameRegister(), ValueRegister(), SlotRegister()};
-
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void StoreGlobalBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {StoreGlobalDescriptor::NameRegister(),
-                          StoreGlobalDescriptor::ValueRegister(),
-                          StoreGlobalDescriptor::SlotRegister()};
-
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void StoreGlobalWithVectorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {NameRegister(), ValueRegister(), SlotRegister(),
-                          VectorRegister()};
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void StoreDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ReceiverRegister(), NameRegister(), ValueRegister(),
-                          SlotRegister()};
-
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void StoreBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      StoreDescriptor::ReceiverRegister(), StoreDescriptor::NameRegister(),
-      StoreDescriptor::ValueRegister(), StoreDescriptor::SlotRegister()};
-
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void StoreTransitionDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      ReceiverRegister(), NameRegister(), MapRegister(),
-      ValueRegister(),    SlotRegister(), VectorRegister(),
-  };
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void BaselineOutOfLinePrologueDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // TODO(v8:11421): Implement on other platforms.
-#if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_IA32 || \
-    V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_RISCV64
-  Register registers[] = {kContextRegister,
-                          kJSFunctionRegister,
-                          kJavaScriptCallArgCountRegister,
-                          kJavaScriptCallExtraArg1Register,
-                          kJavaScriptCallNewTargetRegister,
-                          kInterpreterBytecodeArrayRegister};
-  data->InitializePlatformSpecific(kParameterCount - kStackArgumentsCount,
-                                   registers);
-#else
-  InitializePlatformUnimplemented(data, kParameterCount);
-#endif
-}
-
-void BaselineLeaveFrameDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // TODO(v8:11421): Implement on other platforms.
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || \
-    V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_RISCV64
-  Register registers[] = {ParamsSizeRegister(), WeightRegister()};
-  data->InitializePlatformSpecific(kParameterCount, registers);
-#else
-  InitializePlatformUnimplemented(data, kParameterCount);
-#endif
-}
-
-void StringAtDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void StringAtAsStringDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void StringSubstringDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void TypeConversionDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ArgumentRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void TypeConversionNoContextDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {TypeConversionDescriptor::ArgumentRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void TypeConversion_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void SingleParameterOnStackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  data->InitializePlatformSpecific(0, nullptr);
-}
-
-void AsyncFunctionStackParameterDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  data->InitializePlatformSpecific(0, nullptr);
-}
-
-void GetIteratorStackParameterDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  data->InitializePlatformSpecific(0, nullptr);
-}
-
-void LoadWithVectorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ReceiverRegister(), NameRegister(), SlotRegister(),
-                          VectorRegister()};
-  // TODO(jgruber): This DCHECK could be enabled if RegisterBase::ListOf were
-  // to allow no_reg entries.
-  // DCHECK(!AreAliased(ReceiverRegister(), NameRegister(), SlotRegister(),
-  //                    VectorRegister(), kRootRegister));
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-void StoreWithVectorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ReceiverRegister(), NameRegister(), ValueRegister(),
-                          SlotRegister(), VectorRegister()};
-  // TODO(jgruber): This DCHECK could be enabled if RegisterBase::ListOf were
-  // to allow no_reg entries.
-  // DCHECK(!AreAliased(ReceiverRegister(), NameRegister(), kRootRegister));
-  int len = arraysize(registers) - kStackArgumentsCount;
-  data->InitializePlatformSpecific(len, registers);
-}
-
-const Register ApiGetterDescriptor::ReceiverRegister() {
-  return LoadDescriptor::ReceiverRegister();
-}
-
-void ApiGetterDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ReceiverRegister(), HolderRegister(),
-                          CallbackRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ContextOnlyDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  data->InitializePlatformSpecific(0, nullptr);
-}
-
-void NoContextDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  data->InitializePlatformSpecific(0, nullptr);
-}
-
-void GrowArrayElementsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {ObjectRegister(), KeyRegister()};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ArrayNoArgumentConstructorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // This descriptor must use the same set of registers as the
-  // ArrayNArgumentsConstructorDescriptor.
-  ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(data);
-}
-
-void ArraySingleArgumentConstructorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // This descriptor must use the same set of registers as the
-  // ArrayNArgumentsConstructorDescriptor.
-  ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(data);
-}
-
-void ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // Keep the arguments on the same registers as they were in
-  // ArrayConstructorDescriptor to avoid unnecessary register moves.
-  // kFunction, kAllocationSite, kActualArgumentsCount
-  Register registers[] = {kJavaScriptCallTargetRegister,
-                          kJavaScriptCallExtraArg1Register,
-                          kJavaScriptCallArgCountRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-#if !V8_TARGET_ARCH_IA32
-// We need a custom descriptor on ia32 to avoid using xmm0.
-void WasmFloat32ToNumberDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-// We need a custom descriptor on ia32 to avoid using xmm0.
-void WasmFloat64ToNumberDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-#endif  // !V8_TARGET_ARCH_IA32
-
-#if !defined(V8_TARGET_ARCH_MIPS) && !defined(V8_TARGET_ARCH_MIPS64) && \
-    !defined(V8_TARGET_ARCH_RISCV64)
-void WasmI32AtomicWait32Descriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void WasmI64AtomicWait32Descriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data,
-                                    kParameterCount - kStackArgumentsCount);
-}
-#endif
-
-void CloneObjectWithVectorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void CloneObjectBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-// static
-Register RunMicrotasksDescriptor::MicrotaskQueueRegister() {
-  return CallDescriptors::call_descriptor_data(CallDescriptors::RunMicrotasks)
-      ->register_param(0);
-}
-
-void RunMicrotasksDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void I64ToBigIntDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void I32PairToBigIntDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void BigIntToI64Descriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void BigIntToI32PairDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void BinaryOp_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 4);
-}
-
-void CallTrampoline_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void CallTrampoline_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 4);
-}
-
-void CallWithArrayLike_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 4);
-}
-
-void CallWithSpread_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void CallWithSpread_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 4);
-}
-
-void ConstructWithArrayLike_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 4);
-}
-
-void ConstructWithSpread_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data,
-                                    kParameterCount - kStackArgumentsCount);
-}
-
-void ConstructWithSpread_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 4);
-}
-
-void Compare_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 4);
-}
-
-void UnaryOp_WithFeedbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 3);
-}
-
-void UnaryOp_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, 2);
-}
-
-void ForInPrepareDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void SuspendGeneratorBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
-void ResumeGeneratorBaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  DefaultInitializePlatformSpecific(data, kParameterCount);
-}
-
 }  // namespace internal
 }  // namespace v8
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index 8d03907efc0..c788678e028 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -7,6 +7,7 @@
 
 #include <memory>
 
+#include "src/base/logging.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/register-arch.h"
 #include "src/codegen/tnode.h"
@@ -151,17 +152,21 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   };
   using Flags = base::Flags<Flag>;
 
+  static constexpr int kUninitializedCount = -1;
+
   CallInterfaceDescriptorData() = default;
 
   CallInterfaceDescriptorData(const CallInterfaceDescriptorData&) = delete;
   CallInterfaceDescriptorData& operator=(const CallInterfaceDescriptorData&) =
       delete;
 
-  // A copy of the passed in registers and param_representations is made
-  // and owned by the CallInterfaceDescriptorData.
-
-  void InitializePlatformSpecific(int register_parameter_count,
-                                  const Register* registers);
+  // The passed registers are owned by the caller, and their lifetime is
+  // expected to exceed that of this data. In practice, they are expected to
+  // be in a static local.
+  void InitializeRegisters(Flags flags, int return_count, int parameter_count,
+                           StackArgumentOrder stack_order,
+                           int register_parameter_count,
+                           const Register* registers);
 
   // if machine_types is null, then an array of size
   // (return_count + parameter_count) will be created with
@@ -171,17 +176,13 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   // (return_count + parameter_count). Those members of the parameter array will
   // be initialized from {machine_types}, and the rest initialized to
   // MachineType::AnyTagged().
-  void InitializePlatformIndependent(Flags flags, int return_count,
-                                     int parameter_count,
-                                     const MachineType* machine_types,
-                                     int machine_types_length,
-                                     StackArgumentOrder stack_order);
+  void InitializeTypes(const MachineType* machine_types,
+                       int machine_types_length);
 
   void Reset();
 
   bool IsInitialized() const {
-    return IsInitializedPlatformSpecific() &&
-           IsInitializedPlatformIndependent();
+    return IsInitializedRegisters() && IsInitializedTypes();
   }
 
   Flags flags() const { return flags_; }
@@ -189,7 +190,6 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   int param_count() const { return param_count_; }
   int register_param_count() const { return register_param_count_; }
   Register register_param(int index) const { return register_params_[index]; }
-  Register* register_params() const { return register_params_; }
   MachineType return_type(int index) const {
     DCHECK_LT(index, return_count_);
     return machine_types_[index];
@@ -200,9 +200,9 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   }
   StackArgumentOrder stack_order() const { return stack_order_; }
 
-  void RestrictAllocatableRegisters(const Register* registers, int num) {
+  void RestrictAllocatableRegisters(const Register* registers, size_t num) {
     DCHECK_EQ(allocatable_registers_, 0);
-    for (int i = 0; i < num; ++i) {
+    for (size_t i = 0; i < num; ++i) {
       allocatable_registers_ |= registers[i].bit();
     }
     DCHECK_GT(NumRegs(allocatable_registers_), 0);
@@ -211,17 +211,17 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   RegList allocatable_registers() const { return allocatable_registers_; }
 
  private:
-  bool IsInitializedPlatformSpecific() const {
+  bool IsInitializedRegisters() const {
     const bool initialized =
-        (register_param_count_ == 0 && register_params_ == nullptr) ||
-        (register_param_count_ > 0 && register_params_ != nullptr);
-    // Platform-specific initialization happens before platform-independent.
+        return_count_ != kUninitializedCount &&
+        param_count_ != kUninitializedCount &&
+        (register_param_count_ == 0 || register_params_ != nullptr);
+    // Register initialization happens before type initialization.
     return initialized;
   }
-  bool IsInitializedPlatformIndependent() const {
-    const bool initialized =
-        return_count_ >= 0 && param_count_ >= 0 && machine_types_ != nullptr;
-    // Platform-specific initialization happens before platform-independent.
+  bool IsInitializedTypes() const {
+    const bool initialized = machine_types_ != nullptr;
+    // Register initialization happens before type initialization.
     return initialized;
   }
 
@@ -229,9 +229,9 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   bool AllStackParametersAreTagged() const;
 #endif  // DEBUG
 
-  int register_param_count_ = -1;
-  int return_count_ = -1;
-  int param_count_ = -1;
+  int register_param_count_ = kUninitializedCount;
+  int return_count_ = kUninitializedCount;
+  int param_count_ = kUninitializedCount;
   Flags flags_ = kNoFlags;
   StackArgumentOrder stack_order_ = StackArgumentOrder::kDefault;
 
@@ -242,10 +242,10 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   // |registers_params_| defines registers that are used for parameter passing.
   // |machine_types_| defines machine types for resulting values and incomping
   // parameters.
-  // Both arrays are allocated dynamically by the InterfaceDescriptor and
-  // freed on destruction. This is because static arrays cause creation of
-  // runtime static initializers which we don't want.
-  Register* register_params_ = nullptr;
+  // The register params array is owned by the caller, and it's expected that it
+  // is a static local stored in the caller function. The machine types are
+  // allocated dynamically by the InterfaceDescriptor and freed on destruction.
+  const Register* register_params_ = nullptr;
   MachineType* machine_types_ = nullptr;
 };
 
@@ -278,12 +278,35 @@ class V8_EXPORT_PRIVATE CallDescriptors : public AllStatic {
       call_descriptor_data_[NUMBER_OF_DESCRIPTORS];
 };
 
+#if defined(V8_TARGET_ARCH_IA32)
+// To support all possible cases, we must limit the number of register args for
+// TFS builtins on ia32 to 3. Out of the 6 allocatable registers, esi is taken
+// as the context register and ebx is the root register. One register must
+// remain available to store the jump/call target. Thus 3 registers remain for
+// arguments. The reason this applies to TFS builtins specifically is because
+// this becomes relevant for builtins used as targets of Torque function
+// pointers (which must have a register available to store the target).
+// TODO(jgruber): Ideally we should just decrement kMaxBuiltinRegisterParams but
+// that comes with its own set of complications. It's possible, but requires
+// refactoring the calling convention of other existing stubs.
+constexpr int kMaxBuiltinRegisterParams = 4;
+constexpr int kMaxTFSBuiltinRegisterParams = 3;
+#else
+constexpr int kMaxBuiltinRegisterParams = 5;
+constexpr int kMaxTFSBuiltinRegisterParams = kMaxBuiltinRegisterParams;
+#endif
+STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
+constexpr int kJSBuiltinRegisterParams = 4;
+
+// Polymorphic base class for call interface descriptors, which defines getters
+// for the various descriptor properties via a runtime-loaded
+// CallInterfaceDescriptorData field.
 class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
  public:
   using Flags = CallInterfaceDescriptorData::Flags;
 
   CallInterfaceDescriptor() : data_(nullptr) {}
-  virtual ~CallInterfaceDescriptor() = default;
+  ~CallInterfaceDescriptor() = default;
 
   explicit CallInterfaceDescriptor(CallDescriptors::Key key)
       : data_(CallDescriptors::call_descriptor_data(key)) {}
@@ -333,7 +356,9 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
     return data()->stack_order();
   }
 
-  static const Register ContextRegister();
+  static constexpr inline Register ContextRegister() {
+    return kContextRegister;
+  }
 
   const char* DebugName() const;
 
@@ -344,39 +369,13 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
  protected:
   const CallInterfaceDescriptorData* data() const { return data_; }
 
-  virtual void InitializePlatformSpecific(CallInterfaceDescriptorData* data) {
-    UNREACHABLE();
-  }
-
-  // Initializes |data| to an unspecified state, for platforms that haven't
-  // implemented a given builtin.
-  static void InitializePlatformUnimplemented(CallInterfaceDescriptorData* data,
-                                              int register_parameter_count) {
-    DefaultInitializePlatformSpecific(data,
-                                      std::min(register_parameter_count, 4));
-  }
-
-  virtual void InitializePlatformIndependent(
-      CallInterfaceDescriptorData* data) {
-    // Default descriptor configuration: one result, all parameters are passed
-    // in registers and all parameters have MachineType::AnyTagged() type.
-    data->InitializePlatformIndependent(
-        CallInterfaceDescriptorData::kNoFlags, 1, data->register_param_count(),
-        nullptr, 0, StackArgumentOrder::kDefault);
-  }
-
-  // Initializes |data| using the platform dependent default set of registers.
-  // It is intended to be used for TurboFan stubs when particular set of
-  // registers does not matter.
-  static void DefaultInitializePlatformSpecific(
-      CallInterfaceDescriptorData* data, int register_parameter_count);
-
-  // Initializes |data| using the platform dependent default set of registers
-  // for JavaScript-compatible calling convention.
-  // It is intended to be used for TurboFan stubs being called with JavaScript
-  // linkage + additional parameters on registers and stack.
-  static void JSDefaultInitializePlatformSpecific(
-      CallInterfaceDescriptorData* data, int non_js_register_parameter_count);
+  // Helper for defining the default register set.
+  //
+  // Use auto for the return type to allow different architectures to have
+  // differently sized default register arrays.
+  static constexpr inline auto DefaultRegisterArray();
+  static constexpr inline std::array<Register, kJSBuiltinRegisterParams>
+  DefaultJSRegisterArray();
 
   // Checks if float parameters are not assigned invalid registers.
   bool CheckFloatingPointParameters(CallInterfaceDescriptorData* data) {
@@ -392,105 +391,165 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
 
   bool IsValidFloatParameterRegister(Register reg);
 
+ private:
+  const CallInterfaceDescriptorData* data_;
+};
+
+// CRTP base class for call interface descriptors, which defines static getters
+// for the various descriptor properties based on static values defined in the
+// subclass.
+template <typename DerivedDescriptor>
+class StaticCallInterfaceDescriptor : public CallInterfaceDescriptor {
+ public:
+  // ===========================================================================
+  // The following are the descriptor's CRTP configuration points, overwritable
+  // by DerivedDescriptor.
+  static constexpr int kReturnCount =
+      CallInterfaceDescriptorData::kUninitializedCount;
+  static constexpr int kParameterCount =
+      CallInterfaceDescriptorData::kUninitializedCount;
+  static constexpr bool kNoContext = false;
+  static constexpr bool kAllowVarArgs = false;
+  static constexpr bool kNoStackScan = false;
+  static constexpr auto kStackArgumentOrder = StackArgumentOrder::kDefault;
+
+  // The set of registers available to the parameters, as a
+  // std::array<Register,N>. Can be larger or smaller than kParameterCount; if
+  // larger then any remaining registers are ignored; if smaller, any parameters
+  // after registers().size() will be stack registers.
+  //
+  // Defaults to CallInterfaceDescriptor::DefaultRegisterArray().
+  static constexpr inline auto registers();
+
+  // An additional limit on the number of register parameters allowed. This is
+  // here so that it can be overwritten to kMaxTFSBuiltinRegisterParams for TFS
+  // builtins, see comment on kMaxTFSBuiltinRegisterParams above.
+  static constexpr int kMaxRegisterParams = kMaxBuiltinRegisterParams;
+
+  // If set to true, the descriptor will restrict the set of allocatable
+  // registers to the set returned by registers(). Then, it is expected that
+  // the first kParameterCount registers() are the parameters of the builtin.
+  static constexpr bool kRestrictAllocatableRegisters = false;
+
+  // End of customization points.
+  // ===========================================================================
+
+  static constexpr inline Flags flags() {
+    return Flags((DerivedDescriptor::kNoContext
+                      ? CallInterfaceDescriptorData::kNoContext
+                      : 0) |
+                 (DerivedDescriptor::kAllowVarArgs
+                      ? CallInterfaceDescriptorData::kAllowVarArgs
+                      : 0) |
+                 (DerivedDescriptor::kNoStackScan
+                      ? CallInterfaceDescriptorData::kNoStackScan
+                      : 0));
+  }
+  static constexpr inline bool AllowVarArgs() {
+    return DerivedDescriptor::kAllowVarArgs;
+  }
+  static constexpr inline bool HasContextParameter() {
+    return !DerivedDescriptor::kNoContext;
+  }
+
+  static constexpr inline int GetReturnCount();
+  static constexpr inline int GetParameterCount();
+  static constexpr inline int GetRegisterParameterCount();
+  static constexpr inline int GetStackParameterCount();
+  static constexpr inline Register* GetRegisterData();
+
+  static constexpr inline Register GetRegisterParameter(int i) {
+    return DerivedDescriptor::registers()[i];
+  }
+
+  explicit StaticCallInterfaceDescriptor(CallDescriptors::Key key)
+      : CallInterfaceDescriptor(key) {}
+
  private:
   // {CallDescriptors} is allowed to call the private {Initialize} method.
   friend class CallDescriptors;
 
-  const CallInterfaceDescriptorData* data_;
+  inline void Initialize(CallInterfaceDescriptorData* data);
 
-  void Initialize(CallInterfaceDescriptorData* data) {
-    // The passed pointer should be a modifiable pointer to our own data.
-    DCHECK_EQ(data, data_);
-    DCHECK(!data->IsInitialized());
-    InitializePlatformSpecific(data);
-    InitializePlatformIndependent(data);
-    DCHECK(data->IsInitialized());
-    DCHECK(CheckFloatingPointParameters(data));
+  // Set up the types of the descriptor. This is a static function, so that it
+  // is overwritable by subclasses. By default, all parameters have
+  // MachineType::AnyTagged() type.
+  static void InitializeTypes(CallInterfaceDescriptorData* data) {
+    data->InitializeTypes(nullptr, 0);
   }
 };
 
-#define DECLARE_DESCRIPTOR_WITH_BASE(name, base) \
- public:                                         \
-  explicit name() : base(key()) {}               \
-  static inline CallDescriptors::Key key();
+template <typename Descriptor>
+class StaticJSCallInterfaceDescriptor
+    : public StaticCallInterfaceDescriptor<Descriptor> {
+ public:
+  static constexpr auto kStackArgumentOrder = StackArgumentOrder::kJS;
+  static constexpr inline auto registers();
 
-#if defined(V8_TARGET_ARCH_IA32)
-// To support all possible cases, we must limit the number of register args for
-// TFS builtins on ia32 to 3. Out of the 6 allocatable registers, esi is taken
-// as the context register and ebx is the root register. One register must
-// remain available to store the jump/call target. Thus 3 registers remain for
-// arguments. The reason this applies to TFS builtins specifically is because
-// this becomes relevant for builtins used as targets of Torque function
-// pointers (which must have a register available to store the target).
-// TODO(jgruber): Ideally we should just decrement kMaxBuiltinRegisterParams but
-// that comes with its own set of complications. It's possible, but requires
-// refactoring the calling convention of other existing stubs.
-constexpr int kMaxBuiltinRegisterParams = 4;
-constexpr int kMaxTFSBuiltinRegisterParams = 3;
-#else
-constexpr int kMaxBuiltinRegisterParams = 5;
-constexpr int kMaxTFSBuiltinRegisterParams = kMaxBuiltinRegisterParams;
-#endif
-STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
+  using StaticCallInterfaceDescriptor<
+      Descriptor>::StaticCallInterfaceDescriptor;
+};
 
-#define DECLARE_DEFAULT_DESCRIPTOR(name, base)                                 \
-  DECLARE_DESCRIPTOR_WITH_BASE(name, base)                                     \
- protected:                                                                    \
-  static const int kRegisterParams =                                           \
-      kParameterCount > kMaxTFSBuiltinRegisterParams                           \
-          ? kMaxTFSBuiltinRegisterParams                                       \
-          : kParameterCount;                                                   \
-  static const int kStackParams = kParameterCount - kRegisterParams;           \
-  void InitializePlatformSpecific(CallInterfaceDescriptorData* data)           \
-      override {                                                               \
-    DefaultInitializePlatformSpecific(data, kRegisterParams);                  \
-  }                                                                            \
-  void InitializePlatformIndependent(CallInterfaceDescriptorData* data)        \
-      override {                                                               \
-    data->InitializePlatformIndependent(Flags(kDescriptorFlags), kReturnCount, \
-                                        kParameterCount, nullptr, 0,           \
-                                        kStackArgumentOrder);                  \
-  }                                                                            \
-  name(CallDescriptors::Key key) : base(key) {}                                \
-                                                                               \
- public:
-
-#define DECLARE_JS_COMPATIBLE_DESCRIPTOR(name, base,                        \
-                                         non_js_reg_parameters_count)       \
-  DECLARE_DESCRIPTOR_WITH_BASE(name, base)                                  \
- protected:                                                                 \
-  void InitializePlatformSpecific(CallInterfaceDescriptorData* data)        \
-      override {                                                            \
-    JSDefaultInitializePlatformSpecific(data, non_js_reg_parameters_count); \
-  }                                                                         \
-  name(CallDescriptors::Key key) : base(key) {}                             \
-                                                                            \
- public:
-
-#define DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(flags, stack_order,       \
-                                               return_count, ...)        \
-  static constexpr int kDescriptorFlags = flags;                         \
-  static constexpr int kReturnCount = return_count;                      \
-  static constexpr StackArgumentOrder kStackArgumentOrder = stack_order; \
-  enum ParameterIndices {                                                \
-    __dummy = -1, /* to be able to pass zero arguments */                \
-    ##__VA_ARGS__,                                                       \
-                                                                         \
-    kParameterCount,                                                     \
-    kContext = kParameterCount /* implicit parameter */                  \
-  };
+template <Builtins::Name kBuiltin>
+struct CallInterfaceDescriptorFor;
+
+// Stub class replacing std::array<Register, 0>, as a workaround for MSVC's
+// https://github.com/microsoft/STL/issues/942
+struct EmptyRegisterArray {
+  Register* data() { return nullptr; }
+  size_t size() const { return 0; }
+  Register operator[](size_t i) const { UNREACHABLE(); }
+};
+
+// Helper method for defining an array of registers for the various
+// Descriptor::registers() methods.
+template <typename... Registers>
+constexpr std::array<Register, 1 + sizeof...(Registers)> RegisterArray(
+    Register first_reg, Registers... regs) {
+  return {first_reg, regs...};
+}
+constexpr EmptyRegisterArray RegisterArray() { return {}; }
+
+#define DECLARE_DESCRIPTOR_WITH_BASE(name, base)                  \
+ public:                                                          \
+  /* StaticCallInterfaceDescriptor can call Initialize methods */ \
+  friend class StaticCallInterfaceDescriptor<name>;               \
+  explicit name() : base(key()) {}                                \
+  static inline CallDescriptors::Key key();
 
-#define DEFINE_RESULT_AND_PARAMETERS(return_count, ...)                    \
-  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                  \
-      CallInterfaceDescriptorData::kNoFlags, StackArgumentOrder::kDefault, \
-      return_count, ##__VA_ARGS__)
+#define DECLARE_DEFAULT_DESCRIPTOR(name)                                  \
+  DECLARE_DESCRIPTOR_WITH_BASE(name, StaticCallInterfaceDescriptor)       \
+  static constexpr int kMaxRegisterParams = kMaxTFSBuiltinRegisterParams; \
+                                                                          \
+ protected:                                                               \
+  explicit name(CallDescriptors::Key key)                                 \
+      : StaticCallInterfaceDescriptor(key) {}                             \
+                                                                          \
+ public:
+
+#define DECLARE_JS_COMPATIBLE_DESCRIPTOR(name)                        \
+  DECLARE_DESCRIPTOR_WITH_BASE(name, StaticJSCallInterfaceDescriptor) \
+ protected:                                                           \
+  explicit name(CallDescriptors::Key key)                             \
+      : StaticJSCallInterfaceDescriptor(key) {}                       \
+                                                                      \
+ public:
+
+#define DEFINE_RESULT_AND_PARAMETERS(return_count, ...)   \
+  static constexpr int kReturnCount = return_count;       \
+  enum ParameterIndices {                                 \
+    __dummy = -1, /* to be able to pass zero arguments */ \
+    ##__VA_ARGS__,                                        \
+                                                          \
+    kParameterCount,                                      \
+    kContext = kParameterCount /* implicit parameter */   \
+  };
 
 // This is valid only for builtins that use EntryFrame, which does not scan
 // stack arguments on GC.
 #define DEFINE_PARAMETERS_ENTRY(...)                        \
-  static constexpr int kDescriptorFlags =                   \
-      CallInterfaceDescriptorData::kNoContext |             \
-      CallInterfaceDescriptorData::kNoStackScan;            \
+  static constexpr bool kNoContext = true;                  \
+  static constexpr bool kNoStackScan = true;                \
   static constexpr StackArgumentOrder kStackArgumentOrder = \
       StackArgumentOrder::kDefault;                         \
   static constexpr int kReturnCount = 1;                    \
@@ -501,37 +560,31 @@ STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
     kParameterCount                                         \
   };
 
-#define DEFINE_PARAMETERS(...)                                                \
-  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                     \
-      CallInterfaceDescriptorData::kNoFlags, StackArgumentOrder::kDefault, 1, \
-      ##__VA_ARGS__)
+#define DEFINE_PARAMETERS(...) DEFINE_RESULT_AND_PARAMETERS(1, ##__VA_ARGS__)
+
+#define DEFINE_PARAMETERS_NO_CONTEXT(...) \
+  DEFINE_PARAMETERS(__VA_ARGS__)          \
+  static constexpr bool kNoContext = true;
 
-#define DEFINE_PARAMETERS_NO_CONTEXT(...)                                    \
-  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                    \
-      CallInterfaceDescriptorData::kNoContext, StackArgumentOrder::kDefault, \
-      1, ##__VA_ARGS__)
+#define DEFINE_PARAMETERS_VARARGS(...)                      \
+  DEFINE_PARAMETERS(__VA_ARGS__)                            \
+  static constexpr bool kAllowVarArgs = true;               \
+  static constexpr StackArgumentOrder kStackArgumentOrder = \
+      StackArgumentOrder::kJS;
 
-#define DEFINE_PARAMETERS_VARARGS(...)                                        \
-  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                     \
-      CallInterfaceDescriptorData::kAllowVarArgs, StackArgumentOrder::kJS, 1, \
-      ##__VA_ARGS__)
+#define DEFINE_RESULT_AND_PARAMETERS_NO_CONTEXT(return_count, ...) \
+  DEFINE_RESULT_AND_PARAMETERS(return_count, ##__VA_ARGS__)        \
+  static constexpr bool kNoContext = true;
 
-#define DEFINE_RESULT_AND_PARAMETER_TYPES_WITH_FLAG(flag, ...)                \
-  void InitializePlatformIndependent(CallInterfaceDescriptorData* data)       \
-      override {                                                              \
+#define DEFINE_RESULT_AND_PARAMETER_TYPES(...)                                \
+  static void InitializeTypes(CallInterfaceDescriptorData* data) {            \
     MachineType machine_types[] = {__VA_ARGS__};                              \
     static_assert(                                                            \
         kReturnCount + kParameterCount == arraysize(machine_types),           \
         "Parameter names definition is not consistent with parameter types"); \
-    data->InitializePlatformIndependent(                                      \
-        Flags(flag | kDescriptorFlags), kReturnCount, kParameterCount,        \
-        machine_types, arraysize(machine_types), kStackArgumentOrder);        \
+    data->InitializeTypes(machine_types, arraysize(machine_types));           \
   }
 
-#define DEFINE_RESULT_AND_PARAMETER_TYPES(...) \
-  DEFINE_RESULT_AND_PARAMETER_TYPES_WITH_FLAG( \
-      CallInterfaceDescriptorData::kNoFlags, __VA_ARGS__)
-
 #define DEFINE_PARAMETER_TYPES(...)                                        \
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged() /* result */, \
                                     ##__VA_ARGS__)
@@ -539,8 +592,7 @@ STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
 // When the extra arguments described here are located in the stack, they are
 // just above the return address in the frame (first arguments).
 #define DEFINE_JS_PARAMETERS(...)                           \
-  static constexpr int kDescriptorFlags =                   \
-      CallInterfaceDescriptorData::kAllowVarArgs;           \
+  static constexpr bool kAllowVarArgs = true;               \
   static constexpr int kReturnCount = 1;                    \
   static constexpr StackArgumentOrder kStackArgumentOrder = \
       StackArgumentOrder::kJS;                              \
@@ -554,9 +606,8 @@ STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
   };
 
 #define DEFINE_JS_PARAMETERS_NO_CONTEXT(...)                \
-  static constexpr int kDescriptorFlags =                   \
-      CallInterfaceDescriptorData::kAllowVarArgs |          \
-      CallInterfaceDescriptorData::kNoContext;              \
+  static constexpr bool kAllowVarArgs = true;               \
+  static constexpr bool kNoContext = true;                  \
   static constexpr int kReturnCount = 1;                    \
   static constexpr StackArgumentOrder kStackArgumentOrder = \
       StackArgumentOrder::kJS;                              \
@@ -574,63 +625,22 @@ STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
                          MachineType::Int32(),     /* kActualArgumentsCount */ \
                          ##__VA_ARGS__)
 
-#define DECLARE_DESCRIPTOR(name, base)                                         \
-  DECLARE_DESCRIPTOR_WITH_BASE(name, base)                                     \
- protected:                                                                    \
-  void InitializePlatformSpecific(CallInterfaceDescriptorData* data) override; \
-  name(CallDescriptors::Key key) : base(key) {}                                \
-                                                                               \
+#define DECLARE_DESCRIPTOR(name)                                    \
+  DECLARE_DESCRIPTOR_WITH_BASE(name, StaticCallInterfaceDescriptor) \
+ protected:                                                         \
+  explicit name(CallDescriptors::Key key)                           \
+      : StaticCallInterfaceDescriptor(key) {}                       \
+                                                                    \
  public:
 
-class V8_EXPORT_PRIVATE VoidDescriptor : public CallInterfaceDescriptor {
+class V8_EXPORT_PRIVATE VoidDescriptor
+    : public StaticCallInterfaceDescriptor<VoidDescriptor> {
  public:
   DEFINE_PARAMETERS()
   DEFINE_PARAMETER_TYPES()
-  DECLARE_DESCRIPTOR(VoidDescriptor, CallInterfaceDescriptor)
-};
-
-// This class is subclassed by Torque-generated call interface descriptors.
-template <int return_count, int parameter_count, bool has_context_parameter>
-class TorqueInterfaceDescriptor : public CallInterfaceDescriptor {
- public:
-  static constexpr int kDescriptorFlags =
-      has_context_parameter ? CallInterfaceDescriptorData::kNoFlags
-                            : CallInterfaceDescriptorData::kNoContext;
-  static constexpr int kParameterCount = parameter_count;
-  enum ParameterIndices { kContext = kParameterCount };
-  template <int i>
-  static ParameterIndices ParameterIndex() {
-    STATIC_ASSERT(0 <= i && i < kParameterCount);
-    return static_cast<ParameterIndices>(i);
-  }
-  static constexpr int kReturnCount = return_count;
-
-  using CallInterfaceDescriptor::CallInterfaceDescriptor;
+  DECLARE_DESCRIPTOR(VoidDescriptor)
 
- protected:
-  static const int kRegisterParams =
-      kParameterCount > kMaxTFSBuiltinRegisterParams
-          ? kMaxTFSBuiltinRegisterParams
-          : kParameterCount;
-  static const int kStackParams = kParameterCount - kRegisterParams;
-  virtual std::vector<MachineType> ReturnType() = 0;
-  virtual std::array<MachineType, kParameterCount> ParameterTypes() = 0;
-  void InitializePlatformSpecific(CallInterfaceDescriptorData* data) override {
-    DefaultInitializePlatformSpecific(data, kRegisterParams);
-  }
-  void InitializePlatformIndependent(
-      CallInterfaceDescriptorData* data) override {
-    std::vector<MachineType> machine_types = ReturnType();
-    DCHECK_EQ(kReturnCount, machine_types.size());
-    auto parameter_types = ParameterTypes();
-    machine_types.insert(machine_types.end(), parameter_types.begin(),
-                         parameter_types.end());
-    DCHECK_EQ(kReturnCount + kParameterCount, machine_types.size());
-    data->InitializePlatformIndependent(Flags(kDescriptorFlags), kReturnCount,
-                                        kParameterCount, machine_types.data(),
-                                        static_cast<int>(machine_types.size()),
-                                        StackArgumentOrder::kDefault);
-  }
+  static constexpr auto registers();
 };
 
 // Dummy descriptor used to mark builtins that don't yet have their proper
@@ -646,180 +656,171 @@ using CCallDescriptor = VoidDescriptor;
 // here.
 using DeoptimizationEntryDescriptor = VoidDescriptor;
 
-class AllocateDescriptor : public CallInterfaceDescriptor {
+class AllocateDescriptor
+    : public StaticCallInterfaceDescriptor<AllocateDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kRequestedSize)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::TaggedPointer(),  // result 1
                                     MachineType::IntPtr())  // kRequestedSize
-  DECLARE_DESCRIPTOR(AllocateDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(AllocateDescriptor)
+
+  static constexpr auto registers();
 };
 
 // This descriptor defines the JavaScript calling convention that can be used
 // by stubs: target, new.target, argc (not including the receiver) and context
 // are passed in registers while receiver and the rest of the JS arguments are
 // passed on the stack.
-class JSTrampolineDescriptor : public CallInterfaceDescriptor {
+class JSTrampolineDescriptor
+    : public StaticJSCallInterfaceDescriptor<JSTrampolineDescriptor> {
  public:
   DEFINE_JS_PARAMETERS()
   DEFINE_JS_PARAMETER_TYPES()
 
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(JSTrampolineDescriptor,
-                                   CallInterfaceDescriptor, 0)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(JSTrampolineDescriptor)
 };
 
-class ContextOnlyDescriptor : public CallInterfaceDescriptor {
+class ContextOnlyDescriptor
+    : public StaticCallInterfaceDescriptor<ContextOnlyDescriptor> {
  public:
   DEFINE_PARAMETERS()
   DEFINE_PARAMETER_TYPES()
-  DECLARE_DESCRIPTOR(ContextOnlyDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ContextOnlyDescriptor)
+
+  static constexpr auto registers();
 };
 
-class NoContextDescriptor : public CallInterfaceDescriptor {
+class NoContextDescriptor
+    : public StaticCallInterfaceDescriptor<NoContextDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT()
   DEFINE_PARAMETER_TYPES()
-  DECLARE_DESCRIPTOR(NoContextDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(NoContextDescriptor)
+
+  static constexpr auto registers();
 };
 
 // LoadDescriptor is used by all stubs that implement Load/KeyedLoad ICs.
-class LoadDescriptor : public CallInterfaceDescriptor {
+class LoadDescriptor : public StaticCallInterfaceDescriptor<LoadDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(LoadDescriptor)
 
-  static const Register ReceiverRegister();
-  static const Register NameRegister();
-  static const Register SlotRegister();
+  static constexpr inline Register ReceiverRegister();
+  static constexpr inline Register NameRegister();
+  static constexpr inline Register SlotRegister();
+
+  static constexpr auto registers();
 };
 
 // LoadBaselineDescriptor is a load descriptor that does not take a context as
 // input.
-class LoadBaselineDescriptor : public CallInterfaceDescriptor {
+class LoadBaselineDescriptor
+    : public StaticCallInterfaceDescriptor<LoadBaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kReceiver, kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadBaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(LoadBaselineDescriptor)
+
+  static constexpr auto registers();
 };
 
-class LoadGlobalNoFeedbackDescriptor : public CallInterfaceDescriptor {
+class LoadGlobalNoFeedbackDescriptor
+    : public StaticCallInterfaceDescriptor<LoadGlobalNoFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS(kName, kICKind)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kICKind
-  DECLARE_DESCRIPTOR(LoadGlobalNoFeedbackDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(LoadGlobalNoFeedbackDescriptor)
 
-  static const Register NameRegister() {
-    return LoadDescriptor::NameRegister();
-  }
+  static constexpr inline Register ICKindRegister();
 
-  static const Register ICKindRegister() {
-    return LoadDescriptor::SlotRegister();
-  }
+  static constexpr auto registers();
 };
 
-class LoadNoFeedbackDescriptor : public LoadGlobalNoFeedbackDescriptor {
+class LoadNoFeedbackDescriptor
+    : public StaticCallInterfaceDescriptor<LoadNoFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kICKind)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kICKind
-  DECLARE_DESCRIPTOR(LoadNoFeedbackDescriptor, LoadGlobalNoFeedbackDescriptor)
-
-  static const Register ReceiverRegister() {
-    return LoadDescriptor::ReceiverRegister();
-  }
+  DECLARE_DESCRIPTOR(LoadNoFeedbackDescriptor)
 
-  static const Register NameRegister() {
-    return LoadGlobalNoFeedbackDescriptor::NameRegister();
-  }
+  static constexpr inline Register ICKindRegister();
 
-  static const Register ICKindRegister() {
-    return LoadGlobalNoFeedbackDescriptor::ICKindRegister();
-  }
+  static constexpr auto registers();
 };
 
-class LoadGlobalDescriptor : public CallInterfaceDescriptor {
+class LoadGlobalDescriptor
+    : public StaticCallInterfaceDescriptor<LoadGlobalDescriptor> {
  public:
   DEFINE_PARAMETERS(kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadGlobalDescriptor, CallInterfaceDescriptor)
-
-  static const Register NameRegister() {
-    return LoadDescriptor::NameRegister();
-  }
+  DECLARE_DESCRIPTOR(LoadGlobalDescriptor)
 
-  static const Register SlotRegister() {
-    return LoadDescriptor::SlotRegister();
-  }
+  static constexpr auto registers();
 };
 
-class LoadGlobalBaselineDescriptor : public CallInterfaceDescriptor {
+class LoadGlobalBaselineDescriptor
+    : public StaticCallInterfaceDescriptor<LoadGlobalBaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadGlobalBaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(LoadGlobalBaselineDescriptor)
+
+  static constexpr auto registers();
 };
 
-class LookupBaselineDescriptor : public CallInterfaceDescriptor {
+class LookupBaselineDescriptor
+    : public StaticCallInterfaceDescriptor<LookupBaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kName, kDepth, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged(),  // kDepth
                          MachineType::AnyTagged())  // kSlot
-  DECLARE_DESCRIPTOR(LookupBaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(LookupBaselineDescriptor)
 };
 
-class StoreDescriptor : public CallInterfaceDescriptor {
+class StoreDescriptor : public StaticCallInterfaceDescriptor<StoreDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(StoreDescriptor)
 
-  static const Register ReceiverRegister();
-  static const Register NameRegister();
-  static const Register ValueRegister();
-  static const Register SlotRegister();
+  static constexpr inline Register ReceiverRegister();
+  static constexpr inline Register NameRegister();
+  static constexpr inline Register ValueRegister();
+  static constexpr inline Register SlotRegister();
 
-#if V8_TARGET_ARCH_IA32
-  static const bool kPassLastArgsOnStack = true;
-#else
-  static const bool kPassLastArgsOnStack = false;
-#endif
-
-  // Pass value and slot through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
+  static constexpr auto registers();
 };
 
-class StoreBaselineDescriptor : public CallInterfaceDescriptor {
+class StoreBaselineDescriptor
+    : public StaticCallInterfaceDescriptor<StoreDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kReceiver, kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreBaselineDescriptor, CallInterfaceDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  static const bool kPassLastArgsOnStack = true;
-#else
-  static const bool kPassLastArgsOnStack = false;
-#endif
+  DECLARE_DESCRIPTOR(StoreBaselineDescriptor)
 
-  // Pass value and slot through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
+  static constexpr auto registers();
 };
 
-class StoreTransitionDescriptor : public StoreDescriptor {
+class StoreTransitionDescriptor
+    : public StaticCallInterfaceDescriptor<StoreTransitionDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kMap, kValue, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
@@ -828,17 +829,15 @@ class StoreTransitionDescriptor : public StoreDescriptor {
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(StoreTransitionDescriptor, StoreDescriptor)
+  DECLARE_DESCRIPTOR(StoreTransitionDescriptor)
 
-  static const Register MapRegister();
-  static const Register SlotRegister();
-  static const Register VectorRegister();
+  static constexpr inline Register MapRegister();
 
-  // Pass value, slot and vector through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
+  static constexpr auto registers();
 };
 
-class StoreWithVectorDescriptor : public StoreDescriptor {
+class StoreWithVectorDescriptor
+    : public StaticCallInterfaceDescriptor<StoreWithVectorDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kValue, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
@@ -846,72 +845,52 @@ class StoreWithVectorDescriptor : public StoreDescriptor {
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(StoreWithVectorDescriptor, StoreDescriptor)
+  DECLARE_DESCRIPTOR(StoreWithVectorDescriptor)
 
-  static const Register VectorRegister();
+  static constexpr inline Register VectorRegister();
 
-  // Pass value, slot and vector through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
+  static constexpr auto registers();
 };
 
-class StoreGlobalDescriptor : public CallInterfaceDescriptor {
+class StoreGlobalDescriptor
+    : public StaticCallInterfaceDescriptor<StoreGlobalDescriptor> {
  public:
   DEFINE_PARAMETERS(kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreGlobalDescriptor, CallInterfaceDescriptor)
-
-  static const bool kPassLastArgsOnStack =
-      StoreDescriptor::kPassLastArgsOnStack;
-  // Pass value and slot through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
-
-  static const Register NameRegister() {
-    return StoreDescriptor::NameRegister();
-  }
-
-  static const Register ValueRegister() {
-    return StoreDescriptor::ValueRegister();
-  }
+  DECLARE_DESCRIPTOR(StoreGlobalDescriptor)
 
-  static const Register SlotRegister() {
-    return StoreDescriptor::SlotRegister();
-  }
+  static constexpr auto registers();
 };
 
-class StoreGlobalBaselineDescriptor : public CallInterfaceDescriptor {
+class StoreGlobalBaselineDescriptor
+    : public StaticCallInterfaceDescriptor<StoreGlobalBaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreGlobalBaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(StoreGlobalBaselineDescriptor)
 
-  static const bool kPassLastArgsOnStack =
-      StoreDescriptor::kPassLastArgsOnStack;
-  // Pass value and slot through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
+  static constexpr auto registers();
 };
 
-class StoreGlobalWithVectorDescriptor : public StoreGlobalDescriptor {
+class StoreGlobalWithVectorDescriptor
+    : public StaticCallInterfaceDescriptor<StoreGlobalWithVectorDescriptor> {
  public:
   DEFINE_PARAMETERS(kName, kValue, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(StoreGlobalWithVectorDescriptor, StoreGlobalDescriptor)
-
-  static const Register VectorRegister() {
-    return StoreWithVectorDescriptor::VectorRegister();
-  }
+  DECLARE_DESCRIPTOR(StoreGlobalWithVectorDescriptor)
 
-  // Pass value, slot and vector through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
+  static constexpr auto registers();
 };
 
-class LoadWithVectorDescriptor : public LoadDescriptor {
+class LoadWithVectorDescriptor
+    : public StaticCallInterfaceDescriptor<LoadWithVectorDescriptor> {
  public:
   // TODO(v8:9497): Revert the Machine type for kSlot to the
   // TaggedSigned once Torque can emit better call descriptors
@@ -920,24 +899,19 @@ class LoadWithVectorDescriptor : public LoadDescriptor {
                          MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged(),  // kSlot
                          MachineType::AnyTagged())  // kVector
-  DECLARE_DESCRIPTOR(LoadWithVectorDescriptor, LoadDescriptor)
-
-  static const Register VectorRegister();
+  DECLARE_DESCRIPTOR(LoadWithVectorDescriptor)
 
-#if V8_TARGET_ARCH_IA32
-  static const bool kPassLastArgsOnStack = true;
-#else
-  static const bool kPassLastArgsOnStack = false;
-#endif
+  static constexpr inline Register VectorRegister();
 
-  // Pass vector through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
+  static constexpr auto registers();
 };
 
 // Like LoadWithVectorDescriptor, except we pass the receiver (the object which
 // should be used as the receiver for accessor function calls) and the lookup
 // start object separately.
-class LoadWithReceiverAndVectorDescriptor : public LoadWithVectorDescriptor {
+class LoadWithReceiverAndVectorDescriptor
+    : public StaticCallInterfaceDescriptor<
+          LoadWithReceiverAndVectorDescriptor> {
  public:
   // TODO(v8:9497): Revert the Machine type for kSlot to the
   // TaggedSigned once Torque can emit better call descriptors
@@ -947,22 +921,15 @@ class LoadWithReceiverAndVectorDescriptor : public LoadWithVectorDescriptor {
                          MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged(),  // kSlot
                          MachineType::AnyTagged())  // kVector
-  DECLARE_DESCRIPTOR(LoadWithReceiverAndVectorDescriptor,
-                     LoadWithVectorDescriptor)
-
-  static const Register LookupStartObjectRegister();
+  DECLARE_DESCRIPTOR(LoadWithReceiverAndVectorDescriptor)
 
-#if V8_TARGET_ARCH_IA32
-  static const bool kPassLastArgsOnStack = true;
-#else
-  static const bool kPassLastArgsOnStack = false;
-#endif
+  static constexpr inline Register LookupStartObjectRegister();
 
-  // Pass vector through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
+  static constexpr auto registers();
 };
 
-class LoadWithReceiverBaselineDescriptor : public LoadBaselineDescriptor {
+class LoadWithReceiverBaselineDescriptor
+    : public StaticCallInterfaceDescriptor<LoadWithReceiverBaselineDescriptor> {
  public:
   // TODO(v8:9497): Revert the Machine type for kSlot to the
   // TaggedSigned once Torque can emit better call descriptors
@@ -971,29 +938,27 @@ class LoadWithReceiverBaselineDescriptor : public LoadBaselineDescriptor {
                          MachineType::AnyTagged(),  // kLookupStartObject
                          MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged())  // kSlot
-  DECLARE_DESCRIPTOR(LoadWithReceiverBaselineDescriptor, LoadBaselineDescriptor)
+  DECLARE_DESCRIPTOR(LoadWithReceiverBaselineDescriptor)
+
+  static constexpr auto registers();
 };
 
-class LoadGlobalWithVectorDescriptor : public LoadGlobalDescriptor {
+class LoadGlobalWithVectorDescriptor
+    : public StaticCallInterfaceDescriptor<LoadGlobalWithVectorDescriptor> {
  public:
   DEFINE_PARAMETERS(kName, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(LoadGlobalWithVectorDescriptor, LoadGlobalDescriptor)
+  DECLARE_DESCRIPTOR(LoadGlobalWithVectorDescriptor)
 
-#if V8_TARGET_ARCH_IA32
-  // On ia32, LoadWithVectorDescriptor passes vector on the stack and thus we
-  // need to choose a new register here.
-  static const Register VectorRegister() { return edx; }
-#else
-  static const Register VectorRegister() {
-    return LoadWithVectorDescriptor::VectorRegister();
-  }
-#endif
+  static constexpr inline Register VectorRegister();
+
+  static constexpr auto registers();
 };
 
-class DynamicCheckMapsDescriptor final : public CallInterfaceDescriptor {
+class DynamicCheckMapsDescriptor final
+    : public StaticCallInterfaceDescriptor<DynamicCheckMapsDescriptor> {
  public:
   DEFINE_PARAMETERS(kMap, kSlot, kHandler)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::Int32(),          // return val
@@ -1001,20 +966,28 @@ class DynamicCheckMapsDescriptor final : public CallInterfaceDescriptor {
                                     MachineType::IntPtr(),         // kSlot
                                     MachineType::TaggedSigned())   // kHandler
 
-  DECLARE_DESCRIPTOR(DynamicCheckMapsDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(DynamicCheckMapsDescriptor)
+
+  static constexpr auto registers();
+  static constexpr bool kRestrictAllocatableRegisters = true;
 };
 
-class FastNewObjectDescriptor : public CallInterfaceDescriptor {
+class FastNewObjectDescriptor
+    : public StaticCallInterfaceDescriptor<FastNewObjectDescriptor> {
  public:
   DEFINE_PARAMETERS(kTarget, kNewTarget)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged())  // kNewTarget
-  DECLARE_DESCRIPTOR(FastNewObjectDescriptor, CallInterfaceDescriptor)
-  static const Register TargetRegister();
-  static const Register NewTargetRegister();
+  DECLARE_DESCRIPTOR(FastNewObjectDescriptor)
+
+  static constexpr inline Register TargetRegister();
+  static constexpr inline Register NewTargetRegister();
+
+  static constexpr auto registers();
 };
 
-class RecordWriteDescriptor final : public CallInterfaceDescriptor {
+class RecordWriteDescriptor final
+    : public StaticCallInterfaceDescriptor<RecordWriteDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kObject, kSlot, kRememberedSet, kFPMode)
   DEFINE_PARAMETER_TYPES(MachineType::TaggedPointer(),  // kObject
@@ -1022,90 +995,119 @@ class RecordWriteDescriptor final : public CallInterfaceDescriptor {
                          MachineType::TaggedSigned(),   // kRememberedSet
                          MachineType::TaggedSigned())   // kFPMode
 
-  DECLARE_DESCRIPTOR(RecordWriteDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(RecordWriteDescriptor)
+
+  static constexpr auto registers();
+  static constexpr bool kRestrictAllocatableRegisters = true;
 };
 
-class EphemeronKeyBarrierDescriptor final : public CallInterfaceDescriptor {
+class EphemeronKeyBarrierDescriptor final
+    : public StaticCallInterfaceDescriptor<EphemeronKeyBarrierDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kObject, kSlotAddress, kFPMode)
   DEFINE_PARAMETER_TYPES(MachineType::TaggedPointer(),  // kObject
                          MachineType::Pointer(),        // kSlotAddress
                          MachineType::TaggedSigned())   // kFPMode
 
-  DECLARE_DESCRIPTOR(EphemeronKeyBarrierDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(EphemeronKeyBarrierDescriptor)
+
+  static constexpr auto registers();
+  static constexpr bool kRestrictAllocatableRegisters = true;
 };
 
-class TypeConversionDescriptor final : public CallInterfaceDescriptor {
+class TypeConversionDescriptor final
+    : public StaticCallInterfaceDescriptor<TypeConversionDescriptor> {
  public:
   DEFINE_PARAMETERS(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(TypeConversionDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(TypeConversionDescriptor)
+
+  static constexpr inline Register ArgumentRegister();
 
-  static const Register ArgumentRegister();
+  static constexpr auto registers();
 };
 
-class TypeConversionNoContextDescriptor final : public CallInterfaceDescriptor {
+class TypeConversionNoContextDescriptor final
+    : public StaticCallInterfaceDescriptor<TypeConversionNoContextDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(TypeConversionNoContextDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(TypeConversionNoContextDescriptor)
+
+  static constexpr auto registers();
 };
 
-class TypeConversion_BaselineDescriptor final : public CallInterfaceDescriptor {
+class TypeConversion_BaselineDescriptor final
+    : public StaticCallInterfaceDescriptor<TypeConversion_BaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kArgument, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(), MachineType::UintPtr())
-  DECLARE_DESCRIPTOR(TypeConversion_BaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(TypeConversion_BaselineDescriptor)
 };
 
-class SingleParameterOnStackDescriptor final : public CallInterfaceDescriptor {
+class SingleParameterOnStackDescriptor final
+    : public StaticCallInterfaceDescriptor<SingleParameterOnStackDescriptor> {
  public:
   DEFINE_PARAMETERS(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(SingleParameterOnStackDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(SingleParameterOnStackDescriptor)
+
+  static constexpr auto registers();
 };
 
 class AsyncFunctionStackParameterDescriptor final
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          AsyncFunctionStackParameterDescriptor> {
  public:
   DEFINE_PARAMETERS(kPromise, kResult)
   DEFINE_PARAMETER_TYPES(MachineType::TaggedPointer(), MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(AsyncFunctionStackParameterDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(AsyncFunctionStackParameterDescriptor)
+
+  static constexpr auto registers();
 };
 
 class GetIteratorStackParameterDescriptor final
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          GetIteratorStackParameterDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kCallSlot, kFeedback, kResult)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(), MachineType::AnyTagged(),
                          MachineType::AnyTagged(), MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(GetIteratorStackParameterDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(GetIteratorStackParameterDescriptor)
+
+  static constexpr auto registers();
 };
 
-class GetPropertyDescriptor final : public CallInterfaceDescriptor {
+class GetPropertyDescriptor final
+    : public StaticCallInterfaceDescriptor<GetPropertyDescriptor> {
  public:
   DEFINE_PARAMETERS(kObject, kKey)
-  DECLARE_DEFAULT_DESCRIPTOR(GetPropertyDescriptor, CallInterfaceDescriptor)
+  DECLARE_DEFAULT_DESCRIPTOR(GetPropertyDescriptor)
 };
 
-class TypeofDescriptor : public CallInterfaceDescriptor {
+class TypeofDescriptor
+    : public StaticCallInterfaceDescriptor<TypeofDescriptor> {
  public:
   DEFINE_PARAMETERS(kObject)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(TypeofDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(TypeofDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class CallTrampolineDescriptor : public CallInterfaceDescriptor {
+class CallTrampolineDescriptor
+    : public StaticCallInterfaceDescriptor<CallTrampolineDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunction, kActualArgumentsCount)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunction
                          MachineType::Int32())      // kActualArgumentsCount
-  DECLARE_DESCRIPTOR(CallTrampolineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallTrampolineDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class CallVarargsDescriptor : public CallInterfaceDescriptor {
+class CallVarargsDescriptor
+    : public StaticCallInterfaceDescriptor<CallVarargsDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kActualArgumentsCount, kArgumentsLength,
                             kArgumentsList)
@@ -1113,46 +1115,60 @@ class CallVarargsDescriptor : public CallInterfaceDescriptor {
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::Int32(),      // kArgumentsLength
                          MachineType::AnyTagged())  // kArgumentsList
-  DECLARE_DESCRIPTOR(CallVarargsDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallVarargsDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class CallForwardVarargsDescriptor : public CallInterfaceDescriptor {
+class CallForwardVarargsDescriptor
+    : public StaticCallInterfaceDescriptor<CallForwardVarargsDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kActualArgumentsCount, kStartIndex)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::Int32())      // kStartIndex
-  DECLARE_DESCRIPTOR(CallForwardVarargsDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallForwardVarargsDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class CallFunctionTemplateDescriptor : public CallInterfaceDescriptor {
+class CallFunctionTemplateDescriptor
+    : public StaticCallInterfaceDescriptor<CallFunctionTemplateDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunctionTemplateInfo, kArgumentsCount)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunctionTemplateInfo
                          MachineType::IntPtr())     // kArgumentsCount
-  DECLARE_DESCRIPTOR(CallFunctionTemplateDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallFunctionTemplateDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class CallWithSpreadDescriptor : public CallInterfaceDescriptor {
+class CallWithSpreadDescriptor
+    : public StaticCallInterfaceDescriptor<CallWithSpreadDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kArgumentsCount, kSpread)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::Int32(),      // kArgumentsCount
                          MachineType::AnyTagged())  // kSpread
-  DECLARE_DESCRIPTOR(CallWithSpreadDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallWithSpreadDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class CallWithSpread_BaselineDescriptor : public CallInterfaceDescriptor {
+class CallWithSpread_BaselineDescriptor
+    : public StaticCallInterfaceDescriptor<CallWithSpread_BaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kArgumentsCount, kSpread, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::Int32(),      // kArgumentsCount
                          MachineType::AnyTagged(),  // kSpread
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(CallWithSpread_BaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallWithSpread_BaselineDescriptor)
 };
 
-class CallWithSpread_WithFeedbackDescriptor : public CallInterfaceDescriptor {
+class CallWithSpread_WithFeedbackDescriptor
+    : public StaticCallInterfaceDescriptor<
+          CallWithSpread_WithFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kArgumentsCount, kSpread, kSlot,
                             kFeedbackVector)
@@ -1161,75 +1177,79 @@ class CallWithSpread_WithFeedbackDescriptor : public CallInterfaceDescriptor {
                          MachineType::AnyTagged(),  // kSpread
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(CallWithSpread_WithFeedbackDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallWithSpread_WithFeedbackDescriptor)
 };
 
-class CallWithArrayLikeDescriptor : public CallInterfaceDescriptor {
+class CallWithArrayLikeDescriptor
+    : public StaticCallInterfaceDescriptor<CallWithArrayLikeDescriptor> {
  public:
   DEFINE_PARAMETERS(kTarget, kArgumentsList)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged())  // kArgumentsList
-  DECLARE_DESCRIPTOR(CallWithArrayLikeDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallWithArrayLikeDescriptor)
+
+  static constexpr inline auto registers();
 };
 
 class CallWithArrayLike_WithFeedbackDescriptor
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          CallWithArrayLike_WithFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS(kTarget, kArgumentsList, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged(),  // kArgumentsList
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(CallWithArrayLike_WithFeedbackDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallWithArrayLike_WithFeedbackDescriptor)
 };
 
-class ConstructVarargsDescriptor : public CallInterfaceDescriptor {
+class ConstructVarargsDescriptor
+    : public StaticCallInterfaceDescriptor<ConstructVarargsDescriptor> {
  public:
   DEFINE_JS_PARAMETERS(kArgumentsLength, kArgumentsList)
   DEFINE_JS_PARAMETER_TYPES(MachineType::Int32(),      // kArgumentsLength
                             MachineType::AnyTagged())  // kArgumentsList
 
-  DECLARE_DESCRIPTOR(ConstructVarargsDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ConstructVarargsDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class ConstructForwardVarargsDescriptor : public CallInterfaceDescriptor {
+class ConstructForwardVarargsDescriptor
+    : public StaticCallInterfaceDescriptor<ConstructForwardVarargsDescriptor> {
  public:
   DEFINE_JS_PARAMETERS(kStartIndex)
   DEFINE_JS_PARAMETER_TYPES(MachineType::Int32())
-  DECLARE_DESCRIPTOR(ConstructForwardVarargsDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ConstructForwardVarargsDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class ConstructWithSpreadDescriptor : public CallInterfaceDescriptor {
+class ConstructWithSpreadDescriptor
+    : public StaticCallInterfaceDescriptor<ConstructWithSpreadDescriptor> {
  public:
   DEFINE_JS_PARAMETERS(kSpread)
   DEFINE_JS_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(ConstructWithSpreadDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ConstructWithSpreadDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class ConstructWithSpread_BaselineDescriptor : public CallInterfaceDescriptor {
+class ConstructWithSpread_BaselineDescriptor
+    : public StaticCallInterfaceDescriptor<
+          ConstructWithSpread_BaselineDescriptor> {
  public:
   // Note: kSlot comes before kSpread since as an untagged value it must be
   // passed in a register.
   DEFINE_JS_PARAMETERS(kSlot, kSpread)
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr(),    // kSlot
                             MachineType::AnyTagged())  // kSpread
-  DECLARE_DESCRIPTOR(ConstructWithSpread_BaselineDescriptor,
-                     CallInterfaceDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  static const bool kPassLastArgsOnStack = true;
-#else
-  static const bool kPassLastArgsOnStack = false;
-#endif
-
-  // Pass spread through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
+  DECLARE_DESCRIPTOR(ConstructWithSpread_BaselineDescriptor)
 };
 
 class ConstructWithSpread_WithFeedbackDescriptor
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          ConstructWithSpread_WithFeedbackDescriptor> {
  public:
   // Note: kSlot comes before kSpread since as an untagged value it must be
   // passed in a register.
@@ -1237,21 +1257,24 @@ class ConstructWithSpread_WithFeedbackDescriptor
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr(),    // kSlot
                             MachineType::AnyTagged(),  // kSpread
                             MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(ConstructWithSpread_WithFeedbackDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ConstructWithSpread_WithFeedbackDescriptor)
 };
 
-class ConstructWithArrayLikeDescriptor : public CallInterfaceDescriptor {
+class ConstructWithArrayLikeDescriptor
+    : public StaticCallInterfaceDescriptor<ConstructWithArrayLikeDescriptor> {
  public:
   DEFINE_PARAMETERS(kTarget, kNewTarget, kArgumentsList)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged(),  // kNewTarget
                          MachineType::AnyTagged())  // kArgumentsList
-  DECLARE_DESCRIPTOR(ConstructWithArrayLikeDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ConstructWithArrayLikeDescriptor)
+
+  static constexpr inline auto registers();
 };
 
 class ConstructWithArrayLike_WithFeedbackDescriptor
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          ConstructWithArrayLike_WithFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS(kTarget, kNewTarget, kArgumentsList, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
@@ -1259,38 +1282,44 @@ class ConstructWithArrayLike_WithFeedbackDescriptor
                          MachineType::AnyTagged(),  // kArgumentsList
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(ConstructWithArrayLike_WithFeedbackDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ConstructWithArrayLike_WithFeedbackDescriptor)
 };
 
 // TODO(ishell): consider merging this with ArrayConstructorDescriptor
-class ConstructStubDescriptor : public CallInterfaceDescriptor {
+class ConstructStubDescriptor
+    : public StaticCallInterfaceDescriptor<ConstructStubDescriptor> {
  public:
   // TODO(jgruber): Remove the unused allocation site parameter.
   DEFINE_JS_PARAMETERS(kAllocationSite)
   DEFINE_JS_PARAMETER_TYPES(MachineType::AnyTagged())
 
   // TODO(ishell): Use DECLARE_JS_COMPATIBLE_DESCRIPTOR if registers match
-  DECLARE_DESCRIPTOR(ConstructStubDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ConstructStubDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class AbortDescriptor : public CallInterfaceDescriptor {
+class AbortDescriptor : public StaticCallInterfaceDescriptor<AbortDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kMessageOrMessageId)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(AbortDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(AbortDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class ArrayConstructorDescriptor : public CallInterfaceDescriptor {
+class ArrayConstructorDescriptor
+    : public StaticJSCallInterfaceDescriptor<ArrayConstructorDescriptor> {
  public:
   DEFINE_JS_PARAMETERS(kAllocationSite)
   DEFINE_JS_PARAMETER_TYPES(MachineType::AnyTagged())
 
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(ArrayConstructorDescriptor,
-                                   CallInterfaceDescriptor, 1)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(ArrayConstructorDescriptor)
 };
 
-class ArrayNArgumentsConstructorDescriptor : public CallInterfaceDescriptor {
+class ArrayNArgumentsConstructorDescriptor
+    : public StaticCallInterfaceDescriptor<
+          ArrayNArgumentsConstructorDescriptor> {
  public:
   // This descriptor declares only register arguments while respective number
   // of JS arguments stay on the expression stack.
@@ -1300,12 +1329,14 @@ class ArrayNArgumentsConstructorDescriptor : public CallInterfaceDescriptor {
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunction,
                          MachineType::AnyTagged(),  // kAllocationSite
                          MachineType::Int32())      // kActualArgumentsCount
-  DECLARE_DESCRIPTOR(ArrayNArgumentsConstructorDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ArrayNArgumentsConstructorDescriptor)
+
+  static constexpr auto registers();
 };
 
 class ArrayNoArgumentConstructorDescriptor
-    : public ArrayNArgumentsConstructorDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          ArrayNoArgumentConstructorDescriptor> {
  public:
   // This descriptor declares same register arguments as the parent
   // ArrayNArgumentsConstructorDescriptor and it declares indices for
@@ -1316,12 +1347,14 @@ class ArrayNoArgumentConstructorDescriptor
                          MachineType::AnyTagged(),  // kAllocationSite
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::AnyTagged())  // kFunctionParameter
-  DECLARE_DESCRIPTOR(ArrayNoArgumentConstructorDescriptor,
-                     ArrayNArgumentsConstructorDescriptor)
+  DECLARE_DESCRIPTOR(ArrayNoArgumentConstructorDescriptor)
+
+  static constexpr auto registers();
 };
 
 class ArraySingleArgumentConstructorDescriptor
-    : public ArrayNArgumentsConstructorDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          ArraySingleArgumentConstructorDescriptor> {
  public:
   // This descriptor declares same register arguments as the parent
   // ArrayNArgumentsConstructorDescriptor and it declares indices for
@@ -1334,44 +1367,56 @@ class ArraySingleArgumentConstructorDescriptor
                          // JS arguments on the stack
                          MachineType::AnyTagged(),  // kArraySizeSmiParameter
                          MachineType::AnyTagged())  // kReceiverParameter
-  DECLARE_DESCRIPTOR(ArraySingleArgumentConstructorDescriptor,
-                     ArrayNArgumentsConstructorDescriptor)
+  DECLARE_DESCRIPTOR(ArraySingleArgumentConstructorDescriptor)
+
+  static constexpr auto registers();
 };
 
-class CompareDescriptor : public CallInterfaceDescriptor {
+class CompareDescriptor
+    : public StaticCallInterfaceDescriptor<CompareDescriptor> {
  public:
   DEFINE_PARAMETERS(kLeft, kRight)
-  DECLARE_DESCRIPTOR(CompareDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CompareDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class BinaryOpDescriptor : public CallInterfaceDescriptor {
+class BinaryOpDescriptor
+    : public StaticCallInterfaceDescriptor<BinaryOpDescriptor> {
  public:
   DEFINE_PARAMETERS(kLeft, kRight)
-  DECLARE_DESCRIPTOR(BinaryOpDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(BinaryOpDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class BinaryOp_BaselineDescriptor : public CallInterfaceDescriptor {
+class BinaryOp_BaselineDescriptor
+    : public StaticCallInterfaceDescriptor<BinaryOp_BaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kLeft, kRight, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(BinaryOp_BaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(BinaryOp_BaselineDescriptor)
+
+  static constexpr inline auto registers();
 };
 
 // This desciptor is shared among String.p.charAt/charCodeAt/codePointAt
 // as they all have the same interface.
-class StringAtDescriptor final : public CallInterfaceDescriptor {
+class StringAtDescriptor final
+    : public StaticCallInterfaceDescriptor<StringAtDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kPosition)
   // TODO(turbofan): Return untagged value here.
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::TaggedSigned(),  // result 1
                                     MachineType::AnyTagged(),     // kReceiver
                                     MachineType::IntPtr())        // kPosition
-  DECLARE_DESCRIPTOR(StringAtDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(StringAtDescriptor)
 };
 
-class StringAtAsStringDescriptor final : public CallInterfaceDescriptor {
+class StringAtAsStringDescriptor final
+    : public StaticCallInterfaceDescriptor<StringAtAsStringDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kPosition)
   // TODO(turbofan): Return untagged value here.
@@ -1379,10 +1424,11 @@ class StringAtAsStringDescriptor final : public CallInterfaceDescriptor {
       MachineType::TaggedPointer(),  // result string
       MachineType::AnyTagged(),      // kReceiver
       MachineType::IntPtr())         // kPosition
-  DECLARE_DESCRIPTOR(StringAtAsStringDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(StringAtAsStringDescriptor)
 };
 
-class StringSubstringDescriptor final : public CallInterfaceDescriptor {
+class StringSubstringDescriptor final
+    : public StaticCallInterfaceDescriptor<StringSubstringDescriptor> {
  public:
   DEFINE_PARAMETERS(kString, kFrom, kTo)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kString
@@ -1390,18 +1436,19 @@ class StringSubstringDescriptor final : public CallInterfaceDescriptor {
                          MachineType::IntPtr())     // kTo
 
   // TODO(turbofan): Allow builtins to return untagged values.
-  DECLARE_DESCRIPTOR(StringSubstringDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(StringSubstringDescriptor)
 };
 
-class CppBuiltinAdaptorDescriptor : public CallInterfaceDescriptor {
+class CppBuiltinAdaptorDescriptor
+    : public StaticJSCallInterfaceDescriptor<CppBuiltinAdaptorDescriptor> {
  public:
   DEFINE_JS_PARAMETERS(kCFunction)
   DEFINE_JS_PARAMETER_TYPES(MachineType::Pointer())
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(CppBuiltinAdaptorDescriptor,
-                                   CallInterfaceDescriptor, 1)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(CppBuiltinAdaptorDescriptor)
 };
 
-class CEntry1ArgvOnStackDescriptor : public CallInterfaceDescriptor {
+class CEntry1ArgvOnStackDescriptor
+    : public StaticCallInterfaceDescriptor<CEntry1ArgvOnStackDescriptor> {
  public:
   DEFINE_PARAMETERS(kArity,          // register argument
                     kCFunction,      // register argument
@@ -1415,10 +1462,13 @@ class CEntry1ArgvOnStackDescriptor : public CallInterfaceDescriptor {
                          MachineType::AnyTagged(),  // kArgcSmi
                          MachineType::AnyTagged(),  // kTargetCopy
                          MachineType::AnyTagged())  // kNewTargetCopy
-  DECLARE_DESCRIPTOR(CEntry1ArgvOnStackDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CEntry1ArgvOnStackDescriptor)
+
+  static constexpr auto registers();
 };
 
-class ApiCallbackDescriptor : public CallInterfaceDescriptor {
+class ApiCallbackDescriptor
+    : public StaticCallInterfaceDescriptor<ApiCallbackDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kApiFunctionAddress, kActualArgumentsCount,
                             kCallData, kHolder)
@@ -1428,44 +1478,56 @@ class ApiCallbackDescriptor : public CallInterfaceDescriptor {
                          MachineType::IntPtr(),     // kActualArgumentsCount
                          MachineType::AnyTagged(),  // kCallData
                          MachineType::AnyTagged())  // kHolder
-  DECLARE_DESCRIPTOR(ApiCallbackDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ApiCallbackDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class ApiGetterDescriptor : public CallInterfaceDescriptor {
+class ApiGetterDescriptor
+    : public StaticCallInterfaceDescriptor<ApiGetterDescriptor> {
  public:
   DEFINE_PARAMETERS(kReceiver, kHolder, kCallback)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kReceiver
                          MachineType::AnyTagged(),  // kHolder
                          MachineType::AnyTagged())  // kCallback
-  DECLARE_DESCRIPTOR(ApiGetterDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ApiGetterDescriptor)
 
-  static const Register ReceiverRegister();
-  static const Register HolderRegister();
-  static const Register CallbackRegister();
+  static constexpr inline Register ReceiverRegister();
+  static constexpr inline Register HolderRegister();
+  static constexpr inline Register CallbackRegister();
+
+  static constexpr auto registers();
 };
 
 // TODO(turbofan): We should probably rename this to GrowFastElementsDescriptor.
-class GrowArrayElementsDescriptor : public CallInterfaceDescriptor {
+class GrowArrayElementsDescriptor
+    : public StaticCallInterfaceDescriptor<GrowArrayElementsDescriptor> {
  public:
   DEFINE_PARAMETERS(kObject, kKey)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kObject
                          MachineType::AnyTagged())  // kKey
-  DECLARE_DESCRIPTOR(GrowArrayElementsDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(GrowArrayElementsDescriptor)
+
+  static constexpr inline Register ObjectRegister();
+  static constexpr inline Register KeyRegister();
 
-  static const Register ObjectRegister();
-  static const Register KeyRegister();
+  static constexpr auto registers();
 };
 
 class V8_EXPORT_PRIVATE TailCallOptimizedCodeSlotDescriptor
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          TailCallOptimizedCodeSlotDescriptor> {
  public:
   DEFINE_PARAMETERS(kOptimizedCodeEntry)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())  // kAccumulator
-  DECLARE_DESCRIPTOR(TailCallOptimizedCodeSlotDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(TailCallOptimizedCodeSlotDescriptor)
+
+  static constexpr auto registers();
 };
 
-class BaselineOutOfLinePrologueDescriptor : public CallInterfaceDescriptor {
+class BaselineOutOfLinePrologueDescriptor
+    : public StaticCallInterfaceDescriptor<
+          BaselineOutOfLinePrologueDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kCalleeContext, kClosure,
                                kJavaScriptCallArgCount, kStackFrameSize,
@@ -1477,32 +1539,31 @@ class BaselineOutOfLinePrologueDescriptor : public CallInterfaceDescriptor {
                          MachineType::Int32(),      // kStackFrameSize
                          MachineType::AnyTagged(),  // kJavaScriptCallNewTarget
                          MachineType::AnyTagged())  // kInterpreterBytecodeArray
-  DECLARE_DESCRIPTOR(BaselineOutOfLinePrologueDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(BaselineOutOfLinePrologueDescriptor)
 
-#if V8_TARGET_ARCH_IA32
-  static const bool kPassLastArgsOnStack = true;
-#else
-  static const bool kPassLastArgsOnStack = false;
-#endif
+  static constexpr inline auto registers();
 
-  // Pass bytecode array through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
+  // We pass the context manually, so we have one extra register.
+  static constexpr int kMaxRegisterParams =
+      StaticCallInterfaceDescriptor::kMaxRegisterParams + 1;
 };
 
-class BaselineLeaveFrameDescriptor : public CallInterfaceDescriptor {
+class BaselineLeaveFrameDescriptor
+    : public StaticCallInterfaceDescriptor<BaselineLeaveFrameDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kParamsSize, kWeight)
   DEFINE_PARAMETER_TYPES(MachineType::Int32(),  // kParamsSize
                          MachineType::Int32())  // kWeight
-  DECLARE_DESCRIPTOR(BaselineLeaveFrameDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(BaselineLeaveFrameDescriptor)
 
-  static const Register ParamsSizeRegister();
-  static const Register WeightRegister();
+  static constexpr inline Register ParamsSizeRegister();
+  static constexpr inline Register WeightRegister();
+
+  static constexpr inline auto registers();
 };
 
 class V8_EXPORT_PRIVATE InterpreterDispatchDescriptor
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<InterpreterDispatchDescriptor> {
  public:
   DEFINE_PARAMETERS(kAccumulator, kBytecodeOffset, kBytecodeArray,
                     kDispatchTable)
@@ -1510,21 +1571,27 @@ class V8_EXPORT_PRIVATE InterpreterDispatchDescriptor
                          MachineType::IntPtr(),     // kBytecodeOffset
                          MachineType::AnyTagged(),  // kBytecodeArray
                          MachineType::IntPtr())     // kDispatchTable
-  DECLARE_DESCRIPTOR(InterpreterDispatchDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(InterpreterDispatchDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class InterpreterPushArgsThenCallDescriptor : public CallInterfaceDescriptor {
+class InterpreterPushArgsThenCallDescriptor
+    : public StaticCallInterfaceDescriptor<
+          InterpreterPushArgsThenCallDescriptor> {
  public:
   DEFINE_PARAMETERS(kNumberOfArguments, kFirstArgument, kFunction)
   DEFINE_PARAMETER_TYPES(MachineType::Int32(),      // kNumberOfArguments
                          MachineType::Pointer(),    // kFirstArgument
                          MachineType::AnyTagged())  // kFunction
-  DECLARE_DESCRIPTOR(InterpreterPushArgsThenCallDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(InterpreterPushArgsThenCallDescriptor)
+
+  static constexpr inline auto registers();
 };
 
 class InterpreterPushArgsThenConstructDescriptor
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<
+          InterpreterPushArgsThenConstructDescriptor> {
  public:
   DEFINE_PARAMETERS(kNumberOfArguments, kFirstArgument, kConstructor,
                     kNewTarget, kFeedbackElement)
@@ -1533,20 +1600,13 @@ class InterpreterPushArgsThenConstructDescriptor
                          MachineType::AnyTagged(),  // kConstructor
                          MachineType::AnyTagged(),  // kNewTarget
                          MachineType::AnyTagged())  // kFeedbackElement
-  DECLARE_DESCRIPTOR(InterpreterPushArgsThenConstructDescriptor,
-                     CallInterfaceDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  static const bool kPassLastArgsOnStack = true;
-#else
-  static const bool kPassLastArgsOnStack = false;
-#endif
+  DECLARE_DESCRIPTOR(InterpreterPushArgsThenConstructDescriptor)
 
-  // Pass constructor, new target and feedback element through the stack.
-  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
+  static constexpr inline auto registers();
 };
 
-class InterpreterCEntry1Descriptor : public CallInterfaceDescriptor {
+class InterpreterCEntry1Descriptor
+    : public StaticCallInterfaceDescriptor<InterpreterCEntry1Descriptor> {
  public:
   DEFINE_RESULT_AND_PARAMETERS(1, kNumberOfArguments, kFirstArgument,
                                kFunctionEntry)
@@ -1554,10 +1614,13 @@ class InterpreterCEntry1Descriptor : public CallInterfaceDescriptor {
                                     MachineType::Int32(),  // kNumberOfArguments
                                     MachineType::Pointer(),  // kFirstArgument
                                     MachineType::Pointer())  // kFunctionEntry
-  DECLARE_DESCRIPTOR(InterpreterCEntry1Descriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(InterpreterCEntry1Descriptor)
+
+  static constexpr auto registers();
 };
 
-class InterpreterCEntry2Descriptor : public CallInterfaceDescriptor {
+class InterpreterCEntry2Descriptor
+    : public StaticCallInterfaceDescriptor<InterpreterCEntry2Descriptor> {
  public:
   DEFINE_RESULT_AND_PARAMETERS(2, kNumberOfArguments, kFirstArgument,
                                kFunctionEntry)
@@ -1566,10 +1629,13 @@ class InterpreterCEntry2Descriptor : public CallInterfaceDescriptor {
                                     MachineType::Int32(),  // kNumberOfArguments
                                     MachineType::Pointer(),  // kFirstArgument
                                     MachineType::Pointer())  // kFunctionEntry
-  DECLARE_DESCRIPTOR(InterpreterCEntry2Descriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(InterpreterCEntry2Descriptor)
+
+  static constexpr auto registers();
 };
 
-class ForInPrepareDescriptor : public CallInterfaceDescriptor {
+class ForInPrepareDescriptor
+    : public StaticCallInterfaceDescriptor<ForInPrepareDescriptor> {
  public:
   DEFINE_RESULT_AND_PARAMETERS(2, kEnumerator, kVectorIndex, kFeedbackVector)
   DEFINE_RESULT_AND_PARAMETER_TYPES(
@@ -1578,18 +1644,22 @@ class ForInPrepareDescriptor : public CallInterfaceDescriptor {
       MachineType::AnyTagged(),     // kEnumerator
       MachineType::TaggedSigned(),  // kVectorIndex
       MachineType::AnyTagged())     // kFeedbackVector
-  DECLARE_DESCRIPTOR(ForInPrepareDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ForInPrepareDescriptor)
 };
 
-class ResumeGeneratorDescriptor final : public CallInterfaceDescriptor {
+class ResumeGeneratorDescriptor final
+    : public StaticCallInterfaceDescriptor<ResumeGeneratorDescriptor> {
  public:
   DEFINE_PARAMETERS(kValue, kGenerator)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kValue
                          MachineType::AnyTagged())  // kGenerator
-  DECLARE_DESCRIPTOR(ResumeGeneratorDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ResumeGeneratorDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class ResumeGeneratorBaselineDescriptor final : public CallInterfaceDescriptor {
+class ResumeGeneratorBaselineDescriptor final
+    : public StaticCallInterfaceDescriptor<ResumeGeneratorBaselineDescriptor> {
  public:
   DEFINE_PARAMETERS(kGeneratorObject, kRegisterCount)
   DEFINE_RESULT_AND_PARAMETER_TYPES(
@@ -1597,11 +1667,11 @@ class ResumeGeneratorBaselineDescriptor final : public CallInterfaceDescriptor {
       MachineType::AnyTagged(),     // kGeneratorObject
       MachineType::IntPtr(),        // kRegisterCount
   )
-  DECLARE_DESCRIPTOR(ResumeGeneratorBaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(ResumeGeneratorBaselineDescriptor)
 };
 
 class SuspendGeneratorBaselineDescriptor final
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<SuspendGeneratorBaselineDescriptor> {
  public:
   DEFINE_PARAMETERS(kGeneratorObject, kSuspendId, kBytecodeOffset,
                     kRegisterCount)
@@ -1610,88 +1680,107 @@ class SuspendGeneratorBaselineDescriptor final
                          MachineType::IntPtr(),     // kBytecodeOffset
                          MachineType::IntPtr(),     // kRegisterCount
   )
-  DECLARE_DESCRIPTOR(SuspendGeneratorBaselineDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(SuspendGeneratorBaselineDescriptor)
 };
 
-class FrameDropperTrampolineDescriptor final : public CallInterfaceDescriptor {
+class FrameDropperTrampolineDescriptor final
+    : public StaticCallInterfaceDescriptor<FrameDropperTrampolineDescriptor> {
  public:
   DEFINE_PARAMETERS(kRestartFp)
   DEFINE_PARAMETER_TYPES(MachineType::Pointer())
-  DECLARE_DESCRIPTOR(FrameDropperTrampolineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(FrameDropperTrampolineDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class RunMicrotasksEntryDescriptor final : public CallInterfaceDescriptor {
+class RunMicrotasksEntryDescriptor final
+    : public StaticCallInterfaceDescriptor<RunMicrotasksEntryDescriptor> {
  public:
   DEFINE_PARAMETERS_ENTRY(kRootRegisterValue, kMicrotaskQueue)
   DEFINE_PARAMETER_TYPES(MachineType::Pointer(),  // kRootRegisterValue
                          MachineType::Pointer())  // kMicrotaskQueue
-  DECLARE_DESCRIPTOR(RunMicrotasksEntryDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(RunMicrotasksEntryDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class RunMicrotasksDescriptor final : public CallInterfaceDescriptor {
+class RunMicrotasksDescriptor final
+    : public StaticCallInterfaceDescriptor<RunMicrotasksDescriptor> {
  public:
   DEFINE_PARAMETERS(kMicrotaskQueue)
   DEFINE_PARAMETER_TYPES(MachineType::Pointer())
-  DECLARE_DESCRIPTOR(RunMicrotasksDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(RunMicrotasksDescriptor)
 
-  static Register MicrotaskQueueRegister();
+  static constexpr inline Register MicrotaskQueueRegister();
 };
 
-class WasmFloat32ToNumberDescriptor final : public CallInterfaceDescriptor {
+class WasmFloat32ToNumberDescriptor final
+    : public StaticCallInterfaceDescriptor<WasmFloat32ToNumberDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kValue)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged(),  // result
                                     MachineType::Float32())    // value
-  DECLARE_DESCRIPTOR(WasmFloat32ToNumberDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(WasmFloat32ToNumberDescriptor)
+
+#if V8_TARGET_ARCH_IA32
+  // We need a custom descriptor on ia32 to avoid using xmm0.
+  static constexpr inline auto registers();
+#endif
 };
 
-class WasmFloat64ToNumberDescriptor final : public CallInterfaceDescriptor {
+class WasmFloat64ToNumberDescriptor final
+    : public StaticCallInterfaceDescriptor<WasmFloat64ToNumberDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kValue)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged(),  // result
                                     MachineType::Float64())    // value
-  DECLARE_DESCRIPTOR(WasmFloat64ToNumberDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(WasmFloat64ToNumberDescriptor)
+
+#if V8_TARGET_ARCH_IA32
+  // We need a custom descriptor on ia32 to avoid using xmm0.
+  static constexpr inline auto registers();
+#endif
 };
 
 class V8_EXPORT_PRIVATE I64ToBigIntDescriptor final
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<I64ToBigIntDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::Int64())  // kArgument
-  DECLARE_DESCRIPTOR(I64ToBigIntDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(I64ToBigIntDescriptor)
 };
 
 // 32 bits version of the I64ToBigIntDescriptor call interface descriptor
 class V8_EXPORT_PRIVATE I32PairToBigIntDescriptor final
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<I32PairToBigIntDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kLow, kHigh)
   DEFINE_PARAMETER_TYPES(MachineType::Uint32(),  // kLow
                          MachineType::Uint32())  // kHigh
-  DECLARE_DESCRIPTOR(I32PairToBigIntDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(I32PairToBigIntDescriptor)
 };
 
 class V8_EXPORT_PRIVATE BigIntToI64Descriptor final
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<BigIntToI64Descriptor> {
  public:
   DEFINE_PARAMETERS(kArgument)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::Int64(),      // result 1
                                     MachineType::AnyTagged())  // kArgument
-  DECLARE_DESCRIPTOR(BigIntToI64Descriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(BigIntToI64Descriptor)
 };
 
 class V8_EXPORT_PRIVATE BigIntToI32PairDescriptor final
-    : public CallInterfaceDescriptor {
+    : public StaticCallInterfaceDescriptor<BigIntToI32PairDescriptor> {
  public:
   DEFINE_RESULT_AND_PARAMETERS(2, kArgument)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::Uint32(),     // result 1
                                     MachineType::Uint32(),     // result 2
                                     MachineType::AnyTagged())  // kArgument
-  DECLARE_DESCRIPTOR(BigIntToI32PairDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(BigIntToI32PairDescriptor)
 };
 
-class WasmI32AtomicWait32Descriptor final : public CallInterfaceDescriptor {
+class WasmI32AtomicWait32Descriptor final
+    : public StaticCallInterfaceDescriptor<WasmI32AtomicWait32Descriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kAddress, kExpectedValue, kTimeoutLow,
                                kTimeoutHigh)
@@ -1700,36 +1789,30 @@ class WasmI32AtomicWait32Descriptor final : public CallInterfaceDescriptor {
                                     MachineType::Int32(),   // kExpectedValue
                                     MachineType::Uint32(),  // kTimeoutLow
                                     MachineType::Uint32())  // kTimeoutHigh
-  DECLARE_DESCRIPTOR(WasmI32AtomicWait32Descriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(WasmI32AtomicWait32Descriptor)
 };
 
-class WasmI64AtomicWait32Descriptor final : public CallInterfaceDescriptor {
+class WasmI64AtomicWait32Descriptor final
+    : public StaticCallInterfaceDescriptor<WasmI64AtomicWait32Descriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kAddress, kExpectedValueLow, kExpectedValueHigh,
                                kTimeoutLow, kTimeoutHigh)
 
-  DEFINE_RESULT_AND_PARAMETER_TYPES_WITH_FLAG(
-      CallInterfaceDescriptorData::kNoStackScan,  // allow untagged stack params
-      MachineType::Uint32(),                      // result 1
-      MachineType::Uint32(),                      // kAddress
-      MachineType::Uint32(),                      // kExpectedValueLow
-      MachineType::Uint32(),                      // kExpectedValueHigh
-      MachineType::Uint32(),                      // kTimeoutLow
-      MachineType::Uint32())                      // kTimeoutHigh
+  static constexpr bool kNoStackScan = true;
 
-#if V8_TARGET_ARCH_IA32
-  static constexpr bool kPassLastArgOnStack = true;
-#else
-  static constexpr bool kPassLastArgOnStack = false;
-#endif
-
-  // Pass the last parameter through the stack.
-  static constexpr int kStackArgumentsCount = kPassLastArgOnStack ? 1 : 0;
+  DEFINE_RESULT_AND_PARAMETER_TYPES(
+      MachineType::Uint32(),  // result 1
+      MachineType::Uint32(),  // kAddress
+      MachineType::Uint32(),  // kExpectedValueLow
+      MachineType::Uint32(),  // kExpectedValueHigh
+      MachineType::Uint32(),  // kTimeoutLow
+      MachineType::Uint32())  // kTimeoutHigh
 
-  DECLARE_DESCRIPTOR(WasmI64AtomicWait32Descriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(WasmI64AtomicWait32Descriptor)
 };
 
-class CloneObjectWithVectorDescriptor final : public CallInterfaceDescriptor {
+class CloneObjectWithVectorDescriptor final
+    : public StaticCallInterfaceDescriptor<CloneObjectWithVectorDescriptor> {
  public:
   DEFINE_PARAMETERS(kSource, kFlags, kSlot, kVector)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::TaggedPointer(),  // result 1
@@ -1737,38 +1820,43 @@ class CloneObjectWithVectorDescriptor final : public CallInterfaceDescriptor {
                                     MachineType::TaggedSigned(),   // kFlags
                                     MachineType::TaggedSigned(),   // kSlot
                                     MachineType::AnyTagged())      // kVector
-  DECLARE_DESCRIPTOR(CloneObjectWithVectorDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CloneObjectWithVectorDescriptor)
 };
 
-class CloneObjectBaselineDescriptor final : public CallInterfaceDescriptor {
+class CloneObjectBaselineDescriptor final
+    : public StaticCallInterfaceDescriptor<CloneObjectBaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kSource, kFlags, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kSource
                          MachineType::TaggedSigned(),  // kFlags
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(CloneObjectBaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CloneObjectBaselineDescriptor)
 };
 
-class BinaryOp_WithFeedbackDescriptor : public CallInterfaceDescriptor {
+class BinaryOp_WithFeedbackDescriptor
+    : public StaticCallInterfaceDescriptor<BinaryOp_WithFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS(kLeft, kRight, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(BinaryOp_WithFeedbackDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(BinaryOp_WithFeedbackDescriptor)
 };
 
-class CallTrampoline_BaselineDescriptor : public CallInterfaceDescriptor {
+class CallTrampoline_BaselineDescriptor
+    : public StaticCallInterfaceDescriptor<CallTrampoline_BaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunction, kActualArgumentsCount, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunction
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(CallTrampoline_BaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallTrampoline_BaselineDescriptor)
 };
 
-class CallTrampoline_WithFeedbackDescriptor : public CallInterfaceDescriptor {
+class CallTrampoline_WithFeedbackDescriptor
+    : public StaticCallInterfaceDescriptor<
+          CallTrampoline_WithFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunction, kActualArgumentsCount, kSlot,
                             kFeedbackVector)
@@ -1776,69 +1864,75 @@ class CallTrampoline_WithFeedbackDescriptor : public CallInterfaceDescriptor {
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(CallTrampoline_WithFeedbackDescriptor,
-                     CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(CallTrampoline_WithFeedbackDescriptor)
 };
 
-class Compare_WithFeedbackDescriptor : public CallInterfaceDescriptor {
+class Compare_WithFeedbackDescriptor
+    : public StaticCallInterfaceDescriptor<Compare_WithFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS(kLeft, kRight, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(Compare_WithFeedbackDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(Compare_WithFeedbackDescriptor)
 };
 
-class Compare_BaselineDescriptor : public CallInterfaceDescriptor {
+class Compare_BaselineDescriptor
+    : public StaticCallInterfaceDescriptor<Compare_BaselineDescriptor> {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kLeft, kRight, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(Compare_BaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(Compare_BaselineDescriptor)
+
+  static constexpr inline auto registers();
 };
 
-class Construct_BaselineDescriptor : public CallInterfaceDescriptor {
+class Construct_BaselineDescriptor
+    : public StaticJSCallInterfaceDescriptor<Construct_BaselineDescriptor> {
  public:
   DEFINE_JS_PARAMETERS_NO_CONTEXT(kSlot)
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr())  // kSlot
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_BaselineDescriptor,
-                                   CallInterfaceDescriptor, 1)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_BaselineDescriptor)
 };
 
-class Construct_WithFeedbackDescriptor : public CallInterfaceDescriptor {
+class Construct_WithFeedbackDescriptor
+    : public StaticJSCallInterfaceDescriptor<Construct_WithFeedbackDescriptor> {
  public:
   // kSlot is passed in a register, kFeedbackVector on the stack.
   DEFINE_JS_PARAMETERS(kSlot, kFeedbackVector)
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr(),    // kSlot
                             MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_WithFeedbackDescriptor,
-                                   CallInterfaceDescriptor, 1)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_WithFeedbackDescriptor)
 };
 
-class UnaryOp_WithFeedbackDescriptor : public CallInterfaceDescriptor {
+class UnaryOp_WithFeedbackDescriptor
+    : public StaticCallInterfaceDescriptor<UnaryOp_WithFeedbackDescriptor> {
  public:
   DEFINE_PARAMETERS(kValue, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kValue
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(UnaryOp_WithFeedbackDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(UnaryOp_WithFeedbackDescriptor)
 };
 
-class UnaryOp_BaselineDescriptor : public CallInterfaceDescriptor {
+class UnaryOp_BaselineDescriptor
+    : public StaticCallInterfaceDescriptor<UnaryOp_BaselineDescriptor> {
  public:
   DEFINE_PARAMETERS(kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kValue
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(UnaryOp_BaselineDescriptor, CallInterfaceDescriptor)
+  DECLARE_DESCRIPTOR(UnaryOp_BaselineDescriptor)
 };
 
-#define DEFINE_TFS_BUILTIN_DESCRIPTOR(Name, ...)                          \
-  class Name##Descriptor : public CallInterfaceDescriptor {               \
-   public:                                                                \
-    DEFINE_PARAMETERS(__VA_ARGS__)                                        \
-    DECLARE_DEFAULT_DESCRIPTOR(Name##Descriptor, CallInterfaceDescriptor) \
+#define DEFINE_TFS_BUILTIN_DESCRIPTOR(Name, ...)                 \
+  class Name##Descriptor                                         \
+      : public StaticCallInterfaceDescriptor<Name##Descriptor> { \
+   public:                                                       \
+    DEFINE_PARAMETERS(__VA_ARGS__)                               \
+    DECLARE_DEFAULT_DESCRIPTOR(Name##Descriptor)                 \
   };
 BUILTIN_LIST_TFS(DEFINE_TFS_BUILTIN_DESCRIPTOR)
 #undef DEFINE_TFS_BUILTIN_DESCRIPTOR
@@ -1852,11 +1946,12 @@ BUILTIN_LIST_TFS(DEFINE_TFS_BUILTIN_DESCRIPTOR)
 #undef DECLARE_DESCRIPTOR_WITH_BASE
 #undef DECLARE_DESCRIPTOR
 #undef DECLARE_JS_COMPATIBLE_DESCRIPTOR
-#undef DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS
 #undef DEFINE_RESULT_AND_PARAMETERS
+#undef DEFINE_PARAMETERS_ENTRY
 #undef DEFINE_PARAMETERS
 #undef DEFINE_PARAMETERS_VARARGS
 #undef DEFINE_PARAMETERS_NO_CONTEXT
+#undef DEFINE_RESULT_AND_PARAMETERS_NO_CONTEXT
 #undef DEFINE_RESULT_AND_PARAMETER_TYPES
 #undef DEFINE_PARAMETER_TYPES
 #undef DEFINE_JS_PARAMETERS
diff --git a/src/codegen/register-arch.h b/src/codegen/register-arch.h
index 3936ee80cc2..eb4cdb8789b 100644
--- a/src/codegen/register-arch.h
+++ b/src/codegen/register-arch.h
@@ -41,6 +41,27 @@ constexpr bool ShouldPadArguments(int argument_count) {
   return ArgumentPaddingSlots(argument_count) != 0;
 }
 
+#ifdef DEBUG
+struct CountIfValidRegisterFunctor {
+  template <typename RegType>
+  constexpr int operator()(int count, RegType reg) const {
+    return count + (reg.is_valid() ? 1 : 0);
+  }
+};
+
+template <typename RegType, typename... RegTypes,
+          // All arguments must be either Register or DoubleRegister.
+          typename = typename std::enable_if<
+              base::is_same<Register, RegType, RegTypes...>::value ||
+              base::is_same<DoubleRegister, RegType, RegTypes...>::value>::type>
+inline constexpr bool AreAliased(RegType first_reg, RegTypes... regs) {
+  int num_different_regs = NumRegs(RegType::ListOf(first_reg, regs...));
+  int num_given_regs =
+      base::fold(CountIfValidRegisterFunctor{}, 0, first_reg, regs...);
+  return num_different_regs < num_given_regs;
+}
+#endif
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/codegen/turbo-assembler.h b/src/codegen/turbo-assembler.h
index ee1eae49c48..98267fdcfa5 100644
--- a/src/codegen/turbo-assembler.h
+++ b/src/codegen/turbo-assembler.h
@@ -165,27 +165,6 @@ class V8_NODISCARD HardAbortScope {
   bool old_value_;
 };
 
-#ifdef DEBUG
-struct CountIfValidRegisterFunctor {
-  template <typename RegType>
-  constexpr int operator()(int count, RegType reg) const {
-    return count + (reg.is_valid() ? 1 : 0);
-  }
-};
-
-template <typename RegType, typename... RegTypes,
-          // All arguments must be either Register or DoubleRegister.
-          typename = typename std::enable_if<
-              base::is_same<Register, RegType, RegTypes...>::value ||
-              base::is_same<DoubleRegister, RegType, RegTypes...>::value>::type>
-inline bool AreAliased(RegType first_reg, RegTypes... regs) {
-  int num_different_regs = NumRegs(RegType::ListOf(first_reg, regs...));
-  int num_given_regs =
-      base::fold(CountIfValidRegisterFunctor{}, 0, first_reg, regs...);
-  return num_different_regs < num_given_regs;
-}
-#endif
-
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/codegen/x64/interface-descriptors-x64-inl.h b/src/codegen/x64/interface-descriptors-x64-inl.h
new file mode 100644
index 00000000000..e5cc5df4f20
--- /dev/null
+++ b/src/codegen/x64/interface-descriptors-x64-inl.h
@@ -0,0 +1,263 @@
+// Copyright 2021 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef V8_CODEGEN_X64_INTERFACE_DESCRIPTORS_X64_INL_H_
+#define V8_CODEGEN_X64_INTERFACE_DESCRIPTORS_X64_INL_H_
+
+#if V8_TARGET_ARCH_X64
+
+#include "src/codegen/interface-descriptors.h"
+
+namespace v8 {
+namespace internal {
+
+constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
+  auto registers = RegisterArray(rax, rbx, rcx, rdx, rdi);
+  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
+  return registers;
+}
+
+// static
+constexpr auto RecordWriteDescriptor::registers() {
+  return RegisterArray(arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4,
+                       kReturnRegister0);
+}
+
+// static
+constexpr auto DynamicCheckMapsDescriptor::registers() {
+  return RegisterArray(kReturnRegister0, arg_reg_1, arg_reg_2, arg_reg_3,
+                       kRuntimeCallFunctionRegister, kContextRegister);
+}
+
+// static
+constexpr auto EphemeronKeyBarrierDescriptor::registers() {
+  return RegisterArray(arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4,
+                       kReturnRegister0);
+}
+
+// static
+constexpr Register LoadDescriptor::ReceiverRegister() { return rdx; }
+// static
+constexpr Register LoadDescriptor::NameRegister() { return rcx; }
+// static
+constexpr Register LoadDescriptor::SlotRegister() { return rax; }
+
+// static
+constexpr Register LoadWithVectorDescriptor::VectorRegister() { return rbx; }
+
+// static
+constexpr Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return rdi;
+}
+
+// static
+constexpr Register StoreDescriptor::ReceiverRegister() { return rdx; }
+// static
+constexpr Register StoreDescriptor::NameRegister() { return rcx; }
+// static
+constexpr Register StoreDescriptor::ValueRegister() { return rax; }
+// static
+constexpr Register StoreDescriptor::SlotRegister() { return rdi; }
+
+// static
+constexpr Register StoreWithVectorDescriptor::VectorRegister() { return rbx; }
+
+// static
+constexpr Register StoreTransitionDescriptor::MapRegister() { return r11; }
+
+// static
+constexpr Register ApiGetterDescriptor::HolderRegister() { return rcx; }
+// static
+constexpr Register ApiGetterDescriptor::CallbackRegister() { return rbx; }
+
+// static
+constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return rax; }
+// static
+constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return rbx; }
+
+// static
+constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
+  return rbx;
+}
+// static
+constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() {
+  return rcx;
+}
+
+// static
+constexpr Register TypeConversionDescriptor::ArgumentRegister() { return rax; }
+
+// static
+constexpr auto TypeofDescriptor::registers() { return RegisterArray(rbx); }
+
+// static
+constexpr auto CallTrampolineDescriptor::registers() {
+  // rax : number of arguments
+  // rdi : the target to call
+  return RegisterArray(rdi, rax);
+}
+
+// static
+constexpr auto CallVarargsDescriptor::registers() {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rcx : arguments list length (untagged)
+  // rbx : arguments list (FixedArray)
+  return RegisterArray(rdi, rax, rcx, rbx);
+}
+
+// static
+constexpr auto CallForwardVarargsDescriptor::registers() {
+  // rax : number of arguments
+  // rcx : start index (to support rest parameters)
+  // rdi : the target to call
+  return RegisterArray(rdi, rax, rcx);
+}
+
+// static
+constexpr auto CallFunctionTemplateDescriptor::registers() {
+  // rdx: the function template info
+  // rcx: number of arguments (on the stack, not including receiver)
+  return RegisterArray(rdx, rcx);
+}
+
+// static
+constexpr auto CallWithSpreadDescriptor::registers() {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rbx : the object to spread
+  return RegisterArray(rdi, rax, rbx);
+}
+
+// static
+constexpr auto CallWithArrayLikeDescriptor::registers() {
+  // rdi : the target to call
+  // rbx : the arguments list
+  return RegisterArray(rdi, rbx);
+}
+
+// static
+constexpr auto ConstructVarargsDescriptor::registers() {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rdx : the new target
+  // rcx : arguments list length (untagged)
+  // rbx : arguments list (FixedArray)
+  return RegisterArray(rdi, rdx, rax, rcx, rbx);
+}
+
+// static
+constexpr auto ConstructForwardVarargsDescriptor::registers() {
+  // rax : number of arguments
+  // rdx : the new target
+  // rcx : start index (to support rest parameters)
+  // rdi : the target to call
+  return RegisterArray(rdi, rdx, rax, rcx);
+}
+
+// static
+constexpr auto ConstructWithSpreadDescriptor::registers() {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rdx : the new target
+  // rbx : the object to spread
+  return RegisterArray(rdi, rdx, rax, rbx);
+}
+
+// static
+constexpr auto ConstructWithArrayLikeDescriptor::registers() {
+  // rdi : the target to call
+  // rdx : the new target
+  // rbx : the arguments list
+  return RegisterArray(rdi, rdx, rbx);
+}
+
+// static
+constexpr auto ConstructStubDescriptor::registers() {
+  // rax : number of arguments
+  // rdx : the new target
+  // rdi : the target to call
+  // rbx : allocation site or undefined
+  return RegisterArray(rdi, rdx, rax, rbx);
+}
+
+// static
+constexpr auto AbortDescriptor::registers() { return RegisterArray(rdx); }
+
+// static
+constexpr auto CompareDescriptor::registers() {
+  return RegisterArray(rdx, rax);
+}
+
+// static
+constexpr auto BinaryOpDescriptor::registers() {
+  return RegisterArray(rdx, rax);
+}
+
+// static
+constexpr auto Compare_BaselineDescriptor::registers() {
+  return RegisterArray(rdx, rax, rbx);
+}
+
+// static
+constexpr auto BinaryOp_BaselineDescriptor::registers() {
+  return RegisterArray(rdx, rax, rbx);
+}
+
+// static
+constexpr auto ApiCallbackDescriptor::registers() {
+  return RegisterArray(rdx,   // api function address
+                       rcx,   // argument count (not including receiver)
+                       rbx,   // call data
+                       rdi);  // holder
+}
+
+// static
+constexpr auto InterpreterDispatchDescriptor::registers() {
+  return RegisterArray(
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
+}
+
+// static
+constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
+  return RegisterArray(rax,   // argument count (not including receiver)
+                       rbx,   // address of first argument
+                       rdi);  // the target callable to be call
+}
+
+// static
+constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
+  return RegisterArray(
+      rax,   // argument count (not including receiver)
+      rcx,   // address of first argument
+      rdi,   // constructor to call
+      rdx,   // new target
+      rbx);  // allocation site feedback if available, undefined otherwise
+}
+
+// static
+constexpr auto ResumeGeneratorDescriptor::registers() {
+  return RegisterArray(
+      rax,   // the value to pass to the generator
+      rdx);  // the JSGeneratorObject / JSAsyncGeneratorObject to resume
+}
+
+// static
+constexpr auto FrameDropperTrampolineDescriptor::registers() {
+  return RegisterArray(rbx);  // loaded new FP
+}
+
+// static
+constexpr auto RunMicrotasksEntryDescriptor::registers() {
+  return RegisterArray(arg_reg_1, arg_reg_2);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_X64
+
+#endif  // V8_CODEGEN_X64_INTERFACE_DESCRIPTORS_X64_INL_H_
diff --git a/src/codegen/x64/interface-descriptors-x64.cc b/src/codegen/x64/interface-descriptors-x64.cc
deleted file mode 100644
index 4029b56d2b3..00000000000
--- a/src/codegen/x64/interface-descriptors-x64.cc
+++ /dev/null
@@ -1,309 +0,0 @@
-// Copyright 2012 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#if V8_TARGET_ARCH_X64
-
-#include "src/codegen/interface-descriptors.h"
-
-#include "src/execution/frames.h"
-
-namespace v8 {
-namespace internal {
-
-const Register CallInterfaceDescriptor::ContextRegister() { return rsi; }
-
-void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
-    CallInterfaceDescriptorData* data, int register_parameter_count) {
-  const Register default_stub_registers[] = {rax, rbx, rcx, rdx, rdi};
-  CHECK_LE(static_cast<size_t>(register_parameter_count),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(register_parameter_count,
-                                   default_stub_registers);
-}
-
-void RecordWriteDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  const Register default_stub_registers[] = {arg_reg_1, arg_reg_2, arg_reg_3,
-                                             arg_reg_4, kReturnRegister0};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register default_stub_registers[] = {kReturnRegister0,
-                                       arg_reg_1,
-                                       arg_reg_2,
-                                       arg_reg_3,
-                                       kRuntimeCallFunctionRegister,
-                                       kContextRegister};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  const Register default_stub_registers[] = {arg_reg_1, arg_reg_2, arg_reg_3,
-                                             arg_reg_4, kReturnRegister0};
-
-  data->RestrictAllocatableRegisters(default_stub_registers,
-                                     arraysize(default_stub_registers));
-
-  CHECK_LE(static_cast<size_t>(kParameterCount),
-           arraysize(default_stub_registers));
-  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
-}
-
-const Register LoadDescriptor::ReceiverRegister() { return rdx; }
-const Register LoadDescriptor::NameRegister() { return rcx; }
-const Register LoadDescriptor::SlotRegister() { return rax; }
-
-const Register LoadWithVectorDescriptor::VectorRegister() { return rbx; }
-
-const Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return rdi;
-}
-
-const Register StoreDescriptor::ReceiverRegister() { return rdx; }
-const Register StoreDescriptor::NameRegister() { return rcx; }
-const Register StoreDescriptor::ValueRegister() { return rax; }
-const Register StoreDescriptor::SlotRegister() { return rdi; }
-
-const Register StoreWithVectorDescriptor::VectorRegister() { return rbx; }
-
-const Register StoreTransitionDescriptor::SlotRegister() { return rdi; }
-const Register StoreTransitionDescriptor::VectorRegister() { return rbx; }
-const Register StoreTransitionDescriptor::MapRegister() { return r11; }
-
-const Register ApiGetterDescriptor::HolderRegister() { return rcx; }
-const Register ApiGetterDescriptor::CallbackRegister() { return rbx; }
-
-const Register GrowArrayElementsDescriptor::ObjectRegister() { return rax; }
-const Register GrowArrayElementsDescriptor::KeyRegister() { return rbx; }
-
-const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
-  return rbx;
-}
-const Register BaselineLeaveFrameDescriptor::WeightRegister() { return rcx; }
-
-void TypeofDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-// static
-const Register TypeConversionDescriptor::ArgumentRegister() { return rax; }
-
-void CallTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments
-  // rdi : the target to call
-  Register registers[] = {rdi, rax};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rcx : arguments list length (untagged)
-  // rbx : arguments list (FixedArray)
-  Register registers[] = {rdi, rax, rcx, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments
-  // rcx : start index (to support rest parameters)
-  // rdi : the target to call
-  Register registers[] = {rdi, rax, rcx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rdx: the function template info
-  // rcx: number of arguments (on the stack, not including receiver)
-  Register registers[] = {rdx, rcx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rbx : the object to spread
-  Register registers[] = {rdi, rax, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rdi : the target to call
-  // rbx : the arguments list
-  Register registers[] = {rdi, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rdx : the new target
-  // rcx : arguments list length (untagged)
-  // rbx : arguments list (FixedArray)
-  Register registers[] = {rdi, rdx, rax, rcx, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments
-  // rdx : the new target
-  // rcx : start index (to support rest parameters)
-  // rdi : the target to call
-  Register registers[] = {rdi, rdx, rax, rcx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rdx : the new target
-  // rbx : the object to spread
-  Register registers[] = {rdi, rdx, rax, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rdi : the target to call
-  // rdx : the new target
-  // rbx : the arguments list
-  Register registers[] = {rdi, rdx, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ConstructStubDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  // rax : number of arguments
-  // rdx : the new target
-  // rdi : the target to call
-  // rbx : allocation site or undefined
-  Register registers[] = {rdi, rdx, rax, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void AbortDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {rdx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void CompareDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {rdx, rax};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void Compare_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {rdx, rax, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOpDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {rdx, rax};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {rdx, rax, rbx};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ApiCallbackDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      rdx,  // api function address
-      rcx,  // argument count (not including receiver)
-      rbx,  // call data
-      rdi,  // holder
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterDispatchDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      rax,  // argument count (not including receiver)
-      rbx,  // address of first argument
-      rdi   // the target callable to be call
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      rax,  // argument count (not including receiver)
-      rcx,  // address of first argument
-      rdi,  // constructor to call
-      rdx,  // new target
-      rbx,  // allocation site feedback if available, undefined otherwise
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void ResumeGeneratorDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      rax,  // the value to pass to the generator
-      rdx   // the JSGeneratorObject / JSAsyncGeneratorObject to resume
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {
-      rbx,  // loaded new FP
-  };
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
-    CallInterfaceDescriptorData* data) {
-  Register registers[] = {arg_reg_1, arg_reg_2};
-  data->InitializePlatformSpecific(arraysize(registers), registers);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_X64
diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index e3d00e3489f..4992f0b5fb4 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -12,6 +12,7 @@
 #include "src/codegen/code-factory.h"
 #include "src/codegen/cpu-features.h"
 #include "src/codegen/external-reference-table.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/register-configuration.h"
 #include "src/codegen/string-constants.h"
diff --git a/src/compiler/backend/instruction-selector.cc b/src/compiler/backend/instruction-selector.cc
index 5a383288321..ad59f639443 100644
--- a/src/compiler/backend/instruction-selector.cc
+++ b/src/compiler/backend/instruction-selector.cc
@@ -9,6 +9,7 @@
 #include "src/base/iterator.h"
 #include "src/base/platform/wrappers.h"
 #include "src/codegen/assembler-inl.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/tick-counter.h"
 #include "src/compiler/backend/instruction-selector-impl.h"
 #include "src/compiler/compiler-source-position-table.h"
diff --git a/src/compiler/code-assembler.cc b/src/compiler/code-assembler.cc
index a2cb595a5ea..8ff1777366d 100644
--- a/src/compiler/code-assembler.cc
+++ b/src/compiler/code-assembler.cc
@@ -8,7 +8,7 @@
 
 #include "src/base/bits.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/compiler/backend/instruction-selector.h"
diff --git a/src/compiler/effect-control-linearizer.cc b/src/compiler/effect-control-linearizer.cc
index dedf68e93c2..4780bec2b88 100644
--- a/src/compiler/effect-control-linearizer.cc
+++ b/src/compiler/effect-control-linearizer.cc
@@ -7,6 +7,7 @@
 #include "include/v8-fast-api-calls.h"
 #include "src/base/bits.h"
 #include "src/codegen/code-factory.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/common/ptr-compr-inl.h"
 #include "src/compiler/access-builder.h"
diff --git a/src/compiler/js-generic-lowering.cc b/src/compiler/js-generic-lowering.cc
index 71a0d43a415..935e4460ce9 100644
--- a/src/compiler/js-generic-lowering.cc
+++ b/src/compiler/js-generic-lowering.cc
@@ -7,6 +7,7 @@
 #include "src/ast/ast.h"
 #include "src/builtins/builtins-constructor.h"
 #include "src/codegen/code-factory.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/compiler/access-builder.h"
 #include "src/compiler/common-operator.h"
 #include "src/compiler/js-graph.h"
diff --git a/src/compiler/js-typed-lowering.cc b/src/compiler/js-typed-lowering.cc
index 008aacdb392..2525b41e8cf 100644
--- a/src/compiler/js-typed-lowering.cc
+++ b/src/compiler/js-typed-lowering.cc
@@ -7,6 +7,7 @@
 #include "src/ast/modules.h"
 #include "src/builtins/builtins-utils.h"
 #include "src/codegen/code-factory.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/compiler/access-builder.h"
 #include "src/compiler/allocation-builder.h"
 #include "src/compiler/graph-assembler.h"
diff --git a/src/compiler/memory-lowering.cc b/src/compiler/memory-lowering.cc
index 2014fd228d5..f27aa9391f2 100644
--- a/src/compiler/memory-lowering.cc
+++ b/src/compiler/memory-lowering.cc
@@ -4,7 +4,7 @@
 
 #include "src/compiler/memory-lowering.h"
 
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/common/external-pointer.h"
 #include "src/compiler/access-builder.h"
 #include "src/compiler/js-graph.h"
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 5669c353554..42e8c76bbc0 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -16,7 +16,7 @@
 #include "src/codegen/assembler.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/compiler.h"
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/optimized-compilation-info.h"
 #include "src/compiler/backend/code-generator.h"
diff --git a/src/ic/accessor-assembler.cc b/src/ic/accessor-assembler.cc
index 7ef16febd88..787c3236e7b 100644
--- a/src/ic/accessor-assembler.cc
+++ b/src/ic/accessor-assembler.cc
@@ -8,6 +8,7 @@
 #include "src/base/optional.h"
 #include "src/builtins/builtins-constructor-gen.h"
 #include "src/codegen/code-factory.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/ic/handler-configuration.h"
 #include "src/ic/ic.h"
 #include "src/ic/keyed-store-generic.h"
@@ -1507,7 +1508,6 @@ void AccessorAssembler::HandleStoreAccessor(const StoreICParameters* p,
       LoadObjectField(accessor_pair, AccessorPair::kSetterOffset);
   CSA_ASSERT(this, Word32BinaryNot(IsTheHole(setter)));
 
-  Callable callable = CodeFactory::Call(isolate());
   Return(Call(p->context(), setter, p->receiver(), p->value()));
 }
 
diff --git a/src/interpreter/interpreter-assembler.cc b/src/interpreter/interpreter-assembler.cc
index df5b525877d..730e9ee19bd 100644
--- a/src/interpreter/interpreter-assembler.cc
+++ b/src/interpreter/interpreter-assembler.cc
@@ -8,7 +8,7 @@
 #include <ostream>
 
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/execution/frames.h"
 #include "src/interpreter/bytecodes.h"
diff --git a/src/snapshot/embedded/embedded-data.cc b/src/snapshot/embedded/embedded-data.cc
index be7a9dd33c9..2fac12b6f9b 100644
--- a/src/snapshot/embedded/embedded-data.cc
+++ b/src/snapshot/embedded/embedded-data.cc
@@ -6,6 +6,7 @@
 
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/callable.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/objects/objects-inl.h"
 #include "src/snapshot/snapshot-utils.h"
 #include "src/snapshot/snapshot.h"
@@ -187,14 +188,15 @@ bool BuiltinAliasesOffHeapTrampolineRegister(Isolate* isolate, Code code) {
       return false;
   }
 
+  if (CallInterfaceDescriptor::ContextRegister() ==
+      kOffHeapTrampolineRegister) {
+    return true;
+  }
+
   Callable callable = Builtins::CallableFor(
       isolate, static_cast<Builtins::Name>(code.builtin_index()));
   CallInterfaceDescriptor descriptor = callable.descriptor();
 
-  if (descriptor.ContextRegister() == kOffHeapTrampolineRegister) {
-    return true;
-  }
-
   for (int i = 0; i < descriptor.GetRegisterParameterCount(); i++) {
     Register reg = descriptor.GetRegisterParameter(i);
     if (reg == kOffHeapTrampolineRegister) return true;
diff --git a/src/torque/implementation-visitor.cc b/src/torque/implementation-visitor.cc
index 7c4b6a80cc9..d1bd8226798 100644
--- a/src/torque/implementation-visitor.cc
+++ b/src/torque/implementation-visitor.cc
@@ -658,8 +658,8 @@ void ImplementationVisitor::Visit(Builtin* builtin) {
   } else {
     DCHECK(builtin->IsStub());
 
-    bool has_context_parameter = signature.HasContextParameter();
     for (size_t i = 0; i < signature.parameter_names.size(); ++i) {
+      const std::string& parameter_name = signature.parameter_names[i]->value;
       const Type* type = signature.types()[i];
       const bool mark_as_used = signature.implicit_count > i;
       std::string var = AddParameter(i, builtin, &parameters, &parameter_types,
@@ -667,14 +667,8 @@ void ImplementationVisitor::Visit(Builtin* builtin) {
       csa_ccfile() << "  " << type->GetGeneratedTypeName() << " " << var
                    << " = "
                    << "UncheckedParameter<" << type->GetGeneratedTNodeTypeName()
-                   << ">(";
-      if (i == 0 && has_context_parameter) {
-        csa_ccfile() << "Descriptor::kContext";
-      } else {
-        csa_ccfile() << "Descriptor::ParameterIndex<"
-                     << (has_context_parameter ? i - 1 : i) << ">()";
-      }
-      csa_ccfile() << ");\n";
+                   << ">(Descriptor::k" << CamelifyString(parameter_name)
+                   << ");\n";
       csa_ccfile() << "  USE(" << var << ");\n";
     }
   }
@@ -3437,40 +3431,40 @@ void ImplementationVisitor::GenerateBuiltinDefinitionsAndInterfaceDescriptors(
         std::string descriptor_name = builtin->ExternalName() + "Descriptor";
         bool has_context_parameter = builtin->signature().HasContextParameter();
         size_t kFirstNonContextParameter = has_context_parameter ? 1 : 0;
-        size_t parameter_count =
-            builtin->parameter_names().size() - kFirstNonContextParameter;
         TypeVector return_types = LowerType(builtin->signature().return_type);
 
-        interface_descriptors
-            << "class " << descriptor_name
-            << " : public TorqueInterfaceDescriptor<" << return_types.size()
-            << ", " << parameter_count << ", "
-            << (has_context_parameter ? "true" : "false") << "> {\n";
-        interface_descriptors << "  DECLARE_DESCRIPTOR_WITH_BASE("
-                              << descriptor_name
-                              << ", TorqueInterfaceDescriptor)\n";
-
-        interface_descriptors
-            << "  std::vector<MachineType> ReturnType() override {\n";
-        interface_descriptors << "    return {{";
+        interface_descriptors << "class " << descriptor_name
+                              << " : public StaticCallInterfaceDescriptor<"
+                              << descriptor_name << "> {\n";
+
+        interface_descriptors << " public:\n";
+
+        if (has_context_parameter) {
+          interface_descriptors << "  DEFINE_RESULT_AND_PARAMETERS(";
+        } else {
+          interface_descriptors << "  DEFINE_RESULT_AND_PARAMETERS_NO_CONTEXT(";
+        }
+        interface_descriptors << return_types.size();
+        for (size_t i = kFirstNonContextParameter;
+             i < builtin->parameter_names().size(); ++i) {
+          Identifier* parameter = builtin->parameter_names()[i];
+          interface_descriptors << ", k" << CamelifyString(parameter->value);
+        }
+        interface_descriptors << ")\n";
+
+        interface_descriptors << "  DEFINE_RESULT_AND_PARAMETER_TYPES(";
         PrintCommaSeparatedList(interface_descriptors, return_types,
                                 MachineTypeString);
-        interface_descriptors << "}};\n";
-        interface_descriptors << "  }\n";
-
-        interface_descriptors << "  std::array<MachineType, " << parameter_count
-                              << "> ParameterTypes() override {\n";
-        interface_descriptors << "    return {";
         for (size_t i = kFirstNonContextParameter;
              i < builtin->parameter_names().size(); ++i) {
-          bool last = i + 1 == builtin->parameter_names().size();
           const Type* type = builtin->signature().parameter_types.types[i];
-          interface_descriptors << MachineTypeString(type)
-                                << (last ? "" : ", ");
+          interface_descriptors << ", " << MachineTypeString(type);
         }
-        interface_descriptors << "};\n";
+        interface_descriptors << ")\n";
+
+        interface_descriptors << "  DECLARE_DEFAULT_DESCRIPTOR("
+                              << descriptor_name << ")\n";
 
-        interface_descriptors << "  }\n";
         interface_descriptors << "};\n\n";
       } else {
         builtin_definitions << "TFJ(" << builtin->ExternalName();
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index 590f807a9df..f92b4dd6d4c 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -10,7 +10,7 @@
 #include "src/codegen/assembler-inl.h"
 // TODO(clemensb): Remove dependences on compiler stuff.
 #include "src/codegen/external-reference.h"
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/compiler/linkage.h"
diff --git a/test/cctest/test-code-stub-assembler.cc b/test/cctest/test-code-stub-assembler.cc
index 67aafa8709d..326e08fb2e7 100644
--- a/test/cctest/test-code-stub-assembler.cc
+++ b/test/cctest/test-code-stub-assembler.cc
@@ -11,6 +11,7 @@
 #include "src/builtins/builtins-string-gen.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/code-stub-assembler.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/compiler/node.h"
 #include "src/debug/debug.h"
 #include "src/execution/isolate.h"
@@ -2024,7 +2025,7 @@ TEST(PopAndReturnFromTFCBuiltinWithStackParameters) {
   // least one argument passed on stack.
   using Descriptor = FlatMapIntoArrayDescriptor;
   Descriptor descriptor;
-  CHECK_LT(0, descriptor.GetStackParameterCount());
+  CHECK_LT(0, Descriptor::GetStackParameterCount());
 
   CodeAssemblerTester asm_tester(isolate, Descriptor());
   {
diff --git a/test/unittests/codegen/code-stub-assembler-unittest.cc b/test/unittests/codegen/code-stub-assembler-unittest.cc
index 6137b3425a8..121190bdb8c 100644
--- a/test/unittests/codegen/code-stub-assembler-unittest.cc
+++ b/test/unittests/codegen/code-stub-assembler-unittest.cc
@@ -5,7 +5,7 @@
 #include "test/unittests/codegen/code-stub-assembler-unittest.h"
 
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/compiler/node.h"
 #include "src/execution/isolate.h"
 #include "src/objects/objects-inl.h"
diff --git a/test/unittests/compiler/int64-lowering-unittest.cc b/test/unittests/compiler/int64-lowering-unittest.cc
index 8eafd4fe15a..d8890b866cb 100644
--- a/test/unittests/compiler/int64-lowering-unittest.cc
+++ b/test/unittests/compiler/int64-lowering-unittest.cc
@@ -4,7 +4,7 @@
 
 #include "src/compiler/int64-lowering.h"
 
-#include "src/codegen/interface-descriptors.h"
+#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/signature.h"
 #include "src/compiler/common-operator.h"
@@ -1063,20 +1063,20 @@ TEST_F(Int64LoweringTest, WasmBigIntSpecialCaseBigIntToI64) {
 
   CallDescriptor* bigint_to_i64_call_descriptor =
       Linkage::GetStubCallDescriptor(
-          zone(),                   // zone
-          BigIntToI64Descriptor(),  // descriptor
-          BigIntToI64Descriptor()
-              .GetStackParameterCount(),   // stack parameter count
-          CallDescriptor::kNoFlags,        // flags
-          Operator::kNoProperties,         // properties
-          StubCallMode::kCallCodeObject);  // stub call mode
+          zone(),                                           // zone
+          BigIntToI64Descriptor(),                          // descriptor
+          BigIntToI64Descriptor::GetStackParameterCount(),  // stack parameter
+                                                            // count
+          CallDescriptor::kNoFlags,                         // flags
+          Operator::kNoProperties,                          // properties
+          StubCallMode::kCallCodeObject);                   // stub call mode
 
   CallDescriptor* bigint_to_i32_pair_call_descriptor =
       Linkage::GetStubCallDescriptor(
           zone(),                       // zone
           BigIntToI32PairDescriptor(),  // descriptor
-          BigIntToI32PairDescriptor()
-              .GetStackParameterCount(),   // stack parameter count
+          BigIntToI32PairDescriptor::
+              GetStackParameterCount(),    // stack parameter count
           CallDescriptor::kNoFlags,        // flags
           Operator::kNoProperties,         // properties
           StubCallMode::kCallCodeObject);  // stub call mode
@@ -1109,20 +1109,20 @@ TEST_F(Int64LoweringTest, WasmBigIntSpecialCaseI64ToBigInt) {
 
   CallDescriptor* i64_to_bigint_call_descriptor =
       Linkage::GetStubCallDescriptor(
-          zone(),                   // zone
-          I64ToBigIntDescriptor(),  // descriptor
-          I64ToBigIntDescriptor()
-              .GetStackParameterCount(),   // stack parameter count
-          CallDescriptor::kNoFlags,        // flags
-          Operator::kNoProperties,         // properties
-          StubCallMode::kCallCodeObject);  // stub call mode
+          zone(),                                           // zone
+          I64ToBigIntDescriptor(),                          // descriptor
+          I64ToBigIntDescriptor::GetStackParameterCount(),  // stack parameter
+                                                            // count
+          CallDescriptor::kNoFlags,                         // flags
+          Operator::kNoProperties,                          // properties
+          StubCallMode::kCallCodeObject);                   // stub call mode
 
   CallDescriptor* i32_pair_to_bigint_call_descriptor =
       Linkage::GetStubCallDescriptor(
           zone(),                       // zone
           I32PairToBigIntDescriptor(),  // descriptor
-          I32PairToBigIntDescriptor()
-              .GetStackParameterCount(),   // stack parameter count
+          I32PairToBigIntDescriptor::
+              GetStackParameterCount(),    // stack parameter count
           CallDescriptor::kNoFlags,        // flags
           Operator::kNoProperties,         // properties
           StubCallMode::kCallCodeObject);  // stub call mode
-- 
2.35.1


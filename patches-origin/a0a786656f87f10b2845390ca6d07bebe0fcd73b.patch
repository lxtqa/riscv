From a0a786656f87f10b2845390ca6d07bebe0fcd73b Mon Sep 17 00:00:00 2001
From: Manos Koukoutos <manoskouk@chromium.org>
Date: Fri, 1 Jul 2022 11:50:04 +0000
Subject: [PATCH] [wasm-gc][refactor] Rename optRef -> refNull

This makes the internal V8 name consistent with the text-format name.

Bug: v8:7748
Change-Id: I44f7ac1eb5e634b4f829e596bf1f14caeb748d54
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3726291
Reviewed-by: Toon Verwaest <verwaest@chromium.org>
Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
Commit-Queue: Manos Koukoutos <manoskouk@chromium.org>
Cr-Commit-Position: refs/heads/main@{#81491}
---
 src/builtins/x64/builtins-x64.cc              |   4 +-
 src/compiler/wasm-compiler.cc                 |  22 ++--
 src/debug/debug-wasm-objects.cc               |   2 +-
 .../wasm/gdb-server/wasm-module-debug.cc      |   2 +-
 src/diagnostics/objects-printer.cc            |   4 +-
 src/ic/accessor-assembler.cc                  |   2 +-
 src/ic/handler-configuration-inl.h            |   4 +-
 src/ic/handler-configuration.h                |   2 +-
 src/ic/ic.cc                                  |   2 +-
 src/wasm/baseline/arm/liftoff-assembler-arm.h |   8 +-
 .../baseline/arm64/liftoff-assembler-arm64.h  |   6 +-
 .../baseline/ia32/liftoff-assembler-ia32.h    |  10 +-
 src/wasm/baseline/liftoff-assembler.cc        |   2 +-
 src/wasm/baseline/liftoff-compiler.cc         |  22 ++--
 src/wasm/baseline/liftoff-register.h          |   2 +-
 .../loong64/liftoff-assembler-loong64.h       |  12 +-
 .../baseline/mips/liftoff-assembler-mips.h    |  12 +-
 .../mips64/liftoff-assembler-mips64.h         |  12 +-
 src/wasm/baseline/ppc/liftoff-assembler-ppc.h |  20 +--
 .../riscv64/liftoff-assembler-riscv64.h       |  19 +--
 .../baseline/s390/liftoff-assembler-s390.h    |  20 +--
 src/wasm/baseline/x64/liftoff-assembler-x64.h |  10 +-
 src/wasm/c-api.cc                             |   8 +-
 src/wasm/constant-expression-interface.cc     |   2 +-
 src/wasm/function-body-decoder-impl.h         |  12 +-
 src/wasm/module-instantiate.cc                |   2 +-
 src/wasm/names-provider.cc                    |   2 +-
 src/wasm/value-type.h                         |  43 ++++---
 src/wasm/wasm-constants.h                     |   2 +-
 src/wasm/wasm-debug.cc                        |   2 +-
 src/wasm/wasm-js.cc                           |  12 +-
 src/wasm/wasm-module-builder.cc               |   2 +-
 src/wasm/wasm-objects-inl.h                   |   6 +-
 src/wasm/wasm-objects.cc                      |   8 +-
 src/wasm/wasm-subtyping.cc                    |   2 +-
 src/wasm/wasm-subtyping.h                     |   6 +-
 src/wasm/wasm-value.h                         |   2 +-
 test/cctest/wasm/test-gc.cc                   | 114 +++++++++---------
 test/common/wasm/wasm-interpreter.cc          |  10 +-
 test/common/wasm/wasm-macro-gen.h             |   4 +-
 test/common/wasm/wasm-module-runner.cc        |   4 +-
 test/fuzzer/wasm-compile.cc                   |   4 +-
 test/fuzzer/wasm-fuzzer-common.cc             |   4 +-
 test/mjsunit/regress/wasm/regress-1189454.js  |   2 +-
 test/mjsunit/regress/wasm/regress-12945.js    |   2 +-
 test/mjsunit/regress/wasm/regress-1299183.js  |  66 ++++++++--
 .../regress/wasm/regress-crbug-1339321.js     |   2 +-
 .../regress/wasm/regress-inlining-throw.js    |   2 +-
 .../wasm/wasm-typer-incompatible-ref-cast.js  |   2 +-
 test/mjsunit/wasm/array-copy-benchmark.js     |  18 +--
 test/mjsunit/wasm/array-init-from-segment.js  |  26 ++--
 test/mjsunit/wasm/gc-experiments.js           |   2 +-
 test/mjsunit/wasm/gc-nominal.js               |   4 +-
 test/mjsunit/wasm/gc-optimizations.js         |  30 ++---
 test/mjsunit/wasm/inlining.js                 |   4 +-
 test/mjsunit/wasm/reference-globals.js        |  14 +--
 test/mjsunit/wasm/reference-tables.js         |   8 +-
 test/mjsunit/wasm/type-based-optimizations.js |   2 +-
 test/mjsunit/wasm/wasm-gc-js-roundtrip.js     |   2 +-
 test/mjsunit/wasm/wasm-module-builder.js      |   8 +-
 .../wasm/function-body-decoder-unittest.cc    |  10 +-
 .../unittests/wasm/module-decoder-unittest.cc |  50 ++++----
 test/unittests/wasm/subtyping-unittest.cc     |  76 ++++++------
 63 files changed, 413 insertions(+), 367 deletions(-)

diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index 5871e39a37e..a2a2a89d239 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -3495,10 +3495,10 @@ void GenericJSToWasmWrapperHelper(MacroAssembler* masm, bool stack_switch) {
   __ movq(param, MemOperand(original_fp, current_param, times_1, 0));
   __ movl(valuetype,
           Operand(valuetypes_array_ptr, wasm::ValueType::bit_field_offset()));
-  // Extract the ValueKind of the type, to check for kRef and kOptRef.
+  // Extract the ValueKind of the type, to check for kRef and kRefNull.
   __ andl(valuetype, Immediate(wasm::kWasmValueKindBitsMask));
   Label move_ref_to_slot;
-  __ cmpq(valuetype, Immediate(wasm::ValueKind::kOptRef));
+  __ cmpq(valuetype, Immediate(wasm::ValueKind::kRefNull));
   __ j(equal, &move_ref_to_slot);
   __ cmpq(valuetype, Immediate(wasm::ValueKind::kRef));
   __ j(equal, &move_ref_to_slot);
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 76a0911a70f..71e60b32602 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -2159,7 +2159,7 @@ Node* WasmGraphBuilder::Throw(uint32_t tag_index, const wasm::WasmTag* tag,
             graph()->NewNode(m->I32x4ExtractLane(3), value));
         break;
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
       case wasm::kRtt:
         gasm_->StoreFixedArrayElementAny(values_array, index, value);
         ++index;
@@ -2290,7 +2290,7 @@ Node* WasmGraphBuilder::GetExceptionValues(Node* except_obj,
             BuildDecodeException32BitValue(values_array, &index));
         break;
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
       case wasm::kRtt:
         value = gasm_->LoadFixedArrayElementAny(values_array, index);
         ++index;
@@ -5198,7 +5198,7 @@ Node* WasmGraphBuilder::DefaultValue(wasm::ValueType type) {
       return Float64Constant(0);
     case wasm::kS128:
       return S128Zero();
-    case wasm::kOptRef:
+    case wasm::kRefNull:
       return RefNull();
     case wasm::kRtt:
     case wasm::kVoid:
@@ -6171,10 +6171,10 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
       case wasm::kF64:
         return BuildChangeFloat64ToNumber(node);
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
         switch (type.heap_representation()) {
           case wasm::HeapType::kFunc: {
-            if (type.kind() == wasm::kOptRef) {
+            if (type.kind() == wasm::kRefNull) {
               auto done =
                   gasm_->MakeLabel(MachineRepresentation::kTaggedPointer);
               // Do not wrap {null}.
@@ -6198,7 +6198,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
           case wasm::HeapType::kArray:
           case wasm::HeapType::kI31:
             // TODO(7748): Update this when JS interop is settled.
-            if (type.kind() == wasm::kOptRef) {
+            if (type.kind() == wasm::kRefNull) {
               auto done =
                   gasm_->MakeLabel(MachineRepresentation::kTaggedPointer);
               // Do not wrap {null}.
@@ -6211,7 +6211,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
             }
           case wasm::HeapType::kString:
             // Either {node} is already a tagged JS string, or if type.kind() is
-            // wasm::kOptRef, it's the null object.  Either way it's good to go
+            // wasm::kRefNull, it's the null object.  Either way it's good to go
             // already to JS.
             return node;
           case wasm::HeapType::kAny: {
@@ -6414,7 +6414,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
                Node* frame_state = nullptr) {
     switch (type.kind()) {
       case wasm::kRef:
-      case wasm::kOptRef: {
+      case wasm::kRefNull: {
         switch (type.heap_representation()) {
           case wasm::HeapType::kAny:
             if (!enabled_features_.has_gc()) return input;
@@ -6525,7 +6525,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
         return done.PhiAt(0);
       }
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
       case wasm::kI64:
       case wasm::kRtt:
       case wasm::kS128:
@@ -6690,7 +6690,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
       wasm::ValueType type = sig_->GetParam(i);
       switch (type.kind()) {
         case wasm::kRef:
-        case wasm::kOptRef:
+        case wasm::kRefNull:
         case wasm::kI64:
         case wasm::kRtt:
         case wasm::kS128:
@@ -6740,7 +6740,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
         return;
       }
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
       case wasm::kI64:
       case wasm::kRtt:
       case wasm::kS128:
diff --git a/src/debug/debug-wasm-objects.cc b/src/debug/debug-wasm-objects.cc
index 401247b7972..6c2ee18abb9 100644
--- a/src/debug/debug-wasm-objects.cc
+++ b/src/debug/debug-wasm-objects.cc
@@ -903,7 +903,7 @@ Handle<WasmValueObject> WasmValueObject::New(
       v = WasmSimd128ToString(isolate, value.to_s128_unchecked());
       break;
     }
-    case wasm::kOptRef:
+    case wasm::kRefNull:
     case wasm::kRef: {
       t = GetRefTypeName(isolate, value.type(), module_object->native_module());
       Handle<Object> ref = value.to_ref();
diff --git a/src/debug/wasm/gdb-server/wasm-module-debug.cc b/src/debug/wasm/gdb-server/wasm-module-debug.cc
index 751e9896e32..ddfd62aafc2 100644
--- a/src/debug/wasm/gdb-server/wasm-module-debug.cc
+++ b/src/debug/wasm/gdb-server/wasm-module-debug.cc
@@ -402,7 +402,7 @@ bool WasmModuleDebug::GetWasmValue(const wasm::WasmValue& wasm_value,
     case wasm::kS128:
       return StoreValue(wasm_value.to_s128(), buffer, buffer_size, size);
     case wasm::kRef:
-    case wasm::kOptRef:
+    case wasm::kRefNull:
     case wasm::kRtt:
     case wasm::kVoid:
     case wasm::kBottom:
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index e57bd97f2b5..7dda48076f7 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -1886,7 +1886,7 @@ void WasmStruct::WasmStructPrint(std::ostream& os) {
         os << base::ReadUnalignedValue<int16_t>(field_address);
         break;
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
       case wasm::kRtt: {
         Tagged_t raw = base::ReadUnalignedValue<Tagged_t>(field_address);
 #if V8_COMPRESS_POINTERS
@@ -1942,7 +1942,7 @@ void WasmArray::WasmArrayPrint(std::ostream& os) {
       break;
     case wasm::kS128:
     case wasm::kRef:
-    case wasm::kOptRef:
+    case wasm::kRefNull:
     case wasm::kRtt:
       os << "\n   Printing elements of this type is unimplemented, sorry";
       // TODO(7748): Implement.
diff --git a/src/ic/accessor-assembler.cc b/src/ic/accessor-assembler.cc
index 2d4a99b0eac..364e7195a6e 100644
--- a/src/ic/accessor-assembler.cc
+++ b/src/ic/accessor-assembler.cc
@@ -356,7 +356,7 @@ void AccessorAssembler::HandleLoadWasmField(
       static_cast<int32_t>(WasmValueType::kF32),
       static_cast<int32_t>(WasmValueType::kF64),
       static_cast<int32_t>(WasmValueType::kRef),
-      static_cast<int32_t>(WasmValueType::kOptRef),
+      static_cast<int32_t>(WasmValueType::kRefNull),
       // TODO(v8:11804): support the following value types.
       static_cast<int32_t>(WasmValueType::kS128)};
   const size_t kWasmValueTypeCount =
diff --git a/src/ic/handler-configuration-inl.h b/src/ic/handler-configuration-inl.h
index 0a55014d9be..48e96ab0375 100644
--- a/src/ic/handler-configuration-inl.h
+++ b/src/ic/handler-configuration-inl.h
@@ -300,8 +300,8 @@ inline const char* WasmValueType2String(WasmValueType type) {
 
     case WasmValueType::kRef:
       return "Ref";
-    case WasmValueType::kOptRef:
-      return "OptRef";
+    case WasmValueType::kRefNull:
+      return "RefNull";
 
     case WasmValueType::kNumTypes:
       return "???";
diff --git a/src/ic/handler-configuration.h b/src/ic/handler-configuration.h
index 3bc13c3c4e5..34c8d403fe6 100644
--- a/src/ic/handler-configuration.h
+++ b/src/ic/handler-configuration.h
@@ -33,7 +33,7 @@ enum class WasmValueType {
   kS128,
 
   kRef,
-  kOptRef,
+  kRefNull,
 
   kNumTypes
 };
diff --git a/src/ic/ic.cc b/src/ic/ic.cc
index 9a9293d2830..e34ae2eb0c7 100644
--- a/src/ic/ic.cc
+++ b/src/ic/ic.cc
@@ -887,7 +887,7 @@ inline WasmValueType GetWasmValueType(wasm::ValueType type) {
     TYPE_CASE(F64)
     TYPE_CASE(S128)
     TYPE_CASE(Ref)
-    TYPE_CASE(OptRef)
+    TYPE_CASE(RefNull)
 
     case wasm::kRtt:
       // Rtt values are not supposed to be made available to JavaScript side.
diff --git a/src/wasm/baseline/arm/liftoff-assembler-arm.h b/src/wasm/baseline/arm/liftoff-assembler-arm.h
index 9fe750f8724..0ed700b198f 100644
--- a/src/wasm/baseline/arm/liftoff-assembler-arm.h
+++ b/src/wasm/baseline/arm/liftoff-assembler-arm.h
@@ -306,7 +306,7 @@ inline void Store(LiftoffAssembler* assm, LiftoffRegister src, MemOperand dst,
 #endif
   switch (kind) {
     case kI32:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->str(src.gp(), dst);
@@ -340,7 +340,7 @@ inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, MemOperand src,
                  ValueKind kind) {
   switch (kind) {
     case kI32:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->ldr(dst.gp(), src);
@@ -4464,7 +4464,7 @@ void LiftoffStackSlots::Construct(int param_slots) {
           case kI64:
           case kF32:
           case kRef:
-          case kOptRef: {
+          case kRefNull: {
             asm_->AllocateStackSpace(stack_decrement - kSystemPointerSize);
             UseScratchRegisterScope temps(asm_);
             Register scratch = temps.Acquire();
@@ -4506,7 +4506,7 @@ void LiftoffStackSlots::Construct(int param_slots) {
           } break;
           case kI32:
           case kRef:
-          case kOptRef:
+          case kRefNull:
             asm_->push(src.reg().gp());
             break;
           case kF32:
diff --git a/src/wasm/baseline/arm64/liftoff-assembler-arm64.h b/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
index 8f3143eca17..e46819380bd 100644
--- a/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
+++ b/src/wasm/baseline/arm64/liftoff-assembler-arm64.h
@@ -82,7 +82,7 @@ inline CPURegister GetRegFromType(const LiftoffRegister& reg, ValueKind kind) {
       return reg.gp().W();
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       return reg.gp().X();
     case kF32:
@@ -113,7 +113,7 @@ inline CPURegister AcquireByType(UseScratchRegisterScope* temps,
       return temps->AcquireW();
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
       return temps->AcquireX();
     case kF32:
       return temps->AcquireS();
@@ -1565,7 +1565,7 @@ void LiftoffAssembler::emit_cond_jump(LiftoffCondition liftoff_cond,
       }
       break;
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       DCHECK(rhs.is_valid());
       DCHECK(liftoff_cond == kEqual || liftoff_cond == kUnequal);
diff --git a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
index 4e67fc8f2ab..81ddffbb019 100644
--- a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
+++ b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
@@ -72,7 +72,7 @@ inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, Register base,
   Operand src(base, offset);
   switch (kind) {
     case kI32:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->mov(dst.gp(), src);
@@ -100,7 +100,7 @@ inline void Store(LiftoffAssembler* assm, Register base, int32_t offset,
   Operand dst(base, offset);
   switch (kind) {
     case kI32:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->mov(dst, src.gp());
@@ -131,7 +131,7 @@ inline void push(LiftoffAssembler* assm, LiftoffRegister reg, ValueKind kind,
   switch (kind) {
     case kI32:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       assm->AllocateStackSpace(padding);
       assm->push(reg.gp());
@@ -1199,7 +1199,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
   Operand dst = liftoff::GetStackSlot(offset);
   switch (kind) {
     case kI32:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       mov(dst, reg.gp());
@@ -2464,7 +2464,7 @@ void LiftoffAssembler::emit_cond_jump(LiftoffCondition liftoff_cond,
   if (rhs != no_reg) {
     switch (kind) {
       case kRef:
-      case kOptRef:
+      case kRefNull:
       case kRtt:
         DCHECK(liftoff_cond == kEqual || liftoff_cond == kUnequal);
         V8_FALLTHROUGH;
diff --git a/src/wasm/baseline/liftoff-assembler.cc b/src/wasm/baseline/liftoff-assembler.cc
index 6cf7df8044e..eb010371e35 100644
--- a/src/wasm/baseline/liftoff-assembler.cc
+++ b/src/wasm/baseline/liftoff-assembler.cc
@@ -1395,7 +1395,7 @@ bool CheckCompatibleStackSlotTypes(ValueKind a, ValueKind b) {
   if (is_object_reference(a)) {
     // Since Liftoff doesn't do accurate type tracking (e.g. on loop back
     // edges), we only care that pointer types stay amongst pointer types.
-    // It's fine if ref/optref overwrite each other.
+    // It's fine if ref/ref null overwrite each other.
     DCHECK(is_object_reference(b));
   } else if (is_rtt(a)) {
     // Same for rtt/rtt_with_depth.
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index b0aa0ecfe53..76c0bcbdb2f 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -602,7 +602,7 @@ class LiftoffCompiler {
         bailout_reason = kSimd;
         break;
       case kRef:
-      case kOptRef:
+      case kRefNull:
       case kRtt:
       case kI8:
       case kI16:
@@ -2171,7 +2171,7 @@ class LiftoffCompiler {
           }
         });
       case kExprRefEq: {
-        return EmitBinOp<kOptRef, kI32>(
+        return EmitBinOp<kRefNull, kI32>(
             BindFirst(&LiftoffAssembler::emit_ptrsize_set_cond, kEqual));
       }
 
@@ -2601,10 +2601,10 @@ class LiftoffCompiler {
     LoadNullValue(null.gp(), pinned);
     {
       FREEZE_STATE(trapping);
-      __ emit_cond_jump(kUnequal, trap_label, kOptRef, obj.gp(), null.gp(),
+      __ emit_cond_jump(kUnequal, trap_label, kRefNull, obj.gp(), null.gp(),
                         trapping);
     }
-    __ PushRegister(kOptRef, obj);
+    __ PushRegister(kRefNull, obj);
   }
 
   void NopForTestingUnsupportedInLiftoff(FullDecoder* decoder) {
@@ -4491,7 +4491,7 @@ class LiftoffCompiler {
         break;
       }
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
       case wasm::kRtt: {
         --(*index_in_array);
         __ StoreTaggedPointer(
@@ -4549,7 +4549,7 @@ class LiftoffCompiler {
         break;
       }
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
       case wasm::kRtt: {
         __ LoadTaggedPointer(
             value.gp(), values_array.gp(), no_reg,
@@ -5646,7 +5646,7 @@ class LiftoffCompiler {
     CallRuntimeStub(FLAG_experimental_wasm_skip_bounds_checks
                         ? WasmCode::kWasmArrayCopy
                         : WasmCode::kWasmArrayCopyWithChecks,
-                    MakeSig::Params(kI32, kI32, kI32, kOptRef, kOptRef),
+                    MakeSig::Params(kI32, kI32, kI32, kRefNull, kRefNull),
                     // Builtin parameter order:
                     // [dst_index, src_index, length, dst, src].
                     {__ cache_state()->stack_state.end()[-4],
@@ -5987,7 +5987,7 @@ class LiftoffCompiler {
   }
   void LoadInstanceType(TypeCheck& check, const FreezeCacheState& frozen) {
     if (check.obj_type.is_nullable()) {
-      __ emit_cond_jump(kEqual, check.no_match, kOptRef, check.obj_reg,
+      __ emit_cond_jump(kEqual, check.no_match, kRefNull, check.obj_reg,
                         check.null_reg(), frozen);
     }
     __ emit_smi_check(check.obj_reg, check.no_match,
@@ -7007,7 +7007,7 @@ class LiftoffCompiler {
     LiftoffRegister null = __ GetUnusedRegister(kGpReg, pinned);
     LoadNullValue(null.gp(), pinned);
     FREEZE_STATE(trapping);
-    __ emit_cond_jump(LiftoffCondition::kEqual, trap_label, kOptRef, object,
+    __ emit_cond_jump(LiftoffCondition::kEqual, trap_label, kRefNull, object,
                       null.gp(), trapping);
   }
 
@@ -7071,7 +7071,7 @@ class LiftoffCompiler {
       case kS128:
         DCHECK(CpuFeatures::SupportsWasmSimd128());
         return __ emit_s128_xor(reg, reg, reg);
-      case kOptRef:
+      case kRefNull:
         return LoadNullValue(reg.gp(), pinned);
       case kRtt:
       case kVoid:
@@ -7172,7 +7172,7 @@ class LiftoffCompiler {
       // MVP:
       kI32, kI64, kF32, kF64,
       // Extern ref:
-      kRef, kOptRef, kRtt, kI8, kI16};
+      kRef, kRefNull, kRtt, kI8, kI16};
 
   LiftoffAssembler asm_;
 
diff --git a/src/wasm/baseline/liftoff-register.h b/src/wasm/baseline/liftoff-register.h
index c00787abe4c..adf17d5f11e 100644
--- a/src/wasm/baseline/liftoff-register.h
+++ b/src/wasm/baseline/liftoff-register.h
@@ -67,7 +67,7 @@ static inline constexpr RegClass reg_class_for(ValueKind kind) {
     case kS128:
       return kNeedS128RegPair ? kFpRegPair : kFpReg;
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       return kGpReg;
     default:
diff --git a/src/wasm/baseline/loong64/liftoff-assembler-loong64.h b/src/wasm/baseline/loong64/liftoff-assembler-loong64.h
index e48bd62e8db..4aa18ba5685 100644
--- a/src/wasm/baseline/loong64/liftoff-assembler-loong64.h
+++ b/src/wasm/baseline/loong64/liftoff-assembler-loong64.h
@@ -103,7 +103,7 @@ inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, MemOperand src,
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       assm->Ld_d(dst.gp(), src);
       break;
@@ -129,7 +129,7 @@ inline void Store(LiftoffAssembler* assm, Register base, int32_t offset,
       assm->St_w(src.gp(), dst);
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->St_d(src.gp(), dst);
@@ -152,7 +152,7 @@ inline void push(LiftoffAssembler* assm, LiftoffRegister reg, ValueKind kind) {
       assm->St_w(reg.gp(), MemOperand(sp, 0));
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->Push(reg.gp());
@@ -890,7 +890,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       St_d(reg.gp(), dst);
       break;
@@ -921,7 +921,7 @@ void LiftoffAssembler::Spill(int offset, WasmValue value) {
     }
     case kI64:
     case kRef:
-    case kOptRef: {
+    case kRefNull: {
       UseScratchRegisterScope temps(this);
       Register scratch = temps.Acquire();
       TurboAssembler::li(scratch, value.to_i64());
@@ -943,7 +943,7 @@ void LiftoffAssembler::Fill(LiftoffRegister reg, int offset, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     // TODO(LOONG_dev): LOONG64 Check, MIPS64 dosn't need, ARM64/LOONG64 need?
     case kRtt:
       Ld_d(reg.gp(), src);
diff --git a/src/wasm/baseline/mips/liftoff-assembler-mips.h b/src/wasm/baseline/mips/liftoff-assembler-mips.h
index d1a5cdc6903..6b67e1ca094 100644
--- a/src/wasm/baseline/mips/liftoff-assembler-mips.h
+++ b/src/wasm/baseline/mips/liftoff-assembler-mips.h
@@ -92,7 +92,7 @@ inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, Register base,
   switch (kind) {
     case kI32:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       assm->lw(dst.gp(), src);
       break;
@@ -118,7 +118,7 @@ inline void Store(LiftoffAssembler* assm, Register base, int32_t offset,
   MemOperand dst(base, offset);
   switch (kind) {
     case kI32:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->Usw(src.gp(), dst);
@@ -143,7 +143,7 @@ inline void Store(LiftoffAssembler* assm, Register base, int32_t offset,
 inline void push(LiftoffAssembler* assm, LiftoffRegister reg, ValueKind kind) {
   switch (kind) {
     case kI32:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->push(reg.gp());
@@ -810,7 +810,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
   switch (kind) {
     case kI32:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       sw(reg.gp(), dst);
       break;
@@ -835,7 +835,7 @@ void LiftoffAssembler::Spill(int offset, WasmValue value) {
   switch (value.type().kind()) {
     case kI32:
     case kRef:
-    case kOptRef: {
+    case kRefNull: {
       LiftoffRegister tmp = GetUnusedRegister(kGpReg, {});
       TurboAssembler::li(tmp.gp(), Operand(value.to_i32()));
       sw(tmp.gp(), dst);
@@ -865,7 +865,7 @@ void LiftoffAssembler::Fill(LiftoffRegister reg, int offset, ValueKind kind) {
   switch (kind) {
     case kI32:
     case kRef:
-    case kOptRef:
+    case kRefNull:
       lw(reg.gp(), src);
       break;
     case kI64:
diff --git a/src/wasm/baseline/mips64/liftoff-assembler-mips64.h b/src/wasm/baseline/mips64/liftoff-assembler-mips64.h
index e396d11eef7..0802a46eb98 100644
--- a/src/wasm/baseline/mips64/liftoff-assembler-mips64.h
+++ b/src/wasm/baseline/mips64/liftoff-assembler-mips64.h
@@ -103,7 +103,7 @@ inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, MemOperand src,
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       assm->Ld(dst.gp(), src);
       break;
@@ -129,7 +129,7 @@ inline void Store(LiftoffAssembler* assm, Register base, int32_t offset,
       assm->Usw(src.gp(), dst);
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->Usd(src.gp(), dst);
@@ -155,7 +155,7 @@ inline void push(LiftoffAssembler* assm, LiftoffRegister reg, ValueKind kind) {
       assm->sw(reg.gp(), MemOperand(sp, 0));
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->push(reg.gp());
@@ -993,7 +993,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       Sd(reg.gp(), dst);
       break;
@@ -1022,7 +1022,7 @@ void LiftoffAssembler::Spill(int offset, WasmValue value) {
     }
     case kI64:
     case kRef:
-    case kOptRef: {
+    case kRefNull: {
       TurboAssembler::li(kScratchReg, value.to_i64());
       Sd(kScratchReg, dst);
       break;
@@ -1042,7 +1042,7 @@ void LiftoffAssembler::Fill(LiftoffRegister reg, int offset, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
       Ld(reg.gp(), src);
       break;
     case kF32:
diff --git a/src/wasm/baseline/ppc/liftoff-assembler-ppc.h b/src/wasm/baseline/ppc/liftoff-assembler-ppc.h
index 6f8d2269bf6..c5066c341c1 100644
--- a/src/wasm/baseline/ppc/liftoff-assembler-ppc.h
+++ b/src/wasm/baseline/ppc/liftoff-assembler-ppc.h
@@ -805,7 +805,7 @@ void LiftoffAssembler::LoadCallerFrameSlot(LiftoffRegister dst,
     }
     case kRef:
     case kRtt:
-    case kOptRef:
+    case kRefNull:
     case kI64: {
       LoadU64(dst.gp(), MemOperand(fp, offset), r0);
       break;
@@ -843,7 +843,7 @@ void LiftoffAssembler::StoreCallerFrameSlot(LiftoffRegister src,
     }
     case kRef:
     case kRtt:
-    case kOptRef:
+    case kRefNull:
     case kI64: {
       StoreU64(src.gp(), MemOperand(fp, offset), r0);
       break;
@@ -879,7 +879,7 @@ void LiftoffAssembler::LoadReturnStackSlot(LiftoffRegister dst, int offset,
     }
     case kRef:
     case kRtt:
-    case kOptRef:
+    case kRefNull:
     case kI64: {
       LoadU64(dst.gp(), MemOperand(sp, offset), r0);
       break;
@@ -918,7 +918,7 @@ void LiftoffAssembler::MoveStackValue(uint32_t dst_offset, uint32_t src_offset,
       StoreU32(ip, liftoff::GetStackSlot(dst_offset + stack_bias), r0);
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
     case kF64:
@@ -955,7 +955,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
       StoreU32(reg.gp(), liftoff::GetStackSlot(offset + stack_bias), r0);
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       StoreU64(reg.gp(), liftoff::GetStackSlot(offset), r0);
@@ -1004,7 +1004,7 @@ void LiftoffAssembler::Fill(LiftoffRegister reg, int offset, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       LoadU64(reg.gp(), liftoff::GetStackSlot(offset), r0);
       break;
@@ -1605,7 +1605,7 @@ void LiftoffAssembler::emit_cond_jump(LiftoffCondition liftoff_cond,
         }
         break;
       case kRef:
-      case kOptRef:
+      case kRefNull:
       case kRtt:
         DCHECK(liftoff_cond == kEqual || liftoff_cond == kUnequal);
         V8_FALLTHROUGH;
@@ -3103,7 +3103,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
         LoadS32(result_reg->gp(), MemOperand(sp));
         break;
       case kI64:
-      case kOptRef:
+      case kRefNull:
       case kRef:
       case kRtt:
         LoadU64(result_reg->gp(), MemOperand(sp));
@@ -3183,7 +3183,7 @@ void LiftoffStackSlots::Construct(int param_slots) {
         switch (src.kind()) {
           case kI32:
           case kRef:
-          case kOptRef:
+          case kRefNull:
           case kRtt:
           case kI64: {
             asm_->AllocateStackSpace(stack_decrement - kSystemPointerSize);
@@ -3225,7 +3225,7 @@ void LiftoffStackSlots::Construct(int param_slots) {
           case kI64:
           case kI32:
           case kRef:
-          case kOptRef:
+          case kRefNull:
           case kRtt:
             asm_->push(src.reg().gp());
             break;
diff --git a/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h b/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h
index d84ad6df8fe..1445fb58d44 100644
--- a/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h
+++ b/src/wasm/baseline/riscv64/liftoff-assembler-riscv64.h
@@ -102,7 +102,7 @@ inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, MemOperand src,
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       assm->Ld(dst.gp(), src);
       break;
@@ -125,7 +125,7 @@ inline void Store(LiftoffAssembler* assm, Register base, int32_t offset,
       assm->Sw(src.gp(), dst);
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->Sd(src.gp(), dst);
@@ -148,7 +148,7 @@ inline void push(LiftoffAssembler* assm, LiftoffRegister reg, ValueKind kind) {
       assm->Sw(reg.gp(), MemOperand(sp, 0));
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->push(reg.gp());
@@ -966,7 +966,7 @@ void LiftoffAssembler::MoveStackValue(uint32_t dst_offset, uint32_t src_offset,
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       Ld(kScratchReg, src);
       Sd(kScratchReg, dst);
@@ -993,7 +993,10 @@ void LiftoffAssembler::MoveStackValue(uint32_t dst_offset, uint32_t src_offset,
       vs(kSimd128ScratchReg, dst_reg, 0, VSew::E8);
       break;
     }
-    default:
+    case kVoid:
+    case kI8:
+    case kI16:
+    case kBottom:
       UNREACHABLE();
   }
 }
@@ -1023,7 +1026,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       Sd(reg.gp(), dst);
       break;
@@ -1060,7 +1063,7 @@ void LiftoffAssembler::Spill(int offset, WasmValue value) {
     }
     case kI64:
     case kRef:
-    case kOptRef: {
+    case kRefNull: {
       UseScratchRegisterScope temps(this);
       Register tmp = temps.Acquire();
       TurboAssembler::li(tmp, value.to_i64());
@@ -1082,7 +1085,7 @@ void LiftoffAssembler::Fill(LiftoffRegister reg, int offset, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
       Ld(reg.gp(), src);
       break;
     case kF32:
diff --git a/src/wasm/baseline/s390/liftoff-assembler-s390.h b/src/wasm/baseline/s390/liftoff-assembler-s390.h
index 79b23dc3264..2a4205ff894 100644
--- a/src/wasm/baseline/s390/liftoff-assembler-s390.h
+++ b/src/wasm/baseline/s390/liftoff-assembler-s390.h
@@ -1232,7 +1232,7 @@ void LiftoffAssembler::LoadCallerFrameSlot(LiftoffRegister dst,
     }
     case kRef:
     case kRtt:
-    case kOptRef:
+    case kRefNull:
     case kI64: {
       LoadU64(dst.gp(), MemOperand(fp, offset));
       break;
@@ -1272,7 +1272,7 @@ void LiftoffAssembler::StoreCallerFrameSlot(LiftoffRegister src,
     }
     case kRef:
     case kRtt:
-    case kOptRef:
+    case kRefNull:
     case kI64: {
       StoreU64(src.gp(), MemOperand(fp, offset));
       break;
@@ -1310,7 +1310,7 @@ void LiftoffAssembler::LoadReturnStackSlot(LiftoffRegister dst, int offset,
     }
     case kRef:
     case kRtt:
-    case kOptRef:
+    case kRefNull:
     case kI64: {
       LoadU64(dst.gp(), MemOperand(sp, offset));
       break;
@@ -1350,7 +1350,7 @@ void LiftoffAssembler::MoveStackValue(uint32_t dst_offset, uint32_t src_offset,
       length = 4;
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
     case kF64:
@@ -1409,7 +1409,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
       StoreU32(reg.gp(), liftoff::GetStackSlot(offset + stack_bias));
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       StoreU64(reg.gp(), liftoff::GetStackSlot(offset));
@@ -1460,7 +1460,7 @@ void LiftoffAssembler::Fill(LiftoffRegister reg, int offset, ValueKind kind) {
       break;
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
     case kRtt:
       LoadU64(reg.gp(), liftoff::GetStackSlot(offset));
       break;
@@ -2136,7 +2136,7 @@ void LiftoffAssembler::emit_cond_jump(LiftoffCondition liftoff_cond,
         }
         break;
       case kRef:
-      case kOptRef:
+      case kRefNull:
       case kRtt:
         DCHECK(liftoff_cond == kEqual || liftoff_cond == kUnequal);
         V8_FALLTHROUGH;
@@ -3102,7 +3102,7 @@ void LiftoffAssembler::CallC(const ValueKindSig* sig,
         LoadS32(result_reg->gp(), MemOperand(sp));
         break;
       case kI64:
-      case kOptRef:
+      case kRefNull:
       case kRef:
       case kRtt:
         LoadU64(result_reg->gp(), MemOperand(sp));
@@ -3208,7 +3208,7 @@ void LiftoffStackSlots::Construct(int param_slots) {
         switch (src.kind()) {
           case kI32:
           case kRef:
-          case kOptRef:
+          case kRefNull:
           case kRtt:
           case kI64: {
             asm_->AllocateStackSpace(stack_decrement - kSystemPointerSize);
@@ -3255,7 +3255,7 @@ void LiftoffStackSlots::Construct(int param_slots) {
           case kI64:
           case kI32:
           case kRef:
-          case kOptRef:
+          case kRefNull:
           case kRtt:
             asm_->push(src.reg().gp());
             break;
diff --git a/src/wasm/baseline/x64/liftoff-assembler-x64.h b/src/wasm/baseline/x64/liftoff-assembler-x64.h
index 3f72136c953..b59b42c3546 100644
--- a/src/wasm/baseline/x64/liftoff-assembler-x64.h
+++ b/src/wasm/baseline/x64/liftoff-assembler-x64.h
@@ -99,7 +99,7 @@ inline void Load(LiftoffAssembler* assm, LiftoffRegister dst, Operand src,
       assm->movl(dst.gp(), src);
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->movq(dst.gp(), src);
@@ -127,7 +127,7 @@ inline void Store(LiftoffAssembler* assm, Operand dst, LiftoffRegister src,
     case kI64:
       assm->movq(dst, src.gp());
       break;
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       assm->StoreTaggedField(dst, src.gp());
@@ -152,7 +152,7 @@ inline void push(LiftoffAssembler* assm, LiftoffRegister reg, ValueKind kind,
     case kI32:
     case kI64:
     case kRef:
-    case kOptRef:
+    case kRefNull:
       assm->AllocateStackSpace(padding);
       assm->pushq(reg.gp());
       break;
@@ -919,7 +919,7 @@ void LiftoffAssembler::Spill(int offset, LiftoffRegister reg, ValueKind kind) {
       movl(dst, reg.gp());
       break;
     case kI64:
-    case kOptRef:
+    case kRefNull:
     case kRef:
     case kRtt:
       movq(dst, reg.gp());
@@ -2142,7 +2142,7 @@ void LiftoffAssembler::emit_cond_jump(LiftoffCondition liftoff_cond,
         cmpl(lhs, rhs);
         break;
       case kRef:
-      case kOptRef:
+      case kRefNull:
       case kRtt:
         DCHECK(liftoff_cond == kEqual || liftoff_cond == kUnequal);
         V8_FALLTHROUGH;
diff --git a/src/wasm/c-api.cc b/src/wasm/c-api.cc
index 517bec33904..d751d0f2aca 100644
--- a/src/wasm/c-api.cc
+++ b/src/wasm/c-api.cc
@@ -80,7 +80,7 @@ ValKind V8ValueTypeToWasm(i::wasm::ValueType v8_valtype) {
     case i::wasm::kF64:
       return F64;
     case i::wasm::kRef:
-    case i::wasm::kOptRef:
+    case i::wasm::kRefNull:
       switch (v8_valtype.heap_representation()) {
         case i::wasm::HeapType::kFunc:
           return FUNCREF;
@@ -1564,7 +1564,7 @@ void PushArgs(const i::wasm::FunctionSig* sig, const Val args[],
         packer->Push(args[i].f64());
         break;
       case i::wasm::kRef:
-      case i::wasm::kOptRef:
+      case i::wasm::kRefNull:
         // TODO(7748): Make sure this works for all heap types.
         packer->Push(WasmRefToV8(store->i_isolate(), args[i].ref())->ptr());
         break;
@@ -1600,7 +1600,7 @@ void PopArgs(const i::wasm::FunctionSig* sig, Val results[],
         results[i] = Val(packer->Pop<double>());
         break;
       case i::wasm::kRef:
-      case i::wasm::kOptRef: {
+      case i::wasm::kRefNull: {
         // TODO(7748): Make sure this works for all heap types.
         i::Address raw = packer->Pop<i::Address>();
         i::Handle<i::Object> obj(i::Object(raw), store->i_isolate());
@@ -1863,7 +1863,7 @@ auto Global::get() const -> Val {
     case i::wasm::kF64:
       return Val(v8_global->GetF64());
     case i::wasm::kRef:
-    case i::wasm::kOptRef: {
+    case i::wasm::kRefNull: {
       // TODO(7748): Make sure this works for all heap types.
       StoreImpl* store = impl(this)->store();
       i::HandleScope scope(store->i_isolate());
diff --git a/src/wasm/constant-expression-interface.cc b/src/wasm/constant-expression-interface.cc
index a0e4f8d454b..c6ae87bc1e6 100644
--- a/src/wasm/constant-expression-interface.cc
+++ b/src/wasm/constant-expression-interface.cc
@@ -169,7 +169,7 @@ WasmValue DefaultValueForType(ValueType type, Isolate* isolate) {
       return WasmValue(0.0);
     case kS128:
       return WasmValue(Simd128());
-    case kOptRef:
+    case kRefNull:
       return WasmValue(isolate->factory()->null_value(), type);
     case kVoid:
     case kRtt:
diff --git a/src/wasm/function-body-decoder-impl.h b/src/wasm/function-body-decoder-impl.h
index 8ef194334ac..2b51ebf7601 100644
--- a/src/wasm/function-body-decoder-impl.h
+++ b/src/wasm/function-body-decoder-impl.h
@@ -323,8 +323,8 @@ ValueType read_value_type(Decoder* decoder, const byte* pc,
     case kF64Code:
       return kWasmF64;
     case kRefCode:
-    case kOptRefCode: {
-      Nullability nullability = code == kOptRefCode ? kNullable : kNonNullable;
+    case kRefNullCode: {
+      Nullability nullability = code == kRefNullCode ? kNullable : kNonNullable;
       if (!VALIDATE(enabled.has_typed_funcref())) {
         DecodeError<validate>(decoder, pc,
                               "Invalid type '(ref%s <heaptype>)', enable with "
@@ -2939,7 +2939,7 @@ class WasmFullDecoder : public WasmDecoder<validate, decoding_mode> {
         // For a non-nullable value, we won't take the branch, and can leave
         // the stack as it is.
         break;
-      case kOptRef: {
+      case kRefNull: {
         Value result = CreateValue(
             ValueType::Ref(ref_object.type.heap_type(), kNonNullable));
         // The result of br_on_null has the same value as the argument (but a
@@ -2991,7 +2991,7 @@ class WasmFullDecoder : public WasmDecoder<validate, decoding_mode> {
           c->br_merge()->reached = true;
         }
         break;
-      case kOptRef: {
+      case kRefNull: {
         if (V8_LIKELY(current_code_reachable_and_ok_)) {
           CALL_INTERFACE(BrOnNonNull, ref_object, value_on_branch, imm.depth,
                          true);
@@ -3310,7 +3310,7 @@ class WasmFullDecoder : public WasmDecoder<validate, decoding_mode> {
     Value value = Peek(0);
     Value result = CreateValue(kWasmI32);
     switch (value.type.kind()) {
-      case kOptRef:
+      case kRefNull:
         CALL_INTERFACE_IF_OK_AND_REACHABLE(UnOp, kExprRefIsNull, value,
                                            &result);
         Drop(value);
@@ -3356,7 +3356,7 @@ class WasmFullDecoder : public WasmDecoder<validate, decoding_mode> {
       case kRef:
         // A non-nullable value can remain as-is.
         return 1;
-      case kOptRef: {
+      case kRefNull: {
         Value result =
             CreateValue(ValueType::Ref(value.type.heap_type(), kNonNullable));
         CALL_INTERFACE_IF_OK_AND_REACHABLE(RefAsNonNull, value, &result);
diff --git a/src/wasm/module-instantiate.cc b/src/wasm/module-instantiate.cc
index f43804639e5..5f0c2dd20e3 100644
--- a/src/wasm/module-instantiate.cc
+++ b/src/wasm/module-instantiate.cc
@@ -1404,7 +1404,7 @@ bool InstanceBuilder::ProcessImportedWasmGlobalObject(
       break;
     case kRtt:
     case kRef:
-    case kOptRef:
+    case kRefNull:
       value = WasmValue(global_object->GetRef(), global_object->type());
       break;
     case kVoid:
diff --git a/src/wasm/names-provider.cc b/src/wasm/names-provider.cc
index 1789a4f0907..ce80824eea1 100644
--- a/src/wasm/names-provider.cc
+++ b/src/wasm/names-provider.cc
@@ -381,7 +381,7 @@ void NamesProvider::PrintHeapType(StringBuilder& out, HeapType type) {
 void NamesProvider::PrintValueType(StringBuilder& out, ValueType type) {
   switch (type.kind()) {
     case kRef:
-    case kOptRef:
+    case kRefNull:
       if (type.encoding_needs_heap_type()) {
         out << (type.kind() == kRef ? "(ref " : "(ref null ");
         PrintHeapType(out, type.heap_type());
diff --git a/src/wasm/value-type.h b/src/wasm/value-type.h
index 15ec301d2ee..769ac6b2c4d 100644
--- a/src/wasm/value-type.h
+++ b/src/wasm/value-type.h
@@ -29,9 +29,8 @@ class Simd128;
 // Format: kind, log2Size, code, machineType, shortName, typeName
 //
 // Some of these types are from proposals that are not standardized yet:
-// - "ref"/"optref" (a.k.a. "ref null") per
-//   https://github.com/WebAssembly/function-references
-// - "rtt" per https://github.com/WebAssembly/gc
+// - "ref"/"ref null" https://github.com/WebAssembly/function-references
+// - "rtt", "i8" and "i16" per https://github.com/WebAssembly/gc
 #define FOREACH_NUMERIC_VALUE_TYPE(V)    \
   V(I32, 2, I32, Int32, 'i', "i32")      \
   V(I64, 3, I64, Int64, 'l', "i64")      \
@@ -41,12 +40,12 @@ class Simd128;
   V(I8, 0, I8, Int8, 'b', "i8")          \
   V(I16, 1, I16, Int16, 'h', "i16")
 
-#define FOREACH_VALUE_TYPE(V)                                    \
-  V(Void, -1, Void, None, 'v', "<void>")                         \
-  FOREACH_NUMERIC_VALUE_TYPE(V)                                  \
-  V(Rtt, kTaggedSizeLog2, Rtt, TaggedPointer, 't', "rtt")        \
-  V(Ref, kTaggedSizeLog2, Ref, AnyTagged, 'r', "ref")            \
-  V(OptRef, kTaggedSizeLog2, OptRef, AnyTagged, 'n', "ref null") \
+#define FOREACH_VALUE_TYPE(V)                                      \
+  V(Void, -1, Void, None, 'v', "<void>")                           \
+  FOREACH_NUMERIC_VALUE_TYPE(V)                                    \
+  V(Rtt, kTaggedSizeLog2, Rtt, TaggedPointer, 't', "rtt")          \
+  V(Ref, kTaggedSizeLog2, Ref, AnyTagged, 'r', "ref")              \
+  V(RefNull, kTaggedSizeLog2, RefNull, AnyTagged, 'n', "ref null") \
   V(Bottom, -1, Void, None, '*', "<bot>")
 
 constexpr int kMaxValueTypeSize = 16;  // bytes
@@ -229,11 +228,11 @@ constexpr bool is_numeric(ValueKind kind) {
 }
 
 constexpr bool is_reference(ValueKind kind) {
-  return kind == kRef || kind == kOptRef || kind == kRtt;
+  return kind == kRef || kind == kRefNull || kind == kRtt;
 }
 
 constexpr bool is_object_reference(ValueKind kind) {
-  return kind == kRef || kind == kOptRef;
+  return kind == kRef || kind == kRefNull;
 }
 
 constexpr int value_kind_size_log2(ValueKind kind) {
@@ -334,7 +333,7 @@ class ValueType {
   static constexpr ValueType Ref(uint32_t heap_type, Nullability nullability) {
     DCHECK(HeapType(heap_type).is_valid());
     return ValueType(
-        KindField::encode(nullability == kNullable ? kOptRef : kRef) |
+        KindField::encode(nullability == kNullable ? kRefNull : kRef) |
         HeapTypeField::encode(heap_type));
   }
   static constexpr ValueType Ref(HeapType heap_type, Nullability nullability) {
@@ -348,7 +347,7 @@ class ValueType {
   }
 
   static constexpr ValueType FromIndex(ValueKind kind, uint32_t index) {
-    DCHECK(kind == kOptRef || kind == kRef || kind == kRtt);
+    DCHECK(kind == kRefNull || kind == kRef || kind == kRtt);
     return ValueType(KindField::encode(kind) | HeapTypeField::encode(index));
   }
 
@@ -366,11 +365,11 @@ class ValueType {
     return wasm::is_object_reference(kind());
   }
 
-  constexpr bool is_nullable() const { return kind() == kOptRef; }
+  constexpr bool is_nullable() const { return kind() == kRefNull; }
   constexpr bool is_non_nullable() const { return kind() == kRef; }
 
   constexpr bool is_reference_to(uint32_t htype) const {
-    return (kind() == kRef || kind() == kOptRef) &&
+    return (kind() == kRef || kind() == kRefNull) &&
            heap_representation() == htype;
   }
 
@@ -417,7 +416,7 @@ class ValueType {
   }
   constexpr Nullability nullability() const {
     DCHECK(is_object_reference());
-    return kind() == kOptRef ? kNullable : kNonNullable;
+    return kind() == kRefNull ? kNullable : kNonNullable;
   }
 
   // Useful when serializing this type to store it into a runtime object.
@@ -484,11 +483,11 @@ class ValueType {
   // For compatibility with the reftypes and exception-handling proposals, this
   // function prioritizes shorthand encodings
   // (e.g., Ref(HeapType::kFunc, kNullable).value_type_code will return
-  // kFuncrefCode and not kOptRefCode).
+  // kFuncrefCode and not kRefNullCode).
   constexpr ValueTypeCode value_type_code() const {
     DCHECK_NE(kBottom, kind());
     switch (kind()) {
-      case kOptRef:
+      case kRefNull:
         switch (heap_representation()) {
           case HeapType::kFunc:
             return kFuncRefCode;
@@ -505,7 +504,7 @@ class ValueType {
           case HeapType::kStringViewIter:
             return kStringViewIterCode;
           default:
-            return kOptRefCode;
+            return kRefNullCode;
         }
       case kRef:
         switch (heap_representation()) {
@@ -541,7 +540,7 @@ class ValueType {
         return heap_representation() != HeapType::kI31 &&
                heap_representation() != HeapType::kArray &&
                heap_representation() != HeapType::kData;
-      case kOptRef:
+      case kRefNull:
         return heap_representation() != HeapType::kFunc &&
                heap_representation() != HeapType::kEq &&
                heap_representation() != HeapType::kAny &&
@@ -561,9 +560,9 @@ class ValueType {
     std::ostringstream buf;
     switch (kind()) {
       case kRef:
-      case kOptRef:
+      case kRefNull:
         if (encoding_needs_heap_type()) {
-          buf << "(ref " << (kind() == kOptRef ? "null " : "")
+          buf << "(ref " << (kind() == kRefNull ? "null " : "")
               << heap_type().name() << ")";
         } else {
           buf << heap_type().name() << "ref";
diff --git a/src/wasm/wasm-constants.h b/src/wasm/wasm-constants.h
index a7e5fa9f8d7..d77513e210b 100644
--- a/src/wasm/wasm-constants.h
+++ b/src/wasm/wasm-constants.h
@@ -42,7 +42,7 @@ enum ValueTypeCode : uint8_t {
   // TODO(7748): For backwards compatibility only, remove when able.
   kAnyRefCodeAlias = 0x6e,
   kEqRefCode = 0x6d,
-  kOptRefCode = 0x6c,
+  kRefNullCode = 0x6c,
   kRefCode = 0x6b,
   kI31RefCode = 0x6a,
   // TODO(7748): Only here for backwards compatibility, remove when able.
diff --git a/src/wasm/wasm-debug.cc b/src/wasm/wasm-debug.cc
index 59cbc16c28c..01080566cac 100644
--- a/src/wasm/wasm-debug.cc
+++ b/src/wasm/wasm-debug.cc
@@ -598,7 +598,7 @@ class DebugInfoImpl {
       case kS128:
         return WasmValue(Simd128(ReadUnalignedValue<int16>(stack_address)));
       case kRef:
-      case kOptRef:
+      case kRefNull:
       case kRtt: {
         Handle<Object> obj(Object(ReadUnalignedValue<Address>(stack_address)),
                            isolate);
diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
index e864302a6a6..f66de4ef0b0 100644
--- a/src/wasm/wasm-js.cc
+++ b/src/wasm/wasm-js.cc
@@ -1543,7 +1543,7 @@ void WebAssemblyGlobal(const v8::FunctionCallbackInfo<v8::Value>& args) {
       break;
     }
     case i::wasm::kRef:
-    case i::wasm::kOptRef: {
+    case i::wasm::kRefNull: {
       switch (type.heap_representation()) {
         case i::wasm::HeapType::kAny: {
           if (args.Length() < 2) {
@@ -1778,7 +1778,7 @@ void EncodeExceptionValues(v8::Isolate* isolate,
         break;
       }
       case i::wasm::kRef:
-      case i::wasm::kOptRef:
+      case i::wasm::kRefNull:
         switch (type.heap_representation()) {
           case i::wasm::HeapType::kFunc:
           case i::wasm::HeapType::kAny:
@@ -2381,7 +2381,7 @@ void WebAssemblyExceptionGetArg(
         decode_index += 4;
         break;
       case i::wasm::kRef:
-      case i::wasm::kOptRef:
+      case i::wasm::kRefNull:
         switch (signature.get(i).heap_representation()) {
           case i::wasm::HeapType::kFunc:
           case i::wasm::HeapType::kAny:
@@ -2443,7 +2443,7 @@ void WebAssemblyExceptionGetArg(
       break;
     }
     case i::wasm::kRef:
-    case i::wasm::kOptRef:
+    case i::wasm::kRefNull:
       switch (signature.get(index).heap_representation()) {
         case i::wasm::HeapType::kFunc:
         case i::wasm::HeapType::kAny:
@@ -2526,7 +2526,7 @@ void WebAssemblyGlobalGetValueCommon(
       thrower.TypeError("Can't get the value of s128 WebAssembly.Global");
       break;
     case i::wasm::kRef:
-    case i::wasm::kOptRef:
+    case i::wasm::kRefNull:
       switch (receiver->type().heap_representation()) {
         case i::wasm::HeapType::kAny:
         case i::wasm::HeapType::kString:
@@ -2631,7 +2631,7 @@ void WebAssemblyGlobalSetValue(
       thrower.TypeError("Can't set the value of s128 WebAssembly.Global");
       break;
     case i::wasm::kRef:
-    case i::wasm::kOptRef:
+    case i::wasm::kRefNull:
       switch (receiver->type().heap_representation()) {
         case i::wasm::HeapType::kAny:
           receiver->SetExternRef(Utils::OpenHandle(*args[0]));
diff --git a/src/wasm/wasm-module-builder.cc b/src/wasm/wasm-module-builder.cc
index 8a6175047e3..994e7afcd14 100644
--- a/src/wasm/wasm-module-builder.cc
+++ b/src/wasm/wasm-module-builder.cc
@@ -506,7 +506,7 @@ void WriteInitializerExpressionWithEnd(ZoneBuffer* buffer,
           buffer->write_u8(kExprF64Const);
           buffer->write_f64(0.);
           break;
-        case kOptRef:
+        case kRefNull:
           buffer->write_u8(kExprRefNull);
           buffer->write_i32v(type.heap_type().code());
           break;
diff --git a/src/wasm/wasm-objects-inl.h b/src/wasm/wasm-objects-inl.h
index ef6f23fa6fc..da6cf65f12c 100644
--- a/src/wasm/wasm-objects-inl.h
+++ b/src/wasm/wasm-objects-inl.h
@@ -368,7 +368,7 @@ Handle<Object> WasmObject::ReadValueAt(Isolate* isolate, Handle<HeapObject> obj,
       UNREACHABLE();
 
     case wasm::kRef:
-    case wasm::kOptRef: {
+    case wasm::kRefNull: {
       ObjectSlot slot(field_address);
       return handle(slot.load(isolate), isolate);
     }
@@ -399,7 +399,7 @@ MaybeHandle<Object> WasmObject::ToWasmValue(Isolate* isolate,
       return BigInt::FromObject(isolate, value);
 
     case wasm::kRef:
-    case wasm::kOptRef: {
+    case wasm::kRefNull: {
       // TODO(v8:11804): implement ref type check
       UNREACHABLE();
     }
@@ -477,7 +477,7 @@ void WasmObject::WriteValueAt(Isolate* isolate, Handle<HeapObject> obj,
       break;
     }
     case wasm::kRef:
-    case wasm::kOptRef:
+    case wasm::kRefNull:
       // TODO(v8:11804): implement
       UNREACHABLE();
 
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 603c5537143..f89a876782c 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1566,7 +1566,7 @@ wasm::WasmValue WasmStruct::GetFieldValue(uint32_t index) {
     FOREACH_WASMVALUE_CTYPES(CASE_TYPE)
 #undef CASE_TYPE
     case wasm::kRef:
-    case wasm::kOptRef: {
+    case wasm::kRefNull: {
       Handle<Object> ref(TaggedField<Object>::load(*this, field_offset),
                          GetIsolateFromWritableObject(*this));
       return wasm::WasmValue(ref, field_type);
@@ -1595,7 +1595,7 @@ wasm::WasmValue WasmArray::GetElement(uint32_t index) {
     FOREACH_WASMVALUE_CTYPES(CASE_TYPE)
 #undef CASE_TYPE
     case wasm::kRef:
-    case wasm::kOptRef: {
+    case wasm::kRefNull: {
       Handle<Object> ref(TaggedField<Object>::load(*this, element_offset),
                          GetIsolateFromWritableObject(*this));
       return wasm::WasmValue(ref, element_type);
@@ -1864,7 +1864,7 @@ uint32_t WasmExceptionPackage::GetEncodedSize(const wasm::WasmTag* tag) {
         encoded_size += 8;
         break;
       case wasm::kRef:
-      case wasm::kOptRef:
+      case wasm::kRefNull:
         encoded_size += 1;
         break;
       case wasm::kRtt:
@@ -2274,7 +2274,7 @@ bool TypecheckJSObject(Isolate* isolate, const WasmModule* module,
                        const char** error_message) {
   DCHECK(expected.is_reference());
   switch (expected.kind()) {
-    case kOptRef:
+    case kRefNull:
       if (value->IsNull(isolate)) {
         HeapType::Representation repr = expected.heap_representation();
         switch (repr) {
diff --git a/src/wasm/wasm-subtyping.cc b/src/wasm/wasm-subtyping.cc
index 13b321dda4d..3268377649f 100644
--- a/src/wasm/wasm-subtyping.cc
+++ b/src/wasm/wasm-subtyping.cc
@@ -143,7 +143,7 @@ V8_NOINLINE V8_EXPORT_PRIVATE bool IsSubtypeOfImpl(
              EquivalentIndices(subtype.ref_index(), supertype.ref_index(),
                                sub_module, super_module);
     case kRef:
-    case kOptRef:
+    case kRefNull:
       break;
   }
 
diff --git a/src/wasm/wasm-subtyping.h b/src/wasm/wasm-subtyping.h
index d9634344929..6e61ef90ad1 100644
--- a/src/wasm/wasm-subtyping.h
+++ b/src/wasm/wasm-subtyping.h
@@ -28,7 +28,7 @@ V8_NOINLINE V8_EXPORT_PRIVATE bool IsHeapSubtypeOfImpl(
 // module2.
 // Type equivalence (~) is described by the following rules:
 // - Two numeric types are equivalent iff they are equal.
-// - T(ht1) ~ T(ht2) iff ht1 ~ ht2 for T in {ref, optref, rtt}.
+// - T(ht1) ~ T(ht2) iff ht1 ~ ht2 for T in {ref, ref null, rtt}.
 // Equivalence of heap types ht1 ~ ht2 is defined as follows:
 // - Two non-index heap types are equivalent iff they are equal.
 // - Two indexed heap types are equivalent iff they are iso-recursive
@@ -43,8 +43,8 @@ V8_NOINLINE V8_EXPORT_PRIVATE bool EquivalentTypes(ValueType type1,
 // Subtyping between value types is described by the following rules
 // (structural subtyping):
 // - numeric types are subtype-related iff they are equal.
-// - optref(ht1) <: optref(ht2) iff ht1 <: ht2.
-// - ref(ht1) <: ref/optref(ht2) iff ht1 <: ht2.
+// - (ref null ht1) <: (ref null ht2) iff ht1 <: ht2.
+// - (ref ht1) <: (ref null? ht2) iff ht1 <: ht2.
 // - rtt1 <: rtt2 iff rtt1 ~ rtt2.
 // For heap types, the following subtyping rules hold:
 // - The abstract heap types form the following type hierarchy:
diff --git a/src/wasm/wasm-value.h b/src/wasm/wasm-value.h
index b049ce392f1..e7f1b71b90b 100644
--- a/src/wasm/wasm-value.h
+++ b/src/wasm/wasm-value.h
@@ -199,7 +199,7 @@ class WasmValue {
         }
         return stream.str();
       }
-      case kOptRef:
+      case kRefNull:
       case kRef:
       case kRtt:
         return "Handle [" + std::to_string(to_ref().address()) + "]";
diff --git a/test/cctest/wasm/test-gc.cc b/test/cctest/wasm/test-gc.cc
index ad0c7fc900e..ecf56e0ed83 100644
--- a/test/cctest/wasm/test-gc.cc
+++ b/test/cctest/wasm/test-gc.cc
@@ -267,7 +267,7 @@ class WasmGCTester {
 ValueType ref(uint32_t type_index) {
   return ValueType::Ref(type_index, kNonNullable);
 }
-ValueType optref(uint32_t type_index) {
+ValueType refNull(uint32_t type_index) {
   return ValueType::Ref(type_index, kNullable);
 }
 
@@ -279,7 +279,7 @@ WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
   const byte empty_struct_index = tester.DefineStruct({});
   ValueType kRefType = ref(type_index);
   ValueType kEmptyStructType = ref(empty_struct_index);
-  ValueType kOptRefType = optref(type_index);
+  ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, &kRefType);
   FunctionSig sig_qe_v(1, 0, &kEmptyStructType);
 
@@ -324,7 +324,7 @@ WASM_COMPILED_EXEC_TEST(WasmBasicStruct) {
   const byte j_local_index = 0;
   const byte j_field_index = 0;
   const byte kSet = tester.DefineFunction(
-      tester.sigs.i_v(), {kOptRefType},
+      tester.sigs.i_v(), {kRefNullType},
       {WASM_LOCAL_SET(
            j_local_index,
            WASM_STRUCT_NEW_WITH_RTT(type_index, WASM_I32V(42), WASM_I32V(64),
@@ -355,11 +355,11 @@ WASM_COMPILED_EXEC_TEST(WasmRefAsNonNull) {
   const byte type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefTypes[] = {ref(type_index)};
-  ValueType kOptRefType = optref(type_index);
+  ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, kRefTypes);
 
   const byte global_index =
-      tester.AddGlobal(kOptRefType, true,
+      tester.AddGlobal(kRefNullType, true,
                        WasmInitExpr::RefNullConst(
                            static_cast<HeapType::Representation>(type_index)));
   const byte field_index = 0;
@@ -393,7 +393,7 @@ WASM_COMPILED_EXEC_TEST(WasmRefAsNonNullSkipCheck) {
   FunctionSig sig_q_v(1, 0, &kRefType);
 
   const byte global_index =
-      tester.AddGlobal(optref(type_index), true,
+      tester.AddGlobal(refNull(type_index), true,
                        WasmInitExpr::RefNullConst(
                            static_cast<HeapType::Representation>(type_index)));
   const byte kFunc = tester.DefineFunction(
@@ -412,11 +412,11 @@ WASM_COMPILED_EXEC_TEST(WasmBrOnNull) {
   const byte type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefTypes[] = {ref(type_index)};
-  ValueType kOptRefType = optref(type_index);
+  ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, kRefTypes);
   const byte local_index = 0;
   const byte kTaken = tester.DefineFunction(
-      tester.sigs.i_v(), {kOptRefType},
+      tester.sigs.i_v(), {kRefNullType},
       {WASM_BLOCK_I(WASM_I32V(42),
                     // Branch will be taken.
                     // 42 left on stack outside the block (not 52).
@@ -449,12 +449,12 @@ WASM_COMPILED_EXEC_TEST(WasmBrOnNonNull) {
   const byte type_index =
       tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefType = ref(type_index);
-  ValueType kOptRefType = optref(type_index);
+  ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, &kRefType);
   const byte field_index = 0;
 
   const byte kTaken = tester.DefineFunction(
-      tester.sigs.i_v(), {kOptRefType, kOptRefType},
+      tester.sigs.i_v(), {kRefNullType, kRefNullType},
       {WASM_LOCAL_SET(
            0, WASM_STRUCT_NEW_WITH_RTT(type_index, WASM_I32V(52), WASM_I32V(62),
                                        WASM_RTT_CANON(type_index))),
@@ -470,7 +470,7 @@ WASM_COMPILED_EXEC_TEST(WasmBrOnNonNull) {
        kExprEnd});
 
   const byte kNotTaken = tester.DefineFunction(
-      tester.sigs.i_v(), {kOptRefType, kOptRefType},
+      tester.sigs.i_v(), {kRefNullType, kRefNullType},
       {WASM_LOCAL_SET(0, WASM_REF_NULL(type_index)),
        WASM_LOCAL_SET(
            1, WASM_STRUCT_NEW_WITH_RTT(type_index, WASM_I32V(11), WASM_I32V(22),
@@ -791,12 +791,12 @@ WASM_COMPILED_EXEC_TEST(WasmRefEq) {
   WasmGCTester tester(execution_tier);
   byte type_index = tester.DefineStruct({F(kWasmI32, true), F(kWasmI32, true)});
   ValueType kRefTypes[] = {ref(type_index)};
-  ValueType kOptRefType = optref(type_index);
+  ValueType kRefNullType = refNull(type_index);
   FunctionSig sig_q_v(1, 0, kRefTypes);
 
   byte local_index = 0;
   const byte kFunc = tester.DefineFunction(
-      tester.sigs.i_v(), {kOptRefType},
+      tester.sigs.i_v(), {kRefNullType},
       {WASM_LOCAL_SET(local_index, WASM_STRUCT_NEW_WITH_RTT(
                                        type_index, WASM_I32V(55), WASM_I32V(66),
                                        WASM_RTT_CANON(type_index))),
@@ -831,7 +831,7 @@ WASM_COMPILED_EXEC_TEST(WasmPackedStructU) {
 
   const byte type_index = tester.DefineStruct(
       {F(kWasmI8, true), F(kWasmI16, true), F(kWasmI32, true)});
-  ValueType struct_type = optref(type_index);
+  ValueType struct_type = refNull(type_index);
 
   const byte local_index = 0;
 
@@ -868,7 +868,7 @@ WASM_COMPILED_EXEC_TEST(WasmPackedStructS) {
 
   const byte type_index = tester.DefineStruct(
       {F(kWasmI8, true), F(kWasmI16, true), F(kWasmI32, true)});
-  ValueType struct_type = optref(type_index);
+  ValueType struct_type = refNull(type_index);
 
   const byte local_index = 0;
 
@@ -989,12 +989,12 @@ WASM_COMPILED_EXEC_TEST(WasmBasicArray) {
   const byte immut_type_index = tester.DefineArray(wasm::kWasmI32, false);
   ValueType kRefTypes[] = {ref(type_index)};
   FunctionSig sig_q_v(1, 0, kRefTypes);
-  ValueType kOptRefType = optref(type_index);
+  ValueType kRefNullType = refNull(type_index);
 
   // f: a = [12, 12, 12]; a[1] = 42; return a[arg0]
   const byte local_index = 1;
   const byte kGetElem = tester.DefineFunction(
-      tester.sigs.i_i(), {kOptRefType},
+      tester.sigs.i_i(), {kRefNullType},
       {WASM_LOCAL_SET(local_index, WASM_ARRAY_NEW_WITH_RTT(
                                        type_index, WASM_I32V(12), WASM_I32V(3),
                                        WASM_RTT_CANON(type_index))),
@@ -1058,7 +1058,7 @@ WASM_COMPILED_EXEC_TEST(WasmBasicArray) {
   // f: a = [10.0, 10.0, 10.0]; a[1] = 42.42; return static_cast<int64>(a[1]);
   double result_value = 42.42;
   const byte kTestFpArray = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(fp_type_index)},
+      tester.sigs.i_v(), {refNull(fp_type_index)},
       {WASM_LOCAL_SET(0, WASM_ARRAY_NEW_WITH_RTT(
                              fp_type_index, WASM_F64(10.0), WASM_I32V(3),
                              WASM_RTT_CANON(fp_type_index))),
@@ -1107,7 +1107,7 @@ WASM_COMPILED_EXEC_TEST(WasmBasicArray) {
 WASM_COMPILED_EXEC_TEST(WasmPackedArrayU) {
   WasmGCTester tester(execution_tier);
   const byte array_index = tester.DefineArray(kWasmI8, true);
-  ValueType array_type = optref(array_index);
+  ValueType array_type = refNull(array_index);
 
   const byte param_index = 0;
   const byte local_index = 1;
@@ -1142,7 +1142,7 @@ WASM_COMPILED_EXEC_TEST(WasmPackedArrayU) {
 WASM_COMPILED_EXEC_TEST(WasmPackedArrayS) {
   WasmGCTester tester(execution_tier);
   const byte array_index = tester.DefineArray(kWasmI16, true);
-  ValueType array_type = optref(array_index);
+  ValueType array_type = refNull(array_index);
 
   int32_t array_elements[] = {0x12345678, 10, 0xFEDC, 0xFF1234};
 
@@ -1178,11 +1178,11 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
   WasmGCTester tester(execution_tier);
   const byte array32_index = tester.DefineArray(kWasmI32, true);
   const byte array16_index = tester.DefineArray(kWasmI16, true);
-  const byte arrayref_index = tester.DefineArray(optref(array32_index), true);
+  const byte arrayref_index = tester.DefineArray(refNull(array32_index), true);
 
   // Copies i32 ranges: local1[0..3] to local2[6..9].
   const byte kCopyI32 = tester.DefineFunction(
-      tester.sigs.i_i(), {optref(array32_index), optref(array32_index)},
+      tester.sigs.i_i(), {refNull(array32_index), refNull(array32_index)},
       {WASM_LOCAL_SET(
            1, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(array32_index, WASM_I32V(10),
                                               WASM_RTT_CANON(array32_index))),
@@ -1205,7 +1205,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
 
   // Copies i16 ranges: local1[0..3] to local2[6..9].
   const byte kCopyI16 = tester.DefineFunction(
-      tester.sigs.i_i(), {optref(array16_index), optref(array16_index)},
+      tester.sigs.i_i(), {refNull(array16_index), refNull(array16_index)},
       {WASM_LOCAL_SET(
            1, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(array16_index, WASM_I32V(10),
                                               WASM_RTT_CANON(array16_index))),
@@ -1228,8 +1228,8 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
 
   // Copies reference ranges: local1[0..3] to local2[6..9].
   const byte kCopyRef = tester.DefineFunction(
-      FunctionSig::Build(tester.zone(), {optref(array32_index)}, {kWasmI32}),
-      {optref(arrayref_index), optref(arrayref_index)},
+      FunctionSig::Build(tester.zone(), {refNull(array32_index)}, {kWasmI32}),
+      {refNull(arrayref_index), refNull(arrayref_index)},
       {WASM_LOCAL_SET(
            1, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(arrayref_index, WASM_I32V(10),
                                               WASM_RTT_CANON(arrayref_index))),
@@ -1260,8 +1260,8 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
 
   // Copies overlapping reference ranges: local1[0..3] to local1[2..5].
   const byte kCopyRefOverlapping = tester.DefineFunction(
-      FunctionSig::Build(tester.zone(), {optref(array32_index)}, {kWasmI32}),
-      {optref(arrayref_index)},
+      FunctionSig::Build(tester.zone(), {refNull(array32_index)}, {kWasmI32}),
+      {refNull(arrayref_index)},
       {WASM_LOCAL_SET(
            1, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(arrayref_index, WASM_I32V(10),
                                               WASM_RTT_CANON(arrayref_index))),
@@ -1288,7 +1288,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
        kExprEnd});
 
   const byte kOobSource = tester.DefineFunction(
-      tester.sigs.v_v(), {optref(array32_index), optref(array32_index)},
+      tester.sigs.v_v(), {refNull(array32_index), refNull(array32_index)},
       {WASM_LOCAL_SET(
            0, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(array32_index, WASM_I32V(10),
                                               WASM_RTT_CANON(array32_index))),
@@ -1301,7 +1301,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
        kExprEnd});
 
   const byte kOobDestination = tester.DefineFunction(
-      tester.sigs.v_v(), {optref(array32_index), optref(array32_index)},
+      tester.sigs.v_v(), {refNull(array32_index), refNull(array32_index)},
       {WASM_LOCAL_SET(
            0, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(array32_index, WASM_I32V(10),
                                               WASM_RTT_CANON(array32_index))),
@@ -1314,7 +1314,7 @@ WASM_COMPILED_EXEC_TEST(WasmArrayCopy) {
        kExprEnd});
 
   const byte kZeroLength = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(arrayref_index), optref(arrayref_index)},
+      tester.sigs.i_v(), {refNull(arrayref_index), refNull(arrayref_index)},
       {WASM_LOCAL_SET(
            0, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(arrayref_index, WASM_I32V(10),
                                               WASM_RTT_CANON(arrayref_index))),
@@ -1377,13 +1377,13 @@ WASM_COMPILED_EXEC_TEST(NewDefault) {
 
   tester.builder()->StartRecursiveTypeGroup();
   const byte struct_type = tester.DefineStruct(
-      {F(wasm::kWasmI32, true), F(wasm::kWasmF64, true), F(optref(0), true)});
+      {F(wasm::kWasmI32, true), F(wasm::kWasmF64, true), F(refNull(0), true)});
   tester.builder()->EndRecursiveTypeGroup();
 
   const byte array_type = tester.DefineArray(wasm::kWasmI32, true);
   // Returns: struct[0] + f64_to_i32(struct[1]) + (struct[2].is_null ^ 1) == 0.
   const byte allocate_struct = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(struct_type)},
+      tester.sigs.i_v(), {refNull(struct_type)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT_WITH_RTT(
                              struct_type, WASM_RTT_CANON(struct_type))),
        WASM_I32_ADD(
@@ -1395,7 +1395,7 @@ WASM_COMPILED_EXEC_TEST(NewDefault) {
                         WASM_I32V(1))),
        kExprEnd});
   const byte allocate_array = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(array_type)},
+      tester.sigs.i_v(), {refNull(array_type)},
       {WASM_LOCAL_SET(
            0, WASM_ARRAY_NEW_DEFAULT_WITH_RTT(array_type, WASM_I32V(2),
                                               WASM_RTT_CANON(array_type))),
@@ -1446,7 +1446,7 @@ WASM_COMPILED_EXEC_TEST(BasicRtt) {
   //   }
   // The expected return value is 1+42 = 43.
   const byte kRefCast = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(type_index)},
+      tester.sigs.i_v(), {refNull(type_index)},
       {WASM_LOCAL_SET(
            kStructIndexCode,
            WASM_STRUCT_NEW_WITH_RTT(subtype_index, WASM_I32V(11), WASM_I32V(42),
@@ -1608,7 +1608,7 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
       {WASM_REF_TEST_STATIC(WASM_REF_NULL(subtype_index), type_index),
        kExprEnd});
   const byte kRefTestUnrelatedNullable = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(subtype_index)},
+      tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
        WASM_REF_TEST_STATIC(WASM_LOCAL_GET(0), sig_index), kExprEnd});
   const byte kRefTestUnrelatedNull = tester.DefineFunction(
@@ -1636,7 +1636,7 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
                                  WASM_REF_NULL(subtype_index), type_index)),
                              kExprEnd});
   const byte kRefCastUnrelatedNullable = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(subtype_index)},
+      tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
        WASM_REF_IS_NULL(WASM_REF_CAST_STATIC(WASM_LOCAL_GET(0), sig_index)),
        kExprEnd});
@@ -1653,57 +1653,57 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
 
   const byte kBrOnCastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(subtype_index), WASM_REF_NULL(type_index),
+      {WASM_BLOCK_R(refNull(subtype_index), WASM_REF_NULL(type_index),
                     WASM_BR_ON_CAST_STATIC(0, subtype_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastUpcast = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(type_index), WASM_STRUCT_NEW_DEFAULT(subtype_index),
+      {WASM_BLOCK_R(refNull(type_index), WASM_STRUCT_NEW_DEFAULT(subtype_index),
                     WASM_BR_ON_CAST_STATIC(0, type_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastUpcastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(type_index), WASM_REF_NULL(subtype_index),
+      {WASM_BLOCK_R(refNull(type_index), WASM_REF_NULL(subtype_index),
                     WASM_BR_ON_CAST_STATIC(0, type_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastUnrelatedNullable = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(subtype_index)},
+      tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
-       WASM_BLOCK_R(optref(sig_index), WASM_LOCAL_GET(0),
+       WASM_BLOCK_R(refNull(sig_index), WASM_LOCAL_GET(0),
                     WASM_BR_ON_CAST_STATIC(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastUnrelatedNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(sig_index), WASM_REF_NULL(subtype_index),
+      {WASM_BLOCK_R(refNull(sig_index), WASM_REF_NULL(subtype_index),
                     WASM_BR_ON_CAST_STATIC(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastUnrelatedNonNullable = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(sig_index), WASM_STRUCT_NEW_DEFAULT(subtype_index),
+      {WASM_BLOCK_R(refNull(sig_index), WASM_STRUCT_NEW_DEFAULT(subtype_index),
                     WASM_BR_ON_CAST_STATIC(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastFailNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(type_index), WASM_REF_NULL(type_index),
+      {WASM_BLOCK_R(refNull(type_index), WASM_REF_NULL(type_index),
                     WASM_BR_ON_CAST_STATIC_FAIL(0, subtype_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastFailUpcast = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(subtype_index),
+      {WASM_BLOCK_R(refNull(subtype_index),
                     WASM_STRUCT_NEW_DEFAULT(subtype_index),
                     WASM_BR_ON_CAST_STATIC_FAIL(0, type_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
@@ -1711,29 +1711,29 @@ WASM_COMPILED_EXEC_TEST(RefTrivialCastsStatic) {
 
   const byte kBrOnCastFailUpcastNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(subtype_index), WASM_REF_NULL(subtype_index),
+      {WASM_BLOCK_R(refNull(subtype_index), WASM_REF_NULL(subtype_index),
                     WASM_BR_ON_CAST_STATIC_FAIL(0, type_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastFailUnrelatedNullable = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(subtype_index)},
+      tester.sigs.i_v(), {refNull(subtype_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_DEFAULT(subtype_index)),
-       WASM_BLOCK_R(optref(subtype_index), WASM_LOCAL_GET(0),
+       WASM_BLOCK_R(refNull(subtype_index), WASM_LOCAL_GET(0),
                     WASM_BR_ON_CAST_STATIC_FAIL(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastFailUnrelatedNull = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(subtype_index), WASM_REF_NULL(subtype_index),
+      {WASM_BLOCK_R(refNull(subtype_index), WASM_REF_NULL(subtype_index),
                     WASM_BR_ON_CAST_STATIC_FAIL(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
        WASM_DROP, WASM_I32V(1), WASM_END});
 
   const byte kBrOnCastFailUnrelatedNonNullable = tester.DefineFunction(
       tester.sigs.i_v(), {},
-      {WASM_BLOCK_R(optref(subtype_index),
+      {WASM_BLOCK_R(refNull(subtype_index),
                     WASM_STRUCT_NEW_DEFAULT(subtype_index),
                     WASM_BR_ON_CAST_STATIC_FAIL(0, sig_index), WASM_DROP,
                     WASM_RETURN(WASM_I32V(0))),
@@ -1877,7 +1877,7 @@ WASM_COMPILED_EXEC_TEST(NoDepthRtt) {
       &sig_t2_v_nd, {}, {WASM_RTT_CANON(subtype_index), kExprEnd});
 
   const byte kTestCanon = tester.DefineFunction(
-      tester.sigs.i_v(), {optref(type_index)},
+      tester.sigs.i_v(), {refNull(type_index)},
       {WASM_LOCAL_SET(0, WASM_STRUCT_NEW_WITH_RTT(
                              subtype_index, WASM_I32V(11), WASM_I32V(42),
                              WASM_RTT_CANON(subtype_index))),
@@ -2013,7 +2013,7 @@ WASM_COMPILED_EXEC_TEST(CallRef) {
 WASM_COMPILED_EXEC_TEST(CallReftypeParameters) {
   WasmGCTester tester(execution_tier);
   byte type_index = tester.DefineStruct({F(wasm::kWasmI32, true)});
-  ValueType kRefType{optref(type_index)};
+  ValueType kRefType{refNull(type_index)};
   ValueType sig_types[] = {kWasmI32, kRefType, kRefType, kRefType, kRefType,
                            kWasmI32, kWasmI32, kWasmI32, kWasmI32};
   FunctionSig sig(1, 8, sig_types);
@@ -2396,13 +2396,13 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
   byte sub_struct = tester.DefineStruct({F(kWasmI32, false), F(kWasmI32, true)},
                                         super_struct);
   FunctionSig* super_sig =
-      FunctionSig::Build(tester.zone(), {kWasmI32}, {optref(sub_struct)});
+      FunctionSig::Build(tester.zone(), {kWasmI32}, {refNull(sub_struct)});
   byte super_sig_index = tester.DefineSignature(super_sig);
   FunctionSig* sub_sig =
-      FunctionSig::Build(tester.zone(), {kWasmI32}, {optref(super_struct)});
+      FunctionSig::Build(tester.zone(), {kWasmI32}, {refNull(super_struct)});
   byte sub_sig_index = tester.DefineSignature(sub_sig, super_sig_index);
 
-  tester.DefineTable(optref(super_sig_index), 10, 10);
+  tester.DefineTable(refNull(super_sig_index), 10, 10);
 
   byte super_func = tester.DefineFunction(
       super_sig_index, {},
@@ -2471,9 +2471,9 @@ WASM_COMPILED_EXEC_TEST(GCTables) {
        WASM_END});
 
   // Only here so these functions count as "declared".
-  tester.AddGlobal(optref(super_sig_index), false,
+  tester.AddGlobal(refNull(super_sig_index), false,
                    WasmInitExpr::RefFuncConst(super_func));
-  tester.AddGlobal(optref(sub_sig_index), false,
+  tester.AddGlobal(refNull(sub_sig_index), false,
                    WasmInitExpr::RefFuncConst(sub_func));
 
   tester.CompileModule();
diff --git a/test/common/wasm/wasm-interpreter.cc b/test/common/wasm/wasm-interpreter.cc
index c5587fddc13..fafb43aadd1 100644
--- a/test/common/wasm/wasm-interpreter.cc
+++ b/test/common/wasm/wasm-interpreter.cc
@@ -1440,7 +1440,7 @@ class WasmInterpreterInternals {
     break;
         FOREACH_WASMVALUE_CTYPES(CASE_TYPE)
 #undef CASE_TYPE
-        case kOptRef: {
+        case kRefNull: {
           val = WasmValue(isolate_->factory()->null_value(), p);
           break;
         }
@@ -3205,7 +3205,7 @@ class WasmInterpreterInternals {
           break;
         }
         case kRef:
-        case kOptRef:
+        case kRefNull:
         case kRtt:
           encoded_values->set(encoded_index++, *value.to_ref());
           break;
@@ -3292,7 +3292,7 @@ class WasmInterpreterInternals {
           break;
         }
         case kRef:
-        case kOptRef:
+        case kRefNull:
         case kRtt: {
           Handle<Object> ref(encoded_values->get(encoded_index++), isolate_);
           value = WasmValue(ref, sig->GetParam(i));
@@ -3668,7 +3668,7 @@ class WasmInterpreterInternals {
             FOREACH_WASMVALUE_CTYPES(CASE_TYPE)
 #undef CASE_TYPE
             case kRef:
-            case kOptRef:
+            case kRefNull:
             case kRtt: {
               // TODO(7748): Type checks or DCHECKs for ref types?
               HandleScope handle_scope(isolate_);  // Avoid leaking handles.
@@ -4078,7 +4078,7 @@ class WasmInterpreterInternals {
         case kVoid:
           PrintF("void");
           break;
-        case kOptRef:
+        case kRefNull:
           if (val.to_ref()->IsNull()) {
             PrintF("ref:null");
             break;
diff --git a/test/common/wasm/wasm-macro-gen.h b/test/common/wasm/wasm-macro-gen.h
index 84e5e810a0c..01d10e370e3 100644
--- a/test/common/wasm/wasm-macro-gen.h
+++ b/test/common/wasm/wasm-macro-gen.h
@@ -113,8 +113,8 @@
 
 #define WASM_HEAP_TYPE(heap_type) static_cast<byte>((heap_type).code() & 0x7f)
 
-#define WASM_REF_TYPE(type)                       \
-  (type).kind() == kRef ? kRefCode : kOptRefCode, \
+#define WASM_REF_TYPE(type)                        \
+  (type).kind() == kRef ? kRefCode : kRefNullCode, \
       WASM_HEAP_TYPE((type).heap_type())
 
 #define WASM_BLOCK(...) kExprBlock, kVoidCode, __VA_ARGS__, kExprEnd
diff --git a/test/common/wasm/wasm-module-runner.cc b/test/common/wasm/wasm-module-runner.cc
index 56b5b2c52a0..797239270e7 100644
--- a/test/common/wasm/wasm-module-runner.cc
+++ b/test/common/wasm/wasm-module-runner.cc
@@ -66,7 +66,7 @@ base::OwnedVector<WasmValue> MakeDefaultInterpreterArguments(
         arguments[i] = WasmValue(Simd128{s128_bytes});
         break;
       }
-      case kOptRef:
+      case kRefNull:
         arguments[i] =
             WasmValue(Handle<Object>::cast(isolate->factory()->null_value()),
                       sig->GetParam(i));
@@ -102,7 +102,7 @@ base::OwnedVector<Handle<Object>> MakeDefaultArguments(Isolate* isolate,
       case kI64:
         arguments[i] = BigInt::FromInt64(isolate, static_cast<int64_t>(i));
         break;
-      case kOptRef:
+      case kRefNull:
         arguments[i] = isolate->factory()->null_value();
         break;
       case kRef:
diff --git a/test/fuzzer/wasm-compile.cc b/test/fuzzer/wasm-compile.cc
index 8d59325ba92..f487e339542 100644
--- a/test/fuzzer/wasm-compile.cc
+++ b/test/fuzzer/wasm-compile.cc
@@ -2040,7 +2040,7 @@ void WasmGenerator::Generate(ValueType type, DataRange* data) {
       return Generate<kF64>(data);
     case kS128:
       return Generate<kS128>(data);
-    case kOptRef:
+    case kRefNull:
       return GenerateRef(type.heap_type(), data, kNullable);
     case kRef:
       return GenerateRef(type.heap_type(), data, kNonNullable);
@@ -2361,7 +2361,7 @@ WasmInitExpr GenerateInitExpr(Zone* zone, WasmModuleBuilder* builder,
                               ValueType type,
                               uint32_t num_struct_and_array_types) {
   switch (type.kind()) {
-    case kOptRef:
+    case kRefNull:
       return WasmInitExpr::RefNullConst(type.heap_type().representation());
     case kI8:
     case kI16:
diff --git a/test/fuzzer/wasm-fuzzer-common.cc b/test/fuzzer/wasm-fuzzer-common.cc
index 9349fa9ecfe..19ef3f0975b 100644
--- a/test/fuzzer/wasm-fuzzer-common.cc
+++ b/test/fuzzer/wasm-fuzzer-common.cc
@@ -277,7 +277,7 @@ std::string ValueTypeToConstantName(ValueType type) {
       return "kWasmF64";
     case kS128:
       return "kWasmS128";
-    case kOptRef:
+    case kRefNull:
       switch (type.heap_representation()) {
         case HeapType::kFunc:
           return "kWasmFuncRef";
@@ -291,7 +291,7 @@ std::string ValueTypeToConstantName(ValueType type) {
         case HeapType::kArray:
         case HeapType::kI31:
         default:
-          return "wasmOptRefType(" + HeapTypeToConstantName(type.heap_type()) +
+          return "wasmRefNullType(" + HeapTypeToConstantName(type.heap_type()) +
                  ")";
       }
     case kRef:
diff --git a/test/mjsunit/regress/wasm/regress-1189454.js b/test/mjsunit/regress/wasm/regress-1189454.js
index f1adcbe5183..82829cbe752 100644
--- a/test/mjsunit/regress/wasm/regress-1189454.js
+++ b/test/mjsunit/regress/wasm/regress-1189454.js
@@ -15,7 +15,7 @@ var builder = new WasmModuleBuilder();
 
 builder.addStruct([makeField(kWasmI32, true)]);
 
-builder.addFunction('test', makeSig([wasmOptRefType(0)], [kWasmI32]))
+builder.addFunction('test', makeSig([wasmRefNullType(0)], [kWasmI32]))
     .addBody([
       kExprLocalGet, 0,
       kExprRefIsNull,
diff --git a/test/mjsunit/regress/wasm/regress-12945.js b/test/mjsunit/regress/wasm/regress-12945.js
index 707e7cc1d9c..8b0a20a730c 100644
--- a/test/mjsunit/regress/wasm/regress-12945.js
+++ b/test/mjsunit/regress/wasm/regress-12945.js
@@ -11,7 +11,7 @@ let i32_field = makeField(kWasmI32, true);
 let supertype = builder.addStruct([i32_field]);
 let sub1 = builder.addStruct([i32_field, i32_field], supertype);
 let sub2 = builder.addStruct([i32_field, makeField(kWasmF64, true)], supertype);
-let sig = makeSig([wasmOptRefType(supertype)], [kWasmI32]);
+let sig = makeSig([wasmRefNullType(supertype)], [kWasmI32]);
 
 let callee = builder.addFunction("callee", sig).addBody([
   kExprLocalGet, 0,
diff --git a/test/mjsunit/regress/wasm/regress-1299183.js b/test/mjsunit/regress/wasm/regress-1299183.js
index 1f3f74dbfa2..df76f5e2634 100644
--- a/test/mjsunit/regress/wasm/regress-1299183.js
+++ b/test/mjsunit/regress/wasm/regress-1299183.js
@@ -9,26 +9,70 @@ d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');
 const builder = new WasmModuleBuilder();
 builder.addStruct([]);
 builder.addType(makeSig([kWasmI32, kWasmI32, kWasmI32], [kWasmI32]));
-builder.addType(makeSig([kWasmAnyRef, kWasmFuncRef, kWasmExternRef], [wasmRefType(0)]));
-builder.addType(makeSig([kWasmI64, kWasmF32, kWasmS128, kWasmI32], [wasmRefType(1), wasmOptRefType(2), kWasmI64, wasmOptRefType(2), kWasmI64]));
-builder.addType(makeSig([], [wasmOptRefType(2), wasmOptRefType(2), kWasmF64, wasmOptRefType(2), kWasmI32, wasmOptRefType(2), kWasmI32, kWasmI32, wasmOptRefType(2), kWasmI32, kWasmI32, kWasmI64, kWasmI32, kWasmS128, wasmOptRefType(2)]));
+builder.addType(makeSig([kWasmAnyRef, kWasmFuncRef, kWasmExternRef],
+                        [wasmRefType(0)]));
+builder.addType(
+  makeSig([kWasmI64, kWasmF32, kWasmS128, kWasmI32],
+          [wasmRefType(1), wasmRefNullType(2), kWasmI64, wasmRefNullType(2),
+           kWasmI64]));
+builder.addType(
+  makeSig([],
+          [wasmRefNullType(2), wasmRefNullType(2), kWasmF64, wasmRefNullType(2),
+           kWasmI32, wasmRefNullType(2), kWasmI32, kWasmI32, wasmRefNullType(2),
+           kWasmI32, kWasmI32, kWasmI64, kWasmI32, kWasmS128,
+           wasmRefNullType(2)]));
 builder.addType(makeSig([], []));
-builder.addType(makeSig([wasmRefType(kWasmAnyRef)], [kWasmI32, kWasmI32, wasmRefType(1), wasmRefType(kWasmAnyRef), kWasmI32, wasmRefType(1), kWasmI64, wasmOptRefType(4), kWasmI32, wasmRefType(kWasmAnyRef), wasmOptRefType(4), kWasmI64, kWasmI64, wasmRefType(kWasmEqRef), kWasmI32]));
-builder.addType(makeSig([wasmRefType(kWasmEqRef), kWasmAnyRef, kWasmI32, kWasmI32], [wasmRefType(1), kWasmI64, wasmOptRefType(4), kWasmI32, wasmRefType(kWasmAnyRef), wasmOptRefType(4), kWasmI64, kWasmI64, wasmRefType(kWasmEqRef), kWasmI32]));
-builder.addType(makeSig([kWasmI32, kWasmI32, wasmRefType(1), wasmRefType(kWasmAnyRef), kWasmI32, wasmRefType(1), kWasmI64, wasmOptRefType(4), kWasmI32, wasmRefType(kWasmAnyRef), wasmOptRefType(4), kWasmI64, kWasmI64, wasmRefType(kWasmEqRef), kWasmI32], [kWasmI32]));
+builder.addType(
+  makeSig([wasmRefType(kWasmAnyRef)],
+          [kWasmI32, kWasmI32, wasmRefType(1), wasmRefType(kWasmAnyRef),
+           kWasmI32, wasmRefType(1), kWasmI64, wasmRefNullType(4), kWasmI32,
+           wasmRefType(kWasmAnyRef), wasmRefNullType(4), kWasmI64, kWasmI64,
+           wasmRefType(kWasmEqRef), kWasmI32]));
+builder.addType(
+  makeSig([wasmRefType(kWasmEqRef), kWasmAnyRef, kWasmI32, kWasmI32],
+          [wasmRefType(1), kWasmI64, wasmRefNullType(4), kWasmI32,
+           wasmRefType(kWasmAnyRef), wasmRefNullType(4), kWasmI64, kWasmI64,
+           wasmRefType(kWasmEqRef), kWasmI32]));
+builder.addType(
+  makeSig([kWasmI32, kWasmI32, wasmRefType(1), wasmRefType(kWasmAnyRef),
+           kWasmI32, wasmRefType(1), kWasmI64, wasmRefNullType(4), kWasmI32,
+           wasmRefType(kWasmAnyRef), wasmRefNullType(4), kWasmI64, kWasmI64,
+           wasmRefType(kWasmEqRef), kWasmI32],
+          [kWasmI32]));
 builder.addMemory(16, 32, false);
 builder.addTable(kWasmFuncRef, 4, 5, undefined)
 builder.addTable(kWasmFuncRef, 15, 25, undefined)
 builder.addTable(kWasmFuncRef, 1, 1, undefined)
 builder.addTable(kWasmFuncRef, 16, 17, undefined)
-builder.addActiveElementSegment(0, wasmI32Const(0), [[kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3]], kWasmFuncRef);
-builder.addActiveElementSegment(1, wasmI32Const(0), [[kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3], [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3], [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3], [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2]], kWasmFuncRef);
-builder.addActiveElementSegment(2, wasmI32Const(0), [[kExprRefFunc, 0]], kWasmFuncRef);
-builder.addActiveElementSegment(3, wasmI32Const(0), [[kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3], [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3], [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3], [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3]], kWasmFuncRef);
+builder.addActiveElementSegment(
+  0, wasmI32Const(0),
+  [[kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3]],
+  kWasmFuncRef);
+builder.addActiveElementSegment(
+  1, wasmI32Const(0),
+  [[kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3],
+   [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3],
+   [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3],
+   [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2]],
+  kWasmFuncRef);
+builder.addActiveElementSegment(
+  2, wasmI32Const(0), [[kExprRefFunc, 0]], kWasmFuncRef);
+builder.addActiveElementSegment(
+  3, wasmI32Const(0),
+  [[kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3],
+   [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3],
+   [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3],
+   [kExprRefFunc, 0], [kExprRefFunc, 1], [kExprRefFunc, 2], [kExprRefFunc, 3]],
+  kWasmFuncRef);
 builder.addTag(makeSig([], []));
 // Generate function 1 (out of 4).
 builder.addFunction(undefined, 1 /* sig */)
-  .addLocals(kWasmI64, 1).addLocals(wasmOptRefType(4), 1).addLocals(kWasmI32, 2).addLocals(kWasmI64, 1).addLocals(wasmOptRefType(4), 1).addLocals(kWasmI32, 1).addLocals(kWasmI64, 3).addLocals(kWasmI32, 1).addLocals(kWasmI64, 1).addLocals(kWasmI32, 1).addLocals(kWasmI64, 1).addLocals(wasmOptRefType(4), 1).addLocals(kWasmI64, 1)
+  .addLocals(kWasmI64, 1).addLocals(wasmRefNullType(4), 1)
+  .addLocals(kWasmI32, 2).addLocals(kWasmI64, 1)
+  .addLocals(wasmRefNullType(4), 1).addLocals(kWasmI32, 1)
+  .addLocals(kWasmI64, 3).addLocals(kWasmI32, 1).addLocals(kWasmI64, 1)
+  .addLocals(kWasmI32, 1).addLocals(kWasmI64, 1)
+  .addLocals(wasmRefNullType(4), 1).addLocals(kWasmI64, 1)
   .addBodyWithEnd([
 // signature: i_iii
 // body:
diff --git a/test/mjsunit/regress/wasm/regress-crbug-1339321.js b/test/mjsunit/regress/wasm/regress-crbug-1339321.js
index 38739c94c0c..1aaca4ee120 100644
--- a/test/mjsunit/regress/wasm/regress-crbug-1339321.js
+++ b/test/mjsunit/regress/wasm/regress-crbug-1339321.js
@@ -40,7 +40,7 @@ builder.addFunction("crash", kSig_v_v).exportFunc().addBody([
   kExprEnd,  // loop
 ]);
 
-let array_type = builder.addArray(wasmOptRefType(kSig_i_i), true);
+let array_type = builder.addArray(wasmRefNullType(kSig_i_i), true);
 builder.addFunction("array", kSig_l_v).exportFunc()
   .addLocals(kWasmI64, 10)
   .addBody([
diff --git a/test/mjsunit/regress/wasm/regress-inlining-throw.js b/test/mjsunit/regress/wasm/regress-inlining-throw.js
index 54762590e0d..bccc568334e 100644
--- a/test/mjsunit/regress/wasm/regress-inlining-throw.js
+++ b/test/mjsunit/regress/wasm/regress-inlining-throw.js
@@ -15,7 +15,7 @@ let subtype = builder.addStruct(
 let unused_type = builder.addStruct(
     [makeField(kWasmI32, true), makeField(kWasmF64, true)], supertype);
 
-let sig = makeSig([wasmOptRefType(supertype)], [kWasmI32]);
+let sig = makeSig([wasmRefNullType(supertype)], [kWasmI32]);
 
 let callee1 = builder.addFunction('callee1', sig).addBody([
     kExprBlock, kWasmRef, subtype,
diff --git a/test/mjsunit/regress/wasm/wasm-typer-incompatible-ref-cast.js b/test/mjsunit/regress/wasm/wasm-typer-incompatible-ref-cast.js
index 6de4a2e7d7c..d20ffcb38bb 100644
--- a/test/mjsunit/regress/wasm/wasm-typer-incompatible-ref-cast.js
+++ b/test/mjsunit/regress/wasm/wasm-typer-incompatible-ref-cast.js
@@ -12,7 +12,7 @@ let sub1 = builder.addStruct([makeField(kWasmI32, true)], supertype);
 let sub2 = builder.addStruct([makeField(kWasmF64, true)], supertype);
 
 let crash = builder.addFunction("crash", kSig_v_i).exportFunc()
- .addLocals(wasmOptRefType(sub1), 1)
+ .addLocals(wasmRefNullType(sub1), 1)
  .addBody([
    kGCPrefix, kExprStructNewDefault, sub1,
    kExprLocalSet, 1,
diff --git a/test/mjsunit/wasm/array-copy-benchmark.js b/test/mjsunit/wasm/array-copy-benchmark.js
index 92eb9662252..ea9cb6d88e8 100644
--- a/test/mjsunit/wasm/array-copy-benchmark.js
+++ b/test/mjsunit/wasm/array-copy-benchmark.js
@@ -23,10 +23,10 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   var builder = new WasmModuleBuilder();
   let struct_index = builder.addStruct([makeField(kWasmI32, true),
                                         makeField(kWasmI8, false)]);
-  let array_type = kWasmI32;  // Also try kWasmI64, wasmOptRefType(struct_index)
+  let array_type = kWasmI32;  // Also try kWasmI64, wasmRefNullType(struct_index)
   var array_index = builder.addArray(array_type, true);
-  var from = builder.addGlobal(wasmOptRefType(array_index), true);
-  var to = builder.addGlobal(wasmOptRefType(array_index), true);
+  var from = builder.addGlobal(wasmRefNullType(array_index), true);
+  var to = builder.addGlobal(wasmRefNullType(array_index), true);
 
   builder.addFunction("init", kSig_v_v)
     .addBody([
@@ -118,11 +118,11 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   var builder = new WasmModuleBuilder();
   let struct_index = builder.addStruct([makeField(kWasmI32, true),
                                         makeField(kWasmI8, false)]);
-  let array_type = test_object_type ? wasmOptRefType(struct_index) : kWasmI32;
+  let array_type = test_object_type ? wasmRefNullType(struct_index) : kWasmI32;
   var array_index = builder.addArray(array_type, true);
 
   let array_new = builder.addFunction(
-      "array_new", makeSig([], [wasmOptRefType(array_index)]))
+      "array_new", makeSig([], [wasmRefNullType(array_index)]))
     .addBody([
       ...wasmI32Const(array_length),
       kGCPrefix, kExprRttCanon, array_index,
@@ -130,7 +130,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     .exportFunc();
 
   builder.addFunction("loop_array_new", kSig_v_v)
-    .addLocals(wasmOptRefType(array_index), 1)
+    .addLocals(wasmRefNullType(array_index), 1)
     .addLocals(kWasmI32, 1)
     .addBody([
       kExprLoop, kWasmVoid,
@@ -160,11 +160,11 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   var builder = new WasmModuleBuilder();
   let struct_index = builder.addStruct([makeField(kWasmI32, true),
                                         makeField(kWasmI8, false)]);
-  let array_type = test_object_type ? wasmOptRefType(struct_index) : kWasmI32;
+  let array_type = test_object_type ? wasmRefNullType(struct_index) : kWasmI32;
   var array_index = builder.addArray(array_type, true);
 
   let array_new = builder.addFunction(
-      "array_new", makeSig([], [wasmOptRefType(array_index)]))
+      "array_new", makeSig([], [wasmRefNullType(array_index)]))
     .addBody([
       ...(test_object_type ? [kGCPrefix, kExprStructNewDefault, struct_index]
                            : wasmI32Const(10)),
@@ -174,7 +174,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     .exportFunc();
 
   builder.addFunction("loop_array_new", kSig_v_v)
-    .addLocals(wasmOptRefType(array_index), 1)
+    .addLocals(wasmRefNullType(array_index), 1)
     .addLocals(kWasmI32, 1)
     .addBody([
       kExprLoop, kWasmVoid,
diff --git a/test/mjsunit/wasm/array-init-from-segment.js b/test/mjsunit/wasm/array-init-from-segment.js
index eda459b2233..f2d16c09945 100644
--- a/test/mjsunit/wasm/array-init-from-segment.js
+++ b/test/mjsunit/wasm/array-init-from-segment.js
@@ -10,7 +10,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   print(arguments.callee.name);
   let builder = new WasmModuleBuilder();
   let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
-  let struct_type = wasmOptRefType(struct_type_index);
+  let struct_type = wasmRefNullType(struct_type_index);
   let array_type_index = builder.addArray(struct_type, true);
 
   function makeStruct(element) {
@@ -82,9 +82,9 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   print(arguments.callee.name);
   let builder = new WasmModuleBuilder();
   let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
-  let struct_type = wasmOptRefType(struct_type_index);
+  let struct_type = wasmRefNullType(struct_type_index);
   let array_type_index = builder.addArray(struct_type, true);
-  let array_type = wasmOptRefType(array_type_index);
+  let array_type = wasmRefNullType(array_type_index);
 
   function makeStruct(element) {
     return [...wasmI32Const(element),
@@ -163,12 +163,12 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   print(arguments.callee.name);
   let builder = new WasmModuleBuilder();
   let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
-  let struct_type = wasmOptRefType(struct_type_index);
+  let struct_type = wasmRefNullType(struct_type_index);
   let array_type_index = builder.addArray(struct_type, true);
 
   let passive_segment = builder.addPassiveElementSegment([
     [kExprRefNull, array_type_index]],
-    wasmOptRefType(array_type_index));
+    wasmRefNullType(array_type_index));
 
   builder.addFunction("mistyped", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
       .addBody([
@@ -191,7 +191,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   print(arguments.callee.name);
   let builder = new WasmModuleBuilder();
   let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
-  let struct_type = wasmOptRefType(struct_type_index);
+  let struct_type = wasmRefNullType(struct_type_index);
   let array_type_index = builder.addArray(struct_type, true);
 
   let passive_segment = builder.addPassiveElementSegment([
@@ -199,7 +199,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     struct_type_index);
 
   builder.addGlobal(
-    wasmOptRefType(array_type_index), false,
+    wasmRefNullType(array_type_index), false,
     [...wasmI32Const(0), ...wasmI32Const(1),
      kGCPrefix, kExprArrayNewElemStatic,
      array_type_index, passive_segment]);
@@ -212,9 +212,9 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   print(arguments.callee.name);
   let builder = new WasmModuleBuilder();
   let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
-  let struct_type = wasmOptRefType(struct_type_index);
+  let struct_type = wasmRefNullType(struct_type_index);
   let array_type_index = builder.addArray(struct_type, true);
-  let array_type = wasmOptRefType(array_type_index);
+  let array_type = wasmRefNullType(array_type_index);
 
   function makeStruct(element) {
     return [...wasmI32Const(element),
@@ -251,9 +251,9 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   print(arguments.callee.name);
   let builder = new WasmModuleBuilder();
   let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
-  let struct_type = wasmOptRefType(struct_type_index);
+  let struct_type = wasmRefNullType(struct_type_index);
   let array_type_index = builder.addArray(struct_type, true);
-  let array_type = wasmOptRefType(array_type_index);
+  let array_type = wasmRefNullType(array_type_index);
 
   function makeStruct(element) {
     return [...wasmI32Const(element),
@@ -290,9 +290,9 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   print(arguments.callee.name);
   let builder = new WasmModuleBuilder();
   let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
-  let struct_type = wasmOptRefType(struct_type_index);
+  let struct_type = wasmRefNullType(struct_type_index);
   let array_type_index = builder.addArray(struct_type, true);
-  let array_type = wasmOptRefType(array_type_index);
+  let array_type = wasmRefNullType(array_type_index);
 
   function makeStruct(element) {
     return [...wasmI32Const(element),
diff --git a/test/mjsunit/wasm/gc-experiments.js b/test/mjsunit/wasm/gc-experiments.js
index db7052a67a2..98b46558436 100644
--- a/test/mjsunit/wasm/gc-experiments.js
+++ b/test/mjsunit/wasm/gc-experiments.js
@@ -11,7 +11,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   let struct = builder.addStruct([makeField(kWasmI32, true)]);
 
   builder.addFunction("main", kSig_i_i)
-    .addLocals(wasmOptRefType(kWasmDataRef), 1)
+    .addLocals(wasmRefNullType(kWasmDataRef), 1)
     .addBody([
       kExprLocalGet, 0,
       kGCPrefix, kExprStructNew, struct,
diff --git a/test/mjsunit/wasm/gc-nominal.js b/test/mjsunit/wasm/gc-nominal.js
index 36c554ae93c..55d3d5f3310 100644
--- a/test/mjsunit/wasm/gc-nominal.js
+++ b/test/mjsunit/wasm/gc-nominal.js
@@ -18,8 +18,8 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   let array2 = builder.addArray(kWasmI32, true, array1);
 
   builder.addFunction("main", kSig_v_v)
-      .addLocals(wasmOptRefType(struct1), 1)
-      .addLocals(wasmOptRefType(array1), 1)
+      .addLocals(wasmRefNullType(struct1), 1)
+      .addLocals(wasmRefNullType(array1), 1)
       .addBody([
         // Check that we can create a struct with explicit RTT...
         kGCPrefix, kExprRttCanon, struct2, kGCPrefix,
diff --git a/test/mjsunit/wasm/gc-optimizations.js b/test/mjsunit/wasm/gc-optimizations.js
index 06231fc9a91..d9c548df2de 100644
--- a/test/mjsunit/wasm/gc-optimizations.js
+++ b/test/mjsunit/wasm/gc-optimizations.js
@@ -17,7 +17,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
                                   makeField(kWasmI32, true)]);
 
   builder.addFunction("main", makeSig([kWasmI32], [kWasmI32]))
-    .addLocals(wasmOptRefType(struct), 1)
+    .addLocals(wasmRefNullType(struct), 1)
     .addBody([
       kExprI32Const, 10,  // local1 = struct(10, 100);
       kExprI32Const, 100,
@@ -107,7 +107,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     .exportFunc();
 
   builder.addFunction("main_aliasing", kSig_i_v)
-    .addLocals(wasmOptRefType(struct), 1)
+    .addLocals(wasmRefNullType(struct), 1)
     .addBody([
       ...buildStruct(init_value_1), kExprLocalSet, 0,
       kExprLocalGet, 0, kExprRefAsNonNull,
@@ -132,12 +132,12 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   let replacing_value_1 = 55;
   let replacing_value_2 = 37;
 
-  let id = builder.addFunction("id", makeSig([wasmOptRefType(struct)],
-                                             [wasmOptRefType(struct)]))
+  let id = builder.addFunction("id", makeSig([wasmRefNullType(struct)],
+                                             [wasmRefNullType(struct)]))
       .addBody([kExprLocalGet, 0])
 
   builder.addFunction("main", kSig_i_v)
-    .addLocals(wasmOptRefType(struct), 2)
+    .addLocals(wasmRefNullType(struct), 2)
     .addBody([
       // We store a fresh struct in local0
       kExprI32Const, initial_value,
@@ -178,7 +178,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
   // parameter: unknown array index
   builder.addFunction("main", makeSig([kWasmI32], [kWasmI32]))
-    .addLocals(wasmOptRefType(array), 1)
+    .addLocals(wasmRefNullType(array), 1)
     .addBody([
       kExprI32Const, 5,
       kGCPrefix, kExprRttCanon, array,
@@ -260,15 +260,15 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   let value_1 = 55;
   let value_2 = 2;
 
-  let id = builder.addFunction("id", makeSig([wasmOptRefType(array)],
-                                             [wasmOptRefType(array)]))
+  let id = builder.addFunction("id", makeSig([wasmRefNullType(array)],
+                                             [wasmRefNullType(array)]))
       .addBody([kExprLocalGet, 0])
 
   // parameters: array, index
   let tester = builder.addFunction("tester",
       makeSig([wasmRefType(array), kWasmI32], [kWasmI32]))
-    .addLocals(wasmOptRefType(struct), 1)
-    .addLocals(wasmOptRefType(array), 1)
+    .addLocals(wasmRefNullType(struct), 1)
+    .addLocals(wasmRefNullType(array), 1)
     .addBody([
       // We store a fresh struct in local1
       kExprI32Const, 0,
@@ -323,7 +323,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
   let builder = new WasmModuleBuilder();
   let struct1 = builder.addStruct([makeField(kWasmI32, true)]);
-  let struct2 = builder.addStruct([makeField(wasmOptRefType(struct1), true)]);
+  let struct2 = builder.addStruct([makeField(wasmRefNullType(struct1), true)]);
 
   // TF should eliminate both allocations in this function.
   builder.addFunction("main", kSig_i_i)
@@ -348,7 +348,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
   let builder = new WasmModuleBuilder();
   let struct1 = builder.addStruct([makeField(kWasmI32, true)]);
-  let struct2 = builder.addStruct([makeField(wasmOptRefType(struct1), true)]);
+  let struct2 = builder.addStruct([makeField(wasmRefNullType(struct1), true)]);
 
   let nop = builder.addFunction("nop", kSig_v_v).addBody([]);
 
@@ -385,7 +385,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   ]);
 
   let global = builder.addGlobal(
-      wasmOptRefType(struct_2), true, [kExprRefNull, struct_2]);
+      wasmRefNullType(struct_2), true, [kExprRefNull, struct_2]);
 
   // The three alocations should be folded.
   builder.addFunction("main", kSig_i_i)
@@ -419,7 +419,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   let addToLocal = [kExprLocalGet, 1, kExprI32Add, kExprLocalSet, 1];
 
   builder.addFunction(
-      "main", makeSig([wasmOptRefType(super_struct)], [kWasmI32]))
+      "main", makeSig([wasmRefNullType(super_struct)], [kWasmI32]))
     .addLocals(kWasmI32, 1)
     .addBody([
       kExprLocalGet, 0,
@@ -440,7 +440,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
         kGCPrefix, kExprStructGet, sub_struct, 1,
         ...addToLocal,
 
-        kExprBlock, kWasmOptRef, super_struct,
+        kExprBlock, kWasmRefNull, super_struct,
           kExprLocalGet, 0,
           // This should also get optimized away.
           kGCPrefix, kExprBrOnCastStaticFail, 0, mid_struct,
diff --git a/test/mjsunit/wasm/inlining.js b/test/mjsunit/wasm/inlining.js
index eb6fd392274..2293afdeea5 100644
--- a/test/mjsunit/wasm/inlining.js
+++ b/test/mjsunit/wasm/inlining.js
@@ -367,7 +367,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   let struct = builder.addStruct([makeField(kWasmI32, true)]);
 
   let callee = builder
-    .addFunction("callee", makeSig([wasmOptRefType(struct)], [kWasmI32]))
+    .addFunction("callee", makeSig([wasmRefNullType(struct)], [kWasmI32]))
     .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0]);
 
   // When inlining "callee", TF should pass the real parameter type (ref 0) and
@@ -386,7 +386,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   let struct = builder.addStruct([makeField(kWasmI32, true)]);
 
   let callee = builder
-    .addFunction("callee", makeSig([wasmOptRefType(struct)], [kWasmI32]))
+    .addFunction("callee", makeSig([wasmRefNullType(struct)], [kWasmI32]))
     .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0]);
 
   // The allocation should be removed.
diff --git a/test/mjsunit/wasm/reference-globals.js b/test/mjsunit/wasm/reference-globals.js
index d7d5c32e6a4..235e8b55aa7 100644
--- a/test/mjsunit/wasm/reference-globals.js
+++ b/test/mjsunit/wasm/reference-globals.js
@@ -22,7 +22,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     builder.addGlobal(wasmRefType(sig_index), false,
                       [kExprRefFunc, addition_index.index])
            .exportAs("global");
-    builder.addGlobal(wasmOptRefType(wrong_sig_index), false)
+    builder.addGlobal(wasmRefNullType(wrong_sig_index), false)
       .exportAs("mistyped_global");
 
     return builder.instantiate({});
@@ -33,7 +33,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     () => {
       var builder = new WasmModuleBuilder();
       var sig_index = builder.addType(kSig_i_ii);
-      builder.addImportedGlobal("imports", "global", wasmOptRefType(sig_index),
+      builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                                 false);
       builder.instantiate(
         {imports: { global: exporting_instance.exports.mistyped_global }})},
@@ -46,7 +46,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     () => {
       var builder = new WasmModuleBuilder();
       var sig_index = builder.addType(kSig_i_i);
-      builder.addImportedGlobal("imports", "global", wasmOptRefType(sig_index),
+      builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                                 false);
       builder.instantiate(
         {imports: { global: exporting_instance.exports.global }})},
@@ -59,7 +59,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
     () => {
       var builder = new WasmModuleBuilder();
       var sig_index = builder.addType(kSig_i_ii);
-      builder.addImportedGlobal("imports", "global", wasmOptRefType(sig_index),
+      builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                                 false);
       builder.instantiate({imports: { global: 42 }})},
     WebAssembly.LinkError,
@@ -84,7 +84,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
     var sig_index = builder.addType(kSig_i_ii);
 
-    builder.addImportedGlobal("imports", "global", wasmOptRefType(sig_index),
+    builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                               false);
 
     builder.addFunction("test_import", kSig_i_ii)
@@ -113,7 +113,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
   var struct_index = builder.addStruct([{type: kWasmI32, mutability: false}]);
   var composite_struct_index = builder.addStruct(
       [{type: kWasmI32, mutability: false},
-       {type: wasmOptRefType(struct_index), mutability: false},
+       {type: wasmRefNullType(struct_index), mutability: false},
        {type: kWasmI8, mutability: true}]);
 
   let field1_value = 432;
@@ -224,7 +224,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
   var builder = new WasmModuleBuilder();
   var struct_index = builder.addStruct([{type: kWasmI32, mutability: false}]);
-  var array_index = builder.addArray(wasmOptRefType(struct_index), true);
+  var array_index = builder.addArray(wasmRefNullType(struct_index), true);
 
   let element0_value = 44;
   let element2_value = 55;
diff --git a/test/mjsunit/wasm/reference-tables.js b/test/mjsunit/wasm/reference-tables.js
index 5d16b54a638..423d10fcd33 100644
--- a/test/mjsunit/wasm/reference-tables.js
+++ b/test/mjsunit/wasm/reference-tables.js
@@ -19,7 +19,7 @@ d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');
         .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add])
         .exportFunc();
 
-    builder.addTable(wasmOptRefType(binary_type), 1, 100).exportAs('table');
+    builder.addTable(wasmRefNullType(binary_type), 1, 100).exportAs('table');
 
     return builder.instantiate({});
   })();
@@ -29,7 +29,7 @@ d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');
     var builder = new WasmModuleBuilder();
     var unary_type = builder.addType(kSig_i_i);
     builder.addImportedTable(
-        'imports', 'table', 1, 100, wasmOptRefType(unary_type));
+        'imports', 'table', 1, 100, wasmRefNullType(unary_type));
     builder.instantiate({imports: {table: exporting_instance.exports.table}})
   }, WebAssembly.LinkError, /imported table does not match the expected type/)
 
@@ -47,10 +47,10 @@ d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');
     var binary_type = builder.addType(kSig_i_ii);
 
     builder.addImportedTable(
-        'imports', 'table', 1, 100, wasmOptRefType(binary_type));
+        'imports', 'table', 1, 100, wasmRefNullType(binary_type));
 
     var table =
-        builder.addTable(wasmOptRefType(unary_type), 10).exportAs('table');
+        builder.addTable(wasmRefNullType(unary_type), 10).exportAs('table');
     builder.addTable(kWasmFuncRef, 1).exportAs('generic_table');
 
     builder
diff --git a/test/mjsunit/wasm/type-based-optimizations.js b/test/mjsunit/wasm/type-based-optimizations.js
index f5796968485..cf841ef5fa2 100644
--- a/test/mjsunit/wasm/type-based-optimizations.js
+++ b/test/mjsunit/wasm/type-based-optimizations.js
@@ -25,7 +25,7 @@ d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
 
   builder.addFunction("main", makeSig(
         [wasmRefType(bottom1), wasmRefType(bottom2)], [kWasmI32]))
-    .addLocals(wasmOptRefType(top), 1)
+    .addLocals(wasmRefNullType(top), 1)
     .addLocals(kWasmI32, 1)
     .addBody([
         // temp = x0;
diff --git a/test/mjsunit/wasm/wasm-gc-js-roundtrip.js b/test/mjsunit/wasm/wasm-gc-js-roundtrip.js
index 4c36fb1ea9e..6c19c66b415 100644
--- a/test/mjsunit/wasm/wasm-gc-js-roundtrip.js
+++ b/test/mjsunit/wasm/wasm-gc-js-roundtrip.js
@@ -52,7 +52,7 @@ let instance = (() => {
   };
 
   for (key in test_types) {
-    let type = wasmOptRefType(test_types[key]);
+    let type = wasmRefNullType(test_types[key]);
     builder.addFunction(key + '_id', makeSig([type], [type]))
         .addBody([kExprLocalGet, 0])
         .exportFunc();
diff --git a/test/mjsunit/wasm/wasm-module-builder.js b/test/mjsunit/wasm/wasm-module-builder.js
index b9f4737be62..42b7bf973a7 100644
--- a/test/mjsunit/wasm/wasm-module-builder.js
+++ b/test/mjsunit/wasm/wasm-module-builder.js
@@ -148,10 +148,10 @@ let kStringViewWtf8Code = kWasmStringViewWtf8 & kLeb128Mask;
 let kStringViewWtf16Code = kWasmStringViewWtf16 & kLeb128Mask;
 let kStringViewIterCode = kWasmStringViewIter & kLeb128Mask;
 
-let kWasmOptRef = 0x6c;
+let kWasmRefNull = 0x6c;
 let kWasmRef = 0x6b;
-function wasmOptRefType(heap_type) {
-  return {opcode: kWasmOptRef, heap_type: heap_type};
+function wasmRefNullType(heap_type) {
+  return {opcode: kWasmRefNull, heap_type: heap_type};
 }
 function wasmRefType(heap_type) {
   return {opcode: kWasmRef, heap_type: heap_type};
@@ -1371,7 +1371,7 @@ class WasmModuleBuilder {
       case kWasmS128:
         return [kSimdPrefix, kExprS128Const, ...(new Array(16).fill(0))];
       default:
-        if ((typeof type) != 'number' && type.opcode != kWasmOptRef) {
+        if ((typeof type) != 'number' && type.opcode != kWasmRefNull) {
           throw new Error("Non-defaultable type");
         }
         let heap_type = (typeof type) == 'number' ? type : type.heap_type;
diff --git a/test/unittests/wasm/function-body-decoder-unittest.cc b/test/unittests/wasm/function-body-decoder-unittest.cc
index 06fc92c322b..935e0b0a9be 100644
--- a/test/unittests/wasm/function-body-decoder-unittest.cc
+++ b/test/unittests/wasm/function-body-decoder-unittest.cc
@@ -3607,7 +3607,7 @@ TEST_F(FunctionBodyDecoderTest, UnpackPackedTypes) {
 ValueType ref(byte type_index) {
   return ValueType::Ref(type_index, kNonNullable);
 }
-ValueType optref(byte type_index) {
+ValueType refNull(byte type_index) {
   return ValueType::Ref(type_index, kNullable);
 }
 
@@ -3733,7 +3733,7 @@ TEST_F(FunctionBodyDecoderTest, RefEq) {
                                 ValueType::Ref(HeapType::kEq, kNonNullable),
                                 ValueType::Ref(HeapType::kI31, kNullable),
                                 ref(struct_type_index),
-                                optref(struct_type_index)};
+                                refNull(struct_type_index)};
   ValueType non_eqref_subtypes[] = {
       kWasmI32,
       kWasmI64,
@@ -4543,7 +4543,7 @@ TEST_F(FunctionBodyDecoderTest, MergeNullableTypes) {
   WASM_FEATURE_SCOPE(gc);
 
   byte struct_type_index = builder.AddStruct({F(kWasmI32, true)});
-  ValueType struct_type = optref(struct_type_index);
+  ValueType struct_type = refNull(struct_type_index);
   FunctionSig loop_sig(0, 1, &struct_type);
   byte loop_sig_index = builder.AddSignature(&loop_sig);
   // Verifies that when a loop consuming a nullable type is entered with a
@@ -4862,8 +4862,8 @@ TEST_F(WasmOpcodeLengthTest, SimdExpressions) {
 }
 
 TEST_F(WasmOpcodeLengthTest, IllegalRefIndices) {
-  ExpectFailure(kExprBlock, kOptRefCode, U32V_3(kV8MaxWasmTypes + 1));
-  ExpectFailure(kExprBlock, kOptRefCode, U32V_4(0x01000000));
+  ExpectFailure(kExprBlock, kRefNullCode, U32V_3(kV8MaxWasmTypes + 1));
+  ExpectFailure(kExprBlock, kRefNullCode, U32V_4(0x01000000));
 }
 
 TEST_F(WasmOpcodeLengthTest, GCOpcodes) {
diff --git a/test/unittests/wasm/module-decoder-unittest.cc b/test/unittests/wasm/module-decoder-unittest.cc
index f377f0236ea..499a2197b79 100644
--- a/test/unittests/wasm/module-decoder-unittest.cc
+++ b/test/unittests/wasm/module-decoder-unittest.cc
@@ -121,7 +121,7 @@ namespace module_decoder_unittest {
 #define FIELD_COUNT(count) U32V_1(count)
 #define STRUCT_FIELD(type, mutability) type, (mutability ? 1 : 0)
 #define WASM_REF(index) kRefCode, index
-#define WASM_OPT_REF(index) kOptRefCode, index
+#define WASM_OPT_REF(index) kRefNullCode, index
 #define WASM_STRUCT_DEF(...) kWasmStructTypeCode, __VA_ARGS__
 #define WASM_ARRAY_DEF(type, mutability) \
   kWasmArrayTypeCode, type, (mutability ? 1 : 0)
@@ -771,8 +771,8 @@ TEST_F(WasmModuleVerifyTest, RefNullGlobal) {
 
 TEST_F(WasmModuleVerifyTest, RefNullGlobalInvalid1) {
   WASM_FEATURE_SCOPE(typed_funcref);
-  static const byte data[] = {SECTION(Global, ENTRY_COUNT(1), kOptRefCode, 0, 1,
-                                      WASM_REF_NULL(0), kExprEnd)};
+  static const byte data[] = {SECTION(Global, ENTRY_COUNT(1), kRefNullCode, 0,
+                                      1, WASM_REF_NULL(0), kExprEnd)};
   ModuleResult result = DecodeModule(data, data + sizeof(data));
   EXPECT_NOT_OK(result, "Type index 0 is out of bounds");
 }
@@ -959,7 +959,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
-              kOptRefCode,           // field type: reference...
+              kRefNullCode,          // field type: reference...
               3,                     // ...to nonexistent type
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_oob_ref, "Type index 3 is out of bounds");
@@ -968,7 +968,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
-              kOptRefCode,           // field type: reference...
+              kRefNullCode,          // field type: reference...
               U32V_4(1234567),       // ...to a type > kV8MaxWasmTypes
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref, "greater than the maximum");
@@ -977,7 +977,7 @@ TEST_F(WasmModuleVerifyTest, InvalidStructTypeDef) {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmStructTypeCode,   // --
               U32V_1(1),             // field count
-              kOptRefCode,           // field type: reference...
+              kRefNullCode,          // field type: reference...
               kI32Code,              // ...to a non-referenceable type
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref2, "Unknown heap type");
@@ -1045,17 +1045,17 @@ TEST_F(WasmModuleVerifyTest, NominalStructTypeDef) {
 
               kWasmStructNominalCode,  // type1
               1,                       // field count
-              kOptRefCode, 1, 1,       // mut optref type1
+              kRefNullCode, 1, 1,      // mut (ref null type1)
               0,                       // supertype
 
               kWasmStructNominalCode,  // type 2
               1,                       // field count
-              kOptRefCode, 3, 1,       // mut optref type3
+              kRefNullCode, 3, 1,      // mut (ref null type3)
               0,                       // supertype
 
               kWasmStructNominalCode,  // type 3
               1,                       // field count
-              kOptRefCode, 2, 1,       // mut optref type2
+              kRefNullCode, 2, 1,      // mut (ref null type2)
               0)};                     // supertype
   EXPECT_VERIFIES(self_or_mutual_ref);
 
@@ -1064,17 +1064,17 @@ TEST_F(WasmModuleVerifyTest, NominalStructTypeDef) {
               ENTRY_COUNT(3),          // --
               kWasmStructNominalCode,  //
               1,                       // field count
-              kOptRefCode, 0, 0,       // ref type0
+              kRefNullCode, 0, 0,      // ref type0
               kDataRefCode,            // root of hierarchy
 
               kWasmStructNominalCode,  // --
               1,                       // field count
-              kOptRefCode, 2, 0,       // ref type2
+              kRefNullCode, 2, 0,      // ref type2
               0,                       // supertype
 
               kWasmStructNominalCode,  // --
               1,                       // field count
-              kOptRefCode, 1, 0,       // ref type1
+              kRefNullCode, 1, 0,      // ref type1
               0)};                     // supertype
   EXPECT_VERIFIES(mutual_ref_with_subtyping);
 
@@ -1121,12 +1121,12 @@ TEST_F(WasmModuleVerifyTest, NominalFunctionTypeDef) {
               1,                         // params count
               kRefCode, 0,               // ref #0
               1,                         // results count
-              kOptRefCode, 0,            // optref #0
+              kRefNullCode, 0,           // (ref null 0)
               kFuncRefCode,              // root of type hierarchy
 
               kWasmFunctionNominalCode,  // type #1
               1,                         // params count
-              kOptRefCode, 0,            // refined (contravariant)
+              kRefNullCode, 0,           // refined (contravariant)
               1,                         // results count
               kRefCode, 0,               // refined (covariant)
               0)};                       // supertype
@@ -1158,7 +1158,7 @@ TEST_F(WasmModuleVerifyTest, InvalidArrayTypeDef) {
   static const byte field_type_oob_ref[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
-              kOptRefCode,           // field type: reference...
+              kRefNullCode,          // field type: reference...
               3,                     // ...to nonexistent type
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_oob_ref, "Type index 3 is out of bounds");
@@ -1166,7 +1166,7 @@ TEST_F(WasmModuleVerifyTest, InvalidArrayTypeDef) {
   static const byte field_type_invalid_ref[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
-              kOptRefCode,           // field type: reference...
+              kRefNullCode,          // field type: reference...
               U32V_3(1234567),       // ...to a type > kV8MaxWasmTypes
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref, "Unknown heap type");
@@ -1174,7 +1174,7 @@ TEST_F(WasmModuleVerifyTest, InvalidArrayTypeDef) {
   static const byte field_type_invalid_ref2[] = {
       SECTION(Type, ENTRY_COUNT(1),  // --
               kWasmArrayTypeCode,    // --
-              kOptRefCode,           // field type: reference...
+              kRefNullCode,          // field type: reference...
               kI32Code,              // ...to a non-referenceable type
               1)};                   // mutability
   EXPECT_FAILURE_WITH_MSG(field_type_invalid_ref2, "Unknown heap type");
@@ -2203,10 +2203,10 @@ TEST_F(WasmModuleVerifyTest, TypedFunctionTable) {
 
   static const byte data[] = {
       SECTION(Type, ENTRY_COUNT(1), SIG_ENTRY_v_x(kI32Code)),
-      SECTION(Table,           // table section
-              ENTRY_COUNT(1),  // 1 table
-              kOptRefCode, 0,  // table 0: type
-              0, 10)};         // table 0: limits
+      SECTION(Table,            // table section
+              ENTRY_COUNT(1),   // 1 table
+              kRefNullCode, 0,  // table 0: type
+              0, 10)};          // table 0: limits
 
   ModuleResult result = DecodeModule(data, data + sizeof(data));
   EXPECT_OK(result);
@@ -2221,7 +2221,7 @@ TEST_F(WasmModuleVerifyTest, NullableTableIllegalInitializer) {
       ONE_EMPTY_FUNCTION(0),                         // function section
       SECTION(Table,                                 // table section
               ENTRY_COUNT(1),                        // 1 table
-              kOptRefCode, 0,                        // table 0: type
+              kRefNullCode, 0,                       // table 0: type
               0, 10,                                 // table 0: limits
               kExprRefFunc, 0, kExprEnd)};           // table 0: initializer
 
@@ -2236,9 +2236,9 @@ TEST_F(WasmModuleVerifyTest, IllegalTableTypes) {
 
   using Vec = std::vector<byte>;
 
-  static Vec table_types[] = {{kOptRefCode, 0},
-                              {kOptRefCode, 1},
-                              {kOptRefCode, kI31RefCode},
+  static Vec table_types[] = {{kRefNullCode, 0},
+                              {kRefNullCode, 1},
+                              {kRefNullCode, kI31RefCode},
                               {kI31RefCode},
                               {kRttCode, 0}};
 
diff --git a/test/unittests/wasm/subtyping-unittest.cc b/test/unittests/wasm/subtyping-unittest.cc
index 7b5490eec0e..24544c4ed2f 100644
--- a/test/unittests/wasm/subtyping-unittest.cc
+++ b/test/unittests/wasm/subtyping-unittest.cc
@@ -19,7 +19,7 @@ using FieldInit = std::pair<ValueType, bool>;
 constexpr ValueType ref(uint32_t index) {
   return ValueType::Ref(index, kNonNullable);
 }
-constexpr ValueType optRef(uint32_t index) {
+constexpr ValueType refNull(uint32_t index) {
   return ValueType::Ref(index, kNullable);
 }
 
@@ -75,17 +75,17 @@ TEST_F(WasmSubtypingTest, Subtyping) {
 
   // Set up two identical modules.
   for (WasmModule* module : {module1, module2}) {
-    /*  0 */ DefineStruct(module, {mut(ref(2)), immut(optRef(2))});
+    /*  0 */ DefineStruct(module, {mut(ref(2)), immut(refNull(2))});
     /*  1 */ DefineStruct(module, {mut(ref(2)), immut(ref(2))}, 0);
     /*  2 */ DefineArray(module, immut(ref(0)));
     /*  3 */ DefineArray(module, immut(ref(1)), 2);
     /*  4 */ DefineStruct(module, {mut(ref(2)), immut(ref(3)), immut(kWasmF64)},
                           1);
-    /*  5 */ DefineStruct(module, {mut(optRef(2)), immut(ref(2))});
+    /*  5 */ DefineStruct(module, {mut(refNull(2)), immut(ref(2))});
     /*  6 */ DefineArray(module, mut(kWasmI32));
     /*  7 */ DefineArray(module, immut(kWasmI32));
-    /*  8 */ DefineStruct(module, {mut(kWasmI32), immut(optRef(8))});
-    /*  9 */ DefineStruct(module, {mut(kWasmI32), immut(optRef(8))}, 8);
+    /*  8 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(8))});
+    /*  9 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(8))}, 8);
     /* 10 */ DefineSignature(module, {}, {});
     /* 11 */ DefineSignature(module, {kWasmI32}, {kWasmI32});
     /* 12 */ DefineSignature(module, {kWasmI32, kWasmI32}, {kWasmI32});
@@ -93,21 +93,21 @@ TEST_F(WasmSubtypingTest, Subtyping) {
     /* 14 */ DefineSignature(module, {ref(0)}, {kWasmI32}, 13);
     /* 15 */ DefineSignature(module, {ref(0)}, {ref(4)}, 16);
     /* 16 */ DefineSignature(module, {ref(0)}, {ref(0)});
-    /* 17 */ DefineStruct(module, {mut(kWasmI32), immut(optRef(17))});
+    /* 17 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))});
 
     // Rec. group.
-    /* 18 */ DefineStruct(module, {mut(kWasmI32), immut(optRef(17))}, 17,
+    /* 18 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))}, 17,
                           false);
-    /* 19 */ DefineArray(module, {mut(optRef(21))}, kNoSuperType, false);
+    /* 19 */ DefineArray(module, {mut(refNull(21))}, kNoSuperType, false);
     /* 20 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, kNoSuperType,
                              false);
     /* 21 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, 20, false);
     GetTypeCanonicalizer()->AddRecursiveGroup(module, 4);
 
     // Identical rec. group.
-    /* 22 */ DefineStruct(module, {mut(kWasmI32), immut(optRef(17))}, 17,
+    /* 22 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))}, 17,
                           false);
-    /* 23 */ DefineArray(module, {mut(optRef(25))}, kNoSuperType, false);
+    /* 23 */ DefineArray(module, {mut(refNull(25))}, kNoSuperType, false);
     /* 24 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, kNoSuperType,
                              false);
     /* 25 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, 24, false);
@@ -115,17 +115,17 @@ TEST_F(WasmSubtypingTest, Subtyping) {
 
     // Nonidentical rec. group: the last function extends a type outside the
     // recursive group.
-    /* 26 */ DefineStruct(module, {mut(kWasmI32), immut(optRef(17))}, 17,
+    /* 26 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))}, 17,
                           false);
-    /* 27 */ DefineArray(module, {mut(optRef(29))}, kNoSuperType, false);
+    /* 27 */ DefineArray(module, {mut(refNull(29))}, kNoSuperType, false);
     /* 28 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, kNoSuperType,
                              false);
     /* 29 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, 20, false);
     GetTypeCanonicalizer()->AddRecursiveGroup(module, 4);
 
-    /* 30 */ DefineStruct(module, {mut(kWasmI32), immut(optRef(18))}, 18);
-    /* 31 */ DefineStruct(module,
-                          {mut(ref(2)), immut(optRef(2)), immut(kWasmS128)}, 1);
+    /* 30 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(18))}, 18);
+    /* 31 */ DefineStruct(
+        module, {mut(ref(2)), immut(refNull(2)), immut(kWasmS128)}, 1);
   }
 
   constexpr ValueType numeric_types[] = {kWasmI32, kWasmI64, kWasmF32, kWasmF64,
@@ -133,9 +133,9 @@ TEST_F(WasmSubtypingTest, Subtyping) {
   constexpr ValueType ref_types[] = {
       kWasmFuncRef, kWasmEqRef,    kWasmI31Ref,  // --
       kWasmDataRef, kWasmArrayRef, kWasmAnyRef,  // --
-      optRef(0),    ref(0),                      // struct
-      optRef(2),    ref(2),                      // array
-      optRef(11),   ref(11)                      // signature
+      refNull(0),   ref(0),                      // struct
+      refNull(2),   ref(2),                      // array
+      refNull(11),  ref(11)                      // signature
   };
 
 // Some macros to help managing types and modules.
@@ -198,7 +198,7 @@ TEST_F(WasmSubtypingTest, Subtyping) {
       // externref/funcref/anyref/functions are not.
       SUBTYPE_IFF(ref_type, kWasmEqRef,
                   ref_type != kWasmFuncRef && ref_type != kWasmAnyRef &&
-                      ref_type != optRef(11) && ref_type != ref(11));
+                      ref_type != refNull(11) && ref_type != ref(11));
       // Non-nullable struct/array types are subtypes of dataref.
       SUBTYPE_IFF(ref_type, kWasmDataRef,
                   ref_type == kWasmDataRef || ref_type == kWasmArrayRef ||
@@ -208,7 +208,7 @@ TEST_F(WasmSubtypingTest, Subtyping) {
                   ref_type == kWasmArrayRef || ref_type == ref(2));
       // Functions are subtypes of funcref.
       SUBTYPE_IFF(ref_type, kWasmFuncRef,
-                  ref_type == kWasmFuncRef || ref_type == optRef(11) ||
+                  ref_type == kWasmFuncRef || ref_type == refNull(11) ||
                       ref_type == ref(11));
       // Each reference type is a subtype of itself.
       SUBTYPE(ref_type, ref_type);
@@ -238,24 +238,24 @@ TEST_F(WasmSubtypingTest, Subtyping) {
 
     // Unrelated refs are unrelated.
     NOT_VALID_SUBTYPE(ref(0), ref(2));
-    NOT_VALID_SUBTYPE(optRef(3), optRef(1));
-    // ref is a subtype of optref for the same struct/array.
-    VALID_SUBTYPE(ref(0), optRef(0));
-    VALID_SUBTYPE(ref(2), optRef(2));
-    // optref is not a subtype of ref for the same struct/array.
-    NOT_SUBTYPE(optRef(0), ref(0));
-    NOT_SUBTYPE(optRef(2), ref(2));
-    // ref is a subtype of optref if the same is true for the underlying
+    NOT_VALID_SUBTYPE(refNull(3), refNull(1));
+    // ref is a subtype of ref null for the same struct/array.
+    VALID_SUBTYPE(ref(0), refNull(0));
+    VALID_SUBTYPE(ref(2), refNull(2));
+    // ref null is not a subtype of ref for the same struct/array.
+    NOT_SUBTYPE(refNull(0), ref(0));
+    NOT_SUBTYPE(refNull(2), ref(2));
+    // ref is a subtype of ref null if the same is true for the underlying
     // structs/arrays.
-    VALID_SUBTYPE(ref(3), optRef(2));
+    VALID_SUBTYPE(ref(3), refNull(2));
     // Prefix subtyping for structs.
-    VALID_SUBTYPE(optRef(4), optRef(0));
+    VALID_SUBTYPE(refNull(4), refNull(0));
     // Mutable fields are invariant.
     NOT_VALID_SUBTYPE(ref(0), ref(5));
     // Immutable fields are covariant.
     VALID_SUBTYPE(ref(1), ref(0));
     // Prefix subtyping + immutable field covariance for structs.
-    VALID_SUBTYPE(optRef(4), optRef(1));
+    VALID_SUBTYPE(refNull(4), refNull(1));
     // No subtyping between mutable/immutable fields.
     NOT_VALID_SUBTYPE(ref(7), ref(6));
     NOT_VALID_SUBTYPE(ref(6), ref(7));
@@ -417,19 +417,19 @@ TEST_F(WasmSubtypingTest, Subtyping) {
 
     // Concrete types of the same kind.
     // Subtyping relation.
-    UNION(optRef(4), ref(1), optRef(1));
-    INTERSECTION_M(optRef(4), ref(1), ref(4), module1);
-    INTERSECTION_M(optRef(1), optRef(4), optRef(4), module);
+    UNION(refNull(4), ref(1), refNull(1));
+    INTERSECTION_M(refNull(4), ref(1), ref(4), module1);
+    INTERSECTION_M(refNull(1), refNull(4), refNull(4), module);
     // Common ancestor.
     UNION(ref(4), ref(31), ref(1));
     INTERSECTION(ref(4), ref(31), kWasmBottom);
     // No common ancestor.
-    UNION(ref(6), optRef(2), kWasmArrayRef.AsNullable());
-    INTERSECTION(ref(6), optRef(2), kWasmBottom);
+    UNION(ref(6), refNull(2), kWasmArrayRef.AsNullable());
+    INTERSECTION(ref(6), refNull(2), kWasmBottom);
     UNION(ref(0), ref(17), kWasmDataRef);
     INTERSECTION(ref(0), ref(17), kWasmBottom);
-    UNION(ref(10), optRef(11), kWasmFuncRef);
-    INTERSECTION(ref(10), optRef(11), kWasmBottom);
+    UNION(ref(10), refNull(11), kWasmFuncRef);
+    INTERSECTION(ref(10), refNull(11), kWasmBottom);
   }
 #undef SUBTYPE
 #undef NOT_SUBTYPE
-- 
2.35.1


From 06d8a985d8180221c7c5a227b49c6d8b8c938c53 Mon Sep 17 00:00:00 2001
From: Lu Yahan <yahan@iscas.ac.cn>
Date: Fri, 27 Oct 2023 19:05:19 +0800
Subject: [PATCH] [wasm][riscv] Add platform-specific support for the
 wasm-to-js wrapper

Port commit 93bb287c2fef9c52760940895e82759f780ec93f

Also add check_nanbox argument to control WriteMem<Float32> in simulator. FSW/C_FSWSP should not be checked and converted.

Bug: v8:14035
Change-Id: I82a675b891abfbbe8cc3d37161617f98321ff321
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4974898
Reviewed-by: Ji Qiu <qiuji@iscas.ac.cn>
Auto-Submit: Yahan Lu <yahan@iscas.ac.cn>
Reviewed-by: Clemens Backes <clemensb@chromium.org>
Commit-Queue: Clemens Backes <clemensb@chromium.org>
Cr-Commit-Position: refs/heads/main@{#90657}
---
 src/builtins/riscv/builtins-riscv.cc          | 22 ++++++++++++++++++-
 src/codegen/riscv/register-riscv.h            |  2 +-
 .../backend/riscv/code-generator-riscv.cc     | 11 +++++++++-
 src/execution/riscv/simulator-riscv.cc        | 12 ++++++----
 src/execution/riscv/simulator-riscv.h         |  2 +-
 .../riscv/liftoff-assembler-riscv32-inl.h     |  8 +++----
 src/wasm/wasm-linkage.h                       |  2 +-
 src/wasm/wasm-objects.cc                      |  2 +-
 test/inspector/inspector.status               | 11 ++++++++--
 9 files changed, 56 insertions(+), 16 deletions(-)

diff --git a/src/builtins/riscv/builtins-riscv.cc b/src/builtins/riscv/builtins-riscv.cc
index 8279c5867b1..08e145eaebf 100644
--- a/src/builtins/riscv/builtins-riscv.cc
+++ b/src/builtins/riscv/builtins-riscv.cc
@@ -3227,7 +3227,27 @@ void Builtins::Generate_WasmReturnPromiseOnSuspendAsm(MacroAssembler* masm) {
   __ Trap();
 }
 
-void Builtins::Generate_WasmToJsWrapperAsm(MacroAssembler* masm) { __ Trap(); }
+void Builtins::Generate_WasmToJsWrapperAsm(MacroAssembler* masm) {
+  int required_stack_space = arraysize(wasm::kFpParamRegisters) * kDoubleSize;
+  __ SubWord(sp, sp, Operand(required_stack_space));
+  for (int i = 0; i < static_cast<int>(arraysize(wasm::kFpParamRegisters));
+       ++i) {
+    __ StoreDouble(wasm::kFpParamRegisters[i], MemOperand(sp, i * kDoubleSize));
+  }
+
+  constexpr int num_gp = arraysize(wasm::kGpParamRegisters) - 1;
+  required_stack_space = num_gp * kSystemPointerSize;
+  __ SubWord(sp, sp, Operand(required_stack_space));
+  for (int i = 1; i < static_cast<int>(arraysize(wasm::kGpParamRegisters));
+       ++i) {
+    __ StoreWord(wasm::kGpParamRegisters[i],
+                 MemOperand(sp, (i - 1) * kSystemPointerSize));
+  }
+  // Decrement the stack to allocate a stack slot. The signature gets written
+  // into the slot in Torque.
+  __ Push(zero_reg);
+  __ TailCallBuiltin(Builtin::kWasmToJsWrapperCSA);
+}
 
 void Builtins::Generate_WasmTrapHandlerLandingPad(MacroAssembler* masm) {
   __ Trap();
diff --git a/src/codegen/riscv/register-riscv.h b/src/codegen/riscv/register-riscv.h
index 85c1c5b75dd..30f480971e9 100644
--- a/src/codegen/riscv/register-riscv.h
+++ b/src/codegen/riscv/register-riscv.h
@@ -304,7 +304,7 @@ constexpr Register kJavaScriptCallExtraArg1Register = a2;
 constexpr Register kRuntimeCallFunctionRegister = a1;
 constexpr Register kRuntimeCallArgCountRegister = a0;
 constexpr Register kRuntimeCallArgvRegister = a2;
-constexpr Register kWasmInstanceRegister = a0;
+constexpr Register kWasmInstanceRegister = a7;
 constexpr Register kWasmCompileLazyFuncIndexRegister = t0;
 
 constexpr DoubleRegister kFPReturnRegister0 = fa0;
diff --git a/src/compiler/backend/riscv/code-generator-riscv.cc b/src/compiler/backend/riscv/code-generator-riscv.cc
index 780bae074ee..8839833a1da 100644
--- a/src/compiler/backend/riscv/code-generator-riscv.cc
+++ b/src/compiler/backend/riscv/code-generator-riscv.cc
@@ -4486,7 +4486,16 @@ void CodeGenerator::AssembleMove(InstructionOperand* source,
       FPURegister src = g.ToDoubleRegister(source);
       if (destination->IsFPRegister()) {
         FPURegister dst = g.ToDoubleRegister(destination);
-        __ Move(dst, src);
+        if (rep == MachineRepresentation::kFloat32) {
+          // In src/builtins/wasm-to-js.tq:193
+          //*toRef =
+          //Convert<intptr>(Bitcast<uint32>(WasmTaggedToFloat32(retVal))); so
+          // high 32 of src is 0. fmv.s can't NaNBox src.
+          __ fmv_x_w(kScratchReg, src);
+          __ fmv_w_x(dst, kScratchReg);
+        } else {
+          __ MoveDouble(dst, src);
+        }
       } else {
         DCHECK(destination->IsFPStackSlot());
         if (rep == MachineRepresentation::kFloat32) {
diff --git a/src/execution/riscv/simulator-riscv.cc b/src/execution/riscv/simulator-riscv.cc
index 5b5411cb3e2..68416027d3d 100644
--- a/src/execution/riscv/simulator-riscv.cc
+++ b/src/execution/riscv/simulator-riscv.cc
@@ -2540,9 +2540,12 @@ float Simulator::get_fpu_register_float(int fpureg) const {
   return *base::bit_cast<float*>(const_cast<int64_t*>(&FPUregisters_[fpureg]));
 }
 
-Float32 Simulator::get_fpu_register_Float32(int fpureg) const {
+// Fix NaN boxing error according to
+// https://github.com/riscv/riscv-isa-manual/blob/main/src/d-st-ext.adoc#nan-boxing-of-narrower-values"
+Float32 Simulator::get_fpu_register_Float32(int fpureg,
+                                            bool check_nanbox) const {
   DCHECK((fpureg >= 0) && (fpureg < kNumFPURegisters));
-  if (!is_boxed_float(FPUregisters_[fpureg])) {
+  if (check_nanbox && !is_boxed_float(FPUregisters_[fpureg])) {
     std::cout << std::hex << FPUregisters_[fpureg] << std::endl;
     return Float32::FromBits(0x7fc00000);
   }
@@ -5082,7 +5085,8 @@ void Simulator::DecodeRVSType() {
 #endif /*V8_TARGET_ARCH_RISCV64*/
     // TODO(riscv): use F Extension macro block
     case RO_FSW: {
-      WriteMem<Float32>(rs1() + s_imm12(), get_fpu_register_Float32(rs2_reg()),
+      WriteMem<Float32>(rs1() + s_imm12(),
+                        get_fpu_register_Float32(rs2_reg(), false),
                         instr_.instr());
       break;
     }
@@ -5328,7 +5332,7 @@ void Simulator::DecodeCSSType() {
 #if V8_TARGET_ARCH_RISCV32
     case RO_C_FSWSP: {
       sreg_t addr = get_register(sp) + rvc_imm6_sdsp();
-      WriteMem<Float32>(addr, get_fpu_register_Float32(rvc_rs2_reg()),
+      WriteMem<Float32>(addr, get_fpu_register_Float32(rvc_rs2_reg(), false),
                         instr_.instr());
       break;
     }
diff --git a/src/execution/riscv/simulator-riscv.h b/src/execution/riscv/simulator-riscv.h
index 38ea7e41277..20a5d83eab1 100644
--- a/src/execution/riscv/simulator-riscv.h
+++ b/src/execution/riscv/simulator-riscv.h
@@ -432,7 +432,7 @@ class Simulator : public SimulatorBase {
   int32_t get_fpu_register_signed_word(int fpureg) const;
   int32_t get_fpu_register_hi_word(int fpureg) const;
   float get_fpu_register_float(int fpureg) const;
-  Float32 get_fpu_register_Float32(int fpureg) const;
+  Float32 get_fpu_register_Float32(int fpureg, bool check_nanbox = true) const;
   double get_fpu_register_double(int fpureg) const;
   Float64 get_fpu_register_Float64(int fpureg) const;
 
diff --git a/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h b/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h
index 8f1dc808938..6aa2149106f 100644
--- a/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h
+++ b/src/wasm/baseline/riscv/liftoff-assembler-riscv32-inl.h
@@ -9,7 +9,6 @@
 #include "src/wasm/baseline/liftoff-assembler.h"
 #include "src/wasm/baseline/riscv/liftoff-assembler-riscv-inl.h"
 #include "src/wasm/wasm-objects.h"
-
 namespace v8::internal::wasm {
 
 namespace liftoff {
@@ -421,16 +420,17 @@ inline void AtomicBinop64(LiftoffAssembler* lasm, Register dst_addr,
                           Register offset_reg, uintptr_t offset_imm,
                           LiftoffRegister value, LiftoffRegister result,
                           StoreType type, Binop op) {
+  ASM_CODE_COMMENT(lasm);
   FrameScope scope(lasm, StackFrame::MANUAL);
   RegList c_params = {arg_reg_1, arg_reg_2, arg_reg_3};
   RegList result_list = {result.low_gp(), result.high_gp()};
-
   // Result registers does not need to be pushed.
   __ MultiPush(c_params - result_list);
   liftoff::CalculateActualAddress(lasm, dst_addr, offset_reg, offset_imm,
-                                  arg_reg_1);
+                                  kScratchReg);
   __ Mv(arg_reg_2, value.low_gp());
   __ Mv(arg_reg_3, value.high_gp());
+  __ Mv(arg_reg_1, kScratchReg);
   __ MultiPush(kJSCallerSaved - c_params - result_list);
   __ PrepareCallCFunction(3, 0, kScratchReg);
   ExternalReference extern_func_ref;
@@ -869,11 +869,11 @@ void LiftoffAssembler::AtomicCompareExchange(
     RegList result_list = {result.low_gp(), result.high_gp()};
     MultiPush(c_params - result_list);
 
-    Mv(a0, actual_addr);
     Mv(a1, expected.low_gp());
     Mv(a2, expected.high_gp());
     Mv(a3, new_value.low_gp());
     Mv(a4, new_value.high_gp());
+    Mv(a0, actual_addr);
 
     MultiPush(kJSCallerSaved - c_params - result_list);
     PrepareCallCFunction(5, 0, kScratchReg);
diff --git a/src/wasm/wasm-linkage.h b/src/wasm/wasm-linkage.h
index af33a1688cf..2c77f59c6f1 100644
--- a/src/wasm/wasm-linkage.h
+++ b/src/wasm/wasm-linkage.h
@@ -112,7 +112,7 @@ constexpr DoubleRegister kFpReturnRegisters[] = {d0, d2};
 // ===========================================================================
 // Note that kGpParamRegisters and kFpParamRegisters are used in
 // Builtins::Generate_WasmCompileLazy (builtins-riscv.cc)
-constexpr Register kGpParamRegisters[] = {a0, a2, a3, a4, a5, a6, a7};
+constexpr Register kGpParamRegisters[] = {a7, a0, a2, a3, a4, a5, a6};
 constexpr Register kGpReturnRegisters[] = {a0, a1};
 constexpr DoubleRegister kFpParamRegisters[] = {fa0, fa1, fa2, fa3,
                                                 fa4, fa5, fa6, fa7};
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 86c6eddb1b9..fcb2a010428 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -1982,7 +1982,7 @@ bool UseGenericWasmToJSWrapper(wasm::ImportCallKind kind,
     return false;
   }
 #if !V8_TARGET_ARCH_X64 && !V8_TARGET_ARCH_ARM64 && !V8_TARGET_ARCH_ARM && \
-    !V8_TARGET_ARCH_IA32
+    !V8_TARGET_ARCH_IA32 && !V8_TARGET_ARCH_RISCV64 && !V8_TARGET_ARCH_RISCV32
   return false;
 #else
   if (suspend == wasm::kSuspend) return false;
diff --git a/test/inspector/inspector.status b/test/inspector/inspector.status
index 254f9e96bad..32e9a276450 100644
--- a/test/inspector/inspector.status
+++ b/test/inspector/inspector.status
@@ -113,14 +113,21 @@
 }], # no_simd_hardware
 
 ##############################################################################
-['arch == riscv64 or arch == riscv32 or arch == loong64', {
+['arch == loong64', {
   # SIMD support is still in progress.
   'debugger/wasm-scope-info*': [SKIP],
   'debugger/wasm-step-after-trap': [SKIP],
   # Generic wasm-to-js wrapper must be enabled.
   'cpu-profiler/console-profile-wasm': [SKIP],
 
-}],  # 'arch == riscv64 or arch == riscv32 or arch == loong64'
+}],  # 'arch == loong64'
+
+##############################################################################
+['arch == riscv64 or arch == riscv32', {
+  # SIMD support is still in progress.
+  'debugger/wasm-scope-info*': [SKIP],
+  'debugger/wasm-step-after-trap': [SKIP],
+}],  # 'arch == riscv64 or arch == riscv32'
 
 ##############################################################################
 ['arch == riscv32', {
-- 
2.35.1


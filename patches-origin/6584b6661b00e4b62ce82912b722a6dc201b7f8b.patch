From 6584b6661b00e4b62ce82912b722a6dc201b7f8b Mon Sep 17 00:00:00 2001
From: Aapo Alasuutari <aapo.alasuutari@gmail.com>
Date: Thu, 11 May 2023 17:14:20 +0300
Subject: [PATCH] [fastcall] Support 64-bit integer return values, add BigInt
 as possible representation for 64-bit integers

This CL adds support for 64-bit integer values as return values and parameters through a `CFunctionInfo::Int64Representation` enum to control how the 64-bit integers are to be represented in JavaScript.

The default case (`CFunctionInfo::Int64Representation::kNumber`) with is to, as currently, represent 64-bit integers as numbers and accept the consequences: Only safe integers can be passed into fastcalls as parameters, and any fastcall returning a 64-bit integer will lose precision if the value is higher than JS numbers can safely represent. This is to eventually ensure that the default case for 64-bit integer parameters remains as it is now, only supporting JavaScript numbers.

The other mode, `CFunctionInfo::Int64Representation::kBigInt`, sets fastcalls to always expect 64-bit integer parameters and return as BigInts. The `Int64Representation` enum might later be extended to eg. control how JS numbers are converted to floats.

Change-Id: I120e31d3a2c5b1af3abc6f5ea7cc10089e3b0f67
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4103340
Reviewed-by: Nico Hartmann <nicohartmann@chromium.org>
Commit-Queue: Nico Hartmann <nicohartmann@chromium.org>
Cr-Commit-Position: refs/heads/main@{#87681}
---
 include/v8-fast-api-calls.h                   |  28 ++-
 src/api/api.cc                                |  10 +-
 src/compiler/effect-control-linearizer.cc     | 180 +++++++++------
 src/compiler/simplified-lowering.cc           |  14 +-
 .../turboshaft/fast-api-call-reducer.h        |  42 +++-
 src/d8/d8-test.cc                             | 200 ++++++++++++++++
 .../fast-api-calls-64-bit-integer-values.js   | 218 ++++++++++++++++++
 test/mjsunit/mjsunit.status                   |   4 +
 8 files changed, 617 insertions(+), 79 deletions(-)
 create mode 100644 test/mjsunit/compiler/fast-api-calls-64-bit-integer-values.js

diff --git a/include/v8-fast-api-calls.h b/include/v8-fast-api-calls.h
index 0fe7cd2489b..e40f1068fab 100644
--- a/include/v8-fast-api-calls.h
+++ b/include/v8-fast-api-calls.h
@@ -388,13 +388,19 @@ struct FastOneByteString {
 
 class V8_EXPORT CFunctionInfo {
  public:
+  enum class Int64Representation : uint8_t {
+    kNumber = 0,  // Use numbers to represent 64 bit integers.
+    kBigInt = 1,  // Use BigInts to represent 64 bit integers.
+  };
+
   // Construct a struct to hold a CFunction's type information.
   // |return_info| describes the function's return type.
   // |arg_info| is an array of |arg_count| CTypeInfos describing the
   //   arguments. Only the last argument may be of the special type
   //   CTypeInfo::kCallbackOptionsType.
   CFunctionInfo(const CTypeInfo& return_info, unsigned int arg_count,
-                const CTypeInfo* arg_info);
+                const CTypeInfo* arg_info,
+                Int64Representation repr = Int64Representation::kNumber);
 
   const CTypeInfo& ReturnInfo() const { return return_info_; }
 
@@ -404,6 +410,8 @@ class V8_EXPORT CFunctionInfo {
     return HasOptions() ? arg_count_ - 1 : arg_count_;
   }
 
+  Int64Representation GetInt64Representation() const { return repr_; }
+
   // |index| must be less than ArgumentCount().
   //  Note: if the last argument passed on construction of CFunctionInfo
   //  has type CTypeInfo::kCallbackOptionsType, it is not included in
@@ -418,6 +426,7 @@ class V8_EXPORT CFunctionInfo {
 
  private:
   const CTypeInfo return_info_;
+  const Int64Representation repr_;
   const unsigned int arg_count_;
   const CTypeInfo* arg_info_;
 };
@@ -469,6 +478,9 @@ class V8_EXPORT CFunction {
   unsigned int ArgumentCount() const { return type_info_->ArgumentCount(); }
 
   const void* GetAddress() const { return address_; }
+  CFunctionInfo::Int64Representation GetInt64Representation() const {
+    return type_info_->GetInt64Representation();
+  }
   const CFunctionInfo* GetTypeInfo() const { return type_info_; }
 
   enum class OverloadResolution { kImpossible, kAtRuntime, kAtCompileTime };
@@ -598,7 +610,8 @@ struct count<T, T, Args...>
 template <typename T, typename U, typename... Args>
 struct count<T, U, Args...> : count<T, Args...> {};
 
-template <typename RetBuilder, typename... ArgBuilders>
+template <CFunctionInfo::Int64Representation Representation,
+          typename RetBuilder, typename... ArgBuilders>
 class CFunctionInfoImpl : public CFunctionInfo {
   static constexpr int kOptionsArgCount =
       count<FastApiCallbackOptions&, ArgBuilders...>();
@@ -613,18 +626,20 @@ class CFunctionInfoImpl : public CFunctionInfo {
  public:
   constexpr CFunctionInfoImpl()
       : CFunctionInfo(RetBuilder::Build(), sizeof...(ArgBuilders),
-                      arg_info_storage_),
+                      arg_info_storage_, Representation),
         arg_info_storage_{ArgBuilders::Build()...} {
     constexpr CTypeInfo::Type kReturnType = RetBuilder::Build().GetType();
     static_assert(kReturnType == CTypeInfo::Type::kVoid ||
                       kReturnType == CTypeInfo::Type::kBool ||
                       kReturnType == CTypeInfo::Type::kInt32 ||
                       kReturnType == CTypeInfo::Type::kUint32 ||
+                      kReturnType == CTypeInfo::Type::kInt64 ||
+                      kReturnType == CTypeInfo::Type::kUint64 ||
                       kReturnType == CTypeInfo::Type::kFloat32 ||
                       kReturnType == CTypeInfo::Type::kFloat64 ||
                       kReturnType == CTypeInfo::Type::kPointer ||
                       kReturnType == CTypeInfo::Type::kAny,
-                  "64-bit int, string and api object values are not currently "
+                  "String and api object values are not currently "
                   "supported return types.");
   }
 
@@ -845,8 +860,11 @@ class CFunctionBuilderWithFunction {
     return *this;
   }
 
+  template <CFunctionInfo::Int64Representation Representation =
+                CFunctionInfo::Int64Representation::kNumber>
   auto Build() {
-    static CFunctionInfoImpl<RetBuilder, ArgBuilders...> instance;
+    static CFunctionInfoImpl<Representation, RetBuilder, ArgBuilders...>
+        instance;
     return CFunction(fn_, &instance);
   }
 
diff --git a/src/api/api.cc b/src/api/api.cc
index ec8ed6f1975..9d41a921f1f 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -11138,8 +11138,14 @@ CFunction::CFunction(const void* address, const CFunctionInfo* type_info)
 }
 
 CFunctionInfo::CFunctionInfo(const CTypeInfo& return_info,
-                             unsigned int arg_count, const CTypeInfo* arg_info)
-    : return_info_(return_info), arg_count_(arg_count), arg_info_(arg_info) {
+                             unsigned int arg_count, const CTypeInfo* arg_info,
+                             Int64Representation repr)
+    : return_info_(return_info),
+      repr_(repr),
+      arg_count_(arg_count),
+      arg_info_(arg_info) {
+  DCHECK(repr == Int64Representation::kNumber ||
+         repr == Int64Representation::kBigInt);
   if (arg_count_ > 0) {
     for (unsigned int i = 0; i < arg_count_ - 1; ++i) {
       DCHECK(arg_info_[i].GetType() != CTypeInfo::kCallbackOptionsType);
diff --git a/src/compiler/effect-control-linearizer.cc b/src/compiler/effect-control-linearizer.cc
index 80db2ccb430..c826e714a06 100644
--- a/src/compiler/effect-control-linearizer.cc
+++ b/src/compiler/effect-control-linearizer.cc
@@ -316,9 +316,13 @@ class EffectControlLinearizer {
   Node* ChangeTaggedInt32ToSmi(Node* value);
   Node* ChangeInt32ToIntPtr(Node* value);
   Node* ChangeInt32ToTagged(Node* value);
+  Node* ChangeInt64ToBigInt(Node* value);
   Node* ChangeInt64ToSmi(Node* value);
+  Node* ChangeInt64ToTagged(Node* value);
   Node* ChangeIntPtrToInt32(Node* value);
   Node* ChangeIntPtrToSmi(Node* value);
+  Node* ChangeUint64ToBigInt(Node* value);
+  Node* ChangeUint64ToTagged(Node* value);
   Node* ChangeUint32ToUintPtr(Node* value);
   Node* ChangeUint32ToSmi(Node* value);
   Node* ChangeUint32ToTagged(Node* value);
@@ -2073,26 +2077,7 @@ Node* EffectControlLinearizer::LowerChangeInt64ToTagged(Node* node) {
   DCHECK(!v8_flags.turboshaft);
   Node* value = node->InputAt(0);
 
-  auto if_not_in_smi_range = __ MakeDeferredLabel();
-  auto done = __ MakeLabel(MachineRepresentation::kTagged);
-
-  Node* value32 = __ TruncateInt64ToInt32(value);
-  __ GotoIfNot(__ Word64Equal(__ ChangeInt32ToInt64(value32), value),
-               &if_not_in_smi_range);
-
-  if (SmiValuesAre32Bits()) {
-    Node* value_smi = ChangeInt64ToSmi(value);
-    __ Goto(&done, value_smi);
-  } else {
-    SmiTagOrOverflow(value32, &if_not_in_smi_range, &done);
-  }
-
-  __ Bind(&if_not_in_smi_range);
-  Node* number = AllocateHeapNumberWithValue(__ ChangeInt64ToFloat64(value));
-  __ Goto(&done, number);
-
-  __ Bind(&done);
-  return done.PhiAt(0);
+  return ChangeInt64ToTagged(value);
 }
 
 Node* EffectControlLinearizer::LowerChangeUint32ToTagged(Node* node) {
@@ -2122,21 +2107,7 @@ Node* EffectControlLinearizer::LowerChangeUint64ToTagged(Node* node) {
   DCHECK(!v8_flags.turboshaft);
   Node* value = node->InputAt(0);
 
-  auto if_not_in_smi_range = __ MakeDeferredLabel();
-  auto done = __ MakeLabel(MachineRepresentation::kTagged);
-
-  Node* check =
-      __ Uint64LessThanOrEqual(value, __ Int64Constant(Smi::kMaxValue));
-  __ GotoIfNot(check, &if_not_in_smi_range);
-  __ Goto(&done, ChangeInt64ToSmi(value));
-
-  __ Bind(&if_not_in_smi_range);
-  Node* number = AllocateHeapNumberWithValue(__ ChangeInt64ToFloat64(value));
-
-  __ Goto(&done, number);
-  __ Bind(&done);
-
-  return done.PhiAt(0);
+  return ChangeUint64ToTagged(value);
 }
 
 Node* EffectControlLinearizer::LowerChangeTaggedSignedToInt32(Node* node) {
@@ -4406,45 +4377,18 @@ Node* EffectControlLinearizer::LowerChangeInt64ToBigInt(Node* node) {
   DCHECK(!v8_flags.turboshaft);
   DCHECK(machine()->Is64());
 
-  auto done = __ MakeLabel(MachineRepresentation::kTagged);
   Node* value = node->InputAt(0);
 
-  // BigInts with value 0 must be of size 0 (canonical form).
-  __ GotoIf(__ Word64Equal(value, __ IntPtrConstant(0)), &done,
-            BuildAllocateBigInt(nullptr, nullptr));
-
-  // Shift sign bit into BigInt's sign bit position.
-  Node* sign =
-      __ Word64Shr(value, __ IntPtrConstant(63 - BigInt::SignBits::kShift));
-  Node* bitfield =
-      __ Word32Or(__ Int32Constant(BigInt::LengthBits::encode(1)), sign);
-
-  // We use (value XOR (value >> 63)) - (value >> 63) to compute the
-  // absolute value, in a branchless fashion.
-  Node* sign_mask = __ Word64Sar(value, __ Int64Constant(63));
-  Node* absolute_value = __ Int64Sub(__ Word64Xor(value, sign_mask), sign_mask);
-  __ Goto(&done, BuildAllocateBigInt(bitfield, absolute_value));
-
-  __ Bind(&done);
-  return done.PhiAt(0);
+  return ChangeInt64ToBigInt(value);
 }
 
 Node* EffectControlLinearizer::LowerChangeUint64ToBigInt(Node* node) {
   DCHECK(!v8_flags.turboshaft);
   DCHECK(machine()->Is64());
 
-  auto done = __ MakeLabel(MachineRepresentation::kTagged);
   Node* value = node->InputAt(0);
 
-  // BigInts with value 0 must be of size 0 (canonical form).
-  __ GotoIf(__ Word64Equal(value, __ IntPtrConstant(0)), &done,
-            BuildAllocateBigInt(nullptr, nullptr));
-
-  const auto bitfield = BigInt::LengthBits::encode(1);
-  __ Goto(&done, BuildAllocateBigInt(__ Int32Constant(bitfield), value));
-
-  __ Bind(&done);
-  return done.PhiAt(0);
+  return ChangeUint64ToBigInt(value);
 }
 
 Node* EffectControlLinearizer::LowerTruncateBigIntToWord64(Node* node) {
@@ -6286,6 +6230,31 @@ Node* EffectControlLinearizer::ChangeInt32ToSmi(Node* value) {
   return ChangeIntPtrToSmi(ChangeInt32ToIntPtr(value));
 }
 
+Node* EffectControlLinearizer::ChangeInt64ToBigInt(Node* value) {
+  DCHECK(machine()->Is64());
+
+  auto done = __ MakeLabel(MachineRepresentation::kTagged);
+
+  // BigInts with value 0 must be of size 0 (canonical form).
+  __ GotoIf(__ Word64Equal(value, __ IntPtrConstant(0)), &done,
+            BuildAllocateBigInt(nullptr, nullptr));
+
+  // Shift sign bit into BigInt's sign bit position.
+  Node* sign =
+      __ Word64Shr(value, __ IntPtrConstant(63 - BigInt::SignBits::kShift));
+  Node* bitfield =
+      __ Word32Or(__ Int32Constant(BigInt::LengthBits::encode(1)), sign);
+
+  // We use (value XOR (value >> 63)) - (value >> 63) to compute the
+  // absolute value, in a branchless fashion.
+  Node* sign_mask = __ Word64Sar(value, __ Int64Constant(63));
+  Node* absolute_value = __ Int64Sub(__ Word64Xor(value, sign_mask), sign_mask);
+  __ Goto(&done, BuildAllocateBigInt(bitfield, absolute_value));
+
+  __ Bind(&done);
+  return done.PhiAt(0);
+}
+
 Node* EffectControlLinearizer::ChangeInt64ToSmi(Node* value) {
   DCHECK(machine()->Is64());
   return ChangeIntPtrToSmi(value);
@@ -6298,6 +6267,63 @@ Node* EffectControlLinearizer::ChangeUint32ToUintPtr(Node* value) {
   return value;
 }
 
+Node* EffectControlLinearizer::ChangeInt64ToTagged(Node* value) {
+  auto if_not_in_smi_range = __ MakeDeferredLabel();
+  auto done = __ MakeLabel(MachineRepresentation::kTagged);
+
+  Node* value32 = __ TruncateInt64ToInt32(value);
+  __ GotoIfNot(__ Word64Equal(__ ChangeInt32ToInt64(value32), value),
+               &if_not_in_smi_range);
+
+  if (SmiValuesAre32Bits()) {
+    Node* value_smi = ChangeInt64ToSmi(value);
+    __ Goto(&done, value_smi);
+  } else {
+    SmiTagOrOverflow(value32, &if_not_in_smi_range, &done);
+  }
+
+  __ Bind(&if_not_in_smi_range);
+  Node* number = AllocateHeapNumberWithValue(__ ChangeInt64ToFloat64(value));
+  __ Goto(&done, number);
+
+  __ Bind(&done);
+  return done.PhiAt(0);
+}
+
+Node* EffectControlLinearizer::ChangeUint64ToBigInt(Node* value) {
+  DCHECK(machine()->Is64());
+
+  auto done = __ MakeLabel(MachineRepresentation::kTagged);
+
+  // BigInts with value 0 must be of size 0 (canonical form).
+  __ GotoIf(__ Word64Equal(value, __ IntPtrConstant(0)), &done,
+            BuildAllocateBigInt(nullptr, nullptr));
+
+  const auto bitfield = BigInt::LengthBits::encode(1);
+  __ Goto(&done, BuildAllocateBigInt(__ Int32Constant(bitfield), value));
+
+  __ Bind(&done);
+  return done.PhiAt(0);
+}
+
+Node* EffectControlLinearizer::ChangeUint64ToTagged(Node* value) {
+  auto if_not_in_smi_range = __ MakeDeferredLabel();
+  auto done = __ MakeLabel(MachineRepresentation::kTagged);
+
+  Node* check =
+      __ Uint64LessThanOrEqual(value, __ Int64Constant(Smi::kMaxValue));
+  __ GotoIfNot(check, &if_not_in_smi_range);
+  __ Goto(&done, ChangeInt64ToSmi(value));
+
+  __ Bind(&if_not_in_smi_range);
+  Node* number = AllocateHeapNumberWithValue(__ ChangeInt64ToFloat64(value));
+
+  __ Goto(&done, number);
+  __ Bind(&done);
+
+  return done.PhiAt(0);
+}
+
 Node* EffectControlLinearizer::ChangeUint32ToSmi(Node* value) {
   // Do shift on 32bit values if Smis are stored in the lower word.
   if (machine()->Is64() && SmiValuesAre31Bits()) {
@@ -7067,6 +7093,7 @@ Node* EffectControlLinearizer::LowerFastApiCall(Node* node) {
       },
       // Convert return value from C function to JS value
       [this](const CFunctionInfo* c_signature, Node* c_call_result) -> Node* {
+        // TODO(mslekova, aapoalas): Implement these conversions in SL.
         switch (c_signature->ReturnInfo().GetType()) {
           case CTypeInfo::Type::kVoid:
             return __ UndefinedConstant();
@@ -7078,9 +7105,28 @@ Node* EffectControlLinearizer::LowerFastApiCall(Node* node) {
             return ChangeInt32ToTagged(c_call_result);
           case CTypeInfo::Type::kUint32:
             return ChangeUint32ToTagged(c_call_result);
-          case CTypeInfo::Type::kInt64:
-          case CTypeInfo::Type::kUint64:
-            UNREACHABLE();
+          case CTypeInfo::Type::kInt64: {
+            CFunctionInfo::Int64Representation repr =
+                c_signature->GetInt64Representation();
+            if (repr == CFunctionInfo::Int64Representation::kBigInt) {
+              return ChangeInt64ToBigInt(c_call_result);
+            } else if (repr == CFunctionInfo::Int64Representation::kNumber) {
+              return ChangeInt64ToTagged(c_call_result);
+            } else {
+              UNREACHABLE();
+            }
+          }
+          case CTypeInfo::Type::kUint64: {
+            CFunctionInfo::Int64Representation repr =
+                c_signature->GetInt64Representation();
+            if (repr == CFunctionInfo::Int64Representation::kBigInt) {
+              return ChangeUint64ToBigInt(c_call_result);
+            } else if (repr == CFunctionInfo::Int64Representation::kNumber) {
+              return ChangeUint64ToTagged(c_call_result);
+            } else {
+              UNREACHABLE();
+            }
+          }
           case CTypeInfo::Type::kFloat32:
             return ChangeFloat64ToTagged(
                 __ ChangeFloat32ToFloat64(c_call_result),
diff --git a/src/compiler/simplified-lowering.cc b/src/compiler/simplified-lowering.cc
index d4d9e977714..89e07fcce61 100644
--- a/src/compiler/simplified-lowering.cc
+++ b/src/compiler/simplified-lowering.cc
@@ -1932,12 +1932,14 @@ class RepresentationSelector {
   }
 
   UseInfo UseInfoForFastApiCallArgument(CTypeInfo type,
+                                        CFunctionInfo::Int64Representation repr,
                                         FeedbackSource const& feedback) {
     switch (type.GetSequenceType()) {
       case CTypeInfo::SequenceType::kScalar: {
         uint8_t flags = uint8_t(type.GetFlags());
         if (flags & uint8_t(CTypeInfo::Flags::kEnforceRangeBit) ||
             flags & uint8_t(CTypeInfo::Flags::kClampBit)) {
+          DCHECK(repr != CFunctionInfo::Int64Representation::kBigInt);
           return UseInfo::CheckedNumberAsFloat64(kIdentifyZeros, feedback);
         }
         switch (type.GetType()) {
@@ -1954,6 +1956,13 @@ class RepresentationSelector {
           // path.
           case CTypeInfo::Type::kInt64:
           case CTypeInfo::Type::kUint64:
+            if (repr == CFunctionInfo::Int64Representation::kBigInt) {
+              return UseInfo::CheckedBigIntTruncatingWord64(feedback);
+            } else if (repr == CFunctionInfo::Int64Representation::kNumber) {
+              return UseInfo::CheckedSigned64AsWord64(kIdentifyZeros, feedback);
+            } else {
+              UNREACHABLE();
+            }
           case CTypeInfo::Type::kAny:
             return UseInfo::CheckedSigned64AsWord64(kIdentifyZeros, feedback);
           case CTypeInfo::Type::kFloat32:
@@ -2003,7 +2012,8 @@ class RepresentationSelector {
     // Propagate representation information from TypeInfo.
     for (int i = 0; i < c_arg_count; i++) {
       arg_use_info[i] = UseInfoForFastApiCallArgument(
-          c_signature->ArgumentInfo(i), op_params.feedback());
+          c_signature->ArgumentInfo(i), c_signature->GetInt64Representation(),
+          op_params.feedback());
       ProcessInput<T>(node, i, arg_use_info[i]);
     }
 
@@ -2027,7 +2037,7 @@ class RepresentationSelector {
       case wasm::kI32:
         return MachineType::Int32();
       case wasm::kI64:
-        return MachineType::SignedBigInt64();
+        return MachineType::Int64();
       case wasm::kF32:
         return MachineType::Float32();
       case wasm::kF64:
diff --git a/src/compiler/turboshaft/fast-api-call-reducer.h b/src/compiler/turboshaft/fast-api-call-reducer.h
index 2faa0fdc344..3fb056e7dcc 100644
--- a/src/compiler/turboshaft/fast-api-call-reducer.h
+++ b/src/compiler/turboshaft/fast-api-call-reducer.h
@@ -12,6 +12,7 @@
 #include "src/compiler/turboshaft/operations.h"
 #include "src/compiler/turboshaft/optimization-phase.h"
 #include "src/compiler/turboshaft/phase.h"
+#include "src/compiler/turboshaft/representations.h"
 
 namespace v8::internal::compiler::turboshaft {
 
@@ -493,9 +494,44 @@ class FastApiCallReducer : public Next {
         return __ ConvertInt32ToNumber(result);
       case CTypeInfo::Type::kUint32:
         return __ ConvertUint32ToNumber(result);
-      case CTypeInfo::Type::kInt64:
-      case CTypeInfo::Type::kUint64:
-        UNREACHABLE();
+      case CTypeInfo::Type::kInt64: {
+        CFunctionInfo::Int64Representation repr =
+            c_signature->GetInt64Representation();
+        if (repr == CFunctionInfo::Int64Representation::kBigInt) {
+          return __ ConvertPrimitiveToObject(
+              result, ConvertPrimitiveToObjectOp::Kind::kBigInt,
+              RegisterRepresentation::Word64(),
+              ConvertPrimitiveToObjectOp::InputInterpretation::kSigned,
+              CheckForMinusZeroMode::kDontCheckForMinusZero);
+        } else if (repr == CFunctionInfo::Int64Representation::kNumber) {
+          return __ ConvertPrimitiveToObject(
+              result, ConvertPrimitiveToObjectOp::Kind::kNumber,
+              RegisterRepresentation::Word64(),
+              ConvertPrimitiveToObjectOp::InputInterpretation::kSigned,
+              CheckForMinusZeroMode::kDontCheckForMinusZero);
+        } else {
+          UNREACHABLE();
+        }
+      }
+      case CTypeInfo::Type::kUint64: {
+        CFunctionInfo::Int64Representation repr =
+            c_signature->GetInt64Representation();
+        if (repr == CFunctionInfo::Int64Representation::kBigInt) {
+          return __ ConvertPrimitiveToObject(
+              result, ConvertPrimitiveToObjectOp::Kind::kBigInt,
+              RegisterRepresentation::Word64(),
+              ConvertPrimitiveToObjectOp::InputInterpretation::kUnsigned,
+              CheckForMinusZeroMode::kDontCheckForMinusZero);
+        } else if (repr == CFunctionInfo::Int64Representation::kNumber) {
+          return __ ConvertPrimitiveToObject(
+              result, ConvertPrimitiveToObjectOp::Kind::kNumber,
+              RegisterRepresentation::Word64(),
+              ConvertPrimitiveToObjectOp::InputInterpretation::kUnsigned,
+              CheckForMinusZeroMode::kDontCheckForMinusZero);
+        } else {
+          UNREACHABLE();
+        }
+      }
       case CTypeInfo::Type::kFloat32:
         return __ ConvertFloat64ToNumber(
             __ ChangeFloat32ToFloat64(result),
diff --git a/src/d8/d8-test.cc b/src/d8/d8-test.cc
index 24ba0860b03..073ff50237b 100644
--- a/src/d8/d8-test.cc
+++ b/src/d8/d8-test.cc
@@ -1171,6 +1171,170 @@ class FastCApiObject {
     info.GetReturnValue().Set(pointer_a == pointer_b);
   }
 
+  static int64_t sumInt64FastCallback(Local<Object> receiver, int64_t a,
+                                      int64_t b,
+                                      FastApiCallbackOptions& options) {
+    FastCApiObject* self = UnwrapObject(receiver);
+    CHECK_SELF_OR_FALLBACK(0);
+    self->fast_call_count_++;
+
+    return a + b;
+  }
+
+  static void sumInt64AsNumberSlowCallback(
+      const FunctionCallbackInfo<Value>& info) {
+    Isolate* isolate = info.GetIsolate();
+    FastCApiObject* self = UnwrapObject(info.This());
+    CHECK_SELF_OR_THROW();
+    self->slow_call_count_++;
+
+    if (info.Length() != 2) {
+      info.GetIsolate()->ThrowError(
+          "Invalid number of arguments, expected two.");
+      return;
+    }
+
+    Local<Value> value_a = info[0];
+    Local<Value> value_b = info[1];
+
+    int64_t a;
+    if (value_a->IsNumber()) {
+      a = static_cast<int64_t>(value_a.As<Number>()->Value());
+    } else {
+      info.GetIsolate()->ThrowError("Did not get a number as first parameter.");
+      return;
+    }
+
+    int64_t b;
+    if (value_b->IsNumber()) {
+      b = static_cast<int64_t>(value_b.As<Number>()->Value());
+    } else {
+      info.GetIsolate()->ThrowError(
+          "Did not get a number as second parameter.");
+      return;
+    }
+
+    info.GetReturnValue().Set(Number::New(isolate, static_cast<double>(a + b)));
+  }
+
+  static void sumInt64AsBigIntSlowCallback(
+      const FunctionCallbackInfo<Value>& info) {
+    Isolate* isolate = info.GetIsolate();
+    FastCApiObject* self = UnwrapObject(info.This());
+    CHECK_SELF_OR_THROW();
+    self->slow_call_count_++;
+
+    if (info.Length() != 2) {
+      info.GetIsolate()->ThrowError(
+          "Invalid number of arguments, expected two.");
+      return;
+    }
+
+    Local<Value> value_a = info[0];
+    Local<Value> value_b = info[1];
+
+    int64_t a;
+    if (value_a->IsBigInt()) {
+      a = static_cast<int64_t>(value_a.As<BigInt>()->Int64Value());
+    } else {
+      info.GetIsolate()->ThrowError("Did not get a BigInt as first parameter.");
+      return;
+    }
+
+    int64_t b;
+    if (value_b->IsBigInt()) {
+      b = static_cast<int64_t>(value_b.As<BigInt>()->Int64Value());
+    } else {
+      info.GetIsolate()->ThrowError(
+          "Did not get a BigInt as second parameter.");
+      return;
+    }
+
+    info.GetReturnValue().Set(BigInt::New(isolate, a + b));
+  }
+
+  static uint64_t sumUint64FastCallback(Local<Object> receiver, uint64_t a,
+                                        uint64_t b,
+                                        FastApiCallbackOptions& options) {
+    FastCApiObject* self = UnwrapObject(receiver);
+    CHECK_SELF_OR_FALLBACK(0);
+    self->fast_call_count_++;
+
+    return a + b;
+  }
+
+  static void sumUint64AsNumberSlowCallback(
+      const FunctionCallbackInfo<Value>& info) {
+    Isolate* isolate = info.GetIsolate();
+    FastCApiObject* self = UnwrapObject(info.This());
+    CHECK_SELF_OR_THROW();
+    self->slow_call_count_++;
+
+    if (info.Length() != 2) {
+      info.GetIsolate()->ThrowError(
+          "Invalid number of arguments, expected two.");
+      return;
+    }
+
+    Local<Value> value_a = info[0];
+    Local<Value> value_b = info[1];
+
+    uint64_t a;
+    if (value_a->IsNumber()) {
+      a = static_cast<uint64_t>(value_a.As<Number>()->Value());
+    } else {
+      info.GetIsolate()->ThrowError("Did not get a number as first parameter.");
+      return;
+    }
+
+    uint64_t b;
+    if (value_b->IsNumber()) {
+      b = static_cast<uint64_t>(value_b.As<Number>()->Value());
+    } else {
+      info.GetIsolate()->ThrowError(
+          "Did not get a number as second parameter.");
+      return;
+    }
+
+    info.GetReturnValue().Set(Number::New(isolate, static_cast<double>(a + b)));
+  }
+
+  static void sumUint64AsBigIntSlowCallback(
+      const FunctionCallbackInfo<Value>& info) {
+    Isolate* isolate = info.GetIsolate();
+    FastCApiObject* self = UnwrapObject(info.This());
+    CHECK_SELF_OR_THROW();
+    self->slow_call_count_++;
+
+    if (info.Length() != 2) {
+      info.GetIsolate()->ThrowError(
+          "Invalid number of arguments, expected two.");
+      return;
+    }
+
+    Local<Value> value_a = info[0];
+    Local<Value> value_b = info[1];
+
+    uint64_t a;
+    if (value_a->IsBigInt()) {
+      a = static_cast<uint64_t>(value_a.As<BigInt>()->Uint64Value());
+    } else {
+      info.GetIsolate()->ThrowError("Did not get a BigInt as first parameter.");
+      return;
+    }
+
+    uint64_t b;
+    if (value_b->IsBigInt()) {
+      b = static_cast<uint64_t>(value_b.As<BigInt>()->Uint64Value());
+    } else {
+      info.GetIsolate()->ThrowError(
+          "Did not get a BigInt as second parameter.");
+      return;
+    }
+
+    info.GetReturnValue().Set(BigInt::NewFromUnsigned(isolate, a + b));
+  }
+
   static void FastCallCount(const FunctionCallbackInfo<Value>& info) {
     FastCApiObject* self = UnwrapObject(info.This());
     CHECK_SELF_OR_THROW();
@@ -1659,6 +1823,42 @@ Local<FunctionTemplate> Shell::CreateTestFastCApiTemplate(Isolate* isolate) {
             isolate, FastCApiObject::ComparePointersSlowCallback,
             Local<Value>(), signature, 1, ConstructorBehavior::kThrow,
             SideEffectType::kHasSideEffect, &compare_pointers_c_func));
+    CFunction sum_int64_as_number_c_func =
+        CFunctionBuilder().Fn(FastCApiObject::sumInt64FastCallback).Build();
+    api_obj_ctor->PrototypeTemplate()->Set(
+        isolate, "sum_int64_as_number",
+        FunctionTemplate::New(
+            isolate, FastCApiObject::sumInt64AsNumberSlowCallback,
+            Local<Value>(), signature, 1, ConstructorBehavior::kThrow,
+            SideEffectType::kHasSideEffect, &sum_int64_as_number_c_func));
+    CFunction sum_int64_as_bigint_c_func =
+        CFunctionBuilder()
+            .Fn(FastCApiObject::sumInt64FastCallback)
+            .Build<CFunctionInfo::Int64Representation::kBigInt>();
+    api_obj_ctor->PrototypeTemplate()->Set(
+        isolate, "sum_int64_as_bigint",
+        FunctionTemplate::New(
+            isolate, FastCApiObject::sumInt64AsBigIntSlowCallback,
+            Local<Value>(), signature, 1, ConstructorBehavior::kThrow,
+            SideEffectType::kHasSideEffect, &sum_int64_as_bigint_c_func));
+    CFunction sum_uint64_as_number_c_func =
+        CFunctionBuilder().Fn(FastCApiObject::sumUint64FastCallback).Build();
+    api_obj_ctor->PrototypeTemplate()->Set(
+        isolate, "sum_uint64_as_number",
+        FunctionTemplate::New(
+            isolate, FastCApiObject::sumUint64AsNumberSlowCallback,
+            Local<Value>(), signature, 1, ConstructorBehavior::kThrow,
+            SideEffectType::kHasSideEffect, &sum_uint64_as_number_c_func));
+    CFunction sum_uint64_as_bigint_c_func =
+        CFunctionBuilder()
+            .Fn(FastCApiObject::sumUint64FastCallback)
+            .Build<CFunctionInfo::Int64Representation::kBigInt>();
+    api_obj_ctor->PrototypeTemplate()->Set(
+        isolate, "sum_uint64_as_bigint",
+        FunctionTemplate::New(
+            isolate, FastCApiObject::sumUint64AsBigIntSlowCallback,
+            Local<Value>(), signature, 1, ConstructorBehavior::kThrow,
+            SideEffectType::kHasSideEffect, &sum_uint64_as_bigint_c_func));
 
     api_obj_ctor->PrototypeTemplate()->Set(
         isolate, "fast_call_count",
diff --git a/test/mjsunit/compiler/fast-api-calls-64-bit-integer-values.js b/test/mjsunit/compiler/fast-api-calls-64-bit-integer-values.js
new file mode 100644
index 00000000000..71de05de8ea
--- /dev/null
+++ b/test/mjsunit/compiler/fast-api-calls-64-bit-integer-values.js
@@ -0,0 +1,218 @@
+// Copyright 2023 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// This file excercises basic fast API calls and enables fuzzing of this
+// functionality.
+
+// Flags: --turbo-fast-api-calls --expose-fast-api --allow-natives-syntax --turbofan
+// --always-turbofan is disabled because we rely on particular feedback for
+// optimizing to the fastest path.
+// Flags: --no-always-turbofan
+// The test relies on optimizing/deoptimizing at predictable moments, so
+// it's not suitable for deoptimization fuzzing.
+// Flags: --deopt-every-n-times=0
+
+const fast_c_api = new d8.test.FastCAPI();
+
+// ---------- Test 64-bit integer return values -----------
+
+function reset_counts() {
+  return fast_c_api.reset_counts();
+}
+
+function fast_call_count() {
+  return fast_c_api.fast_call_count();
+}
+
+function slow_call_count() {
+  return fast_c_api.slow_call_count();
+}
+
+function sum_int64_as_number(a, b) {
+  return fast_c_api.sum_int64_as_number(a, b);
+}
+
+function sum_int64_as_bigint(a, b) {
+  return fast_c_api.sum_int64_as_bigint(a, b);
+}
+
+function sum_uint64_as_number(a, b) {
+  return fast_c_api.sum_uint64_as_number(a, b);
+}
+
+function sum_uint64_as_bigint(a, b) {
+  return fast_c_api.sum_uint64_as_bigint(a, b);
+}
+
+let result;
+
+/* ===================== Return as number =====================  */
+
+// === Sum 64-bit signed integers ===
+
+// Prepare
+reset_counts();
+// Test slow path throwing errors on invalid parameters
+assertThrows(() => sum_int64_as_number(136n, 2467247n));
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 1);
+
+%PrepareFunctionForOptimization(sum_int64_as_number);
+result = sum_int64_as_number(0, 0);
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0);
+
+// Test Smi path
+%OptimizeFunctionOnNextCall(sum_int64_as_number);
+result = sum_int64_as_number(0, 0);
+assertEquals(fast_call_count(), 1);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0);
+
+// Test non-Smi path
+result = sum_int64_as_number(2 ** 33, 2467247);
+assertEquals(fast_call_count(), 2);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 2 ** 33 + 2467247);
+
+// Test fast call returning over MAX_SAFE_INTEGER
+result = sum_int64_as_number(Number.MAX_SAFE_INTEGER, 1024);
+assertEquals(fast_call_count(), 3);
+assertEquals(slow_call_count(), 2);
+assertFalse(Number.isSafeInteger(result));
+assertEquals(result, Number.MAX_SAFE_INTEGER + 1024);
+
+// Test fast call returning safe negative number
+result = sum_int64_as_number(10, -24737);
+assertEquals(fast_call_count(), 4);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 10 - 24737);
+
+// Test fast call returning below MIN_SAFE_INTEGER
+result = sum_int64_as_number(-1024, Number.MIN_SAFE_INTEGER);
+assertEquals(fast_call_count(), 5);
+assertEquals(slow_call_count(), 2);
+assertFalse(Number.isSafeInteger(result));
+assertEquals(result, -1024 + Number.MIN_SAFE_INTEGER);
+
+
+// === Sum 64-bit unsigned integers ===
+
+// Prepare
+reset_counts();
+// Test slow path throwing errors on invalid parameters
+assertThrows(() => sum_uint64_as_number(136n, 2467247n));
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 1);
+
+%PrepareFunctionForOptimization(sum_uint64_as_number);
+result = sum_uint64_as_number(0, 0);
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0);
+
+// Test Smi path
+%OptimizeFunctionOnNextCall(sum_uint64_as_number);
+result = sum_uint64_as_number(0, 0);
+assertEquals(fast_call_count(), 1);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0);
+
+// Test non-Smi path
+result = sum_uint64_as_number(2 ** 33, 2467247);
+assertEquals(fast_call_count(), 2);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 2 ** 33 + 2467247);
+
+// Test fast call returning over MAX_SAFE_INTEGER
+result = sum_uint64_as_number(Number.MAX_SAFE_INTEGER, 1024);
+assertEquals(fast_call_count(), 3);
+assertEquals(slow_call_count(), 2);
+assertFalse(Number.isSafeInteger(result));
+assertEquals(result, Number.MAX_SAFE_INTEGER + 1024);
+
+/* ===================== Return as BigInt =====================  */
+
+
+// === Sum 64-bit signed integers ===
+
+// Prepare
+reset_counts();
+// Test slow path throwing errors on invalid parameters
+assertThrows(() => sum_int64_as_bigint(136, 2467247));
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 1);
+
+%PrepareFunctionForOptimization(sum_int64_as_bigint);
+result = sum_int64_as_bigint(0n, 0n);
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0n);
+
+// Test Smi path
+%OptimizeFunctionOnNextCall(sum_int64_as_bigint);
+result = sum_int64_as_bigint(0n, 0n);
+assertEquals(fast_call_count(), 1);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0n);
+
+// Test non-Smi path
+result = sum_int64_as_bigint(2n ** 33n, 2467247n);
+assertEquals(fast_call_count(), 2);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 2n ** 33n + 2467247n);
+
+// Test fast call returning over MAX_SAFE_INTEGER
+result = sum_int64_as_bigint(BigInt(Number.MAX_SAFE_INTEGER), 1024n);
+assertEquals(fast_call_count(), 3);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, BigInt(Number.MAX_SAFE_INTEGER) + 1024n);
+
+// Test fast call returning safe negative number
+result = sum_int64_as_bigint(10n, -24737n);
+assertEquals(fast_call_count(), 4);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 10n - 24737n);
+
+// Test fast call returning below MIN_SAFE_INTEGER
+result = sum_int64_as_bigint(-1024n, BigInt(Number.MIN_SAFE_INTEGER));
+assertEquals(fast_call_count(), 5);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, -1024n + BigInt(Number.MIN_SAFE_INTEGER));
+
+
+// === Sum 64-bit unsigned integers ===
+
+// Prepare
+reset_counts();
+// Test slow path throwing errors on invalid parameters
+assertThrows(() => sum_uint64_as_bigint(136, 2467247));
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 1);
+
+%PrepareFunctionForOptimization(sum_uint64_as_bigint);
+result = sum_uint64_as_bigint(0n, 0n);
+assertEquals(fast_call_count(), 0);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0n);
+
+// Test Smi path
+%OptimizeFunctionOnNextCall(sum_uint64_as_bigint);
+result = sum_uint64_as_bigint(0n, 0n);
+assertEquals(fast_call_count(), 1);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 0n);
+
+// Test non-Smi path
+result = sum_uint64_as_bigint(2n ** 33n, 2467247n);
+assertEquals(fast_call_count(), 2);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, 2n ** 33n + 2467247n);
+
+// Test fast call returning over MAX_SAFE_INTEGER
+result = sum_uint64_as_bigint(BigInt(Number.MAX_SAFE_INTEGER), 1024n);
+assertEquals(fast_call_count(), 3);
+assertEquals(slow_call_count(), 2);
+assertEquals(result, BigInt(Number.MAX_SAFE_INTEGER) + 1024n);
diff --git a/test/mjsunit/mjsunit.status b/test/mjsunit/mjsunit.status
index e7f7aeec453..c7e45686048 100644
--- a/test/mjsunit/mjsunit.status
+++ b/test/mjsunit/mjsunit.status
@@ -572,6 +572,9 @@
 
   # Needs a huge Uint8Array.
   'regress/regress-1432470': [SKIP],
+
+  # Needs 64-bit number register support
+  'compiler/fast-api-calls-64-bit-integer-values': [SKIP],
 }],  # 'arch in (ia32, arm, riscv32)'
 
 ##############################################################################
@@ -1964,6 +1967,7 @@
   'compiler/fast-api-calls-8args': [FAIL],
   'compiler/fast-api-calls-string': [FAIL],
   'compiler/fast-api-calls-pointer': [FAIL],
+  'compiler/fast-api-calls-64-bit-integer-values': [FAIL],
   'compiler/fast-api-interface-types': [FAIL],
   'compiler/fast-api-sequences*': [FAIL],
   # Maglev doesn't specialise the IsBeingInterpreted runtime func.
-- 
2.35.1


From f20f342a3e275ae6442a53e34869f1c90f0db4a0 Mon Sep 17 00:00:00 2001
From: Leszek Swirski <leszeks@chromium.org>
Date: Tue, 1 Aug 2023 11:16:58 +0200
Subject: [PATCH] [tagged-ptr] Make Object methods static

Turn obj->Foo() into Object::Foo(obj) for Object methods.

This allows operations on Smis without dereferencing.

Bug: v8:12710
Change-Id: I6b0cf8b914647c0058bb5b15e47b917714ef4b7f
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4732912
Auto-Submit: Leszek Swirski <leszeks@chromium.org>
Commit-Queue: Michael Lippautz <mlippautz@chromium.org>
Reviewed-by: Michael Lippautz <mlippautz@chromium.org>
Cr-Commit-Position: refs/heads/main@{#89283}
---
 src/api/api-inl.h                             |   4 +-
 src/api/api.cc                                |  46 +-
 src/asmjs/asm-js.cc                           |   5 +-
 src/ast/ast.cc                                |   3 +-
 src/baseline/baseline-batch-compiler.cc       |   4 +-
 src/baseline/baseline.cc                      |   2 +-
 src/builtins/accessors.cc                     |   8 +-
 src/builtins/builtins-array.cc                |  35 +-
 src/builtins/builtins-arraybuffer.cc          |  15 +-
 .../builtins-atomics-synchronization.cc       |   4 +-
 src/builtins/builtins-bigint.cc               |   8 +-
 src/builtins/builtins-dataview.cc             |   6 +-
 src/builtins/builtins-date.cc                 | 156 +++---
 src/builtins/builtins-function.cc             |   2 +-
 src/builtins/builtins-intl.cc                 |  11 +-
 src/builtins/builtins-number.cc               |  12 +-
 src/builtins/builtins-sharedarraybuffer.cc    |  11 +-
 src/builtins/builtins-string.cc               |  10 +-
 src/builtins/builtins-struct.cc               |   2 +-
 src/builtins/builtins-temporal.cc             |   2 +-
 src/builtins/builtins-trace.cc                |   4 +-
 src/builtins/builtins-weak-refs.cc            |   2 +-
 src/codegen/compiler.cc                       |  18 +-
 src/codegen/external-reference.cc             |   2 +-
 src/codegen/pending-optimization-table.cc     |   2 +-
 .../lazy-compile-dispatcher.cc                |   6 +-
 .../optimizing-compile-dispatcher.cc          |   2 +-
 src/compiler/access-info.cc                   |   3 +-
 src/compiler/heap-refs.cc                     |  11 +-
 src/compiler/js-heap-broker.cc                |   2 +-
 src/debug/debug-evaluate.cc                   |   2 +-
 src/debug/debug-interface.cc                  |   6 +-
 src/debug/debug-scopes.cc                     |  18 +-
 src/debug/debug.cc                            |   4 +-
 src/deoptimizer/deoptimizer.cc                |  14 +-
 src/deoptimizer/translated-state.cc           |  25 +-
 src/diagnostics/disassembler.cc               |   2 +-
 src/diagnostics/gdb-jit.cc                    |   2 +-
 src/diagnostics/objects-debug.cc              |  73 +--
 src/diagnostics/objects-printer.cc            |  30 +-
 src/execution/arguments-inl.h                 |   2 +-
 src/execution/arm/simulator-arm.cc            |   4 +-
 src/execution/arm64/simulator-arm64.cc        |   4 +-
 src/execution/execution.cc                    |   2 +-
 src/execution/frames.cc                       |   4 +-
 src/execution/isolate.cc                      |   4 +-
 src/execution/loong64/simulator-loong64.cc    |   2 +-
 src/execution/mips64/simulator-mips64.cc      |   2 +-
 src/execution/ppc/simulator-ppc.cc            |   2 +-
 src/execution/riscv/simulator-riscv.cc        |   4 +-
 src/execution/s390/simulator-s390.cc          |   2 +-
 src/execution/tiering-manager.cc              |   4 +-
 src/handles/global-handles.cc                 |   2 +-
 src/handles/traced-handles.cc                 |   2 +-
 src/heap/factory-inl.h                        |   2 +-
 src/heap/factory.cc                           |   6 +-
 src/heap/heap-verifier.cc                     |   2 +-
 src/heap/heap.cc                              |   6 +-
 src/heap/large-spaces.cc                      |   4 +-
 src/heap/mark-compact.cc                      |   4 +-
 src/heap/object-stats.cc                      |   2 +-
 src/heap/setup-heap-internal.cc               |   2 +-
 src/ic/handler-configuration.cc               |  18 +-
 src/ic/ic.cc                                  |   8 +-
 src/json/json-parser.cc                       |  15 +-
 src/json/json-stringifier.cc                  |   8 +-
 src/logging/log.cc                            |   2 +-
 src/maglev/maglev-compiler.cc                 |   4 +-
 src/maglev/maglev-graph-builder.cc            |   2 +-
 src/maglev/maglev-ir.cc                       |   2 +-
 src/maglev/maglev-ir.h                        |   2 +-
 src/objects/allocation-site-inl.h             |   2 +-
 src/objects/bigint.cc                         |   3 +-
 src/objects/bytecode-array.cc                 |   2 +-
 src/objects/compilation-cache-table-inl.h     |   2 +-
 src/objects/compilation-cache-table.cc        |   5 +-
 src/objects/contexts.cc                       |   4 +-
 src/objects/dependent-code-inl.h              |   2 +-
 src/objects/dictionary-inl.h                  |   4 +-
 src/objects/elements.cc                       |  89 ++--
 src/objects/hash-table-inl.h                  |   8 +-
 src/objects/intl-objects.cc                   |   5 +-
 src/objects/js-array-buffer.cc                |   7 +-
 src/objects/js-date-time-format.cc            |  12 +-
 src/objects/js-function.cc                    |   6 +-
 src/objects/js-number-format.cc               |   6 +-
 src/objects/js-objects.cc                     |  50 +-
 src/objects/js-relative-time-format.cc        |   2 +-
 src/objects/js-temporal-objects.cc            | 454 ++++++++++--------
 src/objects/js-weak-refs-inl.h                |   9 +-
 src/objects/keys.cc                           |  10 +-
 src/objects/lookup-inl.h                      |   2 +-
 src/objects/lookup.cc                         |   8 +-
 src/objects/map-updater.cc                    |   6 +-
 src/objects/map.cc                            |  21 +-
 src/objects/module.cc                         |   8 +-
 src/objects/object-macros.h                   |   7 +
 src/objects/object-type.cc                    |   2 +-
 src/objects/objects-inl.h                     | 115 +++--
 src/objects/objects.cc                        | 248 +++++-----
 src/objects/objects.h                         | 109 +++--
 src/objects/option-utils.cc                   |  10 +-
 src/objects/option-utils.h                    |   2 +-
 src/objects/ordered-hash-table.cc             |  31 +-
 src/objects/property-descriptor.cc            |  13 +-
 src/objects/property.cc                       |   2 +-
 src/objects/shared-function-info.cc           |   4 +-
 src/objects/smi.h                             |   2 +-
 src/objects/source-text-module.cc             |   3 +-
 src/objects/string-forwarding-table.cc        |   6 +-
 src/objects/string-inl.h                      |   6 +-
 src/objects/string-table.cc                   |   2 +-
 src/objects/string.cc                         |   4 +-
 src/objects/swiss-name-dictionary.cc          |   2 +-
 src/objects/tagged-impl.cc                    |  46 +-
 src/objects/tagged-impl.h                     |  45 +-
 src/objects/tagged-index.h                    |   2 +-
 src/objects/value-serializer.cc               |  14 +-
 src/profiler/heap-snapshot-generator.cc       |   2 +-
 src/runtime/runtime-array.cc                  |  22 +-
 src/runtime/runtime-classes.cc                |   4 +-
 src/runtime/runtime-collections.cc            |   4 +-
 src/runtime/runtime-internal.cc               |   2 +-
 src/runtime/runtime-literals.cc               |   2 +-
 src/runtime/runtime-numbers.cc                |   2 +-
 src/runtime/runtime-object.cc                 |   4 +-
 src/runtime/runtime-operators.cc              |   4 +-
 src/runtime/runtime-promise.cc                |   2 +-
 src/runtime/runtime-regexp.cc                 |  12 +-
 src/runtime/runtime-test-wasm.cc              |   2 +-
 src/runtime/runtime-test.cc                   |  18 +-
 src/runtime/runtime-trace.cc                  |   6 +-
 src/runtime/runtime-weak-refs.cc              |   2 +-
 src/snapshot/code-serializer.cc               |   5 +-
 src/snapshot/serializer.cc                    |  16 +-
 src/snapshot/startup-serializer.cc            |   4 +-
 src/strings/string-stream.cc                  |  13 +-
 src/wasm/c-api.cc                             |   7 +-
 src/wasm/module-instantiate.cc                |   7 +-
 src/wasm/wasm-debug.cc                        |   2 +-
 src/wasm/wasm-js.cc                           |   2 +-
 src/wasm/wasm-objects.cc                      |   2 +-
 test/cctest/assembler-helper-arm.cc           |   2 +-
 test/cctest/compiler/codegen-tester.h         |   8 +-
 test/cctest/compiler/function-tester.cc       |   2 +-
 test/cctest/compiler/test-code-generator.cc   |  20 +-
 test/cctest/compiler/test-run-machops.cc      |   6 +-
 test/cctest/heap/test-heap.cc                 |  22 +-
 test/cctest/test-api-typed-array.cc           |  10 +-
 test/cctest/test-api.cc                       |   8 +-
 test/cctest/test-assembler-arm.cc             |  84 ++--
 test/cctest/test-assembler-arm64.cc           |   4 +-
 test/cctest/test-assembler-ia32.cc            |  38 +-
 test/cctest/test-code-stub-assembler.cc       |  16 +-
 test/cctest/test-field-type-tracking.cc       |  16 +-
 test/cctest/test-inobject-slack-tracking.cc   |   2 +-
 test/cctest/test-js-weak-refs.cc              |   2 +-
 test/cctest/test-macro-assembler-arm.cc       |   4 +-
 test/cctest/test-orderedhashtable.cc          |  10 +-
 test/cctest/test-serialize.cc                 |  10 +-
 test/cctest/test-shared-strings.cc            |  40 +-
 test/cctest/test-strings.cc                   |   2 +-
 .../cctest/test-swiss-name-dictionary-infra.h |   2 +-
 test/cctest/wasm/test-run-wasm-memory64.cc    |   2 +-
 test/cctest/wasm/test-run-wasm-module.cc      |   2 +-
 test/cctest/wasm/test-wasm-breakpoints.cc     |   2 +-
 test/cctest/wasm/test-wasm-trap-position.cc   |   2 +-
 test/common/types-fuzz.h                      |   4 +-
 .../assembler/assembler-x64-unittest.cc       |  48 +-
 .../assembler/disasm-ia32-unittest.cc         |   2 +-
 .../assembler/disasm-x64-unittest.cc          |   2 +-
 .../assembler/macro-assembler-arm-unittest.cc |   2 +-
 .../macro-assembler-arm64-unittest.cc         |   2 +-
 .../assembler/macro-assembler-x64-unittest.cc |  12 +-
 test/unittests/codegen/factory-unittest.cc    |   2 +-
 test/unittests/compiler/codegen-tester.h      |   8 +-
 test/unittests/compiler/compiler-unittest.cc  |  12 +-
 test/unittests/compiler/function-tester.cc    |   2 +-
 .../run-bytecode-graph-builder-unittest.cc    | 128 ++---
 .../compiler/run-jsobjects-unittest.cc        |   6 +-
 test/unittests/compiler/types-unittest.cc     |  28 +-
 .../heap/cppgc-js/unified-heap-unittest.cc    |   2 +-
 .../unittests/heap/global-handles-unittest.cc |   2 +-
 .../bytecode-array-iterator-unittest.cc       |   4 +-
 ...bytecode-array-random-iterator-unittest.cc |  12 +-
 .../constant-array-builder-unittest.cc        |  36 +-
 .../interpreter/interpreter-unittest.cc       | 138 +++---
 test/unittests/logging/log-unittest.cc        |   4 +-
 test/unittests/objects/hashcode-unittest.cc   |  11 +-
 test/unittests/objects/symbols-unittest.cc    |   8 +-
 test/unittests/objects/weakmaps-unittest.cc   |  18 +-
 test/unittests/objects/weaksets-unittest.cc   |   8 +-
 test/unittests/parser/preparser-unittest.cc   |   2 +-
 tools/gcmole/README                           |  24 +-
 tools/gcmole/gcmole-test.cc                   |  52 +-
 tools/gcmole/test-expectations.txt            | 102 ++--
 196 files changed, 1711 insertions(+), 1537 deletions(-)

diff --git a/src/api/api-inl.h b/src/api/api-inl.h
index fb621567e66..d4af026d245 100644
--- a/src/api/api-inl.h
+++ b/src/api/api-inl.h
@@ -268,7 +268,7 @@ template <typename T>
 void CopySmiElementsToTypedBuffer(T* dst, uint32_t length,
                                   i::FixedArray elements) {
   for (uint32_t i = 0; i < length; ++i) {
-    double value = elements->get(static_cast<int>(i)).Number();
+    double value = i::Object::Number(elements->get(static_cast<int>(i)));
     // TODO(mslekova): Avoid converting back-and-forth when possible, e.g
     // avoid int->double->int conversions to boost performance.
     dst[i] = i::ConvertDouble<T>(value);
@@ -302,7 +302,7 @@ bool CopyAndConvertArrayToCppBuffer(Local<Array> src, T* dst,
 
   i::DisallowGarbageCollection no_gc;
   i::JSArray obj = *reinterpret_cast<i::JSArray*>(*src);
-  if (obj.IterationHasObservableEffects()) {
+  if (i::Object::IterationHasObservableEffects(obj)) {
     // The array has a custom iterator.
     return false;
   }
diff --git a/src/api/api.cc b/src/api/api.cc
index c81e1be86b5..eede52c9cc9 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -731,7 +731,7 @@ i::Address* GlobalizeTracedReference(i::Isolate* i_isolate, i::Address value,
   auto result = i_isolate->traced_handles()->Create(value, slot, store_mode);
 #ifdef VERIFY_HEAP
   if (i::v8_flags.verify_heap) {
-    i::Object(value).ObjectVerify(i_isolate);
+    Object::ObjectVerify(i::Object(value), i_isolate);
   }
 #endif  // VERIFY_HEAP
   return result.location();
@@ -800,7 +800,7 @@ i::Address* GlobalizeReference(i::Isolate* i_isolate, i::Address value) {
   i::Handle<i::Object> result = i_isolate->global_handles()->Create(value);
 #ifdef VERIFY_HEAP
   if (i::v8_flags.verify_heap) {
-    i::Object(value).ObjectVerify(i_isolate);
+    i::Object::ObjectVerify(i::Object(value), i_isolate);
   }
 #endif  // VERIFY_HEAP
   return result.location();
@@ -3781,7 +3781,7 @@ bool Value::IsInt32() const {
   i::Object obj = *Utils::OpenHandle(this);
   if (i::IsSmi(obj)) return true;
   if (i::IsNumber(obj)) {
-    return i::IsInt32Double(obj.Number());
+    return i::IsInt32Double(i::Object::Number(obj));
   }
   return false;
 }
@@ -3790,7 +3790,7 @@ bool Value::IsUint32() const {
   i::Handle<i::Object> obj = Utils::OpenHandle(this);
   if (i::IsSmi(*obj)) return i::Smi::ToInt(*obj) >= 0;
   if (i::IsNumber(*obj)) {
-    double value = obj->Number();
+    double value = i::Object::Number(*obj);
     return !i::IsMinusZero(value) && value >= 0 && value <= i::kMaxUInt32 &&
            value == i::FastUI2D(i::FastD2UI(value));
   }
@@ -3883,8 +3883,8 @@ MaybeLocal<BigInt> Value::ToBigInt(Local<Context> context) const {
 }
 
 bool Value::BooleanValue(Isolate* v8_isolate) const {
-  return Utils::OpenHandle(this)->BooleanValue(
-      reinterpret_cast<i::Isolate*>(v8_isolate));
+  return i::Object::BooleanValue(*Utils::OpenHandle(this),
+                                 reinterpret_cast<i::Isolate*>(v8_isolate));
 }
 
 MaybeLocal<Primitive> Value::ToPrimitive(Local<Context> context) const {
@@ -4293,14 +4293,14 @@ void v8::RegExp::CheckCast(v8::Value* that) {
 
 Maybe<double> Value::NumberValue(Local<Context> context) const {
   auto obj = Utils::OpenHandle(this);
-  if (i::IsNumber(*obj)) return Just(obj->Number());
+  if (i::IsNumber(*obj)) return Just(i::Object::Number(*obj));
   auto i_isolate = reinterpret_cast<i::Isolate*>(context->GetIsolate());
   ENTER_V8(i_isolate, context, Value, NumberValue, Nothing<double>(),
            i::HandleScope);
   i::Handle<i::Object> num;
   has_pending_exception = !i::Object::ToNumber(i_isolate, obj).ToHandle(&num);
   RETURN_ON_FAILED_EXECUTION_PRIMITIVE(double);
-  return Just(num->Number());
+  return Just(i::Object::Number(*num));
 }
 
 Maybe<int64_t> Value::IntegerValue(Local<Context> context) const {
@@ -4327,7 +4327,7 @@ Maybe<int32_t> Value::Int32Value(Local<Context> context) const {
   has_pending_exception = !i::Object::ToInt32(i_isolate, obj).ToHandle(&num);
   RETURN_ON_FAILED_EXECUTION_PRIMITIVE(int32_t);
   return Just(IsSmi(*num) ? i::Smi::ToInt(*num)
-                          : static_cast<int32_t>(num->Number()));
+                          : static_cast<int32_t>(i::Object::Number(*num)));
 }
 
 Maybe<uint32_t> Value::Uint32Value(Local<Context> context) const {
@@ -4340,7 +4340,7 @@ Maybe<uint32_t> Value::Uint32Value(Local<Context> context) const {
   has_pending_exception = !i::Object::ToUint32(i_isolate, obj).ToHandle(&num);
   RETURN_ON_FAILED_EXECUTION_PRIMITIVE(uint32_t);
   return Just(IsSmi(*num) ? static_cast<uint32_t>(i::Smi::ToInt(*num))
-                          : static_cast<uint32_t>(num->Number()));
+                          : static_cast<uint32_t>(i::Object::Number(*num)));
 }
 
 MaybeLocal<Uint32> Value::ToArrayIndex(Local<Context> context) const {
@@ -4382,13 +4382,13 @@ Maybe<bool> Value::Equals(Local<Context> context, Local<Value> that) const {
 bool Value::StrictEquals(Local<Value> that) const {
   auto self = Utils::OpenHandle(this);
   auto other = Utils::OpenHandle(*that);
-  return self->StrictEquals(*other);
+  return i::Object::StrictEquals(*self, *other);
 }
 
 bool Value::SameValue(Local<Value> that) const {
   auto self = Utils::OpenHandle(this);
   auto other = Utils::OpenHandle(*that);
-  return self->SameValue(*other);
+  return i::Object::SameValue(*self, *other);
 }
 
 Local<String> Value::TypeOf(v8::Isolate* external_isolate) {
@@ -4919,7 +4919,7 @@ Maybe<bool> v8::Object::Has(Local<Context> context, Local<Value> key) {
   Maybe<bool> maybe = Nothing<bool>();
   // Check if the given key is an array index.
   uint32_t index = 0;
-  if (key_obj->ToArrayIndex(&index)) {
+  if (i::Object::ToArrayIndex(*key_obj, &index)) {
     maybe = i::JSReceiver::HasElement(i_isolate, self, index);
   } else {
     // Convert the key to a name - possibly by calling back into JavaScript.
@@ -6181,7 +6181,7 @@ Local<Value> Private::Name() const {
 
 double Number::Value() const {
   i::Handle<i::Object> obj = Utils::OpenHandle(this);
-  return obj->Number();
+  return i::Object::Number(*obj);
 }
 
 bool Boolean::Value() const {
@@ -6194,7 +6194,7 @@ int64_t Integer::Value() const {
   if (i::IsSmi(obj)) {
     return i::Smi::ToInt(obj);
   } else {
-    return static_cast<int64_t>(obj.Number());
+    return static_cast<int64_t>(i::Object::Number(obj));
   }
 }
 
@@ -6203,7 +6203,7 @@ int32_t Int32::Value() const {
   if (i::IsSmi(obj)) {
     return i::Smi::ToInt(obj);
   } else {
-    return static_cast<int32_t>(obj.Number());
+    return static_cast<int32_t>(i::Object::Number(obj));
   }
 }
 
@@ -6212,7 +6212,7 @@ uint32_t Uint32::Value() const {
   if (i::IsSmi(obj)) {
     return i::Smi::ToInt(obj);
   } else {
-    return static_cast<uint32_t>(obj.Number());
+    return static_cast<uint32_t>(i::Object::Number(obj));
   }
 }
 
@@ -7738,7 +7738,7 @@ double v8::NumberObject::ValueOf() const {
   i::Handle<i::JSPrimitiveWrapper> js_primitive_wrapper =
       i::Handle<i::JSPrimitiveWrapper>::cast(obj);
   API_RCS_SCOPE(js_primitive_wrapper->GetIsolate(), NumberObject, NumberValue);
-  return js_primitive_wrapper->value().Number();
+  return i::Object::Number(js_primitive_wrapper->value());
 }
 
 Local<v8::Value> v8::BigIntObject::New(Isolate* v8_isolate, int64_t value) {
@@ -7841,7 +7841,7 @@ double v8::Date::ValueOf() const {
   i::Handle<i::Object> obj = Utils::OpenHandle(this);
   i::Handle<i::JSDate> jsdate = i::Handle<i::JSDate>::cast(obj);
   API_RCS_SCOPE(jsdate->GetIsolate(), Date, NumberValue);
-  return jsdate->value().Number();
+  return i::Object::Number(jsdate->value());
 }
 
 v8::Local<v8::String> v8::Date::ToISOString() const {
@@ -7849,9 +7849,9 @@ v8::Local<v8::String> v8::Date::ToISOString() const {
   i::Handle<i::JSDate> jsdate = i::Handle<i::JSDate>::cast(obj);
   i::Isolate* i_isolate = jsdate->GetIsolate();
   API_RCS_SCOPE(i_isolate, Date, NumberValue);
-  i::DateBuffer buffer =
-      i::ToDateString(jsdate->value().Number(), i_isolate->date_cache(),
-                      i::ToDateStringMode::kISODateAndTime);
+  i::DateBuffer buffer = i::ToDateString(i::Object::Number(jsdate->value()),
+                                         i_isolate->date_cache(),
+                                         i::ToDateStringMode::kISODateAndTime);
   i::Handle<i::String> str = i_isolate->factory()
                                  ->NewStringFromUtf8(base::VectorOf(buffer))
                                  .ToHandleChecked();
@@ -7982,7 +7982,7 @@ uint32_t v8::Array::Length() const {
   if (i::IsSmi(length)) {
     return i::Smi::ToInt(length);
   } else {
-    return static_cast<uint32_t>(length.Number());
+    return static_cast<uint32_t>(i::Object::Number(length));
   }
 }
 
diff --git a/src/asmjs/asm-js.cc b/src/asmjs/asm-js.cc
index b42bd92145f..c02e218a8ad 100644
--- a/src/asmjs/asm-js.cc
+++ b/src/asmjs/asm-js.cc
@@ -57,7 +57,7 @@ bool AreStdlibMembersValid(Isolate* isolate, Handle<JSReceiver> stdlib,
     members.Remove(wasm::AsmJsParser::StandardMember::kInfinity);
     Handle<Name> name = isolate->factory()->Infinity_string();
     Handle<Object> value = JSReceiver::GetDataProperty(isolate, stdlib, name);
-    if (!IsNumber(*value) || !std::isinf(value->Number())) return false;
+    if (!IsNumber(*value) || !std::isinf(Object::Number(*value))) return false;
   }
   if (members.contains(wasm::AsmJsParser::StandardMember::kNaN)) {
     members.Remove(wasm::AsmJsParser::StandardMember::kNaN);
@@ -88,7 +88,8 @@ bool AreStdlibMembersValid(Isolate* isolate, Handle<JSReceiver> stdlib,
     Handle<Name> name(isolate->factory()->InternalizeString(               \
         base::StaticCharVector(#cname)));                                  \
     Handle<Object> value = StdlibMathMember(isolate, stdlib, name);        \
-    if (!IsNumber(*value) || value->Number() != const_value) return false; \
+    if (!IsNumber(*value) || Object::Number(*value) != const_value)        \
+      return false;                                                        \
   }
   STDLIB_MATH_VALUE_LIST(STDLIB_MATH_CONST)
 #undef STDLIB_MATH_CONST
diff --git a/src/ast/ast.cc b/src/ast/ast.cc
index 55453687aa2..8a74081796a 100644
--- a/src/ast/ast.cc
+++ b/src/ast/ast.cc
@@ -713,7 +713,8 @@ void ArrayLiteralBoilerplateBuilder::BuildBoilerplateDescription(
       }
 
       DCHECK_EQ(kind, GetMoreGeneralElementsKind(
-                          kind, boilerplate_value.OptimalElementsKind(
+                          kind, Object::OptimalElementsKind(
+                                    boilerplate_value,
                                     GetPtrComprCageBase(*elements))));
 
       FixedArray::cast(*elements)->set(array_index, boilerplate_value);
diff --git a/src/baseline/baseline-batch-compiler.cc b/src/baseline/baseline-batch-compiler.cc
index c699d4c167f..f31db40df6a 100644
--- a/src/baseline/baseline-batch-compiler.cc
+++ b/src/baseline/baseline-batch-compiler.cc
@@ -62,7 +62,7 @@ class BaselineCompilerTask {
     Handle<Code> code;
     if (!maybe_code_.ToHandle(&code)) return;
     if (v8_flags.print_code) {
-      code->Print();
+      Print(*code);
     }
     // Don't install the code if the bytecode has been flushed or has
     // already some baseline code installed.
@@ -76,7 +76,7 @@ class BaselineCompilerTask {
       CodeTracer::Scope scope(isolate->GetCodeTracer());
       std::stringstream ss;
       ss << "[Concurrent Sparkplug Off Thread] Function ";
-      shared_function_info_->ShortPrint(ss);
+      ShortPrint(*shared_function_info_, ss);
       ss << " installed\n";
       OFStream os(scope.file());
       os << ss.str();
diff --git a/src/baseline/baseline.cc b/src/baseline/baseline.cc
index 1a24d944228..48d2c6108da 100644
--- a/src/baseline/baseline.cc
+++ b/src/baseline/baseline.cc
@@ -64,7 +64,7 @@ MaybeHandle<Code> GenerateBaselineCode(Isolate* isolate,
   compiler.GenerateCode();
   MaybeHandle<Code> code = compiler.Build(local_isolate);
   if (v8_flags.print_code && !code.is_null()) {
-    code.ToHandleChecked()->Print();
+    Print(*code.ToHandleChecked());
   }
   return code;
 }
diff --git a/src/builtins/accessors.cc b/src/builtins/accessors.cc
index 1204d10799b..7e808d9f182 100644
--- a/src/builtins/accessors.cc
+++ b/src/builtins/accessors.cc
@@ -166,8 +166,8 @@ void Accessors::ArrayLengthSetter(
   RCS_SCOPE(isolate, RuntimeCallCounterId::kArrayLengthSetter);
   HandleScope scope(isolate);
 
-  DCHECK(Utils::OpenHandle(*name)->SameValue(
-      ReadOnlyRoots(isolate).length_string()));
+  DCHECK(Object::SameValue(*Utils::OpenHandle(*name),
+                           ReadOnlyRoots(isolate).length_string()));
 
   Handle<JSReceiver> object = Utils::OpenHandle(*info.Holder());
   Handle<JSArray> array = Handle<JSArray>::cast(object);
@@ -186,7 +186,7 @@ void Accessors::ArrayLengthSetter(
     // its property descriptor. Don't perform this check if "length" was
     // previously readonly, as this may have been called during
     // DefineOwnPropertyIgnoreAttributes().
-    if (length == array->length().Number()) {
+    if (length == Object::Number(array->length())) {
       info.GetReturnValue().Set(true);
     } else if (info.ShouldThrowOnError()) {
       Factory* factory = isolate->factory();
@@ -208,7 +208,7 @@ void Accessors::ArrayLengthSetter(
   }
 
   uint32_t actual_new_len = 0;
-  CHECK(array->length().ToArrayLength(&actual_new_len));
+  CHECK(Object::ToArrayLength(array->length(), &actual_new_len));
   // Fail if there were non-deletable elements.
   if (actual_new_len != length) {
     if (info.ShouldThrowOnError()) {
diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc
index b38b91ee698..d6fc854064d 100644
--- a/src/builtins/builtins-array.cc
+++ b/src/builtins/builtins-array.cc
@@ -139,7 +139,7 @@ V8_WARN_UNUSED_RESULT Maybe<double> GetRelativeIndex(Isolate* isolate,
     ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, relative_index_obj,
                                      Object::ToInteger(isolate, index),
                                      Nothing<double>());
-    relative_index = relative_index_obj->Number();
+    relative_index = Object::Number(*relative_index_obj);
   }
 
   if (relative_index < 0) {
@@ -154,7 +154,7 @@ V8_WARN_UNUSED_RESULT Maybe<double> GetLengthProperty(
     Isolate* isolate, Handle<JSReceiver> receiver) {
   if (IsJSArray(*receiver)) {
     Handle<JSArray> array = Handle<JSArray>::cast(receiver);
-    double length = array->length().Number();
+    double length = Object::Number(array->length());
     DCHECK(0 <= length && length <= kMaxSafeInteger);
 
     return Just(length);
@@ -164,7 +164,7 @@ V8_WARN_UNUSED_RESULT Maybe<double> GetLengthProperty(
   ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, raw_length_number,
       Object::GetLengthFromArrayLike(isolate, receiver), Nothing<double>());
-  return Just(raw_length_number->Number());
+  return Just(Object::Number(*raw_length_number));
 }
 
 // Set "length" property, has "fast-path" for JSArrays.
@@ -254,7 +254,7 @@ V8_WARN_UNUSED_RESULT Maybe<bool> TryFastArrayFill(
   // ElementAccessor::Fill is able to grow the backing store as needed, but we
   // need to ensure the JSArray's length is correctly set in case the user
   // assigned a smaller value.
-  if (array->length().Number() < end) {
+  if (Object::Number(array->length()) < end) {
     CHECK(accessor->SetLength(array, end).FromJust());
   }
 
@@ -332,7 +332,7 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPush(Isolate* isolate,
   int arg_count = args->length() - 1;
 
   // 5. If len + arg_count > 2^53-1, throw a TypeError exception.
-  double length = raw_length_number->Number();
+  double length = Object::Number(*raw_length_number);
   if (arg_count > kMaxSafeInteger - length) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewTypeError(MessageTemplate::kPushPastSafeLength,
@@ -387,7 +387,7 @@ BUILTIN(ArrayPush) {
   // Fast Elements Path
   int to_add = args.length() - 1;
   Handle<JSArray> array = Handle<JSArray>::cast(receiver);
-  uint32_t len = static_cast<uint32_t>(array->length().Number());
+  uint32_t len = static_cast<uint32_t>(Object::Number(array->length()));
   if (to_add == 0) return *isolate->factory()->NewNumberFromUint(len);
 
   // Currently fixed arrays cannot grow too big, so we should never hit this.
@@ -418,7 +418,7 @@ V8_WARN_UNUSED_RESULT Object GenericArrayPop(Isolate* isolate,
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
       isolate, raw_length_number,
       Object::GetLengthFromArrayLike(isolate, receiver));
-  double length = raw_length_number->Number();
+  double length = Object::Number(*raw_length_number);
 
   // 3. If len is zero, then.
   if (length == 0) {
@@ -473,7 +473,7 @@ BUILTIN(ArrayPop) {
   }
   Handle<JSArray> array = Handle<JSArray>::cast(receiver);
 
-  uint32_t len = static_cast<uint32_t>(array->length().Number());
+  uint32_t len = static_cast<uint32_t>(Object::Number(array->length()));
 
   if (JSArray::HasReadOnlyLength(array)) {
     return GenericArrayPop(isolate, &args);
@@ -855,7 +855,7 @@ class ArrayConcatVisitor {
 
 uint32_t EstimateElementCount(Isolate* isolate, Handle<JSArray> array) {
   DisallowGarbageCollection no_gc;
-  uint32_t length = static_cast<uint32_t>(array->length().Number());
+  uint32_t length = static_cast<uint32_t>(Object::Number(array->length()));
   int element_count = 0;
   switch (array->GetElementsKind()) {
     case PACKED_SMI_ELEMENTS:
@@ -979,7 +979,7 @@ void CollectElementIndices(Isolate* isolate, Handle<JSObject> object,
         Object k = dict->KeyAt(InternalIndex(j));
         if (!dict.IsKey(roots, k)) continue;
         DCHECK(IsNumber(k));
-        uint32_t index = static_cast<uint32_t>(k.Number());
+        uint32_t index = static_cast<uint32_t>(Object::Number(k));
         if (index < range) {
           indices->push_back(index);
         }
@@ -1105,18 +1105,18 @@ bool IterateElements(Isolate* isolate, Handle<JSReceiver> receiver,
 
   if (IsJSArray(*receiver)) {
     Handle<JSArray> array = Handle<JSArray>::cast(receiver);
-    length = static_cast<uint32_t>(array->length().Number());
+    length = static_cast<uint32_t>(Object::Number(array->length()));
   } else {
     Handle<Object> val;
     ASSIGN_RETURN_ON_EXCEPTION_VALUE(
         isolate, val, Object::GetLengthFromArrayLike(isolate, receiver), false);
-    if (visitor->index_offset() + val->Number() > kMaxSafeInteger) {
+    if (visitor->index_offset() + Object::Number(*val) > kMaxSafeInteger) {
       isolate->Throw(*isolate->factory()->NewTypeError(
           MessageTemplate::kInvalidArrayLength));
       return false;
     }
     // TODO(caitp): Support larger element indexes (up to 2^53-1).
-    if (!val->ToUint32(&length)) {
+    if (!Object::ToUint32(*val, &length)) {
       length = 0;
     }
     // TODO(cbruni): handle other element kind as well
@@ -1277,7 +1277,7 @@ static Maybe<bool> IsConcatSpreadable(Isolate* isolate, Handle<Object> obj) {
         i::Runtime::GetObjectProperty(isolate, obj, key);
     if (!maybeValue.ToHandle(&value)) return Nothing<bool>();
     if (!IsUndefined(*value, isolate))
-      return Just(value->BooleanValue(isolate));
+      return Just(Object::BooleanValue(*value, isolate));
   }
   return Object::IsArray(obj);
 }
@@ -1303,7 +1303,7 @@ Object Slow_ArrayConcat(BuiltinArguments* args, Handle<Object> species,
     uint32_t element_estimate;
     if (IsJSArray(*obj)) {
       Handle<JSArray> array(Handle<JSArray>::cast(obj));
-      length_estimate = static_cast<uint32_t>(array->length().Number());
+      length_estimate = static_cast<uint32_t>(Object::Number(array->length()));
       if (length_estimate != 0) {
         ElementsKind array_kind =
             GetPackedElementsKind(array->GetElementsKind());
@@ -1355,12 +1355,13 @@ Object Slow_ArrayConcat(BuiltinArguments* args, Handle<Object> species,
           double_storage->set(j, Smi::ToInt(*obj));
           j++;
         } else if (IsNumber(*obj)) {
-          double_storage->set(j, obj->Number());
+          double_storage->set(j, Object::Number(*obj));
           j++;
         } else {
           DisallowGarbageCollection no_gc;
           JSArray array = JSArray::cast(*obj);
-          uint32_t length = static_cast<uint32_t>(array->length().Number());
+          uint32_t length =
+              static_cast<uint32_t>(Object::Number(array->length()));
           switch (array->GetElementsKind()) {
             case HOLEY_DOUBLE_ELEMENTS:
             case PACKED_DOUBLE_ELEMENTS: {
diff --git a/src/builtins/builtins-arraybuffer.cc b/src/builtins/builtins-arraybuffer.cc
index 92f09296093..64a180e9c42 100644
--- a/src/builtins/builtins-arraybuffer.cc
+++ b/src/builtins/builtins-arraybuffer.cc
@@ -130,7 +130,7 @@ BUILTIN(ArrayBufferConstructor) {
   Handle<Object> number_length;
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, number_length,
                                      Object::ToInteger(isolate, length));
-  if (number_length->Number() < 0.0) {
+  if (Object::Number(*number_length) < 0.0) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewRangeError(MessageTemplate::kInvalidArrayBufferLength));
   }
@@ -198,9 +198,10 @@ static Object SliceHelper(BuiltinArguments args, Isolate* isolate,
 
   // * If relativeStart < 0, let first be max((len + relativeStart), 0); else
   //   let first be min(relativeStart, len).
-  double const first = (relative_start->Number() < 0)
-                           ? std::max(len + relative_start->Number(), 0.0)
-                           : std::min(relative_start->Number(), len);
+  double const first =
+      (Object::Number(*relative_start) < 0)
+          ? std::max(len + Object::Number(*relative_start), 0.0)
+          : std::min(Object::Number(*relative_start), len);
 
   // * If end is undefined, let relativeEnd be len; else let relativeEnd be ?
   //   ToInteger(end).
@@ -211,7 +212,7 @@ static Object SliceHelper(BuiltinArguments args, Isolate* isolate,
     Handle<Object> relative_end_obj;
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, relative_end_obj,
                                        Object::ToInteger(isolate, end));
-    relative_end = relative_end_obj->Number();
+    relative_end = Object::Number(*relative_end_obj);
   }
 
   // * If relativeEnd < 0, let final be max((len + relativeEnd), 0); else let
@@ -276,7 +277,7 @@ static Object SliceHelper(BuiltinArguments args, Isolate* isolate,
   }
 
   // * [AB] If SameValue(new, O) is true, throw a TypeError exception.
-  if (!is_shared && new_->SameValue(*args.receiver())) {
+  if (!is_shared && Object::SameValue(*new_, *args.receiver())) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewTypeError(MessageTemplate::kArrayBufferSpeciesThis));
   }
@@ -512,7 +513,7 @@ Object ArrayBufferTransfer(Isolate* isolate, Handle<JSArrayBuffer> array_buffer,
     Handle<Object> number_new_byte_length;
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, number_new_byte_length,
                                        Object::ToInteger(isolate, new_length));
-    if (number_new_byte_length->Number() < 0.0) {
+    if (Object::Number(*number_new_byte_length) < 0.0) {
       THROW_NEW_ERROR_RETURN_FAILURE(
           isolate, NewRangeError(MessageTemplate::kInvalidArrayBufferLength));
     }
diff --git a/src/builtins/builtins-atomics-synchronization.cc b/src/builtins/builtins-atomics-synchronization.cc
index 3285fbab4ef..cde44158d71 100644
--- a/src/builtins/builtins-atomics-synchronization.cc
+++ b/src/builtins/builtins-atomics-synchronization.cc
@@ -114,7 +114,7 @@ BUILTIN(AtomicsConditionWait) {
   if (!IsUndefined(*timeout_obj, isolate)) {
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, timeout_obj,
                                        Object::ToNumber(isolate, timeout_obj));
-    double ms = timeout_obj->Number();
+    double ms = Object::Number(*timeout_obj);
     if (!std::isnan(ms)) {
       if (ms < 0) ms = 0;
       if (ms <= static_cast<double>(std::numeric_limits<int64_t>::max())) {
@@ -164,7 +164,7 @@ BUILTIN(AtomicsConditionNotify) {
   } else {
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, count_obj,
                                        Object::ToInteger(isolate, count_obj));
-    double count_double = count_obj->Number();
+    double count_double = Object::Number(*count_obj);
     if (count_double < 0) {
       count_double = 0;
     } else if (count_double > JSAtomicsCondition::kAllWaiters) {
diff --git a/src/builtins/builtins-bigint.cc b/src/builtins/builtins-bigint.cc
index 3fa3ffe956d..90ae17bad1f 100644
--- a/src/builtins/builtins-bigint.cc
+++ b/src/builtins/builtins-bigint.cc
@@ -52,8 +52,8 @@ BUILTIN(BigIntAsUintN) {
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, bigint,
                                      BigInt::FromObject(isolate, bigint_obj));
 
-  RETURN_RESULT_OR_FAILURE(isolate,
-                           BigInt::AsUintN(isolate, bits->Number(), bigint));
+  RETURN_RESULT_OR_FAILURE(
+      isolate, BigInt::AsUintN(isolate, Object::Number(*bits), bigint));
 }
 
 BUILTIN(BigIntAsIntN) {
@@ -70,7 +70,7 @@ BUILTIN(BigIntAsIntN) {
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, bigint,
                                      BigInt::FromObject(isolate, bigint_obj));
 
-  return *BigInt::AsIntN(isolate, bits->Number(), bigint);
+  return *BigInt::AsIntN(isolate, Object::Number(*bits), bigint);
 }
 
 namespace {
@@ -108,7 +108,7 @@ Object BigIntToStringImpl(Handle<Object> receiver, Handle<Object> radix,
     // 4. Else, let radixNumber be ? ToInteger(radix).
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, radix,
                                        Object::ToInteger(isolate, radix));
-    double radix_double = radix->Number();
+    double radix_double = Object::Number(*radix);
     // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.
     if (radix_double < 2 || radix_double > 36) {
       THROW_NEW_ERROR_RETURN_FAILURE(
diff --git a/src/builtins/builtins-dataview.cc b/src/builtins/builtins-dataview.cc
index 992b4bfffb3..5c98dae3227 100644
--- a/src/builtins/builtins-dataview.cc
+++ b/src/builtins/builtins-dataview.cc
@@ -46,7 +46,7 @@ BUILTIN(DataViewConstructor) {
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
       isolate, byte_offset,
       Object::ToIndex(isolate, byte_offset, MessageTemplate::kInvalidOffset));
-  size_t view_byte_offset = byte_offset->Number();
+  size_t view_byte_offset = Object::Number(*byte_offset);
 
   // 4. If IsDetachedBuffer(buffer) is true, throw a TypeError exception.
   if (array_buffer->was_detached()) {
@@ -86,12 +86,12 @@ BUILTIN(DataViewConstructor) {
         isolate, byte_length,
         Object::ToIndex(isolate, byte_length,
                         MessageTemplate::kInvalidDataViewLength));
-    if (view_byte_offset + byte_length->Number() > buffer_byte_length) {
+    if (view_byte_offset + Object::Number(*byte_length) > buffer_byte_length) {
       THROW_NEW_ERROR_RETURN_FAILURE(
           isolate,
           NewRangeError(MessageTemplate::kInvalidDataViewLength, byte_length));
     }
-    view_byte_length = byte_length->Number();
+    view_byte_length = Object::Number(*byte_length);
   }
 
   bool is_backed_by_rab =
diff --git a/src/builtins/builtins-date.cc b/src/builtins/builtins-date.cc
index 2bbd4801f4e..f539f1f6071 100644
--- a/src/builtins/builtins-date.cc
+++ b/src/builtins/builtins-date.cc
@@ -92,7 +92,7 @@ BUILTIN(DateConstructor) {
   } else if (argc == 1) {
     Handle<Object> value = args.at(1);
     if (IsJSDate(*value)) {
-      time_val = Handle<JSDate>::cast(value)->value().Number();
+      time_val = Object::Number(Handle<JSDate>::cast(value)->value());
     } else {
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, value,
                                          Object::ToPrimitive(isolate, value));
@@ -101,7 +101,7 @@ BUILTIN(DateConstructor) {
       } else {
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, value,
                                            Object::ToNumber(isolate, value));
-        time_val = value->Number();
+        time_val = Object::Number(*value);
       }
     }
   } else {
@@ -111,34 +111,34 @@ BUILTIN(DateConstructor) {
     Handle<Object> month_object;
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, month_object,
                                        Object::ToNumber(isolate, args.at(2)));
-    double year = year_object->Number();
-    double month = month_object->Number();
+    double year = Object::Number(*year_object);
+    double month = Object::Number(*month_object);
     double date = 1.0, hours = 0.0, minutes = 0.0, seconds = 0.0, ms = 0.0;
     if (argc >= 3) {
       Handle<Object> date_object;
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, date_object,
                                          Object::ToNumber(isolate, args.at(3)));
-      date = date_object->Number();
+      date = Object::Number(*date_object);
       if (argc >= 4) {
         Handle<Object> hours_object;
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
             isolate, hours_object, Object::ToNumber(isolate, args.at(4)));
-        hours = hours_object->Number();
+        hours = Object::Number(*hours_object);
         if (argc >= 5) {
           Handle<Object> minutes_object;
           ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
               isolate, minutes_object, Object::ToNumber(isolate, args.at(5)));
-          minutes = minutes_object->Number();
+          minutes = Object::Number(*minutes_object);
           if (argc >= 6) {
             Handle<Object> seconds_object;
             ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
                 isolate, seconds_object, Object::ToNumber(isolate, args.at(6)));
-            seconds = seconds_object->Number();
+            seconds = Object::Number(*seconds_object);
             if (argc >= 7) {
               Handle<Object> ms_object;
               ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
                   isolate, ms_object, Object::ToNumber(isolate, args.at(7)));
-              ms = ms_object->Number();
+              ms = Object::Number(*ms_object);
             }
           }
         }
@@ -189,38 +189,38 @@ BUILTIN(DateUTC) {
     Handle<Object> year_object;
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, year_object,
                                        Object::ToNumber(isolate, args.at(1)));
-    year = year_object->Number();
+    year = Object::Number(*year_object);
     if (argc >= 2) {
       Handle<Object> month_object;
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, month_object,
                                          Object::ToNumber(isolate, args.at(2)));
-      month = month_object->Number();
+      month = Object::Number(*month_object);
       if (argc >= 3) {
         Handle<Object> date_object;
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
             isolate, date_object, Object::ToNumber(isolate, args.at(3)));
-        date = date_object->Number();
+        date = Object::Number(*date_object);
         if (argc >= 4) {
           Handle<Object> hours_object;
           ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
               isolate, hours_object, Object::ToNumber(isolate, args.at(4)));
-          hours = hours_object->Number();
+          hours = Object::Number(*hours_object);
           if (argc >= 5) {
             Handle<Object> minutes_object;
             ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
                 isolate, minutes_object, Object::ToNumber(isolate, args.at(5)));
-            minutes = minutes_object->Number();
+            minutes = Object::Number(*minutes_object);
             if (argc >= 6) {
               Handle<Object> seconds_object;
               ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
                   isolate, seconds_object,
                   Object::ToNumber(isolate, args.at(6)));
-              seconds = seconds_object->Number();
+              seconds = Object::Number(*seconds_object);
               if (argc >= 7) {
                 Handle<Object> ms_object;
                 ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
                     isolate, ms_object, Object::ToNumber(isolate, args.at(7)));
-                ms = ms_object->Number();
+                ms = Object::Number(*ms_object);
               }
             }
           }
@@ -245,7 +245,7 @@ BUILTIN(DatePrototypeSetDate) {
   Handle<Object> value = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, value,
                                      Object::ToNumber(isolate, value));
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
@@ -253,7 +253,8 @@ BUILTIN(DatePrototypeSetDate) {
     int time_within_day = isolate->date_cache()->TimeInDay(local_time_ms, days);
     int year, month, day;
     isolate->date_cache()->YearMonthDayFromDays(days, &year, &month, &day);
-    time_val = MakeDate(MakeDay(year, month, value->Number()), time_within_day);
+    time_val =
+        MakeDate(MakeDay(year, month, Object::Number(*value)), time_within_day);
   }
   return SetLocalDateValue(isolate, date, time_val);
 }
@@ -266,10 +267,11 @@ BUILTIN(DatePrototypeSetFullYear) {
   Handle<Object> year = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, year,
                                      Object::ToNumber(isolate, year));
-  double year_double = year->Number(), month_double = 0.0, day_double = 1.0;
+  double year_double = Object::Number(*year), month_double = 0.0,
+         day_double = 1.0;
   int time_within_day = 0;
-  if (!std::isnan(date->value().Number())) {
-    int64_t const time_ms = static_cast<int64_t>(date->value().Number());
+  if (!std::isnan(Object::Number(date->value()))) {
+    int64_t const time_ms = static_cast<int64_t>(Object::Number(date->value()));
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
     int const days = isolate->date_cache()->DaysFromTime(local_time_ms);
     time_within_day = isolate->date_cache()->TimeInDay(local_time_ms, days);
@@ -283,12 +285,12 @@ BUILTIN(DatePrototypeSetFullYear) {
     Handle<Object> month = args.at(2);
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, month,
                                        Object::ToNumber(isolate, month));
-    month_double = month->Number();
+    month_double = Object::Number(*month);
     if (argc >= 3) {
       Handle<Object> day = args.at(3);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, day,
                                          Object::ToNumber(isolate, day));
-      day_double = day->Number();
+      day_double = Object::Number(*day);
     }
   }
   double time_val =
@@ -304,8 +306,8 @@ BUILTIN(DatePrototypeSetHours) {
   Handle<Object> hour = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, hour,
                                      Object::ToNumber(isolate, hour));
-  double h = hour->Number();
-  double time_val = date->value().Number();
+  double h = Object::Number(*hour);
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
@@ -318,17 +320,17 @@ BUILTIN(DatePrototypeSetHours) {
       Handle<Object> min = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, min,
                                          Object::ToNumber(isolate, min));
-      m = min->Number();
+      m = Object::Number(*min);
       if (argc >= 3) {
         Handle<Object> sec = args.at(3);
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, sec,
                                            Object::ToNumber(isolate, sec));
-        s = sec->Number();
+        s = Object::Number(*sec);
         if (argc >= 4) {
           Handle<Object> ms = args.at(4);
           ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                              Object::ToNumber(isolate, ms));
-          milli = ms->Number();
+          milli = Object::Number(*ms);
         }
       }
     }
@@ -344,7 +346,7 @@ BUILTIN(DatePrototypeSetMilliseconds) {
   Handle<Object> ms = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                      Object::ToNumber(isolate, ms));
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
@@ -353,7 +355,7 @@ BUILTIN(DatePrototypeSetMilliseconds) {
     int h = time_within_day / (60 * 60 * 1000);
     int m = (time_within_day / (60 * 1000)) % 60;
     int s = (time_within_day / 1000) % 60;
-    time_val = MakeDate(day, MakeTime(h, m, s, ms->Number()));
+    time_val = MakeDate(day, MakeTime(h, m, s, Object::Number(*ms)));
   }
   return SetLocalDateValue(isolate, date, time_val);
 }
@@ -366,26 +368,26 @@ BUILTIN(DatePrototypeSetMinutes) {
   Handle<Object> min = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, min,
                                      Object::ToNumber(isolate, min));
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
     int day = isolate->date_cache()->DaysFromTime(local_time_ms);
     int time_within_day = isolate->date_cache()->TimeInDay(local_time_ms, day);
     int h = time_within_day / (60 * 60 * 1000);
-    double m = min->Number();
+    double m = Object::Number(*min);
     double s = (time_within_day / 1000) % 60;
     double milli = time_within_day % 1000;
     if (argc >= 2) {
       Handle<Object> sec = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, sec,
                                          Object::ToNumber(isolate, sec));
-      s = sec->Number();
+      s = Object::Number(*sec);
       if (argc >= 3) {
         Handle<Object> ms = args.at(3);
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                            Object::ToNumber(isolate, ms));
-        milli = ms->Number();
+        milli = Object::Number(*ms);
       }
     }
     time_val = MakeDate(day, MakeTime(h, m, s, milli));
@@ -401,7 +403,7 @@ BUILTIN(DatePrototypeSetMonth) {
   Handle<Object> month = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, month,
                                      Object::ToNumber(isolate, month));
-  double time_val = this_date->value().Number();
+  double time_val = Object::Number(this_date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
@@ -409,13 +411,13 @@ BUILTIN(DatePrototypeSetMonth) {
     int time_within_day = isolate->date_cache()->TimeInDay(local_time_ms, days);
     int year, unused, day;
     isolate->date_cache()->YearMonthDayFromDays(days, &year, &unused, &day);
-    double m = month->Number();
+    double m = Object::Number(*month);
     double dt = day;
     if (argc >= 2) {
       Handle<Object> date = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, date,
                                          Object::ToNumber(isolate, date));
-      dt = date->Number();
+      dt = Object::Number(*date);
     }
     time_val = MakeDate(MakeDay(year, m, dt), time_within_day);
   }
@@ -430,7 +432,7 @@ BUILTIN(DatePrototypeSetSeconds) {
   Handle<Object> sec = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, sec,
                                      Object::ToNumber(isolate, sec));
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
@@ -438,13 +440,13 @@ BUILTIN(DatePrototypeSetSeconds) {
     int time_within_day = isolate->date_cache()->TimeInDay(local_time_ms, day);
     int h = time_within_day / (60 * 60 * 1000);
     double m = (time_within_day / (60 * 1000)) % 60;
-    double s = sec->Number();
+    double s = Object::Number(*sec);
     double milli = time_within_day % 1000;
     if (argc >= 2) {
       Handle<Object> ms = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                          Object::ToNumber(isolate, ms));
-      milli = ms->Number();
+      milli = Object::Number(*ms);
     }
     time_val = MakeDate(day, MakeTime(h, m, s, milli));
   }
@@ -458,7 +460,7 @@ BUILTIN(DatePrototypeSetTime) {
   Handle<Object> value = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, value,
                                      Object::ToNumber(isolate, value));
-  return *JSDate::SetValue(date, DateCache::TimeClip(value->Number()));
+  return *JSDate::SetValue(date, DateCache::TimeClip(Object::Number(*value)));
 }
 
 // ES6 section 20.3.4.28 Date.prototype.setUTCDate ( date )
@@ -468,14 +470,14 @@ BUILTIN(DatePrototypeSetUTCDate) {
   Handle<Object> value = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, value,
                                      Object::ToNumber(isolate, value));
-  if (std::isnan(date->value().Number())) return date->value();
-  int64_t const time_ms = static_cast<int64_t>(date->value().Number());
+  if (std::isnan(Object::Number(date->value()))) return date->value();
+  int64_t const time_ms = static_cast<int64_t>(Object::Number(date->value()));
   int const days = isolate->date_cache()->DaysFromTime(time_ms);
   int const time_within_day = isolate->date_cache()->TimeInDay(time_ms, days);
   int year, month, day;
   isolate->date_cache()->YearMonthDayFromDays(days, &year, &month, &day);
   double const time_val =
-      MakeDate(MakeDay(year, month, value->Number()), time_within_day);
+      MakeDate(MakeDay(year, month, Object::Number(*value)), time_within_day);
   return *JSDate::SetValue(date, DateCache::TimeClip(time_val));
 }
 
@@ -487,10 +489,11 @@ BUILTIN(DatePrototypeSetUTCFullYear) {
   Handle<Object> year = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, year,
                                      Object::ToNumber(isolate, year));
-  double year_double = year->Number(), month_double = 0.0, day_double = 1.0;
+  double year_double = Object::Number(*year), month_double = 0.0,
+         day_double = 1.0;
   int time_within_day = 0;
-  if (!std::isnan(date->value().Number())) {
-    int64_t const time_ms = static_cast<int64_t>(date->value().Number());
+  if (!std::isnan(Object::Number(date->value()))) {
+    int64_t const time_ms = static_cast<int64_t>(Object::Number(date->value()));
     int const days = isolate->date_cache()->DaysFromTime(time_ms);
     time_within_day = isolate->date_cache()->TimeInDay(time_ms, days);
     int year_int, month_int, day_int;
@@ -503,12 +506,12 @@ BUILTIN(DatePrototypeSetUTCFullYear) {
     Handle<Object> month = args.at(2);
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, month,
                                        Object::ToNumber(isolate, month));
-    month_double = month->Number();
+    month_double = Object::Number(*month);
     if (argc >= 3) {
       Handle<Object> day = args.at(3);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, day,
                                          Object::ToNumber(isolate, day));
-      day_double = day->Number();
+      day_double = Object::Number(*day);
     }
   }
   double const time_val =
@@ -524,8 +527,8 @@ BUILTIN(DatePrototypeSetUTCHours) {
   Handle<Object> hour = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, hour,
                                      Object::ToNumber(isolate, hour));
-  double h = hour->Number();
-  double time_val = date->value().Number();
+  double h = Object::Number(*hour);
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int day = isolate->date_cache()->DaysFromTime(time_ms);
@@ -537,17 +540,17 @@ BUILTIN(DatePrototypeSetUTCHours) {
       Handle<Object> min = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, min,
                                          Object::ToNumber(isolate, min));
-      m = min->Number();
+      m = Object::Number(*min);
       if (argc >= 3) {
         Handle<Object> sec = args.at(3);
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, sec,
                                            Object::ToNumber(isolate, sec));
-        s = sec->Number();
+        s = Object::Number(*sec);
         if (argc >= 4) {
           Handle<Object> ms = args.at(4);
           ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                              Object::ToNumber(isolate, ms));
-          milli = ms->Number();
+          milli = Object::Number(*ms);
         }
       }
     }
@@ -563,7 +566,7 @@ BUILTIN(DatePrototypeSetUTCMilliseconds) {
   Handle<Object> ms = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                      Object::ToNumber(isolate, ms));
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int day = isolate->date_cache()->DaysFromTime(time_ms);
@@ -571,7 +574,7 @@ BUILTIN(DatePrototypeSetUTCMilliseconds) {
     int h = time_within_day / (60 * 60 * 1000);
     int m = (time_within_day / (60 * 1000)) % 60;
     int s = (time_within_day / 1000) % 60;
-    time_val = MakeDate(day, MakeTime(h, m, s, ms->Number()));
+    time_val = MakeDate(day, MakeTime(h, m, s, Object::Number(*ms)));
   }
   return *JSDate::SetValue(date, DateCache::TimeClip(time_val));
 }
@@ -584,25 +587,25 @@ BUILTIN(DatePrototypeSetUTCMinutes) {
   Handle<Object> min = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, min,
                                      Object::ToNumber(isolate, min));
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int day = isolate->date_cache()->DaysFromTime(time_ms);
     int time_within_day = isolate->date_cache()->TimeInDay(time_ms, day);
     int h = time_within_day / (60 * 60 * 1000);
-    double m = min->Number();
+    double m = Object::Number(*min);
     double s = (time_within_day / 1000) % 60;
     double milli = time_within_day % 1000;
     if (argc >= 2) {
       Handle<Object> sec = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, sec,
                                          Object::ToNumber(isolate, sec));
-      s = sec->Number();
+      s = Object::Number(*sec);
       if (argc >= 3) {
         Handle<Object> ms = args.at(3);
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                            Object::ToNumber(isolate, ms));
-        milli = ms->Number();
+        milli = Object::Number(*ms);
       }
     }
     time_val = MakeDate(day, MakeTime(h, m, s, milli));
@@ -618,20 +621,20 @@ BUILTIN(DatePrototypeSetUTCMonth) {
   Handle<Object> month = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, month,
                                      Object::ToNumber(isolate, month));
-  double time_val = this_date->value().Number();
+  double time_val = Object::Number(this_date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int days = isolate->date_cache()->DaysFromTime(time_ms);
     int time_within_day = isolate->date_cache()->TimeInDay(time_ms, days);
     int year, unused, day;
     isolate->date_cache()->YearMonthDayFromDays(days, &year, &unused, &day);
-    double m = month->Number();
+    double m = Object::Number(*month);
     double dt = day;
     if (argc >= 2) {
       Handle<Object> date = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, date,
                                          Object::ToNumber(isolate, date));
-      dt = date->Number();
+      dt = Object::Number(*date);
     }
     time_val = MakeDate(MakeDay(year, m, dt), time_within_day);
   }
@@ -646,20 +649,20 @@ BUILTIN(DatePrototypeSetUTCSeconds) {
   Handle<Object> sec = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, sec,
                                      Object::ToNumber(isolate, sec));
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (!std::isnan(time_val)) {
     int64_t const time_ms = static_cast<int64_t>(time_val);
     int day = isolate->date_cache()->DaysFromTime(time_ms);
     int time_within_day = isolate->date_cache()->TimeInDay(time_ms, day);
     int h = time_within_day / (60 * 60 * 1000);
     double m = (time_within_day / (60 * 1000)) % 60;
-    double s = sec->Number();
+    double s = Object::Number(*sec);
     double milli = time_within_day % 1000;
     if (argc >= 2) {
       Handle<Object> ms = args.at(2);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, ms,
                                          Object::ToNumber(isolate, ms));
-      milli = ms->Number();
+      milli = Object::Number(*ms);
     }
     time_val = MakeDate(day, MakeTime(h, m, s, milli));
   }
@@ -671,7 +674,7 @@ BUILTIN(DatePrototypeToDateString) {
   HandleScope scope(isolate);
   CHECK_RECEIVER(JSDate, date, "Date.prototype.toDateString");
   DateBuffer buffer =
-      ToDateString(date->value().Number(), isolate->date_cache(),
+      ToDateString(Object::Number(date->value()), isolate->date_cache(),
                    ToDateStringMode::kLocalDate);
   RETURN_RESULT_OR_FAILURE(
       isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
@@ -681,7 +684,7 @@ BUILTIN(DatePrototypeToDateString) {
 BUILTIN(DatePrototypeToISOString) {
   HandleScope scope(isolate);
   CHECK_RECEIVER(JSDate, date, "Date.prototype.toISOString");
-  double const time_val = date->value().Number();
+  double const time_val = Object::Number(date->value());
   if (std::isnan(time_val)) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewRangeError(MessageTemplate::kInvalidTimeValue));
@@ -697,7 +700,7 @@ BUILTIN(DatePrototypeToString) {
   HandleScope scope(isolate);
   CHECK_RECEIVER(JSDate, date, "Date.prototype.toString");
   DateBuffer buffer =
-      ToDateString(date->value().Number(), isolate->date_cache(),
+      ToDateString(Object::Number(date->value()), isolate->date_cache(),
                    ToDateStringMode::kLocalDateAndTime);
   RETURN_RESULT_OR_FAILURE(
       isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
@@ -708,7 +711,7 @@ BUILTIN(DatePrototypeToTimeString) {
   HandleScope scope(isolate);
   CHECK_RECEIVER(JSDate, date, "Date.prototype.toTimeString");
   DateBuffer buffer =
-      ToDateString(date->value().Number(), isolate->date_cache(),
+      ToDateString(Object::Number(date->value()), isolate->date_cache(),
                    ToDateStringMode::kLocalTime);
   RETURN_RESULT_OR_FAILURE(
       isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
@@ -781,7 +784,7 @@ BUILTIN(DatePrototypeToUTCString) {
   HandleScope scope(isolate);
   CHECK_RECEIVER(JSDate, date, "Date.prototype.toUTCString");
   DateBuffer buffer =
-      ToDateString(date->value().Number(), isolate->date_cache(),
+      ToDateString(Object::Number(date->value()), isolate->date_cache(),
                    ToDateStringMode::kUTCDateAndTime);
   RETURN_RESULT_OR_FAILURE(
       isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
@@ -791,7 +794,7 @@ BUILTIN(DatePrototypeToUTCString) {
 BUILTIN(DatePrototypeGetYear) {
   HandleScope scope(isolate);
   CHECK_RECEIVER(JSDate, date, "Date.prototype.getYear");
-  double time_val = date->value().Number();
+  double time_val = Object::Number(date->value());
   if (std::isnan(time_val)) return date->value();
   int64_t time_ms = static_cast<int64_t>(time_val);
   int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
@@ -808,7 +811,8 @@ BUILTIN(DatePrototypeSetYear) {
   Handle<Object> year = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, year,
                                      Object::ToNumber(isolate, year));
-  double month_double = 0.0, day_double = 1.0, year_double = year->Number();
+  double month_double = 0.0, day_double = 1.0,
+         year_double = Object::Number(*year);
   if (!std::isnan(year_double)) {
     double year_int = DoubleToInteger(year_double);
     if (0.0 <= year_int && year_int <= 99.0) {
@@ -816,8 +820,8 @@ BUILTIN(DatePrototypeSetYear) {
     }
   }
   int time_within_day = 0;
-  if (!std::isnan(date->value().Number())) {
-    int64_t const time_ms = static_cast<int64_t>(date->value().Number());
+  if (!std::isnan(Object::Number(date->value()))) {
+    int64_t const time_ms = static_cast<int64_t>(Object::Number(date->value()));
     int64_t local_time_ms = isolate->date_cache()->ToLocal(time_ms);
     int const days = isolate->date_cache()->DaysFromTime(local_time_ms);
     time_within_day = isolate->date_cache()->TimeInDay(local_time_ms, days);
@@ -843,7 +847,7 @@ BUILTIN(DatePrototypeToJson) {
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
       isolate, primitive,
       Object::ToPrimitive(isolate, receiver_obj, ToPrimitiveHint::kNumber));
-  if (IsNumber(*primitive) && !std::isfinite(primitive->Number())) {
+  if (IsNumber(*primitive) && !std::isfinite(Object::Number(*primitive))) {
     return ReadOnlyRoots(isolate).null_value();
   } else {
     Handle<String> name =
diff --git a/src/builtins/builtins-function.cc b/src/builtins/builtins-function.cc
index bbf77e43ccc..a4a2324dad9 100644
--- a/src/builtins/builtins-function.cc
+++ b/src/builtins/builtins-function.cc
@@ -73,7 +73,7 @@ MaybeHandle<Object> CreateDynamicFunction(Isolate* isolate,
 
   bool is_code_like = true;
   for (int i = 0; i < argc; ++i) {
-    if (!args.at(i + 1)->IsCodeLike(isolate)) {
+    if (!Object::IsCodeLike(*args.at(i + 1), isolate)) {
       is_code_like = false;
       break;
     }
diff --git a/src/builtins/builtins-intl.cc b/src/builtins/builtins-intl.cc
index e6fafb1b8a8..794687ef3f9 100644
--- a/src/builtins/builtins-intl.cc
+++ b/src/builtins/builtins-intl.cc
@@ -253,7 +253,7 @@ Object LegacyFormatConstructor(BuiltinArguments args, Isolate* isolate,
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
         isolate, ordinary_has_instance_obj,
         Object::OrdinaryHasInstance(isolate, constructor, receiver));
-    if (ordinary_has_instance_obj->BooleanValue(isolate)) {
+    if (Object::BooleanValue(*ordinary_has_instance_obj, isolate)) {
       if (!IsJSReceiver(*receiver)) {
         THROW_NEW_ERROR_RETURN_FAILURE(
             isolate, NewTypeError(MessageTemplate::kIncompatibleMethodReceiver,
@@ -1027,7 +1027,7 @@ BUILTIN(PluralRulesPrototypeSelect) {
   Handle<Object> number = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, number,
                                      Object::ToNumber(isolate, number));
-  double number_double = number->Number();
+  double number_double = Object::Number(*number);
 
   // 4. Return ! ResolvePlural(pr, n).
   RETURN_RESULT_OR_FAILURE(isolate, JSPluralRules::ResolvePlural(
@@ -1079,8 +1079,9 @@ BUILTIN(PluralRulesPrototypeSelectRange) {
   }
 
   RETURN_RESULT_OR_FAILURE(
-      isolate, JSPluralRules::ResolvePluralRange(isolate, plural_rules,
-                                                 x->Number(), y->Number()));
+      isolate,
+      JSPluralRules::ResolvePluralRange(
+          isolate, plural_rules, Object::Number(*x), Object::Number(*y)));
 }
 
 BUILTIN(PluralRulesSupportedLocalesOf) {
@@ -1245,7 +1246,7 @@ BUILTIN(SegmentsPrototypeContaining) {
   // 6. Let n be ? ToInteger(index).
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, index,
                                      Object::ToInteger(isolate, index));
-  double const n = index->Number();
+  double const n = Object::Number(*index);
 
   RETURN_RESULT_OR_FAILURE(isolate,
                            JSSegments::Containing(isolate, segments, n));
diff --git a/src/builtins/builtins-number.cc b/src/builtins/builtins-number.cc
index 9dfed6eb9d2..8a14852b363 100644
--- a/src/builtins/builtins-number.cc
+++ b/src/builtins/builtins-number.cc
@@ -35,12 +35,12 @@ BUILTIN(NumberPrototypeToExponential) {
                                   "Number.prototype.toExponential"),
                               isolate->factory()->Number_string()));
   }
-  double const value_number = value->Number();
+  double const value_number = Object::Number(*value);
 
   // Convert the {fraction_digits} to an integer first.
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
       isolate, fraction_digits, Object::ToInteger(isolate, fraction_digits));
-  double const fraction_digits_number = fraction_digits->Number();
+  double const fraction_digits_number = Object::Number(*fraction_digits);
 
   if (std::isnan(value_number)) return ReadOnlyRoots(isolate).NaN_string();
   if (std::isinf(value_number)) {
@@ -80,12 +80,12 @@ BUILTIN(NumberPrototypeToFixed) {
                                   "Number.prototype.toFixed"),
                               isolate->factory()->Number_string()));
   }
-  double const value_number = value->Number();
+  double const value_number = Object::Number(*value);
 
   // Convert the {fraction_digits} to an integer first.
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
       isolate, fraction_digits, Object::ToInteger(isolate, fraction_digits));
-  double const fraction_digits_number = fraction_digits->Number();
+  double const fraction_digits_number = Object::Number(*fraction_digits);
 
   // Check if the {fraction_digits} are in the supported range.
   if (fraction_digits_number < 0.0 ||
@@ -158,7 +158,7 @@ BUILTIN(NumberPrototypeToPrecision) {
                                   "Number.prototype.toPrecision"),
                               isolate->factory()->Number_string()));
   }
-  double const value_number = value->Number();
+  double const value_number = Object::Number(*value);
 
   // If no {precision} was specified, just return ToString of {value}.
   if (IsUndefined(*precision, isolate)) {
@@ -168,7 +168,7 @@ BUILTIN(NumberPrototypeToPrecision) {
   // Convert the {precision} to an integer first.
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, precision,
                                      Object::ToInteger(isolate, precision));
-  double const precision_number = precision->Number();
+  double const precision_number = Object::Number(*precision);
 
   if (std::isnan(value_number)) return ReadOnlyRoots(isolate).NaN_string();
   if (std::isinf(value_number)) {
diff --git a/src/builtins/builtins-sharedarraybuffer.cc b/src/builtins/builtins-sharedarraybuffer.cc
index 10bfc77e984..159f44b5c2c 100644
--- a/src/builtins/builtins-sharedarraybuffer.cc
+++ b/src/builtins/builtins-sharedarraybuffer.cc
@@ -45,7 +45,8 @@ BUILTIN(AtomicsIsLockFree) {
   Handle<Object> size = args.atOrUndefined(isolate, 1);
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, size,
                                      Object::ToNumber(isolate, size));
-  return *isolate->factory()->ToBoolean(AtomicIsLockFree(size->Number()));
+  return *isolate->factory()->ToBoolean(
+      AtomicIsLockFree(Object::Number(*size)));
 }
 
 // https://tc39.es/ecma262/#sec-validatesharedintegertypedarray
@@ -149,7 +150,7 @@ BUILTIN(AtomicsNotify) {
   } else {
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, count,
                                        Object::ToInteger(isolate, count));
-    double count_double = count->Number();
+    double count_double = Object::Number(*count);
     if (count_double < 0) {
       count_double = 0;
     } else if (count_double > kMaxUInt32) {
@@ -214,13 +215,13 @@ Object DoWait(Isolate* isolate, FutexEmulation::WaitMode mode,
   // 8. If q is NaN, let t be +, else let t be max(q, 0).
   double timeout_number;
   if (IsUndefined(*timeout, isolate)) {
-    timeout_number = ReadOnlyRoots(isolate).infinity_value()->Number();
+    timeout_number = Object::Number(*ReadOnlyRoots(isolate).infinity_value());
   } else {
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, timeout,
                                        Object::ToNumber(isolate, timeout));
-    timeout_number = timeout->Number();
+    timeout_number = Object::Number(*timeout);
     if (std::isnan(timeout_number))
-      timeout_number = ReadOnlyRoots(isolate).infinity_value()->Number();
+      timeout_number = Object::Number(*ReadOnlyRoots(isolate).infinity_value());
     else if (timeout_number < 0)
       timeout_number = 0;
   }
diff --git a/src/builtins/builtins-string.cc b/src/builtins/builtins-string.cc
index b3bce1b0e1e..db193bdf8bd 100644
--- a/src/builtins/builtins-string.cc
+++ b/src/builtins/builtins-string.cc
@@ -28,12 +28,12 @@ bool IsValidCodePoint(Isolate* isolate, Handle<Object> value) {
     return false;
   }
 
-  if (Object::ToInteger(isolate, value).ToHandleChecked()->Number() !=
-      value->Number()) {
+  if (Object::Number(*Object::ToInteger(isolate, value).ToHandleChecked()) !=
+      Object::Number(*value)) {
     return false;
   }
 
-  if (value->Number() < 0 || value->Number() > 0x10FFFF) {
+  if (Object::Number(*value) < 0 || Object::Number(*value) > 0x10FFFF) {
     return false;
   }
 
@@ -51,7 +51,7 @@ base::uc32 NextCodePoint(Isolate* isolate, BuiltinArguments args, int index) {
         MessageTemplate::kInvalidCodePoint, value));
     return kInvalidCodePoint;
   }
-  return DoubleToUint32(value->Number());
+  return DoubleToUint32(Object::Number(*value));
 }
 
 }  // namespace
@@ -454,7 +454,7 @@ BUILTIN(StringRaw) {
   IncrementalStringBuilder result_builder(isolate);
   // Intentional spec violation: we ignore {length} values >= 2^32, because
   // assuming non-empty chunks they would generate too-long strings anyway.
-  const double raw_len_number = raw_len->Number();
+  const double raw_len_number = Object::Number(*raw_len);
   const uint32_t length = raw_len_number > std::numeric_limits<uint32_t>::max()
                               ? std::numeric_limits<uint32_t>::max()
                               : static_cast<uint32_t>(raw_len_number);
diff --git a/src/builtins/builtins-struct.cc b/src/builtins/builtins-struct.cc
index 0fc64d4cdb4..dc9456ce2a1 100644
--- a/src/builtins/builtins-struct.cc
+++ b/src/builtins/builtins-struct.cc
@@ -119,7 +119,7 @@ BUILTIN(SharedStructTypeConstructor) {
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
       isolate, raw_length_number,
       Object::GetLengthFromArrayLike(isolate, property_names_arg));
-  double num_properties_double = raw_length_number->Number();
+  double num_properties_double = Object::Number(*raw_length_number);
   if (num_properties_double < 0 || num_properties_double > kMaxJSStructFields) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewRangeError(MessageTemplate::kStructFieldCountOutOfRange));
diff --git a/src/builtins/builtins-temporal.cc b/src/builtins/builtins-temporal.cc
index 449621c8df2..be1265f817b 100644
--- a/src/builtins/builtins-temporal.cc
+++ b/src/builtins/builtins-temporal.cc
@@ -156,7 +156,7 @@ namespace internal {
         BigInt::Divide(isolate, Handle<BigInt>(handle->field(), isolate), \
                        BigInt::FromUint64(isolate, scale)));              \
     Handle<Object> number = BigInt::ToNumber(isolate, value);             \
-    DCHECK(std::isfinite(number->Number()));                              \
+    DCHECK(std::isfinite(Object::Number(*number)));                       \
     return *number;                                                       \
   }
 
diff --git a/src/builtins/builtins-trace.cc b/src/builtins/builtins-trace.cc
index 5c4040b830e..59fdcf661a7 100644
--- a/src/builtins/builtins-trace.cc
+++ b/src/builtins/builtins-trace.cc
@@ -148,7 +148,7 @@ BUILTIN(Trace) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewTypeError(MessageTemplate::kTraceEventPhaseError));
   }
-  char phase = static_cast<char>(DoubleToInt32(phase_arg->Number()));
+  char phase = static_cast<char>(DoubleToInt32(Object::Number(*phase_arg)));
   if (!IsString(*category)) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewTypeError(MessageTemplate::kTraceEventCategoryError));
@@ -166,7 +166,7 @@ BUILTIN(Trace) {
           isolate, NewTypeError(MessageTemplate::kTraceEventIDError));
     }
     flags |= TRACE_EVENT_FLAG_HAS_ID;
-    id = DoubleToInt32(id_arg->Number());
+    id = DoubleToInt32(Object::Number(*id_arg));
   }
 
   Handle<String> name_str = Handle<String>::cast(name_arg);
diff --git a/src/builtins/builtins-weak-refs.cc b/src/builtins/builtins-weak-refs.cc
index eef9de1cb1d..32cc43019dc 100644
--- a/src/builtins/builtins-weak-refs.cc
+++ b/src/builtins/builtins-weak-refs.cc
@@ -23,7 +23,7 @@ BUILTIN(FinalizationRegistryUnregister) {
 
   // 3. If CanBeHeldWeakly(unregisterToken) is false, throw a TypeError
   // exception.
-  if (!unregister_token->CanBeHeldWeakly()) {
+  if (!Object::CanBeHeldWeakly(*unregister_token)) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewTypeError(MessageTemplate::kInvalidWeakRefsUnregisterToken,
                               unregister_token));
diff --git a/src/codegen/compiler.cc b/src/codegen/compiler.cc
index 43367d09224..8de7d7398bb 100644
--- a/src/codegen/compiler.cc
+++ b/src/codegen/compiler.cc
@@ -267,7 +267,7 @@ class CompilerTracer : public AllStatic {
     if (!v8_flags.trace_opt) return;
     CodeTracer::Scope scope(isolate->GetCodeTracer());
     PrintF(scope.file(), "[marking ");
-    function->ShortPrint(scope.file());
+    ShortPrint(*function, scope.file());
     PrintF(scope.file(),
            " for optimized recompilation because --always-turbofan");
     PrintF(scope.file(), "]\n");
@@ -284,7 +284,7 @@ class CompilerTracer : public AllStatic {
                                const char* header, Handle<JSFunction> function,
                                CodeKind code_kind) {
     PrintF(scope.file(), "[%s ", header);
-    function->ShortPrint(scope.file());
+    ShortPrint(*function, scope.file());
     PrintF(scope.file(), " (target %s)", CodeKindToString(code_kind));
   }
 
@@ -293,7 +293,7 @@ class CompilerTracer : public AllStatic {
                                Handle<SharedFunctionInfo> shared,
                                CodeKind code_kind) {
     PrintF(scope.file(), "[%s ", header);
-    shared->ShortPrint(scope.file());
+    ShortPrint(*shared, scope.file());
     PrintF(scope.file(), " (target %s)", CodeKindToString(code_kind));
   }
 
@@ -1093,7 +1093,7 @@ bool CompileTurbofan_Concurrent(Isolate* isolate,
   if (!isolate->optimizing_compile_dispatcher()->IsQueueAvailable()) {
     if (v8_flags.trace_concurrent_recompilation) {
       PrintF("  ** Compilation queue full, will retry optimizing ");
-      function->ShortPrint();
+      ShortPrint(*function);
       PrintF(" later.\n");
     }
     return false;
@@ -1102,7 +1102,7 @@ bool CompileTurbofan_Concurrent(Isolate* isolate,
   if (isolate->heap()->HighMemoryPressure()) {
     if (v8_flags.trace_concurrent_recompilation) {
       PrintF("  ** High memory pressure, will retry optimizing ");
-      function->ShortPrint();
+      ShortPrint(*function);
       PrintF(" later.\n");
     }
     return false;
@@ -1124,7 +1124,7 @@ bool CompileTurbofan_Concurrent(Isolate* isolate,
 
   if (v8_flags.trace_concurrent_recompilation) {
     PrintF("  ** Queued ");
-    function->ShortPrint();
+    ShortPrint(*function);
     PrintF(" for concurrent optimization.\n");
   }
 
@@ -2254,7 +2254,7 @@ MaybeHandle<SharedFunctionInfo> BackgroundCompileTask::FinalizeScript(
         merge.CompleteMergeInForeground(isolate, script);
     maybe_result = result;
     script = handle(Script::cast(result->script()), isolate);
-    DCHECK(script->source().StrictEquals(*source));
+    DCHECK(Object::StrictEquals(script->source(), *source));
     DCHECK(isolate->factory()->script_list()->Contains(
         MaybeObject::MakeWeak(MaybeObject::FromObject(*script))));
   } else {
@@ -3038,7 +3038,7 @@ std::pair<MaybeHandle<String>, bool> Compiler::ValidateDynamicCompilationSource(
     // If we run into this condition, the embedder has marked some object
     // templates as "code like", but has given us a callback that only accepts
     // strings. That makes no sense.
-    DCHECK(!original_source->IsCodeLike(isolate));
+    DCHECK(!Object::IsCodeLike(*original_source, isolate));
 
     if (!IsString(*original_source)) {
       return {MaybeHandle<String>(), true};
@@ -3067,7 +3067,7 @@ std::pair<MaybeHandle<String>, bool> Compiler::ValidateDynamicCompilationSource(
   }
 
   if (!IsFalse(context->allow_code_gen_from_strings(), isolate) &&
-      original_source->IsCodeLike(isolate)) {
+      Object::IsCodeLike(*original_source, isolate)) {
     // Codegen is unconditionally allowed, and we're been given a CodeLike
     // object. Stringify.
     MaybeHandle<String> stringified_source =
diff --git a/src/codegen/external-reference.cc b/src/codegen/external-reference.cc
index 41d7fc69342..72a80a1ce26 100644
--- a/src/codegen/external-reference.cc
+++ b/src/codegen/external-reference.cc
@@ -1147,7 +1147,7 @@ FUNCTION_REFERENCE(orderedhashmap_gethash_raw, OrderedHashMap::GetHash)
 
 Address GetOrCreateHash(Isolate* isolate, Address raw_key) {
   DisallowGarbageCollection no_gc;
-  return Object(raw_key).GetOrCreateHash(isolate).ptr();
+  return Object::GetOrCreateHash(Object(raw_key), isolate).ptr();
 }
 
 FUNCTION_REFERENCE(get_or_create_hash_raw, GetOrCreateHash)
diff --git a/src/codegen/pending-optimization-table.cc b/src/codegen/pending-optimization-table.cc
index 6433fc81d59..fe7913ab0bd 100644
--- a/src/codegen/pending-optimization-table.cc
+++ b/src/codegen/pending-optimization-table.cc
@@ -39,7 +39,7 @@ void ManualOptimizationTable::CheckMarkedForManualOptimization(
     Isolate* isolate, JSFunction function) {
   if (!IsMarkedForManualOptimization(isolate, function)) {
     PrintF("Error: Function ");
-    function.ShortPrint();
+    ShortPrint(function);
     PrintF(
         " should be prepared for optimization with "
         "%%PrepareFunctionForOptimization before  "
diff --git a/src/compiler-dispatcher/lazy-compile-dispatcher.cc b/src/compiler-dispatcher/lazy-compile-dispatcher.cc
index e9c0fde65bb..518bcdfb834 100644
--- a/src/compiler-dispatcher/lazy-compile-dispatcher.cc
+++ b/src/compiler-dispatcher/lazy-compile-dispatcher.cc
@@ -166,7 +166,7 @@ void LazyCompileDispatcher::Enqueue(
     base::MutexGuard lock(&mutex_);
     if (trace_compiler_dispatcher_) {
       PrintF("LazyCompileDispatcher: enqueued job for ");
-      shared_info->ShortPrint();
+      ShortPrint(*shared_info);
       PrintF("\n");
     }
 
@@ -250,7 +250,7 @@ bool LazyCompileDispatcher::FinishNow(Handle<SharedFunctionInfo> function) {
   RCS_SCOPE(isolate_, RuntimeCallCounterId::kCompileFinishNowOnDispatcher);
   if (trace_compiler_dispatcher_) {
     PrintF("LazyCompileDispatcher: finishing ");
-    function->ShortPrint();
+    ShortPrint(*function);
     PrintF(" now\n");
   }
 
@@ -298,7 +298,7 @@ bool LazyCompileDispatcher::FinishNow(Handle<SharedFunctionInfo> function) {
 void LazyCompileDispatcher::AbortJob(Handle<SharedFunctionInfo> shared_info) {
   if (trace_compiler_dispatcher_) {
     PrintF("LazyCompileDispatcher: aborting job for ");
-    shared_info->ShortPrint();
+    ShortPrint(*shared_info);
     PrintF("\n");
   }
   base::LockGuard<base::Mutex> lock(&mutex_);
diff --git a/src/compiler-dispatcher/optimizing-compile-dispatcher.cc b/src/compiler-dispatcher/optimizing-compile-dispatcher.cc
index 59e2281cffd..9a71d563c19 100644
--- a/src/compiler-dispatcher/optimizing-compile-dispatcher.cc
+++ b/src/compiler-dispatcher/optimizing-compile-dispatcher.cc
@@ -201,7 +201,7 @@ void OptimizingCompileDispatcher::InstallOptimizedFunctions() {
     if (!info->is_osr() && function->HasAvailableCodeKind(info->code_kind())) {
       if (v8_flags.trace_concurrent_recompilation) {
         PrintF("  ** Aborting compilation for ");
-        function->ShortPrint();
+        ShortPrint(*function);
         PrintF(" as it has already been optimized.\n");
       }
       Compiler::DisposeTurbofanCompilationJob(isolate_, job.get(), false);
diff --git a/src/compiler/access-info.cc b/src/compiler/access-info.cc
index b60f824fd22..63287dbd1a4 100644
--- a/src/compiler/access-info.cc
+++ b/src/compiler/access-info.cc
@@ -524,7 +524,8 @@ PropertyAccessInfo AccessorAccessInfoHelper(
             JSModuleNamespace::cast(proto_info->module_namespace()));
     Handle<Cell> cell = broker->CanonicalPersistentHandle(
         Cell::cast(module_namespace->module()->exports()->Lookup(
-            isolate, name.object(), Smi::ToInt(name.object()->GetHash()))));
+            isolate, name.object(),
+            Smi::ToInt(Object::GetHash(*name.object())))));
     if (IsTheHole(cell->value(kRelaxedLoad), isolate)) {
       // This module has not been fully initialized yet.
       return PropertyAccessInfo::Invalid(zone);
diff --git a/src/compiler/heap-refs.cc b/src/compiler/heap-refs.cc
index 773c3c84b1c..e6d23e7b32e 100644
--- a/src/compiler/heap-refs.cc
+++ b/src/compiler/heap-refs.cc
@@ -348,7 +348,7 @@ OptionalObjectRef GetOwnFastDataPropertyFromHeap(JSHeapBroker* broker,
 
     // Ensure that {constant} matches the {representation} we expect for the
     // field.
-    if (!constant->FitsRepresentation(representation, false)) {
+    if (!Object::FitsRepresentation(*constant, representation, false)) {
       const char* repString = IsSmi(*constant)          ? "Smi"
                               : IsHeapNumber(*constant) ? "HeapNumber"
                                                         : "HeapObject";
@@ -759,8 +759,9 @@ base::Optional<bool> HeapObjectData::TryGetBooleanValue(
     JSHeapBroker* broker) const {
   // Keep in sync with Object::BooleanValue.
   auto result = TryGetBooleanValueImpl(broker);
-  DCHECK_IMPLIES(broker->IsMainThread() && result.has_value(),
-                 result.value() == object()->BooleanValue(broker->isolate()));
+  DCHECK_IMPLIES(
+      broker->IsMainThread() && result.has_value(),
+      result.value() == Object::BooleanValue(*object(), broker->isolate()));
   return result;
 }
 
@@ -1844,7 +1845,7 @@ bool ObjectRef::IsNullOrUndefined() const { return IsNull() || IsUndefined(); }
 
 base::Optional<bool> ObjectRef::TryGetBooleanValue(JSHeapBroker* broker) const {
   if (data_->should_access_heap()) {
-    return object()->BooleanValue(broker->isolate());
+    return Object::BooleanValue(*object(), broker->isolate());
   }
   if (IsSmi()) return AsSmi() != 0;
   return data()->AsHeapObject()->TryGetBooleanValue(broker);
@@ -1914,7 +1915,7 @@ base::Optional<Object> JSObjectRef::GetOwnConstantElementFromHeap(
       return {};
     }
     uint32_t array_length;
-    if (!array_length_obj.ToArrayLength(&array_length)) {
+    if (!Object::ToArrayLength(array_length_obj, &array_length)) {
       return {};
     }
     // See also ElementsAccessorBase::GetMaxIndex.
diff --git a/src/compiler/js-heap-broker.cc b/src/compiler/js-heap-broker.cc
index c75d5c4b30e..7f7f5cb8ed8 100644
--- a/src/compiler/js-heap-broker.cc
+++ b/src/compiler/js-heap-broker.cc
@@ -562,7 +562,7 @@ ProcessedFeedback const& JSHeapBroker::ReadFeedbackForGlobalAccess(
   if (IsSmi(*feedback_value)) {
     // The wanted name belongs to a script-scope variable and the feedback
     // tells us where to find its value.
-    int const number = feedback_value->Number();
+    int const number = Object::Number(*feedback_value);
     int const script_context_index =
         FeedbackNexus::ContextIndexBits::decode(number);
     int const context_slot_index = FeedbackNexus::SlotIndexBits::decode(number);
diff --git a/src/debug/debug-evaluate.cc b/src/debug/debug-evaluate.cc
index 57315d7c32a..565a780b9f3 100644
--- a/src/debug/debug-evaluate.cc
+++ b/src/debug/debug-evaluate.cc
@@ -1051,7 +1051,7 @@ DebugInfo::SideEffectState DebugEvaluate::FunctionGetSideEffectState(
     Handle<BytecodeArray> bytecode_array(info->GetBytecodeArray(isolate),
                                          isolate);
     if (v8_flags.trace_side_effect_free_debug_evaluate) {
-      bytecode_array->Print();
+      Print(*bytecode_array);
     }
     bool requires_runtime_checks = false;
     for (interpreter::BytecodeArrayIterator it(bytecode_array); !it.done();
diff --git a/src/debug/debug-interface.cc b/src/debug/debug-interface.cc
index e3bab997106..b433a7dc1d4 100644
--- a/src/debug/debug-interface.cc
+++ b/src/debug/debug-interface.cc
@@ -127,9 +127,9 @@ Local<String> GetDateDescription(Local<Date> date) {
   i::Handle<i::JSDate> jsdate = i::Handle<i::JSDate>::cast(receiver);
   i::Isolate* i_isolate = jsdate->GetIsolate();
   ENTER_V8_NO_SCRIPT_NO_EXCEPTION(i_isolate);
-  auto buffer =
-      i::ToDateString(jsdate->value().Number(), i_isolate->date_cache(),
-                      i::ToDateStringMode::kLocalDateAndTime);
+  auto buffer = i::ToDateString(i::Object::Number(jsdate->value()),
+                                i_isolate->date_cache(),
+                                i::ToDateStringMode::kLocalDateAndTime);
   return Utils::ToLocal(i_isolate->factory()
                             ->NewStringFromUtf8(base::VectorOf(buffer))
                             .ToHandleChecked());
diff --git a/src/debug/debug-scopes.cc b/src/debug/debug-scopes.cc
index a5b0db38d55..de475ebbf55 100644
--- a/src/debug/debug-scopes.cc
+++ b/src/debug/debug-scopes.cc
@@ -705,17 +705,17 @@ void ScopeIterator::DebugPrint() {
   switch (Type()) {
     case ScopeIterator::ScopeTypeGlobal:
       os << "Global:\n";
-      context_->Print(os);
+      Print(*context_, os);
       break;
 
     case ScopeIterator::ScopeTypeLocal: {
       os << "Local:\n";
       if (NeedsContext()) {
-        context_->Print(os);
+        Print(*context_, os);
         if (context_->has_extension()) {
           Handle<HeapObject> extension(context_->extension(), isolate_);
           DCHECK(IsJSContextExtensionObject(*extension));
-          extension->Print(os);
+          Print(*extension, os);
         }
       }
       break;
@@ -723,28 +723,28 @@ void ScopeIterator::DebugPrint() {
 
     case ScopeIterator::ScopeTypeWith:
       os << "With:\n";
-      context_->extension().Print(os);
+      Print(context_->extension(), os);
       break;
 
     case ScopeIterator::ScopeTypeCatch:
       os << "Catch:\n";
-      context_->extension().Print(os);
-      context_->get(Context::THROWN_OBJECT_INDEX).Print(os);
+      Print(context_->extension(), os);
+      Print(context_->get(Context::THROWN_OBJECT_INDEX), os);
       break;
 
     case ScopeIterator::ScopeTypeClosure:
       os << "Closure:\n";
-      context_->Print(os);
+      Print(*context_, os);
       if (context_->has_extension()) {
         Handle<HeapObject> extension(context_->extension(), isolate_);
         DCHECK(IsJSContextExtensionObject(*extension));
-        extension->Print(os);
+        Print(*extension, os);
       }
       break;
 
     case ScopeIterator::ScopeTypeScript:
       os << "Script:\n";
-      context_->native_context()->script_context_table().Print(os);
+      Print(context_->native_context()->script_context_table(), os);
       break;
 
     default:
diff --git a/src/debug/debug.cc b/src/debug/debug.cc
index 83bd8009afc..859d9613c0e 100644
--- a/src/debug/debug.cc
+++ b/src/debug/debug.cc
@@ -845,7 +845,7 @@ bool Debug::CheckBreakPoint(Handle<BreakPoint> break_point,
         exception_thrown, v8::Utils::ToLocal(maybe_exception));
   }
 
-  return !result.is_null() ? result->BooleanValue(isolate_) : false;
+  return !result.is_null() ? Object::BooleanValue(*result, isolate_) : false;
 }
 
 bool Debug::SetBreakpoint(Handle<SharedFunctionInfo> shared,
@@ -3012,7 +3012,7 @@ bool Debug::PerformSideEffectCheckForAccessor(
   }
   if (v8_flags.trace_side_effect_free_debug_evaluate) {
     PrintF("[debug-evaluate] API Callback '");
-    accessor_info->name().ShortPrint();
+    ShortPrint(accessor_info->name());
     PrintF("' may cause side effect.\n");
   }
 
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index ce02219bbca..30dc939777c 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -231,7 +231,7 @@ class FrameWriter {
         PrintF(trace_scope_->file(), V8PRIxPTR_FMT " <Smi %d>", obj.ptr(),
                Smi::cast(obj).value());
       } else {
-        obj.ShortPrint(trace_scope_->file());
+        ShortPrint(obj, trace_scope_->file());
       }
       PrintF(trace_scope_->file(), " ;  %s", debug_hint);
     }
@@ -636,10 +636,10 @@ void Deoptimizer::TraceDeoptBegin(int optimization_id,
   PrintF(file, "[bailout (kind: %s, reason: %s): begin. deoptimizing ",
          MessageFor(deopt_kind_), DeoptimizeReasonToString(info.deopt_reason));
   if (IsJSFunction(function_)) {
-    function_.ShortPrint(file);
+    ShortPrint(function_, file);
     PrintF(file, ", ");
   }
-  compiled_code_.ShortPrint(file);
+  ShortPrint(compiled_code_, file);
   PrintF(file,
          ", opt id %d, "
 #ifdef DEBUG
@@ -681,9 +681,9 @@ void Deoptimizer::TraceMarkForDeoptimization(Isolate* isolate, Code code,
   CodeTracer::Scope scope(isolate->GetCodeTracer());
   if (v8_flags.trace_deopt) {
     PrintF(scope.file(), "[marking dependent code ");
-    code.ShortPrint(scope.file());
+    ShortPrint(code, scope.file());
     PrintF(scope.file(), " (");
-    deopt_data->SharedFunctionInfo().ShortPrint(scope.file());
+    ShortPrint(deopt_data->SharedFunctionInfo(), scope.file());
     PrintF(") (opt id %d) for deoptimization, reason: %s]\n",
            deopt_data->OptimizationId().value(), reason);
   }
@@ -712,7 +712,7 @@ void Deoptimizer::TraceEvictFromOptimizedCodeCache(Isolate* isolate,
   PrintF(scope.file(),
          "[evicting optimized code marked for deoptimization (%s) for ",
          reason);
-  sfi.ShortPrint(scope.file());
+  ShortPrint(sfi, scope.file());
   PrintF(scope.file(), "]\n");
 }
 
@@ -2087,7 +2087,7 @@ void Deoptimizer::MaterializeHeapObjects() {
              "Materialization [" V8PRIxPTR_FMT "] <- " V8PRIxPTR_FMT " ;  ",
              static_cast<intptr_t>(materialization.output_slot_address_),
              value->ptr());
-      value->ShortPrint(trace_scope()->file());
+      ShortPrint(*value, trace_scope()->file());
       PrintF(trace_scope()->file(), "\n");
     }
 
diff --git a/src/deoptimizer/translated-state.cc b/src/deoptimizer/translated-state.cc
index e3d97fcf08d..d8772191bc4 100644
--- a/src/deoptimizer/translated-state.cc
+++ b/src/deoptimizer/translated-state.cc
@@ -506,7 +506,7 @@ Object TranslatedValue::GetRawValue() const {
   if (materialization_state() == kFinished) {
     int smi;
     if (IsHeapNumber(*storage_) &&
-        DoubleToSmiInteger(storage_->Number(), &smi)) {
+        DoubleToSmiInteger(Object::Number(*storage_), &smi)) {
       return Smi::FromInt(smi);
     }
     return *storage_;
@@ -653,7 +653,7 @@ Handle<Object> TranslatedValue::GetValue() {
     // just always allocate a HeapNumber and later extract the Smi again if we
     // don't need a HeapObject.
     set_initialized_storage(
-        isolate()->factory()->NewHeapNumber(value->Number()));
+        isolate()->factory()->NewHeapNumber(Object::Number(*value)));
     return value;
   }
 
@@ -1263,7 +1263,7 @@ int TranslatedState::CreateNextTranslatedValue(
       if (trace_file != nullptr) {
         PrintF(trace_file, V8PRIxPTR_FMT " ; %s ", uncompressed_value,
                converter.NameOfCPURegister(input_reg));
-        Object(uncompressed_value).ShortPrint(trace_file);
+        ShortPrint(Object(uncompressed_value), trace_file);
       }
       TranslatedValue translated_value =
           TranslatedValue::NewTagged(this, Object(uncompressed_value));
@@ -1446,7 +1446,7 @@ int TranslatedState::CreateNextTranslatedValue(
         PrintF(trace_file, V8PRIxPTR_FMT " ;  [fp %c %3d]  ",
                uncompressed_value, slot_offset < 0 ? '-' : '+',
                std::abs(slot_offset));
-        Object(uncompressed_value).ShortPrint(trace_file);
+        ShortPrint(Object(uncompressed_value), trace_file);
       }
       TranslatedValue translated_value =
           TranslatedValue::NewTagged(this, Object(uncompressed_value));
@@ -1591,7 +1591,7 @@ int TranslatedState::CreateNextTranslatedValue(
       if (trace_file != nullptr) {
         PrintF(trace_file, V8PRIxPTR_FMT " ; (literal %2d) ", value.ptr(),
                literal_index);
-        value.ShortPrint(trace_file);
+        ShortPrint(value, trace_file);
       }
 
       TranslatedValue translated_value =
@@ -1874,7 +1874,7 @@ void TranslatedState::MaterializeFixedDoubleArray(TranslatedFrame* frame,
              frame->values_[*value_index].kind());
     Handle<Object> value = frame->values_[*value_index].GetValue();
     if (IsNumber(*value)) {
-      array->set(i, value->Number());
+      array->set(i, Object::Number(*value));
     } else {
       CHECK(value.is_identical_to(isolate()->factory()->the_hole_value()));
       array->set_the_hole(isolate(), i);
@@ -1891,7 +1891,8 @@ void TranslatedState::MaterializeHeapNumber(TranslatedFrame* frame,
            frame->values_[*value_index].kind());
   Handle<Object> value = frame->values_[*value_index].GetValue();
   CHECK(IsNumber(*value));
-  Handle<HeapNumber> box = isolate()->factory()->NewHeapNumber(value->Number());
+  Handle<HeapNumber> box =
+      isolate()->factory()->NewHeapNumber(Object::Number(*value));
   (*value_index)++;
   slot->set_storage(box);
 }
@@ -2242,7 +2243,7 @@ void TranslatedState::InitializeJSObjectAt(
       CHECK_EQ(kStoreTagged, marker);
       Handle<Object> field_value = slot->GetValue();
       DCHECK_IMPLIES(IsHeapNumber(*field_value),
-                     !IsSmiDouble(field_value->Number()));
+                     !IsSmiDouble(Object::Number(*field_value)));
       WRITE_FIELD(*object_storage, offset, *field_value);
       WRITE_BARRIER(*object_storage, offset, *field_value);
     }
@@ -2293,7 +2294,7 @@ void TranslatedState::InitializeObjectWithTaggedFieldsAt(
       CHECK(marker == kStoreTagged || i == 1);
       field_value = slot->GetValue();
       DCHECK_IMPLIES(IsHeapNumber(*field_value),
-                     !IsSmiDouble(field_value->Number()));
+                     !IsSmiDouble(Object::Number(*field_value)));
     }
     WRITE_FIELD(*object_storage, offset, *field_value);
     WRITE_BARRIER(*object_storage, offset, *field_value);
@@ -2415,14 +2416,14 @@ void TranslatedState::StoreMaterializedValuesAndDeopt(JavaScriptFrame* frame) {
     } else {
       if (*previous_value == *marker) {
         if (IsSmi(*value)) {
-          value = isolate()->factory()->NewHeapNumber(value->Number());
+          value = isolate()->factory()->NewHeapNumber(Object::Number(*value));
         }
         previously_materialized_objects->set(i, *value);
         value_changed = true;
       } else {
         CHECK(*previous_value == *value ||
               (IsHeapNumber(*previous_value) && IsSmi(*value) &&
-               previous_value->Number() == value->Number()));
+               Object::Number(*previous_value) == Object::Number(*value)));
       }
     }
   }
@@ -2478,7 +2479,7 @@ void TranslatedState::VerifyMaterializedObjects() {
     if (slot->kind() == TranslatedValue::kCapturedObject) {
       CHECK_EQ(slot, GetValueByObjectIndex(slot->object_index()));
       if (slot->materialization_state() == TranslatedValue::kFinished) {
-        slot->storage()->ObjectVerify(isolate());
+        Object::ObjectVerify(*slot->storage(), isolate());
       } else {
         CHECK_EQ(slot->materialization_state(),
                  TranslatedValue::kUninitialized);
diff --git a/src/diagnostics/disassembler.cc b/src/diagnostics/disassembler.cc
index 948f791a028..fcd1c4ee6f8 100644
--- a/src/diagnostics/disassembler.cc
+++ b/src/diagnostics/disassembler.cc
@@ -243,7 +243,7 @@ static void PrintRelocInfo(std::ostringstream& out, Isolate* isolate,
   } else if (RelocInfo::IsEmbeddedObjectMode(rmode)) {
     HeapStringAllocator allocator;
     StringStream accumulator(&allocator);
-    relocinfo->target_object(isolate).ShortPrint(&accumulator);
+    ShortPrint(relocinfo->target_object(isolate), &accumulator);
     std::unique_ptr<char[]> obj_name = accumulator.ToCString();
     const bool is_compressed = RelocInfo::IsCompressedEmbeddedObject(rmode);
     out << "    ;; " << (is_compressed ? "(compressed) " : "")
diff --git a/src/diagnostics/gdb-jit.cc b/src/diagnostics/gdb-jit.cc
index 1fa98b47d08..efeb95f81a8 100644
--- a/src/diagnostics/gdb-jit.cc
+++ b/src/diagnostics/gdb-jit.cc
@@ -1749,7 +1749,7 @@ JITDescriptor __jit_debug_descriptor = {1, 0, nullptr, nullptr};
 #ifdef OBJECT_PRINT
 void __gdb_print_v8_object(Object object) {
   StdoutStream os;
-  object.Print(os);
+  Print(object, os);
   os << std::flush;
 }
 #endif
diff --git a/src/diagnostics/objects-debug.cc b/src/diagnostics/objects-debug.cc
index c0611b28d34..becc4c0d102 100644
--- a/src/diagnostics/objects-debug.cc
+++ b/src/diagnostics/objects-debug.cc
@@ -129,15 +129,16 @@ namespace internal {
     TorqueGeneratedClassVerifiers::Class##Verify(*this, isolate); \
   }
 
-void Object::ObjectVerify(Isolate* isolate) {
+// static
+void Object::ObjectVerify(Tagged<Object> obj, Isolate* isolate) {
   RCS_SCOPE(isolate, RuntimeCallCounterId::kObjectVerify);
-  if (IsSmi(*this)) {
-    Smi::cast(*this).SmiVerify(isolate);
+  if (IsSmi(obj)) {
+    Smi::SmiVerify(Smi::cast(obj), isolate);
   } else {
-    HeapObject::cast(*this)->HeapObjectVerify(isolate);
+    HeapObject::cast(obj)->HeapObjectVerify(isolate);
   }
   PtrComprCageBase cage_base(isolate);
-  CHECK(!IsConstructor(*this, cage_base) || IsCallable(*this, cage_base));
+  CHECK(!IsConstructor(obj, cage_base) || IsCallable(obj, cage_base));
 }
 
 void Object::VerifyPointer(Isolate* isolate, Object p) {
@@ -169,14 +170,16 @@ void MaybeObject::VerifyMaybeObjectPointer(Isolate* isolate, MaybeObject p) {
   }
 }
 
-void Smi::SmiVerify(Isolate* isolate) {
-  CHECK(IsSmi(*this));
-  CHECK(!IsCallable(*this));
-  CHECK(!IsConstructor(*this));
+// static
+void Smi::SmiVerify(Tagged<Smi> obj, Isolate* isolate) {
+  CHECK(IsSmi(obj));
+  CHECK(!IsCallable(obj));
+  CHECK(!IsConstructor(obj));
 }
 
-void TaggedIndex::TaggedIndexVerify(Isolate* isolate) {
-  CHECK(IsTaggedIndex(*this));
+// static
+void TaggedIndex::TaggedIndexVerify(Tagged<TaggedIndex> obj, Isolate* isolate) {
+  CHECK(IsTaggedIndex(obj));
 }
 
 void HeapObject::HeapObjectVerify(Isolate* isolate) {
@@ -574,14 +577,14 @@ void Map::MapVerify(Isolate* isolate) {
           CHECK(has_shared_array_elements());
         }
       } else {
-        CHECK(InSharedHeap());
+        CHECK(Object::InSharedHeap(*this));
         CHECK(IsUndefined(GetBackPointer(), isolate));
         Object maybe_cell = prototype_validity_cell(kRelaxedLoad);
-        if (IsCell(maybe_cell)) CHECK(maybe_cell.InSharedHeap());
+        if (IsCell(maybe_cell)) CHECK(Object::InSharedHeap(maybe_cell));
         CHECK(!is_extensible());
         CHECK(!is_prototype_map());
         CHECK(OnlyHasSimpleProperties());
-        CHECK(instance_descriptors(isolate).InSharedHeap());
+        CHECK(Object::InSharedHeap(instance_descriptors(isolate)));
         if (IsJSSharedArrayMap(*this)) {
           CHECK(has_shared_array_elements());
         }
@@ -1219,7 +1222,7 @@ void InstructionStream::InstructionStreamVerify(Isolate* isolate) {
         isolate->heap()->InSpace(*this, CODE_LO_SPACE));
   Address last_gc_pc = kNullAddress;
 
-  relocation_info().ObjectVerify(isolate);
+  Object::ObjectVerify(relocation_info(), isolate);
 
   for (RelocIterator it(code); !it.done(); it.next()) {
     it.rinfo()->Verify(isolate);
@@ -1256,9 +1259,9 @@ void JSArray::JSArrayVerify(Isolate* isolate) {
   } else {
     CHECK(HasDictionaryElements());
     uint32_t array_length;
-    CHECK(length().ToArrayLength(&array_length));
+    CHECK(Object::ToArrayLength(length(), &array_length));
     if (array_length == 0xFFFFFFFF) {
-      CHECK(length().ToArrayLength(&array_length));
+      CHECK(Object::ToArrayLength(length(), &array_length));
     }
     if (array_length != 0) {
       NumberDictionary dict = NumberDictionary::cast(elements());
@@ -1312,7 +1315,7 @@ void VerifyElementIsShared(Object element) {
   // string was in shared space.
   if (IsThinString(element)) {
     CHECK(v8_flags.shared_string_table);
-    CHECK(element.InWritableSharedSpace());
+    CHECK(Object::InWritableSharedSpace(element));
   } else {
     CHECK(IsShared(element));
   }
@@ -1328,7 +1331,7 @@ void JSSharedStruct::JSSharedStructVerify(Isolate* isolate) {
   // Shared structs can only point to primitives or other shared HeapObjects,
   // even internally.
   Map struct_map = map();
-  CHECK(property_array().InSharedHeap());
+  CHECK(Object::InSharedHeap(property_array()));
   DescriptorArray descriptors = struct_map->instance_descriptors(isolate);
   for (InternalIndex i : struct_map->IterateOwnDescriptors()) {
     PropertyDetails details = descriptors->GetDetails(i);
@@ -1348,7 +1351,7 @@ void JSAtomicsMutex::JSAtomicsMutexVerify(Isolate* isolate) {
 
 void JSAtomicsCondition::JSAtomicsConditionVerify(Isolate* isolate) {
   CHECK(IsJSAtomicsCondition(*this));
-  CHECK(InSharedHeap());
+  CHECK(Object::InSharedHeap(*this));
   JSObjectVerify(isolate);
 }
 
@@ -1369,35 +1372,35 @@ void JSSharedArray::JSSharedArrayVerify(Isolate* isolate) {
 void JSIteratorMapHelper::JSIteratorMapHelperVerify(Isolate* isolate) {
   TorqueGeneratedClassVerifiers::JSIteratorMapHelperVerify(*this, isolate);
   CHECK(IsCallable(mapper()));
-  CHECK_GE(counter().Number(), 0);
+  CHECK_GE(Object::Number(counter()), 0);
 }
 
 void JSIteratorFilterHelper::JSIteratorFilterHelperVerify(Isolate* isolate) {
   TorqueGeneratedClassVerifiers::JSIteratorFilterHelperVerify(*this, isolate);
   CHECK(IsCallable(predicate()));
-  CHECK_GE(counter().Number(), 0);
+  CHECK_GE(Object::Number(counter()), 0);
 }
 
 void JSIteratorTakeHelper::JSIteratorTakeHelperVerify(Isolate* isolate) {
   TorqueGeneratedClassVerifiers::JSIteratorTakeHelperVerify(*this, isolate);
-  CHECK_GE(remaining().Number(), 0);
+  CHECK_GE(Object::Number(remaining()), 0);
 }
 
 void JSIteratorDropHelper::JSIteratorDropHelperVerify(Isolate* isolate) {
   TorqueGeneratedClassVerifiers::JSIteratorDropHelperVerify(*this, isolate);
-  CHECK_GE(remaining().Number(), 0);
+  CHECK_GE(Object::Number(remaining()), 0);
 }
 
 void JSIteratorFlatMapHelper::JSIteratorFlatMapHelperVerify(Isolate* isolate) {
   TorqueGeneratedClassVerifiers::JSIteratorFlatMapHelperVerify(*this, isolate);
   CHECK(IsCallable(mapper()));
-  CHECK_GE(counter().Number(), 0);
+  CHECK_GE(Object::Number(counter()), 0);
 }
 
 void WeakCell::WeakCellVerify(Isolate* isolate) {
   CHECK(IsWeakCell(*this));
 
-  CHECK(IsUndefined(target(), isolate) || target().CanBeHeldWeakly());
+  CHECK(IsUndefined(target(), isolate) || Object::CanBeHeldWeakly(target()));
 
   CHECK(IsWeakCell(prev()) || IsUndefined(prev(), isolate));
   if (IsWeakCell(prev())) {
@@ -1425,7 +1428,7 @@ void WeakCell::WeakCellVerify(Isolate* isolate) {
 void JSWeakRef::JSWeakRefVerify(Isolate* isolate) {
   CHECK(IsJSWeakRef(*this));
   JSObjectVerify(isolate);
-  CHECK(IsUndefined(target(), isolate) || target().CanBeHeldWeakly());
+  CHECK(IsUndefined(target(), isolate) || Object::CanBeHeldWeakly(target()));
 }
 
 void JSFinalizationRegistry::JSFinalizationRegistryVerify(Isolate* isolate) {
@@ -1446,16 +1449,16 @@ void JSWeakMap::JSWeakMapVerify(Isolate* isolate) {
 void JSArrayIterator::JSArrayIteratorVerify(Isolate* isolate) {
   TorqueGeneratedClassVerifiers::JSArrayIteratorVerify(*this, isolate);
 
-  CHECK_GE(next_index().Number(), 0);
-  CHECK_LE(next_index().Number(), kMaxSafeInteger);
+  CHECK_GE(Object::Number(next_index()), 0);
+  CHECK_LE(Object::Number(next_index()), kMaxSafeInteger);
 
   if (IsJSTypedArray(iterated_object())) {
     // JSTypedArray::length is limited to Smi range.
     CHECK(IsSmi(next_index()));
-    CHECK_LE(next_index().Number(), Smi::kMaxValue);
+    CHECK_LE(Object::Number(next_index()), Smi::kMaxValue);
   } else if (IsJSArray(iterated_object())) {
     // JSArray::length is limited to Uint32 range.
-    CHECK_LE(next_index().Number(), kMaxUInt32);
+    CHECK_LE(Object::Number(next_index()), kMaxUInt32);
   }
 }
 
@@ -1595,7 +1598,7 @@ void SwissNameDictionary::SwissNameDictionaryVerify(Isolate* isolate,
         CHECK(!IsTheHole(key));
         CHECK(!IsTheHole(value));
         name->NameVerify(isolate);
-        value.ObjectVerify(isolate);
+        Object::ObjectVerify(value, isolate);
       } else if (IsDeleted(ctrl)) {
         ++seen_deleted;
         CHECK(IsTheHole(key));
@@ -2257,12 +2260,12 @@ bool DescriptorArray::IsSortedNoDuplicates() {
     const bool has_hash = key->TryGetHash(&hash);
     CHECK(has_hash);
     if (key == current_key) {
-      Print();
+      Print(*this);
       return false;
     }
     current_key = key;
     if (hash < current) {
-      Print();
+      Print(*this);
       return false;
     }
     current = hash;
@@ -2298,7 +2301,7 @@ bool TransitionArray::IsSortedNoDuplicates() {
     int cmp = CompareKeys(prev_key, prev_hash, prev_kind, prev_attributes, key,
                           hash, kind, attributes);
     if (cmp >= 0) {
-      Print();
+      Print(*this);
       return false;
     }
     prev_key = key;
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index f650d403d5b..ab76b5a1a62 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -33,23 +33,23 @@ namespace internal {
 
 #ifdef OBJECT_PRINT
 
-void Object::Print() const {
+void Print(Object obj) {
   // Output into debugger's command window if a debugger is attached.
   DbgStdoutStream dbg_os;
-  this->Print(dbg_os);
+  Print(obj, dbg_os);
   dbg_os << std::flush;
 
   StdoutStream os;
-  this->Print(os);
+  Print(obj, os);
   os << std::flush;
 }
 
-void Object::Print(std::ostream& os) const {
-  if (IsSmi(*this)) {
-    os << "Smi: " << std::hex << "0x" << Smi::ToInt(*this);
-    os << std::dec << " (" << Smi::ToInt(*this) << ")\n";
+void Print(Object obj, std::ostream& os) {
+  if (IsSmi(obj)) {
+    os << "Smi: " << std::hex << "0x" << Smi::ToInt(obj);
+    os << std::dec << " (" << Smi::ToInt(obj) << ")\n";
   } else {
-    HeapObject::cast(*this)->HeapObjectPrint(os);
+    HeapObject::cast(obj)->HeapObjectPrint(os);
   }
 }
 
@@ -586,7 +586,7 @@ static void JSObjectPrintHeader(std::ostream& os, JSObject obj,
      << ElementsKindToString(obj->map()->elements_kind());
   if (obj->elements()->IsCowArray()) os << " (COW)";
   os << "]";
-  Object hash = obj.GetHash();
+  Object hash = Object::GetHash(obj);
   if (IsSmi(hash)) {
     os << "\n - hash: " << Brief(hash);
   }
@@ -2712,7 +2712,7 @@ void ScopeInfo::ScopeInfoPrint(std::ostream& os) {
   if (HasNewTarget()) os << "\n - needs new target";
   if (HasFunctionName()) {
     os << "\n - function name(" << FunctionVariableBits::decode(flags) << "): ";
-    FunctionName().ShortPrint(os);
+    ShortPrint(FunctionName(), os);
   }
   if (IsAsmModule()) os << "\n - asm module";
   if (HasSimpleParameters()) os << "\n - simple parameters";
@@ -2924,7 +2924,7 @@ void DescriptorArray::PrintDescriptors(std::ostream& os) {
 #ifdef OBJECT_PRINT
     key->NamePrint(os);
 #else
-    key.ShortPrint(os);
+    ShortPrint(key, os);
 #endif
     os << " ";
     PrintDescriptorDetails(os, i, PropertyDetails::kPrintFull);
@@ -2978,7 +2978,7 @@ void TransitionsAccessor::PrintOneTransition(std::ostream& os, Name key,
 #ifdef OBJECT_PRINT
   key->NamePrint(os);
 #else
-  key.ShortPrint(os);
+  ShortPrint(key, os);
 #endif
   os << ": ";
   ReadOnlyRoots roots = key->GetReadOnlyRoots();
@@ -3069,7 +3069,7 @@ void TransitionsAccessor::PrintTransitionTree(
 #ifdef OBJECT_PRINT
       key->NamePrint(os);
 #else
-      key.ShortPrint(os);
+      ShortPrint(key, os);
 #endif
       os << " ";
       DCHECK(!IsSpecialTransition(ReadOnlyRoots(isolate_), key));
@@ -3122,7 +3122,7 @@ V8_EXPORT_PRIVATE extern i::Object _v8_internal_Get_Object(void* object) {
 
 V8_DONT_STRIP_SYMBOL
 V8_EXPORT_PRIVATE extern void _v8_internal_Print_Object(void* object) {
-  GetObjectFromRaw(object).Print();
+  i::Print(GetObjectFromRaw(object));
 }
 
 V8_DONT_STRIP_SYMBOL
@@ -3175,7 +3175,7 @@ V8_EXPORT_PRIVATE extern void _v8_internal_Print_Code(void* object) {
   i::StdoutStream os;
   lookup_result->Disassemble(nullptr, os, isolate, address);
 #else
-  lookup_result->Print();
+  i::Print(*lookup_result);
 #endif
 }
 
diff --git a/src/execution/arguments-inl.h b/src/execution/arguments-inl.h
index b8152c0c6e0..b06da4caf9e 100644
--- a/src/execution/arguments-inl.h
+++ b/src/execution/arguments-inl.h
@@ -45,7 +45,7 @@ int Arguments<T>::tagged_index_value_at(int index) const {
 
 template <ArgumentsType T>
 double Arguments<T>::number_value_at(int index) const {
-  return (*this)[index].Number();
+  return Object::Number((*this)[index]);
 }
 
 template <ArgumentsType T>
diff --git a/src/execution/arm/simulator-arm.cc b/src/execution/arm/simulator-arm.cc
index fe8af1b1ac5..9785fbed8e5 100644
--- a/src/execution/arm/simulator-arm.cc
+++ b/src/execution/arm/simulator-arm.cc
@@ -312,7 +312,7 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
         Object obj(value);
         os << arg1 << ": \n";
 #ifdef DEBUG
-        obj.Print(os);
+        Print(obj, os);
         os << "\n";
 #else
         os << Brief(obj) << "\n";
@@ -364,7 +364,7 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
           if (IsSmi(obj)) {
             PrintF("smi %d", Smi::ToInt(obj));
           } else {
-            obj.ShortPrint();
+            ShortPrint(obj);
           }
           PrintF(")");
         }
diff --git a/src/execution/arm64/simulator-arm64.cc b/src/execution/arm64/simulator-arm64.cc
index 146183e5d39..a88db6d71e3 100644
--- a/src/execution/arm64/simulator-arm64.cc
+++ b/src/execution/arm64/simulator-arm64.cc
@@ -3948,7 +3948,7 @@ bool Simulator::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
         Object obj(value);
         os << arg1 << ": \n";
 #ifdef DEBUG
-        obj.Print(os);
+        Print(obj, os);
         os << "\n";
 #else
         os << Brief(obj) << "\n";
@@ -4011,7 +4011,7 @@ bool Simulator::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
           if (IsSmi(obj)) {
             PrintF("smi %" PRId32, Smi::ToInt(obj));
           } else {
-            obj.ShortPrint();
+            ShortPrint(obj);
           }
           PrintF(")");
         }
diff --git a/src/execution/execution.cc b/src/execution/execution.cc
index 16983011bf4..b4ee4093ce3 100644
--- a/src/execution/execution.cc
+++ b/src/execution/execution.cc
@@ -447,7 +447,7 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> Invoke(Isolate* isolate,
 
 #ifdef VERIFY_HEAP
   if (v8_flags.verify_heap) {
-    value.ObjectVerify(isolate);
+    Object::ObjectVerify(value, isolate);
   }
 #endif
 
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 9e8d1f57734..efd8808ab2a 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -2015,11 +2015,11 @@ void JavaScriptFrame::PrintTop(Isolate* isolate, FILE* file, bool print_args,
         // (we are intentionally only printing the actually
         // supplied parameters, not all parameters required)
         PrintF(file, "(this=");
-        frame->receiver().ShortPrint(file);
+        ShortPrint(frame->receiver(), file);
         const int length = frame->ComputeParametersCount();
         for (int i = 0; i < length; i++) {
           PrintF(file, ", ");
-          frame->GetParameter(i).ShortPrint(file);
+          ShortPrint(frame->GetParameter(i), file);
         }
         PrintF(file, ")");
       }
diff --git a/src/execution/isolate.cc b/src/execution/isolate.cc
index 0e067910541..d5455a1e505 100644
--- a/src/execution/isolate.cc
+++ b/src/execution/isolate.cc
@@ -943,7 +943,7 @@ bool GetStackTraceLimit(Isolate* isolate, int* result) {
   if (!IsNumber(*stack_trace_limit)) return false;
 
   // Ensure that limit is not negative.
-  *result = std::max(FastD2IChecked(stack_trace_limit->Number()), 0);
+  *result = std::max(FastD2IChecked(Object::Number(*stack_trace_limit)), 0);
 
   if (*result != v8_flags.stack_trace_limit) {
     isolate->CountUsage(v8::Isolate::kErrorStackTraceLimit);
@@ -1830,7 +1830,7 @@ Object Isolate::ThrowInternal(Object raw_exception, MessageLocation* location) {
         PrintF(", line %d\n", script->GetLineNumber(location->start_pos()) + 1);
       }
     }
-    raw_exception.Print();
+    Print(raw_exception);
     PrintF("Stack Trace:\n");
     PrintStack(stdout);
     PrintF("=========================================================\n");
diff --git a/src/execution/loong64/simulator-loong64.cc b/src/execution/loong64/simulator-loong64.cc
index 781ed126069..868bcda15fd 100644
--- a/src/execution/loong64/simulator-loong64.cc
+++ b/src/execution/loong64/simulator-loong64.cc
@@ -464,7 +464,7 @@ void Loong64Debugger::Debug() {
               if (IsSmi(obj)) {
                 PrintF("smi %d", Smi::ToInt(obj));
               } else {
-                obj.ShortPrint();
+                ShortPrint(obj);
               }
               PrintF(")");
             }
diff --git a/src/execution/mips64/simulator-mips64.cc b/src/execution/mips64/simulator-mips64.cc
index b89a24ca468..b9b63002895 100644
--- a/src/execution/mips64/simulator-mips64.cc
+++ b/src/execution/mips64/simulator-mips64.cc
@@ -451,7 +451,7 @@ void MipsDebugger::Debug() {
               if (IsSmi(obj)) {
                 PrintF("smi %d", Smi::ToInt(obj));
               } else {
-                obj.ShortPrint();
+                ShortPrint(obj);
               }
               PrintF(")");
             }
diff --git a/src/execution/ppc/simulator-ppc.cc b/src/execution/ppc/simulator-ppc.cc
index a62c31110ae..f292083b078 100644
--- a/src/execution/ppc/simulator-ppc.cc
+++ b/src/execution/ppc/simulator-ppc.cc
@@ -401,7 +401,7 @@ void PPCDebugger::Debug() {
               if (IsSmi(obj)) {
                 PrintF("smi %d", Smi::ToInt(obj));
               } else {
-                obj.ShortPrint();
+                ShortPrint(obj);
               }
               PrintF(")");
             }
diff --git a/src/execution/riscv/simulator-riscv.cc b/src/execution/riscv/simulator-riscv.cc
index 0eb9cbaf98e..4e9123a6ae7 100644
--- a/src/execution/riscv/simulator-riscv.cc
+++ b/src/execution/riscv/simulator-riscv.cc
@@ -1946,7 +1946,7 @@ void RiscvDebugger::Debug() {
             if (IsSmi(obj)) {
               PrintF("smi %d", Smi::ToInt(obj));
             } else {
-              obj.ShortPrint();
+              ShortPrint(obj);
             }
             PrintF(")");
           }
@@ -7699,7 +7699,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     //   if (obj.IsSmi()) {
     //     PrintF("smi %d", Smi::ToInt(obj));
     //   } else {
-    //     obj.ShortPrint();
+    //     ShortPrint(obj);
     //   }
     //   PrintF(")");
     // }
diff --git a/src/execution/s390/simulator-s390.cc b/src/execution/s390/simulator-s390.cc
index c2a6885634e..48f497d0a08 100644
--- a/src/execution/s390/simulator-s390.cc
+++ b/src/execution/s390/simulator-s390.cc
@@ -431,7 +431,7 @@ void S390Debugger::Debug() {
               PrintF(" (smi %d)", Smi::ToInt(obj));
             } else if (IsValidHeapObject(current_heap, HeapObject::cast(obj))) {
               PrintF(" (");
-              obj.ShortPrint();
+              ShortPrint(obj);
               PrintF(")");
             }
             PrintF("\n");
diff --git a/src/execution/tiering-manager.cc b/src/execution/tiering-manager.cc
index 90b14a2c4b9..043dd51aa55 100644
--- a/src/execution/tiering-manager.cc
+++ b/src/execution/tiering-manager.cc
@@ -114,7 +114,7 @@ void TraceRecompile(Isolate* isolate, JSFunction function,
   if (v8_flags.trace_opt) {
     CodeTracer::Scope scope(isolate->GetCodeTracer());
     PrintF(scope.file(), "[marking ");
-    function.ShortPrint(scope.file());
+    ShortPrint(function, scope.file());
     PrintF(scope.file(), " for optimization to %s, %s, reason: %s",
            CodeKindToString(d.code_kind), ToString(d.concurrency_mode),
            OptimizationReasonToString(d.optimization_reason));
@@ -128,7 +128,7 @@ void TraceManualRecompile(JSFunction function, CodeKind code_kind,
                           ConcurrencyMode concurrency_mode) {
   if (v8_flags.trace_opt) {
     PrintF("[manually marking ");
-    function.ShortPrint();
+    ShortPrint(function);
     PrintF(" for optimization to %s, %s]\n", CodeKindToString(code_kind),
            ToString(concurrency_mode));
   }
diff --git a/src/handles/global-handles.cc b/src/handles/global-handles.cc
index 33df55c6c12..eeb32cfcd5c 100644
--- a/src/handles/global-handles.cc
+++ b/src/handles/global-handles.cc
@@ -639,7 +639,7 @@ Handle<Object> GlobalHandles::CopyGlobal(Address* location) {
       Node::FromLocation(location)->global_handles();
 #ifdef VERIFY_HEAP
   if (v8_flags.verify_heap) {
-    Object(*location).ObjectVerify(global_handles->isolate());
+    Object::ObjectVerify(Object(*location), global_handles->isolate());
   }
 #endif  // VERIFY_HEAP
   return global_handles->Create(*location);
diff --git a/src/handles/traced-handles.cc b/src/handles/traced-handles.cc
index a0e8de8075d..98393a8c199 100644
--- a/src/handles/traced-handles.cc
+++ b/src/handles/traced-handles.cc
@@ -717,7 +717,7 @@ void TracedHandlesImpl::Copy(const TracedNode& from_node, Address** to) {
   SetSlotThreadSafe(to, o.location());
 #ifdef VERIFY_HEAP
   if (v8_flags.verify_heap) {
-    Object(**to).ObjectVerify(isolate_);
+    Object::ObjectVerify(Object(**to), isolate_);
   }
 #endif  // VERIFY_HEAP
 }
diff --git a/src/heap/factory-inl.h b/src/heap/factory-inl.h
index 7ab747aa80b..afb11a56083 100644
--- a/src/heap/factory-inl.h
+++ b/src/heap/factory-inl.h
@@ -131,7 +131,7 @@ Handle<Object> Factory::NumberToStringCacheGet(Tagged<Object> number,
   Tagged<FixedArray> cache = *number_string_cache();
   Tagged<Object> key = cache->get(hash * 2);
   if (key == number || (IsHeapNumber(key) && IsHeapNumber(number) &&
-                        key->Number() == number->Number())) {
+                        Object::Number(*key) == Object::Number(*number))) {
     return Handle<String>(String::cast(cache->get(hash * 2 + 1)), isolate());
   }
   return undefined_value();
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index 6cbbd6eaee6..1f83472f15b 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -406,7 +406,7 @@ Handle<EnumCache> Factory::NewEnumCache(Handle<FixedArray> keys,
   DCHECK(allocation == AllocationType::kOld ||
          allocation == AllocationType::kSharedOld);
   DCHECK_EQ(allocation == AllocationType::kSharedOld,
-            keys->InSharedHeap() && indices->InSharedHeap());
+            Object::InSharedHeap(*keys) && Object::InSharedHeap(*indices));
   auto result = NewStructInternal<EnumCache>(ENUM_CACHE_TYPE, allocation);
   DisallowGarbageCollection no_gc;
   result->set_keys(*keys);
@@ -1003,7 +1003,7 @@ StringTransitionStrategy Factory::ComputeInternalizationStrategyForString(
   }
   // If the string table is shared, we need to copy if the string is not already
   // in the shared heap.
-  if (v8_flags.shared_string_table && !string->InSharedHeap()) {
+  if (v8_flags.shared_string_table && !Object::InSharedHeap(*string)) {
     return StringTransitionStrategy::kCopy;
   }
   DCHECK_NOT_NULL(internalized_map);
@@ -1047,7 +1047,7 @@ StringTransitionStrategy Factory::ComputeSharingStrategyForString(
     Handle<String> string, MaybeHandle<Map>* shared_map) {
   DCHECK(v8_flags.shared_string_table);
   // TODO(pthier): Avoid copying LO-space strings. Update page flags instead.
-  if (!string->InSharedHeap()) {
+  if (!Object::InSharedHeap(*string)) {
     return StringTransitionStrategy::kCopy;
   }
   DCHECK_NOT_NULL(shared_map);
diff --git a/src/heap/heap-verifier.cc b/src/heap/heap-verifier.cc
index 9b8b97c2d4e..7165d94053a 100644
--- a/src/heap/heap-verifier.cc
+++ b/src/heap/heap-verifier.cc
@@ -371,7 +371,7 @@ void HeapVerification::VerifyObject(HeapObject object) {
   VerifyObjectMap(object);
 
   // The object itself should look OK.
-  object.ObjectVerify(isolate_);
+  Object::ObjectVerify(object, isolate_);
 
   // Verify outgoing references.
   VerifyOutgoingPointers(object);
diff --git a/src/heap/heap.cc b/src/heap/heap.cc
index a76e51da92d..84bdd405790 100644
--- a/src/heap/heap.cc
+++ b/src/heap/heap.cc
@@ -1039,10 +1039,10 @@ void Heap::PrintRetainingPath(Tagged<HeapObject> target,
     PrintF("^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n");
     PrintF("Distance from root %d%s: ", distance,
            node_ephemeron ? " (ephemeron)" : "");
-    node_object->ShortPrint();
+    ShortPrint(*node_object);
     PrintF("\n");
 #ifdef OBJECT_PRINT
-    node_object->Print();
+    i::Print(*node_object);
     PrintF("\n");
 #endif
     --distance;
@@ -1574,7 +1574,7 @@ void ReportDuplicates(int size, std::vector<HeapObject>* objects) {
     PrintF("%d duplicates of size %d each (%dKB)\n", it->first, size,
            duplicate_bytes / KB);
     PrintF("Sample object: ");
-    it->second.Print();
+    Print(it->second);
     PrintF("============================\n");
   }
 }
diff --git a/src/heap/large-spaces.cc b/src/heap/large-spaces.cc
index 70e88c583c7..e6a02f19959 100644
--- a/src/heap/large-spaces.cc
+++ b/src/heap/large-spaces.cc
@@ -330,7 +330,7 @@ void LargeObjectSpace::Verify(Isolate* isolate,
         IsWeakArrayList(object, cage_base) ||                     //
         IsWeakFixedArray(object, cage_base);
     if (!is_valid_lo_space_object) {
-      object.Print();
+      i::Print(object);
       FATAL("Found invalid Object (instance_type=%i) in large object space.",
             object->map(cage_base)->instance_type());
     }
@@ -357,7 +357,7 @@ void LargeObjectSpace::Print() {
   StdoutStream os;
   LargeObjectSpaceObjectIterator it(this);
   for (HeapObject obj = it.Next(); !obj.is_null(); obj = it.Next()) {
-    obj.Print(os);
+    i::Print(obj, os);
   }
 }
 #endif  // DEBUG
diff --git a/src/heap/mark-compact.cc b/src/heap/mark-compact.cc
index 33d919d5d59..1f31def0af6 100644
--- a/src/heap/mark-compact.cc
+++ b/src/heap/mark-compact.cc
@@ -3371,7 +3371,7 @@ void MarkCompactCollector::ClearJSWeakRefs() {
     HeapObject target = HeapObject::cast(weak_cell->target());
     if (!target.InReadOnlySpace() &&
         !non_atomic_marking_state_->IsMarked(target)) {
-      DCHECK(target.CanBeHeldWeakly());
+      DCHECK(Object::CanBeHeldWeakly(target));
       // The value of the WeakCell is dead.
       JSFinalizationRegistry finalization_registry =
           JSFinalizationRegistry::cast(weak_cell->finalization_registry());
@@ -3394,7 +3394,7 @@ void MarkCompactCollector::ClearJSWeakRefs() {
     HeapObject unregister_token = weak_cell->unregister_token();
     if (!unregister_token.InReadOnlySpace() &&
         !non_atomic_marking_state_->IsMarked(unregister_token)) {
-      DCHECK(unregister_token.CanBeHeldWeakly());
+      DCHECK(Object::CanBeHeldWeakly(unregister_token));
       // The unregister token is dead. Remove any corresponding entries in the
       // key map. Multiple WeakCell with the same token will have all their
       // unregister_token field set to undefined when processing the first
diff --git a/src/heap/object-stats.cc b/src/heap/object-stats.cc
index 68485662000..b94de41635b 100644
--- a/src/heap/object-stats.cc
+++ b/src/heap/object-stats.cc
@@ -622,7 +622,7 @@ void ObjectStatsCollectorImpl::RecordVirtualJSObjectDetails(JSObject object) {
     if (elements != ReadOnlyRoots(heap_).empty_fixed_array()) {
       size_t element_size =
           (elements->Size() - FixedArrayBase::kHeaderSize) / elements->length();
-      uint32_t length = JSArray::cast(object)->length().Number();
+      uint32_t length = Object::Number(JSArray::cast(object)->length());
       size_t over_allocated = (elements->length() - length) * element_size;
       RecordVirtualObjectStats(object, elements,
                                ObjectStats::ARRAY_ELEMENTS_TYPE,
diff --git a/src/heap/setup-heap-internal.cc b/src/heap/setup-heap-internal.cc
index b4c16fa3373..e77fb1e5a05 100644
--- a/src/heap/setup-heap-internal.cc
+++ b/src/heap/setup-heap-internal.cc
@@ -850,7 +850,7 @@ bool Heap::CreateImportantReadOnlyObjects() {
   // The -0 value must be set before NewNumber works.
   set_minus_zero_value(
       *factory->NewHeapNumber<AllocationType::kReadOnly>(-0.0));
-  DCHECK(std::signbit(roots.minus_zero_value()->Number()));
+  DCHECK(std::signbit(Object::Number(*roots.minus_zero_value())));
 
   set_nan_value(*factory->NewHeapNumber<AllocationType::kReadOnly>(
       std::numeric_limits<double>::quiet_NaN()));
diff --git a/src/ic/handler-configuration.cc b/src/ic/handler-configuration.cc
index 677aabbca98..f1960d7ae93 100644
--- a/src/ic/handler-configuration.cc
+++ b/src/ic/handler-configuration.cc
@@ -541,18 +541,18 @@ void LoadHandler::PrintHandler(Object handler, std::ostream& os) {
     PrintSmiLoadHandler(raw_handler, os);
     if (load_handler->data_field_count() >= 1) {
       os << ", data1 = ";
-      load_handler->data1().ShortPrint(os);
+      ShortPrint(load_handler->data1(), os);
     }
     if (load_handler->data_field_count() >= 2) {
       os << ", data2 = ";
-      load_handler->data2().ShortPrint(os);
+      ShortPrint(load_handler->data2(), os);
     }
     if (load_handler->data_field_count() >= 3) {
       os << ", data3 = ";
-      load_handler->data3().ShortPrint(os);
+      ShortPrint(load_handler->data3(), os);
     }
     os << ", validity cell = ";
-    load_handler->validity_cell().ShortPrint(os);
+    ShortPrint(load_handler->validity_cell(), os);
     os << ")";
   } else {
     os << "LoadHandler(<unexpected>)(" << Brief(handler) << ")";
@@ -572,7 +572,7 @@ void StoreHandler::PrintHandler(Object handler, std::ostream& os) {
     if (IsCode(store_handler->smi_handler())) {
       Code code = Code::cast(store_handler->smi_handler());
       os << "builtin = ";
-      code.ShortPrint(os);
+      ShortPrint(code, os);
     } else {
       int raw_handler = store_handler->smi_handler().ToSmi().value();
       os << "do access check on lookup start object = "
@@ -583,18 +583,18 @@ void StoreHandler::PrintHandler(Object handler, std::ostream& os) {
     }
     if (store_handler->data_field_count() >= 1) {
       os << ", data1 = ";
-      store_handler->data1().ShortPrint(os);
+      ShortPrint(store_handler->data1(), os);
     }
     if (store_handler->data_field_count() >= 2) {
       os << ", data2 = ";
-      store_handler->data2().ShortPrint(os);
+      ShortPrint(store_handler->data2(), os);
     }
     if (store_handler->data_field_count() >= 3) {
       os << ", data3 = ";
-      store_handler->data3().ShortPrint(os);
+      ShortPrint(store_handler->data3(), os);
     }
     os << ", validity cell = ";
-    store_handler->validity_cell().ShortPrint(os);
+    ShortPrint(store_handler->validity_cell(), os);
     os << ")" << std::endl;
   } else if (IsMap(handler)) {
     os << "StoreHandler(field transition to " << Brief(handler) << ")"
diff --git a/src/ic/ic.cc b/src/ic/ic.cc
index 9ec25d57d4d..2b0008fb244 100644
--- a/src/ic/ic.cc
+++ b/src/ic/ic.cc
@@ -321,7 +321,7 @@ void IC::OnFeedbackChanged(Isolate* isolate, FeedbackVector vector,
     } else {
       os << "[Feedback slot " << slot.ToInt() << "/" << slot_count << " in ";
     }
-    vector.shared_function_info().ShortPrint(os);
+    ShortPrint(vector.shared_function_info(), os);
     if (slot.IsInvalid()) {
       os << " updated - ";
     } else {
@@ -939,7 +939,7 @@ MaybeObjectHandle LoadIC::ComputeHandler(LookupIterator* lookup) {
             isolate());
         InternalIndex entry =
             exports->FindEntry(isolate(), roots, lookup->name(),
-                               Smi::ToInt(lookup->name()->GetHash()));
+                               Smi::ToInt(Object::GetHash(*lookup->name())));
         // We found the accessor, so the entry must exist.
         DCHECK(entry.is_found());
         int value_index = ObjectHashTable::EntryToValueIndex(entry);
@@ -1438,7 +1438,7 @@ bool CanCache(Handle<Object> receiver, InlineCacheState state) {
 bool IsOutOfBoundsAccess(Handle<Object> receiver, size_t index) {
   size_t length;
   if (IsJSArray(*receiver)) {
-    length = JSArray::cast(*receiver)->length().Number();
+    length = Object::Number(JSArray::cast(*receiver)->length());
   } else if (IsJSTypedArray(*receiver)) {
     length = JSTypedArray::cast(*receiver)->GetLength();
   } else if (IsJSObject(*receiver)) {
@@ -3530,7 +3530,7 @@ RUNTIME_FUNCTION(Runtime_HasElementWithInterceptor) {
       Handle<Object> result = arguments.CallIndexedQuery(interceptor, index);
       if (!result.is_null()) {
         int32_t value;
-        CHECK(result->ToInt32(&value));
+        CHECK(Object::ToInt32(*result, &value));
         if (value == ABSENT) return ReadOnlyRoots(isolate).false_value();
         arguments.AcceptSideEffects();
         return ReadOnlyRoots(isolate).true_value();
diff --git a/src/json/json-parser.cc b/src/json/json-parser.cc
index 18bfc87cf8c..f3ff33f9657 100644
--- a/src/json/json-parser.cc
+++ b/src/json/json-parser.cc
@@ -160,7 +160,7 @@ MaybeHandle<Object> JsonParseInternalizer::InternalizeJsonProperty(
   //
   // When with_source == kWithoutSource, this is unused.
   bool pass_source_to_reviver =
-      with_source == kWithSource && value->SameValue(*snapshot);
+      with_source == kWithSource && Object::SameValue(*value, *snapshot);
 
   if (IsJSReceiver(*value)) {
     Handle<JSReceiver> object = Handle<JSReceiver>::cast(value);
@@ -171,7 +171,7 @@ MaybeHandle<Object> JsonParseInternalizer::InternalizeJsonProperty(
       ASSIGN_RETURN_ON_EXCEPTION(
           isolate_, length_object,
           Object::GetLengthFromArrayLike(isolate_, object), Object);
-      double length = length_object->Number();
+      double length = Object::Number(*length_object);
       if (pass_source_to_reviver) {
         Handle<FixedArray> val_nodes_and_snapshots =
             Handle<FixedArray>::cast(val_node);
@@ -758,15 +758,16 @@ Handle<Object> JsonParser<Char>::BuildJsonObject(
         target->instance_descriptors(isolate_)->GetDetails(descriptor_index);
     Representation expected_representation = details.representation();
 
-    if (!value->FitsRepresentation(expected_representation)) {
-      Representation representation = value->OptimalRepresentation(isolate());
+    if (!Object::FitsRepresentation(*value, expected_representation)) {
+      Representation representation =
+          Object::OptimalRepresentation(*value, isolate());
       representation = representation.generalize(expected_representation);
       if (!expected_representation.CanBeInPlaceChangedTo(representation)) {
         map = ParentOfDescriptorOwner(isolate_, map, target, descriptor);
         break;
       }
       Handle<FieldType> value_type =
-          value->OptimalType(isolate(), representation);
+          Object::OptimalType(*value, isolate(), representation);
       MapUpdater::GeneralizeField(isolate(), target, descriptor_index,
                                   details.constness(), representation,
                                   value_type);
@@ -775,7 +776,7 @@ Handle<Object> JsonParser<Char>::BuildJsonObject(
                     .GetFieldType(descriptor_index)
                     .NowContains(value)) {
       Handle<FieldType> value_type =
-          value->OptimalType(isolate(), expected_representation);
+          Object::OptimalType(*value, isolate(), expected_representation);
       MapUpdater::GeneralizeField(isolate(), target, descriptor_index,
                                   details.constness(), expected_representation,
                                   value_type);
@@ -932,7 +933,7 @@ Handle<Object> JsonParser<Char>::BuildJsonArray(
     DisallowGarbageCollection no_gc;
     FixedDoubleArray elements = FixedDoubleArray::cast(array->elements());
     for (int i = 0; i < length; i++) {
-      elements->set(i, element_stack[start + i]->Number());
+      elements->set(i, Object::Number(*element_stack[start + i]));
     }
   } else {
     DisallowGarbageCollection no_gc;
diff --git a/src/json/json-stringifier.cc b/src/json/json-stringifier.cc
index 96818c0b33d..30bcd28599e 100644
--- a/src/json/json-stringifier.cc
+++ b/src/json/json-stringifier.cc
@@ -427,7 +427,7 @@ bool JsonStringifier::InitializeReplacer(Handle<Object> replacer) {
                                        Handle<JSReceiver>::cast(replacer)),
         false);
     uint32_t length;
-    if (!length_obj->ToUint32(&length)) length = kMaxUInt32;
+    if (!Object::ToUint32(*length_obj, &length)) length = kMaxUInt32;
     for (uint32_t i = 0; i < length; i++) {
       Handle<Object> element;
       Handle<String> key;
@@ -493,7 +493,7 @@ bool JsonStringifier::InitializeGap(Handle<Object> gap) {
       gap_[gap_length] = '\0';
     }
   } else if (IsNumber(*gap)) {
-    double value = std::min(gap->Number(), 10.0);
+    double value = std::min(Object::Number(*gap), 10.0);
     if (value > 0) {
       int gap_length = DoubleToInt32(value);
       gap_ = NewArray<base::uc16>(gap_length + 1);
@@ -875,7 +875,7 @@ JsonStringifier::Result JsonStringifier::SerializeDouble(double number) {
 JsonStringifier::Result JsonStringifier::SerializeJSArray(
     Handle<JSArray> object, Handle<Object> key) {
   uint32_t length = 0;
-  CHECK(object->length().ToArrayLength(&length));
+  CHECK(Object::ToArrayLength(object->length(), &length));
   DCHECK(!IsAccessCheckNeeded(*object));
   if (length == 0) {
     AppendCStringLiteral("[]");
@@ -1129,7 +1129,7 @@ JsonStringifier::Result JsonStringifier::SerializeJSProxy(
                                        Handle<JSReceiver>::cast(object)),
         EXCEPTION);
     uint32_t length;
-    if (!length_object->ToUint32(&length)) {
+    if (!Object::ToUint32(*length_object, &length)) {
       // Technically, we need to be able to handle lengths outside the
       // uint32_t range. However, we would run into string size overflow
       // if we tried to stringify such an array.
diff --git a/src/logging/log.cc b/src/logging/log.cc
index 37dfc5525bd..accccf4737c 100644
--- a/src/logging/log.cc
+++ b/src/logging/log.cc
@@ -1923,7 +1923,7 @@ void V8FileLogger::ICEvent(const char* type, bool keyed, Handle<Map> map,
   if (IsSmi(*key)) {
     msg << Smi::ToInt(*key);
   } else if (IsNumber(*key)) {
-    msg << key->Number();
+    msg << Object::Number(*key);
   } else if (IsName(*key)) {
     msg << Name::cast(*key);
   }
diff --git a/src/maglev/maglev-compiler.cc b/src/maglev/maglev-compiler.cc
index 092a04e2c6e..2f5dbf08308 100644
--- a/src/maglev/maglev-compiler.cc
+++ b/src/maglev/maglev-compiler.cc
@@ -394,7 +394,7 @@ bool MaglevCompiler::Compile(LocalIsolate* local_isolate,
       BytecodeArray::Disassemble(top_level_unit->bytecode().object(),
                                  std::cout);
       if (v8_flags.maglev_print_feedback) {
-        top_level_unit->feedback().object()->Print(std::cout);
+        Print(*top_level_unit->feedback().object(), std::cout);
       }
     }
 
@@ -522,7 +522,7 @@ MaybeHandle<Code> MaglevCompiler::GenerateCode(
   }
 
   if (v8_flags.print_maglev_code) {
-    code->Print();
+    Print(*code);
   }
 
   return code;
diff --git a/src/maglev/maglev-graph-builder.cc b/src/maglev/maglev-graph-builder.cc
index 8399fb2e891..498a599e21f 100644
--- a/src/maglev/maglev-graph-builder.cc
+++ b/src/maglev/maglev-graph-builder.cc
@@ -5576,7 +5576,7 @@ bool MaglevGraphBuilder::ShouldInlineCall(
   TRACE_INLINING("  inlining " << shared);
   if (v8_flags.trace_maglev_inlining_verbose) {
     BytecodeArray::Disassemble(bytecode.object(), std::cout);
-    feedback_vector->object()->Print(std::cout);
+    i::Print(*feedback_vector->object(), std::cout);
   }
   graph()->add_inlined_bytecode_size(bytecode.length());
   return true;
diff --git a/src/maglev/maglev-ir.cc b/src/maglev/maglev-ir.cc
index 409a36081e7..5bfd91c480f 100644
--- a/src/maglev/maglev-ir.cc
+++ b/src/maglev/maglev-ir.cc
@@ -272,7 +272,7 @@ bool CheckToBooleanOnAllRoots(LocalIsolate* local_isolate) {
   /* Ignore 'undefined' roots that are not the undefined value itself. */ \
   if (roots.name() != roots.undefined_value() ||                          \
       RootIndex::k##CamelName == RootIndex::kUndefinedValue) {            \
-    DCHECK_EQ(roots.name()->BooleanValue(local_isolate),                  \
+    DCHECK_EQ(Object::BooleanValue(roots.name(), local_isolate),          \
               RootToBoolean(RootIndex::k##CamelName));                    \
   }
   READ_ONLY_ROOT_LIST(DO_CHECK)
diff --git a/src/maglev/maglev-ir.h b/src/maglev/maglev-ir.h
index 877698619e9..155dbd85313 100644
--- a/src/maglev/maglev-ir.h
+++ b/src/maglev/maglev-ir.h
@@ -4148,7 +4148,7 @@ class Constant : public FixedInputValueNodeT<0, Constant> {
       : Base(bitfield), object_(object) {}
 
   bool ToBoolean(LocalIsolate* local_isolate) const {
-    return object_.object()->BooleanValue(local_isolate);
+    return Object::BooleanValue(*object_.object(), local_isolate);
   }
 
   bool IsTheHole(compiler::JSHeapBroker* broker) const {
diff --git a/src/objects/allocation-site-inl.h b/src/objects/allocation-site-inl.h
index cc3ea1af8d5..f69e47cd5cb 100644
--- a/src/objects/allocation-site-inl.h
+++ b/src/objects/allocation-site-inl.h
@@ -225,7 +225,7 @@ bool AllocationSite::DigestTransitionFeedback(Handle<AllocationSite> site,
       // If the array is huge, it's not likely to be defined in a local
       // function, so we shouldn't make new instances of it very often.
       uint32_t length = 0;
-      CHECK(boilerplate->length().ToArrayLength(&length));
+      CHECK(Object::ToArrayLength(boilerplate->length(), &length));
       if (length <= kMaximumArrayBytesToPretransition) {
         if (update_or_check == AllocationSiteUpdateMode::kCheckOnly) {
           return true;
diff --git a/src/objects/bigint.cc b/src/objects/bigint.cc
index e7b16cd5571..1ee21f2ae46 100644
--- a/src/objects/bigint.cc
+++ b/src/objects/bigint.cc
@@ -1081,7 +1081,8 @@ MaybeHandle<BigInt> BigInt::FromObject(Isolate* isolate, Handle<Object> obj) {
   }
 
   if (IsBoolean(*obj)) {
-    return MutableBigInt::NewFromInt(isolate, obj->BooleanValue(isolate));
+    return MutableBigInt::NewFromInt(isolate,
+                                     Object::BooleanValue(*obj, isolate));
   }
   if (IsBigInt(*obj)) {
     return Handle<BigInt>::cast(obj);
diff --git a/src/objects/bytecode-array.cc b/src/objects/bytecode-array.cc
index bcad7687174..bac4bb05511 100644
--- a/src/objects/bytecode-array.cc
+++ b/src/objects/bytecode-array.cc
@@ -134,7 +134,7 @@ void BytecodeArray::Disassemble(Handle<BytecodeArray> handle,
   os << "Constant pool (size = " << handle->constant_pool()->length() << ")\n";
 #ifdef OBJECT_PRINT
   if (handle->constant_pool()->length() > 0) {
-    handle->constant_pool().Print(os);
+    Print(handle->constant_pool(), os);
   }
 #endif
 
diff --git a/src/objects/compilation-cache-table-inl.h b/src/objects/compilation-cache-table-inl.h
index 044fd9f8efd..4c6149ceb9b 100644
--- a/src/objects/compilation-cache-table-inl.h
+++ b/src/objects/compilation-cache-table-inl.h
@@ -128,7 +128,7 @@ uint32_t CompilationCacheShape::EvalHash(String source,
 uint32_t CompilationCacheShape::HashForObject(ReadOnlyRoots roots,
                                               Object object) {
   // Eval: The key field contains the hash as a Number.
-  if (IsNumber(object)) return static_cast<uint32_t>(object.Number());
+  if (IsNumber(object)) return static_cast<uint32_t>(Object::Number(object));
 
   // Code: The key field contains the SFI key.
   if (IsSharedFunctionInfo(object)) {
diff --git a/src/objects/compilation-cache-table.cc b/src/objects/compilation-cache-table.cc
index 7d0f663e56b..416cc10fbf3 100644
--- a/src/objects/compilation-cache-table.cc
+++ b/src/objects/compilation-cache-table.cc
@@ -156,7 +156,7 @@ class EvalCacheKey : public HashTableKey {
     DisallowGarbageCollection no_gc;
     if (!IsFixedArray(other)) {
       DCHECK(IsNumber(other));
-      uint32_t other_hash = static_cast<uint32_t>(other.Number());
+      uint32_t other_hash = static_cast<uint32_t>(Object::Number(other));
       return Hash() == other_hash;
     }
     FixedArray other_array = FixedArray::cast(other);
@@ -283,7 +283,8 @@ bool ScriptCacheKey::MatchesOrigin(Script script) {
     // host-defined options is a v8::PrimitiveArray.
     DCHECK(IsPrimitive(host_defined_options->get(i)));
     DCHECK(IsPrimitive(script_options->get(i)));
-    if (!host_defined_options->get(i).StrictEquals(script_options->get(i))) {
+    if (!Object::StrictEquals(host_defined_options->get(i),
+                              script_options->get(i))) {
       return false;
     }
   }
diff --git a/src/objects/contexts.cc b/src/objects/contexts.cc
index e4d9ae20dd2..cdeee402548 100644
--- a/src/objects/contexts.cc
+++ b/src/objects/contexts.cc
@@ -185,7 +185,7 @@ static Maybe<bool> UnscopableLookup(LookupIterator* it, bool is_with_context) {
       JSReceiver::GetProperty(isolate, Handle<JSReceiver>::cast(unscopables),
                               it->name()),
       Nothing<bool>());
-  return Just(!blocklist->BooleanValue(isolate));
+  return Just(!Object::BooleanValue(*blocklist, isolate));
 }
 
 static PropertyAttributes GetAttributesForMode(VariableMode mode) {
@@ -214,7 +214,7 @@ Handle<Object> Context::Lookup(Handle<Context> context, Handle<String> name,
 
   if (v8_flags.trace_contexts) {
     PrintF("Context::Lookup(");
-    name->ShortPrint();
+    ShortPrint(*name);
     PrintF(")\n");
   }
 
diff --git a/src/objects/dependent-code-inl.h b/src/objects/dependent-code-inl.h
index 7bc47060358..2cf2cc16784 100644
--- a/src/objects/dependent-code-inl.h
+++ b/src/objects/dependent-code-inl.h
@@ -32,7 +32,7 @@ void DependentCode::DeoptimizeDependencyGroups(Isolate* isolate,
                                                Tagged<ObjectT> object,
                                                DependencyGroups groups) {
   // Shared objects are designed to never invalidate code.
-  DCHECK(!object->InSharedHeap() && !object->InReadOnlySpace());
+  DCHECK(!Object::InSharedHeap(object) && !object->InReadOnlySpace());
   object->dependent_code().DeoptimizeDependencyGroups(isolate, groups);
 }
 
diff --git a/src/objects/dictionary-inl.h b/src/objects/dictionary-inl.h
index 03e66b86b4b..027a6c21470 100644
--- a/src/objects/dictionary-inl.h
+++ b/src/objects/dictionary-inl.h
@@ -303,7 +303,7 @@ void GlobalDictionary::ValueAtPut(InternalIndex entry, Object value) {
 
 bool NumberDictionaryBaseShape::IsMatch(uint32_t key, Object other) {
   DCHECK(IsNumber(other));
-  return key == static_cast<uint32_t>(other.Number());
+  return key == static_cast<uint32_t>(Object::Number(other));
 }
 
 uint32_t NumberDictionaryBaseShape::Hash(ReadOnlyRoots roots, uint32_t key) {
@@ -313,7 +313,7 @@ uint32_t NumberDictionaryBaseShape::Hash(ReadOnlyRoots roots, uint32_t key) {
 uint32_t NumberDictionaryBaseShape::HashForObject(ReadOnlyRoots roots,
                                                   Object other) {
   DCHECK(IsNumber(other));
-  return ComputeSeededHash(static_cast<uint32_t>(other.Number()),
+  return ComputeSeededHash(static_cast<uint32_t>(Object::Number(other)),
                            HashSeed(roots));
 }
 
diff --git a/src/objects/elements.cc b/src/objects/elements.cc
index bba324d8836..67f178c6a1d 100644
--- a/src/objects/elements.cc
+++ b/src/objects/elements.cc
@@ -435,7 +435,7 @@ void CopyObjectToDoubleElements(FixedArrayBase from_base, uint32_t from_start,
     if (hole_or_object == the_hole) {
       to->set_the_hole(to_start);
     } else {
-      to->set(to_start, hole_or_object.Number());
+      to->set(to_start, Object::Number(hole_or_object));
     }
   }
 }
@@ -462,7 +462,7 @@ void CopyDictionaryToDoubleElements(Isolate* isolate, FixedArrayBase from_base,
   for (int i = 0; i < copy_size; i++) {
     InternalIndex entry = from->FindEntry(isolate, i + from_start);
     if (entry.is_found()) {
-      to->set(i + to_start, from->ValueAt(entry).Number());
+      to->set(i + to_start, Object::Number(from->ValueAt(entry)));
     } else {
       to->set_the_hole(i + to_start);
     }
@@ -489,7 +489,7 @@ void SortIndices(Isolate* isolate, Handle<FixedArray> indices,
       if (!IsSmi(b) && IsUndefined(b, isolate)) {
         return true;
       }
-      return a.Number() < b.Number();
+      return Object::Number(a) < Object::Number(b);
     }
     return !IsSmi(b) && IsUndefined(b, isolate);
   });
@@ -511,7 +511,7 @@ Maybe<bool> IncludesValueSlowPath(Isolate* isolate, Handle<JSObject> receiver,
     ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
                                      Object::GetProperty(&it), Nothing<bool>());
 
-    if (value->SameValueZero(*element_k)) return Just(true);
+    if (Object::SameValueZero(*value, *element_k)) return Just(true);
   }
 
   return Just(false);
@@ -529,7 +529,7 @@ Maybe<int64_t> IndexOfValueSlowPath(Isolate* isolate, Handle<JSObject> receiver,
     ASSIGN_RETURN_ON_EXCEPTION_VALUE(
         isolate, element_k, Object::GetProperty(&it), Nothing<int64_t>());
 
-    if (value->StrictEquals(*element_k)) return Just<int64_t>(k);
+    if (Object::StrictEquals(*value, *element_k)) return Just<int64_t>(k);
   }
 
   return Just<int64_t>(-1);
@@ -768,7 +768,7 @@ class ElementsAccessorBase : public InternalElementsAccessor {
     DCHECK(!array->SetLengthWouldNormalize(length));
     DCHECK(IsFastElementsKind(array->GetElementsKind()));
     uint32_t old_length = 0;
-    CHECK(array->length().ToArrayIndex(&old_length));
+    CHECK(Object::ToArrayIndex(array->length(), &old_length));
 
     if (old_length < length) {
       ElementsKind kind = array->GetElementsKind();
@@ -1121,7 +1121,7 @@ class ElementsAccessorBase : public InternalElementsAccessor {
     for (; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
-      if (!key->ToUint32(&index)) continue;
+      if (!Object::ToUint32(*key, &index)) continue;
 
       DCHECK_EQ(object->GetElementsKind(), original_elements_kind);
       InternalIndex entry = Subclass::GetEntryForIndexImpl(
@@ -1147,7 +1147,7 @@ class ElementsAccessorBase : public InternalElementsAccessor {
     for (; i < keys->length(); i++) {
       Handle<Object> key(keys->get(i), isolate);
       uint32_t index;
-      if (!key->ToUint32(&index)) continue;
+      if (!Object::ToUint32(*key, &index)) continue;
 
       if (filter & ONLY_ENUMERABLE) {
         InternalElementsAccessor* accessor =
@@ -1287,7 +1287,7 @@ class ElementsAccessorBase : public InternalElementsAccessor {
       if (convert == GetKeysConversion::kConvertToString) {
         for (uint32_t i = 0; i < nof_indices; i++) {
           Handle<Object> index_string = isolate->factory()->Uint32ToString(
-              combined_keys->get(i).Number());
+              Object::Number(combined_keys->get(i)));
           combined_keys->set(i, *index_string);
         }
       }
@@ -1464,7 +1464,7 @@ class DictionaryElementsAccessor
     Handle<NumberDictionary> dict =
         Handle<NumberDictionary>::cast(backing_store);
     uint32_t old_length = 0;
-    CHECK(array->length().ToArrayLength(&old_length));
+    CHECK(Object::ToArrayLength(array->length(), &old_length));
     {
       DisallowGarbageCollection no_gc;
       ReadOnlyRoots roots(isolate);
@@ -1475,7 +1475,7 @@ class DictionaryElementsAccessor
           for (InternalIndex entry : dict->IterateEntries()) {
             Object index = dict->KeyAt(isolate, entry);
             if (dict->IsKey(roots, index)) {
-              uint32_t number = static_cast<uint32_t>(index.Number());
+              uint32_t number = static_cast<uint32_t>(Object::Number(index));
               if (length <= number && number < old_length) {
                 PropertyDetails details = dict->DetailsAt(entry);
                 if (!details.IsConfigurable()) length = number + 1;
@@ -1493,7 +1493,7 @@ class DictionaryElementsAccessor
           for (InternalIndex entry : dict->IterateEntries()) {
             Object index = dict->KeyAt(isolate, entry);
             if (dict->IsKey(roots, index)) {
-              uint32_t number = static_cast<uint32_t>(index.Number());
+              uint32_t number = static_cast<uint32_t>(Object::Number(index));
               if (length <= number && number < old_length) {
                 dict->ClearEntry(entry);
                 removed_entries++;
@@ -1661,11 +1661,11 @@ class DictionaryElementsAccessor
                             InternalIndex entry, Object raw_key,
                             PropertyFilter filter) {
     DCHECK(IsNumber(raw_key));
-    DCHECK_LE(raw_key.Number(), kMaxUInt32);
+    DCHECK_LE(Object::Number(raw_key), kMaxUInt32);
     PropertyDetails details = dictionary->DetailsAt(entry);
     PropertyAttributes attr = details.attributes();
     if ((int{attr} & filter) != 0) return kMaxUInt32;
-    return static_cast<uint32_t>(raw_key.Number());
+    return static_cast<uint32_t>(Object::Number(raw_key));
   }
 
   static uint32_t GetKeyForEntryImpl(Isolate* isolate,
@@ -1767,7 +1767,8 @@ class DictionaryElementsAccessor
       if (k == undefined) continue;
 
       uint32_t index;
-      if (!k.ToArrayIndex(&index) || index < start_from || index >= length) {
+      if (!Object::ToArrayIndex(k, &index) || index < start_from ||
+          index >= length) {
         continue;
       }
 
@@ -1777,7 +1778,7 @@ class DictionaryElementsAccessor
         return false;
       } else if (!found) {
         Object element_k = dictionary->ValueAt(isolate, i);
-        if (value->SameValueZero(element_k)) found = true;
+        if (Object::SameValueZero(*value, element_k)) found = true;
       }
     }
 
@@ -1818,7 +1819,7 @@ class DictionaryElementsAccessor
       switch (details.kind()) {
         case PropertyKind::kData: {
           Object element_k = dictionary->ValueAt(entry);
-          if (value->SameValueZero(element_k)) return Just(true);
+          if (Object::SameValueZero(*value, element_k)) return Just(true);
           break;
         }
         case PropertyKind::kAccessor: {
@@ -1832,7 +1833,7 @@ class DictionaryElementsAccessor
                                            Object::GetPropertyWithAccessor(&it),
                                            Nothing<bool>());
 
-          if (value->SameValueZero(*element_k)) return Just(true);
+          if (Object::SameValueZero(*value, *element_k)) return Just(true);
 
           // Bailout to slow path if elements on prototype changed
           if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
@@ -1890,7 +1891,7 @@ class DictionaryElementsAccessor
       switch (details.kind()) {
         case PropertyKind::kData: {
           Object element_k = dictionary->ValueAt(entry);
-          if (value->StrictEquals(element_k)) {
+          if (Object::StrictEquals(*value, element_k)) {
             return Just<int64_t>(k);
           }
           break;
@@ -1906,7 +1907,7 @@ class DictionaryElementsAccessor
                                            Object::GetPropertyWithAccessor(&it),
                                            Nothing<int64_t>());
 
-          if (value->StrictEquals(*element_k)) return Just<int64_t>(k);
+          if (Object::StrictEquals(*value, *element_k)) return Just<int64_t>(k);
 
           // Bailout to slow path if elements on prototype changed.
           if (!JSObject::PrototypeHasNoElements(isolate, *receiver)) {
@@ -1945,8 +1946,8 @@ class DictionaryElementsAccessor
     for (InternalIndex i : dictionary->IterateEntries()) {
       Object k;
       if (!dictionary->ToKey(roots, i, &k)) continue;
-      DCHECK_LE(0.0, k.Number());
-      if (k.Number() > NumberDictionary::kRequiresSlowElementsLimit) {
+      DCHECK_LE(0.0, Object::Number(k));
+      if (Object::Number(k) > NumberDictionary::kRequiresSlowElementsLimit) {
         requires_slow_elements = true;
       } else {
         max_key = std::max(max_key, Smi::ToInt(k));
@@ -2049,7 +2050,7 @@ class FastElementsAccessor : public ElementsAccessorBase<Subclass, KindTraits> {
     if (backing_store->length() < kMinLengthForSparsenessCheck) return;
     uint32_t length = 0;
     if (IsJSArray(*obj)) {
-      JSArray::cast(*obj)->length().ToArrayLength(&length);
+      Object::ToArrayLength(JSArray::cast(*obj)->length(), &length);
     } else {
       length = static_cast<uint32_t>(store->length());
     }
@@ -2376,13 +2377,13 @@ class FastElementsAccessor : public ElementsAccessorBase<Subclass, KindTraits> {
         for (size_t k = start_from; k < length; ++k) {
           Object element_k = elements->get(static_cast<int>(k));
           if (element_k == the_hole) continue;
-          if (value.SameValueZero(element_k)) return Just(true);
+          if (Object::SameValueZero(value, element_k)) return Just(true);
         }
         return Just(false);
       }
     } else {
       if (!IsNaN(value)) {
-        double search_number = value.Number();
+        double search_number = Object::Number(value);
         if (IsDoubleElementsKind(Subclass::kind())) {
           // Search for non-NaN Number in PACKED_DOUBLE_ELEMENTS or
           // HOLEY_DOUBLE_ELEMENTS --- Skip TheHole, and trust UCOMISD or
@@ -2405,7 +2406,8 @@ class FastElementsAccessor : public ElementsAccessorBase<Subclass, KindTraits> {
 
           for (size_t k = start_from; k < length; ++k) {
             Object element_k = elements->get(static_cast<int>(k));
-            if (IsNumber(element_k) && element_k.Number() == search_number) {
+            if (IsNumber(element_k) &&
+                Object::Number(element_k) == search_number) {
               return Just(true);
             }
           }
@@ -2689,7 +2691,8 @@ class FastSmiOrObjectElementsAccessor
     static_assert(FixedArray::kMaxLength <=
                   std::numeric_limits<uint32_t>::max());
     for (size_t k = start_from; k < length; ++k) {
-      if (value.StrictEquals(elements->get(static_cast<uint32_t>(k)))) {
+      if (Object::StrictEquals(value,
+                               elements->get(static_cast<uint32_t>(k)))) {
         return Just<int64_t>(k);
       }
     }
@@ -2737,7 +2740,7 @@ class FastNonextensibleObjectElementsAccessor
                                    uint32_t length,
                                    Handle<FixedArrayBase> backing_store) {
     uint32_t old_length = 0;
-    CHECK(array->length().ToArrayIndex(&old_length));
+    CHECK(Object::ToArrayIndex(array->length(), &old_length));
     if (length == old_length) {
       // Do nothing.
       return Just(true);
@@ -2835,7 +2838,7 @@ class FastSealedObjectElementsAccessor
                                    uint32_t length,
                                    Handle<FixedArrayBase> backing_store) {
     uint32_t old_length = 0;
-    CHECK(array->length().ToArrayIndex(&old_length));
+    CHECK(Object::ToArrayIndex(array->length(), &old_length));
     if (length == old_length) {
       // Do nothing.
       return Just(true);
@@ -3017,12 +3020,14 @@ class FastDoubleElementsAccessor
 
   static inline void SetImpl(FixedArrayBase backing_store, InternalIndex entry,
                              Object value) {
-    FixedDoubleArray::cast(backing_store)->set(entry.as_int(), value.Number());
+    FixedDoubleArray::cast(backing_store)
+        ->set(entry.as_int(), Object::Number(value));
   }
 
   static inline void SetImpl(FixedArrayBase backing_store, InternalIndex entry,
                              Object value, WriteBarrierMode mode) {
-    FixedDoubleArray::cast(backing_store)->set(entry.as_int(), value.Number());
+    FixedDoubleArray::cast(backing_store)
+        ->set(entry.as_int(), Object::Number(value));
   }
 
   static void CopyElementsImpl(Isolate* isolate, FixedArrayBase from,
@@ -3113,7 +3118,7 @@ class FastDoubleElementsAccessor
     if (IsNaN(value)) {
       return Just<int64_t>(-1);
     }
-    double numeric_search_value = value.Number();
+    double numeric_search_value = Object::Number(value);
     FixedDoubleArray elements = FixedDoubleArray::cast(receiver->elements());
 
     static_assert(FixedDoubleArray::kMaxLength <=
@@ -3480,7 +3485,7 @@ class TypedElementsAccessor
       if (!lossless) return Just(false);
     } else {
       if (!IsNumber(*value)) return Just(false);
-      double search_value = value->Number();
+      double search_value = Object::Number(*value);
       if (!std::isfinite(search_value)) {
         // Integral types cannot represent +Inf or NaN.
         if (!(Kind == FLOAT32_ELEMENTS || Kind == FLOAT64_ELEMENTS ||
@@ -3550,7 +3555,7 @@ class TypedElementsAccessor
       if (!lossless) return Just<int64_t>(-1);
     } else {
       if (!IsNumber(*value)) return Just<int64_t>(-1);
-      double search_value = value->Number();
+      double search_value = Object::Number(*value);
       if (!std::isfinite(search_value)) {
         // Integral types cannot represent +Inf or NaN.
         if (!IsFloatTypedArrayElementsKind(Kind)) {
@@ -3597,7 +3602,7 @@ class TypedElementsAccessor
       if (!lossless) return Just<int64_t>(-1);
     } else {
       if (!IsNumber(*value)) return Just<int64_t>(-1);
-      double search_value = value->Number();
+      double search_value = Object::Number(*value);
       if (!std::isfinite(search_value)) {
         if (std::is_integral<ElementType>::value) {
           // Integral types cannot represent +Inf or NaN.
@@ -4758,13 +4763,13 @@ class SloppyArgumentsElementsAccessor
                                          Object::GetPropertyWithAccessor(&it),
                                          Nothing<bool>());
 
-        if (value->SameValueZero(*element_k)) return Just(true);
+        if (Object::SameValueZero(*value, *element_k)) return Just(true);
 
         if (object->map() != *original_map) {
           // Some mutation occurred in accessor. Abort "fast" path
           return IncludesValueSlowPath(isolate, object, value, k + 1, length);
         }
-      } else if (value->SameValueZero(*element_k)) {
+      } else if (Object::SameValueZero(*value, *element_k)) {
         return Just(true);
       }
     }
@@ -4798,7 +4803,7 @@ class SloppyArgumentsElementsAccessor
                                          Object::GetPropertyWithAccessor(&it),
                                          Nothing<int64_t>());
 
-        if (value->StrictEquals(*element_k)) {
+        if (Object::StrictEquals(*value, *element_k)) {
           return Just<int64_t>(k);
         }
 
@@ -4806,7 +4811,7 @@ class SloppyArgumentsElementsAccessor
           // Some mutation occurred in accessor. Abort "fast" path.
           return IndexOfValueSlowPath(isolate, object, value, k + 1, length);
         }
-      } else if (value->StrictEquals(*element_k)) {
+      } else if (Object::StrictEquals(*value, *element_k)) {
         return Just<int64_t>(k);
       }
     }
@@ -5257,7 +5262,7 @@ MaybeHandle<Object> ArrayConstructInitializeElements(
 
   } else if (args->length() == 1 && IsNumber(*args->at(0))) {
     uint32_t length;
-    if (!args->at(0)->ToArrayLength(&length)) {
+    if (!Object::ToArrayLength(*args->at(0), &length)) {
       return ThrowArrayLengthRangeError(array->GetIsolate());
     }
 
@@ -5324,7 +5329,7 @@ MaybeHandle<Object> ArrayConstructInitializeElements(
       Handle<FixedDoubleArray> double_elms =
           Handle<FixedDoubleArray>::cast(elms);
       for (int entry = 0; entry < number_of_elements; entry++) {
-        double_elms->set(entry, (*args)[entry].Number());
+        double_elms->set(entry, Object::Number((*args)[entry]));
       }
       break;
     }
@@ -5453,7 +5458,7 @@ Handle<JSArray> ElementsAccessor::Concat(Isolate* isolate,
     // performance degradation.
     JSArray array = JSArray::cast((*args)[i]);
     uint32_t len = 0;
-    array->length().ToArrayLength(&len);
+    Object::ToArrayLength(array->length(), &len);
     if (len == 0) continue;
     ElementsKind from_kind = array->GetElementsKind();
     accessor->CopyElements(array, 0, from_kind, storage, insertion_index, len);
diff --git a/src/objects/hash-table-inl.h b/src/objects/hash-table-inl.h
index 130b354d452..1be5481fe17 100644
--- a/src/objects/hash-table-inl.h
+++ b/src/objects/hash-table-inl.h
@@ -289,14 +289,14 @@ bool ObjectHashSet::Has(Isolate* isolate, Handle<Object> key, int32_t hash) {
 }
 
 bool ObjectHashSet::Has(Isolate* isolate, Handle<Object> key) {
-  Object hash = key->GetHash();
+  Object hash = Object::GetHash(*key);
   if (!IsSmi(hash)) return false;
   return FindEntry(isolate, ReadOnlyRoots(isolate), key, Smi::ToInt(hash))
       .is_found();
 }
 
 bool ObjectHashTableShape::IsMatch(Handle<Object> key, Object other) {
-  return key->SameValue(other);
+  return Object::SameValue(*key, other);
 }
 
 bool RegisteredSymbolTableShape::IsMatch(Handle<String> key, Object value) {
@@ -327,12 +327,12 @@ uint32_t NameToIndexShape::Hash(ReadOnlyRoots roots, Handle<Name> key) {
 }
 
 uint32_t ObjectHashTableShape::Hash(ReadOnlyRoots roots, Handle<Object> key) {
-  return Smi::ToInt(key->GetHash());
+  return Smi::ToInt(Object::GetHash(*key));
 }
 
 uint32_t ObjectHashTableShape::HashForObject(ReadOnlyRoots roots,
                                              Object other) {
-  return Smi::ToInt(other.GetHash());
+  return Smi::ToInt(Object::GetHash(other));
 }
 
 template <typename IsolateT>
diff --git a/src/objects/intl-objects.cc b/src/objects/intl-objects.cc
index e360ddc1015..e14d0a7fc2b 100644
--- a/src/objects/intl-objects.cc
+++ b/src/objects/intl-objects.cc
@@ -622,7 +622,8 @@ MaybeHandle<Object> Intl::LegacyUnwrapReceiver(Isolate* isolate,
   ASSIGN_RETURN_ON_EXCEPTION(
       isolate, obj_ordinary_has_instance,
       Object::OrdinaryHasInstance(isolate, constructor, receiver), Object);
-  bool ordinary_has_instance = obj_ordinary_has_instance->BooleanValue(isolate);
+  bool ordinary_has_instance =
+      Object::BooleanValue(*obj_ordinary_has_instance, isolate);
 
   // 2. If receiver does not have an [[Initialized...]] internal slot
   //    and ? OrdinaryHasInstance(constructor, receiver) is true, then
@@ -815,7 +816,7 @@ Maybe<std::vector<std::string>> Intl::CanonicalizeLocaleList(
   // up to 2^53-1 if {length_obj} says so. Since cases above 2^32 probably
   // don't happen in practice (and would be very slow if they do), we'll keep
   // the code simple for now by using a saturating to-uint32 conversion.
-  double raw_length = length_obj->Number();
+  double raw_length = Object::Number(*length_obj);
   uint32_t len =
       raw_length >= kMaxUInt32 ? kMaxUInt32 : static_cast<uint32_t>(raw_length);
   // 6. Let k be 0.
diff --git a/src/objects/js-array-buffer.cc b/src/objects/js-array-buffer.cc
index d175d4818ea..70d56aaa6dd 100644
--- a/src/objects/js-array-buffer.cc
+++ b/src/objects/js-array-buffer.cc
@@ -37,7 +37,7 @@ bool CanonicalNumericIndexString(Isolate* isolate,
     // 4. If SameValue(! ToString(n), argument) is false, return undefined.
     Handle<String> str = Object::ToString(isolate, result).ToHandleChecked();
     // Avoid treating strings like "2E1" and "20" as the same key.
-    if (!str->SameValue(*key)) return false;
+    if (!Object::SameValue(*str, *key)) return false;
   }
   return true;
 }
@@ -121,12 +121,13 @@ Maybe<bool> JSArrayBuffer::Detach(Handle<JSArrayBuffer> buffer,
   bool key_mismatch = false;
 
   if (!IsUndefined(*detach_key, isolate)) {
-    key_mismatch = maybe_key.is_null() || !maybe_key->StrictEquals(*detach_key);
+    key_mismatch =
+        maybe_key.is_null() || !Object::StrictEquals(*maybe_key, *detach_key);
   } else {
     // Detach key is undefined; allow not passing maybe_key but disallow passing
     // something else than undefined.
     key_mismatch =
-        !maybe_key.is_null() && !maybe_key->StrictEquals(*detach_key);
+        !maybe_key.is_null() && !Object::StrictEquals(*maybe_key, *detach_key);
   }
   if (key_mismatch) {
     THROW_NEW_ERROR_RETURN_VALUE(
diff --git a/src/objects/js-date-time-format.cc b/src/objects/js-date-time-format.cc
index 6d0f3ae6a8c..540659bdd3d 100644
--- a/src/objects/js-date-time-format.cc
+++ b/src/objects/js-date-time-format.cc
@@ -1158,7 +1158,7 @@ Maybe<DateTimeValueRecord> HandleDateTimeOthers(
     ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, x_obj,
                                      Object::ToNumber(isolate, x_obj),
                                      Nothing<DateTimeValueRecord>());
-    x = x_obj->Number();
+    x = Object::Number(*x_obj);
   }
   // 6. Set x to TimeClip(x).
   x = DateCache::TimeClip(x);
@@ -1476,7 +1476,7 @@ MaybeHandle<String> JSDateTimeFormat::DateTimeFormat(
     ASSIGN_RETURN_ON_EXCEPTION(isolate, date, Object::ToNumber(isolate, date),
                                String);
     DCHECK(IsNumber(*date));
-    x = date->Number();
+    x = Object::Number(*date);
   }
   // 5. Return FormatDateTime(dtf, x).
   icu::SimpleDateFormat* format =
@@ -1513,7 +1513,7 @@ MaybeHandle<String> JSDateTimeFormat::ToLocaleDateTime(
                                  factory->Date_string()),
                     String);
   }
-  double const x = Handle<JSDate>::cast(date)->value().Number();
+  double const x = Object::Number(Handle<JSDate>::cast(date)->value());
   // 2. If x is NaN, return "Invalid Date"
   if (std::isnan(x)) {
     return factory->Invalid_Date_string();
@@ -2715,7 +2715,7 @@ MaybeHandle<JSArray> JSDateTimeFormat::FormatToParts(
                                JSArray);
   }
 
-  double date_value = DateCache::TimeClip(x->Number());
+  double date_value = DateCache::TimeClip(Object::Number(*x));
   if (std::isnan(date_value)) {
     THROW_NEW_ERROR(isolate, NewRangeError(MessageTemplate::kInvalidTimeValue),
                     JSArray);
@@ -3043,11 +3043,11 @@ MaybeHandle<T> FormatRangeCommon(Isolate* isolate,
   // 4. Let x be ? ToNumber(startDate).
   ASSIGN_RETURN_ON_EXCEPTION(isolate, x_obj, Object::ToNumber(isolate, x_obj),
                              T);
-  double x = x_obj->Number();
+  double x = Object::Number(*x_obj);
   // 5. Let y be ? ToNumber(endDate).
   ASSIGN_RETURN_ON_EXCEPTION(isolate, y_obj, Object::ToNumber(isolate, y_obj),
                              T);
-  double y = y_obj->Number();
+  double y = Object::Number(*y_obj);
 
   base::Optional<MaybeHandle<T>> result =
       PartitionDateTimeRangePattern<T, Format>(isolate, date_time_format, x, y,
diff --git a/src/objects/js-function.cc b/src/objects/js-function.cc
index 44d1a890a00..c5241798390 100644
--- a/src/objects/js-function.cc
+++ b/src/objects/js-function.cc
@@ -214,14 +214,14 @@ void JSFunction::MarkForOptimization(Isolate* isolate, CodeKind target_kind,
     if (IsInProgress(tiering_state())) {
       if (v8_flags.trace_concurrent_recompilation) {
         PrintF("  ** Not marking ");
-        ShortPrint();
+        ShortPrint(*this);
         PrintF(" -- already in optimization queue.\n");
       }
       return;
     }
     if (v8_flags.trace_concurrent_recompilation) {
       PrintF("  ** Marking ");
-      ShortPrint();
+      ShortPrint(*this);
       PrintF(" for concurrent %s recompilation.\n",
              CodeKindToString(target_kind));
     }
@@ -265,7 +265,7 @@ Maybe<bool> JSFunctionOrBoundFunctionOrWrappedFunction::CopyNameAndLength(
                                        Nothing<bool>());
       if (IsNumber(*target_length)) {
         length = isolate->factory()->NewNumber(std::max(
-            0.0, DoubleToInteger(target_length->Number()) - arg_count));
+            0.0, DoubleToInteger(Object::Number(*target_length)) - arg_count));
       }
     }
     LookupIterator it(isolate, function, isolate->factory()->length_string(),
diff --git a/src/objects/js-number-format.cc b/src/objects/js-number-format.cc
index 08212a5da2d..3b10fb703b0 100644
--- a/src/objects/js-number-format.cc
+++ b/src/objects/js-number-format.cc
@@ -1568,7 +1568,7 @@ Maybe<icu::number::FormattedNumber> IcuFormatNumber(
     } else {
       double number = IsNaN(*numeric_obj)
                           ? std::numeric_limits<double>::quiet_NaN()
-                          : numeric_obj->Number();
+                          : Object::Number(*numeric_obj);
       formatted = number_format.formatDouble(number, status);
     }
   }
@@ -1710,7 +1710,7 @@ Maybe<IntlMathematicalValue> IntlMathematicalValue::From(Isolate* isolate,
   }
   if (IsNumber(*prim_value)) {
     result.value_ = prim_value;
-    result.approx_ = prim_value->Number();
+    result.approx_ = Object::Number(*prim_value);
     return Just(result);
   }
   if (!IsString(*prim_value)) {
@@ -1718,7 +1718,7 @@ Maybe<IntlMathematicalValue> IntlMathematicalValue::From(Isolate* isolate,
     ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, result.value_,
                                      Object::ToNumber(isolate, prim_value),
                                      Nothing<IntlMathematicalValue>());
-    result.approx_ = result.value_->Number();
+    result.approx_ = Object::Number(*result.value_);
     return Just(result);
   }
   Handle<String> string = Handle<String>::cast(prim_value);
diff --git a/src/objects/js-objects.cc b/src/objects/js-objects.cc
index e6b20f4deed..3aa27770141 100644
--- a/src/objects/js-objects.cc
+++ b/src/objects/js-objects.cc
@@ -258,7 +258,7 @@ bool HasExcludedProperty(
     Handle<Object> search_element) {
   // TODO(gsathya): Change this to be a hashtable.
   for (int i = 0; i < excluded_properties->length(); i++) {
-    if (search_element->SameValue(*excluded_properties->at(i))) {
+    if (Object::SameValue(*search_element, *excluded_properties->at(i))) {
       return true;
     }
   }
@@ -1282,7 +1282,7 @@ Maybe<PropertyAttributes> GetPropertyAttributesWithInterceptorInternal(
     }
     if (!result.is_null()) {
       int32_t value;
-      CHECK(result->ToInt32(&value));
+      CHECK(Object::ToInt32(*result, &value));
       DCHECK_IMPLIES((value & ~PropertyAttributes::ALL_ATTRIBUTES_MASK) != 0,
                      value == PropertyAttributes::ABSENT);
       // In case of absent property side effects are not allowed.
@@ -1557,9 +1557,11 @@ Maybe<bool> JSReceiver::ValidateAndApplyPropertyDescriptor(
       (!desc->has_writable() ||
        (current->has_writable() && current->writable() == desc->writable())) &&
       (!desc->has_get() ||
-       (current->has_get() && current->get()->SameValue(*desc->get()))) &&
+       (current->has_get() &&
+        Object::SameValue(*current->get(), *desc->get()))) &&
       (!desc->has_set() ||
-       (current->has_set() && current->set()->SameValue(*desc->set())))) {
+       (current->has_set() &&
+        Object::SameValue(*current->set(), *desc->set())))) {
     return Just(true);
   }
   // 4. If current.[[Configurable]] is false, then
@@ -1637,7 +1639,8 @@ Maybe<bool> JSReceiver::ValidateAndApplyPropertyDescriptor(
         // We'll succeed applying the property, but the value is already the
         // same and the property is read-only, so skip actually writing the
         // property. Otherwise we may try to e.g., write to frozen elements.
-        if (desc->value()->SameValue(*current->value())) return Just(true);
+        if (Object::SameValue(*desc->value(), *current->value()))
+          return Just(true);
         RETURN_FAILURE(
             isolate, GetShouldThrow(isolate, should_throw),
             NewTypeError(MessageTemplate::kRedefineDisallowed,
@@ -1654,7 +1657,8 @@ Maybe<bool> JSReceiver::ValidateAndApplyPropertyDescriptor(
     if (!current->configurable()) {
       // 8a i. If Desc.[[Set]] is present and SameValue(Desc.[[Set]],
       // current.[[Set]]) is false, return false.
-      if (desc->has_set() && !desc->set()->SameValue(*current->set())) {
+      if (desc->has_set() &&
+          !Object::SameValue(*desc->set(), *current->set())) {
         RETURN_FAILURE(
             isolate, GetShouldThrow(isolate, should_throw),
             NewTypeError(MessageTemplate::kRedefineDisallowed,
@@ -1662,7 +1666,8 @@ Maybe<bool> JSReceiver::ValidateAndApplyPropertyDescriptor(
       }
       // 8a ii. If Desc.[[Get]] is present and SameValue(Desc.[[Get]],
       // current.[[Get]]) is false, return false.
-      if (desc->has_get() && !desc->get()->SameValue(*current->get())) {
+      if (desc->has_get() &&
+          !Object::SameValue(*desc->get(), *current->get())) {
         RETURN_FAILURE(
             isolate, GetShouldThrow(isolate, should_throw),
             NewTypeError(MessageTemplate::kRedefineDisallowed,
@@ -2869,7 +2874,7 @@ void JSObject::JSObjectShortPrint(StringStream* accumulator) {
     case JS_ARRAY_TYPE: {
       double length = IsUndefined(JSArray::cast(*this)->length())
                           ? 0
-                          : JSArray::cast(*this)->length().Number();
+                          : Object::Number(JSArray::cast(*this)->length());
       accumulator->Add("<JSArray[%u]>", static_cast<uint32_t>(length));
       break;
     }
@@ -3001,7 +3006,7 @@ void JSObject::JSObjectShortPrint(StringStream* accumulator) {
       }
       if (IsJSPrimitiveWrapper(*this)) {
         accumulator->Add(" value = ");
-        JSPrimitiveWrapper::cast(*this)->value().ShortPrint(accumulator);
+        ShortPrint(JSPrimitiveWrapper::cast(*this)->value(), accumulator);
       }
       accumulator->Put('>');
       break;
@@ -3020,11 +3025,11 @@ void JSObject::PrintElementsTransition(FILE* file, Handle<JSObject> object,
        << ElementsKindToString(to_kind) << "] in ";
     JavaScriptFrame::PrintTop(object->GetIsolate(), file, false, true);
     PrintF(file, " for ");
-    object->ShortPrint(file);
+    ShortPrint(*object, file);
     PrintF(file, " from ");
-    from_elements->ShortPrint(file);
+    ShortPrint(*from_elements, file);
     PrintF(file, " to ");
-    to_elements->ShortPrint(file);
+    ShortPrint(*to_elements, file);
     PrintF(file, "\n");
   }
 }
@@ -3447,7 +3452,7 @@ void MigrateFastToSlow(Isolate* isolate, Handle<JSObject> object,
   if (v8_flags.trace_normalization) {
     StdoutStream os;
     os << "Object properties have been normalized:\n";
-    object->Print(os);
+    Print(*object, os);
   }
 #endif
 }
@@ -4079,7 +4084,7 @@ Handle<NumberDictionary> JSObject::NormalizeElements(Handle<JSObject> object) {
   if (v8_flags.trace_normalization) {
     StdoutStream os;
     os << "Object elements have been normalized:\n";
-    object->Print(os);
+    Print(*object, os);
   }
 #endif
 
@@ -4156,7 +4161,7 @@ bool TestDictionaryPropertiesIntegrityLevel(Dictionary dict,
   for (InternalIndex i : dict.IterateEntries()) {
     Object key;
     if (!dict.ToKey(roots, i, &key)) continue;
-    if (key.FilterKey(ALL_PROPERTIES)) continue;
+    if (Object::FilterKey(key, ALL_PROPERTIES)) continue;
     PropertyDetails details = dict.DetailsAt(i);
     if (details.IsConfigurable()) return false;
     if (level == FROZEN && details.kind() == PropertyKind::kData &&
@@ -4335,7 +4340,7 @@ void JSObject::ApplyAttributesToDictionary(
   for (InternalIndex i : dictionary->IterateEntries()) {
     Object k;
     if (!dictionary->ToKey(roots, i, &k)) continue;
-    if (k.FilterKey(ALL_PROPERTIES)) continue;
+    if (Object::FilterKey(k, ALL_PROPERTIES)) continue;
     PropertyDetails details = dictionary->DetailsAt(i);
     int attrs = attributes;
     // READ_ONLY is an invalid attribute for JS setters/getters.
@@ -4825,7 +4830,8 @@ Object JSObject::SlowReverseLookup(Object value) {
         Object property = RawFastPropertyAt(field_index);
         if (field_index.is_double()) {
           DCHECK(IsHeapNumber(property));
-          if (value_is_number && property.Number() == value.Number()) {
+          if (value_is_number &&
+              Object::Number(property) == Object::Number(value)) {
             return descs->GetKey(i);
           }
         } else if (property == value) {
@@ -5398,7 +5404,7 @@ Maybe<bool> JSObject::AddDataElement(Handle<JSObject> object, uint32_t index,
   uint32_t new_capacity = 0;
 
   if (IsJSArray(*object, isolate)) {
-    CHECK(JSArray::cast(*object)->length().ToArrayLength(&old_length));
+    CHECK(Object::ToArrayLength(JSArray::cast(*object)->length(), &old_length));
   }
 
   ElementsKind kind = object->GetElementsKind(isolate);
@@ -5424,7 +5430,7 @@ Maybe<bool> JSObject::AddDataElement(Handle<JSObject> object, uint32_t index,
     kind = dictionary_kind;
   }
 
-  ElementsKind to = value->OptimalElementsKind(isolate);
+  ElementsKind to = Object::OptimalElementsKind(*value, isolate);
   if (IsHoleyElementsKind(kind) || !IsJSArray(*object, isolate) ||
       index > old_length) {
     to = GetHoleyElementsKind(to);
@@ -5688,7 +5694,7 @@ Object JSDate::DoGetField(Isolate* isolate, FieldIndex index) {
     if (stamp != date_cache->stamp() && IsSmi(stamp)) {
       // Since the stamp is not NaN, the value is also not NaN.
       int64_t local_time_ms =
-          date_cache->ToLocal(static_cast<int64_t>(value().Number()));
+          date_cache->ToLocal(static_cast<int64_t>(Object::Number(value())));
       SetCachedFields(local_time_ms, date_cache);
     }
     switch (index) {
@@ -5712,10 +5718,10 @@ Object JSDate::DoGetField(Isolate* isolate, FieldIndex index) {
   }
 
   if (index >= kFirstUTCField) {
-    return GetUTCField(index, value().Number(), date_cache);
+    return GetUTCField(index, Object::Number(value()), date_cache);
   }
 
-  double time = value().Number();
+  double time = Object::Number(value());
   if (std::isnan(time)) return GetReadOnlyRoots().nan_value();
 
   int64_t local_time_ms = date_cache->ToLocal(static_cast<int64_t>(time));
diff --git a/src/objects/js-relative-time-format.cc b/src/objects/js-relative-time-format.cc
index db10411305d..2906c766b59 100644
--- a/src/objects/js-relative-time-format.cc
+++ b/src/objects/js-relative-time-format.cc
@@ -350,7 +350,7 @@ MaybeHandle<T> FormatCommon(
   Handle<Object> value;
   ASSIGN_RETURN_ON_EXCEPTION(isolate, value,
                              Object::ToNumber(isolate, value_obj), T);
-  double number = value->Number();
+  double number = Object::Number(*value);
   // 4. Let unit be ? ToString(unit).
   Handle<String> unit;
   ASSIGN_RETURN_ON_EXCEPTION(isolate, unit, Object::ToString(isolate, unit_obj),
diff --git a/src/objects/js-temporal-objects.cc b/src/objects/js-temporal-objects.cc
index 35791fe9566..a95bf55432f 100644
--- a/src/objects/js-temporal-objects.cc
+++ b/src/objects/js-temporal-objects.cc
@@ -2590,7 +2590,7 @@ bool IsIntegralNumber(Isolate* isolate, Handle<Object> argument) {
   // 1. If Type(argument) is not Number, return false.
   if (!IsNumber(*argument)) return false;
   // 2. If argument is NaN, +, or -, return false.
-  double number = argument->Number();
+  double number = Object::Number(*argument);
   if (!std::isfinite(number)) return false;
   // 3. If floor(abs((argument)))  abs((argument)), return false.
   if (std::floor(std::abs(number)) != std::abs(number)) return false;
@@ -2606,7 +2606,7 @@ Maybe<double> ToIntegerWithoutRounding(Isolate* isolate,
   ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, number, Object::ToNumber(isolate, argument), Nothing<double>());
   // 2. If number is NaN, +0, or 0 return 0.
-  if (IsNaN(*number) || number->Number() == 0) {
+  if (IsNaN(*number) || Object::Number(*number) == 0) {
     return Just(static_cast<double>(0));
   }
   // 3. If IsIntegralNumber(number) is false, throw a RangeError exception.
@@ -2615,7 +2615,7 @@ Maybe<double> ToIntegerWithoutRounding(Isolate* isolate,
         isolate, NEW_TEMPORAL_INVALID_ARG_RANGE_ERROR(), Nothing<double>());
   }
   // 4. Return (number).
-  return Just(number->Number());
+  return Just(Object::Number(*number));
 }
 
 }  // namespace
@@ -2853,11 +2853,14 @@ Maybe<DurationRecord> ToTemporalDurationRecord(
     Handle<JSTemporalDuration> duration =
         Handle<JSTemporalDuration>::cast(temporal_duration_like);
     return DurationRecord::Create(
-        isolate, duration->years().Number(), duration->months().Number(),
-        duration->weeks().Number(), duration->days().Number(),
-        duration->hours().Number(), duration->minutes().Number(),
-        duration->seconds().Number(), duration->milliseconds().Number(),
-        duration->microseconds().Number(), duration->nanoseconds().Number());
+        isolate, Object::Number(duration->years()),
+        Object::Number(duration->months()), Object::Number(duration->weeks()),
+        Object::Number(duration->days()), Object::Number(duration->hours()),
+        Object::Number(duration->minutes()),
+        Object::Number(duration->seconds()),
+        Object::Number(duration->milliseconds()),
+        Object::Number(duration->microseconds()),
+        Object::Number(duration->nanoseconds()));
   }
   // 3. Let result be a new Record with all the internal slots given in the
   // Internal Slot column in Table 8.
@@ -4360,7 +4363,7 @@ Maybe<int64_t> GetOffsetNanosecondsFor(Isolate* isolate,
     THROW_NEW_ERROR_RETURN_VALUE(
         isolate, NEW_TEMPORAL_INVALID_ARG_RANGE_ERROR(), Nothing<int64_t>());
   }
-  double offset_nanoseconds = offset_nanoseconds_obj->Number();
+  double offset_nanoseconds = Object::Number(*offset_nanoseconds_obj);
 
   // 6. Set offsetNanoseconds to (offsetNanoseconds).
   int64_t offset_nanoseconds_int = static_cast<int64_t>(offset_nanoseconds);
@@ -4436,7 +4439,7 @@ MaybeHandle<Object> InvokeCalendarMethod(Isolate* isolate,
     /* 4. Return ? Action(result). */                                         \
     ASSIGN_RETURN_ON_EXCEPTION(isolate, result, Action(isolate, result),      \
                                Object);                                       \
-    return handle(Smi::FromInt(result->Number()), isolate);                   \
+    return handle(Smi::FromInt(Object::Number(*result)), isolate);            \
   }
 
 #define CALENDAR_ABSTRACT_OPERATION(Name, property)                      \
@@ -4719,7 +4722,7 @@ Maybe<TimeRecord> ToTemporalTimeRecordOrPartialTime(
                                      Nothing<TimeRecord>());
     // e. / iii. Set result's internal slot whose name is the Internal Slot
     // value of the current row to value.
-    *(row.second) = value->Number();
+    *(row.second) = Object::Number(*value);
   }
 
   // 5. If _any_ is *false*, then
@@ -4937,7 +4940,7 @@ MaybeHandle<Object> ToIntegerThrowOnInfinity(Isolate* isolate,
   ASSIGN_RETURN_ON_EXCEPTION(isolate, argument,
                              Object::ToInteger(isolate, argument), Object);
   // 2. If integer is + or -, throw a RangeError exception.
-  if (!std::isfinite(argument->Number())) {
+  if (!std::isfinite(Object::Number(*argument))) {
     // a. Throw a RangeError exception.
     THROW_NEW_ERROR(isolate, NEW_TEMPORAL_INVALID_ARG_RANGE_ERROR(), Object);
   }
@@ -5377,12 +5380,15 @@ Maybe<BalancePossiblyInfiniteDurationResult> BalancePossiblyInfiniteDuration(
   // 1. Return positive overflow.
   // ii. Else if sign = -1, then
   // 1. Return negative overflow.
-  double hours_value = BigInt::ToNumber(isolate, hours)->Number();
-  double minutes_value = BigInt::ToNumber(isolate, minutes)->Number();
-  double seconds_value = BigInt::ToNumber(isolate, seconds)->Number();
-  double milliseconds_value = BigInt::ToNumber(isolate, milliseconds)->Number();
-  double microseconds_value = BigInt::ToNumber(isolate, microseconds)->Number();
-  double nanoseconds_value = BigInt::ToNumber(isolate, nanoseconds)->Number();
+  double hours_value = Object::Number(*BigInt::ToNumber(isolate, hours));
+  double minutes_value = Object::Number(*BigInt::ToNumber(isolate, minutes));
+  double seconds_value = Object::Number(*BigInt::ToNumber(isolate, seconds));
+  double milliseconds_value =
+      Object::Number(*BigInt::ToNumber(isolate, milliseconds));
+  double microseconds_value =
+      Object::Number(*BigInt::ToNumber(isolate, microseconds));
+  double nanoseconds_value =
+      Object::Number(*BigInt::ToNumber(isolate, nanoseconds));
   if (std::isinf(days) || std::isinf(hours_value) ||
       std::isinf(minutes_value) || std::isinf(seconds_value) ||
       std::isinf(milliseconds_value) || std::isinf(microseconds_value) ||
@@ -5566,8 +5572,9 @@ Maybe<NanosecondsToDaysResult> NanosecondsToDays(Isolate* isolate,
       nanoseconds = BigInt::UnaryMinus(isolate, nanoseconds);
     }
     return Just(NanosecondsToDaysResult(
-        {BigInt::ToNumber(isolate, days_bigint)->Number(),
-         BigInt::ToNumber(isolate, nanoseconds)->Number(), kDayLengthNs}));
+        {Object::Number(*BigInt::ToNumber(isolate, days_bigint)),
+         Object::Number(*BigInt::ToNumber(isolate, nanoseconds)),
+         kDayLengthNs}));
   }
   Handle<JSTemporalZonedDateTime> relative_to =
       Handle<JSTemporalZonedDateTime>::cast(relative_to_obj);
@@ -5733,7 +5740,7 @@ Maybe<NanosecondsToDaysResult> NanosecondsToDays(Isolate* isolate,
   // 20. Return the new Record { [[Days]]: days, [[Nanoseconds]]: nanoseconds,
   // [[DayLength]]: abs(dayLengthNs) }.
   NanosecondsToDaysResult result(
-      {days, BigInt::ToNumber(isolate, nanoseconds)->Number(),
+      {days, Object::Number(*BigInt::ToNumber(isolate, nanoseconds)),
        std::abs(day_length_ns->AsInt64())});
   return Just(result);
 }
@@ -5816,7 +5823,7 @@ Maybe<DurationRecord> DifferenceISODateTime(
   // timeDifference.[[Microseconds]], timeDifference.[[Nanoseconds]],
   // largestUnit).
 
-  time_difference.days = date_difference->days().Number();
+  time_difference.days = Object::Number(date_difference->days());
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, time_difference,
       BalanceDuration(isolate, largest_unit, time_difference, method_name),
@@ -5828,11 +5835,12 @@ Maybe<DurationRecord> DifferenceISODateTime(
   // balanceResult.[[Seconds]], balanceResult.[[Milliseconds]],
   // balanceResult.[[Microseconds]], balanceResult.[[Nanoseconds]]).
 
-  return Just(CreateDurationRecord(
-                  isolate, {date_difference->years().Number(),
-                            date_difference->months().Number(),
-                            date_difference->weeks().Number(), time_difference})
-                  .ToChecked());
+  return Just(
+      CreateDurationRecord(
+          isolate, {Object::Number(date_difference->years()),
+                    Object::Number(date_difference->months()),
+                    Object::Number(date_difference->weeks()), time_difference})
+          .ToChecked());
 }
 
 // #sec-temporal-addinstant
@@ -6427,13 +6435,13 @@ Maybe<DateRecord> ISOMonthDayFromFields(Isolate* isolate,
   // ToIntegerThrowOnInfinity inside the PrepareTemporalFields above.
   // Therefore the day_obj is always an integer.
   DCHECK(IsSmi(*day_obj) || IsHeapNumber(*day_obj));
-  result.day = FastD2I(floor(day_obj->Number()));
+  result.day = FastD2I(floor(Object::Number(*day_obj)));
   // 11. Let referenceISOYear be 1972 (the first leap year after the Unix
   // epoch).
   int32_t reference_iso_year = 1972;
   // 12. If monthCode is undefined, then
   if (IsUndefined(*month_code_obj, isolate)) {
-    result.year = FastD2I(floor(year_obj->Number()));
+    result.year = FastD2I(floor(Object::Number(*year_obj)));
     // a. Let result be ? RegulateISODate(year, month, day, overflow).
   } else {
     // 13. Else,
@@ -6861,7 +6869,7 @@ Maybe<DateDurationRecord> UnbalanceDurationRelative(
                             until_options, date_until),
           Nothing<DateDurationRecord>());
       // v. Let oneYearMonths be untilResult.[[Months]].
-      double one_year_months = until_result->months().Number();
+      double one_year_months = Object::Number(until_result->months());
       // vi. Set relativeTo to newRelativeTo.
       relative_to = new_relative_to;
       // vii. Set years to years  sign.
@@ -7137,7 +7145,7 @@ Maybe<DateDurationRecord> BalanceDurationRelative(
                           until_options, date_until),
         Nothing<DateDurationRecord>());
     // o. Let oneYearMonths be untilResult.[[Months]].
-    double one_year_months = until_result->months().Number();
+    double one_year_months = Object::Number(until_result->months());
     // p. Repeat, while abs(months)  abs(oneYearMonths),
     while (std::abs(result.months) >= std::abs(one_year_months)) {
       // i. Set months to months - oneYearMonths.
@@ -7169,7 +7177,7 @@ Maybe<DateDurationRecord> BalanceDurationRelative(
                             until_options, date_until),
           Nothing<DateDurationRecord>());
       // viii. Set oneYearMonths to untilResult.[[Months]].
-      one_year_months = until_result->months().Number();
+      one_year_months = Object::Number(until_result->months());
     }
     // 11. Else if largestUnit is "month", then
   } else if (largest_unit == Unit::kMonth) {
@@ -7277,27 +7285,30 @@ MaybeHandle<Smi> JSTemporalDuration::Compare(Isolate* isolate,
   int64_t shift1;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, shift1,
-      CalculateOffsetShift(isolate, relative_to,
-                           {one->years().Number(), one->months().Number(),
-                            one->weeks().Number(), one->days().Number()},
-                           method_name),
+      CalculateOffsetShift(
+          isolate, relative_to,
+          {Object::Number(one->years()), Object::Number(one->months()),
+           Object::Number(one->weeks()), Object::Number(one->days())},
+          method_name),
       Handle<Smi>());
   // 6. Let shift2 be ? CalculateOffsetShift(relativeTo, two.[[Years]],
   // two.[[Months]], two.[[Weeks]], two.[[Days]]).
   int64_t shift2;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, shift2,
-      CalculateOffsetShift(isolate, relative_to,
-                           {two->years().Number(), two->months().Number(),
-                            two->weeks().Number(), two->days().Number()},
-                           method_name),
+      CalculateOffsetShift(
+          isolate, relative_to,
+          {Object::Number(two->years()), Object::Number(two->months()),
+           Object::Number(two->weeks()), Object::Number(two->days())},
+          method_name),
       Handle<Smi>());
   // 7. If any of one.[[Years]], two.[[Years]], one.[[Months]], two.[[Months]],
   // one.[[Weeks]], or two.[[Weeks]] are not 0, then
   double days1, days2;
-  if (one->years().Number() != 0 || two->years().Number() != 0 ||
-      one->months().Number() != 0 || two->months().Number() != 0 ||
-      one->weeks().Number() != 0 || two->weeks().Number() != 0) {
+  if (Object::Number(one->years()) != 0 || Object::Number(two->years()) != 0 ||
+      Object::Number(one->months()) != 0 ||
+      Object::Number(two->months()) != 0 || Object::Number(one->weeks()) != 0 ||
+      Object::Number(two->weeks()) != 0) {
     // a. Let unbalanceResult1 be ? UnbalanceDurationRelative(one.[[Years]],
     // one.[[Months]], one.[[Weeks]], one.[[Days]], "day", relativeTo).
     DateDurationRecord unbalance_result1;
@@ -7305,8 +7316,8 @@ MaybeHandle<Smi> JSTemporalDuration::Compare(Isolate* isolate,
         isolate, unbalance_result1,
         UnbalanceDurationRelative(
             isolate,
-            {one->years().Number(), one->months().Number(),
-             one->weeks().Number(), one->days().Number()},
+            {Object::Number(one->years()), Object::Number(one->months()),
+             Object::Number(one->weeks()), Object::Number(one->days())},
             Unit::kDay, relative_to, method_name),
         Handle<Smi>());
     // b. Let unbalanceResult2 be ? UnbalanceDurationRelative(two.[[Years]],
@@ -7316,8 +7327,8 @@ MaybeHandle<Smi> JSTemporalDuration::Compare(Isolate* isolate,
         isolate, unbalance_result2,
         UnbalanceDurationRelative(
             isolate,
-            {two->years().Number(), two->months().Number(),
-             two->weeks().Number(), two->days().Number()},
+            {Object::Number(two->years()), Object::Number(two->months()),
+             Object::Number(two->weeks()), Object::Number(two->days())},
             Unit::kDay, relative_to, method_name),
         Handle<Smi>());
     // c. Let days1 be unbalanceResult1.[[Days]].
@@ -7327,27 +7338,27 @@ MaybeHandle<Smi> JSTemporalDuration::Compare(Isolate* isolate,
     // 8. Else,
   } else {
     // a. Let days1 be one.[[Days]].
-    days1 = one->days().Number();
+    days1 = Object::Number(one->days());
     // b. Let days2 be two.[[Days]].
-    days2 = two->days().Number();
+    days2 = Object::Number(two->days());
   }
   // 9. Let ns1 be ! TotalDurationNanoseconds(days1, one.[[Hours]],
   // one.[[Minutes]], one.[[Seconds]], one.[[Milliseconds]],
   // one.[[Microseconds]], one.[[Nanoseconds]], shift1).
   Handle<BigInt> ns1 = TotalDurationNanoseconds(
       isolate,
-      {days1, one->hours().Number(), one->minutes().Number(),
-       one->seconds().Number(), one->milliseconds().Number(),
-       one->microseconds().Number(), one->nanoseconds().Number()},
+      {days1, Object::Number(one->hours()), Object::Number(one->minutes()),
+       Object::Number(one->seconds()), Object::Number(one->milliseconds()),
+       Object::Number(one->microseconds()), Object::Number(one->nanoseconds())},
       shift1);
   // 10. Let ns2 be ! TotalDurationNanoseconds(days2, two.[[Hours]],
   // two.[[Minutes]], two.[[Seconds]], two.[[Milliseconds]],
   // two.[[Microseconds]], two.[[Nanoseconds]], shift2).
   Handle<BigInt> ns2 = TotalDurationNanoseconds(
       isolate,
-      {days2, two->hours().Number(), two->minutes().Number(),
-       two->seconds().Number(), two->milliseconds().Number(),
-       two->microseconds().Number(), two->nanoseconds().Number()},
+      {days2, Object::Number(two->hours()), Object::Number(two->minutes()),
+       Object::Number(two->seconds()), Object::Number(two->milliseconds()),
+       Object::Number(two->microseconds()), Object::Number(two->nanoseconds())},
       shift2);
   switch (BigInt::CompareToBigInt(ns1, ns2)) {
     // 11. If ns1 > ns2, return 1.
@@ -7376,13 +7387,15 @@ MaybeHandle<JSTemporalDuration> JSTemporalDuration::From(Isolate* isolate,
         Handle<JSTemporalDuration>::cast(item);
     return CreateTemporalDuration(
         isolate,
-        {duration->years().Number(),
-         duration->months().Number(),
-         duration->weeks().Number(),
-         {duration->days().Number(), duration->hours().Number(),
-          duration->minutes().Number(), duration->seconds().Number(),
-          duration->milliseconds().Number(), duration->microseconds().Number(),
-          duration->nanoseconds().Number()}});
+        {Object::Number(duration->years()),
+         Object::Number(duration->months()),
+         Object::Number(duration->weeks()),
+         {Object::Number(duration->days()), Object::Number(duration->hours()),
+          Object::Number(duration->minutes()),
+          Object::Number(duration->seconds()),
+          Object::Number(duration->milliseconds()),
+          Object::Number(duration->microseconds()),
+          Object::Number(duration->nanoseconds())}});
   }
   // 2. Return ? ToTemporalDuration(item).
   return temporal::ToTemporalDuration(isolate, item, "Temporal.Duration.from");
@@ -7475,13 +7488,15 @@ MaybeHandle<JSTemporalDuration> JSTemporalDuration::Round(
   // duration.[[Minutes]], duration.[[Seconds]], duration.[[Milliseconds]],
   // duration.[[Microseconds]]).
   Unit default_largest_unit = DefaultTemporalLargestUnit(
-      {duration->years().Number(),
-       duration->months().Number(),
-       duration->weeks().Number(),
-       {duration->days().Number(), duration->hours().Number(),
-        duration->minutes().Number(), duration->seconds().Number(),
-        duration->milliseconds().Number(), duration->microseconds().Number(),
-        duration->nanoseconds().Number()}});
+      {Object::Number(duration->years()),
+       Object::Number(duration->months()),
+       Object::Number(duration->weeks()),
+       {Object::Number(duration->days()), Object::Number(duration->hours()),
+        Object::Number(duration->minutes()),
+        Object::Number(duration->seconds()),
+        Object::Number(duration->milliseconds()),
+        Object::Number(duration->microseconds()),
+        Object::Number(duration->nanoseconds())}});
 
   // 11. Set defaultLargestUnit to !
   // LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit).
@@ -7551,8 +7566,9 @@ MaybeHandle<JSTemporalDuration> JSTemporalDuration::Round(
       isolate, unbalance_result,
       UnbalanceDurationRelative(
           isolate,
-          {duration->years().Number(), duration->months().Number(),
-           duration->weeks().Number(), duration->days().Number()},
+          {Object::Number(duration->years()),
+           Object::Number(duration->months()),
+           Object::Number(duration->weeks()), Object::Number(duration->days())},
           largest_unit, relative_to, method_name),
       Handle<JSTemporalDuration>());
   // 22. Let roundResult be (? RoundDuration(unbalanceResult.[[Years]],
@@ -7564,18 +7580,18 @@ MaybeHandle<JSTemporalDuration> JSTemporalDuration::Round(
   DurationRecordWithRemainder round_result;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, round_result,
-      RoundDuration(
-          isolate,
-          {unbalance_result.years,
-           unbalance_result.months,
-           unbalance_result.weeks,
-           {unbalance_result.days, duration->hours().Number(),
-            duration->minutes().Number(), duration->seconds().Number(),
-            duration->milliseconds().Number(),
-            duration->microseconds().Number(),
-            duration->nanoseconds().Number()}},
-          rounding_increment, smallest_unit, rounding_mode, relative_to,
-          method_name),
+      RoundDuration(isolate,
+                    {unbalance_result.years,
+                     unbalance_result.months,
+                     unbalance_result.weeks,
+                     {unbalance_result.days, Object::Number(duration->hours()),
+                      Object::Number(duration->minutes()),
+                      Object::Number(duration->seconds()),
+                      Object::Number(duration->milliseconds()),
+                      Object::Number(duration->microseconds()),
+                      Object::Number(duration->nanoseconds())}},
+                    rounding_increment, smallest_unit, rounding_mode,
+                    relative_to, method_name),
       Handle<JSTemporalDuration>());
 
   // 23. Let adjustResult be ? AdjustRoundedDurationDays(roundResult.[[Years]],
@@ -7697,8 +7713,9 @@ MaybeHandle<Object> JSTemporalDuration::Total(
       isolate, unbalance_result,
       UnbalanceDurationRelative(
           isolate,
-          {duration->years().Number(), duration->months().Number(),
-           duration->weeks().Number(), duration->days().Number()},
+          {Object::Number(duration->years()),
+           Object::Number(duration->months()),
+           Object::Number(duration->weeks()), Object::Number(duration->days())},
           unit, relative_to, method_name),
       Handle<Object>());
 
@@ -7731,10 +7748,12 @@ MaybeHandle<Object> JSTemporalDuration::Total(
       isolate, balance_result,
       BalancePossiblyInfiniteDuration(
           isolate, unit, intermediate,
-          {unbalance_result.days, duration->hours().Number(),
-           duration->minutes().Number(), duration->seconds().Number(),
-           duration->milliseconds().Number(), duration->microseconds().Number(),
-           duration->nanoseconds().Number()},
+          {unbalance_result.days, Object::Number(duration->hours()),
+           Object::Number(duration->minutes()),
+           Object::Number(duration->seconds()),
+           Object::Number(duration->milliseconds()),
+           Object::Number(duration->microseconds()),
+           Object::Number(duration->nanoseconds())},
           method_name),
       Handle<Object>());
   // 12. If balanceResult is positive overflow, return +.
@@ -7898,14 +7917,15 @@ MaybeHandle<JSTemporalDuration> JSTemporalDuration::With(
       isolate, partial,
       temporal::ToPartialDuration(
           isolate, temporal_duration_like,
-          {duration->years().Number(),
-           duration->months().Number(),
-           duration->weeks().Number(),
-           {duration->days().Number(), duration->hours().Number(),
-            duration->minutes().Number(), duration->seconds().Number(),
-            duration->milliseconds().Number(),
-            duration->microseconds().Number(),
-            duration->nanoseconds().Number()}}),
+          {Object::Number(duration->years()),
+           Object::Number(duration->months()),
+           Object::Number(duration->weeks()),
+           {Object::Number(duration->days()), Object::Number(duration->hours()),
+            Object::Number(duration->minutes()),
+            Object::Number(duration->seconds()),
+            Object::Number(duration->milliseconds()),
+            Object::Number(duration->microseconds()),
+            Object::Number(duration->nanoseconds())}}),
       Handle<JSTemporalDuration>());
 
   // 24. Return ? CreateTemporalDuration(years, months, weeks, days, hours,
@@ -7923,17 +7943,18 @@ MaybeHandle<Smi> JSTemporalDuration::Sign(Isolate* isolate,
   // duration.[[Weeks]], duration.[[Days]], duration.[[Hours]],
   // duration.[[Minutes]], duration.[[Seconds]], duration.[[Milliseconds]],
   // duration.[[Microseconds]], duration.[[Nanoseconds]]).
-  return handle(
-      Smi::FromInt(DurationSign(
-          isolate, {duration->years().Number(),
-                    duration->months().Number(),
-                    duration->weeks().Number(),
-                    {duration->days().Number(), duration->hours().Number(),
-                     duration->minutes().Number(), duration->seconds().Number(),
-                     duration->milliseconds().Number(),
-                     duration->microseconds().Number(),
-                     duration->nanoseconds().Number()}})),
-      isolate);
+  return handle(Smi::FromInt(DurationSign(
+                    isolate, {Object::Number(duration->years()),
+                              Object::Number(duration->months()),
+                              Object::Number(duration->weeks()),
+                              {Object::Number(duration->days()),
+                               Object::Number(duration->hours()),
+                               Object::Number(duration->minutes()),
+                               Object::Number(duration->seconds()),
+                               Object::Number(duration->milliseconds()),
+                               Object::Number(duration->microseconds()),
+                               Object::Number(duration->nanoseconds())}})),
+                isolate);
 }
 
 // #sec-get-temporal.duration.prototype.blank
@@ -7950,13 +7971,15 @@ MaybeHandle<Oddball> JSTemporalDuration::Blank(
   // 5. Return false.
   int32_t sign = DurationSign(
       isolate,
-      {duration->years().Number(),
-       duration->months().Number(),
-       duration->weeks().Number(),
-       {duration->days().Number(), duration->hours().Number(),
-        duration->minutes().Number(), duration->seconds().Number(),
-        duration->milliseconds().Number(), duration->microseconds().Number(),
-        duration->nanoseconds().Number()}});
+      {Object::Number(duration->years()),
+       Object::Number(duration->months()),
+       Object::Number(duration->weeks()),
+       {Object::Number(duration->days()), Object::Number(duration->hours()),
+        Object::Number(duration->minutes()),
+        Object::Number(duration->seconds()),
+        Object::Number(duration->milliseconds()),
+        Object::Number(duration->microseconds()),
+        Object::Number(duration->nanoseconds())}});
   return isolate->factory()->ToBoolean(sign == 0);
 }
 
@@ -7988,16 +8011,17 @@ MaybeHandle<JSTemporalDuration> CreateNegatedTemporalDuration(
   // duration.[[Hours]], duration.[[Minutes]], duration.[[Seconds]],
   // duration.[[Milliseconds]], duration.[[Microseconds]],
   // duration.[[Nanoseconds]]).
-  return CreateTemporalDuration(
-             isolate,
-             {-duration->years().Number(),
-              -duration->months().Number(),
-              -duration->weeks().Number(),
-              {-duration->days().Number(), -duration->hours().Number(),
-               -duration->minutes().Number(), -duration->seconds().Number(),
-               -duration->milliseconds().Number(),
-               -duration->microseconds().Number(),
-               -duration->nanoseconds().Number()}})
+  return CreateTemporalDuration(isolate,
+                                {-Object::Number(duration->years()),
+                                 -Object::Number(duration->months()),
+                                 -Object::Number(duration->weeks()),
+                                 {-Object::Number(duration->days()),
+                                  -Object::Number(duration->hours()),
+                                  -Object::Number(duration->minutes()),
+                                  -Object::Number(duration->seconds()),
+                                  -Object::Number(duration->milliseconds()),
+                                  -Object::Number(duration->microseconds()),
+                                  -Object::Number(duration->nanoseconds())}})
       .ToHandleChecked();
 }
 
@@ -8025,17 +8049,17 @@ MaybeHandle<JSTemporalDuration> JSTemporalDuration::Abs(
   // abs(duration.[[Hours]]), abs(duration.[[Minutes]]),
   // abs(duration.[[Seconds]]), abs(duration.[[Milliseconds]]),
   // abs(duration.[[Microseconds]]), abs(duration.[[Nanoseconds]])).
-  return CreateTemporalDuration(isolate,
-                                {std::abs(duration->years().Number()),
-                                 std::abs(duration->months().Number()),
-                                 std::abs(duration->weeks().Number()),
-                                 {std::abs(duration->days().Number()),
-                                  std::abs(duration->hours().Number()),
-                                  std::abs(duration->minutes().Number()),
-                                  std::abs(duration->seconds().Number()),
-                                  std::abs(duration->milliseconds().Number()),
-                                  std::abs(duration->microseconds().Number()),
-                                  std::abs(duration->nanoseconds().Number())}});
+  return CreateTemporalDuration(
+      isolate, {std::abs(Object::Number(duration->years())),
+                std::abs(Object::Number(duration->months())),
+                std::abs(Object::Number(duration->weeks())),
+                {std::abs(Object::Number(duration->days())),
+                 std::abs(Object::Number(duration->hours())),
+                 std::abs(Object::Number(duration->minutes())),
+                 std::abs(Object::Number(duration->seconds())),
+                 std::abs(Object::Number(duration->milliseconds())),
+                 std::abs(Object::Number(duration->microseconds())),
+                 std::abs(Object::Number(duration->nanoseconds()))}});
 }
 
 namespace {
@@ -8533,7 +8557,7 @@ Maybe<DurationRecord> AddDuration(Isolate* isolate, const DurationRecord& dur1,
     // Note: We call a special version of BalanceDuration which add two duration
     // internally to avoid overflow the double.
     TimeDurationRecord time_dur1 = dur1.time_duration;
-    time_dur1.days = date_difference->days().Number();
+    time_dur1.days = Object::Number(date_difference->days());
     TimeDurationRecord time_dur2 = dur2.time_duration;
     time_dur2.days = 0;
     MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
@@ -8546,12 +8570,12 @@ Maybe<DurationRecord> AddDuration(Isolate* isolate, const DurationRecord& dur1,
     // result.[[Hours]], result.[[Minutes]], result.[[Seconds]],
     // result.[[Milliseconds]], result.[[Microseconds]],
     // result.[[Nanoseconds]]).
-    return Just(
-        CreateDurationRecord(
-            isolate, {date_difference->years().Number(),
-                      date_difference->months().Number(),
-                      date_difference->weeks().Number(), result.time_duration})
-            .ToChecked());
+    return Just(CreateDurationRecord(isolate,
+                                     {Object::Number(date_difference->years()),
+                                      Object::Number(date_difference->months()),
+                                      Object::Number(date_difference->weeks()),
+                                      result.time_duration})
+                    .ToChecked());
   }
   // 6. Assert: relativeTo has an [[InitializedTemporalZonedDateTime]]
   // internal slot.
@@ -8641,14 +8665,15 @@ MaybeHandle<JSTemporalDuration> AddDurationToOrSubtractDurationFromDuration(
       isolate, result,
       AddDuration(
           isolate,
-          {duration->years().Number(),
-           duration->months().Number(),
-           duration->weeks().Number(),
-           {duration->days().Number(), duration->hours().Number(),
-            duration->minutes().Number(), duration->seconds().Number(),
-            duration->milliseconds().Number(),
-            duration->microseconds().Number(),
-            duration->nanoseconds().Number()}},
+          {Object::Number(duration->years()),
+           Object::Number(duration->months()),
+           Object::Number(duration->weeks()),
+           {Object::Number(duration->days()), Object::Number(duration->hours()),
+            Object::Number(duration->minutes()),
+            Object::Number(duration->seconds()),
+            Object::Number(duration->milliseconds()),
+            Object::Number(duration->microseconds()),
+            Object::Number(duration->nanoseconds())}},
           {sign * other.years,
            sign * other.months,
            sign * other.weeks,
@@ -8700,13 +8725,14 @@ MaybeHandle<String> JSTemporalDuration::ToJSON(
   // duration.[[Milliseconds]], duration.[[Microseconds]],
   // duration.[[Nanoseconds]], "auto").
   DurationRecord dur = {
-      duration->years().Number(),
-      duration->months().Number(),
-      duration->weeks().Number(),
-      {duration->days().Number(), duration->hours().Number(),
-       duration->minutes().Number(), duration->seconds().Number(),
-       duration->milliseconds().Number(), duration->microseconds().Number(),
-       duration->nanoseconds().Number()}};
+      Object::Number(duration->years()),
+      Object::Number(duration->months()),
+      Object::Number(duration->weeks()),
+      {Object::Number(duration->days()), Object::Number(duration->hours()),
+       Object::Number(duration->minutes()), Object::Number(duration->seconds()),
+       Object::Number(duration->milliseconds()),
+       Object::Number(duration->microseconds()),
+       Object::Number(duration->nanoseconds())}};
   return TemporalDurationToString(isolate, dur, Precision::kAuto);
 }
 
@@ -8723,13 +8749,14 @@ MaybeHandle<String> JSTemporalDuration::ToLocaleString(
   // duration.[[Milliseconds]], duration.[[Microseconds]],
   // duration.[[Nanoseconds]], "auto").
   DurationRecord dur = {
-      duration->years().Number(),
-      duration->months().Number(),
-      duration->weeks().Number(),
-      {duration->days().Number(), duration->hours().Number(),
-       duration->minutes().Number(), duration->seconds().Number(),
-       duration->milliseconds().Number(), duration->microseconds().Number(),
-       duration->nanoseconds().Number()}};
+      Object::Number(duration->years()),
+      Object::Number(duration->months()),
+      Object::Number(duration->weeks()),
+      {Object::Number(duration->days()), Object::Number(duration->hours()),
+       Object::Number(duration->minutes()), Object::Number(duration->seconds()),
+       Object::Number(duration->milliseconds()),
+       Object::Number(duration->microseconds()),
+       Object::Number(duration->nanoseconds())}};
 
   // TODO(ftang) Implement #sup-temporal.duration.prototype.tolocalestring
   return TemporalDurationToString(isolate, dur, Precision::kAuto);
@@ -9010,7 +9037,7 @@ Maybe<DurationRecordWithRemainder> RoundDuration(Isolate* isolate,
           Nothing<DurationRecordWithRemainder>());
 
       // n. Let yearsPassed be timePassed.[[Years]].
-      double years_passed = time_passed->years().Number();
+      double years_passed = Object::Number(time_passed->years());
 
       // o. Set years to years + yearsPassed.
       result.record.years += years_passed;
@@ -9454,13 +9481,14 @@ MaybeHandle<String> JSTemporalDuration::ToString(
   // duration.[[Microseconds]], duration.[[Nanoseconds]],
   // precision.[[Increment]], precision.[[Unit]], roundingMode).
   DurationRecord dur = {
-      duration->years().Number(),
-      duration->months().Number(),
-      duration->weeks().Number(),
-      {duration->days().Number(), duration->hours().Number(),
-       duration->minutes().Number(), duration->seconds().Number(),
-       duration->milliseconds().Number(), duration->microseconds().Number(),
-       duration->nanoseconds().Number()}};
+      Object::Number(duration->years()),
+      Object::Number(duration->months()),
+      Object::Number(duration->weeks()),
+      {Object::Number(duration->days()), Object::Number(duration->hours()),
+       Object::Number(duration->minutes()), Object::Number(duration->seconds()),
+       Object::Number(duration->milliseconds()),
+       Object::Number(duration->microseconds()),
+       Object::Number(duration->nanoseconds())}};
   DurationRecordWithRemainder result;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
       isolate, result,
@@ -9642,7 +9670,7 @@ Maybe<int32_t> ResolveISOMonth(Isolate* isolate, Handle<JSReceiver> fields) {
     // ToPositiveInteger inside PrepareTemporalFields before calling
     // ResolveISOMonth. Therefore the month_obj is always a positive integer.
     DCHECK(IsSmi(*month_obj) || IsHeapNumber(*month_obj));
-    return Just(FastD2I(month_obj->Number()));
+    return Just(FastD2I(Object::Number(*month_obj)));
   }
   // 4. Assert: Type(monthCode) is String.
   DCHECK(IsString(*month_code_obj));
@@ -9681,7 +9709,8 @@ Maybe<int32_t> ResolveISOMonth(Isolate* isolate, Handle<JSReceiver> fields) {
   // Note: In Temporal spec, "month" in fields is always converted by
   // ToPositiveInteger inside PrepareTemporalFields before calling
   // ResolveISOMonth. Therefore the month_obj is always a positive integer.
-  if (!IsUndefined(*month_obj) && FastD2I(month_obj->Number()) != number_part) {
+  if (!IsUndefined(*month_obj) &&
+      FastD2I(Object::Number(*month_obj)) != number_part) {
     // a. Throw a RangeError exception.
     THROW_NEW_ERROR_RETURN_VALUE(
         isolate,
@@ -9740,9 +9769,9 @@ Maybe<DateRecord> ISODateFromFields(Isolate* isolate, Handle<JSReceiver> fields,
   // Therefore the day_obj is always an integer.
   DCHECK(IsSmi(*day_obj) || IsHeapNumber(*day_obj));
   // 9. Return ? RegulateISODate(year, month, day, overflow).
-  return RegulateISODate(
-      isolate, overflow,
-      {FastD2I(year_obj->Number()), month, FastD2I(day_obj->Number())});
+  return RegulateISODate(isolate, overflow,
+                         {FastD2I(Object::Number(*year_obj)), month,
+                          FastD2I(Object::Number(*day_obj))});
 }
 
 // #sec-temporal-addisodate
@@ -9999,7 +10028,7 @@ Maybe<DateRecord> ISOYearMonthFromFields(Isolate* isolate,
                                  Nothing<DateRecord>());
   }
   DateRecord result;
-  result.year = FastD2I(floor(year_obj->Number()));
+  result.year = FastD2I(floor(Object::Number(*year_obj)));
   // 6. Let month be ? ResolveISOMonth(fields).
   int32_t month;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
@@ -10122,10 +10151,12 @@ MaybeHandle<JSTemporalPlainDate> JSTemporalCalendar::DateAdd(
       isolate, balance_result,
       BalanceDuration(
           isolate, Unit::kDay,
-          {duration->days().Number(), duration->hours().Number(),
-           duration->minutes().Number(), duration->seconds().Number(),
-           duration->milliseconds().Number(), duration->microseconds().Number(),
-           duration->nanoseconds().Number()},
+          {Object::Number(duration->days()), Object::Number(duration->hours()),
+           Object::Number(duration->minutes()),
+           Object::Number(duration->seconds()),
+           Object::Number(duration->milliseconds()),
+           Object::Number(duration->microseconds()),
+           Object::Number(duration->nanoseconds())},
           method_name),
       Handle<JSTemporalPlainDate>());
 
@@ -10139,8 +10170,9 @@ MaybeHandle<JSTemporalPlainDate> JSTemporalCalendar::DateAdd(
         isolate, result,
         AddISODate(isolate,
                    {date->iso_year(), date->iso_month(), date->iso_day()},
-                   {duration->years().Number(), duration->months().Number(),
-                    duration->weeks().Number(), balance_result.days},
+                   {Object::Number(duration->years()),
+                    Object::Number(duration->months()),
+                    Object::Number(duration->weeks()), balance_result.days},
                    overflow),
         Handle<JSTemporalPlainDate>());
   } else {
@@ -11881,10 +11913,10 @@ MaybeHandle<JSTemporalDuration> DifferenceTemporalPlainDate(
     MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
         isolate, round_result,
         RoundDuration(isolate,
-                      {result->years().Number(),
-                       result->months().Number(),
-                       result->weeks().Number(),
-                       {result->days().Number(), 0, 0, 0, 0, 0, 0}},
+                      {Object::Number(result->years()),
+                       Object::Number(result->months()),
+                       Object::Number(result->weeks()),
+                       {Object::Number(result->days()), 0, 0, 0, 0, 0, 0}},
                       settings.rounding_increment, settings.smallest_unit,
                       settings.rounding_mode, temporal_date, method_name),
         Handle<JSTemporalDuration>());
@@ -11908,10 +11940,11 @@ MaybeHandle<JSTemporalDuration> DifferenceTemporalPlainDate(
   // result.[[Months]], sign  result.[[Weeks]], sign  result.[[Days]], 0, 0,
   // 0, 0, 0, 0).
   return CreateTemporalDuration(
-             isolate, {sign * result->years().Number(),
-                       sign * result->months().Number(),
-                       sign * result->weeks().Number(),
-                       {sign * result->days().Number(), 0, 0, 0, 0, 0, 0}})
+             isolate,
+             {sign * Object::Number(result->years()),
+              sign * Object::Number(result->months()),
+              sign * Object::Number(result->weeks()),
+              {sign * Object::Number(result->days()), 0, 0, 0, 0, 0, 0}})
       .ToHandleChecked();
 }
 
@@ -14379,8 +14412,8 @@ MaybeHandle<JSTemporalDuration> DifferenceTemporalPlainYearMonth(
     MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
         isolate, round_result,
         RoundDuration(isolate,
-                      {result->years().Number(),
-                       result->months().Number(),
+                      {Object::Number(result->years()),
+                       Object::Number(result->months()),
                        0,
                        {0, 0, 0, 0, 0, 0, 0}},
                       settings.rounding_increment, settings.smallest_unit,
@@ -14396,10 +14429,11 @@ MaybeHandle<JSTemporalDuration> DifferenceTemporalPlainYearMonth(
   }
   // 16. Return ! CreateTemporalDuration(sign  result.[[Years]], sign 
   // result.[[Months]], 0, 0, 0, 0, 0, 0, 0, 0).
-  return CreateTemporalDuration(isolate, {result->years().Number() * sign,
-                                          result->months().Number() * sign,
-                                          0,
-                                          {0, 0, 0, 0, 0, 0, 0}})
+  return CreateTemporalDuration(isolate,
+                                {Object::Number(result->years()) * sign,
+                                 Object::Number(result->months()) * sign,
+                                 0,
+                                 {0, 0, 0, 0, 0, 0, 0}})
       .ToHandleChecked();
 }
 
@@ -15632,7 +15666,7 @@ Maybe<StringPrecision> ToSecondsStringPrecision(
   // 11. If fractionalDigitsVal is NaN, +, or -, throw a RangeError
   // exception.
   if (IsNaN(*fractional_digits_val) ||
-      std::isinf(fractional_digits_val->Number())) {
+      std::isinf(Object::Number(*fractional_digits_val))) {
     THROW_NEW_ERROR_RETURN_VALUE(
         isolate,
         NewRangeError(MessageTemplate::kPropertyValueOutOfRange,
@@ -15641,7 +15675,7 @@ Maybe<StringPrecision> ToSecondsStringPrecision(
   }
   // 12. Let fractionalDigitCount be RoundTowardsZero((fractionalDigitsVal)).
   int64_t fractional_digit_count =
-      RoundTowardsZero(fractional_digits_val->Number());
+      RoundTowardsZero(Object::Number(*fractional_digits_val));
   // 13. If fractionalDigitCount < 0 or fractionalDigitCount > 9, throw a
   // RangeError exception.
   if (fractional_digit_count < 0 || fractional_digit_count > 9) {
@@ -17147,7 +17181,7 @@ MaybeHandle<JSTemporalZonedDateTime> JSTemporalZonedDateTime::Round(
         temporal_date_time->iso_microsecond(),
         temporal_date_time->iso_nanosecond()}},
       rounding_increment, smallest_unit, rounding_mode,
-      BigInt::ToNumber(isolate, day_length_ns)->Number());
+      Object::Number(*BigInt::ToNumber(isolate, day_length_ns)));
   // 21. Let offsetNanoseconds be ? GetOffsetNanosecondsFor(timeZone, instant).
   int64_t offset_nanoseconds;
   MAYBE_ASSIGN_RETURN_ON_EXCEPTION_VALUE(
@@ -18554,16 +18588,12 @@ TimeDurationRecord DifferenceInstant(Isolate* isolate, Handle<BigInt> ns1,
   // RoundDuration.
   Handle<BigInt> nanoseconds_in_a_hour =
       BigInt::FromUint64(isolate, 3600000000000);
-  double diff_hours =
-      BigInt::ToNumber(isolate,
-                       BigInt::Divide(isolate, diff, nanoseconds_in_a_hour)
-                           .ToHandleChecked())
-          ->Number();
-  double diff_nanoseconds =
-      BigInt::ToNumber(isolate,
-                       BigInt::Remainder(isolate, diff, nanoseconds_in_a_hour)
-                           .ToHandleChecked())
-          ->Number();
+  double diff_hours = Object::Number(*BigInt::ToNumber(
+      isolate,
+      BigInt::Divide(isolate, diff, nanoseconds_in_a_hour).ToHandleChecked()));
+  double diff_nanoseconds = Object::Number(*BigInt::ToNumber(
+      isolate, BigInt::Remainder(isolate, diff, nanoseconds_in_a_hour)
+                   .ToHandleChecked()));
   DurationRecordWithRemainder round_record =
       RoundDuration(
           isolate, {0, 0, 0, {0, diff_hours, 0, 0, 0, 0, diff_nanoseconds}},
diff --git a/src/objects/js-weak-refs-inl.h b/src/objects/js-weak-refs-inl.h
index 4819f988de4..6b6ef7618fd 100644
--- a/src/objects/js-weak-refs-inl.h
+++ b/src/objects/js-weak-refs-inl.h
@@ -40,7 +40,8 @@ void JSFinalizationRegistry::RegisterWeakCellWithUnregisterToken(
   // Unregister tokens are held weakly as objects are often their own
   // unregister token. To avoid using an ephemeron map, the map for token
   // lookup is keyed on the token's identity hash instead of the token itself.
-  uint32_t key = weak_cell->unregister_token().GetOrCreateHash(isolate).value();
+  uint32_t key =
+      Object::GetOrCreateHash(weak_cell->unregister_token(), isolate).value();
   InternalIndex entry = key_map->FindEntry(isolate, key);
   if (entry.is_found()) {
     Object value = key_map->ValueAt(entry);
@@ -80,7 +81,7 @@ bool JSFinalizationRegistry::RemoveUnregisterToken(
       SimpleNumberDictionary::cast(this->key_map());
   // If the token doesn't have a hash, it was not used as a key inside any hash
   // tables.
-  Object hash = unregister_token.GetHash();
+  Object hash = Object::GetHash(unregister_token);
   if (IsUndefined(hash, isolate)) {
     return false;
   }
@@ -170,7 +171,7 @@ void WeakCell::Nullify(Isolate* isolate,
   // only called for WeakCells which haven't been unregistered yet, so they will
   // be in the active_cells list. (The caller must guard against calling this
   // for unregistered WeakCells by checking that the target is not undefined.)
-  DCHECK(target().CanBeHeldWeakly());
+  DCHECK(Object::CanBeHeldWeakly(target()));
   set_target(ReadOnlyRoots(isolate).undefined_value());
 
   JSFinalizationRegistry fr =
@@ -216,7 +217,7 @@ void WeakCell::RemoveFromFinalizationRegistryCells(Isolate* isolate) {
 
   // It's important to set_target to undefined here. This guards that we won't
   // call Nullify (which assumes that the WeakCell is in active_cells).
-  DCHECK(IsUndefined(target()) || target().CanBeHeldWeakly());
+  DCHECK(IsUndefined(target()) || Object::CanBeHeldWeakly(target()));
   set_target(ReadOnlyRoots(isolate).undefined_value());
 
   JSFinalizationRegistry fr =
diff --git a/src/objects/keys.cc b/src/objects/keys.cc
index 18edf1c0bd8..0cbf17e93fc 100644
--- a/src/objects/keys.cc
+++ b/src/objects/keys.cc
@@ -195,7 +195,7 @@ MaybeHandle<FixedArray> FilterProxyKeys(KeyAccumulator* accumulator,
   int store_position = 0;
   for (int i = 0; i < keys->length(); ++i) {
     Handle<Name> key(Name::cast(keys->get(i)), isolate);
-    if (key->FilterKey(filter)) continue;  // Skip this key.
+    if (Object::FilterKey(*key, filter)) continue;  // Skip this key.
     if (skip_indices) {
       uint32_t index;
       if (key->AsArrayIndex(&index)) continue;  // Skip this key.
@@ -704,7 +704,7 @@ KeyAccumulator::FilterForEnumerableProperties(
     Handle<Object> attributes;
     if (type == kIndexed) {
       uint32_t number;
-      CHECK(element->ToUint32(&number));
+      CHECK(Object::ToUint32(*element, &number));
       attributes = args.CallIndexedQuery(interceptor, number);
     } else {
       CHECK(IsName(*element));
@@ -714,7 +714,7 @@ KeyAccumulator::FilterForEnumerableProperties(
 
     if (!attributes.is_null()) {
       int32_t value;
-      CHECK(attributes->ToInt32(&value));
+      CHECK(Object::ToInt32(*attributes, &value));
       if ((value & DONT_ENUM) == 0) {
         RETURN_FAILURE_IF_NOT_SUCCESSFUL(AddKey(element, DO_NOT_CONVERT));
       }
@@ -820,7 +820,7 @@ base::Optional<int> CollectOwnPropertyNamesInternal(
       if (first_skipped == -1) first_skipped = i.as_int();
       continue;
     }
-    if (key.FilterKey(keys->filter())) continue;
+    if (Object::FilterKey(key, keys->filter())) continue;
 
     if (is_shadowing_key) {
       // This might allocate, but {key} is not used afterwards.
@@ -958,7 +958,7 @@ ExceptionStatus CollectKeysFromDictionary(Handle<Dictionary> dictionary,
       Object key;
       Dictionary raw_dictionary = *dictionary;
       if (!raw_dictionary.ToKey(roots, i, &key)) continue;
-      if (key.FilterKey(filter)) continue;
+      if (Object::FilterKey(key, filter)) continue;
       PropertyDetails details = raw_dictionary.DetailsAt(i);
       if ((int{details.attributes()} & filter) != 0) {
         AllowGarbageCollection gc;
diff --git a/src/objects/lookup-inl.h b/src/objects/lookup-inl.h
index 17514de8bb6..184bc5a90a0 100644
--- a/src/objects/lookup-inl.h
+++ b/src/objects/lookup-inl.h
@@ -180,7 +180,7 @@ PropertyKey::PropertyKey(Isolate* isolate, Handle<Name> name) {
 
 PropertyKey::PropertyKey(Isolate* isolate, Handle<Object> valid_key) {
   DCHECK(IsName(*valid_key) || IsNumber(*valid_key));
-  if (valid_key->ToIntegerIndex(&index_)) return;
+  if (Object::ToIntegerIndex(*valid_key, &index_)) return;
   if (IsNumber(*valid_key)) {
     // Negative or out of range -> treat as named property.
     valid_key = isolate->factory()->NumberToString(valid_key);
diff --git a/src/objects/lookup.cc b/src/objects/lookup.cc
index ba0432918cb..b19493225d6 100644
--- a/src/objects/lookup.cc
+++ b/src/objects/lookup.cc
@@ -26,7 +26,7 @@ namespace v8 {
 namespace internal {
 
 PropertyKey::PropertyKey(Isolate* isolate, Handle<Object> key, bool* success) {
-  if (key->ToIntegerIndex(&index_)) {
+  if (Object::ToIntegerIndex(*key, &index_)) {
     *success = true;
     return;
   }
@@ -151,8 +151,8 @@ MaybeHandle<JSReceiver> LookupIterator::GetRootForNonJSReceiver(
     return {};
   }
   Handle<HeapObject> root(
-      lookup_start_object->GetPrototypeChainRootMap(isolate)->prototype(
-          isolate),
+      Object::GetPrototypeChainRootMap(*lookup_start_object, isolate)
+          ->prototype(isolate),
       isolate);
   if (IsNull(*root, isolate)) {
     isolate->PushStackTraceAndDie(
@@ -354,7 +354,7 @@ void LookupIterator::PrepareForDataProperty(Handle<Object> value) {
   if (IsElement(*holder)) {
     Handle<JSObject> holder_obj = Handle<JSObject>::cast(holder);
     ElementsKind kind = holder_obj->GetElementsKind(isolate_);
-    ElementsKind to = value->OptimalElementsKind(isolate_);
+    ElementsKind to = Object::OptimalElementsKind(*value, isolate_);
     if (IsHoleyElementsKind(kind)) to = GetHoleyElementsKind(to);
     to = GetMoreGeneralElementsKind(kind, to);
 
diff --git a/src/objects/map-updater.cc b/src/objects/map-updater.cc
index af3f09cc7de..7660fab201a 100644
--- a/src/objects/map-updater.cc
+++ b/src/objects/map-updater.cc
@@ -157,7 +157,7 @@ Handle<FieldType> MapUpdater::GetOrComputeFieldType(
   if (location == PropertyLocation::kField) {
     return handle(GetFieldType(descriptor), isolate_);
   } else {
-    return GetValue(descriptor).OptimalType(isolate_, representation);
+    return Object::OptimalType(GetValue(descriptor), isolate_, representation);
   }
 }
 
@@ -169,8 +169,8 @@ Handle<FieldType> MapUpdater::GetOrComputeFieldType(
   if (location == PropertyLocation::kField) {
     return handle(descriptors->GetFieldType(descriptor), isolate_);
   } else {
-    return descriptors->GetStrongValue(descriptor)
-        .OptimalType(isolate_, representation);
+    return Object::OptimalType(descriptors->GetStrongValue(descriptor),
+                               isolate_, representation);
   }
 }
 
diff --git a/src/objects/map.cc b/src/objects/map.cc
index 1677d2f4b34..c71e426392c 100644
--- a/src/objects/map.cc
+++ b/src/objects/map.cc
@@ -489,8 +489,10 @@ MaybeHandle<Map> Map::CopyWithConstant(Isolate* isolate, Handle<Map> map,
     return MaybeHandle<Map>();
   }
 
-  Representation representation = constant->OptimalRepresentation(isolate);
-  Handle<FieldType> type = constant->OptimalType(isolate, representation);
+  Representation representation =
+      Object::OptimalRepresentation(*constant, isolate);
+  Handle<FieldType> type =
+      Object::OptimalType(*constant, isolate, representation);
   return CopyWithField(isolate, map, name, type, attributes,
                        PropertyConstness::kConst, representation, flag);
 }
@@ -1095,7 +1097,7 @@ int Map::NumberOfEnumerableProperties() const {
   DescriptorArray descs = instance_descriptors(kRelaxedLoad);
   for (InternalIndex i : IterateOwnDescriptors()) {
     if ((int{descs->GetDetails(i).attributes()} & ONLY_ENUMERABLE) == 0 &&
-        !descs->GetKey(i).FilterKey(ENUMERABLE_STRINGS)) {
+        !Object::FilterKey(descs->GetKey(i), ENUMERABLE_STRINGS)) {
       result++;
     }
   }
@@ -1784,7 +1786,7 @@ bool CanHoldValue(DescriptorArray descriptors, InternalIndex descriptor,
   if (details.location() == PropertyLocation::kField) {
     if (details.kind() == PropertyKind::kData) {
       return IsGeneralizableTo(constness, details.constness()) &&
-             value.FitsRepresentation(details.representation()) &&
+             Object::FitsRepresentation(value, details.representation()) &&
              descriptors->GetFieldType(descriptor).NowContains(value);
     } else {
       DCHECK_EQ(PropertyKind::kAccessor, details.kind());
@@ -1811,8 +1813,9 @@ Handle<Map> UpdateDescriptorForValue(Isolate* isolate, Handle<Map> map,
 
   PropertyAttributes attributes =
       map->instance_descriptors(isolate)->GetDetails(descriptor).attributes();
-  Representation representation = value->OptimalRepresentation(isolate);
-  Handle<FieldType> type = value->OptimalType(isolate, representation);
+  Representation representation =
+      Object::OptimalRepresentation(*value, isolate);
+  Handle<FieldType> type = Object::OptimalType(*value, isolate, representation);
 
   MapUpdater mu(isolate, map);
   return mu.ReconfigureToDataField(descriptor, attributes, constness,
@@ -1869,8 +1872,10 @@ Handle<Map> Map::TransitionToDataProperty(Isolate* isolate, Handle<Map> map,
       isolate->bootstrapper()->IsActive() ? OMIT_TRANSITION : INSERT_TRANSITION;
   MaybeHandle<Map> maybe_map;
   if (!map->TooManyFastProperties(store_origin)) {
-    Representation representation = value->OptimalRepresentation(isolate);
-    Handle<FieldType> type = value->OptimalType(isolate, representation);
+    Representation representation =
+        Object::OptimalRepresentation(*value, isolate);
+    Handle<FieldType> type =
+        Object::OptimalType(*value, isolate, representation);
     maybe_map = Map::CopyWithField(isolate, map, name, type, attributes,
                                    constness, representation, flag);
   }
diff --git a/src/objects/module.cc b/src/objects/module.cc
index 0873bffc9a8..766a28399a0 100644
--- a/src/objects/module.cc
+++ b/src/objects/module.cc
@@ -29,9 +29,10 @@ namespace {
 #ifdef DEBUG
 void PrintModuleName(Module module, std::ostream& os) {
   if (IsSourceTextModule(module)) {
-    SourceTextModule::cast(module)->GetScript()->GetNameOrSourceURL().Print(os);
+    Print(SourceTextModule::cast(module)->GetScript()->GetNameOrSourceURL(),
+          os);
   } else {
-    SyntheticModule::cast(module)->name().Print(os);
+    Print(SyntheticModule::cast(module)->name(), os);
   }
 #ifndef OBJECT_PRINT
   os << "\n";
@@ -440,7 +441,8 @@ Maybe<bool> JSModuleNamespace::DefineOwnProperty(
       (desc->has_enumerable() && !desc->enumerable()) ||
       PropertyDescriptor::IsAccessorDescriptor(desc) ||
       (desc->has_writable() && !desc->writable()) ||
-      (desc->has_value() && !desc->value()->SameValue(*current.value()))) {
+      (desc->has_value() &&
+       !Object::SameValue(*desc->value(), *current.value()))) {
     RETURN_FAILURE(isolate, GetShouldThrow(isolate, should_throw),
                    NewTypeError(MessageTemplate::kRedefineDisallowed, key));
   }
diff --git a/src/objects/object-macros.h b/src/objects/object-macros.h
index d7af0c8129e..a03465df5e9 100644
--- a/src/objects/object-macros.h
+++ b/src/objects/object-macros.h
@@ -715,9 +715,16 @@ static_assert(sizeof(unsigned) == sizeof(uint32_t),
 #define DECL_VERIFIER(Name) void Name##Verify(Isolate* isolate);
 #define EXPORT_DECL_VERIFIER(Name) \
   V8_EXPORT_PRIVATE void Name##Verify(Isolate* isolate);
+#define DECL_STATIC_VERIFIER(Name) \
+  static void Name##Verify(Tagged<Name> obj, Isolate* isolate);
+#define EXPORT_DECL_STATIC_VERIFIER(Name)                      \
+  V8_EXPORT_PRIVATE static void Name##Verify(Tagged<Name> obj, \
+                                             Isolate* isolate);
 #else
 #define DECL_VERIFIER(Name)
 #define EXPORT_DECL_VERIFIER(Name)
+#define DECL_STATIC_VERIFIER(Name)
+#define EXPORT_DECL_STATIC_VERIFIER(Name)
 #endif
 
 #define DEFINE_DEOPT_ELEMENT_ACCESSORS(name, type) \
diff --git a/src/objects/object-type.cc b/src/objects/object-type.cc
index 76574408750..954dcbfc356 100644
--- a/src/objects/object-type.cc
+++ b/src/objects/object-type.cc
@@ -75,7 +75,7 @@ Address CheckObjectType(Address raw_value, Address raw_type,
   }
   MaybeObject maybe_value(raw_value);
   std::stringstream value_description;
-  maybe_value.Print(value_description);
+  Print(maybe_value, value_description);
   FATAL(
       "Type cast failed in %s\n"
       "  Expected %s but found %s",
diff --git a/src/objects/objects-inl.h b/src/objects/objects-inl.h
index c3f9ac91929..d3c1ff8d48a 100644
--- a/src/objects/objects-inl.h
+++ b/src/objects/objects-inl.h
@@ -87,12 +87,14 @@ DEF_HEAP_OBJECT_PREDICATE(HeapObject, IsClassBoilerplate) {
   return IsFixedArrayExact(obj, cage_base);
 }
 
-bool Object::InSharedHeap() const {
-  return IsHeapObject(*this) && HeapObject::cast(*this).InAnySharedSpace();
+// static
+bool Object::InSharedHeap(Tagged<Object> obj) {
+  return IsHeapObject(obj) && HeapObject::cast(obj).InAnySharedSpace();
 }
 
-bool Object::InWritableSharedSpace() const {
-  return IsHeapObject(*this) && HeapObject::cast(*this).InWritableSharedSpace();
+// static
+bool Object::InWritableSharedSpace(Tagged<Object> obj) {
+  return IsHeapObject(obj) && HeapObject::cast(obj).InWritableSharedSpace();
 }
 
 bool IsJSObjectThatCanBeTrackedAsPrototype(Tagged<Object> obj) {
@@ -514,10 +516,11 @@ DEF_HEAP_OBJECT_PREDICATE(HeapObject, IsAccessCheckNeeded) {
 STRUCT_LIST(MAKE_STRUCT_PREDICATE)
 #undef MAKE_STRUCT_PREDICATE
 
-double Object::Number() const {
-  DCHECK(IsNumber(*this));
-  return IsSmi(*this) ? static_cast<double>(Smi(ptr()).value())
-                      : HeapNumber::unchecked_cast(*this)->value();
+// static
+double Object::Number(Tagged<Object> obj) {
+  DCHECK(IsNumber(obj));
+  return IsSmi(obj) ? static_cast<double>(Smi(obj.ptr()).value())
+                    : HeapNumber::unchecked_cast(obj)->value();
 }
 
 // static
@@ -550,32 +553,36 @@ OBJECT_CONSTRUCTORS_IMPL(FreshlyAllocatedBigInt, BigIntBase)
 CAST_ACCESSOR(BigIntBase)
 CAST_ACCESSOR(BigInt)
 
-bool Object::HasValidElements() {
+// static
+bool Object::HasValidElements(Tagged<Object> obj) {
   // Dictionary is covered under FixedArray. ByteArray is used
   // for the JSTypedArray backing stores.
-  return IsFixedArray(*this) || IsFixedDoubleArray(*this) || IsByteArray(*this);
+  return IsFixedArray(obj) || IsFixedDoubleArray(obj) || IsByteArray(obj);
 }
 
-bool Object::FilterKey(PropertyFilter filter) {
-  DCHECK(!IsPropertyCell(*this));
+// static
+bool Object::FilterKey(Tagged<Object> obj, PropertyFilter filter) {
+  DCHECK(!IsPropertyCell(obj));
   if (filter == PRIVATE_NAMES_ONLY) {
-    if (!IsSymbol(*this)) return true;
-    return !Symbol::cast(*this)->is_private_name();
-  } else if (IsSymbol(*this)) {
+    if (!IsSymbol(obj)) return true;
+    return !Symbol::cast(obj)->is_private_name();
+  } else if (IsSymbol(obj)) {
     if (filter & SKIP_SYMBOLS) return true;
 
-    if (Symbol::cast(*this)->is_private()) return true;
+    if (Symbol::cast(obj)->is_private()) return true;
   } else {
     if (filter & SKIP_STRINGS) return true;
   }
   return false;
 }
 
-Representation Object::OptimalRepresentation(PtrComprCageBase cage_base) const {
-  if (IsSmi(*this)) {
+// static
+Representation Object::OptimalRepresentation(Tagged<Object> obj,
+                                             PtrComprCageBase cage_base) {
+  if (IsSmi(obj)) {
     return Representation::Smi();
   }
-  HeapObject heap_object = HeapObject::cast(*this);
+  HeapObject heap_object = HeapObject::cast(obj);
   if (IsHeapNumber(heap_object, cage_base)) {
     return Representation::Double();
   } else if (IsUninitialized(heap_object,
@@ -585,35 +592,40 @@ Representation Object::OptimalRepresentation(PtrComprCageBase cage_base) const {
   return Representation::HeapObject();
 }
 
-ElementsKind Object::OptimalElementsKind(PtrComprCageBase cage_base) const {
-  if (IsSmi(*this)) return PACKED_SMI_ELEMENTS;
-  if (IsNumber(*this, cage_base)) return PACKED_DOUBLE_ELEMENTS;
+// static
+ElementsKind Object::OptimalElementsKind(Tagged<Object> obj,
+                                         PtrComprCageBase cage_base) {
+  if (IsSmi(obj)) return PACKED_SMI_ELEMENTS;
+  if (IsNumber(obj, cage_base)) return PACKED_DOUBLE_ELEMENTS;
   return PACKED_ELEMENTS;
 }
 
-bool Object::FitsRepresentation(Representation representation,
-                                bool allow_coercion) const {
+// static
+bool Object::FitsRepresentation(Tagged<Object> obj,
+                                Representation representation,
+                                bool allow_coercion) {
   if (representation.IsSmi()) {
-    return IsSmi(*this);
+    return IsSmi(obj);
   } else if (representation.IsDouble()) {
-    return allow_coercion ? IsNumber(*this) : IsHeapNumber(*this);
+    return allow_coercion ? IsNumber(obj) : IsHeapNumber(obj);
   } else if (representation.IsHeapObject()) {
-    return IsHeapObject(*this);
+    return IsHeapObject(obj);
   } else if (representation.IsNone()) {
     return false;
   }
   return true;
 }
 
-bool Object::ToUint32(uint32_t* value) const {
-  if (IsSmi(*this)) {
-    int num = Smi::ToInt(*this);
+// static
+bool Object::ToUint32(Tagged<Object> obj, uint32_t* value) {
+  if (IsSmi(obj)) {
+    int num = Smi::ToInt(obj);
     if (num < 0) return false;
     *value = static_cast<uint32_t>(num);
     return true;
   }
-  if (IsHeapNumber(*this)) {
-    double num = HeapNumber::cast(*this)->value();
+  if (IsHeapNumber(obj)) {
+    double num = HeapNumber::cast(obj)->value();
     return DoubleToUint32IfEqualToSelf(num, value);
   }
   return false;
@@ -1095,23 +1107,26 @@ bool IsCustomElementsReceiverMap(Tagged<Map> map) {
   return IsCustomElementsReceiverInstanceType(map->instance_type());
 }
 
-bool Object::ToArrayLength(uint32_t* index) const {
-  return Object::ToUint32(index);
+// static
+bool Object::ToArrayLength(Tagged<Object> obj, uint32_t* index) {
+  return Object::ToUint32(obj, index);
 }
 
-bool Object::ToArrayIndex(uint32_t* index) const {
-  return Object::ToUint32(index) && *index != kMaxUInt32;
+// static
+bool Object::ToArrayIndex(Tagged<Object> obj, uint32_t* index) {
+  return Object::ToUint32(obj, index) && *index != kMaxUInt32;
 }
 
-bool Object::ToIntegerIndex(size_t* index) const {
-  if (IsSmi(*this)) {
-    int num = Smi::ToInt(*this);
+// static
+bool Object::ToIntegerIndex(Tagged<Object> obj, size_t* index) {
+  if (IsSmi(obj)) {
+    int num = Smi::ToInt(obj);
     if (num < 0) return false;
     *index = static_cast<size_t>(num);
     return true;
   }
-  if (IsHeapNumber(*this)) {
-    double num = HeapNumber::cast(*this)->value();
+  if (IsHeapNumber(obj)) {
+    double num = HeapNumber::cast(obj)->value();
     if (!(num >= 0)) return false;  // Negation to catch NaNs.
     constexpr double max =
         std::min(kMaxSafeInteger,
@@ -1294,13 +1309,14 @@ Object Object::GetSimpleHash(Object object) {
   return object;
 }
 
-Object Object::GetHash() {
+// static
+Object Object::GetHash(Tagged<Object> obj) {
   DisallowGarbageCollection no_gc;
-  Object hash = GetSimpleHash(*this);
+  Object hash = GetSimpleHash(obj);
   if (IsSmi(hash)) return hash;
 
-  DCHECK(IsJSReceiver(*this));
-  JSReceiver receiver = JSReceiver::cast(*this);
+  DCHECK(IsJSReceiver(obj));
+  JSReceiver receiver = JSReceiver::cast(obj);
   return receiver->GetIdentityHash();
 }
 
@@ -1362,17 +1378,18 @@ MaybeHandle<Object> Object::Share(Isolate* isolate, Handle<Object> value,
 }
 
 // https://tc39.es/ecma262/#sec-canbeheldweakly
-bool Object::CanBeHeldWeakly() const {
-  if (IsJSReceiver(*this)) {
+// static
+bool Object::CanBeHeldWeakly(Tagged<Object> obj) {
+  if (IsJSReceiver(obj)) {
     // TODO(v8:12547) Shared structs and arrays should only be able to point
     // to shared values in weak collections. For now, disallow them as weak
     // collection keys.
     if (v8_flags.harmony_struct) {
-      return !IsJSSharedStruct(*this) && !IsJSSharedArray(*this);
+      return !IsJSSharedStruct(obj) && !IsJSSharedArray(obj);
     }
     return true;
   }
-  return IsSymbol(*this) && !Symbol::cast(*this)->is_in_public_symbol_table();
+  return IsSymbol(obj) && !Symbol::cast(obj)->is_in_public_symbol_table();
 }
 
 Handle<Object> ObjectHashTableShape::AsHandle(Handle<Object> key) {
diff --git a/src/objects/objects.cc b/src/objects/objects.cc
index cb3b61608bf..b3213a8c09d 100644
--- a/src/objects/objects.cc
+++ b/src/objects/objects.cc
@@ -213,13 +213,14 @@ std::ostream& operator<<(std::ostream& os, PropertyCellType type) {
   UNREACHABLE();
 }
 
-Handle<FieldType> Object::OptimalType(Isolate* isolate,
+// static
+Handle<FieldType> Object::OptimalType(Tagged<Object> obj, Isolate* isolate,
                                       Representation representation) {
   if (representation.IsNone()) return FieldType::None(isolate);
   if (v8_flags.track_field_types) {
-    if (representation.IsHeapObject() && IsHeapObject(*this)) {
+    if (representation.IsHeapObject() && IsHeapObject(obj)) {
       // We can track only JavaScript objects with stable maps.
-      Handle<Map> map(HeapObject::cast(*this)->map(), isolate);
+      Handle<Map> map(HeapObject::cast(obj)->map(), isolate);
       if (map->is_stable() && IsJSReceiverMap(*map)) {
         return FieldType::Class(map, isolate);
       }
@@ -239,7 +240,7 @@ Handle<Object> Object::NewStorageFor(Isolate* isolate, Handle<Object> object,
     result->set_value_as_bits(
         HeapNumber::cast(*object)->value_as_bits(kRelaxedLoad), kRelaxedStore);
   } else {
-    result->set_value(object->Number(), kRelaxedStore);
+    result->set_value(Object::Number(*object), kRelaxedStore);
   }
   return result;
 }
@@ -249,7 +250,7 @@ Handle<Object> Object::WrapForRead(IsolateT* isolate, Handle<Object> object,
                                    Representation representation) {
   DCHECK(!IsUninitialized(*object, isolate));
   if (!representation.IsDouble()) {
-    DCHECK(object->FitsRepresentation(representation));
+    DCHECK(Object::FitsRepresentation(*object, representation));
     return object;
   }
   return isolate->factory()->template NewHeapNumberFromBits<allocation_type>(
@@ -345,7 +346,7 @@ MaybeHandle<Object> Object::ConvertToInteger(Isolate* isolate,
       isolate, input,
       ConvertToNumberOrNumeric(isolate, input, Conversion::kToNumber), Object);
   if (IsSmi(*input)) return input;
-  return isolate->factory()->NewNumber(DoubleToInteger(input->Number()));
+  return isolate->factory()->NewNumber(DoubleToInteger(Object::Number(*input)));
 }
 
 // static
@@ -355,7 +356,8 @@ MaybeHandle<Object> Object::ConvertToInt32(Isolate* isolate,
       isolate, input,
       ConvertToNumberOrNumeric(isolate, input, Conversion::kToNumber), Object);
   if (IsSmi(*input)) return input;
-  return isolate->factory()->NewNumberFromInt(DoubleToInt32(input->Number()));
+  return isolate->factory()->NewNumberFromInt(
+      DoubleToInt32(Object::Number(*input)));
 }
 
 // static
@@ -365,7 +367,8 @@ MaybeHandle<Object> Object::ConvertToUint32(Isolate* isolate,
       isolate, input,
       ConvertToNumberOrNumeric(isolate, input, Conversion::kToNumber), Object);
   if (IsSmi(*input)) return handle(Smi::cast(*input).ToUint32Smi(), isolate);
-  return isolate->factory()->NewNumberFromUint(DoubleToUint32(input->Number()));
+  return isolate->factory()->NewNumberFromUint(
+      DoubleToUint32(Object::Number(*input)));
 }
 
 // static
@@ -395,7 +398,7 @@ MaybeHandle<Object> Object::ConvertToPropertyKey(Isolate* isolate,
   if (IsSmi(*key)) return key;
   if (IsHeapNumber(*key)) {
     uint32_t uint_value;
-    if (value->ToArrayLength(&uint_value) &&
+    if (Object::ToArrayLength(*value, &uint_value) &&
         uint_value <= static_cast<uint32_t>(Smi::kMaxValue)) {
       return handle(Smi::FromInt(static_cast<int>(uint_value)), isolate);
     }
@@ -638,7 +641,7 @@ MaybeHandle<Object> Object::ConvertToLength(Isolate* isolate,
     int value = std::max(Smi::ToInt(*input), 0);
     return handle(Smi::FromInt(value), isolate);
   }
-  double len = DoubleToInteger(input->Number());
+  double len = DoubleToInteger(Object::Number(*input));
   if (len <= 0.0) {
     return handle(Smi::zero(), isolate);
   } else if (len >= kMaxSafeInteger) {
@@ -654,7 +657,7 @@ MaybeHandle<Object> Object::ConvertToIndex(Isolate* isolate,
   if (IsUndefined(*input, isolate)) return handle(Smi::zero(), isolate);
   ASSIGN_RETURN_ON_EXCEPTION(isolate, input, ToNumber(isolate, input), Object);
   if (IsSmi(*input) && Smi::ToInt(*input) >= 0) return input;
-  double len = DoubleToInteger(input->Number());
+  double len = DoubleToInteger(Object::Number(*input));
   Handle<Object> js_len = isolate->factory()->NewNumber(len);
   if (len < 0.0 || len > kMaxSafeInteger) {
     THROW_NEW_ERROR(isolate, NewRangeError(error_index, js_len), Object);
@@ -663,27 +666,28 @@ MaybeHandle<Object> Object::ConvertToIndex(Isolate* isolate,
 }
 
 template <typename IsolateT>
-bool Object::BooleanValue(IsolateT* isolate) {
-  if (IsSmi(*this)) return Smi::ToInt(*this) != 0;
-  DCHECK(IsHeapObject(*this));
-  if (IsBoolean(*this)) return IsTrue(*this, isolate);
-  if (IsNullOrUndefined(*this, isolate)) return false;
+// static
+bool Object::BooleanValue(Tagged<Object> obj, IsolateT* isolate) {
+  if (IsSmi(obj)) return Smi::ToInt(obj) != 0;
+  DCHECK(IsHeapObject(obj));
+  if (IsBoolean(obj)) return IsTrue(obj, isolate);
+  if (IsNullOrUndefined(obj, isolate)) return false;
 #ifdef V8_ENABLE_WEBASSEMBLY
-  if (IsWasmNull(*this)) return false;
+  if (IsWasmNull(obj)) return false;
 #endif
-  if (IsUndetectable(*this)) return false;  // Undetectable object is false.
-  if (IsString(*this)) return String::cast(*this)->length() != 0;
-  if (IsHeapNumber(*this))
-    return DoubleToBoolean(HeapNumber::cast(*this)->value());
-  if (IsBigInt(*this)) return BigInt::cast(*this)->ToBoolean();
+  if (IsUndetectable(obj)) return false;  // Undetectable object is false.
+  if (IsString(obj)) return String::cast(obj)->length() != 0;
+  if (IsHeapNumber(obj)) return DoubleToBoolean(HeapNumber::cast(obj)->value());
+  if (IsBigInt(obj)) return BigInt::cast(obj)->ToBoolean();
   return true;
 }
-template bool Object::BooleanValue(Isolate*);
-template bool Object::BooleanValue(LocalIsolate*);
+template bool Object::BooleanValue(Tagged<Object>, Isolate*);
+template bool Object::BooleanValue(Tagged<Object>, LocalIsolate*);
 
-Object Object::ToBoolean(Isolate* isolate) {
-  if (IsBoolean(*this)) return *this;
-  return isolate->heap()->ToBoolean(BooleanValue(isolate));
+// static
+Object Object::ToBoolean(Tagged<Object> obj, Isolate* isolate) {
+  if (IsBoolean(obj)) return obj;
+  return isolate->heap()->ToBoolean(Object::BooleanValue(obj, isolate));
 }
 
 namespace {
@@ -711,7 +715,7 @@ bool StrictNumberEquals(double x, double y) {
 }
 
 bool StrictNumberEquals(const Object x, const Object y) {
-  return StrictNumberEquals(x.Number(), y.Number());
+  return StrictNumberEquals(Object::Number(x), Object::Number(y));
 }
 
 bool StrictNumberEquals(Handle<Object> x, Handle<Object> y) {
@@ -766,7 +770,7 @@ Maybe<ComparisonResult> Object::Compare(Isolate* isolate, Handle<Object> x,
   bool x_is_number = IsNumber(*x);
   bool y_is_number = IsNumber(*y);
   if (x_is_number && y_is_number) {
-    return Just(StrictNumberCompare(x->Number(), y->Number()));
+    return Just(StrictNumberCompare(Object::Number(*x), Object::Number(*y)));
   } else if (!x_is_number && !y_is_number) {
     return Just(BigInt::CompareToBigInt(Handle<BigInt>::cast(x),
                                         Handle<BigInt>::cast(y)));
@@ -879,18 +883,19 @@ Maybe<bool> Object::Equals(Isolate* isolate, Handle<Object> x,
   }
 }
 
-bool Object::StrictEquals(Object that) {
-  if (IsNumber(*this)) {
+// static
+bool Object::StrictEquals(Tagged<Object> obj, Object that) {
+  if (IsNumber(obj)) {
     if (!IsNumber(that)) return false;
-    return StrictNumberEquals(*this, that);
-  } else if (IsString(*this)) {
+    return StrictNumberEquals(obj, that);
+  } else if (IsString(obj)) {
     if (!IsString(that)) return false;
-    return String::cast(*this)->Equals(String::cast(that));
-  } else if (IsBigInt(*this)) {
+    return String::cast(obj)->Equals(String::cast(that));
+  } else if (IsBigInt(obj)) {
     if (!IsBigInt(that)) return false;
-    return BigInt::EqualToBigInt(BigInt::cast(*this), BigInt::cast(that));
+    return BigInt::EqualToBigInt(BigInt::cast(obj), BigInt::cast(that));
   }
-  return *this == that;
+  return obj == that;
 }
 
 // static
@@ -912,7 +917,8 @@ Handle<String> Object::TypeOf(Isolate* isolate, Handle<Object> object) {
 MaybeHandle<Object> Object::Add(Isolate* isolate, Handle<Object> lhs,
                                 Handle<Object> rhs) {
   if (IsNumber(*lhs) && IsNumber(*rhs)) {
-    return isolate->factory()->NewNumber(lhs->Number() + rhs->Number());
+    return isolate->factory()->NewNumber(Object::Number(*lhs) +
+                                         Object::Number(*rhs));
   } else if (IsString(*lhs) && IsString(*rhs)) {
     return isolate->factory()->NewConsString(Handle<String>::cast(lhs),
                                              Handle<String>::cast(rhs));
@@ -933,7 +939,8 @@ MaybeHandle<Object> Object::Add(Isolate* isolate, Handle<Object> lhs,
                              Object);
   ASSIGN_RETURN_ON_EXCEPTION(isolate, lhs, Object::ToNumber(isolate, lhs),
                              Object);
-  return isolate->factory()->NewNumber(lhs->Number() + rhs->Number());
+  return isolate->factory()->NewNumber(Object::Number(*lhs) +
+                                       Object::Number(*rhs));
 }
 
 // static
@@ -1003,7 +1010,8 @@ MaybeHandle<Object> Object::InstanceOf(Isolate* isolate, Handle<Object> object,
         isolate, result,
         Execution::Call(isolate, inst_of_handler, callable, 1, &object),
         Object);
-    return isolate->factory()->ToBoolean(result->BooleanValue(isolate));
+    return isolate->factory()->ToBoolean(
+        Object::BooleanValue(*result, isolate));
   }
 
   // The {callable} must have a [[Call]] internal method.
@@ -1049,7 +1057,8 @@ MaybeHandle<FixedArray> CreateListFromArrayLikeFastPath(
       Handle<JSArray> array = Handle<JSArray>::cast(object);
       uint32_t length;
       if (!array->HasArrayPrototype(isolate) ||
-          !array->length().ToUint32(&length) || !array->HasFastElements() ||
+          !Object::ToUint32(array->length(), &length) ||
+          !array->HasFastElements() ||
           !JSObject::PrototypeHasNoElements(isolate, *array)) {
         return MaybeHandle<FixedArray>();
       }
@@ -1098,7 +1107,7 @@ MaybeHandle<FixedArray> Object::CreateListFromArrayLike(
                              Object::GetLengthFromArrayLike(isolate, receiver),
                              FixedArray);
   uint32_t len;
-  if (!raw_length_number->ToUint32(&len) ||
+  if (!Object::ToUint32(*raw_length_number, &len) ||
       len > static_cast<uint32_t>(FixedArray::kMaxLength)) {
     THROW_NEW_ERROR(isolate,
                     NewRangeError(MessageTemplate::kInvalidArrayLength),
@@ -1303,7 +1312,7 @@ MaybeHandle<Object> JSProxy::CheckGetSetTrapResult(Isolate* isolate,
     bool inconsistent = PropertyDescriptor::IsDataDescriptor(&target_desc) &&
                         !target_desc.configurable() &&
                         !target_desc.writable() &&
-                        !trap_result->SameValue(*target_desc.value());
+                        !Object::SameValue(*trap_result, *target_desc.value());
     if (inconsistent) {
       if (access_kind == kGet) {
         THROW_NEW_ERROR(
@@ -1347,13 +1356,14 @@ MaybeHandle<Object> JSProxy::CheckGetSetTrapResult(Isolate* isolate,
   return isolate->factory()->undefined_value();
 }
 
-bool Object::ToInt32(int32_t* value) {
-  if (IsSmi(*this)) {
-    *value = Smi::ToInt(*this);
+// static
+bool Object::ToInt32(Tagged<Object> obj, int32_t* value) {
+  if (IsSmi(obj)) {
+    *value = Smi::ToInt(obj);
     return true;
   }
-  if (IsHeapNumber(*this)) {
-    double num = HeapNumber::cast(*this)->value();
+  if (IsHeapNumber(obj)) {
+    double num = HeapNumber::cast(obj)->value();
     // Check range before conversion to avoid undefined behavior.
     if (num >= kMinInt && num <= kMaxInt && FastI2D(FastD2I(num)) == num) {
       *value = FastD2I(num);
@@ -1435,7 +1445,7 @@ MaybeHandle<HeapObject> JSProxy::GetPrototype(Handle<JSProxy> proxy) {
                              JSReceiver::GetPrototype(isolate, target),
                              HeapObject);
   // 12. If SameValue(handlerProto, targetProto) is false, throw a TypeError.
-  if (!handler_proto->SameValue(*target_proto)) {
+  if (!Object::SameValue(*handler_proto, *target_proto)) {
     THROW_NEW_ERROR(
         isolate,
         NewTypeError(MessageTemplate::kProxyGetPrototypeOfNonExtensible),
@@ -1561,9 +1571,9 @@ Maybe<bool> Object::SetPropertyWithAccessor(
     // (signalling an exception) or a boolean Oddball.
     RETURN_VALUE_IF_SCHEDULED_EXCEPTION(isolate, Nothing<bool>());
     if (result.is_null()) return Just(true);
-    DCHECK(result->BooleanValue(isolate) ||
+    DCHECK(Object::BooleanValue(*result, isolate) ||
            GetShouldThrow(isolate, maybe_should_throw) == kDontThrow);
-    return Just(result->BooleanValue(isolate));
+    return Just(Object::BooleanValue(*result, isolate));
   }
 
   // Regular accessor.
@@ -1625,56 +1635,60 @@ Maybe<bool> Object::SetPropertyWithDefinedSetter(
   return Just(true);
 }
 
-Map Object::GetPrototypeChainRootMap(Isolate* isolate) const {
+// static
+Map Object::GetPrototypeChainRootMap(Tagged<Object> obj, Isolate* isolate) {
   DisallowGarbageCollection no_alloc;
-  if (IsSmi(*this)) {
+  if (IsSmi(obj)) {
     Context native_context = isolate->context()->native_context();
     return native_context->number_function()->initial_map();
   }
 
-  const HeapObject heap_object = HeapObject::cast(*this);
+  const HeapObject heap_object = HeapObject::cast(obj);
   return heap_object->map()->GetPrototypeChainRootMap(isolate);
 }
 
-Smi Object::GetOrCreateHash(Isolate* isolate) {
+// static
+Smi Object::GetOrCreateHash(Tagged<Object> obj, Isolate* isolate) {
   DisallowGarbageCollection no_gc;
-  Object hash = Object::GetSimpleHash(*this);
+  Object hash = Object::GetSimpleHash(obj);
   if (IsSmi(hash)) return Smi::cast(hash);
 
-  DCHECK(IsJSReceiver(*this));
-  return JSReceiver::cast(*this)->GetOrCreateIdentityHash(isolate);
+  DCHECK(IsJSReceiver(obj));
+  return JSReceiver::cast(obj)->GetOrCreateIdentityHash(isolate);
 }
 
-bool Object::SameValue(Object other) {
-  if (other == *this) return true;
+// static
+bool Object::SameValue(Tagged<Object> obj, Object other) {
+  if (other == obj) return true;
 
-  if (IsNumber(*this) && IsNumber(other)) {
-    return SameNumberValue(Number(), other.Number());
+  if (IsNumber(obj) && IsNumber(other)) {
+    return SameNumberValue(Object::Number(obj), Object::Number(other));
   }
-  if (IsString(*this) && IsString(other)) {
-    return String::cast(*this)->Equals(String::cast(other));
+  if (IsString(obj) && IsString(other)) {
+    return String::cast(obj)->Equals(String::cast(other));
   }
-  if (IsBigInt(*this) && IsBigInt(other)) {
-    return BigInt::EqualToBigInt(BigInt::cast(*this), BigInt::cast(other));
+  if (IsBigInt(obj) && IsBigInt(other)) {
+    return BigInt::EqualToBigInt(BigInt::cast(obj), BigInt::cast(other));
   }
   return false;
 }
 
-bool Object::SameValueZero(Object other) {
-  if (other == *this) return true;
+// static
+bool Object::SameValueZero(Tagged<Object> obj, Object other) {
+  if (other == obj) return true;
 
-  if (IsNumber(*this) && IsNumber(other)) {
-    double this_value = Number();
-    double other_value = other.Number();
+  if (IsNumber(obj) && IsNumber(other)) {
+    double this_value = Object::Number(obj);
+    double other_value = Object::Number(other);
     // +0 == -0 is true
     return this_value == other_value ||
            (std::isnan(this_value) && std::isnan(other_value));
   }
-  if (IsString(*this) && IsString(other)) {
-    return String::cast(*this)->Equals(String::cast(other));
+  if (IsString(obj) && IsString(other)) {
+    return String::cast(obj)->Equals(String::cast(other));
   }
-  if (IsBigInt(*this) && IsBigInt(other)) {
-    return BigInt::EqualToBigInt(BigInt::cast(*this), BigInt::cast(other));
+  if (IsBigInt(obj) && IsBigInt(other)) {
+    return BigInt::EqualToBigInt(BigInt::cast(obj), BigInt::cast(other));
   }
   return false;
 }
@@ -1770,10 +1784,11 @@ V8_WARN_UNUSED_RESULT MaybeHandle<Object> Object::SpeciesConstructor(
       isolate, NewTypeError(MessageTemplate::kSpeciesNotConstructor), Object);
 }
 
-bool Object::IterationHasObservableEffects() {
+// static
+bool Object::IterationHasObservableEffects(Tagged<Object> obj) {
   // Check that this object is an array.
-  if (!IsJSArray(*this)) return true;
-  JSArray array = JSArray::cast(*this);
+  if (!IsJSArray(obj)) return true;
+  JSArray array = JSArray::cast(obj);
   Isolate* isolate = array->GetIsolate();
 
   // Check that we have the original ArrayPrototype.
@@ -1805,26 +1820,27 @@ bool Object::IterationHasObservableEffects() {
   return true;
 }
 
-bool Object::IsCodeLike(Isolate* isolate) const {
+// static
+bool Object::IsCodeLike(Tagged<Object> obj, Isolate* isolate) {
   DisallowGarbageCollection no_gc;
-  return IsJSReceiver(*this) && JSReceiver::cast(*this)->IsCodeLike(isolate);
+  return IsJSReceiver(obj) && JSReceiver::cast(obj)->IsCodeLike(isolate);
 }
 
-void Object::ShortPrint(FILE* out) const {
+void ShortPrint(Object obj, FILE* out) {
   OFStream os(out);
-  os << Brief(*this);
+  os << Brief(obj);
 }
 
-void Object::ShortPrint(StringStream* accumulator) const {
+void ShortPrint(Object obj, StringStream* accumulator) {
   std::ostringstream os;
-  os << Brief(*this);
+  os << Brief(obj);
   accumulator->Add(os.str().c_str());
 }
 
-void Object::ShortPrint(std::ostream& os) const { os << Brief(*this); }
+void ShortPrint(Object obj, std::ostream& os) { os << Brief(obj); }
 
 std::ostream& operator<<(std::ostream& os, const Object& obj) {
-  obj.ShortPrint(os);
+  ShortPrint(obj, os);
   return os;
 }
 
@@ -1886,7 +1902,7 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {
       os << "<AwaitContext generator= ";
       HeapStringAllocator allocator;
       StringStream accumulator(&allocator);
-      Context::cast(*this)->extension().ShortPrint(&accumulator);
+      ShortPrint(Context::cast(*this)->extension(), &accumulator);
       os << accumulator.ToCString().get();
       os << '>';
       break;
@@ -2141,7 +2157,7 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {
       os << "<Cell value= ";
       HeapStringAllocator allocator;
       StringStream accumulator(&allocator);
-      Cell::cast(*this)->value().ShortPrint(&accumulator);
+      ShortPrint(Cell::cast(*this)->value(), &accumulator);
       os << accumulator.ToCString().get();
       os << '>';
       break;
@@ -2149,11 +2165,11 @@ void HeapObject::HeapObjectShortPrint(std::ostream& os) {
     case PROPERTY_CELL_TYPE: {
       PropertyCell cell = PropertyCell::cast(*this);
       os << "<PropertyCell name=";
-      cell->name().ShortPrint(os);
+      ShortPrint(cell->name(), os);
       os << " value=";
       HeapStringAllocator allocator;
       StringStream accumulator(&allocator);
-      cell->value(kAcquireLoad).ShortPrint(&accumulator);
+      ShortPrint(cell->value(kAcquireLoad), &accumulator);
       os << accumulator.ToCString().get();
       os << '>';
       break;
@@ -3134,7 +3150,7 @@ Maybe<bool> JSProxy::HasProperty(Isolate* isolate, Handle<JSProxy> proxy,
       isolate, trap_result_obj,
       Execution::Call(isolate, trap, handler, arraysize(args), args),
       Nothing<bool>());
-  bool boolean_trap_result = trap_result_obj->BooleanValue(isolate);
+  bool boolean_trap_result = Object::BooleanValue(*trap_result_obj, isolate);
   // 9. If booleanTrapResult is false, then:
   if (!boolean_trap_result) {
     MAYBE_RETURN(JSProxy::CheckHasTrap(isolate, name, target), Nothing<bool>());
@@ -3206,7 +3222,7 @@ Maybe<bool> JSProxy::SetProperty(Handle<JSProxy> proxy, Handle<Name> name,
       isolate, trap_result,
       Execution::Call(isolate, trap, handler, arraysize(args), args),
       Nothing<bool>());
-  if (!trap_result->BooleanValue(isolate)) {
+  if (!Object::BooleanValue(*trap_result, isolate)) {
     RETURN_FAILURE(isolate, GetShouldThrow(isolate, should_throw),
                    NewTypeError(MessageTemplate::kProxyTrapReturnedFalsishFor,
                                 trap_name, name));
@@ -3253,7 +3269,7 @@ Maybe<bool> JSProxy::DeletePropertyOrElement(Handle<JSProxy> proxy,
       isolate, trap_result,
       Execution::Call(isolate, trap, handler, arraysize(args), args),
       Nothing<bool>());
-  if (!trap_result->BooleanValue(isolate)) {
+  if (!Object::BooleanValue(*trap_result, isolate)) {
     RETURN_FAILURE(isolate, should_throw,
                    NewTypeError(MessageTemplate::kProxyTrapReturnedFalsishFor,
                                 trap_name, name));
@@ -3319,7 +3335,7 @@ Maybe<PropertyAttributes> JSProxy::GetPropertyAttributes(LookupIterator* it) {
 // accessors.cc.
 bool PropertyKeyToArrayLength(Handle<Object> value, uint32_t* length) {
   DCHECK(IsNumber(*value) || IsName(*value));
-  if (value->ToArrayLength(length)) return true;
+  if (Object::ToArrayLength(*value, length)) return true;
   if (IsString(*value)) return String::cast(*value)->AsArrayIndex(length);
   return false;
 }
@@ -3353,7 +3369,7 @@ Maybe<bool> JSArray::DefineOwnProperty(Isolate* isolate, Handle<JSArray> o,
     USE(success);
     // 3c. Let oldLen be oldLenDesc.[[Value]].
     uint32_t old_len = 0;
-    CHECK(old_len_desc.value()->ToArrayLength(&old_len));
+    CHECK(Object::ToArrayLength(*old_len_desc.value(), &old_len));
     // 3d. Let index be ToUint32(P).
     // (Already done above.)
     // 3e. (Assert)
@@ -3399,7 +3415,7 @@ bool JSArray::AnythingToArrayLength(Isolate* isolate,
                                     uint32_t* output) {
   // Fast path: check numbers and strings that can be converted directly
   // and unobservably.
-  if (length_object->ToArrayLength(output)) return true;
+  if (Object::ToArrayLength(*length_object, output)) return true;
   if (IsString(*length_object) &&
       Handle<String>::cast(length_object)->AsArrayIndex(output)) {
     return true;
@@ -3418,13 +3434,13 @@ bool JSArray::AnythingToArrayLength(Isolate* isolate,
     return false;
   }
   // 7. If newLen != numberLen, throw a RangeError exception.
-  if (uint32_v->Number() != number_v->Number()) {
+  if (Object::Number(*uint32_v) != Object::Number(*number_v)) {
     Handle<Object> exception =
         isolate->factory()->NewRangeError(MessageTemplate::kInvalidArrayLength);
     isolate->Throw(*exception);
     return false;
   }
-  CHECK(uint32_v->ToArrayLength(output));
+  CHECK(Object::ToArrayLength(*uint32_v, output));
   return true;
 }
 
@@ -3459,7 +3475,7 @@ Maybe<bool> JSArray::ArraySetLength(Isolate* isolate, Handle<JSArray> a,
   USE(success);
   // 11. Let oldLen be oldLenDesc.[[Value]].
   uint32_t old_len = 0;
-  CHECK(old_len_desc.value()->ToArrayLength(&old_len));
+  CHECK(Object::ToArrayLength(*old_len_desc.value(), &old_len));
   // 12. If newLen >= oldLen, then
   if (new_len >= old_len) {
     // 8. Set newLenDesc.[[Value]] to newLen.
@@ -3508,7 +3524,7 @@ Maybe<bool> JSArray::ArraySetLength(Isolate* isolate, Handle<JSArray> a,
     USE(success);
   }
   uint32_t actual_new_len = 0;
-  CHECK(a->length().ToArrayLength(&actual_new_len));
+  CHECK(Object::ToArrayLength(a->length(), &actual_new_len));
   // Steps 19d-v, 21. Return false if there were non-deletable elements.
   bool result = actual_new_len == new_len;
   if (!result) {
@@ -3576,7 +3592,7 @@ Maybe<bool> JSProxy::DefineOwnProperty(Isolate* isolate, Handle<JSProxy> proxy,
       Execution::Call(isolate, trap, handler, arraysize(args), args),
       Nothing<bool>());
   // 10. If booleanTrapResult is false, return false.
-  if (!trap_result_obj->BooleanValue(isolate)) {
+  if (!Object::BooleanValue(*trap_result_obj, isolate)) {
     RETURN_FAILURE(isolate, GetShouldThrow(isolate, should_throw),
                    NewTypeError(MessageTemplate::kProxyTrapReturnedFalsishFor,
                                 trap_name, property_name));
@@ -3850,7 +3866,7 @@ Maybe<bool> JSProxy::PreventExtensions(Handle<JSProxy> proxy,
       isolate, trap_result,
       Execution::Call(isolate, trap, handler, arraysize(args), args),
       Nothing<bool>());
-  if (!trap_result->BooleanValue(isolate)) {
+  if (!Object::BooleanValue(*trap_result, isolate)) {
     RETURN_FAILURE(
         isolate, should_throw,
         NewTypeError(MessageTemplate::kProxyTrapReturnedFalsish, trap_name));
@@ -3898,7 +3914,7 @@ Maybe<bool> JSProxy::IsExtensible(Handle<JSProxy> proxy) {
   // Enforce the invariant.
   Maybe<bool> target_result = JSReceiver::IsExtensible(isolate, target);
   MAYBE_RETURN(target_result, Nothing<bool>());
-  if (target_result.FromJust() != trap_result->BooleanValue(isolate)) {
+  if (target_result.FromJust() != Object::BooleanValue(*trap_result, isolate)) {
     isolate->Throw(
         *factory->NewTypeError(MessageTemplate::kProxyIsExtensibleInconsistent,
                                factory->ToBoolean(target_result.FromJust())));
@@ -4705,7 +4721,7 @@ void WriteFixedArrayToFlat(FixedArray fixed_array, int length, String separator,
     // string is repeated.
     if (V8_UNLIKELY(element_is_special)) {
       int count;
-      CHECK(element.ToInt32(&count));
+      CHECK(Object::ToInt32(element, &count));
       if (count > 0) {
         num_separators = count;
         //  Verify that Smis (number of separators) only occur when necessary:
@@ -4854,7 +4870,7 @@ void Oddball::Initialize(Isolate* isolate, Handle<Oddball> oddball,
     oddball->set_to_number_raw_as_bits(
         Handle<HeapNumber>::cast(to_number)->value_as_bits(kRelaxedLoad));
   } else {
-    oddball->set_to_number_raw(to_number->Number());
+    oddball->set_to_number_raw(Object::Number(*to_number));
   }
   oddball->set_to_number(*to_number);
   oddball->set_to_string(*internalized_to_string);
@@ -5260,7 +5276,7 @@ Maybe<bool> JSProxy::SetPrototype(Isolate* isolate, Handle<JSProxy> proxy,
       isolate, trap_result,
       Execution::Call(isolate, trap, handler, arraysize(argv), argv),
       Nothing<bool>());
-  bool bool_trap_result = trap_result->BooleanValue(isolate);
+  bool bool_trap_result = Object::BooleanValue(*trap_result, isolate);
   // 9. If booleanTrapResult is false, return false.
   if (!bool_trap_result) {
     RETURN_FAILURE(
@@ -5283,7 +5299,7 @@ Maybe<bool> JSProxy::SetPrototype(Isolate* isolate, Handle<JSProxy> proxy,
                                    JSReceiver::GetPrototype(isolate, target),
                                    Nothing<bool>());
   // 13. If SameValue(V, targetProto) is false, throw a TypeError exception.
-  if (bool_trap_result && !value->SameValue(*target_proto)) {
+  if (bool_trap_result && !Object::SameValue(*value, *target_proto)) {
     isolate->Throw(*isolate->factory()->NewTypeError(
         MessageTemplate::kProxySetPrototypeOfNonExtensible));
     return Nothing<bool>();
@@ -5378,7 +5394,7 @@ bool JSArray::HasReadOnlyLength(Handle<JSArray> array) {
 
 bool JSArray::WouldChangeReadOnlyLength(Handle<JSArray> array, uint32_t index) {
   uint32_t length = 0;
-  CHECK(array->length().ToArrayLength(&length));
+  CHECK(Object::ToArrayLength(array->length(), &length));
   if (length <= index) return HasReadOnlyLength(array);
   return false;
 }
@@ -6318,7 +6334,7 @@ int Dictionary<Derived, Shape>::NumberOfEnumerableProperties() {
   for (InternalIndex i : this->IterateEntries()) {
     Object k;
     if (!this->ToKey(roots, i, &k)) continue;
-    if (k.FilterKey(ENUMERABLE_STRINGS)) continue;
+    if (Object::FilterKey(k, ENUMERABLE_STRINGS)) continue;
     PropertyDetails details = this->DetailsAt(i);
     PropertyAttributes attr = details.attributes();
     if ((int{attr} & ONLY_ENUMERABLE) == 0) result++;
@@ -6416,7 +6432,7 @@ Object ObjectHashTableBase<Derived, Shape>::Lookup(Handle<Object> key) {
   DCHECK(this->IsKey(roots, *key));
 
   // If the object does not have an identity hash, it was never used as a key.
-  Object hash = key->GetHash();
+  Object hash = Object::GetHash(*key);
   if (IsUndefined(hash, roots)) {
     return roots.the_hole_value();
   }
@@ -6461,7 +6477,7 @@ Handle<Derived> ObjectHashTableBase<Derived, Shape>::Put(Handle<Derived> table,
   DCHECK(!IsTheHole(*value, ReadOnlyRoots(isolate)));
 
   // Make sure the key object has an identity hash code.
-  int32_t hash = key->GetOrCreateHash(isolate).value();
+  int32_t hash = Object::GetOrCreateHash(*key, isolate).value();
 
   return ObjectHashTableBase<Derived, Shape>::Put(isolate, table, key, value,
                                                   hash);
@@ -6525,7 +6541,7 @@ Handle<Derived> ObjectHashTableBase<Derived, Shape>::Remove(
     bool* was_present) {
   DCHECK(table->IsKey(table->GetReadOnlyRoots(), *key));
 
-  Object hash = key->GetHash();
+  Object hash = Object::GetHash(*key);
   if (IsUndefined(hash)) {
     *was_present = false;
     return table;
@@ -6582,7 +6598,7 @@ std::array<Object, N> ObjectMultiHashTableBase<Derived, N>::Lookup(
   ReadOnlyRoots roots = this->GetReadOnlyRoots(cage_base);
   DCHECK(this->IsKey(roots, *key));
 
-  Object hash_obj = key->GetHash();
+  Object hash_obj = Object::GetHash(*key);
   if (IsUndefined(hash_obj, roots)) {
     return {roots.the_hole_value(), roots.the_hole_value()};
   }
@@ -6611,7 +6627,7 @@ Handle<Derived> ObjectMultiHashTableBase<Derived, N>::Put(
   ReadOnlyRoots roots(isolate);
   DCHECK(table->IsKey(roots, *key));
 
-  int32_t hash = key->GetOrCreateHash(isolate).value();
+  int32_t hash = Object::GetOrCreateHash(*key, isolate).value();
   InternalIndex entry = table->FindEntry(isolate, roots, key, hash);
 
   // Overwrite values if entry is found.
@@ -6642,7 +6658,7 @@ void ObjectMultiHashTableBase<Derived, N>::SetEntryValues(
 Handle<ObjectHashSet> ObjectHashSet::Add(Isolate* isolate,
                                          Handle<ObjectHashSet> set,
                                          Handle<Object> key) {
-  int32_t hash = key->GetOrCreateHash(isolate).value();
+  int32_t hash = Object::GetOrCreateHash(*key, isolate).value();
   if (!set->Has(isolate, key, hash)) {
     set = EnsureCapacity(isolate, set);
     InternalIndex entry = set->FindInsertionEntry(isolate, hash);
@@ -7080,7 +7096,7 @@ void JSFinalizationRegistry::RemoveCellFromUnregisterTokenMap(
     SimpleNumberDictionary key_map =
         SimpleNumberDictionary::cast(finalization_registry->key_map());
     HeapObject unregister_token = weak_cell->unregister_token();
-    uint32_t key = Smi::ToInt(unregister_token.GetHash());
+    uint32_t key = Smi::ToInt(Object::GetHash(unregister_token));
     InternalIndex entry = key_map->FindEntry(isolate, key);
     DCHECK(entry.is_found());
 
diff --git a/src/objects/objects.h b/src/objects/objects.h
index 6fa07e2ff70..13c463e73f9 100644
--- a/src/objects/objects.h
+++ b/src/objects/objects.h
@@ -314,9 +314,9 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
 
   // Whether the object is in the RO heap and the RO heap is shared, or in the
   // writable shared heap.
-  V8_INLINE bool InSharedHeap() const;
+  static V8_INLINE bool InSharedHeap(Tagged<Object> obj);
 
-  V8_INLINE bool InWritableSharedSpace() const;
+  static V8_INLINE bool InWritableSharedSpace(Tagged<Object> obj);
 
   enum class Conversion { kToNumber, kToNumeric };
 
@@ -325,24 +325,27 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
   V8_WARN_UNUSED_RESULT static Maybe<bool> IsArray(Handle<Object> object);
 
   // Extract the number.
-  inline double Number() const;
-  V8_EXPORT_PRIVATE bool ToInt32(int32_t* value);
-  inline bool ToUint32(uint32_t* value) const;
+  static inline double Number(Tagged<Object> obj);
+  V8_EXPORT_PRIVATE static bool ToInt32(Tagged<Object> obj, int32_t* value);
+  static inline bool ToUint32(Tagged<Object> obj, uint32_t* value);
 
-  inline Representation OptimalRepresentation(PtrComprCageBase cage_base) const;
+  static inline Representation OptimalRepresentation(
+      Tagged<Object> obj, PtrComprCageBase cage_base);
 
-  inline ElementsKind OptimalElementsKind(PtrComprCageBase cage_base) const;
+  static inline ElementsKind OptimalElementsKind(Tagged<Object> obj,
+                                                 PtrComprCageBase cage_base);
 
   // If {allow_coercion} is true, then a Smi will be considered to fit
   // a Double representation, since it can be converted to a HeapNumber
   // and stored.
-  inline bool FitsRepresentation(Representation representation,
-                                 bool allow_coercion = true) const;
+  static inline bool FitsRepresentation(Tagged<Object> obj,
+                                        Representation representation,
+                                        bool allow_coercion = true);
 
-  inline bool FilterKey(PropertyFilter filter);
+  static inline bool FilterKey(Tagged<Object> obj, PropertyFilter filter);
 
-  Handle<FieldType> OptimalType(Isolate* isolate,
-                                Representation representation);
+  static Handle<FieldType> OptimalType(Tagged<Object> obj, Isolate* isolate,
+                                       Representation representation);
 
   V8_EXPORT_PRIVATE static Handle<Object> NewStorageFor(
       Isolate* isolate, Handle<Object> object, Representation representation);
@@ -354,12 +357,13 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
 
   // Returns true if the object is of the correct type to be used as a
   // implementation of a JSObject's elements.
-  inline bool HasValidElements();
+  static inline bool HasValidElements(Tagged<Object> obj);
 
   // ECMA-262 9.2.
   template <typename IsolateT>
-  V8_EXPORT_PRIVATE bool BooleanValue(IsolateT* isolate);
-  Object ToBoolean(Isolate* isolate);
+  V8_EXPORT_PRIVATE static bool BooleanValue(Tagged<Object> obj,
+                                             IsolateT* isolate);
+  static Object ToBoolean(Tagged<Object> obj, Isolate* isolate);
 
   // ES6 section 7.2.11 Abstract Relational Comparison
   V8_EXPORT_PRIVATE V8_WARN_UNUSED_RESULT static Maybe<ComparisonResult>
@@ -370,7 +374,7 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
       Isolate* isolate, Handle<Object> x, Handle<Object> y);
 
   // ES6 section 7.2.13 Strict Equality Comparison
-  V8_EXPORT_PRIVATE bool StrictEquals(Object that);
+  V8_EXPORT_PRIVATE static bool StrictEquals(Tagged<Object> obj, Object that);
 
   // ES6 section 7.1.13 ToObject
   // Convert to a JSObject if needed.
@@ -559,17 +563,18 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
 
   // Returns the permanent hash code associated with this object. May return
   // undefined if not yet created.
-  inline Object GetHash();
+  static inline Object GetHash(Tagged<Object> obj);
 
   // Returns the permanent hash code associated with this object depending on
   // the actual object type. May create and store a hash code if needed and none
   // exists.
-  V8_EXPORT_PRIVATE Smi GetOrCreateHash(Isolate* isolate);
+  V8_EXPORT_PRIVATE static Smi GetOrCreateHash(Tagged<Object> obj,
+                                               Isolate* isolate);
 
   // Checks whether this object has the same value as the given one.  This
   // function is implemented according to ES5, section 9.12 and can be used
   // to implement the Object.is function.
-  V8_EXPORT_PRIVATE bool SameValue(Object other);
+  V8_EXPORT_PRIVATE static bool SameValue(Tagged<Object> obj, Object other);
 
   // A part of SameValue which handles Number vs. Number case.
   // Treats NaN == NaN and +0 != -0.
@@ -579,7 +584,7 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
   // +0 and -0 are treated equal. Everything else is the same as SameValue.
   // This function is implemented according to ES6, section 7.2.4 and is used
   // by ES6 Map and Set.
-  bool SameValueZero(Object other);
+  static bool SameValueZero(Tagged<Object> obj, Object other);
 
   // ES6 section 9.4.2.3 ArraySpeciesCreate (part of it)
   V8_WARN_UNUSED_RESULT static MaybeHandle<Object> ArraySpeciesConstructor(
@@ -592,31 +597,33 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
 
   // Tries to convert an object to an array length. Returns true and sets the
   // output parameter if it succeeds.
-  inline bool ToArrayLength(uint32_t* index) const;
+  static inline bool ToArrayLength(Tagged<Object> obj, uint32_t* index);
 
   // Tries to convert an object to an array index. Returns true and sets the
   // output parameter if it succeeds. Equivalent to ToArrayLength, but does not
   // allow kMaxUInt32.
-  V8_WARN_UNUSED_RESULT inline bool ToArrayIndex(uint32_t* index) const;
+  static V8_WARN_UNUSED_RESULT inline bool ToArrayIndex(Tagged<Object> obj,
+                                                        uint32_t* index);
 
   // Tries to convert an object to an index (in the range 0..size_t::max).
   // Returns true and sets the output parameter if it succeeds.
-  inline bool ToIntegerIndex(size_t* index) const;
+  static inline bool ToIntegerIndex(Tagged<Object> obj, size_t* index);
 
   // Returns true if the result of iterating over the object is the same
   // (including observable effects) as simply accessing the properties between 0
   // and length.
-  V8_EXPORT_PRIVATE bool IterationHasObservableEffects();
+  V8_EXPORT_PRIVATE static bool IterationHasObservableEffects(
+      Tagged<Object> obj);
 
   // TC39 "Dynamic Code Brand Checks"
-  bool IsCodeLike(Isolate* isolate) const;
+  static bool IsCodeLike(Tagged<Object> obj, Isolate* isolate);
 
-  EXPORT_DECL_VERIFIER(Object)
+  EXPORT_DECL_STATIC_VERIFIER(Object)
 
 #ifdef VERIFY_HEAP
   // Verify a pointer is a valid (non-InstructionStream) object pointer.
-  // When V8_EXTERNAL_CODE_SPACE is enabled InstructionStream objects are not
-  // allowed.
+  // When V8_EXTERNAL_CODE_SPACE is enabled InstructionStream objects are
+  // not allowed.
   static void VerifyPointer(Isolate* isolate, Object p);
   // Verify a pointer is a valid object pointer.
   // InstructionStream objects are allowed regardless of the
@@ -624,14 +631,6 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
   static void VerifyAnyTagged(Isolate* isolate, Object p);
 #endif
 
-  // Prints this object without details.
-  V8_EXPORT_PRIVATE void ShortPrint(FILE* out = stdout) const;
-
-  // Prints this object without details to a message accumulator.
-  V8_EXPORT_PRIVATE void ShortPrint(StringStream* accumulator) const;
-
-  V8_EXPORT_PRIVATE void ShortPrint(std::ostream& os) const;
-
   inline static constexpr Object cast(Object object) { return object; }
   inline static constexpr Object unchecked_cast(Object object) {
     return object;
@@ -640,17 +639,6 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
   // Layout description.
   static const int kHeaderSize = 0;  // Object does not take up any space.
 
-#ifdef OBJECT_PRINT
-  // For our gdb macros, we should perhaps change these in the future.
-  V8_EXPORT_PRIVATE void Print() const;
-
-  // Prints this object with details.
-  V8_EXPORT_PRIVATE void Print(std::ostream& os) const;
-#else
-  void Print() const { ShortPrint(); }
-  void Print(std::ostream& os) const { ShortPrint(os); }
-#endif
-
   // For use with std::unordered_set.
   struct Hasher {
     size_t operator()(const Object o) const {
@@ -691,7 +679,7 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
   // Whether this Object can be held weakly, i.e. whether it can be used as a
   // key in WeakMap, as a key in WeakSet, as the target of a WeakRef, or as a
   // target or unregister token of a FinalizationRegistry.
-  inline bool CanBeHeldWeakly() const;
+  static inline bool CanBeHeldWeakly(Tagged<Object> obj);
 
  protected:
   struct SkipTypeCheckTag {};
@@ -711,7 +699,7 @@ class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {
   friend class StringStream;
 
   // Return the map of the root of object's prototype chain.
-  Map GetPrototypeChainRootMap(Isolate* isolate) const;
+  static Map GetPrototypeChainRootMap(Tagged<Object> obj, Isolate* isolate);
 
   // Returns a non-SMI for JSReceivers, but returns the hash code forp
   // simple objects.  This avoids a double lookup in the cases where
@@ -873,6 +861,29 @@ inline bool IsShared(Tagged<Object> obj);
 inline bool IsApiCallResultType(Tagged<Object> obj);
 #endif  // DEBUG
 
+// Prints this object without details.
+// TODO(leszeks): Make these functions work on Tagged<Object>, once there is no
+// implicit conversion between Tagged and Object which makes them ambiguously
+// overload with the TaggedImpl overloads.
+V8_EXPORT_PRIVATE void ShortPrint(Object obj, FILE* out = stdout);
+
+// Prints this object without details to a message accumulator.
+V8_EXPORT_PRIVATE void ShortPrint(Object obj, StringStream* accumulator);
+
+V8_EXPORT_PRIVATE void ShortPrint(Object obj, std::ostream& os);
+
+#ifdef OBJECT_PRINT
+// For our gdb macros, we should perhaps change these in the future.
+V8_EXPORT_PRIVATE void Print(Object obj);
+
+// Prints this object with details.
+V8_EXPORT_PRIVATE void Print(Object obj, std::ostream& os);
+
+#else
+inline void Print(Object obj) { ShortPrint(obj); }
+inline void Print(Object obj, std::ostream& os) { ShortPrint(obj, os); }
+#endif
+
 // Heap objects typically have a map pointer in their first word.  However,
 // during GC other data (e.g. mark bits, forwarding addresses) is sometimes
 // encoded in the first word.  The class MapWord is an abstraction of the
diff --git a/src/objects/option-utils.cc b/src/objects/option-utils.cc
index d338ba10567..8d5b893df8e 100644
--- a/src/objects/option-utils.cc
+++ b/src/objects/option-utils.cc
@@ -114,7 +114,7 @@ V8_WARN_UNUSED_RESULT Maybe<bool> GetBoolOption(Isolate* isolate,
   // 2. If value is not undefined, then
   if (!IsUndefined(*value, isolate)) {
     // 2. b. i. Let value be ToBoolean(value).
-    *result = value->BooleanValue(isolate);
+    *result = Object::BooleanValue(*value, isolate);
 
     // 2. e. return value
     return Just(true);
@@ -138,8 +138,8 @@ Maybe<int> DefaultNumberOption(Isolate* isolate, Handle<Object> value, int min,
 
   // b. If value is NaN or less than minimum or greater than maximum, throw a
   // RangeError exception.
-  if (IsNaN(*value_num) || value_num->Number() < min ||
-      value_num->Number() > max) {
+  if (IsNaN(*value_num) || Object::Number(*value_num) < min ||
+      Object::Number(*value_num) > max) {
     THROW_NEW_ERROR_RETURN_VALUE(
         isolate,
         NewRangeError(MessageTemplate::kPropertyValueOutOfRange, property),
@@ -151,7 +151,7 @@ Maybe<int> DefaultNumberOption(Isolate* isolate, Handle<Object> value, int min,
   // int conversion safe.
   //
   // c. Return floor(value).
-  return Just(FastD2I(floor(value_num->Number())));
+  return Just(FastD2I(floor(Object::Number(*value_num))));
 }
 
 // ecma402/#sec-getnumberoption
@@ -196,7 +196,7 @@ Maybe<double> GetNumberOptionAsDouble(Isolate* isolate,
   }
 
   // 7. Return value.
-  return Just(value->Number());
+  return Just(Object::Number(*value));
 }
 
 }  // namespace internal
diff --git a/src/objects/option-utils.h b/src/objects/option-utils.h
index ea6cc76f4f6..2b542051efa 100644
--- a/src/objects/option-utils.h
+++ b/src/objects/option-utils.h
@@ -96,7 +96,7 @@ V8_WARN_UNUSED_RESULT static Maybe<T> GetStringOrBooleanOption(
     return Just(true_value);
   }
   // 4. Let valueBoolean be ToBoolean(value).
-  bool valueBoolean = value->BooleanValue(isolate);
+  bool valueBoolean = Object::BooleanValue(*value, isolate);
   // 5. If valueBoolean is false, then return valueBoolean.
   if (!valueBoolean) {
     return Just(false_value);
diff --git a/src/objects/ordered-hash-table.cc b/src/objects/ordered-hash-table.cc
index f4169cbe927..add1eac22af 100644
--- a/src/objects/ordered-hash-table.cc
+++ b/src/objects/ordered-hash-table.cc
@@ -152,7 +152,7 @@ InternalIndex OrderedHashTable<Derived, entrysize>::FindEntry(Isolate* isolate,
     raw_entry = HashToEntryRaw(hash & Smi::kMaxValue);
   } else {
     HandleScope scope(isolate);
-    Object hash = key.GetHash();
+    Object hash = Object::GetHash(key);
     // If the object does not have an identity hash, it was never used as a key
     if (IsUndefined(hash, isolate)) return InternalIndex::NotFound();
     raw_entry = HashToEntryRaw(Smi::ToInt(hash));
@@ -161,7 +161,8 @@ InternalIndex OrderedHashTable<Derived, entrysize>::FindEntry(Isolate* isolate,
   // Walk the chain in the bucket to find the key.
   while (raw_entry != kNotFound) {
     Object candidate_key = KeyAt(InternalIndex(raw_entry));
-    if (candidate_key.SameValueZero(key)) return InternalIndex(raw_entry);
+    if (Object::SameValueZero(candidate_key, key))
+      return InternalIndex(raw_entry);
     raw_entry = NextChainEntryRaw(raw_entry);
   }
 
@@ -176,14 +177,14 @@ MaybeHandle<OrderedHashSet> OrderedHashSet::Add(Isolate* isolate,
     DisallowGarbageCollection no_gc;
     Tagged<Object> raw_key = *key;
     Tagged<OrderedHashSet> raw_table = *table;
-    hash = raw_key->GetOrCreateHash(isolate).value();
+    hash = Object::GetOrCreateHash(*raw_key, isolate).value();
     if (raw_table->NumberOfElements() > 0) {
       int raw_entry = raw_table->HashToEntryRaw(hash);
       // Walk the chain of the bucket and try finding the key.
       while (raw_entry != kNotFound) {
         Object candidate_key = raw_table->KeyAt(InternalIndex(raw_entry));
         // Do not add if we have the key already
-        if (candidate_key.SameValueZero(raw_key)) return table;
+        if (Object::SameValueZero(candidate_key, raw_key)) return table;
         raw_entry = raw_table->NextChainEntryRaw(raw_entry);
       }
     }
@@ -227,7 +228,7 @@ Handle<FixedArray> OrderedHashSet::ConvertToKeysArray(
     Object key = table->get(index);
     uint32_t index_value;
     if (convert == GetKeysConversion::kConvertToString) {
-      if (key.ToArrayIndex(&index_value)) {
+      if (Object::ToArrayIndex(key, &index_value)) {
         // Avoid trashing the Number2String cache if indices get very large.
         bool use_cache = i < kMaxStringTableEntries;
         key = *isolate->factory()->Uint32ToString(index_value, use_cache);
@@ -235,7 +236,7 @@ Handle<FixedArray> OrderedHashSet::ConvertToKeysArray(
         CHECK(IsName(key));
       }
     } else if (convert == GetKeysConversion::kNoNumbers) {
-      DCHECK(!key.ToArrayIndex(&index_value));
+      DCHECK(!Object::ToArrayIndex(key, &index_value));
     }
     result->set(i, key);
   }
@@ -284,7 +285,7 @@ MaybeHandle<Derived> OrderedHashTable<Derived, entrysize>::Rehash(
       continue;
     }
 
-    Object hash = key.GetHash();
+    Object hash = Object::GetHash(key);
     int bucket = Smi::ToInt(hash) & (new_buckets - 1);
     Object chain_entry = new_table->get(HashTableStartIndex() + bucket);
     new_table->set(HashTableStartIndex() + bucket, Smi::FromInt(new_entry));
@@ -367,7 +368,7 @@ bool OrderedHashTable<Derived, entrysize>::Delete(Isolate* isolate,
 Address OrderedHashMap::GetHash(Isolate* isolate, Address raw_key) {
   DisallowGarbageCollection no_gc;
   Object key(raw_key);
-  Object hash = key.GetHash();
+  Object hash = Object::GetHash(key);
   // If the object does not have an identity hash, it was never used as a key
   if (IsUndefined(hash, isolate)) return Smi::FromInt(-1).ptr();
   DCHECK(IsSmi(hash));
@@ -379,7 +380,7 @@ MaybeHandle<OrderedHashMap> OrderedHashMap::Add(Isolate* isolate,
                                                 Handle<OrderedHashMap> table,
                                                 Handle<Object> key,
                                                 Handle<Object> value) {
-  int hash = key->GetOrCreateHash(isolate).value();
+  int hash = Object::GetOrCreateHash(*key, isolate).value();
   if (table->NumberOfElements() > 0) {
     int raw_entry = table->HashToEntryRaw(hash);
     // Walk the chain of the bucket and try finding the key.
@@ -389,7 +390,7 @@ MaybeHandle<OrderedHashMap> OrderedHashMap::Add(Isolate* isolate,
       while (raw_entry != kNotFound) {
         Object candidate_key = table->KeyAt(InternalIndex(raw_entry));
         // Do not add if we have the key already
-        if (candidate_key.SameValueZero(raw_key)) return table;
+        if (Object::SameValueZero(candidate_key, raw_key)) return table;
         raw_entry = table->NextChainEntryRaw(raw_entry);
       }
     }
@@ -706,7 +707,7 @@ MaybeHandle<SmallOrderedHashSet> SmallOrderedHashSet::Add(
 
   DisallowGarbageCollection no_gc;
   Tagged<SmallOrderedHashSet> raw_table = *table;
-  int hash = key->GetOrCreateHash(isolate).value();
+  int hash = Object::GetOrCreateHash(*key, isolate).value();
   int nof = raw_table->NumberOfElements();
 
   // Read the existing bucket values.
@@ -750,7 +751,7 @@ MaybeHandle<SmallOrderedHashMap> SmallOrderedHashMap::Add(
   }
   DisallowGarbageCollection no_gc;
   Tagged<SmallOrderedHashMap> raw_table = *table;
-  int hash = key->GetOrCreateHash(isolate).value();
+  int hash = Object::GetOrCreateHash(*key, isolate).value();
   int nof = raw_table->NumberOfElements();
 
   // Read the existing bucket values.
@@ -922,7 +923,7 @@ Handle<Derived> SmallOrderedHashTable<Derived>::Rehash(Isolate* isolate,
       Object key = table->KeyAt(old_entry);
       if (IsTheHole(key, isolate)) continue;
 
-      int hash = Smi::ToInt(key.GetHash());
+      int hash = Smi::ToInt(Object::GetHash(key));
       int bucket = new_table->HashToBucket(hash);
       int chain = new_table->GetFirstEntry(bucket);
 
@@ -1004,7 +1005,7 @@ template <class Derived>
 InternalIndex SmallOrderedHashTable<Derived>::FindEntry(Isolate* isolate,
                                                         Object key) {
   DisallowGarbageCollection no_gc;
-  Object hash = key.GetHash();
+  Object hash = Object::GetHash(key);
 
   if (IsUndefined(hash, isolate)) return InternalIndex::NotFound();
   int raw_entry = HashToFirstEntry(Smi::ToInt(hash));
@@ -1013,7 +1014,7 @@ InternalIndex SmallOrderedHashTable<Derived>::FindEntry(Isolate* isolate,
   while (raw_entry != kNotFound) {
     InternalIndex entry(raw_entry);
     Object candidate_key = KeyAt(entry);
-    if (candidate_key.SameValueZero(key)) return entry;
+    if (Object::SameValueZero(candidate_key, key)) return entry;
     raw_entry = GetNextEntry(raw_entry);
   }
   return InternalIndex::NotFound();
diff --git a/src/objects/property-descriptor.cc b/src/objects/property-descriptor.cc
index ead139b7776..0cc448ade68 100644
--- a/src/objects/property-descriptor.cc
+++ b/src/objects/property-descriptor.cc
@@ -94,13 +94,13 @@ bool ToPropertyDescriptorFastPath(Isolate* isolate, Handle<JSReceiver> obj,
     }
     Name key = descs->GetKey(i);
     if (key == roots.enumerable_string()) {
-      desc->set_enumerable(value->BooleanValue(isolate));
+      desc->set_enumerable(Object::BooleanValue(*value, isolate));
     } else if (key == roots.configurable_string()) {
-      desc->set_configurable(value->BooleanValue(isolate));
+      desc->set_configurable(Object::BooleanValue(*value, isolate));
     } else if (key == roots.value_string()) {
       desc->set_value(value);
     } else if (key == roots.writable_string()) {
-      desc->set_writable(value->BooleanValue(isolate));
+      desc->set_writable(Object::BooleanValue(*value, isolate));
     } else if (key == roots.get_string()) {
       // Bail out to slow path to throw an exception if necessary.
       if (!IsCallable(*value)) return false;
@@ -219,7 +219,7 @@ bool PropertyDescriptor::ToPropertyDescriptor(Isolate* isolate,
   }
   // 6c. Set the [[Enumerable]] field of desc to enum.
   if (!enumerable.is_null()) {
-    desc->set_enumerable(enumerable->BooleanValue(isolate));
+    desc->set_enumerable(Object::BooleanValue(*enumerable, isolate));
   }
 
   // configurable?
@@ -231,7 +231,7 @@ bool PropertyDescriptor::ToPropertyDescriptor(Isolate* isolate,
   }
   // 9c. Set the [[Configurable]] field of desc to conf.
   if (!configurable.is_null()) {
-    desc->set_configurable(configurable->BooleanValue(isolate));
+    desc->set_configurable(Object::BooleanValue(*configurable, isolate));
   }
 
   // value?
@@ -252,7 +252,8 @@ bool PropertyDescriptor::ToPropertyDescriptor(Isolate* isolate,
     return false;
   }
   // 15c. Set the [[Writable]] field of desc to writable.
-  if (!writable.is_null()) desc->set_writable(writable->BooleanValue(isolate));
+  if (!writable.is_null())
+    desc->set_writable(Object::BooleanValue(*writable, isolate));
 
   // getter?
   Handle<Object> getter;
diff --git a/src/objects/property.cc b/src/objects/property.cc
index af208c3a289..576a3970060 100644
--- a/src/objects/property.cc
+++ b/src/objects/property.cc
@@ -101,7 +101,7 @@ Descriptor Descriptor::DataConstant(Handle<Name> key, Handle<Object> value,
   return Descriptor(key, MaybeObjectHandle(value), PropertyKind::kData,
                     attributes, PropertyLocation::kDescriptor,
                     PropertyConstness::kConst,
-                    value->OptimalRepresentation(cage_base), 0);
+                    Object::OptimalRepresentation(*value, cage_base), 0);
 }
 
 Descriptor Descriptor::DataConstant(Isolate* isolate, Handle<Name> key,
diff --git a/src/objects/shared-function-info.cc b/src/objects/shared-function-info.cc
index 3d0f5490e55..ebc2c6c711f 100644
--- a/src/objects/shared-function-info.cc
+++ b/src/objects/shared-function-info.cc
@@ -364,7 +364,7 @@ void SharedFunctionInfo::DiscardCompiledMetadata(
     if (v8_flags.trace_flush_code) {
       CodeTracer::Scope scope(isolate->GetCodeTracer());
       PrintF(scope.file(), "[discarding compiled metadata for ");
-      ShortPrint(scope.file());
+      ShortPrint(*this, scope.file());
       PrintF(scope.file(), "]\n");
     }
 
@@ -517,7 +517,7 @@ void SharedFunctionInfo::DisableOptimization(Isolate* isolate,
   if (v8_flags.trace_opt) {
     CodeTracer::Scope scope(isolate->GetCodeTracer());
     PrintF(scope.file(), "[disabled optimization for ");
-    ShortPrint(scope.file());
+    ShortPrint(*this, scope.file());
     PrintF(scope.file(), ", reason: %s]\n", GetBailoutReason(reason));
   }
 }
diff --git a/src/objects/smi.h b/src/objects/smi.h
index 1fba3cbc63a..40c2de68b6f 100644
--- a/src/objects/smi.h
+++ b/src/objects/smi.h
@@ -90,7 +90,7 @@ class Smi : public Object {
 
   // Dispatched behavior.
   V8_EXPORT_PRIVATE void SmiPrint(std::ostream& os) const;
-  DECL_VERIFIER(Smi)
+  DECL_STATIC_VERIFIER(Smi)
 
   // Since this is a constexpr, "calling" it is just as efficient
   // as reading a constant.
diff --git a/src/objects/source-text-module.cc b/src/objects/source-text-module.cc
index 88812a9adc8..0889673bdb4 100644
--- a/src/objects/source-text-module.cc
+++ b/src/objects/source-text-module.cc
@@ -1025,7 +1025,8 @@ MaybeHandle<Object> SourceTextModule::ExecuteModule(
                          Execution::MessageHandling::kKeepPending, nullptr,
                          false),
       Object);
-  DCHECK(JSIteratorResult::cast(*result)->done().BooleanValue(isolate));
+  DCHECK(
+      Object::BooleanValue(JSIteratorResult::cast(*result)->done(), isolate));
   return handle(JSIteratorResult::cast(*result)->value(), isolate);
 }
 
diff --git a/src/objects/string-forwarding-table.cc b/src/objects/string-forwarding-table.cc
index 6f4abe68e7e..64e1f268df8 100644
--- a/src/objects/string-forwarding-table.cc
+++ b/src/objects/string-forwarding-table.cc
@@ -204,9 +204,9 @@ StringForwardingTable::BlockVector* StringForwardingTable::EnsureCapacity(
 
 int StringForwardingTable::AddForwardString(String string, String forward_to) {
   DCHECK_IMPLIES(!v8_flags.always_use_string_forwarding_table,
-                 string.InSharedHeap());
+                 Object::InSharedHeap(string));
   DCHECK_IMPLIES(!v8_flags.always_use_string_forwarding_table,
-                 forward_to.InSharedHeap());
+                 Object::InSharedHeap(forward_to));
   int index = next_free_index_++;
   uint32_t index_in_block;
   const uint32_t block_index = BlockForIndex(index, &index_in_block);
@@ -234,7 +234,7 @@ int StringForwardingTable::AddExternalResourceAndHash(String string,
       std::is_base_of_v<v8::String::ExternalOneByteStringResource, T>;
 
   DCHECK_IMPLIES(!v8_flags.always_use_string_forwarding_table,
-                 string.InSharedHeap());
+                 Object::InSharedHeap(string));
   int index = next_free_index_++;
   uint32_t index_in_block;
   const uint32_t block_index = BlockForIndex(index, &index_in_block);
diff --git a/src/objects/string-inl.h b/src/objects/string-inl.h
index eb4ac0479bc..188da6f2649 100644
--- a/src/objects/string-inl.h
+++ b/src/objects/string-inl.h
@@ -669,7 +669,7 @@ Handle<String> String::Flatten(Isolate* isolate, Handle<String> string,
   if (V8_LIKELY(shape.IsDirect())) return string;
 
   if (shape.IsCons()) {
-    DCHECK(!s.InSharedHeap());
+    DCHECK(!Object::InSharedHeap(s));
     ConsString cons = ConsString::cast(s);
     if (!cons->IsFlat(isolate)) {
       AllowGarbageCollection yes_gc;
@@ -798,7 +798,7 @@ Handle<String> String::Share(Isolate* isolate, Handle<String> string) {
     case StringTransitionStrategy::kInPlace:
       // A relaxed write is sufficient here, because at this point the string
       // has not yet escaped the current thread.
-      DCHECK(string->InSharedHeap());
+      DCHECK(Object::InSharedHeap(*string));
       string->set_map_no_write_barrier(*new_map.ToHandleChecked());
       return string;
     case StringTransitionStrategy::kAlreadyTransitioned:
@@ -875,7 +875,7 @@ bool String::IsShared() const { return IsShared(GetPtrComprCageBase(*this)); }
 
 bool String::IsShared(PtrComprCageBase cage_base) const {
   const bool result = StringShape(*this, cage_base).IsShared();
-  DCHECK_IMPLIES(result, InSharedHeap());
+  DCHECK_IMPLIES(result, Object::InSharedHeap(*this));
   return result;
 }
 
diff --git a/src/objects/string-table.cc b/src/objects/string-table.cc
index d7d6f1ddf21..83dc059d992 100644
--- a/src/objects/string-table.cc
+++ b/src/objects/string-table.cc
@@ -599,7 +599,7 @@ Handle<String> StringTable::LookupKey(IsolateT* isolate, StringTableKey* key) {
   if (entry.is_found()) {
     Handle<String> result(String::cast(current_data->Get(isolate, entry)),
                           isolate);
-    DCHECK_IMPLIES(v8_flags.shared_string_table, result->InSharedHeap());
+    DCHECK_IMPLIES(v8_flags.shared_string_table, Object::InSharedHeap(*result));
     return result;
   }
 
diff --git a/src/objects/string.cc b/src/objects/string.cc
index 4c31eb7b1e7..5102b96ab2f 100644
--- a/src/objects/string.cc
+++ b/src/objects/string.cc
@@ -35,7 +35,7 @@ namespace internal {
 Handle<String> String::SlowFlatten(Isolate* isolate, Handle<ConsString> cons,
                                    AllocationType allocation) {
   DCHECK_NE(cons->second()->length(), 0);
-  DCHECK(!cons->InSharedHeap());
+  DCHECK(!Object::InSharedHeap(*cons));
 
   // TurboFan can create cons strings with empty first parts.
   while (cons->first()->length() == 0) {
@@ -114,7 +114,7 @@ Handle<String> String::SlowShare(Isolate* isolate, Handle<String> source) {
     case StringTransitionStrategy::kInPlace:
       // A relaxed write is sufficient here, because at this point the string
       // has not yet escaped the current thread.
-      DCHECK(flat->InSharedHeap());
+      DCHECK(Object::InSharedHeap(*flat));
       flat->set_map_no_write_barrier(*new_map.ToHandleChecked());
       return flat;
     case StringTransitionStrategy::kAlreadyTransitioned:
diff --git a/src/objects/swiss-name-dictionary.cc b/src/objects/swiss-name-dictionary.cc
index b4ed96f9331..0f1d27593ad 100644
--- a/src/objects/swiss-name-dictionary.cc
+++ b/src/objects/swiss-name-dictionary.cc
@@ -257,7 +257,7 @@ int SwissNameDictionary::NumberOfEnumerableProperties() {
   for (InternalIndex i : this->IterateEntries()) {
     Object k;
     if (!this->ToKey(roots, i, &k)) continue;
-    if (k.FilterKey(ENUMERABLE_STRINGS)) continue;
+    if (Object::FilterKey(k, ENUMERABLE_STRINGS)) continue;
     PropertyDetails details = this->DetailsAt(i);
     PropertyAttributes attr = details.attributes();
     if ((int{attr} & ONLY_ENUMERABLE) == 0) result++;
diff --git a/src/objects/tagged-impl.cc b/src/objects/tagged-impl.cc
index 02a183cf95c..00359c4fdaf 100644
--- a/src/objects/tagged-impl.cc
+++ b/src/objects/tagged-impl.cc
@@ -38,49 +38,69 @@ bool CheckObjectComparisonAllowed(Address a, Address b) {
 #endif  // V8_EXTERNAL_CODE_SPACE
 
 template <HeapObjectReferenceType kRefType, typename StorageType>
-void TaggedImpl<kRefType, StorageType>::ShortPrint(FILE* out) {
+void ShortPrint(TaggedImpl<kRefType, StorageType> ptr, FILE* out) {
   OFStream os(out);
-  os << Brief(*this);
+  os << Brief(ptr);
 }
+template void ShortPrint(
+    TaggedImpl<HeapObjectReferenceType::STRONG, Address> ptr, FILE* out);
+template void ShortPrint(TaggedImpl<HeapObjectReferenceType::WEAK, Address> ptr,
+                         FILE* out);
 
 template <HeapObjectReferenceType kRefType, typename StorageType>
-void TaggedImpl<kRefType, StorageType>::ShortPrint(StringStream* accumulator) {
+void ShortPrint(TaggedImpl<kRefType, StorageType> ptr,
+                StringStream* accumulator) {
   std::ostringstream os;
-  os << Brief(*this);
+  os << Brief(ptr);
   accumulator->Add(os.str().c_str());
 }
+template void ShortPrint(
+    TaggedImpl<HeapObjectReferenceType::STRONG, Address> ptr,
+    StringStream* accumulator);
+template void ShortPrint(TaggedImpl<HeapObjectReferenceType::WEAK, Address> ptr,
+                         StringStream* accumulator);
 
 template <HeapObjectReferenceType kRefType, typename StorageType>
-void TaggedImpl<kRefType, StorageType>::ShortPrint(std::ostream& os) {
-  os << Brief(*this);
+void ShortPrint(TaggedImpl<kRefType, StorageType> ptr, std::ostream& os) {
+  os << Brief(ptr);
 }
+template void ShortPrint(
+    TaggedImpl<HeapObjectReferenceType::STRONG, Address> ptr, std::ostream& os);
+template void ShortPrint(TaggedImpl<HeapObjectReferenceType::WEAK, Address> ptr,
+                         std::ostream& os);
 
 #ifdef OBJECT_PRINT
 template <HeapObjectReferenceType kRefType, typename StorageType>
-void TaggedImpl<kRefType, StorageType>::Print() {
+void Print(TaggedImpl<kRefType, StorageType> ptr) {
   StdoutStream os;
-  this->Print(os);
+  Print(ptr, os);
   os << std::flush;
 }
+template void Print(TaggedImpl<HeapObjectReferenceType::STRONG, Address> ptr);
+template void Print(TaggedImpl<HeapObjectReferenceType::WEAK, Address> ptr);
 
 template <HeapObjectReferenceType kRefType, typename StorageType>
-void TaggedImpl<kRefType, StorageType>::Print(std::ostream& os) {
+void Print(TaggedImpl<kRefType, StorageType> ptr, std::ostream& os) {
   Smi smi(0);
   HeapObject heap_object;
-  if (ToSmi(&smi)) {
+  if (ptr.ToSmi(&smi)) {
     os << "Smi: " << std::hex << "0x" << smi.value();
     os << std::dec << " (" << smi.value() << ")\n";
-  } else if (IsCleared()) {
+  } else if (ptr.IsCleared()) {
     os << "[cleared]";
-  } else if (GetHeapObjectIfWeak(&heap_object)) {
+  } else if (ptr.GetHeapObjectIfWeak(&heap_object)) {
     os << "[weak] ";
     heap_object->HeapObjectPrint(os);
-  } else if (GetHeapObjectIfStrong(&heap_object)) {
+  } else if (ptr.GetHeapObjectIfStrong(&heap_object)) {
     heap_object->HeapObjectPrint(os);
   } else {
     UNREACHABLE();
   }
 }
+template void Print(TaggedImpl<HeapObjectReferenceType::STRONG, Address> ptr,
+                    std::ostream& os);
+template void Print(TaggedImpl<HeapObjectReferenceType::WEAK, Address> ptr,
+                    std::ostream& os);
 #endif  // OBJECT_PRINT
 
 // Explicit instantiation declarations.
diff --git a/src/objects/tagged-impl.h b/src/objects/tagged-impl.h
index 2505c153ba7..14011545b28 100644
--- a/src/objects/tagged-impl.h
+++ b/src/objects/tagged-impl.h
@@ -6,6 +6,7 @@
 #define V8_OBJECTS_TAGGED_IMPL_H_
 
 #include "include/v8-internal.h"
+#include "src/base/macros.h"
 #include "src/common/checks.h"
 #include "src/common/globals.h"
 
@@ -210,22 +211,6 @@ class TaggedImpl {
     return T::cast(Object(ptr_));
   }
 
-  // Prints this object without details.
-  void ShortPrint(FILE* out = stdout);
-
-  // Prints this object without details to a message accumulator.
-  void ShortPrint(StringStream* accumulator);
-
-  void ShortPrint(std::ostream& os);
-
-#ifdef OBJECT_PRINT
-  void Print();
-  void Print(std::ostream& os);
-#else
-  void Print() { ShortPrint(); }
-  void Print(std::ostream& os) { ShortPrint(os); }
-#endif
-
  private:
   friend class CompressedObjectSlot;
   friend class FullObjectSlot;
@@ -233,6 +218,34 @@ class TaggedImpl {
   StorageType ptr_;
 };
 
+// Prints this object without details.
+template <HeapObjectReferenceType kRefType, typename StorageType>
+void ShortPrint(TaggedImpl<kRefType, StorageType> ptr, FILE* out = stdout);
+
+// Prints this object without details to a message accumulator.
+template <HeapObjectReferenceType kRefType, typename StorageType>
+void ShortPrint(TaggedImpl<kRefType, StorageType> ptr,
+                StringStream* accumulator);
+
+template <HeapObjectReferenceType kRefType, typename StorageType>
+void ShortPrint(TaggedImpl<kRefType, StorageType> ptr, std::ostream& os);
+
+#ifdef OBJECT_PRINT
+template <HeapObjectReferenceType kRefType, typename StorageType>
+void Print(TaggedImpl<kRefType, StorageType> ptr);
+template <HeapObjectReferenceType kRefType, typename StorageType>
+void Print(TaggedImpl<kRefType, StorageType> ptr, std::ostream& os);
+#else
+template <HeapObjectReferenceType kRefType, typename StorageType>
+void Print(TaggedImpl<kRefType, StorageType> ptr) {
+  ShortPrint(ptr);
+}
+template <HeapObjectReferenceType kRefType, typename StorageType>
+void Print(TaggedImpl<kRefType, StorageType> ptr, std::ostream& os) {
+  ShortPrint(ptr, os);
+}
+#endif
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/objects/tagged-index.h b/src/objects/tagged-index.h
index 451b918214d..f17c72ba8a9 100644
--- a/src/objects/tagged-index.h
+++ b/src/objects/tagged-index.h
@@ -63,7 +63,7 @@ class TaggedIndex : public Object {
   DECL_CAST(TaggedIndex)
 
   // Dispatched behavior.
-  DECL_VERIFIER(TaggedIndex)
+  DECL_STATIC_VERIFIER(TaggedIndex)
 
   static_assert(kSmiTagSize == 1);
   static constexpr int kTaggedValueSize = 31;
diff --git a/src/objects/value-serializer.cc b/src/objects/value-serializer.cc
index 13f6e1fc6ea..4658492965e 100644
--- a/src/objects/value-serializer.cc
+++ b/src/objects/value-serializer.cc
@@ -707,7 +707,7 @@ Maybe<bool> ValueSerializer::WriteJSObjectSlow(Handle<JSObject> object) {
 Maybe<bool> ValueSerializer::WriteJSArray(Handle<JSArray> array) {
   PtrComprCageBase cage_base(isolate_);
   uint32_t length = 0;
-  bool valid_length = array->length().ToArrayLength(&length);
+  bool valid_length = Object::ToArrayLength(array->length(), &length);
   DCHECK(valid_length);
   USE(valid_length);
 
@@ -820,7 +820,7 @@ Maybe<bool> ValueSerializer::WriteJSArray(Handle<JSArray> array) {
 
 void ValueSerializer::WriteJSDate(JSDate date) {
   WriteTag(SerializationTag::kDate);
-  WriteDouble(date->value().Number());
+  WriteDouble(Object::Number(date->value()));
 }
 
 Maybe<bool> ValueSerializer::WriteJSPrimitiveWrapper(
@@ -835,7 +835,7 @@ Maybe<bool> ValueSerializer::WriteJSPrimitiveWrapper(
       WriteTag(SerializationTag::kFalseObject);
     } else if (IsNumber(inner_value, cage_base)) {
       WriteTag(SerializationTag::kNumberObject);
-      WriteDouble(inner_value.Number());
+      WriteDouble(Object::Number(inner_value));
     } else if (IsBigInt(inner_value, cage_base)) {
       WriteTag(SerializationTag::kBigIntObject);
       WriteBigIntContents(BigInt::cast(inner_value));
@@ -1530,7 +1530,7 @@ MaybeHandle<Object> ValueDeserializer::ReadObject() {
 #if defined(DEBUG) && defined(VERIFY_HEAP)
   if (!result.is_null() && v8_flags.enable_slow_asserts &&
       v8_flags.verify_heap) {
-    object->ObjectVerify(isolate_);
+    Object::ObjectVerify(*object, isolate_);
   }
 #endif
 
@@ -2504,13 +2504,13 @@ Maybe<uint32_t> ValueDeserializer::ReadJSObjectProperties(
           PropertyDetails details =
               target->instance_descriptors(isolate_)->GetDetails(descriptor);
           Representation expected_representation = details.representation();
-          if (value->FitsRepresentation(expected_representation)) {
+          if (Object::FitsRepresentation(*value, expected_representation)) {
             if (expected_representation.IsHeapObject() &&
                 !target->instance_descriptors(isolate_)
                      ->GetFieldType(descriptor)
                      .NowContains(value)) {
-              Handle<FieldType> value_type =
-                  value->OptimalType(isolate_, expected_representation);
+              Handle<FieldType> value_type = Object::OptimalType(
+                  *value, isolate_, expected_representation);
               MapUpdater::GeneralizeField(isolate_, target, descriptor,
                                           details.constness(),
                                           expected_representation, value_type);
diff --git a/src/profiler/heap-snapshot-generator.cc b/src/profiler/heap-snapshot-generator.cc
index 666f057c970..5a05c012516 100644
--- a/src/profiler/heap-snapshot-generator.cc
+++ b/src/profiler/heap-snapshot-generator.cc
@@ -2019,7 +2019,7 @@ void V8HeapExplorer::ExtractElementReferences(JSObject js_obj,
       Object k = dictionary->KeyAt(i);
       if (!dictionary.IsKey(roots, k)) continue;
       DCHECK(IsNumber(k));
-      uint32_t index = static_cast<uint32_t>(k.Number());
+      uint32_t index = static_cast<uint32_t>(Object::Number(k));
       SetElementReference(entry, index, dictionary->ValueAt(i));
     }
   }
diff --git a/src/runtime/runtime-array.cc b/src/runtime/runtime-array.cc
index a322011d4a0..2f6271f8300 100644
--- a/src/runtime/runtime-array.cc
+++ b/src/runtime/runtime-array.cc
@@ -237,7 +237,8 @@ RUNTIME_FUNCTION(Runtime_ArrayIncludes_Slow) {
   {
     if (object->map()->instance_type() == JS_ARRAY_TYPE) {
       uint32_t len32 = 0;
-      bool success = JSArray::cast(*object)->length().ToArrayLength(&len32);
+      bool success =
+          Object::ToArrayLength(JSArray::cast(*object)->length(), &len32);
       DCHECK(success);
       USE(success);
       len = len32;
@@ -250,8 +251,8 @@ RUNTIME_FUNCTION(Runtime_ArrayIncludes_Slow) {
 
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, len_,
                                          Object::ToLength(isolate, len_));
-      len = static_cast<int64_t>(len_->Number());
-      DCHECK_EQ(len, len_->Number());
+      len = static_cast<int64_t>(Object::Number(*len_));
+      DCHECK_EQ(len, Object::Number(*len_));
     }
   }
 
@@ -273,7 +274,7 @@ RUNTIME_FUNCTION(Runtime_ArrayIncludes_Slow) {
       }
     } else {
       DCHECK(IsHeapNumber(*from_index));
-      double start_from = from_index->Number();
+      double start_from = Object::Number(*from_index);
       if (start_from >= len) return ReadOnlyRoots(isolate).false_value();
       if (V8_LIKELY(std::isfinite(start_from))) {
         if (start_from < 0) {
@@ -314,7 +315,7 @@ RUNTIME_FUNCTION(Runtime_ArrayIncludes_Slow) {
     }
 
     // If SameValueZero(searchElement, elementK) is true, return true.
-    if (search_element->SameValueZero(*element_k)) {
+    if (Object::SameValueZero(*search_element, *element_k)) {
       return ReadOnlyRoots(isolate).true_value();
     }
   }
@@ -338,7 +339,8 @@ RUNTIME_FUNCTION(Runtime_ArrayIndexOf) {
   {
     if (IsJSArray(*object)) {
       uint32_t len32 = 0;
-      bool success = JSArray::cast(*object)->length().ToArrayLength(&len32);
+      bool success =
+          Object::ToArrayLength(JSArray::cast(*object)->length(), &len32);
       DCHECK(success);
       USE(success);
       len = len32;
@@ -351,8 +353,8 @@ RUNTIME_FUNCTION(Runtime_ArrayIndexOf) {
 
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, len_,
                                          Object::ToLength(isolate, len_));
-      len = static_cast<int64_t>(len_->Number());
-      DCHECK_EQ(len, len_->Number());
+      len = static_cast<int64_t>(Object::Number(*len_));
+      DCHECK_EQ(len, Object::Number(*len_));
     }
   }
 
@@ -364,7 +366,7 @@ RUNTIME_FUNCTION(Runtime_ArrayIndexOf) {
   {
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, from_index,
                                        Object::ToInteger(isolate, from_index));
-    double fp = from_index->Number();
+    double fp = Object::Number(*from_index);
     if (fp > len) return Smi::FromInt(-1);
     if (V8_LIKELY(fp >=
                   static_cast<double>(std::numeric_limits<int64_t>::min()))) {
@@ -411,7 +413,7 @@ RUNTIME_FUNCTION(Runtime_ArrayIndexOf) {
       if (!present.FromJust()) continue;
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, element_k,
                                          Object::GetProperty(&it));
-      if (search_element->StrictEquals(*element_k)) {
+      if (Object::StrictEquals(*search_element, *element_k)) {
         return *isolate->factory()->NewNumberFromInt64(index);
       }
     }
diff --git a/src/runtime/runtime-classes.cc b/src/runtime/runtime-classes.cc
index 7b8b802bc22..ae634d15c68 100644
--- a/src/runtime/runtime-classes.cc
+++ b/src/runtime/runtime-classes.cc
@@ -325,7 +325,7 @@ bool AddDescriptorsByTemplate(
           value = GetMethodWithSharedName(isolate, args, value);
         }
         details = details.CopyWithRepresentation(
-            value.OptimalRepresentation(isolate));
+            Object::OptimalRepresentation(value, isolate));
       } else {
         DCHECK_EQ(PropertyKind::kAccessor, details.kind());
         if (IsAccessorPair(value)) {
@@ -343,7 +343,7 @@ bool AddDescriptorsByTemplate(
     } else {
       UNREACHABLE();
     }
-    DCHECK(value.FitsRepresentation(details.representation()));
+    DCHECK(Object::FitsRepresentation(value, details.representation()));
     if (details.location() == PropertyLocation::kDescriptor &&
         details.kind() == PropertyKind::kData) {
       details =
diff --git a/src/runtime/runtime-collections.cc b/src/runtime/runtime-collections.cc
index b71d7978404..aebb8a3ac6e 100644
--- a/src/runtime/runtime-collections.cc
+++ b/src/runtime/runtime-collections.cc
@@ -115,7 +115,7 @@ RUNTIME_FUNCTION(Runtime_WeakCollectionDelete) {
   int hash = args.smi_value_at(2);
 
 #ifdef DEBUG
-  DCHECK(key->CanBeHeldWeakly());
+  DCHECK(Object::CanBeHeldWeakly(*key));
   DCHECK(EphemeronHashTable::IsKey(ReadOnlyRoots(isolate), *key));
   Handle<EphemeronHashTable> table(
       EphemeronHashTable::cast(weak_collection->table()), isolate);
@@ -138,7 +138,7 @@ RUNTIME_FUNCTION(Runtime_WeakCollectionSet) {
   int hash = args.smi_value_at(3);
 
 #ifdef DEBUG
-  DCHECK(key->CanBeHeldWeakly());
+  DCHECK(Object::CanBeHeldWeakly(*key));
   DCHECK(EphemeronHashTable::IsKey(ReadOnlyRoots(isolate), *key));
   Handle<EphemeronHashTable> table(
       EphemeronHashTable::cast(weak_collection->table()), isolate);
diff --git a/src/runtime/runtime-internal.cc b/src/runtime/runtime-internal.cc
index d482a3ce174..c9e7a1b02f1 100644
--- a/src/runtime/runtime-internal.cc
+++ b/src/runtime/runtime-internal.cc
@@ -816,7 +816,7 @@ RUNTIME_FUNCTION(Runtime_DoubleToStringWithRadix) {
   DCHECK_EQ(2, args.length());
   double number = args.number_value_at(0);
   int32_t radix = 0;
-  CHECK(args[1].ToInt32(&radix));
+  CHECK(Object::ToInt32(args[1], &radix));
 
   char* const str = DoubleToRadixCString(number, radix);
   Handle<String> result = isolate->factory()->NewStringFromAsciiChecked(str);
diff --git a/src/runtime/runtime-literals.cc b/src/runtime/runtime-literals.cc
index 280da2011aa..ba056a9e22b 100644
--- a/src/runtime/runtime-literals.cc
+++ b/src/runtime/runtime-literals.cc
@@ -422,7 +422,7 @@ Handle<JSObject> CreateObjectLiteral(
     }
 
     uint32_t element_index = 0;
-    if (key->ToArrayIndex(&element_index)) {
+    if (Object::ToArrayIndex(*key, &element_index)) {
       // Array index (uint32).
       if (IsUninitialized(*value, isolate)) {
         value = handle(Smi::zero(), isolate);
diff --git a/src/runtime/runtime-numbers.cc b/src/runtime/runtime-numbers.cc
index b5318221e0d..eee0b01d891 100644
--- a/src/runtime/runtime-numbers.cc
+++ b/src/runtime/runtime-numbers.cc
@@ -35,7 +35,7 @@ RUNTIME_FUNCTION(Runtime_StringParseInt) {
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(isolate, radix,
                                        Object::ToNumber(isolate, radix));
   }
-  int radix32 = DoubleToInt32(radix->Number());
+  int radix32 = DoubleToInt32(Object::Number(*radix));
   if (radix32 != 0 && (radix32 < 2 || radix32 > 36)) {
     return ReadOnlyRoots(isolate).nan_value();
   }
diff --git a/src/runtime/runtime-object.cc b/src/runtime/runtime-object.cc
index d3aa7380e15..a06865356b6 100644
--- a/src/runtime/runtime-object.cc
+++ b/src/runtime/runtime-object.cc
@@ -1424,8 +1424,8 @@ RUNTIME_FUNCTION(Runtime_CreateIterResultObject) {
   DCHECK_EQ(2, args.length());
   Handle<Object> value = args.at(0);
   Handle<Object> done = args.at(1);
-  return *isolate->factory()->NewJSIteratorResult(value,
-                                                  done->BooleanValue(isolate));
+  return *isolate->factory()->NewJSIteratorResult(
+      value, Object::BooleanValue(*done, isolate));
 }
 
 RUNTIME_FUNCTION(Runtime_CreateDataProperty) {
diff --git a/src/runtime/runtime-operators.cc b/src/runtime/runtime-operators.cc
index 1d44f671b20..d009f770da6 100644
--- a/src/runtime/runtime-operators.cc
+++ b/src/runtime/runtime-operators.cc
@@ -43,7 +43,7 @@ RUNTIME_FUNCTION(Runtime_StrictEqual) {
   DCHECK_EQ(2, args.length());
   Object x = args[0];
   Object y = args[1];
-  return isolate->heap()->ToBoolean(x.StrictEquals(y));
+  return isolate->heap()->ToBoolean(Object::StrictEquals(x, y));
 }
 
 RUNTIME_FUNCTION(Runtime_StrictNotEqual) {
@@ -51,7 +51,7 @@ RUNTIME_FUNCTION(Runtime_StrictNotEqual) {
   DCHECK_EQ(2, args.length());
   Object x = args[0];
   Object y = args[1];
-  return isolate->heap()->ToBoolean(!x.StrictEquals(y));
+  return isolate->heap()->ToBoolean(!Object::StrictEquals(x, y));
 }
 
 RUNTIME_FUNCTION(Runtime_ReferenceEqual) {
diff --git a/src/runtime/runtime-promise.cc b/src/runtime/runtime-promise.cc
index 62aa80bf8bf..61b313c938b 100644
--- a/src/runtime/runtime-promise.cc
+++ b/src/runtime/runtime-promise.cc
@@ -142,7 +142,7 @@ RUNTIME_FUNCTION(Runtime_RejectPromise) {
   Handle<Object> reason = args.at(1);
   Handle<Boolean> debug_event = args.at<Boolean>(2);
   return *JSPromise::Reject(promise, reason,
-                            debug_event->BooleanValue(isolate));
+                            Object::BooleanValue(*debug_event, isolate));
 }
 
 RUNTIME_FUNCTION(Runtime_ResolvePromise) {
diff --git a/src/runtime/runtime-regexp.cc b/src/runtime/runtime-regexp.cc
index 22a98808450..0095b6f2b54 100644
--- a/src/runtime/runtime-regexp.cc
+++ b/src/runtime/runtime-regexp.cc
@@ -915,7 +915,7 @@ RUNTIME_FUNCTION(Runtime_RegExpExec) {
   Handle<JSRegExp> regexp = args.at<JSRegExp>(0);
   Handle<String> subject = args.at<String>(1);
   int32_t index = 0;
-  CHECK(args[2].ToInt32(&index));
+  CHECK(Object::ToInt32(args[2], &index));
   Handle<RegExpMatchInfo> last_match_info = args.at<RegExpMatchInfo>(3);
   RETURN_RESULT_OR_FAILURE(
       isolate, RegExpExec(isolate, regexp, subject, index, last_match_info,
@@ -928,7 +928,7 @@ RUNTIME_FUNCTION(Runtime_RegExpExecTreatMatchAtEndAsFailure) {
   Handle<JSRegExp> regexp = args.at<JSRegExp>(0);
   Handle<String> subject = args.at<String>(1);
   int32_t index = 0;
-  CHECK(args[2].ToInt32(&index));
+  CHECK(Object::ToInt32(args[2], &index));
   Handle<RegExpMatchInfo> last_match_info = args.at<RegExpMatchInfo>(3);
   RETURN_RESULT_OR_FAILURE(
       isolate, RegExpExec(isolate, regexp, subject, index, last_match_info,
@@ -941,7 +941,7 @@ RUNTIME_FUNCTION(Runtime_RegExpExperimentalOneshotExec) {
   Handle<JSRegExp> regexp = args.at<JSRegExp>(0);
   Handle<String> subject = args.at<String>(1);
   int32_t index = 0;
-  CHECK(args[2].ToInt32(&index));
+  CHECK(Object::ToInt32(args[2], &index));
   Handle<RegExpMatchInfo> last_match_info = args.at<RegExpMatchInfo>(3);
   RETURN_RESULT_OR_FAILURE(
       isolate,
@@ -956,7 +956,7 @@ RUNTIME_FUNCTION(
   Handle<JSRegExp> regexp = args.at<JSRegExp>(0);
   Handle<String> subject = args.at<String>(1);
   int32_t index = 0;
-  CHECK(args[2].ToInt32(&index));
+  CHECK(Object::ToInt32(args[2], &index));
   Handle<RegExpMatchInfo> last_match_info = args.at<RegExpMatchInfo>(3);
   RETURN_RESULT_OR_FAILURE(
       isolate,
@@ -1821,7 +1821,7 @@ RUNTIME_FUNCTION(Runtime_RegExpReplaceRT) {
   ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
       isolate, global_obj,
       JSReceiver::GetProperty(isolate, recv, factory->global_string()));
-  const bool global = global_obj->BooleanValue(isolate);
+  const bool global = Object::BooleanValue(*global_obj, isolate);
 
   bool unicode = false;
   if (global) {
@@ -1829,7 +1829,7 @@ RUNTIME_FUNCTION(Runtime_RegExpReplaceRT) {
     ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
         isolate, unicode_obj,
         JSReceiver::GetProperty(isolate, recv, factory->unicode_string()));
-    unicode = unicode_obj->BooleanValue(isolate);
+    unicode = Object::BooleanValue(*unicode_obj, isolate);
 
     RETURN_FAILURE_ON_EXCEPTION(isolate,
                                 RegExpUtils::SetLastIndex(isolate, recv, 0));
diff --git a/src/runtime/runtime-test-wasm.cc b/src/runtime/runtime-test-wasm.cc
index 5f4405e1f25..54ce7d67285 100644
--- a/src/runtime/runtime-test-wasm.cc
+++ b/src/runtime/runtime-test-wasm.cc
@@ -552,7 +552,7 @@ RUNTIME_FUNCTION(Runtime_FreezeWasmLazyCompilation) {
 // callback and thereby bypasses the value in v8_flags.
 RUNTIME_FUNCTION(Runtime_SetWasmGCEnabled) {
   DCHECK_EQ(1, args.length());
-  bool enable = args.at(0)->BooleanValue(isolate);
+  bool enable = Object::BooleanValue(*args.at(0), isolate);
   v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(isolate);
   WasmGCEnabledCallback enabled = [](v8::Local<v8::Context>) { return true; };
   WasmGCEnabledCallback disabled = [](v8::Local<v8::Context>) { return false; };
diff --git a/src/runtime/runtime-test.cc b/src/runtime/runtime-test.cc
index 48c8e7b7dd8..20add73b6d3 100644
--- a/src/runtime/runtime-test.cc
+++ b/src/runtime/runtime-test.cc
@@ -79,7 +79,7 @@ V8_WARN_UNUSED_RESULT Object ReturnFuzzSafe(Object value, Isolate* isolate) {
 #define CONVERT_INT32_ARG_FUZZ_SAFE(name, index)                  \
   if (!IsNumber(args[index])) return CrashUnlessFuzzing(isolate); \
   int32_t name = 0;                                               \
-  if (!args[index].ToInt32(&name)) return CrashUnlessFuzzing(isolate);
+  if (!Object::ToInt32(args[index], &name)) return CrashUnlessFuzzing(isolate);
 
 // Cast the given object to a boolean and store it in a variable with
 // the given name.  If the object is not a boolean we crash if not in
@@ -1222,9 +1222,9 @@ static void DebugPrintImpl(MaybeObject maybe_object, std::ostream& os) {
 #ifdef OBJECT_PRINT
     os << "DebugPrint: ";
     if (weak) os << "[weak] ";
-    object.Print(os);
+    Print(object, os);
     if (IsHeapObject(object)) {
-      HeapObject::cast(object)->map().Print(os);
+      Print(HeapObject::cast(object)->map(), os);
     }
 #else
     if (weak) os << "[weak] ";
@@ -1266,7 +1266,7 @@ RUNTIME_FUNCTION(Runtime_DebugPrintPtr) {
   if (!maybe_object.IsCleared()) {
     Object object = maybe_object.GetHeapObjectOrSmi();
     size_t pointer;
-    if (object.ToIntegerIndex(&pointer)) {
+    if (Object::ToIntegerIndex(object, &pointer)) {
       MaybeObject from_pointer(static_cast<Address>(pointer));
       DebugPrintImpl(from_pointer, os);
     }
@@ -1352,7 +1352,7 @@ RUNTIME_FUNCTION(Runtime_PrintWithNameForAssert) {
     PrintF("%c", character);
   }
   PrintF(": ");
-  args[1].ShortPrint();
+  ShortPrint(args[1]);
   PrintF("\n");
 
   return ReadOnlyRoots(isolate).undefined_value();
@@ -1502,7 +1502,7 @@ RUNTIME_FUNCTION(Runtime_DisassembleFunction) {
         Compiler::Compile(isolate, func, Compiler::KEEP_EXCEPTION,
                           &is_compiled_scope));
   StdoutStream os;
-  func->code().Print(os);
+  Print(func->code(), os);
   os << std::endl;
 #endif  // DEBUG
   return ReadOnlyRoots(isolate).undefined_value();
@@ -1546,7 +1546,7 @@ RUNTIME_FUNCTION(Runtime_TraceExit) {
   Object obj = args[0];
   PrintIndentation(StackSize(isolate));
   PrintF("} -> ");
-  obj.ShortPrint();
+  ShortPrint(obj);
   PrintF("\n");
   return obj;  // return TOS
 }
@@ -1853,9 +1853,9 @@ RUNTIME_FUNCTION(Runtime_HeapObjectVerify) {
   }
   Handle<Object> object = args.at(0);
 #ifdef VERIFY_HEAP
-  object->ObjectVerify(isolate);
+  Object::ObjectVerify(*object, isolate);
 #else
-  CHECK(object->IsObject());
+  CHECK(IsObject(**object));
   if (IsHeapObject(*object)) {
     CHECK(IsMap(HeapObject::cast(*object).map()));
   } else {
diff --git a/src/runtime/runtime-trace.cc b/src/runtime/runtime-trace.cc
index 07641b3d4a6..876e48032e9 100644
--- a/src/runtime/runtime-trace.cc
+++ b/src/runtime/runtime-trace.cc
@@ -47,7 +47,7 @@ void PrintRegisterRange(UnoptimizedFrame* frame, std::ostream& os,
     Object reg_object = frame->ReadInterpreterRegister(reg_index);
     os << "      [ " << std::setw(reg_field_width)
        << interpreter::Register(reg_index).ToString() << arrow_direction;
-    reg_object.ShortPrint(os);
+    ShortPrint(reg_object, os);
     os << " ]" << std::endl;
   }
 }
@@ -72,7 +72,7 @@ void PrintRegisters(UnoptimizedFrame* frame, std::ostream& os, bool is_input,
       (!is_input &&
        interpreter::Bytecodes::WritesOrClobbersAccumulator(bytecode))) {
     os << "      [ " << kAccumulator << kArrowDirection;
-    accumulator->ShortPrint(os);
+    ShortPrint(*accumulator, os);
     os << " ]" << std::endl;
   }
 
@@ -214,7 +214,7 @@ RUNTIME_FUNCTION(Runtime_TraceUpdateFeedback) {
 
   StdoutStream os;
   os << "[Feedback slot " << slot << "/" << slot_count << " in ";
-  function->shared().ShortPrint(os);
+  ShortPrint(function->shared(), os);
   os << " updated to ";
   function->feedback_vector().FeedbackSlotPrint(os, FeedbackSlot(slot));
   os << " - ";
diff --git a/src/runtime/runtime-weak-refs.cc b/src/runtime/runtime-weak-refs.cc
index d05a8ab479f..e4c9bc57dbe 100644
--- a/src/runtime/runtime-weak-refs.cc
+++ b/src/runtime/runtime-weak-refs.cc
@@ -44,7 +44,7 @@ RUNTIME_FUNCTION(Runtime_JSWeakRefAddToKeptObjects) {
   HandleScope scope(isolate);
   DCHECK_EQ(1, args.length());
   Handle<HeapObject> object = args.at<HeapObject>(0);
-  DCHECK(object->CanBeHeldWeakly());
+  DCHECK(Object::CanBeHeldWeakly(*object));
 
   isolate->heap()->KeepDuringJob(object);
 
diff --git a/src/snapshot/code-serializer.cc b/src/snapshot/code-serializer.cc
index 4a1486872b9..5cfb9650160 100644
--- a/src/snapshot/code-serializer.cc
+++ b/src/snapshot/code-serializer.cc
@@ -60,7 +60,7 @@ ScriptCompiler::CachedData* CodeSerializer::Serialize(
   Handle<Script> script(Script::cast(info->script()), isolate);
   if (v8_flags.trace_serializer) {
     PrintF("[Serializing from");
-    script->name().ShortPrint();
+    ShortPrint(script->name());
     PrintF("]\n");
   }
 #if V8_ENABLE_WEBASSEMBLY
@@ -573,7 +573,8 @@ MaybeHandle<SharedFunctionInfo> CodeSerializer::FinishOffThreadDeserialize(
       background_merge_task->HasPendingForegroundWork()) {
     Handle<Script> script = handle(Script::cast(result->script()), isolate);
     result = background_merge_task->CompleteMergeInForeground(isolate, script);
-    DCHECK(Script::cast(result->script())->source().StrictEquals(*source));
+    DCHECK(Object::StrictEquals(Script::cast(result->script())->source(),
+                                *source));
     DCHECK(isolate->factory()->script_list()->Contains(
         MaybeObject::MakeWeak(MaybeObject::FromObject(result->script()))));
   } else {
diff --git a/src/snapshot/serializer.cc b/src/snapshot/serializer.cc
index 602ca3a1916..a67f2a492d5 100644
--- a/src/snapshot/serializer.cc
+++ b/src/snapshot/serializer.cc
@@ -189,7 +189,7 @@ void Serializer::PrintStack() { PrintStack(std::cout); }
 
 void Serializer::PrintStack(std::ostream& out) {
   for (const auto o : stack_) {
-    o->Print(out);
+    Print(*o, out);
     out << "\n";
   }
 }
@@ -214,7 +214,7 @@ bool Serializer::SerializeHotObject(HeapObject obj) {
   DCHECK(index >= 0 && index < kHotObjectCount);
   if (v8_flags.trace_serializer) {
     PrintF(" Encoding hot object %d:", index);
-    obj.ShortPrint();
+    ShortPrint(obj);
     PrintF("\n");
   }
   sink_.Put(HotObject::Encode(index), "HotObject");
@@ -239,7 +239,7 @@ bool Serializer::SerializeBackReference(HeapObject obj) {
     DCHECK(reference->is_back_reference());
     if (v8_flags.trace_serializer) {
       PrintF(" Encoding back reference to: ");
-      obj.ShortPrint();
+      ShortPrint(obj);
       PrintF("\n");
     }
 
@@ -270,7 +270,7 @@ void Serializer::PutRoot(RootIndex root) {
   HeapObject object = HeapObject::cast(isolate()->root(root));
   if (v8_flags.trace_serializer) {
     PrintF(" Encoding root %d:", root_index);
-    object.ShortPrint();
+    ShortPrint(object);
     PrintF("\n");
   }
 
@@ -752,7 +752,7 @@ void Serializer::ObjectSerializer::Serialize(SlotType slot_type) {
     if (should_defer && CanBeDeferred(raw, slot_type)) {
       if (v8_flags.trace_serializer) {
         PrintF(" Deferring heap object: ");
-        object_->ShortPrint();
+        ShortPrint(*object_);
         PrintF("\n");
       }
       // Deferred objects are considered "pending".
@@ -765,14 +765,14 @@ void Serializer::ObjectSerializer::Serialize(SlotType slot_type) {
       if (v8_flags.trace_serializer && recursion.ExceedsMaximum()) {
         PrintF(" Exceeding max recursion depth by %d for: ",
                recursion.ExceedsMaximumBy());
-        object_->ShortPrint();
+        ShortPrint(*object_);
         PrintF("\n");
       }
     }
 
     if (v8_flags.trace_serializer) {
       PrintF(" Encoding heap object: ");
-      object_->ShortPrint();
+      ShortPrint(*object_);
       PrintF("\n");
     }
   }
@@ -887,7 +887,7 @@ void Serializer::ObjectSerializer::SerializeDeferred() {
   if (back_reference != nullptr) {
     if (v8_flags.trace_serializer) {
       PrintF(" Deferred heap object ");
-      object_->ShortPrint();
+      ShortPrint(*object_);
       PrintF(" was already serialized\n");
     }
     return;
diff --git a/src/snapshot/startup-serializer.cc b/src/snapshot/startup-serializer.cc
index b84ba0002f1..ef88d41ba9a 100644
--- a/src/snapshot/startup-serializer.cc
+++ b/src/snapshot/startup-serializer.cc
@@ -87,7 +87,7 @@ void StartupSerializer::SerializeObjectImpl(Handle<HeapObject> obj,
   if (IsJSFunction(*obj, cage_base)) {
     v8::base::OS::PrintError("Reference stack:\n");
     PrintStack(std::cerr);
-    obj->Print(std::cerr);
+    Print(*obj, std::cerr);
     FATAL(
         "JSFunction should be added through the context snapshot instead of "
         "the isolate snapshot");
@@ -209,7 +209,7 @@ void SerializedHandleChecker::VisitRootPointers(Root root,
     if (serialized_.find(*p) != serialized_.end()) continue;
     PrintF("%s handle not serialized: ",
            root == Root::kGlobalHandles ? "global" : "eternal");
-    (*p).Print();
+    Print(*p);
     PrintF("\n");
     ok_ = false;
   }
diff --git a/src/strings/string-stream.cc b/src/strings/string-stream.cc
index b1ed5e1852e..741ac40268d 100644
--- a/src/strings/string-stream.cc
+++ b/src/strings/string-stream.cc
@@ -192,7 +192,7 @@ void StringStream::Add(base::Vector<const char> format,
 }
 
 void StringStream::PrintObject(Object o) {
-  o.ShortPrint(this);
+  ShortPrint(o, this);
   if (IsString(o)) {
     if (String::cast(o)->length() <= String::kMaxShortPrintLength) {
       return;
@@ -314,7 +314,7 @@ void StringStream::PrintUsingMap(JSObject js_object) {
         if (IsString(key)) {
           Put(String::cast(key));
         } else {
-          key.ShortPrint();
+          ShortPrint(key);
         }
         Add(": ");
         FieldIndex index = FieldIndex::ForDescriptor(map, i);
@@ -370,7 +370,7 @@ void StringStream::PrintMentionedObjectCache(Isolate* isolate) {
     HeapObject printee = *(*debug_object_cache)[i];
     Add(" #%d# %p: ", static_cast<int>(i),
         reinterpret_cast<void*>(printee.ptr()));
-    printee.ShortPrint(this);
+    ShortPrint(printee, this);
     Add("\n");
     if (IsJSObject(printee)) {
       if (IsJSPrimitiveWrapper(printee)) {
@@ -382,8 +382,8 @@ void StringStream::PrintMentionedObjectCache(Isolate* isolate) {
         JSArray array = JSArray::cast(printee);
         if (array->HasObjectElements()) {
           unsigned int limit = FixedArray::cast(array->elements())->length();
-          unsigned int length =
-              static_cast<uint32_t>(JSArray::cast(array)->length().Number());
+          unsigned int length = static_cast<uint32_t>(
+              Object::Number(JSArray::cast(array)->length()));
           if (length < limit) limit = length;
           PrintFixedArray(FixedArray::cast(array->elements()), limit);
         }
@@ -420,7 +420,8 @@ void StringStream::PrintPrototype(JSFunction fun, Object receiver) {
     print_name = true;
   } else if (!isolate->context().is_null()) {
     if (!IsJSObject(receiver)) {
-      receiver = receiver.GetPrototypeChainRootMap(isolate)->prototype();
+      receiver =
+          Object::GetPrototypeChainRootMap(receiver, isolate)->prototype();
     }
 
     for (PrototypeIterator iter(isolate, JSObject::cast(receiver),
diff --git a/src/wasm/c-api.cc b/src/wasm/c-api.cc
index 3a2e6384ffb..4865790661f 100644
--- a/src/wasm/c-api.cc
+++ b/src/wasm/c-api.cc
@@ -446,7 +446,7 @@ void StoreImpl::SetHostInfo(i::Handle<i::Object> object, void* info,
   size_t estimated_size = sizeof(ManagedData);
   i::Handle<i::Object> wrapper = i::Managed<ManagedData>::FromRawPtr(
       i_isolate(), estimated_size, new ManagedData(info, finalizer));
-  int32_t hash = object->GetOrCreateHash(i_isolate()).value();
+  int32_t hash = i::Object::GetOrCreateHash(*object, i_isolate()).value();
   i::JSWeakCollection::Set(host_info_map_, object, wrapper, hash);
 }
 
@@ -940,7 +940,8 @@ auto Ref::copy() const -> own<Ref> { return impl(this)->copy(); }
 
 auto Ref::same(const Ref* that) const -> bool {
   i::HandleScope handle_scope(impl(this)->isolate());
-  return impl(this)->v8_object()->SameValue(*impl(that)->v8_object());
+  return i::Object::SameValue(*impl(this)->v8_object(),
+                              *impl(that)->v8_object());
 }
 
 auto Ref::get_host_info() const -> void* { return impl(this)->get_host_info(); }
@@ -1986,7 +1987,7 @@ auto Table::type() const -> own<TableType> {
   i::Handle<i::WasmTableObject> table = impl(this)->v8_object();
   uint32_t min = table->current_length();
   uint32_t max;
-  if (!table->maximum_length().ToUint32(&max)) max = 0xFFFFFFFFu;
+  if (!i::Object::ToUint32(table->maximum_length(), &max)) max = 0xFFFFFFFFu;
   ValKind kind;
   switch (table->type().heap_representation()) {
     case i::wasm::HeapType::kFunc:
diff --git a/src/wasm/module-instantiate.cc b/src/wasm/module-instantiate.cc
index 494f9992020..7dcf2ab0a31 100644
--- a/src/wasm/module-instantiate.cc
+++ b/src/wasm/module-instantiate.cc
@@ -245,7 +245,7 @@ bool IsSupportedWasmFastApiFunction(Isolate* isolate,
     if (v8_flags.trace_opt) {
       CodeTracer::Scope scope(isolate->GetCodeTracer());
       PrintF(scope.file(), "[disabled optimization for ");
-      shared->ShortPrint(scope.file());
+      ShortPrint(*shared, scope.file());
       PrintF(scope.file(),
              ", reason: the signature of the imported function in the Wasm "
              "module doesn't match that of the Fast API function (%s)]\n",
@@ -1822,7 +1822,8 @@ bool InstanceBuilder::ProcessImportedTable(Handle<WasmInstanceObject> instance,
                           import_index, table.maximum_size);
       return false;
     }
-    int64_t imported_maximum_size = table_object->maximum_length().Number();
+    int64_t imported_maximum_size =
+        Object::Number(table_object->maximum_length());
     if (imported_maximum_size < 0) {
       thrower_->LinkError("table import %d has no maximum length, expected %u",
                           import_index, table.maximum_size);
@@ -2069,7 +2070,7 @@ bool InstanceBuilder::ProcessImportedGlobal(Handle<WasmInstanceObject> instance,
   }
 
   if (IsNumber(*value) && global.type != kWasmI64) {
-    double number_value = value->Number();
+    double number_value = Object::Number(*value);
     // The Wasm-BigInt proposal currently says that i64 globals may
     // only be initialized with BigInts. See:
     // https://github.com/WebAssembly/JS-BigInt-integration/issues/12
diff --git a/src/wasm/wasm-debug.cc b/src/wasm/wasm-debug.cc
index 6ada7dcacde..971972e1096 100644
--- a/src/wasm/wasm-debug.cc
+++ b/src/wasm/wasm-debug.cc
@@ -1147,7 +1147,7 @@ bool CheckBreakPoint(Isolate* isolate, Handle<BreakPoint> break_point,
     isolate->clear_pending_exception();
     return false;
   }
-  return result->BooleanValue(isolate);
+  return Object::BooleanValue(*result, isolate);
 }
 
 }  // namespace
diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
index b59b39fb0ef..14500715332 100644
--- a/src/wasm/wasm-js.cc
+++ b/src/wasm/wasm-js.cc
@@ -2425,7 +2425,7 @@ void WebAssemblyTableType(const v8::FunctionCallbackInfo<v8::Value>& info) {
   EXTRACT_THIS(table, WasmTableObject);
   base::Optional<uint32_t> max_size;
   if (!IsUndefined(table->maximum_length())) {
-    uint64_t max_size64 = table->maximum_length().Number();
+    uint64_t max_size64 = i::Object::Number(table->maximum_length());
     DCHECK_LE(max_size64, std::numeric_limits<uint32_t>::max());
     max_size.emplace(static_cast<uint32_t>(max_size64));
   }
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index aa18d7dfc3d..687096a7895 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -205,7 +205,7 @@ int WasmTableObject::Grow(Isolate* isolate, Handle<WasmTableObject> table,
 
   // Check if growing by {count} is valid.
   uint32_t max_size;
-  if (!table->maximum_length().ToUint32(&max_size)) {
+  if (!Object::ToUint32(table->maximum_length(), &max_size)) {
     max_size = v8_flags.wasm_max_table_size;
   }
   max_size = std::min(max_size, v8_flags.wasm_max_table_size.value());
diff --git a/test/cctest/assembler-helper-arm.cc b/test/cctest/assembler-helper-arm.cc
index 698005fd9eb..acf4a2ece95 100644
--- a/test/cctest/assembler-helper-arm.cc
+++ b/test/cctest/assembler-helper-arm.cc
@@ -22,7 +22,7 @@ Handle<Code> AssembleCodeImpl(Isolate* isolate,
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   if (v8_flags.print_code) {
-    code->Print();
+    Print(*code);
   }
   return code;
 }
diff --git a/test/cctest/compiler/codegen-tester.h b/test/cctest/compiler/codegen-tester.h
index 65f8dcd21fa..a7ee6092ede 100644
--- a/test/cctest/compiler/codegen-tester.h
+++ b/test/cctest/compiler/codegen-tester.h
@@ -61,13 +61,13 @@ class RawMachineAssemblerTester : public HandleAndZoneScope,
   ~RawMachineAssemblerTester() override = default;
 
   void CheckNumber(double expected, Object number) {
-    CHECK(this->isolate()->factory()->NewNumber(expected)->SameValue(number));
+    CHECK(Object::SameValue(*this->isolate()->factory()->NewNumber(expected),
+                            number));
   }
 
   void CheckString(const char* expected, Object string) {
-    CHECK(
-        this->isolate()->factory()->InternalizeUtf8String(expected)->SameValue(
-            string));
+    CHECK(Object::SameValue(
+        *this->isolate()->factory()->InternalizeUtf8String(expected), string));
   }
 
   void GenerateCode() { Generate(); }
diff --git a/test/cctest/compiler/function-tester.cc b/test/cctest/compiler/function-tester.cc
index 993a9e53b8d..c11e3a03fa8 100644
--- a/test/cctest/compiler/function-tester.cc
+++ b/test/cctest/compiler/function-tester.cc
@@ -83,7 +83,7 @@ void FunctionTester::CheckCall(Handle<Object> expected, Handle<Object> a,
                                Handle<Object> b, Handle<Object> c,
                                Handle<Object> d) {
   Handle<Object> result = Call(a, b, c, d).ToHandleChecked();
-  CHECK(expected->SameValue(*result));
+  CHECK(Object::SameValue(*expected, *result));
 }
 
 Handle<JSFunction> FunctionTester::NewFunction(const char* source) {
diff --git a/test/cctest/compiler/test-code-generator.cc b/test/cctest/compiler/test-code-generator.cc
index 1050ba2d68f..5e530978326 100644
--- a/test/cctest/compiler/test-code-generator.cc
+++ b/test/cctest/compiler/test-code-generator.cc
@@ -276,12 +276,12 @@ void PrintStateValue(std::ostream& os, Isolate* isolate, Handle<Object> value,
       if (IsSmi(*value)) {
         os << Smi::cast(*value).value();
       } else {
-        os << value->Number();
+        os << Object::Number(*value);
       }
       break;
     case MachineRepresentation::kFloat32:
     case MachineRepresentation::kFloat64:
-      os << value->Number();
+      os << Object::Number(*value);
       break;
     case MachineRepresentation::kSimd128: {
       FixedArray vector = FixedArray::cast(*value);
@@ -900,7 +900,7 @@ class TestEnvironment : public HandleAndZoneScope {
       case MachineRepresentation::kTagged:
       case MachineRepresentation::kFloat32:
       case MachineRepresentation::kFloat64:
-        return actual->StrictEquals(*expected);
+        return Object::StrictEquals(*actual, *expected);
       case MachineRepresentation::kSimd128:
         for (int lane = 0; lane < 4; lane++) {
           int actual_lane =
@@ -1370,7 +1370,7 @@ TEST(FuzzAssembleMove) {
 
     Handle<Code> test = c.FinalizeForExecuting();
     if (v8_flags.print_code) {
-      test->Print();
+      Print(*test);
     }
 
     Handle<FixedArray> actual = env.Run(test, state_in);
@@ -1394,7 +1394,7 @@ TEST(FuzzAssembleParallelMove) {
 
   Handle<Code> test = c.FinalizeForExecuting();
   if (v8_flags.print_code) {
-    test->Print();
+    Print(*test);
   }
 
   Handle<FixedArray> actual = env.Run(test, state_in);
@@ -1419,7 +1419,7 @@ TEST(FuzzAssembleSwap) {
 
     Handle<Code> test = c.FinalizeForExecuting();
     if (v8_flags.print_code) {
-      test->Print();
+      Print(*test);
     }
 
     Handle<FixedArray> actual = env.Run(test, state_in);
@@ -1457,7 +1457,7 @@ TEST(FuzzAssembleMoveAndSwap) {
 
     Handle<Code> test = c.FinalizeForExecuting();
     if (v8_flags.print_code) {
-      test->Print();
+      Print(*test);
     }
 
     Handle<FixedArray> actual = env.Run(test, state_in);
@@ -1538,7 +1538,7 @@ TEST(AssembleTailCallGap) {
                                 CodeGeneratorTester::kRegisterPush);
     Handle<Code> code = c.Finalize();
     if (v8_flags.print_code) {
-      code->Print();
+      Print(*code);
     }
   }
 
@@ -1567,7 +1567,7 @@ TEST(AssembleTailCallGap) {
                                 CodeGeneratorTester::kStackSlotPush);
     Handle<Code> code = c.Finalize();
     if (v8_flags.print_code) {
-      code->Print();
+      Print(*code);
     }
   }
 
@@ -1596,7 +1596,7 @@ TEST(AssembleTailCallGap) {
                                 CodeGeneratorTester::kScalarPush);
     Handle<Code> code = c.Finalize();
     if (v8_flags.print_code) {
-      code->Print();
+      Print(*code);
     }
   }
 }
diff --git a/test/cctest/compiler/test-run-machops.cc b/test/cctest/compiler/test-run-machops.cc
index 5753e0606db..598a7a57c08 100644
--- a/test/cctest/compiler/test-run-machops.cc
+++ b/test/cctest/compiler/test-run-machops.cc
@@ -5202,7 +5202,7 @@ TEST(RunRefDiamond) {
   m.Return(m.Int32Constant(magic));
 
   CHECK_EQ(magic, m.Call());
-  CHECK(rexpected->SameValue(buffer));
+  CHECK(Object::SameValue(*rexpected, buffer));
 }
 
 
@@ -5243,7 +5243,7 @@ TEST(RunDoubleRefDiamond) {
 
   CHECK_EQ(magic, m.Call());
   CHECK_EQ(dconstant, dbuffer);
-  CHECK(rexpected->SameValue(rbuffer));
+  CHECK(Object::SameValue(*rexpected, rbuffer));
 }
 
 
@@ -5294,7 +5294,7 @@ TEST(RunDoubleRefDoubleDiamond) {
 
   CHECK_EQ(magic, m.Call());
   CHECK_EQ(dconstant, dbuffer);
-  CHECK(rexpected->SameValue(rbuffer));
+  CHECK(Object::SameValue(*rexpected, rbuffer));
 }
 
 
diff --git a/test/cctest/heap/test-heap.cc b/test/cctest/heap/test-heap.cc
index e92f3ed3089..e229d7a1343 100644
--- a/test/cctest/heap/test-heap.cc
+++ b/test/cctest/heap/test-heap.cc
@@ -264,17 +264,17 @@ TEST(HeapObjects) {
   Handle<Object> value = factory->NewNumber(1.000123);
   CHECK(IsHeapNumber(*value));
   CHECK(IsNumber(*value));
-  CHECK_EQ(1.000123, value->Number());
+  CHECK_EQ(1.000123, Object::Number(*value));
 
   value = factory->NewNumber(1.0);
   CHECK(IsSmi(*value));
   CHECK(IsNumber(*value));
-  CHECK_EQ(1.0, value->Number());
+  CHECK_EQ(1.0, Object::Number(*value));
 
   value = factory->NewNumberFromInt(1024);
   CHECK(IsSmi(*value));
   CHECK(IsNumber(*value));
-  CHECK_EQ(1024.0, value->Number());
+  CHECK_EQ(1024.0, Object::Number(*value));
 
   value = factory->NewNumberFromInt(Smi::kMinValue);
   CHECK(IsSmi(*value));
@@ -291,24 +291,24 @@ TEST(HeapObjects) {
   value = factory->NewNumberFromInt(Smi::kMinValue - 1);
   CHECK(IsHeapNumber(*value));
   CHECK(IsNumber(*value));
-  CHECK_EQ(static_cast<double>(Smi::kMinValue - 1), value->Number());
+  CHECK_EQ(static_cast<double>(Smi::kMinValue - 1), Object::Number(*value));
 #endif
 
   value = factory->NewNumberFromUint(static_cast<uint32_t>(Smi::kMaxValue) + 1);
   CHECK(IsHeapNumber(*value));
   CHECK(IsNumber(*value));
   CHECK_EQ(static_cast<double>(static_cast<uint32_t>(Smi::kMaxValue) + 1),
-           value->Number());
+           Object::Number(*value));
 
   value = factory->NewNumberFromUint(static_cast<uint32_t>(1) << 31);
   CHECK(IsHeapNumber(*value));
   CHECK(IsNumber(*value));
   CHECK_EQ(static_cast<double>(static_cast<uint32_t>(1) << 31),
-           value->Number());
+           Object::Number(*value));
 
   // nan oddball checks
   CHECK(IsNumber(*factory->nan_value()));
-  CHECK(std::isnan(factory->nan_value()->Number()));
+  CHECK(std::isnan(Object::Number(*factory->nan_value())));
 
   Handle<String> s = factory->NewStringFromStaticChars("fisk hest ");
   CHECK(IsString(*s));
@@ -884,7 +884,7 @@ TEST(JSArray) {
   JSArray::SetLength(array, static_cast<uint32_t>(Smi::kMaxValue) + 1);
 
   uint32_t int_length = 0;
-  CHECK(array->length().ToArrayIndex(&int_length));
+  CHECK(Object::ToArrayIndex(array->length(), &int_length));
   CHECK_EQ(static_cast<uint32_t>(Smi::kMaxValue) + 1, int_length);
   CHECK(array->HasDictionaryElements());  // Must be in slow mode.
 
@@ -892,7 +892,7 @@ TEST(JSArray) {
   Object::SetElement(isolate, array, int_length, name, ShouldThrow::kDontThrow)
       .Check();
   uint32_t new_int_length = 0;
-  CHECK(array->length().ToArrayIndex(&new_int_length));
+  CHECK(Object::ToArrayIndex(array->length(), &new_int_length));
   CHECK_EQ(static_cast<double>(int_length), new_int_length - 1);
   element = Object::GetElement(isolate, array, int_length).ToHandleChecked();
   CHECK_EQ(*element, *name);
@@ -3402,7 +3402,7 @@ TEST(PrintSharedFunctionInfo) {
           CcTest::global()->Get(ctx, v8_str("g")).ToLocalChecked())));
 
   StdoutStream os;
-  g->shared().Print(os);
+  Print(g->shared(), os);
   os << std::endl;
 }
 #endif  // OBJECT_PRINT
@@ -3780,7 +3780,7 @@ TEST(DetailedErrorStackTrace) {
     CHECK(IsBoolean(bar_parameters->get(1)));
     Handle<Object> foo = Handle<Object>::cast(GetByName("foo"));
     CHECK_EQ(bar_parameters->get(0), *foo);
-    CHECK(!bar_parameters->get(1).BooleanValue(CcTest::i_isolate()));
+    CHECK(!Object::BooleanValue(bar_parameters->get(1), CcTest::i_isolate()));
 
     FixedArray main_parameters = ParametersOf(stack_trace, 2);
     CHECK_EQ(main_parameters->length(), 2);
diff --git a/test/cctest/test-api-typed-array.cc b/test/cctest/test-api-typed-array.cc
index 8274e69ba48..ae45bccecc7 100644
--- a/test/cctest/test-api-typed-array.cc
+++ b/test/cctest/test-api-typed-array.cc
@@ -178,8 +178,8 @@ void ObjectWithExternalArrayTestHelper(Local<Context> context,
   CHECK_EQ(0, result->Int32Value(context).FromJust());
   if (array_type == i::kExternalFloat64Array ||
       array_type == i::kExternalFloat32Array) {
-    CHECK(std::isnan(
-        i::Object::GetElement(isolate, jsobj, 7).ToHandleChecked()->Number()));
+    CHECK(std::isnan(i::Object::Number(
+        *i::Object::GetElement(isolate, jsobj, 7).ToHandleChecked())));
   } else {
     CheckElementValue(isolate, 0, jsobj, 7);
   }
@@ -190,9 +190,9 @@ void ObjectWithExternalArrayTestHelper(Local<Context> context,
       "}"
       "ext_array[6];");
   CHECK_EQ(2, result->Int32Value(context).FromJust());
-  CHECK_EQ(2, static_cast<int>(i::Object::GetElement(isolate, jsobj, 6)
-                                   .ToHandleChecked()
-                                   ->Number()));
+  CHECK_EQ(2,
+           static_cast<int>(i::Object::Number(
+               *i::Object::GetElement(isolate, jsobj, 6).ToHandleChecked())));
 
   if (array_type != i::kExternalFloat32Array &&
       array_type != i::kExternalFloat64Array) {
diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
index 1bd2d002c98..e44ca42a8e6 100644
--- a/test/cctest/test-api.cc
+++ b/test/cctest/test-api.cc
@@ -3262,11 +3262,11 @@ void GlobalProxyIdentityHash(bool set_in_js) {
   int32_t hash1;
   if (set_in_js) {
     CompileRun("var m = new Set(); m.add(global);");
-    i::Object original_hash = i_global_proxy->GetHash();
+    i::Object original_hash = i::Object::GetHash(*i_global_proxy);
     CHECK(IsSmi(original_hash));
     hash1 = i::Smi::ToInt(original_hash);
   } else {
-    hash1 = i_global_proxy->GetOrCreateHash(i_isolate).value();
+    hash1 = i::Object::GetOrCreateHash(*i_global_proxy, i_isolate).value();
   }
   // Hash should be retained after being detached.
   env->DetachGlobal();
@@ -21450,7 +21450,7 @@ void Verify(v8::Isolate* isolate, Local<v8::Object> obj) {
 #if VERIFY_HEAP
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>(isolate);
   i::Handle<i::JSReceiver> i_obj = v8::Utils::OpenHandle(*obj);
-  i_obj->ObjectVerify(i_isolate);
+  i::Object::ObjectVerify(*i_obj, i_isolate);
 #endif
 }
 
@@ -24096,7 +24096,7 @@ TEST(SyntheticModuleEvaluationStepsSetExport) {
 
   Local<Value> completion_value = module->Evaluate(context).ToLocalChecked();
   CHECK(completion_value->IsUndefined());
-  CHECK_EQ(42, test_export_cell->value().Number());
+  CHECK_EQ(42, i::Object::Number(test_export_cell->value()));
   CHECK_EQ(module->GetStatus(), Module::kEvaluated);
 }
 
diff --git a/test/cctest/test-assembler-arm.cc b/test/cctest/test-assembler-arm.cc
index d511f2d2892..6ac06f846b1 100644
--- a/test/cctest/test-assembler-arm.cc
+++ b/test/cctest/test-assembler-arm.cc
@@ -62,7 +62,7 @@ TEST(0) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
   int res = reinterpret_cast<int>(f.Call(3, 4, 0, 0, 0));
@@ -98,7 +98,7 @@ TEST(1) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
   int res = reinterpret_cast<int>(f.Call(100, 0, 0, 0, 0));
@@ -143,7 +143,7 @@ TEST(2) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
   int res = reinterpret_cast<int>(f.Call(10, 0, 0, 0, 0));
@@ -189,7 +189,7 @@ TEST(3) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   t.i = 100000;
@@ -319,7 +319,7 @@ TEST(4) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
     t.a = 1.5;
@@ -381,7 +381,7 @@ TEST(5) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
     int res = reinterpret_cast<int>(f.Call(0xAAAAAAAA, 0, 0, 0, 0));
@@ -412,7 +412,7 @@ TEST(6) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
   int res = reinterpret_cast<int>(f.Call(0xFFFF, 0, 0, 0, 0));
@@ -479,7 +479,7 @@ static void TestRoundingMode(VCVTTypes types,
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
   int res = reinterpret_cast<int>(f.Call(0, 0, 0, 0, 0));
@@ -661,7 +661,7 @@ TEST(8) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto fn = GeneratedCode<F_ppiii>::FromCode(isolate, *code);
   d.a = 1.1;
@@ -770,7 +770,7 @@ TEST(9) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto fn = GeneratedCode<F_ppiii>::FromCode(isolate, *code);
   d.a = 1.1;
@@ -875,7 +875,7 @@ TEST(10) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto fn = GeneratedCode<F_ppiii>::FromCode(isolate, *code);
   d.a = 1.1;
@@ -969,7 +969,7 @@ TEST(11) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   f.Call(&i, 0, 0, 0, 0);
@@ -1094,7 +1094,7 @@ TEST(13) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
     t.a = 1.5;
@@ -1166,7 +1166,7 @@ TEST(14) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   t.left = base::bit_cast<double>(kHoleNanInt64);
@@ -2170,7 +2170,7 @@ TEST(15) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
     t.src0 = 0x01020304;
@@ -2474,7 +2474,7 @@ TEST(16) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   t.src0 = 0x01020304;
@@ -2552,7 +2552,7 @@ TEST(sdiv) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
     TEST_SDIV(0, kMinInt, 0);
@@ -2612,7 +2612,7 @@ TEST(udiv) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
     TEST_UDIV(0u, 0, 0);
@@ -2640,7 +2640,7 @@ TEST(smmla) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2665,7 +2665,7 @@ TEST(smmul) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2690,7 +2690,7 @@ TEST(sxtb) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2715,7 +2715,7 @@ TEST(sxtab) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2740,7 +2740,7 @@ TEST(sxth) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2765,7 +2765,7 @@ TEST(sxtah) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2790,7 +2790,7 @@ TEST(uxtb) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2815,7 +2815,7 @@ TEST(uxtab) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2840,7 +2840,7 @@ TEST(uxth) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2865,7 +2865,7 @@ TEST(uxtah) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   for (size_t i = 0; i < 128; ++i) {
@@ -2907,7 +2907,7 @@ TEST(rbit) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 
 #ifdef OBJECT_PRINT
-    code->Print(std::cout);
+    Print(*code, std::cout);
 #endif
 
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
@@ -3028,7 +3028,7 @@ TEST(msr_mrs) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_ippii>::FromCode(isolate, *code);
 
@@ -3125,7 +3125,7 @@ TEST(ARMv8_float32_vrintX) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
 
@@ -3226,7 +3226,7 @@ TEST(ARMv8_vrintX) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
 
@@ -3363,7 +3363,7 @@ TEST(ARMv8_vsel) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_ippii>::FromCode(isolate, *code);
 
@@ -3454,7 +3454,7 @@ TEST(ARMv8_vminmax_f64) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_ppiii>::FromCode(isolate, *code);
 
@@ -3536,7 +3536,7 @@ TEST(ARMv8_vminmax_f32) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_ppiii>::FromCode(isolate, *code);
 
@@ -3671,7 +3671,7 @@ static GeneratedCode<F_ppiii> GenerateMacroFloatMinMax(
       Factory::CodeBuilder(assm.isolate(), desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   return GeneratedCode<F_ppiii>::FromCode(assm.isolate(), *code);
 }
@@ -3846,7 +3846,7 @@ TEST(unaligned_loads) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_ppiii>::FromCode(isolate, *code);
 
@@ -3889,7 +3889,7 @@ TEST(unaligned_stores) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_ppiii>::FromCode(isolate, *code);
 
@@ -3989,7 +3989,7 @@ TEST(vswp) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F_piiii>::FromCode(isolate, *code);
   f.Call(&t, 0, 0, 0, 0);
@@ -4201,7 +4201,7 @@ TEST(split_add_immediate) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
     uint32_t res = reinterpret_cast<int>(f.Call(0, 0, 0, 0, 0));
@@ -4221,7 +4221,7 @@ TEST(split_add_immediate) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
     uint32_t res = reinterpret_cast<int>(f.Call(0, 0, 0, 0, 0));
@@ -4244,7 +4244,7 @@ TEST(split_add_immediate) {
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
     auto f = GeneratedCode<F_iiiii>::FromCode(isolate, *code);
     uint32_t res = reinterpret_cast<int>(f.Call(0, 0, 0, 0, 0));
diff --git a/test/cctest/test-assembler-arm64.cc b/test/cctest/test-assembler-arm64.cc
index 90c1349782e..5b224e90040 100644
--- a/test/cctest/test-assembler-arm64.cc
+++ b/test/cctest/test-assembler-arm64.cc
@@ -178,7 +178,7 @@ static void InitializeVM() {
     CodeDesc desc;                                                             \
     __ GetCode(masm.isolate(), &desc);                                         \
     code = Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build(); \
-    if (v8_flags.print_code) code->Print();                                    \
+    if (v8_flags.print_code) Print(*code);                                     \
   }
 
 #else  // ifdef USE_SIMULATOR.
@@ -229,7 +229,7 @@ static void InitializeVM() {
     CodeDesc desc;                                                             \
     __ GetCode(masm.isolate(), &desc);                                         \
     code = Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build(); \
-    if (v8_flags.print_code) code->Print();                                    \
+    if (v8_flags.print_code) Print(*code);                                     \
   }
 
 #endif  // ifdef USE_SIMULATOR.
diff --git a/test/cctest/test-assembler-ia32.cc b/test/cctest/test-assembler-ia32.cc
index 4d4c33985d9..f13a6f93ab5 100644
--- a/test/cctest/test-assembler-ia32.cc
+++ b/test/cctest/test-assembler-ia32.cc
@@ -66,7 +66,7 @@ TEST(AssemblerIa320) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F2>::FromCode(isolate, *code);
   auto res = f.Call(3, 4);
@@ -104,7 +104,7 @@ TEST(AssemblerIa321) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int res = f.Call(100);
@@ -145,7 +145,7 @@ TEST(AssemblerIa322) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   int res = f.Call(10);
@@ -174,7 +174,7 @@ TEST(AssemblerIa323) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F3>::FromCode(isolate, *code);
   int res = f.Call(-3.1415f);
@@ -203,7 +203,7 @@ TEST(AssemblerIa324) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F4>::FromCode(isolate, *code);
   int res = f.Call(2.718281828);
@@ -264,7 +264,7 @@ TEST(AssemblerIa326) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F5>::FromCode(isolate, *code);
   double res = f.Call(2.2, 1.1);
@@ -296,7 +296,7 @@ TEST(AssemblerIa328) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F6>::FromCode(isolate, *code);
   double res = f.Call(12);
@@ -495,7 +495,7 @@ TEST(AssemblerIa32Extractps) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F4>::FromCode(isolate, *code);
@@ -535,7 +535,7 @@ TEST(AssemblerIa32SSE) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F8>::FromCode(isolate, *code);
@@ -568,7 +568,7 @@ TEST(AssemblerIa32SSE3) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F8>::FromCode(isolate, *code);
@@ -796,7 +796,7 @@ TEST(AssemblerX64FMA_sd) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F9>::FromCode(isolate, *code);
@@ -1025,7 +1025,7 @@ TEST(AssemblerX64FMA_ss) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F10>::FromCode(isolate, *code);
@@ -1133,7 +1133,7 @@ TEST(AssemblerIa32BMI1) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -1181,7 +1181,7 @@ TEST(AssemblerIa32LZCNT) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -1229,7 +1229,7 @@ TEST(AssemblerIa32POPCNT) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -1375,7 +1375,7 @@ TEST(AssemblerIa32BMI2) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -1419,7 +1419,7 @@ TEST(AssemblerIa32JumpTables1) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kNumCases; ++i) {
@@ -1467,7 +1467,7 @@ TEST(AssemblerIa32JumpTables2) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
   for (int i = 0; i < kNumCases; ++i) {
@@ -1511,7 +1511,7 @@ TEST(Regress621926) {
 
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
diff --git a/test/cctest/test-code-stub-assembler.cc b/test/cctest/test-code-stub-assembler.cc
index f2cb4ca6bf2..a54527f1f82 100644
--- a/test/cctest/test-code-stub-assembler.cc
+++ b/test/cctest/test-code-stub-assembler.cc
@@ -1545,7 +1545,7 @@ TEST(TryGetOwnProperty) {
         Handle<Object> expected_value =
             JSReceiver::GetProperty(isolate, object, name).ToHandleChecked();
         Handle<Object> value = ft.Call(object, name).ToHandleChecked();
-        CHECK(expected_value->SameValue(*value));
+        CHECK(Object::SameValue(*expected_value, *value));
       }
     }
   }
@@ -3457,7 +3457,7 @@ TEST(IsNumberArrayIndex) {
   for (size_t i = 0; i < arraysize(indices); i++) {
     Handle<Object> index = isolate->factory()->NewNumber(indices[i]);
     uint32_t array_index;
-    CHECK_EQ(index->ToArrayIndex(&array_index),
+    CHECK_EQ(Object::ToArrayIndex(*index, &array_index),
              (ft.CallChecked<Smi>(index)->value() == 1));
   }
 }
@@ -4044,7 +4044,7 @@ TEST(InstructionSchedulingCallerSavedRegisters) {
   Handle<Object> input = isolate->factory()->NewNumber(8);
   MaybeHandle<Object> result = ft.Call(input);
   CHECK(IsSmi(*result.ToHandleChecked()));
-  CHECK_EQ(result.ToHandleChecked()->Number(), 13);
+  CHECK_EQ(Object::Number(*result.ToHandleChecked()), 13);
 
   v8_flags.turbo_instruction_scheduling = old_turbo_instruction_scheduling;
 }
@@ -4084,7 +4084,7 @@ TEST(WasmInt32ToHeapNumber) {
     Handle<Object> result = ft.Call().ToHandleChecked();
     CHECK(IsNumber(*result));
     Handle<Object> expected(isolate->factory()->NewNumber(test_value));
-    CHECK(result->StrictEquals(*expected));
+    CHECK(Object::StrictEquals(*result, *expected));
   }
 }
 
@@ -4170,8 +4170,8 @@ TEST(WasmFloat32ToNumber) {
     Handle<Object> result = ft.Call().ToHandleChecked();
     CHECK(IsNumber(*result));
     Handle<Object> expected(isolate->factory()->NewNumber(test_value));
-    CHECK(result->StrictEquals(*expected) ||
-          (std::isnan(test_value) && std::isnan(result->Number())));
+    CHECK(Object::StrictEquals(*result, *expected) ||
+          (std::isnan(test_value) && std::isnan(Object::Number(*result))));
     CHECK_EQ(IsSmi(*result), IsSmi(*expected));
   }
 }
@@ -4210,8 +4210,8 @@ TEST(WasmFloat64ToNumber) {
     Handle<Object> result = ft.Call().ToHandleChecked();
     CHECK(IsNumber(*result));
     Handle<Object> expected(isolate->factory()->NewNumber(test_value));
-    CHECK(result->StrictEquals(*expected) ||
-          (std::isnan(test_value) && std::isnan(result->Number())));
+    CHECK(Object::StrictEquals(*result, *expected) ||
+          (std::isnan(test_value) && std::isnan(Object::Number(*result))));
     CHECK_EQ(IsSmi(*result), IsSmi(*expected));
   }
 }
diff --git a/test/cctest/test-field-type-tracking.cc b/test/cctest/test-field-type-tracking.cc
index 2ffe1765e78..29606da0980 100644
--- a/test/cctest/test-field-type-tracking.cc
+++ b/test/cctest/test-field-type-tracking.cc
@@ -284,7 +284,7 @@ class Expectations {
       if (!Check(descriptors, i)) {
         Print();
 #ifdef OBJECT_PRINT
-        descriptors.Print();
+        i::Print(descriptors);
 #endif
         return false;
       }
@@ -542,7 +542,7 @@ TEST(ReconfigureAccessorToNonExistingDataField) {
   FieldIndex index = FieldIndex::ForDescriptor(*prepared_map, first);
   CHECK(IsUninitialized(obj->RawFastPropertyAt(index), isolate));
 #ifdef VERIFY_HEAP
-  obj->ObjectVerify(isolate);
+  Object::ObjectVerify(*obj, isolate);
 #endif
 }
 
@@ -3141,10 +3141,10 @@ TEST(DeletePropertyGeneralizesConstness) {
   }
 }
 
-#define CHECK_SAME(object, rep, expected)           \
-  CHECK_EQ(object->FitsRepresentation(rep, true),   \
-           object->FitsRepresentation(rep, false)); \
-  CHECK_EQ(object->FitsRepresentation(rep, true), expected)
+#define CHECK_SAME(object, rep, expected)                    \
+  CHECK_EQ(Object::FitsRepresentation(*object, rep, true),   \
+           Object::FitsRepresentation(*object, rep, false)); \
+  CHECK_EQ(Object::FitsRepresentation(*object, rep, true), expected)
 
 TEST(CheckFitsRepresentationPredicate) {
   CcTest::InitializeVM();
@@ -3165,8 +3165,8 @@ TEST(CheckFitsRepresentationPredicate) {
   // representation by converting it to a HeapNumber. If coercion is
   // disallowed, that query should fail.
   CHECK_SAME(smi_value, rep_smi, true);
-  CHECK_EQ(smi_value->FitsRepresentation(rep_double, true), true);
-  CHECK_EQ(smi_value->FitsRepresentation(rep_double, false), false);
+  CHECK_EQ(Object::FitsRepresentation(*smi_value, rep_double, true), true);
+  CHECK_EQ(Object::FitsRepresentation(*smi_value, rep_double, false), false);
   CHECK_SAME(smi_value, rep_heapobject, false);
   CHECK_SAME(smi_value, rep_tagged, true);
 
diff --git a/test/cctest/test-inobject-slack-tracking.cc b/test/cctest/test-inobject-slack-tracking.cc
index 86ff3bd6a69..897002ff366 100644
--- a/test/cctest/test-inobject-slack-tracking.cc
+++ b/test/cctest/test-inobject-slack-tracking.cc
@@ -82,7 +82,7 @@ static double GetDoubleFieldValue(JSObject obj, FieldIndex field_index) {
   if (IsHeapNumber(value)) {
     return HeapNumber::cast(value)->value();
   } else {
-    return value.Number();
+    return Object::Number(value);
   }
 }
 
diff --git a/test/cctest/test-js-weak-refs.cc b/test/cctest/test-js-weak-refs.cc
index f1c4086c737..5247242be80 100644
--- a/test/cctest/test-js-weak-refs.cc
+++ b/test/cctest/test-js-weak-refs.cc
@@ -175,7 +175,7 @@ void VerifyWeakCellKeyChain(Isolate* isolate, SimpleNumberDictionary key_map,
   va_list args;
   va_start(args, n_args);
 
-  Object hash = unregister_token.GetHash();
+  Object hash = Object::GetHash(unregister_token);
   InternalIndex entry = InternalIndex::NotFound();
   if (!IsUndefined(hash, isolate)) {
     uint32_t key = Smi::ToInt(hash);
diff --git a/test/cctest/test-macro-assembler-arm.cc b/test/cctest/test-macro-assembler-arm.cc
index cce64f00804..a1a0cc3d3a3 100644
--- a/test/cctest/test-macro-assembler-arm.cc
+++ b/test/cctest/test-macro-assembler-arm.cc
@@ -150,7 +150,7 @@ TEST(ExtractLane) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F3>::FromCode(isolate, *code);
   f.Call(&t, 0, 0, 0, 0);
@@ -281,7 +281,7 @@ TEST(ReplaceLane) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef DEBUG
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   auto f = GeneratedCode<F3>::FromCode(isolate, *code);
   f.Call(&t, 0, 0, 0, 0);
diff --git a/test/cctest/test-orderedhashtable.cc b/test/cctest/test-orderedhashtable.cc
index b884ef47ec0..b7fba5f87e5 100644
--- a/test/cctest/test-orderedhashtable.cc
+++ b/test/cctest/test-orderedhashtable.cc
@@ -16,13 +16,13 @@ static Isolate* GetIsolateFrom(LocalContext* context) {
 }
 
 void CopyHashCode(Handle<JSReceiver> from, Handle<JSReceiver> to) {
-  int hash = Smi::ToInt(from->GetHash());
+  int hash = Smi::ToInt(Object::GetHash(*from));
   to->SetIdentityHash(hash);
 }
 
 void Verify(Isolate* isolate, Handle<HeapObject> obj) {
 #if VERIFY_HEAP
-  obj->ObjectVerify(isolate);
+  Object::ObjectVerify(*obj, isolate);
 #endif
 }
 
@@ -297,9 +297,9 @@ TEST(SmallOrderedHashMapDuplicateHashCode) {
   Handle<JSObject> key2 = factory->NewJSObjectWithNullProto();
   CopyHashCode(key1, key2);
 
-  CHECK(!key1->SameValue(*key2));
-  Object hash1 = key1->GetHash();
-  Object hash2 = key2->GetHash();
+  CHECK(!Object::SameValue(*key1, *key2));
+  Object hash1 = Object::GetHash(*key1);
+  Object hash2 = Object::GetHash(*key2);
   CHECK_EQ(hash1, hash2);
 
   map = SmallOrderedHashMap::Add(isolate, map, key2, value).ToHandleChecked();
diff --git a/test/cctest/test-serialize.cc b/test/cctest/test-serialize.cc
index e9175c26ceb..bc09c030c82 100644
--- a/test/cctest/test-serialize.cc
+++ b/test/cctest/test-serialize.cc
@@ -2062,7 +2062,7 @@ TEST(CodeSerializerLargeCodeObject) {
           .ToHandleChecked();
 
   int result_int;
-  CHECK(copy_result->ToInt32(&result_int));
+  CHECK(Object::ToInt32(*copy_result, &result_int));
   CHECK_EQ(7, result_int);
 
   delete cache;
@@ -2145,7 +2145,7 @@ TEST(CodeSerializerLargeCodeObjectWithIncrementalMarking) {
           .ToHandleChecked();
 
   int result_int;
-  CHECK(copy_result->ToInt32(&result_int));
+  CHECK(Object::ToInt32(*copy_result, &result_int));
   CHECK_EQ(7, result_int);
 
   delete cache;
@@ -2396,7 +2396,7 @@ TEST(CodeSerializerExternalString) {
                             isolate->factory()->empty_fixed_array())
           .ToHandleChecked();
 
-  CHECK_EQ(15.0, copy_result->Number());
+  CHECK_EQ(15.0, Object::Number(*copy_result));
 
   // This avoids the GC from trying to free stack allocated resources.
   i::Handle<i::ExternalOneByteString>::cast(one_byte_string)
@@ -2462,7 +2462,7 @@ TEST(CodeSerializerLargeExternalString) {
                             isolate->factory()->empty_fixed_array())
           .ToHandleChecked();
 
-  CHECK_EQ(42.0, copy_result->Number());
+  CHECK_EQ(42.0, Object::Number(*copy_result));
 
   // This avoids the GC from trying to free stack allocated resources.
   i::Handle<i::ExternalOneByteString>::cast(name)->SetResource(isolate,
@@ -2518,7 +2518,7 @@ TEST(CodeSerializerExternalScriptName) {
                             isolate->factory()->empty_fixed_array())
           .ToHandleChecked();
 
-  CHECK_EQ(10.0, copy_result->Number());
+  CHECK_EQ(10.0, Object::Number(*copy_result));
 
   // This avoids the GC from trying to free stack allocated resources.
   i::Handle<i::ExternalOneByteString>::cast(name)->SetResource(isolate,
diff --git a/test/cctest/test-shared-strings.cc b/test/cctest/test-shared-strings.cc
index b2fdc3121a6..5249a196f7c 100644
--- a/test/cctest/test-shared-strings.cc
+++ b/test/cctest/test-shared-strings.cc
@@ -108,32 +108,32 @@ UNINITIALIZED_TEST(InPlaceInternalizableStringsAreShared) {
   // Old generation 1- and 2-byte seq strings are in-place internalizable.
   Handle<String> old_one_byte_seq =
       factory1->NewStringFromAsciiChecked(raw_one_byte, AllocationType::kOld);
-  CHECK(old_one_byte_seq->InSharedHeap());
+  CHECK(Object::InSharedHeap(*old_one_byte_seq));
   Handle<String> old_two_byte_seq =
       factory1->NewStringFromTwoByte(two_byte, AllocationType::kOld)
           .ToHandleChecked();
-  CHECK(old_two_byte_seq->InSharedHeap());
+  CHECK(Object::InSharedHeap(*old_two_byte_seq));
 
   // Young generation are not internalizable and not shared when sharing the
   // string table.
   Handle<String> young_one_byte_seq =
       factory1->NewStringFromAsciiChecked(raw_one_byte, AllocationType::kYoung);
-  CHECK(!young_one_byte_seq->InSharedHeap());
+  CHECK(!Object::InSharedHeap(*young_one_byte_seq));
   Handle<String> young_two_byte_seq =
       factory1->NewStringFromTwoByte(two_byte, AllocationType::kYoung)
           .ToHandleChecked();
-  CHECK(!young_two_byte_seq->InSharedHeap());
+  CHECK(!Object::InSharedHeap(*young_two_byte_seq));
 
   // Internalized strings are shared.
   uint64_t seed = HashSeed(i_isolate1);
   Handle<String> one_byte_intern = factory1->NewOneByteInternalizedString(
       base::OneByteVector(raw_one_byte),
       StringHasher::HashSequentialString<char>(raw_one_byte, 3, seed));
-  CHECK(one_byte_intern->InSharedHeap());
+  CHECK(Object::InSharedHeap(*one_byte_intern));
   Handle<String> two_byte_intern = factory1->NewTwoByteInternalizedString(
       two_byte,
       StringHasher::HashSequentialString<uint16_t>(raw_two_byte, 3, seed));
-  CHECK(two_byte_intern->InSharedHeap());
+  CHECK(Object::InSharedHeap(*two_byte_intern));
 }
 
 UNINITIALIZED_TEST(InPlaceInternalization) {
@@ -167,10 +167,10 @@ UNINITIALIZED_TEST(InPlaceInternalization) {
       factory1->InternalizeString(old_one_byte_seq1);
   Handle<String> two_byte_intern1 =
       factory1->InternalizeString(old_two_byte_seq1);
-  CHECK(old_one_byte_seq1->InSharedHeap());
-  CHECK(old_two_byte_seq1->InSharedHeap());
-  CHECK(one_byte_intern1->InSharedHeap());
-  CHECK(two_byte_intern1->InSharedHeap());
+  CHECK(Object::InSharedHeap(*old_one_byte_seq1));
+  CHECK(Object::InSharedHeap(*old_two_byte_seq1));
+  CHECK(Object::InSharedHeap(*one_byte_intern1));
+  CHECK(Object::InSharedHeap(*two_byte_intern1));
   CHECK(old_one_byte_seq1.equals(one_byte_intern1));
   CHECK(old_two_byte_seq1.equals(two_byte_intern1));
   CHECK_EQ(*old_one_byte_seq1, *one_byte_intern1);
@@ -188,10 +188,10 @@ UNINITIALIZED_TEST(InPlaceInternalization) {
       factory2->InternalizeString(old_one_byte_seq2);
   Handle<String> two_byte_intern2 =
       factory2->InternalizeString(old_two_byte_seq2);
-  CHECK(old_one_byte_seq2->InSharedHeap());
-  CHECK(old_two_byte_seq2->InSharedHeap());
-  CHECK(one_byte_intern2->InSharedHeap());
-  CHECK(two_byte_intern2->InSharedHeap());
+  CHECK(Object::InSharedHeap(*old_one_byte_seq2));
+  CHECK(Object::InSharedHeap(*old_two_byte_seq2));
+  CHECK(Object::InSharedHeap(*one_byte_intern2));
+  CHECK(Object::InSharedHeap(*two_byte_intern2));
   CHECK(!old_one_byte_seq2.equals(one_byte_intern2));
   CHECK(!old_two_byte_seq2.equals(two_byte_intern2));
   CHECK_NE(*old_one_byte_seq2, *one_byte_intern2);
@@ -235,10 +235,10 @@ UNINITIALIZED_TEST(YoungInternalization) {
             .ToHandleChecked();
     one_byte_intern1 = factory1->InternalizeString(young_one_byte_seq1);
     two_byte_intern1 = factory1->InternalizeString(young_two_byte_seq1);
-    CHECK(!young_one_byte_seq1->InSharedHeap());
-    CHECK(!young_two_byte_seq1->InSharedHeap());
-    CHECK(one_byte_intern1->InSharedHeap());
-    CHECK(two_byte_intern1->InSharedHeap());
+    CHECK(!Object::InSharedHeap(*young_one_byte_seq1));
+    CHECK(!Object::InSharedHeap(*young_two_byte_seq1));
+    CHECK(Object::InSharedHeap(*one_byte_intern1));
+    CHECK(Object::InSharedHeap(*two_byte_intern1));
     CHECK(!young_one_byte_seq1.equals(one_byte_intern1));
     CHECK(!young_two_byte_seq1.equals(two_byte_intern1));
     CHECK_NE(*young_one_byte_seq1, *one_byte_intern1);
@@ -552,8 +552,8 @@ Handle<String> ShareAndVerify(Isolate* isolate, Handle<String> string) {
   Handle<String> shared = String::Share(isolate, string);
   CHECK(shared->IsShared());
 #ifdef VERIFY_HEAP
-  shared->ObjectVerify(isolate);
-  string->ObjectVerify(isolate);
+  Object::ObjectVerify(*shared, isolate);
+  Object::ObjectVerify(*string, isolate);
 #endif  // VERIFY_HEAP
   return shared;
 }
diff --git a/test/cctest/test-strings.cc b/test/cctest/test-strings.cc
index 7b68746371a..991de98e028 100644
--- a/test/cctest/test-strings.cc
+++ b/test/cctest/test-strings.cc
@@ -1290,7 +1290,7 @@ TEST(CachedHashOverflow) {
     CHECK_EQ(IsNumber(*results[i]), result->IsNumber());
     if (result->IsNumber()) {
       int32_t value = 0;
-      CHECK(results[i]->ToInt32(&value));
+      CHECK(Object::ToInt32(*results[i], &value));
       CHECK_EQ(value, result->ToInt32(context).ToLocalChecked()->Value());
     }
   }
diff --git a/test/cctest/test-swiss-name-dictionary-infra.h b/test/cctest/test-swiss-name-dictionary-infra.h
index ed0c03a0f1a..c5175ce96b2 100644
--- a/test/cctest/test-swiss-name-dictionary-infra.h
+++ b/test/cctest/test-swiss-name-dictionary-infra.h
@@ -199,7 +199,7 @@ class TestSequence {
       CHECK_EQ(*key, data->get(0));
 
       if (expected_value_opt) {
-        CHECK(expected_value_opt.value()->StrictEquals(data->get(1)));
+        CHECK(Object::StrictEquals(*expected_value_opt.value(), data->get(1)));
       }
 
       if (expected_details_opt) {
diff --git a/test/cctest/wasm/test-run-wasm-memory64.cc b/test/cctest/wasm/test-run-wasm-memory64.cc
index 1092d64a388..1262dbafed2 100644
--- a/test/cctest/wasm/test-run-wasm-memory64.cc
+++ b/test/cctest/wasm/test-run-wasm-memory64.cc
@@ -86,7 +86,7 @@ WASM_EXEC_TEST(InitExpression) {
   testing::CompileAndInstantiateForTesting(
       isolate, &thrower, ModuleWireBytes(data, data + arraysize(data)));
   if (thrower.error()) {
-    thrower.Reify()->Print();
+    Print(*thrower.Reify());
     FATAL("compile or instantiate error");
   }
 }
diff --git a/test/cctest/wasm/test-run-wasm-module.cc b/test/cctest/wasm/test-run-wasm-module.cc
index 9036b596dba..48cc743c1dd 100644
--- a/test/cctest/wasm/test-run-wasm-module.cc
+++ b/test/cctest/wasm/test-run-wasm-module.cc
@@ -830,7 +830,7 @@ TEST(InitDataAtTheUpperLimit) {
     CompileAndInstantiateForTesting(
         isolate, &thrower, ModuleWireBytes(data, data + arraysize(data)));
     if (thrower.error()) {
-      thrower.Reify()->Print();
+      Print(*thrower.Reify());
       FATAL("compile or instantiate error");
     }
   }
diff --git a/test/cctest/wasm/test-wasm-breakpoints.cc b/test/cctest/wasm/test-wasm-breakpoints.cc
index 06b8f60014c..fab849e2748 100644
--- a/test/cctest/wasm/test-wasm-breakpoints.cc
+++ b/test/cctest/wasm/test-wasm-breakpoints.cc
@@ -275,7 +275,7 @@ std::vector<WasmValue> wasmVec(Args... args) {
 int GetIntReturnValue(MaybeHandle<Object> retval) {
   CHECK(!retval.is_null());
   int result;
-  CHECK(retval.ToHandleChecked()->ToInt32(&result));
+  CHECK(Object::ToInt32(*retval.ToHandleChecked(), &result));
   return result;
 }
 
diff --git a/test/cctest/wasm/test-wasm-trap-position.cc b/test/cctest/wasm/test-wasm-trap-position.cc
index a5d70997e55..6f617260a22 100644
--- a/test/cctest/wasm/test-wasm-trap-position.cc
+++ b/test/cctest/wasm/test-wasm-trap-position.cc
@@ -46,7 +46,7 @@ void CheckExceptionInfos(v8::internal::Isolate* isolate, Handle<Object> exc,
   // Check that it's indeed an Error object.
   CHECK(IsJSError(*exc));
 
-  exc->Print();
+  Print(*exc);
   // Extract stack frame from the exception.
   auto stack = isolate->GetSimpleStackTrace(Handle<JSObject>::cast(exc));
   CHECK_EQ(N, stack->length());
diff --git a/test/common/types-fuzz.h b/test/common/types-fuzz.h
index 2fe044f6a41..fb4c8ab2fa5 100644
--- a/test/common/types-fuzz.h
+++ b/test/common/types-fuzz.h
@@ -211,8 +211,8 @@ class Types {
       case 2: {  // range
         int i = rng_->NextInt(static_cast<int>(integers.size()));
         int j = rng_->NextInt(static_cast<int>(integers.size()));
-        double min = integers[i]->Number();
-        double max = integers[j]->Number();
+        double min = Object::Number(*integers[i]);
+        double max = Object::Number(*integers[j]);
         if (min > max) std::swap(min, max);
         return Type::Range(min, max, zone_);
       }
diff --git a/test/unittests/assembler/assembler-x64-unittest.cc b/test/unittests/assembler/assembler-x64-unittest.cc
index fed91da354c..a021652352f 100644
--- a/test/unittests/assembler/assembler-x64-unittest.cc
+++ b/test/unittests/assembler/assembler-x64-unittest.cc
@@ -838,7 +838,7 @@ TEST_F(AssemblerX64Test, AssemblerX64Extractps) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F3>::FromCode(isolate, *code);
@@ -873,7 +873,7 @@ TEST_F(AssemblerX64Test, AssemblerX64SSE) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F6>::FromCode(isolate, *code);
@@ -903,7 +903,7 @@ TEST_F(AssemblerX64Test, AssemblerX64SSE3) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F6>::FromCode(isolate, *code);
@@ -1124,7 +1124,7 @@ TEST_F(AssemblerX64Test, AssemblerX64FMA_sd) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F7>::FromCode(isolate, *code);
@@ -1346,7 +1346,7 @@ TEST_F(AssemblerX64Test, AssemblerX64FMA_ss) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F8>::FromCode(isolate, *code);
@@ -1419,7 +1419,7 @@ TEST_F(AssemblerX64Test, AssemblerX64SSE_ss) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F8>::FromCode(isolate, *code);
@@ -1503,7 +1503,7 @@ TEST_F(AssemblerX64Test, AssemblerX64AVX_ss) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F8>::FromCode(isolate, *code);
@@ -1741,7 +1741,7 @@ TEST_F(AssemblerX64Test, AssemblerX64AVX_sd) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F7>::FromCode(isolate, *code);
@@ -1931,7 +1931,7 @@ TEST_F(AssemblerX64Test, AssemblerX64BMI1) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -1989,7 +1989,7 @@ TEST_F(AssemblerX64Test, AssemblerX64LZCNT) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -2047,7 +2047,7 @@ TEST_F(AssemblerX64Test, AssemblerX64POPCNT) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -2308,7 +2308,7 @@ TEST_F(AssemblerX64Test, AssemblerX64BMI2) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F0>::FromCode(isolate, *code);
@@ -2350,7 +2350,7 @@ TEST_F(AssemblerX64Test, AssemblerX64JumpTables1) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
 
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
@@ -2397,7 +2397,7 @@ TEST_F(AssemblerX64Test, AssemblerX64JumpTables2) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
-  code->Print(std::cout);
+  Print(*code, std::cout);
 #endif
 
   auto f = GeneratedCode<F1>::FromCode(isolate, *code);
@@ -2453,7 +2453,7 @@ TEST_F(AssemblerX64Test, AssemblerX64vmovups) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   auto f = GeneratedCode<F9>::FromCode(isolate, *code);
@@ -2489,7 +2489,7 @@ TEST_F(AssemblerX64Test, AssemblerX64Regmove256bit) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   uint8_t expected[] = {
@@ -2570,7 +2570,7 @@ TEST_F(AssemblerX64Test, AssemblerX64AVX2Op256bit) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   uint8_t expected[] = {
@@ -2664,7 +2664,7 @@ TEST_F(AssemblerX64Test, AssemblerX64FloatingPoint256bit) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   uint8_t expected[] = {// vandpd ymm1, ymm3, ymm5
@@ -2768,7 +2768,7 @@ TEST_F(AssemblerX64Test, AssemblerX64Integer256bit) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   uint8_t expected[] = {
@@ -2860,7 +2860,7 @@ TEST_F(AssemblerX64Test, AssemblerX64CmpOperations256bit) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   uint8_t expected[] = {
@@ -2910,7 +2910,7 @@ TEST_F(AssemblerX64Test, AssemblerX64ShiftImm128bit) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   uint8_t expected[] = {// vpsrlw xmm8,xmm2,0x4
@@ -2955,7 +2955,7 @@ TEST_F(AssemblerX64Test, AssemblerX64ShiftImm256bit) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
 
   uint8_t expected[] = {// vpsrlw ymm0,ymm2,0x4
@@ -3007,7 +3007,7 @@ TEST_F(AssemblerX64Test, AssemblerX64BinOp256bit) {
     Handle<Code> code =
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
 
     uint8_t expected[] = {// vaddps ymm0,ymm1,ymm2
@@ -3061,7 +3061,7 @@ TEST_F(AssemblerX64Test, AssemblerX64BinOp256bit) {
     Handle<Code> code =
         Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
     StdoutStream os;
-    code->Print(os);
+    Print(*code, os);
 #endif
 
     uint8_t expected[] = {// vpaddb ymm6,ymm7,ymm8
diff --git a/test/unittests/assembler/disasm-ia32-unittest.cc b/test/unittests/assembler/disasm-ia32-unittest.cc
index 147d6c3e48e..61a14993ed6 100644
--- a/test/unittests/assembler/disasm-ia32-unittest.cc
+++ b/test/unittests/assembler/disasm-ia32-unittest.cc
@@ -983,7 +983,7 @@ TEST_F(DisasmIa320Test, DisasmIa320) {
   USE(code);
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
   Address begin = code->instruction_start();
   Address end = code->instruction_end();
   disasm::Disassembler::Disassemble(stdout, reinterpret_cast<uint8_t*>(begin),
diff --git a/test/unittests/assembler/disasm-x64-unittest.cc b/test/unittests/assembler/disasm-x64-unittest.cc
index bef7b40b276..a384633e20a 100644
--- a/test/unittests/assembler/disasm-x64-unittest.cc
+++ b/test/unittests/assembler/disasm-x64-unittest.cc
@@ -304,7 +304,7 @@ TEST_F(DisasmX64Test, DisasmX64) {
   USE(code);
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
   Address begin = code->instruction_start();
   Address end = code->instruction_start();
   disasm::Disassembler::Disassemble(stdout, reinterpret_cast<uint8_t*>(begin),
diff --git a/test/unittests/assembler/macro-assembler-arm-unittest.cc b/test/unittests/assembler/macro-assembler-arm-unittest.cc
index 96073bc0c6c..9bc409a8688 100644
--- a/test/unittests/assembler/macro-assembler-arm-unittest.cc
+++ b/test/unittests/assembler/macro-assembler-arm-unittest.cc
@@ -157,7 +157,7 @@ TEST_P(MacroAssemblerTestMoveObjectAndSlot, MoveObjectAndSlot) {
       Handle<Code> code =
           Factory::CodeBuilder(isolate(), desc, CodeKind::FOR_TESTING).Build();
       StdoutStream os;
-      code->Print(os);
+      Print(*code, os);
     }
 
     buffer->MakeExecutable();
diff --git a/test/unittests/assembler/macro-assembler-arm64-unittest.cc b/test/unittests/assembler/macro-assembler-arm64-unittest.cc
index 68a35afc19a..8c1b21a6882 100644
--- a/test/unittests/assembler/macro-assembler-arm64-unittest.cc
+++ b/test/unittests/assembler/macro-assembler-arm64-unittest.cc
@@ -221,7 +221,7 @@ TEST_P(MacroAssemblerTestMoveObjectAndSlot, MoveObjectAndSlot) {
             Factory::CodeBuilder(isolate(), desc, CodeKind::FOR_TESTING)
                 .Build();
         StdoutStream os;
-        code->Print(os);
+        Print(*code, os);
       }
     }
 
diff --git a/test/unittests/assembler/macro-assembler-x64-unittest.cc b/test/unittests/assembler/macro-assembler-x64-unittest.cc
index 6b10b49561b..b08f153ecf8 100644
--- a/test/unittests/assembler/macro-assembler-x64-unittest.cc
+++ b/test/unittests/assembler/macro-assembler-x64-unittest.cc
@@ -60,7 +60,7 @@ void PrintCode(Isolate* isolate, CodeDesc desc) {
   Handle<Code> code =
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif  // OBJECT_PRINT
 }
 
@@ -541,7 +541,7 @@ TEST_F(MacroAssemblerX64Test, EmbeddedObj) {
       Factory::CodeBuilder(isolate, desc, CodeKind::FOR_TESTING).Build();
 #ifdef OBJECT_PRINT
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   using myF0 = Address();
   auto f = GeneratedCode<myF0>::FromAddress(isolate, code->instruction_start());
@@ -1438,7 +1438,7 @@ TEST_F(MacroAssemblerX64Test, F64x4Min) {
   Handle<Code> code =
       Factory::CodeBuilder(i_isolate(), desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   buffer->MakeExecutable();
   // Call the function from C++.
@@ -1505,7 +1505,7 @@ TEST_F(MacroAssemblerX64Test, F64x4Max) {
   Handle<Code> code =
       Factory::CodeBuilder(i_isolate(), desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   buffer->MakeExecutable();
   // Call the function from C++.
@@ -1572,7 +1572,7 @@ TEST_F(MacroAssemblerX64Test, F32x8Min) {
   Handle<Code> code =
       Factory::CodeBuilder(i_isolate(), desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   buffer->MakeExecutable();
   // Call the function from C++.
@@ -1642,7 +1642,7 @@ TEST_F(MacroAssemblerX64Test, F32x8Max) {
   Handle<Code> code =
       Factory::CodeBuilder(i_isolate(), desc, CodeKind::FOR_TESTING).Build();
   StdoutStream os;
-  code->Print(os);
+  Print(*code, os);
 #endif
   buffer->MakeExecutable();
   // Call the function from C++.
diff --git a/test/unittests/codegen/factory-unittest.cc b/test/unittests/codegen/factory-unittest.cc
index 31248ba7191..2bc400eebda 100644
--- a/test/unittests/codegen/factory-unittest.cc
+++ b/test/unittests/codegen/factory-unittest.cc
@@ -38,7 +38,7 @@ TEST_F(FactoryCodeBuilderTest, Factory_CodeBuilder) {
   CHECK(
       i_isolate()->heap()->InSpace(code->instruction_stream(), CODE_LO_SPACE));
 #if VERIFY_HEAP
-  code->ObjectVerify(i_isolate());
+  Object::ObjectVerify(*code, i_isolate());
 #endif
 }
 
diff --git a/test/unittests/compiler/codegen-tester.h b/test/unittests/compiler/codegen-tester.h
index 94caad0b8b2..969c8a97806 100644
--- a/test/unittests/compiler/codegen-tester.h
+++ b/test/unittests/compiler/codegen-tester.h
@@ -61,13 +61,13 @@ class RawMachineAssemblerTester : public CallHelper<ReturnType>,
   ~RawMachineAssemblerTester() override = default;
 
   void CheckNumber(double expected, Object number) {
-    CHECK(this->isolate()->factory()->NewNumber(expected)->SameValue(number));
+    CHECK(Object::SameValue(*this->isolate()->factory()->NewNumber(expected),
+                            number));
   }
 
   void CheckString(const char* expected, Object string) {
-    CHECK(
-        this->isolate()->factory()->InternalizeUtf8String(expected)->SameValue(
-            string));
+    CHECK(Object::SameValue(
+        *this->isolate()->factory()->InternalizeUtf8String(expected), string));
   }
 
   void GenerateCode() { Generate(); }
diff --git a/test/unittests/compiler/compiler-unittest.cc b/test/unittests/compiler/compiler-unittest.cc
index e474571fca8..82a1cce7274 100644
--- a/test/unittests/compiler/compiler-unittest.cc
+++ b/test/unittests/compiler/compiler-unittest.cc
@@ -72,7 +72,7 @@ static double Inc(Isolate* isolate, int x) {
   Execution::CallScript(isolate, fun, global,
                         isolate->factory()->empty_fixed_array())
       .Check();
-  return GetGlobalProperty("result")->Number();
+  return Object::Number(*GetGlobalProperty("result"));
 }
 
 TEST_F(CompilerTest, Inc) {
@@ -90,7 +90,7 @@ static double Add(Isolate* isolate, int x, int y) {
   Execution::CallScript(isolate, fun, global,
                         isolate->factory()->empty_fixed_array())
       .Check();
-  return GetGlobalProperty("result")->Number();
+  return Object::Number(*GetGlobalProperty("result"));
 }
 
 TEST_F(CompilerTest, Add) {
@@ -107,7 +107,7 @@ static double Abs(Isolate* isolate, int x) {
   Execution::CallScript(isolate, fun, global,
                         isolate->factory()->empty_fixed_array())
       .Check();
-  return GetGlobalProperty("result")->Number();
+  return Object::Number(*GetGlobalProperty("result"));
 }
 
 TEST_F(CompilerTest, Abs) {
@@ -125,7 +125,7 @@ static double Sum(Isolate* isolate, int n) {
   Execution::CallScript(isolate, fun, global,
                         isolate->factory()->empty_fixed_array())
       .Check();
-  return GetGlobalProperty("result")->Number();
+  return Object::Number(*GetGlobalProperty("result"));
 }
 
 TEST_F(CompilerTest, Sum) {
@@ -180,7 +180,7 @@ TEST_F(CompilerTest, Stuff) {
   Execution::CallScript(i_isolate(), fun, global,
                         i_isolate()->factory()->empty_fixed_array())
       .Check();
-  EXPECT_EQ(511.0, GetGlobalProperty("r")->Number());
+  EXPECT_EQ(511.0, Object::Number(*GetGlobalProperty("r")));
 }
 
 TEST_F(CompilerTest, UncaughtThrow) {
@@ -194,7 +194,7 @@ TEST_F(CompilerTest, UncaughtThrow) {
   EXPECT_TRUE(Execution::CallScript(isolate, fun, global,
                                     isolate->factory()->empty_fixed_array())
                   .is_null());
-  EXPECT_EQ(42.0, isolate->pending_exception().Number());
+  EXPECT_EQ(42.0, Object::Number(isolate->pending_exception()));
 }
 
 using CompilerC2JSFramesTest = WithPrintExtensionMixin<v8::TestWithIsolate>;
diff --git a/test/unittests/compiler/function-tester.cc b/test/unittests/compiler/function-tester.cc
index 50a98ed8e78..19caab83e86 100644
--- a/test/unittests/compiler/function-tester.cc
+++ b/test/unittests/compiler/function-tester.cc
@@ -95,7 +95,7 @@ void FunctionTester::CheckCall(Handle<Object> expected, Handle<Object> a,
                                Handle<Object> b, Handle<Object> c,
                                Handle<Object> d) {
   Handle<Object> result = Call(a, b, c, d).ToHandleChecked();
-  CHECK(expected->SameValue(*result));
+  CHECK(Object::SameValue(*expected, *result));
 }
 
 Handle<JSFunction> FunctionTester::NewFunction(const char* source) {
diff --git a/test/unittests/compiler/run-bytecode-graph-builder-unittest.cc b/test/unittests/compiler/run-bytecode-graph-builder-unittest.cc
index e6161dfd4b7..b7b8de7eb32 100644
--- a/test/unittests/compiler/run-bytecode-graph-builder-unittest.cc
+++ b/test/unittests/compiler/run-bytecode-graph-builder-unittest.cc
@@ -233,7 +233,7 @@ class RunBytecodeGraphBuilderTest : public TestWithNativeContext {
       auto callable = tester.GetCallable<Handle<Object>>();
       Handle<Object> return_value =
           callable(snippets[i].parameter(0)).ToHandleChecked();
-      CHECK(return_value->SameValue(*snippets[i].return_value()));
+      CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
     }
   }
 
@@ -280,7 +280,7 @@ class RunBytecodeGraphBuilderTest : public TestWithNativeContext {
       auto callable = tester.GetCallable<Handle<Object>>();
       Handle<Object> return_value =
           callable(snippets[i].parameter(0)).ToHandleChecked();
-      CHECK(return_value->SameValue(*snippets[i].return_value()));
+      CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
     }
   }
 
@@ -328,7 +328,7 @@ class RunBytecodeGraphBuilderTest : public TestWithNativeContext {
       BytecodeGraphTester tester(isolate, snippets[i].code_snippet);
       auto callable = tester.GetCallable<>();
       Handle<Object> return_value = callable().ToHandleChecked();
-      CHECK(return_value->SameValue(*snippets[i].return_value()));
+      CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
     }
   }
 
@@ -401,7 +401,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderReturnStatements) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -425,7 +425,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderPrimitiveExpressions) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -480,7 +480,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderTwoParameterTests) {
     Handle<Object> return_value =
         callable(snippets[i].parameter(0), snippets[i].parameter(1))
             .ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -512,7 +512,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderNamedLoad) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -558,7 +558,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderKeyedLoad) {
     Handle<Object> return_value =
         callable(snippets[i].parameter(0), snippets[i].parameter(1))
             .ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -590,7 +590,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderPropertyCall) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -625,7 +625,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCallNew) {
     BytecodeGraphTester tester(isolate, snippets[i].code_snippet);
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -660,7 +660,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCreateClosure) {
     BytecodeGraphTester tester(isolate, snippets[i].code_snippet);
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -682,7 +682,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCallRuntime) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -729,7 +729,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderToName) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -755,7 +755,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLogicalNot) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -782,7 +782,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderTypeOf) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -824,7 +824,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCompareTypeOf) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -870,7 +870,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCountOperation) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -901,7 +901,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderDelete) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -950,7 +950,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderDeleteGlobal) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -986,7 +986,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderDeleteLookupSlot) {
     BytecodeGraphTester tester(isolate, script.begin(), "t");
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1025,7 +1025,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLookupSlot) {
     BytecodeGraphTester tester(isolate, script.begin(), "t");
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1051,7 +1051,8 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLookupContextSlot) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*inner_eval_snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value,
+                            *inner_eval_snippets[i].return_value()));
   }
 
   // Testing with eval called in a parent context.
@@ -1073,7 +1074,8 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLookupContextSlot) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*outer_eval_snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value,
+                            *outer_eval_snippets[i].return_value()));
   }
 }
 
@@ -1099,7 +1101,8 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLookupGlobalSlot) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*inner_eval_snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value,
+                            *inner_eval_snippets[i].return_value()));
   }
 
   // Testing with eval called in a parent context.
@@ -1121,7 +1124,8 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLookupGlobalSlot) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*outer_eval_snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value,
+                            *outer_eval_snippets[i].return_value()));
   }
 }
 
@@ -1161,7 +1165,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLookupSlotWide) {
     BytecodeGraphTester tester(isolate, script.begin(), "t");
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1187,7 +1191,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCallLookupSlot) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1233,7 +1237,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderEval) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1259,7 +1263,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderEvalParams) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1282,7 +1286,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderEvalGlobal) {
     BytecodeGraphTester tester(isolate, snippets[i].code_snippet);
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1294,9 +1298,9 @@ bool get_compare_result(Isolate* isolate, Token::Value opcode,
     case Token::Value::NE:
       return !Object::Equals(isolate, lhs_value, rhs_value).FromJust();
     case Token::Value::EQ_STRICT:
-      return lhs_value->StrictEquals(*rhs_value);
+      return Object::StrictEquals(*lhs_value, *rhs_value);
     case Token::Value::NE_STRICT:
-      return !lhs_value->StrictEquals(*rhs_value);
+      return !Object::StrictEquals(*lhs_value, *rhs_value);
     case Token::Value::LT:
       return Object::LessThan(isolate, lhs_value, rhs_value).FromJust();
     case Token::Value::LTE:
@@ -1360,7 +1364,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCompare) {
             callable(lhs_values[j], rhs_values[k]).ToHandleChecked();
         bool result = get_compare_result(isolate, kCompareOperators[i],
                                          lhs_values[j], rhs_values[k]);
-        CHECK(return_value->SameValue(*factory->ToBoolean(result)));
+        CHECK(Object::SameValue(*return_value, *factory->ToBoolean(result)));
       }
     }
   }
@@ -1402,7 +1406,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderTestIn) {
     Handle<Object> return_value =
         callable(snippets[i].parameter(0), snippets[i].parameter(1))
             .ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1430,7 +1434,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderTestInstanceOf) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1457,7 +1461,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderTryCatch) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1493,7 +1497,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderTryFinally1) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1599,7 +1603,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderContext) {
     BytecodeGraphTester tester(isolate, script.begin(), "f");
     auto callable = tester.GetCallable<>("f");
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1662,7 +1666,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderLoadContext) {
     auto callable = tester.GetCallable<Handle<Object>>("f");
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1691,7 +1695,7 @@ TEST_F(RunBytecodeGraphBuilderTest,
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1735,7 +1739,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCreateArguments) {
         callable(snippets[i].parameter(0), snippets[i].parameter(1),
                  snippets[i].parameter(2))
             .ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1776,7 +1780,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderCreateRestArguments) {
         callable(snippets[i].parameter(0), snippets[i].parameter(1),
                  snippets[i].parameter(2))
             .ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1804,7 +1808,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderRegExpLiterals) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1839,7 +1843,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderArrayLiterals) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -1896,7 +1900,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderObjectLiterals) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2003,7 +2007,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderIf) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2031,7 +2035,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderConditionalOperator) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2076,7 +2080,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderSwitch) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2123,7 +2127,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderSwitchMerge) {
     auto callable = tester.GetCallable<Handle<Object>>();
     Handle<Object> return_value =
         callable(snippets[i].parameter(0)).ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2181,7 +2185,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderNestedSwitch) {
     Handle<Object> return_value =
         callable(snippets[i].parameter(0), snippets[i].parameter(1))
             .ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2219,7 +2223,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderBreakableBlocks) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2265,7 +2269,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderWhile) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2311,7 +2315,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderDo) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2402,7 +2406,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderFor) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2471,7 +2475,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderForIn) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2560,7 +2564,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderForOf) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2597,7 +2601,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderWithStatement) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2642,7 +2646,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderConstDeclaration) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 
   // Tests for strict mode.
@@ -2654,7 +2658,7 @@ TEST_F(RunBytecodeGraphBuilderTest, BytecodeGraphBuilderConstDeclaration) {
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2683,7 +2687,7 @@ TEST_F(RunBytecodeGraphBuilderTest,
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 
   // Tests for strict mode.
@@ -2695,7 +2699,7 @@ TEST_F(RunBytecodeGraphBuilderTest,
     BytecodeGraphTester tester(isolate, script.begin());
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*snippets[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *snippets[i].return_value()));
   }
 }
 
@@ -2742,7 +2746,7 @@ TEST_F(RunBytecodeGraphBuilderTest,
     BytecodeGraphTester tester(isolate, script.begin(), "*");
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*const_decl[i].return_value()));
+    CHECK(Object::SameValue(*return_value, *const_decl[i].return_value()));
   }
 }
 
diff --git a/test/unittests/compiler/run-jsobjects-unittest.cc b/test/unittests/compiler/run-jsobjects-unittest.cc
index 87df355ea04..11844512bf5 100644
--- a/test/unittests/compiler/run-jsobjects-unittest.cc
+++ b/test/unittests/compiler/run-jsobjects-unittest.cc
@@ -25,7 +25,7 @@ TEST_F(RunJSObjectsTest, ArgumentsMapped) {
   Handle<String> l = T.isolate->factory()->length_string();
   Handle<Object> length =
       Object::GetProperty(T.isolate, arguments, l).ToHandleChecked();
-  CHECK_EQ(4, length->Number());
+  CHECK_EQ(4, Object::Number(*length));
 }
 
 TEST_F(RunJSObjectsTest, ArgumentsUnmapped) {
@@ -40,7 +40,7 @@ TEST_F(RunJSObjectsTest, ArgumentsUnmapped) {
   Handle<String> l = T.isolate->factory()->length_string();
   Handle<Object> length =
       Object::GetProperty(T.isolate, arguments, l).ToHandleChecked();
-  CHECK_EQ(4, length->Number());
+  CHECK_EQ(4, Object::Number(*length));
 }
 
 TEST_F(RunJSObjectsTest, ArgumentsRest) {
@@ -54,7 +54,7 @@ TEST_F(RunJSObjectsTest, ArgumentsRest) {
   Handle<String> l = T.isolate->factory()->length_string();
   Handle<Object> length =
       Object::GetProperty(T.isolate, arguments, l).ToHandleChecked();
-  CHECK_EQ(3, length->Number());
+  CHECK_EQ(3, Object::Number(*length));
 }
 
 }  // namespace compiler
diff --git a/test/unittests/compiler/types-unittest.cc b/test/unittests/compiler/types-unittest.cc
index 785146ccd5f..e5318f3c162 100644
--- a/test/unittests/compiler/types-unittest.cc
+++ b/test/unittests/compiler/types-unittest.cc
@@ -186,12 +186,12 @@ class TypesTest : public TestWithNativeContextAndZone {
         CHECK(value.address() == type.AsHeapConstant()->Value().address());
       } else if (type.IsOtherNumberConstant()) {
         CHECK(IsHeapNumber(*value));
-        CHECK(value->Number() == type.AsOtherNumberConstant()->Value());
+        CHECK(Object::Number(*value) == type.AsOtherNumberConstant()->Value());
       } else if (type.IsBitset()) {
         CHECK(type.IsSingleton());
       } else {
         CHECK(type.IsRange());
-        double v = value->Number();
+        double v = Object::Number(*value);
         CHECK(v == type.AsRange()->Min() && v == type.AsRange()->Max());
       }
     }
@@ -330,8 +330,8 @@ class TypesTest : public TestWithNativeContextAndZone {
     // Constructor
     for (ValueIterator i = T.integers.begin(); i != T.integers.end(); ++i) {
       for (ValueIterator j = T.integers.begin(); j != T.integers.end(); ++j) {
-        double min = (*i)->Number();
-        double max = (*j)->Number();
+        double min = Object::Number(**i);
+        double max = Object::Number(**j);
         if (min > max) std::swap(min, max);
         Type type = T.Range(min, max);
         CHECK(type.IsRange());
@@ -341,8 +341,8 @@ class TypesTest : public TestWithNativeContextAndZone {
     // Range attributes
     for (ValueIterator i = T.integers.begin(); i != T.integers.end(); ++i) {
       for (ValueIterator j = T.integers.begin(); j != T.integers.end(); ++j) {
-        double min = (*i)->Number();
-        double max = (*j)->Number();
+        double min = Object::Number(**i);
+        double max = Object::Number(**j);
         if (min > max) std::swap(min, max);
         Type type = T.Range(min, max);
         CHECK(min == type.AsRange()->Min());
@@ -357,10 +357,10 @@ class TypesTest : public TestWithNativeContextAndZone {
         for (ValueIterator i2 = T.integers.begin(); i2 != T.integers.end();
              ++i2) {
           for (ValueIterator j2 = i2; j2 != T.integers.end(); ++j2) {
-            double min1 = (*i1)->Number();
-            double max1 = (*j1)->Number();
-            double min2 = (*i2)->Number();
-            double max2 = (*j2)->Number();
+            double min1 = Object::Number(**i1);
+            double max1 = Object::Number(**j1);
+            double min2 = Object::Number(**i2);
+            double max2 = Object::Number(**j2);
             if (min1 > max1) std::swap(min1, max1);
             if (min2 > max2) std::swap(min2, max2);
             Type type1 = T.Range(min1, max1);
@@ -564,10 +564,10 @@ class TypesTest : public TestWithNativeContextAndZone {
         for (ValueIterator i2 = T.integers.begin(); i2 != T.integers.end();
              ++i2) {
           for (ValueIterator j2 = i2; j2 != T.integers.end(); ++j2) {
-            double min1 = (*i1)->Number();
-            double max1 = (*j1)->Number();
-            double min2 = (*i2)->Number();
-            double max2 = (*j2)->Number();
+            double min1 = Object::Number(**i1);
+            double max1 = Object::Number(**j1);
+            double min2 = Object::Number(**i2);
+            double max2 = Object::Number(**j2);
             if (min1 > max1) std::swap(min1, max1);
             if (min2 > max2) std::swap(min2, max2);
             Type type1 = T.Range(min1, max1);
diff --git a/test/unittests/heap/cppgc-js/unified-heap-unittest.cc b/test/unittests/heap/cppgc-js/unified-heap-unittest.cc
index 93f53c0bf8f..cdcadb37014 100644
--- a/test/unittests/heap/cppgc-js/unified-heap-unittest.cc
+++ b/test/unittests/heap/cppgc-js/unified-heap-unittest.cc
@@ -687,7 +687,7 @@ TEST_F(UnifiedHeapTest, TracingInEphemerons) {
     Handle<JSObject> js_key =
         handle(JSObject::cast(*v8::Utils::OpenHandle(*key)), i_isolate());
     Handle<JSReceiver> js_value = v8::Utils::OpenHandle(*value);
-    int32_t hash = js_key->GetOrCreateHash(i_isolate()).value();
+    int32_t hash = Object::GetOrCreateHash(*js_key, i_isolate()).value();
     JSWeakCollection::Set(weak_map, js_key, js_value, hash);
   }
   CollectGarbageWithoutEmbedderStack(cppgc::Heap::SweepingType::kAtomic);
diff --git a/test/unittests/heap/global-handles-unittest.cc b/test/unittests/heap/global-handles-unittest.cc
index 7a08e2d1d0c..7c7d78b3b72 100644
--- a/test/unittests/heap/global-handles-unittest.cc
+++ b/test/unittests/heap/global-handles-unittest.cc
@@ -381,7 +381,7 @@ TEST_F(GlobalHandlesTest,
         Handle<JSReceiver> key =
             Utils::OpenHandle(*fp->handle.Get(v8_isolate()));
         Handle<Smi> smi(Smi::FromInt(23), isolate);
-        int32_t hash = key->GetOrCreateHash(isolate).value();
+        int32_t hash = Object::GetOrCreateHash(*key, isolate).value();
         JSWeakCollection::Set(weakmap, key, smi, hash);
       },
       SurvivalMode::kSurvives);
diff --git a/test/unittests/interpreter/bytecode-array-iterator-unittest.cc b/test/unittests/interpreter/bytecode-array-iterator-unittest.cc
index a15594c8f11..95f7d24f38d 100644
--- a/test/unittests/interpreter/bytecode-array-iterator-unittest.cc
+++ b/test/unittests/interpreter/bytecode-array-iterator-unittest.cc
@@ -78,7 +78,7 @@ TEST_F(BytecodeArrayIteratorTest, IteratesBytecodeArray) {
   EXPECT_EQ(iterator.current_bytecode(), Bytecode::kLdaConstant);
   EXPECT_EQ(iterator.current_offset(), offset);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_0);
   CHECK(!iterator.done());
   offset += Bytecodes::Size(Bytecode::kLdaConstant, OperandScale::kSingle);
@@ -94,7 +94,7 @@ TEST_F(BytecodeArrayIteratorTest, IteratesBytecodeArray) {
   EXPECT_EQ(iterator.current_bytecode(), Bytecode::kLdaConstant);
   EXPECT_EQ(iterator.current_offset(), offset);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_1);
   CHECK(!iterator.done());
   offset += Bytecodes::Size(Bytecode::kLdaConstant, OperandScale::kSingle);
diff --git a/test/unittests/interpreter/bytecode-array-random-iterator-unittest.cc b/test/unittests/interpreter/bytecode-array-random-iterator-unittest.cc
index 77ecbb99ee7..fd6579b76ee 100644
--- a/test/unittests/interpreter/bytecode-array-random-iterator-unittest.cc
+++ b/test/unittests/interpreter/bytecode-array-random-iterator-unittest.cc
@@ -178,7 +178,7 @@ TEST_F(BytecodeArrayRandomIteratorTest, AccessesFirst) {
   EXPECT_EQ(iterator.current_index(), 0);
   EXPECT_EQ(iterator.current_offset(), 0);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_0);
   ASSERT_TRUE(iterator.IsValid());
 }
@@ -320,7 +320,7 @@ TEST_F(BytecodeArrayRandomIteratorTest, RandomAccessValid) {
   EXPECT_EQ(iterator.current_index(), 2);
   EXPECT_EQ(iterator.current_offset(), offset);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_1);
   ASSERT_TRUE(iterator.IsValid());
 
@@ -472,7 +472,7 @@ TEST_F(BytecodeArrayRandomIteratorTest, IteratesBytecodeArray) {
   EXPECT_EQ(iterator.current_index(), 0);
   EXPECT_EQ(iterator.current_offset(), offset);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_0);
   ASSERT_TRUE(iterator.IsValid());
   offset += Bytecodes::Size(Bytecode::kLdaConstant, OperandScale::kSingle);
@@ -490,7 +490,7 @@ TEST_F(BytecodeArrayRandomIteratorTest, IteratesBytecodeArray) {
   EXPECT_EQ(iterator.current_index(), 2);
   EXPECT_EQ(iterator.current_offset(), offset);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_1);
   ASSERT_TRUE(iterator.IsValid());
   offset += Bytecodes::Size(Bytecode::kLdaConstant, OperandScale::kSingle);
@@ -902,7 +902,7 @@ TEST_F(BytecodeArrayRandomIteratorTest, IteratesBytecodeArrayBackwards) {
   EXPECT_EQ(iterator.current_index(), 2);
   EXPECT_EQ(iterator.current_offset(), offset);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_1);
   ASSERT_TRUE(iterator.IsValid());
   --iterator;
@@ -920,7 +920,7 @@ TEST_F(BytecodeArrayRandomIteratorTest, IteratesBytecodeArrayBackwards) {
   EXPECT_EQ(iterator.current_index(), 0);
   EXPECT_EQ(iterator.current_offset(), offset);
   EXPECT_EQ(iterator.current_operand_scale(), OperandScale::kSingle);
-  EXPECT_EQ(iterator.GetConstantForIndexOperand(0, isolate())->Number(),
+  EXPECT_EQ(Object::Number(*iterator.GetConstantForIndexOperand(0, isolate())),
             heap_num_0);
   ASSERT_TRUE(iterator.IsValid());
   --iterator;
diff --git a/test/unittests/interpreter/constant-array-builder-unittest.cc b/test/unittests/interpreter/constant-array-builder-unittest.cc
index 0c08804a75e..da7589423d2 100644
--- a/test/unittests/interpreter/constant-array-builder-unittest.cc
+++ b/test/unittests/interpreter/constant-array-builder-unittest.cc
@@ -59,7 +59,8 @@ TEST_F(ConstantArrayBuilderTest, ToFixedArray) {
   for (int i = 0; i < kNumberOfElements; i++) {
     Handle<Object> actual(constant_array->get(i), isolate());
     Handle<Object> expected = builder.At(i, isolate()).ToHandleChecked();
-    ASSERT_EQ(expected->Number(), actual->Number()) << "Failure at index " << i;
+    ASSERT_EQ(Object::Number(*expected), Object::Number(*actual))
+        << "Failure at index " << i;
   }
 }
 
@@ -74,7 +75,8 @@ TEST_F(ConstantArrayBuilderTest, ToLargeFixedArray) {
   for (int i = 0; i < kNumberOfElements; i++) {
     Handle<Object> actual(constant_array->get(i), isolate());
     Handle<Object> expected = builder.At(i, isolate()).ToHandleChecked();
-    ASSERT_EQ(expected->Number(), actual->Number()) << "Failure at index " << i;
+    ASSERT_EQ(Object::Number(*expected), Object::Number(*actual))
+        << "Failure at index " << i;
   }
 }
 
@@ -92,7 +94,8 @@ TEST_F(ConstantArrayBuilderTest, ToLargeFixedArrayWithReservations) {
   for (int i = 0; i < kNumberOfElements; i++) {
     Handle<Object> actual(constant_array->get(i), isolate());
     Handle<Object> expected = builder.At(i, isolate()).ToHandleChecked();
-    ASSERT_EQ(expected->Number(), actual->Number()) << "Failure at index " << i;
+    ASSERT_EQ(Object::Number(*expected), Object::Number(*actual))
+        << "Failure at index " << i;
   }
 }
 
@@ -153,12 +156,12 @@ TEST_F(ConstantArrayBuilderTest, AllocateEntriesWithIdx8Reservations) {
     for (size_t i = 0; i < k8BitCapacity - reserved; i++) {
       Object value = constant_array->get(static_cast<int>(i));
       Smi smi = Smi::FromInt(static_cast<int>(i));
-      CHECK(value.SameValue(smi));
+      CHECK(Object::SameValue(value, smi));
     }
     for (size_t i = k8BitCapacity; i < 2 * k8BitCapacity + reserved; i++) {
       Object value = constant_array->get(static_cast<int>(i));
       Smi smi = Smi::FromInt(static_cast<int>(i - reserved));
-      CHECK(value.SameValue(smi));
+      CHECK(Object::SameValue(value, smi));
     }
   }
 }
@@ -203,7 +206,8 @@ TEST_F(ConstantArrayBuilderTest, AllocateEntriesWithWideReservations) {
              static_cast<int>(k8BitCapacity + reserved));
     for (size_t i = 0; i < k8BitCapacity + reserved; i++) {
       Object value = constant_array->get(static_cast<int>(i));
-      CHECK(value.SameValue(*isolate()->factory()->NewNumberFromSize(i)));
+      CHECK(Object::SameValue(value,
+                              *isolate()->factory()->NewNumberFromSize(i)));
     }
   }
 }
@@ -233,9 +237,9 @@ TEST_F(ConstantArrayBuilderTest, GapFilledWhenLowReservationCommitted) {
   for (size_t i = 0; i < k8BitCapacity; i++) {
     Object original = constant_array->get(static_cast<int>(k8BitCapacity + i));
     Object duplicate = constant_array->get(static_cast<int>(i));
-    CHECK(original.SameValue(duplicate));
+    CHECK(Object::SameValue(original, duplicate));
     Handle<Object> reference = isolate()->factory()->NewNumberFromSize(i);
-    CHECK(original.SameValue(*reference));
+    CHECK(Object::SameValue(original, *reference));
   }
 }
 
@@ -264,7 +268,7 @@ TEST_F(ConstantArrayBuilderTest, GapNotFilledWhenLowReservationDiscarded) {
     Handle<Object> reference = isolate()->factory()->NewNumber(i + 0.5);
     Handle<Object> original =
         builder.At(k8BitCapacity + i, isolate()).ToHandleChecked();
-    CHECK(original->SameValue(*reference));
+    CHECK(Object::SameValue(*original, *reference));
     MaybeHandle<Object> duplicate = builder.At(i, isolate());
     CHECK(duplicate.is_null());
   }
@@ -295,13 +299,13 @@ TEST_F(ConstantArrayBuilderTest, HolesWithUnusedReservations) {
   Handle<FixedArray> constant_array = builder.ToFixedArray(isolate());
   CHECK_EQ(constant_array->length(), k8BitCapacity + 1);
   for (int i = kNumberOfHoles; i < k8BitCapacity; i++) {
-    CHECK(constant_array->get(i).SameValue(
-        *isolate()->factory()->the_hole_value()));
+    CHECK(Object::SameValue(constant_array->get(i),
+                            *isolate()->factory()->the_hole_value()));
   }
-  CHECK(!constant_array->get(kNumberOfHoles - 1)
-             .SameValue(*isolate()->factory()->the_hole_value()));
-  CHECK(!constant_array->get(k8BitCapacity)
-             .SameValue(*isolate()->factory()->the_hole_value()));
+  CHECK(!Object::SameValue(constant_array->get(kNumberOfHoles - 1),
+                           *isolate()->factory()->the_hole_value()));
+  CHECK(!Object::SameValue(constant_array->get(k8BitCapacity),
+                           *isolate()->factory()->the_hole_value()));
 }
 
 TEST_F(ConstantArrayBuilderTest, ReservationsAtAllScales) {
@@ -344,7 +348,7 @@ TEST_F(ConstantArrayBuilderTest, ReservationsAtAllScales) {
     } else {
       expected = isolate()->factory()->the_hole_value();
     }
-    CHECK(constant_array->get(i).SameValue(*expected));
+    CHECK(Object::SameValue(constant_array->get(i), *expected));
   }
 }
 
diff --git a/test/unittests/interpreter/interpreter-unittest.cc b/test/unittests/interpreter/interpreter-unittest.cc
index 1304c5aea45..69cfe986da7 100644
--- a/test/unittests/interpreter/interpreter-unittest.cc
+++ b/test/unittests/interpreter/interpreter-unittest.cc
@@ -264,7 +264,7 @@ TEST_F(InterpreterTest, InterpreterShiftOpsSmi) {
         Handle<Object> return_value = callable().ToHandleChecked();
         Handle<Object> expected_value =
             factory->NewNumber(BinaryOpC(kShiftOperators[o], lhs, rhs));
-        CHECK(return_value->SameValue(*expected_value));
+        CHECK(Object::SameValue(*return_value, *expected_value));
       }
     }
   }
@@ -300,7 +300,7 @@ TEST_F(InterpreterTest, InterpreterBinaryOpsSmi) {
         Handle<Object> return_value = callable().ToHandleChecked();
         Handle<Object> expected_value =
             factory->NewNumber(BinaryOpC(kArithmeticOperators[o], lhs, rhs));
-        CHECK(return_value->SameValue(*expected_value));
+        CHECK(Object::SameValue(*return_value, *expected_value));
       }
     }
   }
@@ -337,7 +337,7 @@ TEST_F(InterpreterTest, InterpreterBinaryOpsHeapNumber) {
         Handle<Object> return_value = callable().ToHandleChecked();
         Handle<Object> expected_value =
             factory->NewNumber(BinaryOpC(kArithmeticOperators[o], lhs, rhs));
-        CHECK(return_value->SameValue(*expected_value));
+        CHECK(Object::SameValue(*return_value, *expected_value));
       }
     }
   }
@@ -494,7 +494,7 @@ TEST_F(InterpreterTest, InterpreterStringAdd) {
     InterpreterTester tester(i_isolate(), bytecode_array, metadata);
     auto callable = tester.GetCallable<>();
     Handle<Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*test_cases[i].expected_value));
+    CHECK(Object::SameValue(*return_value, *test_cases[i].expected_value));
 
     if (tester.HasFeedbackMetadata()) {
       MaybeObject feedback = callable.vector()->Get(slot);
@@ -1371,7 +1371,7 @@ TEST_F(InterpreterTest, InterpreterCall) {
         "  this.func = function(a, b) { return a - b; }"
         "})()");
     Handle<Object> return_val = callable(object).ToHandleChecked();
-    CHECK(return_val->SameValue(Smi::FromInt(40)));
+    CHECK(Object::SameValue(*return_val, Smi::FromInt(40)));
   }
 
   // Check with 10 parameters (+ receiver).
@@ -1744,7 +1744,7 @@ TEST_F(InterpreterTest, InterpreterSmiComparisons) {
         auto callable = tester.GetCallable<>();
         Handle<Object> return_value = callable().ToHandleChecked();
         CHECK(IsBoolean(*return_value));
-        CHECK_EQ(return_value->BooleanValue(i_isolate()),
+        CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                  CompareC(comparison, inputs[i], inputs[j]));
         if (tester.HasFeedbackMetadata()) {
           MaybeObject feedback = callable.vector()->Get(slot);
@@ -1793,7 +1793,7 @@ TEST_F(InterpreterTest, InterpreterHeapNumberComparisons) {
         auto callable = tester.GetCallable<>();
         Handle<Object> return_value = callable().ToHandleChecked();
         CHECK(IsBoolean(*return_value));
-        CHECK_EQ(return_value->BooleanValue(i_isolate()),
+        CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                  CompareC(comparison, inputs[i], inputs[j]));
         if (tester.HasFeedbackMetadata()) {
           MaybeObject feedback = callable.vector()->Get(slot);
@@ -1884,7 +1884,7 @@ TEST_F(InterpreterTest, InterpreterStringComparisons) {
         auto callable = tester.GetCallable<>();
         Handle<Object> return_value = callable().ToHandleChecked();
         CHECK(IsBoolean(*return_value));
-        CHECK_EQ(return_value->BooleanValue(i_isolate()),
+        CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                  CompareC(comparison, inputs[i], inputs[j]));
         if (tester.HasFeedbackMetadata()) {
           MaybeObject feedback = callable.vector()->Get(slot);
@@ -1995,7 +1995,7 @@ TEST_F(InterpreterTest, InterpreterMixedComparisons) {
             auto callable = tester.GetCallable<>();
             Handle<Object> return_value = callable().ToHandleChecked();
             CHECK(IsBoolean(*return_value));
-            CHECK_EQ(return_value->BooleanValue(i_isolate()),
+            CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                      CompareC(comparison, lhs, rhs, true));
             if (tester.HasFeedbackMetadata()) {
               MaybeObject feedback = callable.vector()->Get(slot);
@@ -2043,7 +2043,7 @@ TEST_F(InterpreterTest, InterpreterStrictNotEqual) {
       Handle<Object> return_value =
           callable(lhs_obj, rhs_obj).ToHandleChecked();
       CHECK(IsBoolean(*return_value));
-      CHECK_EQ(return_value->BooleanValue(i_isolate()),
+      CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                CompareC(Token::Value::NE_STRICT, lhs, rhs, true));
     }
   }
@@ -2060,7 +2060,7 @@ TEST_F(InterpreterTest, InterpreterStrictNotEqual) {
       Handle<Object> return_value =
           callable(lhs_obj, rhs_obj).ToHandleChecked();
       CHECK(IsBoolean(*return_value));
-      CHECK_EQ(return_value->BooleanValue(i_isolate()),
+      CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                CompareC(Token::Value::NE_STRICT, inputs_str[i], inputs_str[j]));
     }
   }
@@ -2081,7 +2081,7 @@ TEST_F(InterpreterTest, InterpreterStrictNotEqual) {
       Handle<Object> return_value =
           callable(lhs_obj, rhs_obj).ToHandleChecked();
       CHECK(IsBoolean(*return_value));
-      CHECK_EQ(return_value->BooleanValue(i_isolate()),
+      CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                CompareC(Token::Value::NE_STRICT, inputs_number[i],
                         inputs_number[j]));
     }
@@ -2134,7 +2134,7 @@ TEST_F(InterpreterTest, InterpreterCompareTypeOf) {
     for (size_t i = 0; i < arraysize(inputs); i++) {
       Handle<Object> return_value = callable(inputs[i].first).ToHandleChecked();
       CHECK(IsBoolean(*return_value));
-      CHECK_EQ(return_value->BooleanValue(i_isolate()),
+      CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
                inputs[i].second == literal_flag);
     }
   }
@@ -2170,7 +2170,7 @@ TEST_F(InterpreterTest, InterpreterInstanceOf) {
     Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
     Handle<Object> return_value = RunBytecode(bytecode_array, metadata);
     CHECK(IsBoolean(*return_value));
-    CHECK_EQ(return_value->BooleanValue(i_isolate()), expected_value);
+    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()), expected_value);
   }
 }
 
@@ -2207,7 +2207,7 @@ TEST_F(InterpreterTest, InterpreterTestIn) {
     Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
     Handle<Object> return_value = RunBytecode(bytecode_array, metadata);
     CHECK(IsBoolean(*return_value));
-    CHECK_EQ(return_value->BooleanValue(i_isolate()), expected_value);
+    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()), expected_value);
   }
 }
 
@@ -2224,7 +2224,7 @@ TEST_F(InterpreterTest, InterpreterUnaryNot) {
     Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
     Handle<Object> return_value = RunBytecode(bytecode_array);
     CHECK(IsBoolean(*return_value));
-    CHECK_EQ(return_value->BooleanValue(i_isolate()), expected_value);
+    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()), expected_value);
   }
 }
 
@@ -2253,7 +2253,7 @@ TEST_F(InterpreterTest, InterpreterUnaryNotNonBoolean) {
     Handle<BytecodeArray> bytecode_array = builder.ToBytecodeArray(i_isolate());
     Handle<Object> return_value = RunBytecode(bytecode_array);
     CHECK(IsBoolean(*return_value));
-    CHECK_EQ(return_value->BooleanValue(i_isolate()),
+    CHECK_EQ(Object::BooleanValue(*return_value, i_isolate()),
              object_type_tuples[i].second);
   }
 }
@@ -2333,7 +2333,7 @@ TEST_F(InterpreterTest, InterpreterRegExpLiterals) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*literals[i].second));
+    CHECK(Object::SameValue(*return_value, *literals[i].second));
   }
 }
 
@@ -2359,7 +2359,7 @@ TEST_F(InterpreterTest, InterpreterArrayLiterals) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*literals[i].second));
+    CHECK(Object::SameValue(*return_value, *literals[i].second));
   }
 }
 
@@ -2408,7 +2408,7 @@ TEST_F(InterpreterTest, InterpreterObjectLiterals) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*literals[i].second));
+    CHECK(Object::SameValue(*return_value, *literals[i].second));
   }
 }
 
@@ -2494,7 +2494,7 @@ TEST_F(InterpreterTest, InterpreterContextVariables) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*context_vars[i].second));
+    CHECK(Object::SameValue(*return_value, *context_vars[i].second));
   }
 }
 
@@ -2519,7 +2519,7 @@ TEST_F(InterpreterTest, InterpreterContextParameters) {
     Handle<Object> a2 = handle(Smi::FromInt(2), i_isolate());
     Handle<Object> a3 = handle(Smi::FromInt(3), i_isolate());
     Handle<i::Object> return_value = callable(a1, a2, a3).ToHandleChecked();
-    CHECK(return_value->SameValue(*context_params[i].second));
+    CHECK(Object::SameValue(*return_value, *context_params[i].second));
   }
 }
 
@@ -2548,7 +2548,7 @@ TEST_F(InterpreterTest, InterpreterOuterContextVariables) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*context_vars[i].second));
+    CHECK(Object::SameValue(*return_value, *context_vars[i].second));
   }
 }
 
@@ -2573,7 +2573,7 @@ TEST_F(InterpreterTest, InterpreterComma) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*literals[i].second));
+    CHECK(Object::SameValue(*return_value, *literals[i].second));
   }
 }
 
@@ -2598,7 +2598,7 @@ TEST_F(InterpreterTest, InterpreterLogicalOr) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*literals[i].second));
+    CHECK(Object::SameValue(*return_value, *literals[i].second));
   }
 }
 
@@ -2628,7 +2628,7 @@ TEST_F(InterpreterTest, InterpreterLogicalAnd) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*literals[i].second));
+    CHECK(Object::SameValue(*return_value, *literals[i].second));
   }
 }
 
@@ -2651,7 +2651,7 @@ TEST_F(InterpreterTest, InterpreterTryCatch) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*catches[i].second));
+    CHECK(Object::SameValue(*return_value, *catches[i].second));
   }
 }
 
@@ -2705,7 +2705,7 @@ TEST_F(InterpreterTest, InterpreterTryFinally) {
     InterpreterTester tester(i_isolate(), source.c_str());
     tester.GetCallable<>();
     Handle<Object> wrapped = v8::Utils::OpenHandle(*CompileRun(try_wrapper));
-    CHECK(wrapped->SameValue(*finallies[i].second));
+    CHECK(Object::SameValue(*wrapped, *finallies[i].second));
   }
 }
 
@@ -2733,7 +2733,7 @@ TEST_F(InterpreterTest, InterpreterThrow) {
     InterpreterTester tester(i_isolate(), source.c_str());
     tester.GetCallable<>();
     Handle<Object> thrown_obj = v8::Utils::OpenHandle(*CompileRun(try_wrapper));
-    CHECK(thrown_obj->SameValue(*throws[i].second));
+    CHECK(Object::SameValue(*thrown_obj, *throws[i].second));
   }
 }
 
@@ -2791,7 +2791,7 @@ TEST_F(InterpreterTest, InterpreterCountOperators) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*count_ops[i].second));
+    CHECK(Object::SameValue(*return_value, *count_ops[i].second));
   }
 }
 
@@ -2816,7 +2816,7 @@ TEST_F(InterpreterTest, InterpreterGlobalCountOperators) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*count_ops[i].second));
+    CHECK(Object::SameValue(*return_value, *count_ops[i].second));
   }
 }
 
@@ -2844,7 +2844,7 @@ TEST_F(InterpreterTest, InterpreterCompoundExpressions) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*compound_expr[i].second));
+    CHECK(Object::SameValue(*return_value, *compound_expr[i].second));
   }
 }
 
@@ -2863,7 +2863,7 @@ TEST_F(InterpreterTest, InterpreterGlobalCompoundExpressions) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*compound_expr[i].second));
+    CHECK(Object::SameValue(*return_value, *compound_expr[i].second));
   }
 }
 
@@ -2936,7 +2936,7 @@ TEST_F(InterpreterTest, InterpreterCreateArguments) {
         tester.GetCallable<Handle<Object>, Handle<Object>, Handle<Object>>();
     Handle<Object> return_val =
         callable(args[0], args[1], args[2]).ToHandleChecked();
-    CHECK(return_val->SameValue(*args[create_args[i].second]));
+    CHECK(Object::SameValue(*return_val, *args[create_args[i].second]));
   }
 }
 
@@ -2966,7 +2966,7 @@ TEST_F(InterpreterTest, InterpreterConditional) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*conditional[i].second));
+    CHECK(Object::SameValue(*return_value, *conditional[i].second));
   }
 }
 
@@ -3007,7 +3007,7 @@ TEST_F(InterpreterTest, InterpreterDelete) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*test_delete[i].second));
+    CHECK(Object::SameValue(*return_value, *test_delete[i].second));
   }
 
   // Test delete in strict mode
@@ -3019,7 +3019,7 @@ TEST_F(InterpreterTest, InterpreterDelete) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*test_delete[i].second));
+    CHECK(Object::SameValue(*return_value, *test_delete[i].second));
   }
 }
 
@@ -3055,7 +3055,7 @@ TEST_F(InterpreterTest, InterpreterDeleteSloppyUnqualifiedIdentifier) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*test_delete[i].second));
+    CHECK(Object::SameValue(*return_value, *test_delete[i].second));
   }
 }
 
@@ -3118,7 +3118,7 @@ TEST_F(InterpreterTest, InterpreterGlobalDelete) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*test_global_delete[i].second));
+    CHECK(Object::SameValue(*return_value, *test_global_delete[i].second));
   }
 }
 
@@ -3211,7 +3211,7 @@ TEST_F(InterpreterTest, InterpreterBasicLoops) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*loops[i].second));
+    CHECK(Object::SameValue(*return_value, *loops[i].second));
   }
 }
 
@@ -3506,7 +3506,7 @@ TEST_F(InterpreterTest, InterpreterForOf) {
     InterpreterTester tester(i_isolate(), for_of[i].first);
     auto callable = tester.GetCallable<>();
     Handle<Object> return_val = callable().ToHandleChecked();
-    CHECK(return_val->SameValue(*for_of[i].second));
+    CHECK(Object::SameValue(*return_val, *for_of[i].second));
   }
 }
 
@@ -3583,7 +3583,7 @@ TEST_F(InterpreterTest, InterpreterSwitch) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*switch_ops[i].second));
+    CHECK(Object::SameValue(*return_value, *switch_ops[i].second));
   }
 }
 
@@ -3614,7 +3614,7 @@ TEST_F(InterpreterTest, InterpreterSloppyThis) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*sloppy_this[i].second));
+    CHECK(Object::SameValue(*return_value, *sloppy_this[i].second));
   }
 }
 
@@ -3626,7 +3626,8 @@ TEST_F(InterpreterTest, InterpreterThisFunction) {
   auto callable = tester.GetCallable<>();
 
   Handle<i::Object> return_value = callable().ToHandleChecked();
-  CHECK(return_value->SameValue(*factory->NewStringFromStaticChars("f")));
+  CHECK(Object::SameValue(*return_value,
+                          *factory->NewStringFromStaticChars("f")));
 }
 
 TEST_F(InterpreterTest, InterpreterNewTarget) {
@@ -3641,7 +3642,8 @@ TEST_F(InterpreterTest, InterpreterNewTarget) {
 
   Handle<Object> new_target_name = v8::Utils::OpenHandle(
       *CompileRun("(function() { return (new f()).a.name; })();"));
-  CHECK(new_target_name->SameValue(*factory->NewStringFromStaticChars("f")));
+  CHECK(Object::SameValue(*new_target_name,
+                          *factory->NewStringFromStaticChars("f")));
 }
 
 TEST_F(InterpreterTest, InterpreterAssignmentInExpressions) {
@@ -3818,7 +3820,7 @@ TEST_F(InterpreterTest, InterpreterToName) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*to_name_tests[i].second));
+    CHECK(Object::SameValue(*return_value, *to_name_tests[i].second));
   }
 }
 
@@ -3849,7 +3851,7 @@ TEST_F(InterpreterTest, TemporaryRegisterAllocation) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*reg_tests[i].second));
+    CHECK(Object::SameValue(*return_value, *reg_tests[i].second));
   }
 }
 
@@ -3885,7 +3887,7 @@ TEST_F(InterpreterTest, InterpreterLookupSlot) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*lookup_slot[i].second));
+    CHECK(Object::SameValue(*return_value, *lookup_slot[i].second));
   }
 }
 
@@ -3924,7 +3926,7 @@ TEST_F(InterpreterTest, InterpreterLookupContextSlot) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*std::get<2>(lookup_slot[i])));
+    CHECK(Object::SameValue(*return_value, *std::get<2>(lookup_slot[i])));
   }
 }
 
@@ -3962,7 +3964,7 @@ TEST_F(InterpreterTest, InterpreterLookupGlobalSlot) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*std::get<2>(lookup_slot[i])));
+    CHECK(Object::SameValue(*return_value, *std::get<2>(lookup_slot[i])));
   }
 }
 
@@ -3985,7 +3987,7 @@ TEST_F(InterpreterTest, InterpreterCallLookupSlot) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*call_lookup[i].second));
+    CHECK(Object::SameValue(*return_value, *call_lookup[i].second));
   }
 }
 
@@ -4026,7 +4028,7 @@ TEST_F(InterpreterTest, InterpreterLookupSlotWide) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*lookup_slot[i].second));
+    CHECK(Object::SameValue(*return_value, *lookup_slot[i].second));
   }
 }
 
@@ -4065,7 +4067,7 @@ TEST_F(InterpreterTest, InterpreterDeleteLookupSlot) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*delete_lookup_slot[i].second));
+    CHECK(Object::SameValue(*return_value, *delete_lookup_slot[i].second));
   }
 }
 
@@ -4145,7 +4147,7 @@ TEST_F(InterpreterTest, InterpreterEval) {
     InterpreterTester tester(i_isolate(), source.c_str());
     auto callable = tester.GetCallable<>();
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*eval[i].second));
+    CHECK(Object::SameValue(*return_value, *eval[i].second));
   }
 }
 
@@ -4169,7 +4171,7 @@ TEST_F(InterpreterTest, InterpreterEvalParams) {
 
     Handle<i::Object> return_value =
         callable(handle(Smi::FromInt(20), i_isolate())).ToHandleChecked();
-    CHECK(return_value->SameValue(*eval_params[i].second));
+    CHECK(Object::SameValue(*return_value, *eval_params[i].second));
   }
 }
 
@@ -4193,7 +4195,7 @@ TEST_F(InterpreterTest, InterpreterEvalGlobal) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*eval_global[i].second));
+    CHECK(Object::SameValue(*return_value, *eval_global[i].second));
   }
 }
 
@@ -4240,7 +4242,7 @@ TEST_F(InterpreterTest, InterpreterEvalVariableDecl) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*eval_global[i].second));
+    CHECK(Object::SameValue(*return_value, *eval_global[i].second));
   }
 }
 
@@ -4260,7 +4262,7 @@ TEST_F(InterpreterTest, InterpreterEvalFunctionDecl) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*eval_func_decl[i].second));
+    CHECK(Object::SameValue(*return_value, *eval_func_decl[i].second));
   }
 }
 
@@ -4298,7 +4300,7 @@ TEST_F(InterpreterTest, InterpreterWideRegisterArithmetic) {
   for (size_t i = 0; i < kMaxRegisterForTest; i++) {
     Handle<Object> arg = handle(Smi::FromInt(static_cast<int>(i)), i_isolate());
     Handle<Object> return_value = callable(arg).ToHandleChecked();
-    CHECK(return_value->SameValue(*arg));
+    CHECK(Object::SameValue(*return_value, *arg));
   }
 }
 
@@ -4427,7 +4429,7 @@ TEST_F(InterpreterTest, InterpreterWithStatement) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*with_stmt[i].second));
+    CHECK(Object::SameValue(*return_value, *with_stmt[i].second));
   }
 }
 
@@ -4486,7 +4488,7 @@ TEST_F(InterpreterTest, InterpreterClassLiterals) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*examples[i].second));
+    CHECK(Object::SameValue(*return_value, *examples[i].second));
   }
 }
 
@@ -4543,7 +4545,7 @@ TEST_F(InterpreterTest, InterpreterClassAndSuperClass) {
     InterpreterTester tester(i_isolate(), source.c_str(), "*");
     auto callable = tester.GetCallable<>();
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*examples[i].second));
+    CHECK(Object::SameValue(*return_value, *examples[i].second));
   }
 }
 
@@ -4585,7 +4587,7 @@ TEST_F(InterpreterTest, InterpreterConstDeclaration) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*const_decl[i].second));
+    CHECK(Object::SameValue(*return_value, *const_decl[i].second));
   }
 
   // Tests for strict mode.
@@ -4597,7 +4599,7 @@ TEST_F(InterpreterTest, InterpreterConstDeclaration) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*const_decl[i].second));
+    CHECK(Object::SameValue(*return_value, *const_decl[i].second));
   }
 }
 
@@ -4622,7 +4624,7 @@ TEST_F(InterpreterTest, InterpreterConstDeclarationLookupSlots) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*const_decl[i].second));
+    CHECK(Object::SameValue(*return_value, *const_decl[i].second));
   }
 
   // Tests for strict mode.
@@ -4634,7 +4636,7 @@ TEST_F(InterpreterTest, InterpreterConstDeclarationLookupSlots) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*const_decl[i].second));
+    CHECK(Object::SameValue(*return_value, *const_decl[i].second));
   }
 }
 
@@ -4677,7 +4679,7 @@ TEST_F(InterpreterTest, InterpreterConstInLookupContextChain) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*const_decl[i].second));
+    CHECK(Object::SameValue(*return_value, *const_decl[i].second));
   }
 }
 
@@ -4736,7 +4738,7 @@ TEST_F(InterpreterTest, InterpreterGenerators) {
     auto callable = tester.GetCallable<>();
 
     Handle<i::Object> return_value = callable().ToHandleChecked();
-    CHECK(return_value->SameValue(*tests[i].second));
+    CHECK(Object::SameValue(*return_value, *tests[i].second));
   }
 }
 
diff --git a/test/unittests/logging/log-unittest.cc b/test/unittests/logging/log-unittest.cc
index 71c187fd477..f5a29fd3a84 100644
--- a/test/unittests/logging/log-unittest.cc
+++ b/test/unittests/logging/log-unittest.cc
@@ -929,7 +929,7 @@ void ValidateMapDetailsLogging(v8::Isolate* isolate,
     uintptr_t address = obj.ptr();
     if (map_create_addresses.find(address) == map_create_addresses.end()) {
       // logger->PrintLog();
-      i::Map::cast(obj).Print();
+      i::Print(i::Map::cast(obj));
       FATAL(
           "Map (%p, #%zu) creation not logged during startup with "
           "--log-maps!"
@@ -939,7 +939,7 @@ void ValidateMapDetailsLogging(v8::Isolate* isolate,
     } else if (map_details_addresses.find(address) ==
                map_details_addresses.end()) {
       // logger->PrintLog();
-      i::Map::cast(obj).Print();
+      i::Print(i::Map::cast(obj));
       FATAL(
           "Map (%p, #%zu) details not logged during startup with "
           "--log-maps!"
diff --git a/test/unittests/objects/hashcode-unittest.cc b/test/unittests/objects/hashcode-unittest.cc
index 77e58a8d40e..3df90c28e2a 100644
--- a/test/unittests/objects/hashcode-unittest.cc
+++ b/test/unittests/objects/hashcode-unittest.cc
@@ -34,11 +34,12 @@ class HashcodeTest : public TestWithContext {
 
   int AddToSetAndGetHash(Handle<JSObject> obj, bool has_fast_properties) {
     CHECK_EQ(has_fast_properties, obj->HasFastProperties());
-    CHECK_EQ(ReadOnlyRoots(i_isolate()).undefined_value(), obj->GetHash());
+    CHECK_EQ(ReadOnlyRoots(i_isolate()).undefined_value(),
+             Object::GetHash(*obj));
     Handle<OrderedHashSet> set = i_isolate()->factory()->NewOrderedHashSet();
     OrderedHashSet::Add(i_isolate(), set, obj);
     CHECK_EQ(has_fast_properties, obj->HasFastProperties());
-    return Smi::ToInt(obj->GetHash());
+    return Smi::ToInt(Object::GetHash(*obj));
   }
 
   int GetPropertyDictionaryHash(Handle<JSObject> obj) {
@@ -68,14 +69,14 @@ class HashcodeTest : public TestWithContext {
   void CheckFastObject(Handle<JSObject> obj, int hash) {
     CHECK(obj->HasFastProperties());
     CHECK(IsPropertyArray(obj->raw_properties_or_hash()));
-    CHECK_EQ(Smi::FromInt(hash), obj->GetHash());
+    CHECK_EQ(Smi::FromInt(hash), Object::GetHash(*obj));
     CHECK_EQ(hash, obj->property_array()->Hash());
   }
 
   void CheckDictionaryObject(Handle<JSObject> obj, int hash) {
     CHECK(!obj->HasFastProperties());
     CheckIsDictionaryModeObject(obj);
-    CHECK_EQ(Smi::FromInt(hash), obj->GetHash());
+    CHECK_EQ(Smi::FromInt(hash), Object::GetHash(*obj));
     CHECK_EQ(hash, GetPropertyDictionaryHash(obj));
   }
 };
@@ -210,7 +211,7 @@ TEST_F(HashcodeTest, TransitionSlowToFastWithoutProperties) {
   CHECK_EQ(hash, GetPropertyDictionaryHash(obj));
 
   JSObject::MigrateSlowToFast(obj, 0, "cctest/test-hashcode");
-  CHECK_EQ(Smi::FromInt(hash), obj->GetHash());
+  CHECK_EQ(Smi::FromInt(hash), Object::GetHash(*obj));
 }
 
 TEST_F(HashcodeTest, TransitionSlowToFastWithPropertyArray) {
diff --git a/test/unittests/objects/symbols-unittest.cc b/test/unittests/objects/symbols-unittest.cc
index 08436edbdcc..d1f6247dae2 100644
--- a/test/unittests/objects/symbols-unittest.cc
+++ b/test/unittests/objects/symbols-unittest.cc
@@ -57,10 +57,10 @@ TEST_F(SymbolsTest, Create) {
     CHECK_GT(symbols[i]->hash(), 0u);
     os << Brief(*symbols[i]) << "\n";
 #if OBJECT_PRINT
-    symbols[i]->Print(os);
+    Print(*symbols[i], os);
 #endif
 #if VERIFY_HEAP
-    symbols[i]->ObjectVerify(isolate());
+    Object::ObjectVerify(*symbols[i], isolate());
 #endif
   }
 
@@ -69,9 +69,9 @@ TEST_F(SymbolsTest, Create) {
 
   // All symbols should be distinct.
   for (int i = 0; i < kNumSymbols; ++i) {
-    CHECK(symbols[i]->SameValue(*symbols[i]));
+    CHECK(Object::SameValue(*symbols[i], *symbols[i]));
     for (int j = i + 1; j < kNumSymbols; ++j) {
-      CHECK(!symbols[i]->SameValue(*symbols[j]));
+      CHECK(!Object::SameValue(*symbols[i], *symbols[j]));
     }
   }
 }
diff --git a/test/unittests/objects/weakmaps-unittest.cc b/test/unittests/objects/weakmaps-unittest.cc
index 01ab89cf4b1..65341d69606 100644
--- a/test/unittests/objects/weakmaps-unittest.cc
+++ b/test/unittests/objects/weakmaps-unittest.cc
@@ -80,9 +80,9 @@ TEST_F(WeakMapsTest, Weakness) {
     Handle<Map> map = factory->NewMap(JS_OBJECT_TYPE, JSObject::kHeaderSize);
     Handle<JSObject> object = factory->NewJSObjectFromMap(map);
     Handle<Smi> smi(Smi::FromInt(23), isolate);
-    int32_t hash = key->GetOrCreateHash(isolate).value();
+    int32_t hash = Object::GetOrCreateHash(*key, isolate).value();
     JSWeakCollection::Set(weakmap, key, object, hash);
-    int32_t object_hash = object->GetOrCreateHash(isolate).value();
+    int32_t object_hash = Object::GetOrCreateHash(*object, isolate).value();
     JSWeakCollection::Set(weakmap, object, smi, object_hash);
   }
   // Put a symbol key into weak map.
@@ -134,7 +134,7 @@ TEST_F(WeakMapsTest, Shrinking) {
     for (int i = 0; i < 32; i++) {
       Handle<JSObject> object = factory->NewJSObjectFromMap(map);
       Handle<Smi> smi(Smi::FromInt(i), isolate);
-      int32_t object_hash = object->GetOrCreateHash(isolate).value();
+      int32_t object_hash = Object::GetOrCreateHash(*object, isolate).value();
       JSWeakCollection::Set(weakmap, object, smi, object_hash);
     }
   }
@@ -178,7 +178,7 @@ TEST_F(WeakMapsTest, WeakMapPromotionMarkCompact) {
   Handle<Map> map = factory->NewMap(JS_OBJECT_TYPE, JSObject::kHeaderSize);
   Handle<JSObject> object = factory->NewJSObjectFromMap(map);
   Handle<Smi> smi(Smi::FromInt(1), isolate);
-  int32_t object_hash = object->GetOrCreateHash(isolate).value();
+  int32_t object_hash = Object::GetOrCreateHash(*object, isolate).value();
   JSWeakCollection::Set(weakmap, object, smi, object_hash);
 
   CHECK(EphemeronHashTableContainsKey(
@@ -211,7 +211,7 @@ TEST_F(WeakMapsTest, WeakMapScavenge) {
   Handle<Map> map = factory->NewMap(JS_OBJECT_TYPE, JSObject::kHeaderSize);
   Handle<JSObject> object = factory->NewJSObjectFromMap(map);
   Handle<Smi> smi(Smi::FromInt(1), isolate);
-  int32_t object_hash = object->GetOrCreateHash(isolate).value();
+  int32_t object_hash = Object::GetOrCreateHash(*object, isolate).value();
   JSWeakCollection::Set(weakmap, object, smi, object_hash);
 
   CHECK(EphemeronHashTableContainsKey(
@@ -261,7 +261,7 @@ TEST_F(WeakMapsTest, Regress2060a) {
       CHECK(!Heap::InYoungGeneration(*object));
       CHECK_IMPLIES(!v8_flags.enable_third_party_heap,
                     !first_page->Contains(object->address()));
-      int32_t hash = key->GetOrCreateHash(isolate).value();
+      int32_t hash = Object::GetOrCreateHash(*key, isolate).value();
       JSWeakCollection::Set(weakmap, key, object, hash);
     }
   }
@@ -303,7 +303,7 @@ TEST_F(WeakMapsTest, Regress2060b) {
   Handle<JSWeakMap> weakmap = isolate->factory()->NewJSWeakMap();
   for (int i = 0; i < 32; i++) {
     Handle<Smi> smi(Smi::FromInt(i), isolate);
-    int32_t hash = keys[i]->GetOrCreateHash(isolate).value();
+    int32_t hash = Object::GetOrCreateHash(*keys[i], isolate).value();
     JSWeakCollection::Set(weakmap, keys[i], smi, hash);
   }
 
@@ -353,8 +353,8 @@ TEST_F(WeakMapsTest, WeakMapsWithChainedEntries) {
     g2.SetWeak();
     Handle<Object> i_o1 = v8::Utils::OpenHandle(*o1);
     Handle<Object> i_o2 = v8::Utils::OpenHandle(*o2);
-    int32_t hash1 = i_o1->GetOrCreateHash(i_isolate()).value();
-    int32_t hash2 = i_o2->GetOrCreateHash(i_isolate()).value();
+    int32_t hash1 = Object::GetOrCreateHash(*i_o1, i_isolate()).value();
+    int32_t hash2 = Object::GetOrCreateHash(*i_o2, i_isolate()).value();
     JSWeakCollection::Set(weakmap1, i_o1, i_o2, hash1);
     JSWeakCollection::Set(weakmap2, i_o2, i_o1, hash2);
   }
diff --git a/test/unittests/objects/weaksets-unittest.cc b/test/unittests/objects/weaksets-unittest.cc
index e3e61dcdb3a..f97d3abf678 100644
--- a/test/unittests/objects/weaksets-unittest.cc
+++ b/test/unittests/objects/weaksets-unittest.cc
@@ -93,7 +93,7 @@ TEST_F(WeakSetsTest, WeakSet_Weakness) {
   {
     HandleScope inner_scope(i_isolate());
     Handle<Smi> smi(Smi::FromInt(23), i_isolate());
-    int32_t hash = key->GetOrCreateHash(i_isolate()).value();
+    int32_t hash = Object::GetOrCreateHash(*key, i_isolate()).value();
     JSWeakCollection::Set(weakset, key, smi, hash);
   }
   CHECK_EQ(1, EphemeronHashTable::cast(weakset->table())->NumberOfElements());
@@ -137,7 +137,7 @@ TEST_F(WeakSetsTest, WeakSet_Shrinking) {
     for (int i = 0; i < 32; i++) {
       Handle<JSObject> object = factory->NewJSObjectFromMap(map);
       Handle<Smi> smi(Smi::FromInt(i), i_isolate());
-      int32_t hash = object->GetOrCreateHash(i_isolate()).value();
+      int32_t hash = Object::GetOrCreateHash(*object, i_isolate()).value();
       JSWeakCollection::Set(weakset, object, smi, hash);
     }
   }
@@ -187,7 +187,7 @@ TEST_F(WeakSetsTest, WeakSet_Regress2060a) {
       CHECK(!Heap::InYoungGeneration(*object));
       CHECK_IMPLIES(!v8_flags.enable_third_party_heap,
                     !first_page->Contains(object->address()));
-      int32_t hash = key->GetOrCreateHash(i_isolate()).value();
+      int32_t hash = Object::GetOrCreateHash(*key, i_isolate()).value();
       JSWeakCollection::Set(weakset, key, object, hash);
     }
   }
@@ -231,7 +231,7 @@ TEST_F(WeakSetsTest, WeakSet_Regress2060b) {
   Handle<JSWeakSet> weakset = AllocateJSWeakSet();
   for (int i = 0; i < 32; i++) {
     Handle<Smi> smi(Smi::FromInt(i), i_isolate());
-    int32_t hash = keys[i]->GetOrCreateHash(i_isolate()).value();
+    int32_t hash = Object::GetOrCreateHash(*keys[i], i_isolate()).value();
     JSWeakCollection::Set(weakset, keys[i], smi, hash);
   }
 
diff --git a/test/unittests/parser/preparser-unittest.cc b/test/unittests/parser/preparser-unittest.cc
index ad5030bf7f1..891c642033a 100644
--- a/test/unittests/parser/preparser-unittest.cc
+++ b/test/unittests/parser/preparser-unittest.cc
@@ -57,7 +57,7 @@ TEST_F(PreParserTest, LazyFunctionLength) {
 
   Handle<Smi> length = RunJS<Smi>("lazy.length");
   int32_t value;
-  CHECK(length->ToInt32(&value));
+  CHECK(Object::ToInt32(*length, &value));
   CHECK_EQ(3, value);
 }
 
diff --git a/tools/gcmole/README b/tools/gcmole/README
index 15828fa4353..0b5fed89434 100644
--- a/tools/gcmole/README
+++ b/tools/gcmole/README
@@ -1,6 +1,6 @@
 DESCRIPTION -------------------------------------------------------------------
 
-gcmole is a simple static analysis tool used to find possible evaluation order 
+gcmole is a simple static analysis tool used to find possible evaluation order
 dependent GC-unsafe places in the V8 codebase and "stale" pointers to the heap
 (ones whose addresses got invalidated by the GC).
 
@@ -13,9 +13,9 @@ For example the following code is GC-unsafe:
     baz->Qux(*Foo());  // (a)
     Bar(*Foo(), *baz); // (b)
 
-Both in cases (a) and (b) compiler is free to evaluate call arguments (that 
-includes receiver) in any order. That means it can dereference baz before 
-calling to Foo and save a raw pointer to a heap object in the register or 
+Both in cases (a) and (b) compiler is free to evaluate call arguments (that
+includes receiver) in any order. That means it can dereference baz before
+calling to Foo and save a raw pointer to a heap object in the register or
 on the stack.
 
 In terms of the AST analysis that gcmole does, it warns about places in the
@@ -28,7 +28,7 @@ function was detected as potentially allocating, as in the previous example):
 
     JSObject raw_obj = ...;
     Foo();
-    raw_obj.Print();
+    Print(raw_obj);
 
 Since Foo can trigger a GC, it might have moved the raw_obj. The solution is
 simply to store it as a Handle.
@@ -43,7 +43,7 @@ PREREQUISITES -----------------------------------------------------------------
 
     Follow the instructions on http://clang.llvm.org/get_started.html.
 
-    Make sure to pass -DCMAKE_BUILD_TYPE=Release to cmake to get Release build 
+    Make sure to pass -DCMAKE_BUILD_TYPE=Release to cmake to get Release build
     instead of a Debug one.
 
 (3) Build gcmole Clang plugin (libgcmole.so)
@@ -73,16 +73,16 @@ CLANG_BIN=<path-to-clang-bin-folder> python tools/gcmole/gcmole.py [<arch>]
 
 where arch should be one of architectures supported by V8 (arm, ia32, x64).
 
-Analysis will be performed in 2 stages: 
+Analysis will be performed in 2 stages:
 
-- on the first stage driver will parse all files and build a global callgraph 
+- on the first stage driver will parse all files and build a global callgraph
 approximation to find all functions that might potentially cause GC, list
 of this functions will be written into gcsuspects file.
 
-- on the second stage driver will parse all files again and will locate all 
-callsites that might be GC-unsafe based on the list of functions causing GC. 
-Such places are marked with a "Possible problem with evaluation order." 
-warning. Messages "Failed to resolve v8::internal::Object" are benign and 
+- on the second stage driver will parse all files again and will locate all
+callsites that might be GC-unsafe based on the list of functions causing GC.
+Such places are marked with a "Possible problem with evaluation order."
+warning. Messages "Failed to resolve v8::internal::Object" are benign and
 can be ignored.
 
 If any errors were found driver exits with non-zero status.
diff --git a/tools/gcmole/gcmole-test.cc b/tools/gcmole/gcmole-test.cc
index 39d7ce1e154..b08f1bec8a1 100644
--- a/tools/gcmole/gcmole-test.cc
+++ b/tools/gcmole/gcmole-test.cc
@@ -37,8 +37,8 @@ Managed<Smi> CauseGCManaged(int i, Isolate* isolate) {
 }
 
 void TwoArgumentsFunction(Object a, Object b) {
-  a.Print();
-  b.Print();
+  Print(a);
+  Print(b);
 }
 
 void TestTwoArguments(Isolate* isolate) {
@@ -65,10 +65,10 @@ void TestTwoSizeTArguments(Isolate* isolate) {
 
 class SomeObject : public Object {
  public:
-  void Method(Object a) { a.Print(); }
+  void Method(Object a) { Print(a); }
 
   SomeObject& operator=(const Object& b) {
-    this->Print();
+    Print(*this);
     return *this;
   }
 
@@ -161,7 +161,7 @@ void TestDeadVarAnalysis(Isolate* isolate) {
   CauseGCRaw(raw_obj, isolate);
 
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestDeadVarBecauseOfSafepointAnalysis(Isolate* isolate) {
@@ -169,7 +169,7 @@ void TestDeadVarBecauseOfSafepointAnalysis(Isolate* isolate) {
   Safepoint();
 
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysis(Isolate* isolate) {
@@ -182,7 +182,7 @@ void TestGuardedDeadVarAnalysis(Isolate* isolate) {
   CauseGCRaw(raw_obj, isolate);
 
   // Shouldn't cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysis2(Isolate* isolate) {
@@ -195,7 +195,7 @@ void TestGuardedDeadVarAnalysis2(Isolate* isolate) {
   CauseGCRaw(raw_obj, isolate);
 
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedAgainstSafepointDeadVarAnalysis(Isolate* isolate) {
@@ -208,7 +208,7 @@ void TestGuardedAgainstSafepointDeadVarAnalysis(Isolate* isolate) {
   Safepoint();
 
   // Shouldn't cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedAgainstSafepointDeadVarAnalysis2(Isolate* isolate) {
@@ -221,7 +221,7 @@ void TestGuardedAgainstSafepointDeadVarAnalysis2(Isolate* isolate) {
   Safepoint();
 
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedAgainstSafepointDeadVarAnalysis3(Isolate* isolate) {
@@ -232,14 +232,14 @@ void TestGuardedAgainstSafepointDeadVarAnalysis3(Isolate* isolate) {
   DisallowGarbageCollection no_gc;
   Safepoint();
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
   {
     DisableGCMole no_gc_mole;
     // Shouldn't cause warning.
-    raw_obj.Print();
+    Print(raw_obj);
   }
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestOnlyHeapGuardedDeadVarAnalysisInCompound(Isolate* isolate) {
@@ -249,7 +249,7 @@ void TestOnlyHeapGuardedDeadVarAnalysisInCompound(Isolate* isolate) {
   DisallowHeapAccess no_gc;
   CauseGCRaw(raw_obj, isolate);
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestOnlyHeapGuardedDeadVarAnalysisInCompound2(Isolate* isolate) {
@@ -259,16 +259,16 @@ void TestOnlyHeapGuardedDeadVarAnalysisInCompound2(Isolate* isolate) {
   DisallowHeapAccess no_gc;
   CauseGCRaw(raw_obj, isolate);
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
   DisableGCMole no_gc_mole;
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysisNested(JSObject raw_obj, Isolate* isolate) {
   CauseGCRaw(raw_obj, isolate);
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysisCaller(Isolate* isolate) {
@@ -276,7 +276,7 @@ void TestGuardedDeadVarAnalysisCaller(Isolate* isolate) {
   JSObject raw_obj = *isolate->factory()->NewJSObjectWithNullProto();
   TestGuardedDeadVarAnalysisNested(raw_obj, isolate);
   // Shouldn't cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysisCaller2(Isolate* isolate) {
@@ -284,7 +284,7 @@ void TestGuardedDeadVarAnalysisCaller2(Isolate* isolate) {
   JSObject raw_obj = *isolate->factory()->NewJSObjectWithNullProto();
   TestGuardedDeadVarAnalysisNested(raw_obj, isolate);
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysisCaller3(Isolate* isolate) {
@@ -292,14 +292,14 @@ void TestGuardedDeadVarAnalysisCaller3(Isolate* isolate) {
   JSObject raw_obj = *isolate->factory()->NewJSObjectWithNullProto();
   TestGuardedDeadVarAnalysisNested(raw_obj, isolate);
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysisCaller4(Isolate* isolate) {
   JSObject raw_obj = *isolate->factory()->NewJSObjectWithNullProto();
   TestGuardedDeadVarAnalysisNested(raw_obj, isolate);
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 JSObject GuardedAllocation(Isolate* isolate) {
@@ -316,7 +316,7 @@ void TestNestedDeadVarAnalysis(Isolate* isolate) {
   JSObject raw_obj = GuardedAllocation(isolate);
   CauseGCRaw(raw_obj, isolate);
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestNestedDeadVarAnalysis2(Isolate* isolate) {
@@ -324,7 +324,7 @@ void TestNestedDeadVarAnalysis2(Isolate* isolate) {
   JSObject raw_obj = GuardedAllocation(isolate);
   CauseGCRaw(raw_obj, isolate);
   // Shouldn't cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 // Test that putting a guard in the middle of the function doesn't
@@ -335,7 +335,7 @@ void TestGuardedDeadVarAnalysisMidFunction(Isolate* isolate) {
   // Guarding the rest of the function from triggering a GC.
   DisallowGarbageCollection no_gc;
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 // Test that putting a guard in the middle of the function doesn't
@@ -346,7 +346,7 @@ void TestGuardedDeadVarAnalysisMidFunction2(Isolate* isolate) {
   // Guarding the rest of the function from triggering a GC.
   DisableGCMole no_gc_mole;
   // Should cause warning.
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 void TestGuardedDeadVarAnalysisMultipleSafepoints(Isolate* isolate) {
@@ -356,7 +356,7 @@ void TestGuardedDeadVarAnalysisMultipleSafepoints(Isolate* isolate) {
   JSObject raw_obj = *isolate->factory()->NewJSObjectWithNullProto();
   DisallowGarbageCollection no_gc;
   Safepoint();
-  raw_obj.Print();
+  Print(raw_obj);
 }
 
 }  // namespace internal
diff --git a/tools/gcmole/test-expectations.txt b/tools/gcmole/test-expectations.txt
index 549fb949f01..c09089ac51c 100644
--- a/tools/gcmole/test-expectations.txt
+++ b/tools/gcmole/test-expectations.txt
@@ -70,153 +70,153 @@ tools/gcmole/gcmole-test.cc:154:22: note: Call might cause unexpected GC.
 tools/gcmole/gcmole-test.cc:140:3: note: GC call here.
   static Handle<Object> StaticCauseGC(Handle<Object> obj, Isolate* isolate) {
   ^
-tools/gcmole/gcmole-test.cc:164:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:164:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:161:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:172:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:172:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:169:3: note: Call might cause unexpected GC.
   Safepoint();
   ^
 tools/gcmole/gcmole-test.cc:19:1: note: GC call here.
 void Safepoint() { LocalHeap::Current()->Safepoint(); }
 ^
-tools/gcmole/gcmole-test.cc:198:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:198:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:195:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:224:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:224:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:221:3: note: Call might cause unexpected GC.
   Safepoint();
   ^
 tools/gcmole/gcmole-test.cc:19:1: note: GC call here.
 void Safepoint() { LocalHeap::Current()->Safepoint(); }
 ^
-tools/gcmole/gcmole-test.cc:235:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:235:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:233:3: note: Call might cause unexpected GC.
   Safepoint();
   ^
 tools/gcmole/gcmole-test.cc:19:1: note: GC call here.
 void Safepoint() { LocalHeap::Current()->Safepoint(); }
 ^
-tools/gcmole/gcmole-test.cc:242:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:242:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:233:3: note: Call might cause unexpected GC.
   Safepoint();
   ^
 tools/gcmole/gcmole-test.cc:19:1: note: GC call here.
 void Safepoint() { LocalHeap::Current()->Safepoint(); }
 ^
-tools/gcmole/gcmole-test.cc:252:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:252:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:250:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:262:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:262:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:260:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:265:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:265:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:260:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:271:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:271:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:269:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:287:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:287:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:285:3: note: Call might cause unexpected GC.
   TestGuardedDeadVarAnalysisNested(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:268:1: note: GC call here.
 void TestGuardedDeadVarAnalysisNested(JSObject raw_obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:295:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:295:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:293:3: note: Call might cause unexpected GC.
   TestGuardedDeadVarAnalysisNested(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:268:1: note: GC call here.
 void TestGuardedDeadVarAnalysisNested(JSObject raw_obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:302:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:302:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:300:3: note: Call might cause unexpected GC.
   TestGuardedDeadVarAnalysisNested(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:268:1: note: GC call here.
 void TestGuardedDeadVarAnalysisNested(JSObject raw_obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:319:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:319:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:317:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:338:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:338:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:334:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:349:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:349:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:345:3: note: Call might cause unexpected GC.
   CauseGCRaw(raw_obj, isolate);
   ^
 tools/gcmole/gcmole-test.cc:27:1: note: GC call here.
 Object CauseGCRaw(Object obj, Isolate* isolate) {
 ^
-tools/gcmole/gcmole-test.cc:359:3: warning: Possibly stale variable due to GCs.
-  raw_obj.Print();
-  ^
+tools/gcmole/gcmole-test.cc:359:9: warning: Possibly stale variable due to GCs.
+  Print(raw_obj);
+        ^
 tools/gcmole/gcmole-test.cc:355:3: note: Call might cause unexpected GC.
   Safepoint();
   ^
-- 
2.35.1


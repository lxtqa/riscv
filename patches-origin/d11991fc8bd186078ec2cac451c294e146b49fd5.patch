From d11991fc8bd186078ec2cac451c294e146b49fd5 Mon Sep 17 00:00:00 2001
From: Peter Kasting <pkasting@chromium.org>
Date: Wed, 7 Jul 2021 07:12:26 -0700
Subject: [PATCH] Fix an instance of -Wimplicit-int-float-conversion.

Bug: chromium:989932
Change-Id: I357a19a9da934f07181122bbf50614ccddce3a4b
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3009926
Auto-Submit: Peter Kasting <pkasting@chromium.org>
Commit-Queue: Victor Gomes <victorgomes@chromium.org>
Reviewed-by: Victor Gomes <victorgomes@chromium.org>
Cr-Commit-Position: refs/heads/master@{#75612}
---
 test/cctest/compiler/test-run-machops.cc | 28 ++++++++++++------------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/test/cctest/compiler/test-run-machops.cc b/test/cctest/compiler/test-run-machops.cc
index 095405ea778..d91bb005a18 100644
--- a/test/cctest/compiler/test-run-machops.cc
+++ b/test/cctest/compiler/test-run-machops.cc
@@ -4424,29 +4424,29 @@ TEST(RunTruncateFloat32ToInt32) {
                                       TruncateKind::kArchitectureDefault));
     FOR_FLOAT32_INPUTS(i) {
       if (i < upper_bound && i >= lower_bound) {
-        CHECK_FLOAT_EQ(static_cast<int32_t>(i), m.Call(i));
+        CHECK_EQ(static_cast<int32_t>(i), m.Call(i));
       } else if (i < lower_bound) {
 #if (V8_TARGET_ARCH_MIPS || V8_TARGET_ARCH_MIPS64) && !_MIPS_ARCH_MIPS32R6 && \
     !_MIPS_ARCH_MIPS64R6
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::max(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::max(), m.Call(i));
 #else
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
 #endif
       } else if (i >= upper_bound) {
 #if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
 #else
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::max(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::max(), m.Call(i));
 #endif
       } else {
         DCHECK(std::isnan(i));
 #if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_S390X || \
     V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
 #elif V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_ARM
-        CHECK_FLOAT_EQ(0, m.Call(i));
+        CHECK_EQ(0, m.Call(i));
 #elif V8_TARGET_ARCH_RISCV64
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::max(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::max(), m.Call(i));
 #endif
       }
     }
@@ -4457,16 +4457,16 @@ TEST(RunTruncateFloat32ToInt32) {
                                       TruncateKind::kSetOverflowToMin));
     FOR_FLOAT32_INPUTS(i) {
       if (i < upper_bound && i >= lower_bound) {
-        CHECK_FLOAT_EQ(static_cast<int32_t>(i), m.Call(i));
+        CHECK_EQ(static_cast<int32_t>(i), m.Call(i));
       } else if (!std::isnan(i)) {
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
       } else {
         DCHECK(std::isnan(i));
 #if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_S390X || \
     V8_TARGET_ARCH_PPC || V8_TARGET_ARCH_PPC64
-        CHECK_FLOAT_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
+        CHECK_EQ(std::numeric_limits<int32_t>::min(), m.Call(i));
 #elif V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_ARM
-        CHECK_FLOAT_EQ(0, m.Call(i));
+        CHECK_EQ(0, m.Call(i));
 #endif
       }
     }
@@ -4501,7 +4501,7 @@ TEST(RunTruncateFloat32ToUint32) {
     }
     FOR_FLOAT32_INPUTS(j) {
       if ((j < upper_bound) && (j > lower_bound)) {
-        CHECK_FLOAT_EQ(static_cast<uint32_t>(j), m.Call(j));
+        CHECK_EQ(static_cast<uint32_t>(j), m.Call(j));
       }
     }
   }
@@ -4517,7 +4517,7 @@ TEST(RunTruncateFloat32ToUint32) {
     }
     FOR_FLOAT32_INPUTS(j) {
       if ((j < upper_bound) && (j > lower_bound)) {
-        CHECK_FLOAT_EQ(static_cast<uint32_t>(j), m.Call(j));
+        CHECK_EQ(static_cast<uint32_t>(j), m.Call(j));
       }
     }
   }
-- 
2.35.1


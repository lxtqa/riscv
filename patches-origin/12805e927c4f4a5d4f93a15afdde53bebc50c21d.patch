From 12805e927c4f4a5d4f93a15afdde53bebc50c21d Mon Sep 17 00:00:00 2001
From: Andreas Haas <ahaas@chromium.org>
Date: Tue, 27 Jun 2023 15:32:26 +0200
Subject: [PATCH] [builtin] Allow definition of return registers in
 interface-descriptors

So far builtins had to use the default return registers for up to three
GP returns and one FP return. With this CL a builtin can define builtins
with an arbitrary number of GP an FP register returns, with arbitrary
register configuration.

R=nicohartmann@chromium.org

Bug: v8:14035
Change-Id: I29e7e9a3103c862eafaf13ebd11097828c6c743c
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4626634
Reviewed-by: Nico Hartmann <nicohartmann@chromium.org>
Commit-Queue: Andreas Haas <ahaas@chromium.org>
Cr-Commit-Position: refs/heads/main@{#88505}
---
 .../arm/interface-descriptors-arm-inl.h       | 16 +++++
 .../arm64/interface-descriptors-arm64-inl.h   | 12 ++++
 .../ia32/interface-descriptors-ia32-inl.h     | 12 ++++
 src/codegen/interface-descriptors-inl.h       | 36 +++++++++--
 src/codegen/interface-descriptors.cc          | 60 ++++++++++++-------
 src/codegen/interface-descriptors.h           | 24 +++++++-
 .../interface-descriptors-loong64-inl.h       | 12 ++++
 .../mips64/interface-descriptors-mips64-inl.h | 12 ++++
 .../ppc/interface-descriptors-ppc-inl.h       | 12 ++++
 .../riscv/interface-descriptors-riscv-inl.h   | 12 ++++
 .../s390/interface-descriptors-s390-inl.h     | 12 ++++
 .../x64/interface-descriptors-x64-inl.h       | 12 ++++
 src/compiler/linkage.cc                       | 19 ++----
 13 files changed, 208 insertions(+), 43 deletions(-)

diff --git a/src/codegen/arm/interface-descriptors-arm-inl.h b/src/codegen/arm/interface-descriptors-arm-inl.h
index e36c8dd28df..3f9481058bb 100644
--- a/src/codegen/arm/interface-descriptors-arm-inl.h
+++ b/src/codegen/arm/interface-descriptors-arm-inl.h
@@ -28,6 +28,22 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Construct the std::array explicitly here because on arm, the registers d0,
+  // d1, ... are not of type DoubleRegister but only support implicit casting to
+  // DoubleRegister. For template resolution, however, implicit casting is not
+  // sufficient.
+  // Padding to have as many double return registers as GP return registers.
+  std::array<DoubleRegister, 3> registers{kFPReturnRegister0, no_dreg, no_dreg};
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/arm64/interface-descriptors-arm64-inl.h b/src/codegen/arm64/interface-descriptors-arm64-inl.h
index dd2cf186a51..b68ef4adf71 100644
--- a/src/codegen/arm64/interface-descriptors-arm64-inl.h
+++ b/src/codegen/arm64/interface-descriptors-arm64-inl.h
@@ -25,6 +25,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/ia32/interface-descriptors-ia32-inl.h b/src/codegen/ia32/interface-descriptors-ia32-inl.h
index 72b05091429..ee82d4828f3 100644
--- a/src/codegen/ia32/interface-descriptors-ia32-inl.h
+++ b/src/codegen/ia32/interface-descriptors-ia32-inl.h
@@ -24,6 +24,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/interface-descriptors-inl.h b/src/codegen/interface-descriptors-inl.h
index cfda2b65e39..cfb924c15ef 100644
--- a/src/codegen/interface-descriptors-inl.h
+++ b/src/codegen/interface-descriptors-inl.h
@@ -57,6 +57,20 @@ StaticCallInterfaceDescriptor<DerivedDescriptor>::double_registers() {
   return CallInterfaceDescriptor::DefaultDoubleRegisterArray();
 }
 
+// static
+template <typename DerivedDescriptor>
+constexpr auto
+StaticCallInterfaceDescriptor<DerivedDescriptor>::return_registers() {
+  return CallInterfaceDescriptor::DefaultReturnRegisterArray();
+}
+
+// static
+template <typename DerivedDescriptor>
+constexpr auto
+StaticCallInterfaceDescriptor<DerivedDescriptor>::return_double_registers() {
+  return CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray();
+}
+
 // static
 template <typename DerivedDescriptor>
 constexpr auto StaticJSCallInterfaceDescriptor<DerivedDescriptor>::registers() {
@@ -75,6 +89,9 @@ void StaticCallInterfaceDescriptor<DerivedDescriptor>::Initialize(
   // initialization
   static auto registers = DerivedDescriptor::registers();
   static auto double_registers = DerivedDescriptor::double_registers();
+  static auto return_registers = DerivedDescriptor::return_registers();
+  static auto return_double_registers =
+      DerivedDescriptor::return_double_registers();
 
   // The passed pointer should be a modifiable pointer to our own data.
   DCHECK_EQ(data, this->data());
@@ -86,12 +103,19 @@ void StaticCallInterfaceDescriptor<DerivedDescriptor>::Initialize(
     DCHECK(!DerivedDescriptor::kCalleeSaveRegisters);
   }
 
-  data->InitializeRegisters(DerivedDescriptor::flags(),
-                            DerivedDescriptor::kReturnCount,
-                            DerivedDescriptor::GetParameterCount(),
-                            DerivedDescriptor::kStackArgumentOrder,
-                            DerivedDescriptor::GetRegisterParameterCount(),
-                            registers.data(), double_registers.data());
+  // Make sure the defined arrays are big enough. The arrays can be filled up
+  // with `no_reg` and `no_dreg` to pass this DCHECK.
+  DCHECK_GE(registers.size(), GetRegisterParameterCount());
+  DCHECK_GE(double_registers.size(), GetRegisterParameterCount());
+  DCHECK_GE(return_registers.size(), DerivedDescriptor::kReturnCount);
+  DCHECK_GE(return_double_registers.size(), DerivedDescriptor::kReturnCount);
+  data->InitializeRegisters(
+      DerivedDescriptor::flags(), DerivedDescriptor::kReturnCount,
+      DerivedDescriptor::GetParameterCount(),
+      DerivedDescriptor::kStackArgumentOrder,
+      DerivedDescriptor::GetRegisterParameterCount(), registers.data(),
+      double_registers.data(), return_registers.data(),
+      return_double_registers.data());
 
   // InitializeTypes is customizable by the DerivedDescriptor subclass.
   DerivedDescriptor::InitializeTypes(data);
diff --git a/src/codegen/interface-descriptors.cc b/src/codegen/interface-descriptors.cc
index 1cb8b52d871..250b1963447 100644
--- a/src/codegen/interface-descriptors.cc
+++ b/src/codegen/interface-descriptors.cc
@@ -10,35 +10,45 @@
 namespace v8 {
 namespace internal {
 
+#ifdef DEBUG
+void CheckRegisterConfiguration(int count, const Register* registers,
+                                const DoubleRegister* double_registers) {
+  // Make sure that the registers are all valid, and don't alias each other.
+  RegList reglist;
+  DoubleRegList double_reglist;
+  for (int i = 0; i < count; ++i) {
+    Register reg = registers[i];
+    DoubleRegister dreg = double_registers[i];
+    DCHECK(reg.is_valid() || dreg.is_valid());
+    DCHECK_NE(reg, kRootRegister);
+#ifdef V8_COMPRESS_POINTERS
+    DCHECK_NE(reg, kPtrComprCageBaseRegister);
+#endif
+    if (reg.is_valid()) {
+      DCHECK(!reglist.has(reg));
+      reglist.set(reg);
+    }
+    if (dreg.is_valid()) {
+      DCHECK(!double_reglist.has(dreg));
+      double_reglist.set(dreg);
+    }
+  }
+}
+#endif
+
 void CallInterfaceDescriptorData::InitializeRegisters(
     Flags flags, int return_count, int parameter_count,
     StackArgumentOrder stack_order, int register_parameter_count,
-    const Register* registers, const DoubleRegister* double_registers) {
+    const Register* registers, const DoubleRegister* double_registers,
+    const Register* return_registers,
+    const DoubleRegister* return_double_registers) {
   DCHECK(!IsInitializedTypes());
 
 #ifdef DEBUG
-  {
-    // Make sure that the registers are all valid, and don't alias each other.
-    RegList reglist;
-    DoubleRegList double_reglist;
-    for (int i = 0; i < register_parameter_count; ++i) {
-      Register reg = registers[i];
-      DoubleRegister dreg = double_registers[i];
-      DCHECK(reg.is_valid() || dreg.is_valid());
-      DCHECK_NE(reg, kRootRegister);
-#ifdef V8_COMPRESS_POINTERS
-      DCHECK_NE(reg, kPtrComprCageBaseRegister);
-#endif
-      if (reg.is_valid()) {
-        DCHECK(!reglist.has(reg));
-        reglist.set(reg);
-      }
-      if (dreg.is_valid()) {
-        DCHECK(!double_reglist.has(dreg));
-        double_reglist.set(dreg);
-      }
-    }
-  }
+  CheckRegisterConfiguration(register_parameter_count, registers,
+                             double_registers);
+  CheckRegisterConfiguration(return_count, return_registers,
+                             return_double_registers);
 #endif
 
   flags_ = flags;
@@ -50,6 +60,8 @@ void CallInterfaceDescriptorData::InitializeRegisters(
   // The caller owns the the registers array, so we just set the pointer.
   register_params_ = registers;
   double_register_params_ = double_registers;
+  register_returns_ = return_registers;
+  double_register_returns_ = return_double_registers;
 }
 
 void CallInterfaceDescriptorData::InitializeTypes(
@@ -87,6 +99,8 @@ void CallInterfaceDescriptorData::Reset() {
   machine_types_ = nullptr;
   register_params_ = nullptr;
   double_register_params_ = nullptr;
+  register_returns_ = nullptr;
+  double_register_returns_ = nullptr;
 }
 
 // static
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index 93c189ed1c0..326353b6ae0 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -187,7 +187,9 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
                            StackArgumentOrder stack_order,
                            int register_parameter_count,
                            const Register* registers,
-                           const DoubleRegister* double_registers);
+                           const DoubleRegister* double_registers,
+                           const Register* return_registers,
+                           const DoubleRegister* return_double_registers);
 
   // if machine_types is null, then an array of size
   // (return_count + parameter_count) will be created with
@@ -214,6 +216,10 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   DoubleRegister double_register_param(int index) const {
     return double_register_params_[index];
   }
+  Register register_return(int index) const { return register_returns_[index]; }
+  DoubleRegister double_register_return(int index) const {
+    return double_register_returns_[index];
+  }
   MachineType return_type(int index) const {
     DCHECK_LT(index, return_count_);
     return machine_types_[index];
@@ -271,6 +277,8 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   // allocated dynamically by the InterfaceDescriptor and freed on destruction.
   const Register* register_params_ = nullptr;
   const DoubleRegister* double_register_params_ = nullptr;
+  const Register* register_returns_ = nullptr;
+  const DoubleRegister* double_register_returns_ = nullptr;
   MachineType* machine_types_ = nullptr;
 };
 
@@ -377,6 +385,16 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
     return data()->double_register_param(index);
   }
 
+  Register GetRegisterReturn(int index) const {
+    DCHECK_LT(index, data()->return_count());
+    return data()->register_return(index);
+  }
+
+  DoubleRegister GetDoubleRegisterReturn(int index) const {
+    DCHECK_LT(index, data()->return_count());
+    return data()->double_register_return(index);
+  }
+
   MachineType GetParameterType(int index) const {
     DCHECK_LT(index, data()->param_count());
     return data()->param_type(index);
@@ -409,6 +427,8 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
   // differently sized default register arrays.
   static constexpr inline auto DefaultRegisterArray();
   static constexpr inline auto DefaultDoubleRegisterArray();
+  static constexpr inline auto DefaultReturnRegisterArray();
+  static constexpr inline auto DefaultReturnDoubleRegisterArray();
   static constexpr inline std::array<Register, kJSBuiltinRegisterParams>
   DefaultJSRegisterArray();
 
@@ -456,6 +476,8 @@ class StaticCallInterfaceDescriptor : public CallInterfaceDescriptor {
   // Defaults to CallInterfaceDescriptor::DefaultRegisterArray().
   static constexpr inline auto registers();
   static constexpr inline auto double_registers();
+  static constexpr inline auto return_registers();
+  static constexpr inline auto return_double_registers();
 
   // An additional limit on the number of register parameters allowed. This is
   // here so that it can be overwritten to kMaxTFSBuiltinRegisterParams for TFS
diff --git a/src/codegen/loong64/interface-descriptors-loong64-inl.h b/src/codegen/loong64/interface-descriptors-loong64-inl.h
index 216614b1bb6..a671f41066e 100644
--- a/src/codegen/loong64/interface-descriptors-loong64-inl.h
+++ b/src/codegen/loong64/interface-descriptors-loong64-inl.h
@@ -24,6 +24,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/mips64/interface-descriptors-mips64-inl.h b/src/codegen/mips64/interface-descriptors-mips64-inl.h
index 506c6e4d222..16ebff25ffd 100644
--- a/src/codegen/mips64/interface-descriptors-mips64-inl.h
+++ b/src/codegen/mips64/interface-descriptors-mips64-inl.h
@@ -24,6 +24,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/ppc/interface-descriptors-ppc-inl.h b/src/codegen/ppc/interface-descriptors-ppc-inl.h
index 8edf0302655..6e30d7791e3 100644
--- a/src/codegen/ppc/interface-descriptors-ppc-inl.h
+++ b/src/codegen/ppc/interface-descriptors-ppc-inl.h
@@ -24,6 +24,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/riscv/interface-descriptors-riscv-inl.h b/src/codegen/riscv/interface-descriptors-riscv-inl.h
index 8affc87052d..f6fe9b48fef 100644
--- a/src/codegen/riscv/interface-descriptors-riscv-inl.h
+++ b/src/codegen/riscv/interface-descriptors-riscv-inl.h
@@ -23,6 +23,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/s390/interface-descriptors-s390-inl.h b/src/codegen/s390/interface-descriptors-s390-inl.h
index 1e1f002fa45..fbf3b831d7f 100644
--- a/src/codegen/s390/interface-descriptors-s390-inl.h
+++ b/src/codegen/s390/interface-descriptors-s390-inl.h
@@ -24,6 +24,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/x64/interface-descriptors-x64-inl.h b/src/codegen/x64/interface-descriptors-x64-inl.h
index 25493393f94..87e3a984f56 100644
--- a/src/codegen/x64/interface-descriptors-x64-inl.h
+++ b/src/codegen/x64/interface-descriptors-x64-inl.h
@@ -24,6 +24,18 @@ constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultReturnRegisterArray() {
+  auto registers =
+      RegisterArray(kReturnRegister0, kReturnRegister1, kReturnRegister2);
+  return registers;
+}
+
+constexpr auto CallInterfaceDescriptor::DefaultReturnDoubleRegisterArray() {
+  // Padding to have as many double return registers as GP return registers.
+  auto registers = DoubleRegisterArray(kFPReturnRegister0, no_dreg, no_dreg);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/compiler/linkage.cc b/src/compiler/linkage.cc
index 4edb94b1f81..97fb067b244 100644
--- a/src/compiler/linkage.cc
+++ b/src/compiler/linkage.cc
@@ -455,27 +455,20 @@ CallDescriptor* Linkage::GetStubCallDescriptor(
 
   DCHECK_GE(stack_parameter_count, descriptor.GetStackParameterCount());
 
-  size_t return_count = descriptor.GetReturnCount();
+  int return_count = descriptor.GetReturnCount();
   LocationSignature::Builder locations(zone, return_count, parameter_count);
 
   // Add returns.
-  static constexpr Register return_registers[] = {
-      kReturnRegister0, kReturnRegister1, kReturnRegister2};
-  size_t num_returns = 0;
-  size_t num_fp_returns = 0;
-  for (size_t i = 0; i < locations.return_count_; i++) {
+  for (int i = 0; i < return_count; i++) {
     MachineType type = descriptor.GetReturnType(static_cast<int>(i));
     if (IsFloatingPoint(type.representation())) {
-      DCHECK_LT(num_fp_returns, 1);  // Only 1 FP return is supported.
-      locations.AddReturn(regloc(kFPReturnRegister0, type));
-      num_fp_returns++;
+      DoubleRegister reg = descriptor.GetDoubleRegisterReturn(i);
+      locations.AddReturn(regloc(reg, type));
     } else {
-      DCHECK_LT(num_returns, arraysize(return_registers));
-      locations.AddReturn(regloc(return_registers[num_returns], type));
-      num_returns++;
+      Register reg = descriptor.GetRegisterReturn(i);
+      locations.AddReturn(regloc(reg, type));
     }
   }
-  USE(num_fp_returns);
 
   // Add parameters in registers and on the stack.
   for (int i = 0; i < js_parameter_count; i++) {
-- 
2.35.1


From 28b5d299845f6ca289647241badd08844b51bb7c Mon Sep 17 00:00:00 2001
From: Anton Bikineev <bikineev@chromium.org>
Date: Mon, 27 Jun 2022 13:37:04 +0200
Subject: [PATCH] Move host/target detection macros to API

Since v8config.h already defines the related logic for OS detection, it
should be fine to move arch detection also there. The CL also makes
Oilpan use one of those macros to avoid discrepancy between the compiler
and custom macros (the discrepancy occurs for host tools, e.g. mksnapshot).

Bug: chromium:1336222
Change-Id: Ibe7d9116d27c3e816f4778fd4c149d8142d0f7a9
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3726208
Commit-Queue: Anton Bikineev <bikineev@chromium.org>
Reviewed-by: Michael Lippautz <mlippautz@chromium.org>
Cr-Commit-Position: refs/heads/main@{#81397}
---
 include/cppgc/internal/api-constants.h |   2 +-
 include/v8config.h                     | 199 +++++++++++++++++++++++++
 src/base/build_config.h                | 194 ------------------------
 src/heap/cppgc/globals.h               |   5 +-
 4 files changed, 201 insertions(+), 199 deletions(-)

diff --git a/include/cppgc/internal/api-constants.h b/include/cppgc/internal/api-constants.h
index 30230a07d48..d4dfbe26891 100644
--- a/include/cppgc/internal/api-constants.h
+++ b/include/cppgc/internal/api-constants.h
@@ -32,7 +32,7 @@ static constexpr uint16_t kFullyConstructedBitMask = uint16_t{1};
 
 static constexpr size_t kPageSize = size_t{1} << 17;
 
-#if defined(__aarch64__) && defined(V8_OS_MACOS)
+#if defined(V8_TARGET_ARCH_ARM64) && defined(V8_OS_MACOS)
 constexpr size_t kGuardPageSize = 0;
 #else
 constexpr size_t kGuardPageSize = 4096;
diff --git a/include/v8config.h b/include/v8config.h
index 0e5bb1558d0..714d8a6f057 100644
--- a/include/v8config.h
+++ b/include/v8config.h
@@ -589,6 +589,205 @@ V8 shared library set USING_V8_SHARED.
 
 // clang-format on
 
+// Processor architecture detection.  For more info on what's defined, see:
+//   http://msdn.microsoft.com/en-us/library/b0084kay.aspx
+//   http://www.agner.org/optimize/calling_conventions.pdf
+//   or with gcc, run: "echo | gcc -E -dM -"
+// The V8_HOST_ARCH_* macros correspond to the architecture on which V8, as a
+// virtual machine and compiler, runs. Don't confuse this with the architecture
+// on which V8 is built.
+#if defined(_M_X64) || defined(__x86_64__)
+#define V8_HOST_ARCH_X64 1
+#if defined(__x86_64__) && __SIZEOF_POINTER__ == 4  // Check for x32.
+#define V8_HOST_ARCH_32_BIT 1
+#else
+#define V8_HOST_ARCH_64_BIT 1
+#endif
+#elif defined(_M_IX86) || defined(__i386__)
+#define V8_HOST_ARCH_IA32 1
+#define V8_HOST_ARCH_32_BIT 1
+#elif defined(__AARCH64EL__) || defined(_M_ARM64)
+#define V8_HOST_ARCH_ARM64 1
+#define V8_HOST_ARCH_64_BIT 1
+#elif defined(__ARMEL__)
+#define V8_HOST_ARCH_ARM 1
+#define V8_HOST_ARCH_32_BIT 1
+#elif defined(__mips64)
+#define V8_HOST_ARCH_MIPS64 1
+#define V8_HOST_ARCH_64_BIT 1
+#elif defined(__MIPSEB__) || defined(__MIPSEL__)
+#define V8_HOST_ARCH_MIPS 1
+#define V8_HOST_ARCH_32_BIT 1
+#elif defined(__loongarch64)
+#define V8_HOST_ARCH_LOONG64 1
+#define V8_HOST_ARCH_64_BIT 1
+#elif defined(__PPC64__) || defined(_ARCH_PPC64)
+#define V8_HOST_ARCH_PPC64 1
+#define V8_HOST_ARCH_64_BIT 1
+#elif defined(__PPC__) || defined(_ARCH_PPC)
+#define V8_HOST_ARCH_PPC 1
+#define V8_HOST_ARCH_32_BIT 1
+#elif defined(__s390__) || defined(__s390x__)
+#define V8_HOST_ARCH_S390 1
+#if defined(__s390x__)
+#define V8_HOST_ARCH_64_BIT 1
+#else
+#define V8_HOST_ARCH_32_BIT 1
+#endif
+#elif defined(__riscv) || defined(__riscv__)
+#if __riscv_xlen == 64
+#define V8_HOST_ARCH_RISCV64 1
+#define V8_HOST_ARCH_64_BIT 1
+#else
+#error "Cannot detect Riscv's bitwidth"
+#endif
+#else
+#error "Host architecture was not detected as supported by v8"
+#endif
+
+// Target architecture detection. This corresponds to the architecture for which
+// V8's JIT will generate code (the last stage of the canadian cross-compiler).
+// The macros may be set externally. If not, detect in the same way as the host
+// architecture, that is, target the native environment as presented by the
+// compiler.
+#if !V8_TARGET_ARCH_X64 && !V8_TARGET_ARCH_IA32 && !V8_TARGET_ARCH_ARM &&      \
+    !V8_TARGET_ARCH_ARM64 && !V8_TARGET_ARCH_MIPS && !V8_TARGET_ARCH_MIPS64 && \
+    !V8_TARGET_ARCH_PPC && !V8_TARGET_ARCH_PPC64 && !V8_TARGET_ARCH_S390 &&    \
+    !V8_TARGET_ARCH_RISCV64 && !V8_TARGET_ARCH_LOONG64
+#if defined(_M_X64) || defined(__x86_64__)
+#define V8_TARGET_ARCH_X64 1
+#elif defined(_M_IX86) || defined(__i386__)
+#define V8_TARGET_ARCH_IA32 1
+#elif defined(__AARCH64EL__) || defined(_M_ARM64)
+#define V8_TARGET_ARCH_ARM64 1
+#elif defined(__ARMEL__)
+#define V8_TARGET_ARCH_ARM 1
+#elif defined(__mips64)
+#define V8_TARGET_ARCH_MIPS64 1
+#elif defined(__MIPSEB__) || defined(__MIPSEL__)
+#define V8_TARGET_ARCH_MIPS 1
+#elif defined(_ARCH_PPC64)
+#define V8_TARGET_ARCH_PPC64 1
+#elif defined(_ARCH_PPC)
+#define V8_TARGET_ARCH_PPC 1
+#elif defined(__riscv) || defined(__riscv__)
+#if __riscv_xlen == 64
+#define V8_TARGET_ARCH_RISCV64 1
+#endif
+#else
+#error Target architecture was not detected as supported by v8
+#endif
+#endif
+
+// Determine architecture pointer size.
+#if V8_TARGET_ARCH_IA32
+#define V8_TARGET_ARCH_32_BIT 1
+#elif V8_TARGET_ARCH_X64
+#if !V8_TARGET_ARCH_32_BIT && !V8_TARGET_ARCH_64_BIT
+#if defined(__x86_64__) && __SIZEOF_POINTER__ == 4  // Check for x32.
+#define V8_TARGET_ARCH_32_BIT 1
+#else
+#define V8_TARGET_ARCH_64_BIT 1
+#endif
+#endif
+#elif V8_TARGET_ARCH_ARM
+#define V8_TARGET_ARCH_32_BIT 1
+#elif V8_TARGET_ARCH_ARM64
+#define V8_TARGET_ARCH_64_BIT 1
+#elif V8_TARGET_ARCH_MIPS
+#define V8_TARGET_ARCH_32_BIT 1
+#elif V8_TARGET_ARCH_MIPS64
+#define V8_TARGET_ARCH_64_BIT 1
+#elif V8_TARGET_ARCH_LOONG64
+#define V8_TARGET_ARCH_64_BIT 1
+#elif V8_TARGET_ARCH_PPC
+#define V8_TARGET_ARCH_32_BIT 1
+#elif V8_TARGET_ARCH_PPC64
+#define V8_TARGET_ARCH_64_BIT 1
+#elif V8_TARGET_ARCH_S390
+#if V8_TARGET_ARCH_S390X
+#define V8_TARGET_ARCH_64_BIT 1
+#else
+#define V8_TARGET_ARCH_32_BIT 1
+#endif
+#elif V8_TARGET_ARCH_RISCV64
+#define V8_TARGET_ARCH_64_BIT 1
+#else
+#error Unknown target architecture pointer size
+#endif
+
+// Check for supported combinations of host and target architectures.
+#if V8_TARGET_ARCH_IA32 && !V8_HOST_ARCH_IA32
+#error Target architecture ia32 is only supported on ia32 host
+#endif
+#if (V8_TARGET_ARCH_X64 && V8_TARGET_ARCH_64_BIT && \
+     !((V8_HOST_ARCH_X64 || V8_HOST_ARCH_ARM64) && V8_HOST_ARCH_64_BIT))
+#error Target architecture x64 is only supported on x64 and arm64 host
+#endif
+#if (V8_TARGET_ARCH_X64 && V8_TARGET_ARCH_32_BIT && \
+     !(V8_HOST_ARCH_X64 && V8_HOST_ARCH_32_BIT))
+#error Target architecture x32 is only supported on x64 host with x32 support
+#endif
+#if (V8_TARGET_ARCH_ARM && !(V8_HOST_ARCH_IA32 || V8_HOST_ARCH_ARM))
+#error Target architecture arm is only supported on arm and ia32 host
+#endif
+#if (V8_TARGET_ARCH_ARM64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_ARM64))
+#error Target architecture arm64 is only supported on arm64 and x64 host
+#endif
+#if (V8_TARGET_ARCH_MIPS && !(V8_HOST_ARCH_IA32 || V8_HOST_ARCH_MIPS))
+#error Target architecture mips is only supported on mips and ia32 host
+#endif
+#if (V8_TARGET_ARCH_MIPS64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_MIPS64))
+#error Target architecture mips64 is only supported on mips64 and x64 host
+#endif
+#if (V8_TARGET_ARCH_RISCV64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_RISCV64))
+#error Target architecture riscv64 is only supported on riscv64 and x64 host
+#endif
+#if (V8_TARGET_ARCH_LOONG64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_LOONG64))
+#error Target architecture loong64 is only supported on loong64 and x64 host
+#endif
+
+// Determine architecture endianness.
+#if V8_TARGET_ARCH_IA32
+#define V8_TARGET_LITTLE_ENDIAN 1
+#elif V8_TARGET_ARCH_X64
+#define V8_TARGET_LITTLE_ENDIAN 1
+#elif V8_TARGET_ARCH_ARM
+#define V8_TARGET_LITTLE_ENDIAN 1
+#elif V8_TARGET_ARCH_ARM64
+#define V8_TARGET_LITTLE_ENDIAN 1
+#elif V8_TARGET_ARCH_LOONG64
+#define V8_TARGET_LITTLE_ENDIAN 1
+#elif V8_TARGET_ARCH_MIPS
+#if defined(__MIPSEB__)
+#define V8_TARGET_BIG_ENDIAN 1
+#else
+#define V8_TARGET_LITTLE_ENDIAN 1
+#endif
+#elif V8_TARGET_ARCH_MIPS64
+#if defined(__MIPSEB__) || defined(V8_TARGET_ARCH_MIPS64_BE)
+#define V8_TARGET_BIG_ENDIAN 1
+#else
+#define V8_TARGET_LITTLE_ENDIAN 1
+#endif
+#elif __BIG_ENDIAN__  // FOR PPCGR on AIX
+#define V8_TARGET_BIG_ENDIAN 1
+#elif V8_TARGET_ARCH_PPC_LE
+#define V8_TARGET_LITTLE_ENDIAN 1
+#elif V8_TARGET_ARCH_PPC_BE
+#define V8_TARGET_BIG_ENDIAN 1
+#elif V8_TARGET_ARCH_S390
+#if V8_TARGET_ARCH_S390_LE_SIM
+#define V8_TARGET_LITTLE_ENDIAN 1
+#else
+#define V8_TARGET_BIG_ENDIAN 1
+#endif
+#elif V8_TARGET_ARCH_RISCV64
+#define V8_TARGET_LITTLE_ENDIAN 1
+#else
+#error Unknown target architecture endianness
+#endif
+
 #undef V8_HAS_CPP_ATTRIBUTE
 
 #endif  // V8CONFIG_H_
diff --git a/src/base/build_config.h b/src/base/build_config.h
index 3befde51e7f..46a18277224 100644
--- a/src/base/build_config.h
+++ b/src/base/build_config.h
@@ -7,59 +7,6 @@
 
 #include "include/v8config.h"
 
-// Processor architecture detection.  For more info on what's defined, see:
-//   http://msdn.microsoft.com/en-us/library/b0084kay.aspx
-//   http://www.agner.org/optimize/calling_conventions.pdf
-//   or with gcc, run: "echo | gcc -E -dM -"
-#if defined(_M_X64) || defined(__x86_64__)
-#define V8_HOST_ARCH_X64 1
-#if defined(__x86_64__) && __SIZEOF_POINTER__ == 4  // Check for x32.
-#define V8_HOST_ARCH_32_BIT 1
-#else
-#define V8_HOST_ARCH_64_BIT 1
-#endif
-#elif defined(_M_IX86) || defined(__i386__)
-#define V8_HOST_ARCH_IA32 1
-#define V8_HOST_ARCH_32_BIT 1
-#elif defined(__AARCH64EL__) || defined(_M_ARM64)
-#define V8_HOST_ARCH_ARM64 1
-#define V8_HOST_ARCH_64_BIT 1
-#elif defined(__ARMEL__)
-#define V8_HOST_ARCH_ARM 1
-#define V8_HOST_ARCH_32_BIT 1
-#elif defined(__mips64)
-#define V8_HOST_ARCH_MIPS64 1
-#define V8_HOST_ARCH_64_BIT 1
-#elif defined(__MIPSEB__) || defined(__MIPSEL__)
-#define V8_HOST_ARCH_MIPS 1
-#define V8_HOST_ARCH_32_BIT 1
-#elif defined(__loongarch64)
-#define V8_HOST_ARCH_LOONG64 1
-#define V8_HOST_ARCH_64_BIT 1
-#elif defined(__PPC64__) || defined(_ARCH_PPC64)
-#define V8_HOST_ARCH_PPC64 1
-#define V8_HOST_ARCH_64_BIT 1
-#elif defined(__PPC__) || defined(_ARCH_PPC)
-#define V8_HOST_ARCH_PPC 1
-#define V8_HOST_ARCH_32_BIT 1
-#elif defined(__s390__) || defined(__s390x__)
-#define V8_HOST_ARCH_S390 1
-#if defined(__s390x__)
-#define V8_HOST_ARCH_64_BIT 1
-#else
-#define V8_HOST_ARCH_32_BIT 1
-#endif
-#elif defined(__riscv) || defined(__riscv__)
-#if __riscv_xlen == 64
-#define V8_HOST_ARCH_RISCV64 1
-#define V8_HOST_ARCH_64_BIT 1
-#else
-#error "Cannot detect Riscv's bitwidth"
-#endif
-#else
-#error "Host architecture was not detected as supported by v8"
-#endif
-
 #if defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || \
     defined(__ARM_ARCH_7__)
 #define CAN_USE_ARMV7_INSTRUCTIONS 1
@@ -80,147 +27,6 @@
 #endif
 #endif
 
-// Target architecture detection. This may be set externally. If not, detect
-// in the same way as the host architecture, that is, target the native
-// environment as presented by the compiler.
-#if !V8_TARGET_ARCH_X64 && !V8_TARGET_ARCH_IA32 && !V8_TARGET_ARCH_ARM &&      \
-    !V8_TARGET_ARCH_ARM64 && !V8_TARGET_ARCH_MIPS && !V8_TARGET_ARCH_MIPS64 && \
-    !V8_TARGET_ARCH_PPC && !V8_TARGET_ARCH_PPC64 && !V8_TARGET_ARCH_S390 &&    \
-    !V8_TARGET_ARCH_RISCV64 && !V8_TARGET_ARCH_LOONG64
-#if defined(_M_X64) || defined(__x86_64__)
-#define V8_TARGET_ARCH_X64 1
-#elif defined(_M_IX86) || defined(__i386__)
-#define V8_TARGET_ARCH_IA32 1
-#elif defined(__AARCH64EL__) || defined(_M_ARM64)
-#define V8_TARGET_ARCH_ARM64 1
-#elif defined(__ARMEL__)
-#define V8_TARGET_ARCH_ARM 1
-#elif defined(__mips64)
-#define V8_TARGET_ARCH_MIPS64 1
-#elif defined(__MIPSEB__) || defined(__MIPSEL__)
-#define V8_TARGET_ARCH_MIPS 1
-#elif defined(_ARCH_PPC64)
-#define V8_TARGET_ARCH_PPC64 1
-#elif defined(_ARCH_PPC)
-#define V8_TARGET_ARCH_PPC 1
-#elif defined(__riscv) || defined(__riscv__)
-#if __riscv_xlen == 64
-#define V8_TARGET_ARCH_RISCV64 1
-#endif
-#else
-#error Target architecture was not detected as supported by v8
-#endif
-#endif
-
-// Determine architecture pointer size.
-#if V8_TARGET_ARCH_IA32
-#define V8_TARGET_ARCH_32_BIT 1
-#elif V8_TARGET_ARCH_X64
-#if !V8_TARGET_ARCH_32_BIT && !V8_TARGET_ARCH_64_BIT
-#if defined(__x86_64__) && __SIZEOF_POINTER__ == 4  // Check for x32.
-#define V8_TARGET_ARCH_32_BIT 1
-#else
-#define V8_TARGET_ARCH_64_BIT 1
-#endif
-#endif
-#elif V8_TARGET_ARCH_ARM
-#define V8_TARGET_ARCH_32_BIT 1
-#elif V8_TARGET_ARCH_ARM64
-#define V8_TARGET_ARCH_64_BIT 1
-#elif V8_TARGET_ARCH_MIPS
-#define V8_TARGET_ARCH_32_BIT 1
-#elif V8_TARGET_ARCH_MIPS64
-#define V8_TARGET_ARCH_64_BIT 1
-#elif V8_TARGET_ARCH_LOONG64
-#define V8_TARGET_ARCH_64_BIT 1
-#elif V8_TARGET_ARCH_PPC
-#define V8_TARGET_ARCH_32_BIT 1
-#elif V8_TARGET_ARCH_PPC64
-#define V8_TARGET_ARCH_64_BIT 1
-#elif V8_TARGET_ARCH_S390
-#if V8_TARGET_ARCH_S390X
-#define V8_TARGET_ARCH_64_BIT 1
-#else
-#define V8_TARGET_ARCH_32_BIT 1
-#endif
-#elif V8_TARGET_ARCH_RISCV64
-#define V8_TARGET_ARCH_64_BIT 1
-#else
-#error Unknown target architecture pointer size
-#endif
-
-// Check for supported combinations of host and target architectures.
-#if V8_TARGET_ARCH_IA32 && !V8_HOST_ARCH_IA32
-#error Target architecture ia32 is only supported on ia32 host
-#endif
-#if (V8_TARGET_ARCH_X64 && V8_TARGET_ARCH_64_BIT && \
-     !((V8_HOST_ARCH_X64 || V8_HOST_ARCH_ARM64) && V8_HOST_ARCH_64_BIT))
-#error Target architecture x64 is only supported on x64 and arm64 host
-#endif
-#if (V8_TARGET_ARCH_X64 && V8_TARGET_ARCH_32_BIT && \
-     !(V8_HOST_ARCH_X64 && V8_HOST_ARCH_32_BIT))
-#error Target architecture x32 is only supported on x64 host with x32 support
-#endif
-#if (V8_TARGET_ARCH_ARM && !(V8_HOST_ARCH_IA32 || V8_HOST_ARCH_ARM))
-#error Target architecture arm is only supported on arm and ia32 host
-#endif
-#if (V8_TARGET_ARCH_ARM64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_ARM64))
-#error Target architecture arm64 is only supported on arm64 and x64 host
-#endif
-#if (V8_TARGET_ARCH_MIPS && !(V8_HOST_ARCH_IA32 || V8_HOST_ARCH_MIPS))
-#error Target architecture mips is only supported on mips and ia32 host
-#endif
-#if (V8_TARGET_ARCH_MIPS64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_MIPS64))
-#error Target architecture mips64 is only supported on mips64 and x64 host
-#endif
-#if (V8_TARGET_ARCH_RISCV64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_RISCV64))
-#error Target architecture riscv64 is only supported on riscv64 and x64 host
-#endif
-#if (V8_TARGET_ARCH_LOONG64 && !(V8_HOST_ARCH_X64 || V8_HOST_ARCH_LOONG64))
-#error Target architecture loong64 is only supported on loong64 and x64 host
-#endif
-
-// Determine architecture endianness.
-#if V8_TARGET_ARCH_IA32
-#define V8_TARGET_LITTLE_ENDIAN 1
-#elif V8_TARGET_ARCH_X64
-#define V8_TARGET_LITTLE_ENDIAN 1
-#elif V8_TARGET_ARCH_ARM
-#define V8_TARGET_LITTLE_ENDIAN 1
-#elif V8_TARGET_ARCH_ARM64
-#define V8_TARGET_LITTLE_ENDIAN 1
-#elif V8_TARGET_ARCH_LOONG64
-#define V8_TARGET_LITTLE_ENDIAN 1
-#elif V8_TARGET_ARCH_MIPS
-#if defined(__MIPSEB__)
-#define V8_TARGET_BIG_ENDIAN 1
-#else
-#define V8_TARGET_LITTLE_ENDIAN 1
-#endif
-#elif V8_TARGET_ARCH_MIPS64
-#if defined(__MIPSEB__) || defined(V8_TARGET_ARCH_MIPS64_BE)
-#define V8_TARGET_BIG_ENDIAN 1
-#else
-#define V8_TARGET_LITTLE_ENDIAN 1
-#endif
-#elif __BIG_ENDIAN__  // FOR PPCGR on AIX
-#define V8_TARGET_BIG_ENDIAN 1
-#elif V8_TARGET_ARCH_PPC_LE
-#define V8_TARGET_LITTLE_ENDIAN 1
-#elif V8_TARGET_ARCH_PPC_BE
-#define V8_TARGET_BIG_ENDIAN 1
-#elif V8_TARGET_ARCH_S390
-#if V8_TARGET_ARCH_S390_LE_SIM
-#define V8_TARGET_LITTLE_ENDIAN 1
-#else
-#define V8_TARGET_BIG_ENDIAN 1
-#endif
-#elif V8_TARGET_ARCH_RISCV64
-#define V8_TARGET_LITTLE_ENDIAN 1
-#else
-#error Unknown target architecture endianness
-#endif
-
 // pthread_jit_write_protect is only available on arm64 Mac.
 #if defined(V8_OS_MACOS) && defined(V8_HOST_ARCH_ARM64)
 #define V8_HAS_PTHREAD_JIT_WRITE_PROTECT 1
diff --git a/src/heap/cppgc/globals.h b/src/heap/cppgc/globals.h
index d1308d901c8..44bec42223f 100644
--- a/src/heap/cppgc/globals.h
+++ b/src/heap/cppgc/globals.h
@@ -43,10 +43,7 @@ constexpr size_t kPageSize = 1 << kPageSizeLog2;
 constexpr size_t kPageOffsetMask = kPageSize - 1;
 constexpr size_t kPageBaseMask = ~kPageOffsetMask;
 
-#if defined(__aarch64__) && defined(V8_OS_MACOS)
-#if !defined(V8_TARGET_ARCH_ARM64)
-#error "V8_TARGET_ARCH_ARM64 and __aarch64__ must match"
-#endif  // !defined(V8_TARGET_ARCH_ARM64)
+#if defined(V8_TARGET_ARCH_ARM64) && defined(V8_OS_MACOS)
 // No guard pages on ARM64 macOS. This target has 16 kiB pages, meaning that
 // the guard pages do not protect anything, since there is no inaccessible
 // region surrounding the allocation.
-- 
2.35.1


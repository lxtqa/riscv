From 4207107d4ff98f25914f20aa6d9270ccb68c85fc Mon Sep 17 00:00:00 2001
From: Andreas Haas <ahaas@chromium.org>
Date: Mon, 5 Jun 2023 10:58:54 +0200
Subject: [PATCH] [builtins] Support definition of fp registers in
 interface-descriptors

So far fp registers could not be defined explicitly in interface-
descriptors. Instead, one would have to define the gp register with the
same reg code. With this CL FP registers can now be defined explicitly.

Bug: v8:14035
Change-Id: Ia13ae86309af50d39fa3bf1bff886142553fb668
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4582550
Commit-Queue: Andreas Haas <ahaas@chromium.org>
Reviewed-by: Nico Hartmann <nicohartmann@chromium.org>
Cr-Commit-Position: refs/heads/main@{#88102}
---
 .../arm/interface-descriptors-arm-inl.h       |  9 +++
 .../arm64/interface-descriptors-arm64-inl.h   |  5 ++
 .../ia32/interface-descriptors-ia32-inl.h     | 41 ++-----------
 src/codegen/interface-descriptors-inl.h       | 19 ++++--
 src/codegen/interface-descriptors.cc          | 18 ++++--
 src/codegen/interface-descriptors.h           | 58 ++++++++++---------
 .../interface-descriptors-loong64-inl.h       |  5 ++
 .../mips64/interface-descriptors-mips64-inl.h |  5 ++
 .../ppc/interface-descriptors-ppc-inl.h       |  5 ++
 .../riscv/interface-descriptors-riscv-inl.h   |  5 ++
 .../s390/interface-descriptors-s390-inl.h     |  5 ++
 .../x64/interface-descriptors-x64-inl.h       |  6 ++
 src/compiler/linkage.cc                       | 15 +++--
 13 files changed, 118 insertions(+), 78 deletions(-)

diff --git a/src/codegen/arm/interface-descriptors-arm-inl.h b/src/codegen/arm/interface-descriptors-arm-inl.h
index 100fe44228..d73fb090be 100644
--- a/src/codegen/arm/interface-descriptors-arm-inl.h
+++ b/src/codegen/arm/interface-descriptors-arm-inl.h
@@ -19,6 +19,15 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  // Construct the std::array explicitly here because on arm, the registers d0,
+  // d1, ... are not of type DoubleRegister but only support implicit casting to
+  // DoubleRegister. For template resolution, however, implicit casting is not
+  // sufficient.
+  std::array<DoubleRegister, 7> registers{d0, d1, d2, d3, d4, d5, d6};
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/arm64/interface-descriptors-arm64-inl.h b/src/codegen/arm64/interface-descriptors-arm64-inl.h
index 928714bbdd..4270adc2f9 100644
--- a/src/codegen/arm64/interface-descriptors-arm64-inl.h
+++ b/src/codegen/arm64/interface-descriptors-arm64-inl.h
@@ -20,6 +20,11 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  auto registers = DoubleRegisterArray(d0, d1, d2, d3, d4, d5, d6);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/ia32/interface-descriptors-ia32-inl.h b/src/codegen/ia32/interface-descriptors-ia32-inl.h
index 567bff9647..2888b47957 100644
--- a/src/codegen/ia32/interface-descriptors-ia32-inl.h
+++ b/src/codegen/ia32/interface-descriptors-ia32-inl.h
@@ -18,6 +18,12 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  // xmm0 isn't allocatable.
+  auto registers = DoubleRegisterArray(xmm1, xmm2, xmm3, xmm4, xmm5, xmm6);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
@@ -324,41 +330,6 @@ constexpr auto RunMicrotasksEntryDescriptor::registers() {
   return RegisterArray();
 }
 
-// static
-constexpr auto WasmFloat32ToNumberDescriptor::registers() {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  return RegisterArray(ecx);
-}
-
-// static
-constexpr auto WasmFloat64ToTaggedDescriptor::registers() {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  return RegisterArray(ecx);
-}
-
-// static
-constexpr auto NewHeapNumberDescriptor::registers() {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  return RegisterArray(ecx);
-}
-
-// static
-constexpr auto CheckTurboshaftFloat32TypeDescriptor::registers() {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  return RegisterArray(ecx);
-}
-
-// static
-constexpr auto CheckTurboshaftFloat64TypeDescriptor::registers() {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  return RegisterArray(ecx);
-}
-
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/codegen/interface-descriptors-inl.h b/src/codegen/interface-descriptors-inl.h
index 07acdd9542..0897adda73 100644
--- a/src/codegen/interface-descriptors-inl.h
+++ b/src/codegen/interface-descriptors-inl.h
@@ -50,6 +50,13 @@ constexpr auto StaticCallInterfaceDescriptor<DerivedDescriptor>::registers() {
   return CallInterfaceDescriptor::DefaultRegisterArray();
 }
 
+// static
+template <typename DerivedDescriptor>
+constexpr auto
+StaticCallInterfaceDescriptor<DerivedDescriptor>::double_registers() {
+  return CallInterfaceDescriptor::DefaultDoubleRegisterArray();
+}
+
 // static
 template <typename DerivedDescriptor>
 constexpr auto StaticJSCallInterfaceDescriptor<DerivedDescriptor>::registers() {
@@ -67,6 +74,7 @@ void StaticCallInterfaceDescriptor<DerivedDescriptor>::Initialize(
   // Static local copy of the Registers array, for platform-specific
   // initialization
   static auto registers = DerivedDescriptor::registers();
+  static auto double_registers = DerivedDescriptor::double_registers();
 
   // The passed pointer should be a modifiable pointer to our own data.
   DCHECK_EQ(data, this->data());
@@ -78,11 +86,12 @@ void StaticCallInterfaceDescriptor<DerivedDescriptor>::Initialize(
     DCHECK(!DerivedDescriptor::kCalleeSaveRegisters);
   }
 
-  data->InitializeRegisters(
-      DerivedDescriptor::flags(), DerivedDescriptor::kReturnCount,
-      DerivedDescriptor::GetParameterCount(),
-      DerivedDescriptor::kStackArgumentOrder,
-      DerivedDescriptor::GetRegisterParameterCount(), registers.data());
+  data->InitializeRegisters(DerivedDescriptor::flags(),
+                            DerivedDescriptor::kReturnCount,
+                            DerivedDescriptor::GetParameterCount(),
+                            DerivedDescriptor::kStackArgumentOrder,
+                            DerivedDescriptor::GetRegisterParameterCount(),
+                            registers.data(), double_registers.data());
 
   // InitializeTypes is customizable by the DerivedDescriptor subclass.
   DerivedDescriptor::InitializeTypes(data);
diff --git a/src/codegen/interface-descriptors.cc b/src/codegen/interface-descriptors.cc
index b746c51ab7..1cb8b52d87 100644
--- a/src/codegen/interface-descriptors.cc
+++ b/src/codegen/interface-descriptors.cc
@@ -13,22 +13,30 @@ namespace internal {
 void CallInterfaceDescriptorData::InitializeRegisters(
     Flags flags, int return_count, int parameter_count,
     StackArgumentOrder stack_order, int register_parameter_count,
-    const Register* registers) {
+    const Register* registers, const DoubleRegister* double_registers) {
   DCHECK(!IsInitializedTypes());
 
 #ifdef DEBUG
   {
     // Make sure that the registers are all valid, and don't alias each other.
     RegList reglist;
+    DoubleRegList double_reglist;
     for (int i = 0; i < register_parameter_count; ++i) {
       Register reg = registers[i];
-      DCHECK(reg.is_valid());
-      DCHECK(!reglist.has(reg));
+      DoubleRegister dreg = double_registers[i];
+      DCHECK(reg.is_valid() || dreg.is_valid());
       DCHECK_NE(reg, kRootRegister);
 #ifdef V8_COMPRESS_POINTERS
       DCHECK_NE(reg, kPtrComprCageBaseRegister);
 #endif
-      reglist.set(reg);
+      if (reg.is_valid()) {
+        DCHECK(!reglist.has(reg));
+        reglist.set(reg);
+      }
+      if (dreg.is_valid()) {
+        DCHECK(!double_reglist.has(dreg));
+        double_reglist.set(dreg);
+      }
     }
   }
 #endif
@@ -41,6 +49,7 @@ void CallInterfaceDescriptorData::InitializeRegisters(
 
   // The caller owns the the registers array, so we just set the pointer.
   register_params_ = registers;
+  double_register_params_ = double_registers;
 }
 
 void CallInterfaceDescriptorData::InitializeTypes(
@@ -77,6 +86,7 @@ void CallInterfaceDescriptorData::Reset() {
   delete[] machine_types_;
   machine_types_ = nullptr;
   register_params_ = nullptr;
+  double_register_params_ = nullptr;
 }
 
 // static
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index 3b7dcb2abf..68af7f121d 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -185,7 +185,8 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   void InitializeRegisters(Flags flags, int return_count, int parameter_count,
                            StackArgumentOrder stack_order,
                            int register_parameter_count,
-                           const Register* registers);
+                           const Register* registers,
+                           const DoubleRegister* double_registers);
 
   // if machine_types is null, then an array of size
   // (return_count + parameter_count) will be created with
@@ -209,6 +210,9 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   int param_count() const { return param_count_; }
   int register_param_count() const { return register_param_count_; }
   Register register_param(int index) const { return register_params_[index]; }
+  DoubleRegister double_register_param(int index) const {
+    return double_register_params_[index];
+  }
   MachineType return_type(int index) const {
     DCHECK_LT(index, return_count_);
     return machine_types_[index];
@@ -265,6 +269,7 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   // is a static local stored in the caller function. The machine types are
   // allocated dynamically by the InterfaceDescriptor and freed on destruction.
   const Register* register_params_ = nullptr;
+  const DoubleRegister* double_register_params_ = nullptr;
   MachineType* machine_types_ = nullptr;
 };
 
@@ -366,6 +371,11 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
     return data()->register_param(index);
   }
 
+  DoubleRegister GetDoubleRegisterParameter(int index) const {
+    DCHECK_LT(index, data()->register_param_count());
+    return data()->double_register_param(index);
+  }
+
   MachineType GetParameterType(int index) const {
     DCHECK_LT(index, data()->param_count());
     return data()->param_type(index);
@@ -397,6 +407,7 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
   // Use auto for the return type to allow different architectures to have
   // differently sized default register arrays.
   static constexpr inline auto DefaultRegisterArray();
+  static constexpr inline auto DefaultDoubleRegisterArray();
   static constexpr inline std::array<Register, kJSBuiltinRegisterParams>
   DefaultJSRegisterArray();
 
@@ -443,6 +454,7 @@ class StaticCallInterfaceDescriptor : public CallInterfaceDescriptor {
   //
   // Defaults to CallInterfaceDescriptor::DefaultRegisterArray().
   static constexpr inline auto registers();
+  static constexpr inline auto double_registers();
 
   // An additional limit on the number of register parameters allowed. This is
   // here so that it can be overwritten to kMaxTFSBuiltinRegisterParams for TFS
@@ -557,6 +569,25 @@ constexpr std::array<Register, 1 + sizeof...(Registers)> RegisterArray(
 }
 constexpr EmptyRegisterArray RegisterArray() { return {}; }
 
+// Stub class replacing std::array<Register, 0>, as a workaround for MSVC's
+// https://github.com/microsoft/STL/issues/942
+struct EmptyDoubleRegisterArray {
+  DoubleRegister* data() { return nullptr; }
+  size_t size() const { return 0; }
+  DoubleRegister operator[](size_t i) const { UNREACHABLE(); }
+};
+
+// Helper method for defining an array of unique registers for the various
+// Descriptor::double_registers() methods.
+template <typename... Registers>
+constexpr std::array<DoubleRegister, 1 + sizeof...(Registers)>
+DoubleRegisterArray(DoubleRegister first_reg, Registers... regs) {
+  DCHECK(!AreAliased(first_reg, regs...));
+  return {first_reg, regs...};
+}
+
+constexpr EmptyDoubleRegisterArray DoubleRegisterArray() { return {}; }
+
 #define DECLARE_DESCRIPTOR_WITH_BASE(name, base)                  \
  public:                                                          \
   /* StaticCallInterfaceDescriptor can call Initialize methods */ \
@@ -743,11 +774,6 @@ class NewHeapNumberDescriptor
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::TaggedPointer(),  // Result
                                     MachineType::Float64())        // kValue
   DECLARE_DESCRIPTOR(NewHeapNumberDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  // We need a custom descriptor on ia32 to avoid using xmm0.
-  static constexpr inline auto registers();
-#endif
 };
 
 // This descriptor defines the JavaScript calling convention that can be used
@@ -2030,11 +2056,6 @@ class WasmFloat32ToNumberDescriptor final
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged(),  // result
                                     MachineType::Float32())    // value
   DECLARE_DESCRIPTOR(WasmFloat32ToNumberDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  // We need a custom descriptor on ia32 to avoid using xmm0.
-  static constexpr inline auto registers();
-#endif
 };
 
 class WasmFloat64ToTaggedDescriptor final
@@ -2044,11 +2065,6 @@ class WasmFloat64ToTaggedDescriptor final
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged(),  // result
                                     MachineType::Float64())    // value
   DECLARE_DESCRIPTOR(WasmFloat64ToTaggedDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  // We need a custom descriptor on ia32 to avoid using xmm0.
-  static constexpr inline auto registers();
-#endif
 };
 
 class WasmSuspendDescriptor final
@@ -2246,11 +2262,6 @@ class CheckTurboshaftFloat32TypeDescriptor
                                     MachineType::TaggedPointer(),
                                     MachineType::TaggedSigned())
   DECLARE_DEFAULT_DESCRIPTOR(CheckTurboshaftFloat32TypeDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  // We need a custom descriptor on ia32 to avoid using xmm0.
-  static constexpr inline auto registers();
-#endif
 };
 
 class CheckTurboshaftFloat64TypeDescriptor
@@ -2263,11 +2274,6 @@ class CheckTurboshaftFloat64TypeDescriptor
                                     MachineType::TaggedPointer(),
                                     MachineType::TaggedSigned())
   DECLARE_DEFAULT_DESCRIPTOR(CheckTurboshaftFloat64TypeDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  // We need a custom descriptor on ia32 to avoid using xmm0.
-  static constexpr inline auto registers();
-#endif
 };
 
 class DebugPrintWordPtrDescriptor
diff --git a/src/codegen/loong64/interface-descriptors-loong64-inl.h b/src/codegen/loong64/interface-descriptors-loong64-inl.h
index 90e4479268..9dcfbb89d3 100644
--- a/src/codegen/loong64/interface-descriptors-loong64-inl.h
+++ b/src/codegen/loong64/interface-descriptors-loong64-inl.h
@@ -19,6 +19,11 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  auto registers = DoubleRegisterArray(f0, f1, f2, f3, f4, f5, f6);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/mips64/interface-descriptors-mips64-inl.h b/src/codegen/mips64/interface-descriptors-mips64-inl.h
index 94f441a2cf..c413557679 100644
--- a/src/codegen/mips64/interface-descriptors-mips64-inl.h
+++ b/src/codegen/mips64/interface-descriptors-mips64-inl.h
@@ -19,6 +19,11 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  auto registers = DoubleRegisterArray(f0, f2, f4, f6, f8, f10, f12);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/ppc/interface-descriptors-ppc-inl.h b/src/codegen/ppc/interface-descriptors-ppc-inl.h
index e0d6ac93c7..021932a9e0 100644
--- a/src/codegen/ppc/interface-descriptors-ppc-inl.h
+++ b/src/codegen/ppc/interface-descriptors-ppc-inl.h
@@ -19,6 +19,11 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  auto registers = DoubleRegisterArray(d1, d2, d3, d4, d5, d6, d7);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/riscv/interface-descriptors-riscv-inl.h b/src/codegen/riscv/interface-descriptors-riscv-inl.h
index df9100372c..82281eabae 100644
--- a/src/codegen/riscv/interface-descriptors-riscv-inl.h
+++ b/src/codegen/riscv/interface-descriptors-riscv-inl.h
@@ -18,6 +18,11 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  auto registers = DoubleRegisterArray(ft1, ft2, ft3, ft4, ft5, ft6, ft7);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/s390/interface-descriptors-s390-inl.h b/src/codegen/s390/interface-descriptors-s390-inl.h
index ea8c19ba28..affa5aa05e 100644
--- a/src/codegen/s390/interface-descriptors-s390-inl.h
+++ b/src/codegen/s390/interface-descriptors-s390-inl.h
@@ -19,6 +19,11 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  auto registers = DoubleRegisterArray(d1, d2, d3, d4, d5, d6, d7);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/codegen/x64/interface-descriptors-x64-inl.h b/src/codegen/x64/interface-descriptors-x64-inl.h
index 38901c571b..c7f4356115 100644
--- a/src/codegen/x64/interface-descriptors-x64-inl.h
+++ b/src/codegen/x64/interface-descriptors-x64-inl.h
@@ -18,6 +18,12 @@ constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
   return registers;
 }
 
+constexpr auto CallInterfaceDescriptor::DefaultDoubleRegisterArray() {
+  auto registers =
+      DoubleRegisterArray(xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6);
+  return registers;
+}
+
 #if DEBUG
 template <typename DerivedDescriptor>
 void StaticCallInterfaceDescriptor<DerivedDescriptor>::
diff --git a/src/compiler/linkage.cc b/src/compiler/linkage.cc
index e401cf7113..4edb94b1f8 100644
--- a/src/compiler/linkage.cc
+++ b/src/compiler/linkage.cc
@@ -481,15 +481,14 @@ CallDescriptor* Linkage::GetStubCallDescriptor(
   for (int i = 0; i < js_parameter_count; i++) {
     if (i < register_parameter_count) {
       // The first parameters go in registers.
-      // TODO(bbudge) Add floating point registers to the InterfaceDescriptor
-      // and use them for FP types. Currently, this works because on most
-      // platforms, all FP registers are available for use. On ia32, xmm0 is
-      // not allocatable and so we must work around that with platform-specific
-      // descriptors, adjusting the GP register set to avoid eax, which has
-      // register code 0.
-      Register reg = descriptor.GetRegisterParameter(i);
       MachineType type = descriptor.GetParameterType(i);
-      locations.AddParam(regloc(reg, type));
+      if (IsFloatingPoint(type.representation())) {
+        DoubleRegister reg = descriptor.GetDoubleRegisterParameter(i);
+        locations.AddParam(regloc(reg, type));
+      } else {
+        Register reg = descriptor.GetRegisterParameter(i);
+        locations.AddParam(regloc(reg, type));
+      }
     } else {
       // The rest of the parameters go on the stack.
       int stack_slot = i - register_parameter_count - stack_parameter_count;
-- 
2.35.1


From 5dea60d60bc2d2588f2dee258e4fd68aab384474 Mon Sep 17 00:00:00 2001
From: Leszek Swirski <leszeks@chromium.org>
Date: Fri, 16 Apr 2021 13:47:49 +0000
Subject: [PATCH] Revert "[codegen] Add static interface descriptors"

This reverts commit ae0752df1b84d8c53cc7b2af71013a9e678a9c6e.

Reason for revert: Predictably, constexpr issues on non-clang compilers.

Original change's description:
> [codegen] Add static interface descriptors
>
> Add a new CRTP StaticCallInterfaceDescriptor class, which provides
> static constexpr getters for a descriptor's registers, parameter counts,
> and so on. Each CallInterfaceDescriptor subclass is changed to extend
> StaticCallInterfaceDescriptor, with StaticCallInterfaceDescriptor itself
> extending CallInterfaceDescriptor to still provide a dynamic lookup
> where needed.
>
> StaticCallInterfaceDescriptor provides a couple of customisation points,
> where it reads its CRTP derived descriptor's static fields and
> functions, with default fallbacks where appropriate. With these
> customisation points, the definition of CallInterfaceDescriptor
> subclasses is simplified to:
>
>     a) Providing parameter names (as before)
>     b) Providing parameter types (as before)
>     c) Optionally setting flags (like kNoContext or kAllowVarArgs) as
>        static booleans on the class.
>     d) Optionally providing a `registers()` method that returns a
>        std::array<Register, N> of registers that may be used for
>        parameters (if not provided, this defaults to the implementation
>        specific default register set).
>
> Parameter registers (and register count) are automagically set based on
> the number of parameters and number of given registers, with extra magic
> to ignore no_reg registers (to reduce ia32 special casing). The
> CallInterfaceDescriptorData is initialized based on these static
> functions, rather than manual per-descriptor initializers.
>
> This allows us to skip loading descriptors dynamically for CallBuiltin
> in Sparkplug, and instead lets us use a bit of template magic to
> statically set up arguments for the calls. Any other users of statically
> known descriptors will also benefit, thanks to C++ picking the static
> methods over the dynamic methods on the base class when available.
>
> Because we can remove various virtual functions and trigger heavier
> inlining of constantly known values, binary size slightly decreases with
> this change.
>
> Note that torque-generated descriptors are changed to use the same magic,
> rather than having Torque-specific magic, for consistency.
>
> Bug: v8:11420
> Change-Id: Icc5e238b6313a08734feb564204a13226b450c22
> Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2814518
> Auto-Submit: Leszek Swirski <leszeks@chromium.org>
> Reviewed-by: Nico Hartmann <nicohartmann@chromium.org>
> Reviewed-by: Clemens Backes <clemensb@chromium.org>
> Reviewed-by: Igor Sheludko <ishell@chromium.org>
> Reviewed-by: Jakob Gruber <jgruber@chromium.org>
> Commit-Queue: Clemens Backes <clemensb@chromium.org>
> Cr-Commit-Position: refs/heads/master@{#73996}

Bug: v8:11420
Change-Id: Ie5469c9253fc140590ac30b72db6eb1d93f86806
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2831485
Auto-Submit: Leszek Swirski <leszeks@chromium.org>
Commit-Queue: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Bot-Commit: Rubber Stamper <rubber-stamper@appspot.gserviceaccount.com>
Cr-Commit-Position: refs/heads/master@{#74000}
---
 BUILD.gn                                      |    9 +-
 src/baseline/arm/baseline-compiler-arm-inl.h  |    6 +-
 .../arm64/baseline-compiler-arm64-inl.h       |    6 +-
 src/baseline/baseline-assembler-inl.h         |    1 -
 src/baseline/baseline-compiler.cc             |  782 +++++-----
 src/baseline/baseline-compiler.h              |   22 +-
 .../ia32/baseline-compiler-ia32-inl.h         |    6 +-
 src/baseline/x64/baseline-assembler-x64-inl.h |    1 +
 src/baseline/x64/baseline-compiler-x64-inl.h  |    6 +-
 src/builtins/arm/builtins-arm.cc              |    1 -
 src/builtins/arm64/builtins-arm64.cc          |    1 -
 src/builtins/builtins-array-gen.cc            |    1 -
 src/builtins/builtins-internal-gen.cc         |    1 -
 src/builtins/ia32/builtins-ia32.cc            |    3 +-
 src/builtins/x64/builtins-x64.cc              |    5 +-
 .../arm/interface-descriptors-arm-inl.h       |  261 ----
 src/codegen/arm/interface-descriptors-arm.cc  |  306 ++++
 src/codegen/arm/macro-assembler-arm.cc        |    1 -
 .../arm64/interface-descriptors-arm64-inl.h   |  270 ----
 .../arm64/interface-descriptors-arm64.cc      |  310 ++++
 src/codegen/arm64/macro-assembler-arm64.cc    |    1 -
 .../ia32/interface-descriptors-ia32-inl.h     |  272 ----
 .../ia32/interface-descriptors-ia32.cc        |  318 ++++
 src/codegen/ia32/macro-assembler-ia32.cc      |    2 +-
 src/codegen/interface-descriptors-inl.h       |  471 ------
 src/codegen/interface-descriptors.cc          |  557 ++++++-
 src/codegen/interface-descriptors.h           | 1325 ++++++++---------
 src/codegen/register-arch.h                   |   21 -
 src/codegen/turbo-assembler.h                 |   21 +
 .../x64/interface-descriptors-x64-inl.h       |  263 ----
 src/codegen/x64/interface-descriptors-x64.cc  |  309 ++++
 src/codegen/x64/macro-assembler-x64.cc        |    1 -
 src/compiler/backend/instruction-selector.cc  |    1 -
 src/compiler/code-assembler.cc                |    2 +-
 src/compiler/effect-control-linearizer.cc     |    1 -
 src/compiler/js-generic-lowering.cc           |    1 -
 src/compiler/js-typed-lowering.cc             |    1 -
 src/compiler/memory-lowering.cc               |    2 +-
 src/compiler/wasm-compiler.cc                 |    2 +-
 src/ic/accessor-assembler.cc                  |    2 +-
 src/interpreter/interpreter-assembler.cc      |    2 +-
 src/snapshot/embedded/embedded-data.cc        |   10 +-
 src/torque/implementation-visitor.cc          |   62 +-
 src/wasm/baseline/liftoff-compiler.cc         |    2 +-
 test/cctest/test-code-stub-assembler.cc       |    3 +-
 .../codegen/code-stub-assembler-unittest.cc   |    2 +-
 .../compiler/int64-lowering-unittest.cc       |   38 +-
 47 files changed, 2898 insertions(+), 2793 deletions(-)
 delete mode 100644 src/codegen/arm/interface-descriptors-arm-inl.h
 create mode 100644 src/codegen/arm/interface-descriptors-arm.cc
 delete mode 100644 src/codegen/arm64/interface-descriptors-arm64-inl.h
 create mode 100644 src/codegen/arm64/interface-descriptors-arm64.cc
 delete mode 100644 src/codegen/ia32/interface-descriptors-ia32-inl.h
 create mode 100644 src/codegen/ia32/interface-descriptors-ia32.cc
 delete mode 100644 src/codegen/interface-descriptors-inl.h
 delete mode 100644 src/codegen/x64/interface-descriptors-x64-inl.h
 create mode 100644 src/codegen/x64/interface-descriptors-x64.cc

diff --git a/BUILD.gn b/BUILD.gn
index 263e5668bb..6fc9f920e0 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -2337,7 +2337,6 @@ v8_header_set("v8_internal_headers") {
     "src/codegen/external-reference.h",
     "src/codegen/flush-instruction-cache.h",
     "src/codegen/handler-table.h",
-    "src/codegen/interface-descriptors-inl.h",
     "src/codegen/interface-descriptors.h",
     "src/codegen/label.h",
     "src/codegen/machine-type.h",
@@ -4058,7 +4057,7 @@ v8_source_set("v8_base_without_compiler") {
     sources += [  ### gcmole(arch:ia32) ###
       "src/codegen/ia32/assembler-ia32.cc",
       "src/codegen/ia32/cpu-ia32.cc",
-      "src/codegen/ia32/interface-descriptors-ia32-inl.h",
+      "src/codegen/ia32/interface-descriptors-ia32.cc",
       "src/codegen/ia32/macro-assembler-ia32.cc",
       "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.cc",
       "src/compiler/backend/ia32/code-generator-ia32.cc",
@@ -4076,7 +4075,7 @@ v8_source_set("v8_base_without_compiler") {
       "src/codegen/shared-ia32-x64/macro-assembler-shared-ia32-x64.cc",
       "src/codegen/x64/assembler-x64.cc",
       "src/codegen/x64/cpu-x64.cc",
-      "src/codegen/x64/interface-descriptors-x64-inl.h",
+      "src/codegen/x64/interface-descriptors-x64.cc",
       "src/codegen/x64/macro-assembler-x64.cc",
       "src/compiler/backend/x64/code-generator-x64.cc",
       "src/compiler/backend/x64/instruction-scheduler-x64.cc",
@@ -4111,7 +4110,7 @@ v8_source_set("v8_base_without_compiler") {
       "src/codegen/arm/assembler-arm.cc",
       "src/codegen/arm/constants-arm.cc",
       "src/codegen/arm/cpu-arm.cc",
-      "src/codegen/arm/interface-descriptors-arm-inl.h",
+      "src/codegen/arm/interface-descriptors-arm.cc",
       "src/codegen/arm/macro-assembler-arm.cc",
       "src/compiler/backend/arm/code-generator-arm.cc",
       "src/compiler/backend/arm/instruction-scheduler-arm.cc",
@@ -4133,7 +4132,7 @@ v8_source_set("v8_base_without_compiler") {
       "src/codegen/arm64/decoder-arm64.cc",
       "src/codegen/arm64/instructions-arm64-constants.cc",
       "src/codegen/arm64/instructions-arm64.cc",
-      "src/codegen/arm64/interface-descriptors-arm64-inl.h",
+      "src/codegen/arm64/interface-descriptors-arm64.cc",
       "src/codegen/arm64/macro-assembler-arm64.cc",
       "src/codegen/arm64/register-arm64.cc",
       "src/codegen/arm64/utils-arm64.cc",
diff --git a/src/baseline/arm/baseline-compiler-arm-inl.h b/src/baseline/arm/baseline-compiler-arm-inl.h
index d7f0a606d3..ff2b6d1a83 100644
--- a/src/baseline/arm/baseline-compiler-arm-inl.h
+++ b/src/baseline/arm/baseline-compiler-arm-inl.h
@@ -19,9 +19,9 @@ void BaselineCompiler::Prologue() {
   __ masm()->EnterFrame(StackFrame::BASELINE);
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
-      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
+              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   PrologueFillFrame();
 }
diff --git a/src/baseline/arm64/baseline-compiler-arm64-inl.h b/src/baseline/arm64/baseline-compiler-arm64-inl.h
index 0807c5434a..e567be41d2 100644
--- a/src/baseline/arm64/baseline-compiler-arm64-inl.h
+++ b/src/baseline/arm64/baseline-compiler-arm64-inl.h
@@ -18,9 +18,9 @@ void BaselineCompiler::Prologue() {
   __ masm()->EnterFrame(StackFrame::BASELINE);
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
-      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
+              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   __ masm()->AssertSpAligned();
   PrologueFillFrame();
diff --git a/src/baseline/baseline-assembler-inl.h b/src/baseline/baseline-assembler-inl.h
index 6a3f86632b..cbce3ba7b8 100644
--- a/src/baseline/baseline-assembler-inl.h
+++ b/src/baseline/baseline-assembler-inl.h
@@ -14,7 +14,6 @@
 #include <unordered_map>
 
 #include "src/baseline/baseline-assembler.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/interpreter/bytecode-register.h"
 #include "src/objects/feedback-cell.h"
 #include "src/objects/js-function.h"
diff --git a/src/baseline/baseline-compiler.cc b/src/baseline/baseline-compiler.cc
index ac6880ecb5..e5ab1f1491 100644
--- a/src/baseline/baseline-compiler.cc
+++ b/src/baseline/baseline-compiler.cc
@@ -19,7 +19,7 @@
 #include "src/builtins/builtins.h"
 #include "src/codegen/assembler.h"
 #include "src/codegen/compiler.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/common/globals.h"
@@ -70,7 +70,6 @@ bool Clobbers(Register target, TaggedIndex index) { return false; }
 bool Clobbers(Register target, int32_t imm) { return false; }
 bool Clobbers(Register target, RootIndex index) { return false; }
 bool Clobbers(Register target, interpreter::Register reg) { return false; }
-bool Clobbers(Register target, interpreter::RegisterList list) { return false; }
 
 // We don't know what's inside machine registers or operands, so assume they
 // match.
@@ -100,132 +99,130 @@ bool MachineTypeMatches(MachineType type, interpreter::Register reg) {
   return type.IsTagged();
 }
 
-template <typename Descriptor, typename... Args>
+template <typename... Args>
 struct CheckArgsHelper;
 
-template <typename Descriptor>
-struct CheckArgsHelper<Descriptor> {
-  static void Check(BaselineAssembler* masm, int i) {
-    if (Descriptor::AllowVarArgs()) {
-      CHECK_GE(i, Descriptor::GetParameterCount());
+template <>
+struct CheckArgsHelper<> {
+  static void Check(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
+                    int i) {
+    if (descriptor.AllowVarArgs()) {
+      CHECK_GE(i, descriptor.GetParameterCount());
     } else {
-      CHECK_EQ(i, Descriptor::GetParameterCount());
+      CHECK_EQ(i, descriptor.GetParameterCount());
     }
   }
 };
 
-template <typename Descriptor, typename Arg, typename... Args>
-struct CheckArgsHelper<Descriptor, Arg, Args...> {
-  static void Check(BaselineAssembler* masm, int i, Arg arg, Args... args) {
-    if (i >= Descriptor::GetParameterCount()) {
-      CHECK(Descriptor::AllowVarArgs());
+template <typename Arg, typename... Args>
+struct CheckArgsHelper<Arg, Args...> {
+  static void Check(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
+                    int i, Arg arg, Args... args) {
+    if (i >= descriptor.GetParameterCount()) {
+      CHECK(descriptor.AllowVarArgs());
       return;
     }
-    CHECK(MachineTypeMatches(Descriptor().GetParameterType(i), arg));
-    CheckArgsHelper<Descriptor, Args...>::Check(masm, i + 1, args...);
+    CHECK(MachineTypeMatches(descriptor.GetParameterType(i), arg));
+    CheckArgsHelper<Args...>::Check(masm, descriptor, i + 1, args...);
   }
 };
 
-template <typename Descriptor, typename... Args>
-struct CheckArgsHelper<Descriptor, interpreter::RegisterList, Args...> {
-  static void Check(BaselineAssembler* masm, int i,
-                    interpreter::RegisterList list, Args... args) {
+template <typename... Args>
+struct CheckArgsHelper<interpreter::RegisterList, Args...> {
+  static void Check(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
+                    int i, interpreter::RegisterList list, Args... args) {
     for (int reg_index = 0; reg_index < list.register_count();
          ++reg_index, ++i) {
-      if (i >= Descriptor::GetParameterCount()) {
-        CHECK(Descriptor::AllowVarArgs());
+      if (i >= descriptor.GetParameterCount()) {
+        CHECK(descriptor.AllowVarArgs());
         return;
       }
-      CHECK(MachineTypeMatches(Descriptor().GetParameterType(i),
-                               list[reg_index]));
+      CHECK(
+          MachineTypeMatches(descriptor.GetParameterType(i), list[reg_index]));
     }
-    CheckArgsHelper<Descriptor, Args...>::Check(masm, i, args...);
+    CheckArgsHelper<Args...>::Check(masm, descriptor, i, args...);
   }
 };
 
-template <typename Descriptor, typename... Args>
-void CheckArgs(BaselineAssembler* masm, Args... args) {
-  CheckArgsHelper<Descriptor, Args...>::Check(masm, 0, args...);
-}
-
-void CheckSettingDoesntClobber(Register target) {}
-template <typename Arg, typename... Args>
-void CheckSettingDoesntClobber(Register target, Arg arg, Args... args) {
-  DCHECK(!Clobbers(target, arg));
-  CheckSettingDoesntClobber(target, args...);
+template <typename... Args>
+void CheckArgs(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
+               Args... args) {
+  CheckArgsHelper<Args...>::Check(masm, descriptor, 0, args...);
 }
 
 #else  // DEBUG
 
-template <typename Descriptor, typename... Args>
-void CheckArgs(Args... args) {}
-
 template <typename... Args>
-void CheckSettingDoesntClobber(Register target, Args... args) {}
+void CheckArgs(Args... args) {}
 
 #endif  // DEBUG
 
-template <typename Descriptor, int ArgIndex, bool kIsRegister, typename... Args>
+template <typename... Args>
 struct ArgumentSettingHelper;
 
-template <typename Descriptor, int ArgIndex, bool kIsRegister>
-struct ArgumentSettingHelper<Descriptor, ArgIndex, kIsRegister> {
-  static void Set(BaselineAssembler* masm) {
-    // Should only ever be called for the end of register arguments.
-    STATIC_ASSERT(ArgIndex == Descriptor::GetRegisterParameterCount());
-  }
-};
-
-template <typename Descriptor, int ArgIndex, typename Arg, typename... Args>
-struct ArgumentSettingHelper<Descriptor, ArgIndex, true, Arg, Args...> {
-  static void Set(BaselineAssembler* masm, Arg arg, Args... args) {
-    STATIC_ASSERT(ArgIndex < Descriptor::GetRegisterParameterCount());
-    Register target = Descriptor::GetRegisterParameter(ArgIndex);
-    CheckSettingDoesntClobber(target, args...);
-    masm->Move(target, arg);
-    ArgumentSettingHelper<Descriptor, ArgIndex + 1,
-                          (ArgIndex + 1 <
-                           Descriptor::GetRegisterParameterCount()),
-                          Args...>::Set(masm, args...);
-  }
+template <>
+struct ArgumentSettingHelper<> {
+  static void Set(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
+                  int i) {}
+  static void CheckSettingDoesntClobber(Register target, int arg_index) {}
 };
 
-template <typename Descriptor, int ArgIndex>
-struct ArgumentSettingHelper<Descriptor, ArgIndex, true,
-                             interpreter::RegisterList> {
-  static void Set(BaselineAssembler* masm, interpreter::RegisterList list) {
-    STATIC_ASSERT(ArgIndex < Descriptor::GetRegisterParameterCount());
-    DCHECK_EQ(ArgIndex + list.register_count(),
-              Descriptor::GetRegisterParameterCount());
-    for (int i = 0; ArgIndex + i < Descriptor::GetRegisterParameterCount();
-         ++i) {
-      Register target = Descriptor::GetRegisterParameter(ArgIndex + i);
-      masm->Move(target, masm->RegisterFrameOperand(list[i]));
+template <typename Arg, typename... Args>
+struct ArgumentSettingHelper<Arg, Args...> {
+  static void Set(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
+                  int i, Arg arg, Args... args) {
+    if (i < descriptor.GetRegisterParameterCount()) {
+      Register target = descriptor.GetRegisterParameter(i);
+      ArgumentSettingHelper<Args...>::CheckSettingDoesntClobber(target, i + 1,
+                                                                args...);
+      masm->Move(target, arg);
+      ArgumentSettingHelper<Args...>::Set(masm, descriptor, i + 1, args...);
+    } else if (descriptor.GetStackArgumentOrder() ==
+               StackArgumentOrder::kDefault) {
+      masm->Push(arg, args...);
+    } else {
+      masm->PushReverse(arg, args...);
     }
   }
+  static void CheckSettingDoesntClobber(Register target, int arg_index, Arg arg,
+                                        Args... args) {
+    DCHECK(!Clobbers(target, arg));
+    ArgumentSettingHelper<Args...>::CheckSettingDoesntClobber(
+        target, arg_index + 1, args...);
+  }
 };
 
-template <typename Descriptor, int ArgIndex, typename Arg, typename... Args>
-struct ArgumentSettingHelper<Descriptor, ArgIndex, false, Arg, Args...> {
-  static void Set(BaselineAssembler* masm, Arg arg, Args... args) {
-    if (Descriptor::kStackArgumentOrder == StackArgumentOrder::kDefault) {
-      masm->Push(arg, args...);
+// Specialization for interpreter::RegisterList which iterates it.
+// RegisterLists are only allowed to be the last argument.
+template <>
+struct ArgumentSettingHelper<interpreter::RegisterList> {
+  static void Set(BaselineAssembler* masm, CallInterfaceDescriptor descriptor,
+                  int i, interpreter::RegisterList list) {
+    // Either all the values are in machine registers, or they're all on the
+    // stack.
+    if (i < descriptor.GetRegisterParameterCount()) {
+      for (int reg_index = 0; reg_index < list.register_count();
+           ++reg_index, ++i) {
+        Register target = descriptor.GetRegisterParameter(i);
+        masm->Move(target, masm->RegisterFrameOperand(list[reg_index]));
+      }
+    } else if (descriptor.GetStackArgumentOrder() ==
+               StackArgumentOrder::kDefault) {
+      masm->Push(list);
     } else {
-      masm->PushReverse(arg, args...);
+      masm->PushReverse(list);
     }
   }
+  static void CheckSettingDoesntClobber(Register target, int arg_index,
+                                        interpreter::RegisterList arg) {}
 };
 
-template <Builtins::Name kBuiltin, typename... Args>
-void MoveArgumentsForBuiltin(BaselineAssembler* masm, Args... args) {
-  using Descriptor = typename CallInterfaceDescriptorFor<kBuiltin>::type;
-  CheckArgs<Descriptor>(masm, args...);
-  ArgumentSettingHelper<Descriptor, 0,
-                        (0 < Descriptor::GetRegisterParameterCount()),
-                        Args...>::Set(masm, args...);
-  if (Descriptor::HasContextParameter()) {
-    masm->LoadContext(Descriptor::ContextRegister());
-  }
+template <typename... Args>
+void MoveArgumentsForDescriptor(BaselineAssembler* masm,
+                                CallInterfaceDescriptor descriptor,
+                                Args... args) {
+  CheckArgs(masm, descriptor, args...);
+  ArgumentSettingHelper<Args...>::Set(masm, descriptor, 0, args...);
 }
 
 }  // namespace detail
@@ -555,18 +552,28 @@ Label* BaselineCompiler::BuildForwardJumpLabel() {
   return &threaded_label->label;
 }
 
-template <Builtins::Name kBuiltin, typename... Args>
-void BaselineCompiler::CallBuiltin(Args... args) {
+template <typename... Args>
+void BaselineCompiler::CallBuiltin(Builtins::Name builtin, Args... args) {
   __ RecordComment("[ CallBuiltin");
-  detail::MoveArgumentsForBuiltin<kBuiltin>(&basm_, args...);
-  __ CallBuiltin(kBuiltin);
+  CallInterfaceDescriptor descriptor =
+      Builtins::CallInterfaceDescriptorFor(builtin);
+  detail::MoveArgumentsForDescriptor(&basm_, descriptor, args...);
+  if (descriptor.HasContextParameter()) {
+    __ LoadContext(descriptor.ContextRegister());
+  }
+  __ CallBuiltin(builtin);
   __ RecordComment("]");
 }
 
-template <Builtins::Name kBuiltin, typename... Args>
-void BaselineCompiler::TailCallBuiltin(Args... args) {
-  detail::MoveArgumentsForBuiltin<kBuiltin>(&basm_, args...);
-  __ TailCallBuiltin(kBuiltin);
+template <typename... Args>
+void BaselineCompiler::TailCallBuiltin(Builtins::Name builtin, Args... args) {
+  CallInterfaceDescriptor descriptor =
+      Builtins::CallInterfaceDescriptorFor(builtin);
+  detail::MoveArgumentsForDescriptor(&basm_, descriptor, args...);
+  if (descriptor.HasContextParameter()) {
+    __ LoadContext(descriptor.ContextRegister());
+  }
+  __ TailCallBuiltin(builtin);
 }
 
 template <typename... Args>
@@ -591,7 +598,7 @@ void BaselineCompiler::JumpIfToBoolean(bool do_jump_if_true, Register reg,
   Register to_boolean = scratch_scope.AcquireScratch();
   {
     SaveAccumulatorScope accumulator_scope(&basm_);
-    CallBuiltin<Builtins::kToBoolean>(reg);
+    CallBuiltin(Builtins::kToBoolean, reg);
     __ Move(to_boolean, kInterpreterAccumulatorRegister);
   }
   __ JumpIfRoot(to_boolean, RootIndex::kTrueValue, true_label, true_distance);
@@ -634,21 +641,22 @@ void BaselineCompiler::VisitLdaConstant() {
 }
 
 void BaselineCompiler::VisitLdaGlobal() {
-  CallBuiltin<Builtins::kLoadGlobalICBaseline>(Constant<Name>(0),  // name
-                                               IndexAsTagged(1));  // slot
+  CallBuiltin(Builtins::kLoadGlobalICBaseline,
+              Constant<Name>(0),  // name
+              IndexAsTagged(1));  // slot
 }
 
 void BaselineCompiler::VisitLdaGlobalInsideTypeof() {
-  CallBuiltin<Builtins::kLoadGlobalICInsideTypeofBaseline>(
-      Constant<Name>(0),  // name
-      IndexAsTagged(1));  // slot
+  CallBuiltin(Builtins::kLoadGlobalICInsideTypeofBaseline,
+              Constant<Name>(0),  // name
+              IndexAsTagged(1));  // slot
 }
 
 void BaselineCompiler::VisitStaGlobal() {
-  CallBuiltin<Builtins::kStoreGlobalICBaseline>(
-      Constant<Name>(0),                // name
-      kInterpreterAccumulatorRegister,  // value
-      IndexAsTagged(1));                // slot
+  CallBuiltin(Builtins::kStoreGlobalICBaseline,
+              Constant<Name>(0),                // name
+              kInterpreterAccumulatorRegister,  // value
+              IndexAsTagged(1));                // slot
 }
 
 void BaselineCompiler::VisitPushContext() {
@@ -722,13 +730,13 @@ void BaselineCompiler::VisitLdaLookupSlot() {
 }
 
 void BaselineCompiler::VisitLdaLookupContextSlot() {
-  CallBuiltin<Builtins::kLookupContextBaseline>(
-      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin(Builtins::kLookupContextBaseline, Constant<Name>(0),
+              UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupGlobalSlot() {
-  CallBuiltin<Builtins::kLookupGlobalICBaseline>(
-      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin(Builtins::kLookupGlobalICBaseline, Constant<Name>(0),
+              UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupSlotInsideTypeof() {
@@ -736,13 +744,13 @@ void BaselineCompiler::VisitLdaLookupSlotInsideTypeof() {
 }
 
 void BaselineCompiler::VisitLdaLookupContextSlotInsideTypeof() {
-  CallBuiltin<Builtins::kLookupContextInsideTypeofBaseline>(
-      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin(Builtins::kLookupContextInsideTypeofBaseline, Constant<Name>(0),
+              UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitLdaLookupGlobalSlotInsideTypeof() {
-  CallBuiltin<Builtins::kLookupGlobalICInsideTypeofBaseline>(
-      Constant<Name>(0), UintAsTagged(2), IndexAsTagged(1));
+  CallBuiltin(Builtins::kLookupGlobalICInsideTypeofBaseline, Constant<Name>(0),
+              UintAsTagged(2), IndexAsTagged(1));
 }
 
 void BaselineCompiler::VisitStaLookupSlot() {
@@ -785,13 +793,14 @@ void BaselineCompiler::VisitMov() {
 }
 
 void BaselineCompiler::VisitLdaNamedProperty() {
-  CallBuiltin<Builtins::kLoadICBaseline>(RegisterOperand(0),  // object
-                                         Constant<Name>(1),   // name
-                                         IndexAsTagged(2));   // slot
+  CallBuiltin(Builtins::kLoadICBaseline,
+              RegisterOperand(0),  // object
+              Constant<Name>(1),   // name
+              IndexAsTagged(2));   // slot
 }
 
 void BaselineCompiler::VisitLdaNamedPropertyNoFeedback() {
-  CallBuiltin<Builtins::kGetProperty>(RegisterOperand(0), Constant<Name>(1));
+  CallBuiltin(Builtins::kGetProperty, RegisterOperand(0), Constant<Name>(1));
 }
 
 void BaselineCompiler::VisitLdaNamedPropertyFromSuper() {
@@ -799,19 +808,19 @@ void BaselineCompiler::VisitLdaNamedPropertyFromSuper() {
       LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister(),
       kInterpreterAccumulatorRegister);
 
-  CallBuiltin<Builtins::kLoadSuperICBaseline>(
-      RegisterOperand(0),  // object
-      LoadWithReceiverAndVectorDescriptor::
-          LookupStartObjectRegister(),  // lookup start
-      Constant<Name>(1),                // name
-      IndexAsTagged(2));                // slot
+  CallBuiltin(Builtins::kLoadSuperICBaseline,
+              RegisterOperand(0),  // object
+              LoadWithReceiverAndVectorDescriptor::
+                  LookupStartObjectRegister(),  // lookup start
+              Constant<Name>(1),                // name
+              IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitLdaKeyedProperty() {
-  CallBuiltin<Builtins::kKeyedLoadICBaseline>(
-      RegisterOperand(0),               // object
-      kInterpreterAccumulatorRegister,  // key
-      IndexAsTagged(1));                // slot
+  CallBuiltin(Builtins::kKeyedLoadICBaseline,
+              RegisterOperand(0),               // object
+              kInterpreterAccumulatorRegister,  // key
+              IndexAsTagged(1));                // slot
 }
 
 void BaselineCompiler::VisitLdaModuleVariable() {
@@ -869,11 +878,11 @@ void BaselineCompiler::VisitStaModuleVariable() {
 }
 
 void BaselineCompiler::VisitStaNamedProperty() {
-  CallBuiltin<Builtins::kStoreICBaseline>(
-      RegisterOperand(0),               // object
-      Constant<Name>(1),                // name
-      kInterpreterAccumulatorRegister,  // value
-      IndexAsTagged(2));                // slot
+  CallBuiltin(Builtins::kStoreICBaseline,
+              RegisterOperand(0),               // object
+              Constant<Name>(1),                // name
+              kInterpreterAccumulatorRegister,  // value
+              IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitStaNamedPropertyNoFeedback() {
@@ -891,19 +900,19 @@ void BaselineCompiler::VisitStaNamedOwnProperty() {
 }
 
 void BaselineCompiler::VisitStaKeyedProperty() {
-  CallBuiltin<Builtins::kKeyedStoreICBaseline>(
-      RegisterOperand(0),               // object
-      RegisterOperand(1),               // key
-      kInterpreterAccumulatorRegister,  // value
-      IndexAsTagged(2));                // slot
+  CallBuiltin(Builtins::kKeyedStoreICBaseline,
+              RegisterOperand(0),               // object
+              RegisterOperand(1),               // key
+              kInterpreterAccumulatorRegister,  // value
+              IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitStaInArrayLiteral() {
-  CallBuiltin<Builtins::kStoreInArrayLiteralICBaseline>(
-      RegisterOperand(0),               // object
-      RegisterOperand(1),               // name
-      kInterpreterAccumulatorRegister,  // value
-      IndexAsTagged(2));                // slot
+  CallBuiltin(Builtins::kStoreInArrayLiteralICBaseline,
+              RegisterOperand(0),               // object
+              RegisterOperand(1),               // name
+              kInterpreterAccumulatorRegister,  // value
+              IndexAsTagged(2));                // slot
 }
 
 void BaselineCompiler::VisitStaDataPropertyInLiteral() {
@@ -925,143 +934,132 @@ void BaselineCompiler::VisitCollectTypeProfile() {
 }
 
 void BaselineCompiler::VisitAdd() {
-  CallBuiltin<Builtins::kAdd_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kAdd_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitSub() {
-  CallBuiltin<Builtins::kSubtract_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kSubtract_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitMul() {
-  CallBuiltin<Builtins::kMultiply_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kMultiply_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitDiv() {
-  CallBuiltin<Builtins::kDivide_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kDivide_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitMod() {
-  CallBuiltin<Builtins::kModulus_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kModulus_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitExp() {
-  CallBuiltin<Builtins::kExponentiate_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kExponentiate_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseOr() {
-  CallBuiltin<Builtins::kBitwiseOr_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kBitwiseOr_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseXor() {
-  CallBuiltin<Builtins::kBitwiseXor_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kBitwiseXor_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitBitwiseAnd() {
-  CallBuiltin<Builtins::kBitwiseAnd_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kBitwiseAnd_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftLeft() {
-  CallBuiltin<Builtins::kShiftLeft_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kShiftLeft_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftRight() {
-  CallBuiltin<Builtins::kShiftRight_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kShiftRight_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
 }
 
 void BaselineCompiler::VisitShiftRightLogical() {
-  CallBuiltin<Builtins::kShiftRightLogical_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  CallBuiltin(Builtins::kShiftRightLogical_Baseline, RegisterOperand(0),
+              kInterpreterAccumulatorRegister, Index(1));
+}
+
+void BaselineCompiler::BuildBinopWithConstant(Builtins::Name builtin_name) {
+  CallBuiltin(builtin_name, kInterpreterAccumulatorRegister, IntAsSmi(0),
+              Index(1));
 }
 
 void BaselineCompiler::VisitAddSmi() {
-  CallBuiltin<Builtins::kAdd_Baseline>(kInterpreterAccumulatorRegister,
-                                       IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kAdd_Baseline);
 }
 
 void BaselineCompiler::VisitSubSmi() {
-  CallBuiltin<Builtins::kSubtract_Baseline>(kInterpreterAccumulatorRegister,
-                                            IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kSubtract_Baseline);
 }
 
 void BaselineCompiler::VisitMulSmi() {
-  CallBuiltin<Builtins::kMultiply_Baseline>(kInterpreterAccumulatorRegister,
-                                            IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kMultiply_Baseline);
 }
 
 void BaselineCompiler::VisitDivSmi() {
-  CallBuiltin<Builtins::kDivide_Baseline>(kInterpreterAccumulatorRegister,
-                                          IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kDivide_Baseline);
 }
 
 void BaselineCompiler::VisitModSmi() {
-  CallBuiltin<Builtins::kModulus_Baseline>(kInterpreterAccumulatorRegister,
-                                           IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kModulus_Baseline);
 }
 
 void BaselineCompiler::VisitExpSmi() {
-  CallBuiltin<Builtins::kExponentiate_Baseline>(kInterpreterAccumulatorRegister,
-                                                IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kExponentiate_Baseline);
 }
 
 void BaselineCompiler::VisitBitwiseOrSmi() {
-  CallBuiltin<Builtins::kBitwiseOr_Baseline>(kInterpreterAccumulatorRegister,
-                                             IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kBitwiseOr_Baseline);
 }
 
 void BaselineCompiler::VisitBitwiseXorSmi() {
-  CallBuiltin<Builtins::kBitwiseXor_Baseline>(kInterpreterAccumulatorRegister,
-                                              IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kBitwiseXor_Baseline);
 }
 
 void BaselineCompiler::VisitBitwiseAndSmi() {
-  CallBuiltin<Builtins::kBitwiseAnd_Baseline>(kInterpreterAccumulatorRegister,
-                                              IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kBitwiseAnd_Baseline);
 }
 
 void BaselineCompiler::VisitShiftLeftSmi() {
-  CallBuiltin<Builtins::kShiftLeft_Baseline>(kInterpreterAccumulatorRegister,
-                                             IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kShiftLeft_Baseline);
 }
 
 void BaselineCompiler::VisitShiftRightSmi() {
-  CallBuiltin<Builtins::kShiftRight_Baseline>(kInterpreterAccumulatorRegister,
-                                              IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kShiftRight_Baseline);
 }
 
 void BaselineCompiler::VisitShiftRightLogicalSmi() {
-  CallBuiltin<Builtins::kShiftRightLogical_Baseline>(
-      kInterpreterAccumulatorRegister, IntAsSmi(0), Index(1));
+  BuildBinopWithConstant(Builtins::kShiftRightLogical_Baseline);
 }
 
-void BaselineCompiler::VisitInc() {
-  CallBuiltin<Builtins::kIncrement_Baseline>(kInterpreterAccumulatorRegister,
-                                             Index(0));
+void BaselineCompiler::BuildUnop(Builtins::Name builtin_name) {
+  CallBuiltin(builtin_name,
+              kInterpreterAccumulatorRegister,  // value
+              Index(0));                        // slot
 }
 
-void BaselineCompiler::VisitDec() {
-  CallBuiltin<Builtins::kDecrement_Baseline>(kInterpreterAccumulatorRegister,
-                                             Index(0));
-}
+void BaselineCompiler::VisitInc() { BuildUnop(Builtins::kIncrement_Baseline); }
 
-void BaselineCompiler::VisitNegate() {
-  CallBuiltin<Builtins::kNegate_Baseline>(kInterpreterAccumulatorRegister,
-                                          Index(0));
-}
+void BaselineCompiler::VisitDec() { BuildUnop(Builtins::kDecrement_Baseline); }
+
+void BaselineCompiler::VisitNegate() { BuildUnop(Builtins::kNegate_Baseline); }
 
 void BaselineCompiler::VisitBitwiseNot() {
-  CallBuiltin<Builtins::kBitwiseNot_Baseline>(kInterpreterAccumulatorRegister,
-                                              Index(0));
+  BuildUnop(Builtins::kBitwiseNot_Baseline);
 }
 
 void BaselineCompiler::VisitToBooleanLogicalNot() {
@@ -1083,23 +1081,23 @@ void BaselineCompiler::VisitLogicalNot() {
 }
 
 void BaselineCompiler::VisitTypeOf() {
-  CallBuiltin<Builtins::kTypeof>(kInterpreterAccumulatorRegister);
+  CallBuiltin(Builtins::kTypeof, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitDeletePropertyStrict() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register scratch = scratch_scope.AcquireScratch();
   __ Move(scratch, kInterpreterAccumulatorRegister);
-  CallBuiltin<Builtins::kDeleteProperty>(RegisterOperand(0), scratch,
-                                         Smi::FromEnum(LanguageMode::kStrict));
+  CallBuiltin(Builtins::kDeleteProperty, RegisterOperand(0), scratch,
+              Smi::FromEnum(LanguageMode::kStrict));
 }
 
 void BaselineCompiler::VisitDeletePropertySloppy() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register scratch = scratch_scope.AcquireScratch();
   __ Move(scratch, kInterpreterAccumulatorRegister);
-  CallBuiltin<Builtins::kDeleteProperty>(RegisterOperand(0), scratch,
-                                         Smi::FromEnum(LanguageMode::kSloppy));
+  CallBuiltin(Builtins::kDeleteProperty, RegisterOperand(0), scratch,
+              Smi::FromEnum(LanguageMode::kSloppy));
 }
 
 void BaselineCompiler::VisitGetSuperConstructor() {
@@ -1108,94 +1106,87 @@ void BaselineCompiler::VisitGetSuperConstructor() {
   __ LoadPrototype(prototype, kInterpreterAccumulatorRegister);
   StoreRegister(0, prototype);
 }
-
-namespace {
-constexpr Builtins::Name ConvertReceiverModeToBuiltin(
-    ConvertReceiverMode mode) {
+template <typename... Args>
+void BaselineCompiler::BuildCall(ConvertReceiverMode mode, uint32_t slot,
+                                 uint32_t arg_count, Args... args) {
+  Builtins::Name builtin;
   switch (mode) {
     case ConvertReceiverMode::kAny:
-      return Builtins::kCall_ReceiverIsAny_Baseline;
+      builtin = Builtins::kCall_ReceiverIsAny_Baseline;
       break;
     case ConvertReceiverMode::kNullOrUndefined:
-      return Builtins::kCall_ReceiverIsNullOrUndefined_Baseline;
+      builtin = Builtins::kCall_ReceiverIsNullOrUndefined_Baseline;
       break;
     case ConvertReceiverMode::kNotNullOrUndefined:
-      return Builtins::kCall_ReceiverIsNotNullOrUndefined_Baseline;
+      builtin = Builtins::kCall_ReceiverIsNotNullOrUndefined_Baseline;
       break;
     default:
       UNREACHABLE();
   }
-}
-}  // namespace
-
-template <ConvertReceiverMode kMode, typename... Args>
-void BaselineCompiler::BuildCall(uint32_t slot, uint32_t arg_count,
-                                 Args... args) {
-  CallBuiltin<ConvertReceiverModeToBuiltin(kMode)>(
-      RegisterOperand(0),  // kFunction
-      arg_count,           // kActualArgumentsCount
-      slot,                // kSlot
-      args...);            // Arguments
+  CallBuiltin(builtin,
+              RegisterOperand(0),  // kFunction
+              arg_count,           // kActualArgumentsCount
+              slot,                // kSlot
+              args...);            // Arguments
 }
 
 void BaselineCompiler::VisitCallAnyReceiver() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count() - 1;  // Remove receiver.
-  BuildCall<ConvertReceiverMode::kAny>(Index(3), arg_count, args);
+  BuildCall(ConvertReceiverMode::kAny, Index(3), arg_count, args);
 }
 
 void BaselineCompiler::VisitCallProperty() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count() - 1;  // Remove receiver.
-  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(Index(3), arg_count,
-                                                      args);
+  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(3), arg_count,
+            args);
 }
 
 void BaselineCompiler::VisitCallProperty0() {
-  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(Index(2), 0,
-                                                      RegisterOperand(1));
+  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(2), 0,
+            RegisterOperand(1));
 }
 
 void BaselineCompiler::VisitCallProperty1() {
-  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(
-      Index(3), 1, RegisterOperand(1), RegisterOperand(2));
+  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(3), 1,
+            RegisterOperand(1), RegisterOperand(2));
 }
 
 void BaselineCompiler::VisitCallProperty2() {
-  BuildCall<ConvertReceiverMode::kNotNullOrUndefined>(
-      Index(4), 2, RegisterOperand(1), RegisterOperand(2), RegisterOperand(3));
+  BuildCall(ConvertReceiverMode::kNotNullOrUndefined, Index(4), 2,
+            RegisterOperand(1), RegisterOperand(2), RegisterOperand(3));
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count();
-  BuildCall<ConvertReceiverMode::kNullOrUndefined>(
-      Index(3), arg_count, RootIndex::kUndefinedValue, args);
+  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(3), arg_count,
+            RootIndex::kUndefinedValue, args);
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver0() {
-  BuildCall<ConvertReceiverMode::kNullOrUndefined>(Index(1), 0,
-                                                   RootIndex::kUndefinedValue);
+  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(1), 0,
+            RootIndex::kUndefinedValue);
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver1() {
-  BuildCall<ConvertReceiverMode::kNullOrUndefined>(
-      Index(2), 1, RootIndex::kUndefinedValue, RegisterOperand(1));
+  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(2), 1,
+            RootIndex::kUndefinedValue, RegisterOperand(1));
 }
 
 void BaselineCompiler::VisitCallUndefinedReceiver2() {
-  BuildCall<ConvertReceiverMode::kNullOrUndefined>(
-      Index(3), 2, RootIndex::kUndefinedValue, RegisterOperand(1),
-      RegisterOperand(2));
+  BuildCall(ConvertReceiverMode::kNullOrUndefined, Index(3), 2,
+            RootIndex::kUndefinedValue, RegisterOperand(1), RegisterOperand(2));
 }
 
 void BaselineCompiler::VisitCallNoFeedback() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count();
-  CallBuiltin<Builtins::kCall_ReceiverIsAny>(
-      RegisterOperand(0),  // kFunction
-      arg_count - 1,       // kActualArgumentsCount
-      args);
+  CallBuiltin(Builtins::kCall_ReceiverIsAny,
+              RegisterOperand(0),  // kFunction
+              arg_count - 1,       // kActualArgumentsCount
+              args);
 }
 
 void BaselineCompiler::VisitCallWithSpread() {
@@ -1207,12 +1198,12 @@ void BaselineCompiler::VisitCallWithSpread() {
 
   uint32_t arg_count = args.register_count() - 1;  // Remove receiver.
 
-  CallBuiltin<Builtins::kCallWithSpread_Baseline>(
-      RegisterOperand(0),  // kFunction
-      arg_count,           // kActualArgumentsCount
-      spread_register,     // kSpread
-      Index(3),            // kSlot
-      args);
+  CallBuiltin(Builtins::kCallWithSpread_Baseline,
+              RegisterOperand(0),  // kFunction
+              arg_count,           // kActualArgumentsCount
+              spread_register,     // kSpread
+              Index(3),            // kSlot
+              args);
 }
 
 void BaselineCompiler::VisitCallRuntime() {
@@ -1235,11 +1226,11 @@ void BaselineCompiler::VisitCallJSRuntime() {
   __ LoadContext(kContextRegister);
   __ LoadNativeContextSlot(kJavaScriptCallTargetRegister,
                            iterator().GetNativeContextIndexOperand(0));
-  CallBuiltin<Builtins::kCall_ReceiverIsNullOrUndefined>(
-      kJavaScriptCallTargetRegister,  // kFunction
-      arg_count,                      // kActualArgumentsCount
-      RootIndex::kUndefinedValue,     // kReceiver
-      args);
+  CallBuiltin(Builtins::kCall_ReceiverIsNullOrUndefined,
+              kJavaScriptCallTargetRegister,  // kFunction
+              arg_count,                      // kActualArgumentsCount
+              RootIndex::kUndefinedValue,     // kReceiver
+              args);
 }
 
 void BaselineCompiler::VisitInvokeIntrinsic() {
@@ -1310,29 +1301,29 @@ void BaselineCompiler::VisitIntrinsicIsSmi(interpreter::RegisterList args) {
 
 void BaselineCompiler::VisitIntrinsicCopyDataProperties(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCopyDataProperties>(args);
+  CallBuiltin(Builtins::kCopyDataProperties, args);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateIterResultObject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCreateIterResultObject>(args);
+  CallBuiltin(Builtins::kCreateIterResultObject, args);
 }
 
 void BaselineCompiler::VisitIntrinsicHasProperty(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kHasProperty>(args);
+  CallBuiltin(Builtins::kHasProperty, args);
 }
 
 void BaselineCompiler::VisitIntrinsicToString(interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kToString>(args);
+  CallBuiltin(Builtins::kToString, args);
 }
 
 void BaselineCompiler::VisitIntrinsicToLength(interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kToLength>(args);
+  CallBuiltin(Builtins::kToLength, args);
 }
 
 void BaselineCompiler::VisitIntrinsicToObject(interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kToObject>(args);
+  CallBuiltin(Builtins::kToObject, args);
 }
 
 void BaselineCompiler::VisitIntrinsicCall(interpreter::RegisterList args) {
@@ -1344,20 +1335,20 @@ void BaselineCompiler::VisitIntrinsicCall(interpreter::RegisterList args) {
   args = args.PopLeft();
 
   uint32_t arg_count = args.register_count();
-  CallBuiltin<Builtins::kCall_ReceiverIsAny>(
-      kJavaScriptCallTargetRegister,  // kFunction
-      arg_count - 1,                  // kActualArgumentsCount
-      args);
+  CallBuiltin(Builtins::kCall_ReceiverIsAny,
+              kJavaScriptCallTargetRegister,  // kFunction
+              arg_count - 1,                  // kActualArgumentsCount
+              args);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateAsyncFromSyncIterator(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCreateAsyncFromSyncIteratorBaseline>(args[0]);
+  CallBuiltin(Builtins::kCreateAsyncFromSyncIteratorBaseline, args[0]);
 }
 
 void BaselineCompiler::VisitIntrinsicCreateJSGeneratorObject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kCreateGeneratorObject>(args);
+  CallBuiltin(Builtins::kCreateGeneratorObject, args);
 }
 
 void BaselineCompiler::VisitIntrinsicGeneratorGetResumeMode(
@@ -1379,69 +1370,69 @@ void BaselineCompiler::VisitIntrinsicGeneratorClose(
 
 void BaselineCompiler::VisitIntrinsicGetImportMetaObject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kGetImportMetaObjectBaseline>();
+  CallBuiltin(Builtins::kGetImportMetaObjectBaseline);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionAwaitCaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionAwaitCaught>(args);
+  CallBuiltin(Builtins::kAsyncFunctionAwaitCaught, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionAwaitUncaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionAwaitUncaught>(args);
+  CallBuiltin(Builtins::kAsyncFunctionAwaitUncaught, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionEnter(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionEnter>(args);
+  CallBuiltin(Builtins::kAsyncFunctionEnter, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionReject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionReject>(args);
+  CallBuiltin(Builtins::kAsyncFunctionReject, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncFunctionResolve(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncFunctionResolve>(args);
+  CallBuiltin(Builtins::kAsyncFunctionResolve, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorAwaitCaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorAwaitCaught>(args);
+  CallBuiltin(Builtins::kAsyncGeneratorAwaitCaught, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorAwaitUncaught(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorAwaitUncaught>(args);
+  CallBuiltin(Builtins::kAsyncGeneratorAwaitUncaught, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorReject(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorReject>(args);
+  CallBuiltin(Builtins::kAsyncGeneratorReject, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorResolve(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorResolve>(args);
+  CallBuiltin(Builtins::kAsyncGeneratorResolve, args);
 }
 
 void BaselineCompiler::VisitIntrinsicAsyncGeneratorYield(
     interpreter::RegisterList args) {
-  CallBuiltin<Builtins::kAsyncGeneratorYield>(args);
+  CallBuiltin(Builtins::kAsyncGeneratorYield, args);
 }
 
 void BaselineCompiler::VisitConstruct() {
   interpreter::RegisterList args = iterator().GetRegisterListOperand(1);
   uint32_t arg_count = args.register_count();
-  CallBuiltin<Builtins::kConstruct_Baseline>(
-      RegisterOperand(0),               // kFunction
-      kInterpreterAccumulatorRegister,  // kNewTarget
-      arg_count,                        // kActualArgumentsCount
-      Index(3),                         // kSlot
-      RootIndex::kUndefinedValue,       // kReceiver
-      args);
+  CallBuiltin(Builtins::kConstruct_Baseline,
+              RegisterOperand(0),               // kFunction
+              kInterpreterAccumulatorRegister,  // kNewTarget
+              arg_count,                        // kActualArgumentsCount
+              Index(3),                         // kSlot
+              RootIndex::kUndefinedValue,       // kReceiver
+              args);
 }
 
 void BaselineCompiler::VisitConstructWithSpread() {
@@ -1453,50 +1444,51 @@ void BaselineCompiler::VisitConstructWithSpread() {
 
   uint32_t arg_count = args.register_count();
 
-  using Descriptor =
-      CallInterfaceDescriptorFor<Builtins::kConstructWithSpread_Baseline>::type;
   Register new_target =
-      Descriptor::GetRegisterParameter(Descriptor::kNewTarget);
+      Builtins::CallInterfaceDescriptorFor(
+          Builtins::kConstructWithSpread_Baseline)
+          .GetRegisterParameter(
+              ConstructWithSpread_BaselineDescriptor::kNewTarget);
   __ Move(new_target, kInterpreterAccumulatorRegister);
 
-  CallBuiltin<Builtins::kConstructWithSpread_Baseline>(
-      RegisterOperand(0),          // kFunction
-      new_target,                  // kNewTarget
-      arg_count,                   // kActualArgumentsCount
-      Index(3),                    // kSlot
-      spread_register,             // kSpread
-      RootIndex::kUndefinedValue,  // kReceiver
-      args);
+  CallBuiltin(Builtins::kConstructWithSpread_Baseline,
+              RegisterOperand(0),          // kFunction
+              new_target,                  // kNewTarget
+              arg_count,                   // kActualArgumentsCount
+              Index(3),                    // kSlot
+              spread_register,             // kSpread
+              RootIndex::kUndefinedValue,  // kReceiver
+              args);
+}
+
+void BaselineCompiler::BuildCompare(Builtins::Name builtin_name) {
+  CallBuiltin(builtin_name, RegisterOperand(0),  // lhs
+              kInterpreterAccumulatorRegister,   // rhs
+              Index(1));                         // slot
 }
 
 void BaselineCompiler::VisitTestEqual() {
-  CallBuiltin<Builtins::kEqual_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  BuildCompare(Builtins::kEqual_Baseline);
 }
 
 void BaselineCompiler::VisitTestEqualStrict() {
-  CallBuiltin<Builtins::kStrictEqual_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  BuildCompare(Builtins::kStrictEqual_Baseline);
 }
 
 void BaselineCompiler::VisitTestLessThan() {
-  CallBuiltin<Builtins::kLessThan_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  BuildCompare(Builtins::kLessThan_Baseline);
 }
 
 void BaselineCompiler::VisitTestGreaterThan() {
-  CallBuiltin<Builtins::kGreaterThan_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  BuildCompare(Builtins::kGreaterThan_Baseline);
 }
 
 void BaselineCompiler::VisitTestLessThanOrEqual() {
-  CallBuiltin<Builtins::kLessThanOrEqual_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  BuildCompare(Builtins::kLessThanOrEqual_Baseline);
 }
 
 void BaselineCompiler::VisitTestGreaterThanOrEqual() {
-  CallBuiltin<Builtins::kGreaterThanOrEqual_Baseline>(
-      RegisterOperand(0), kInterpreterAccumulatorRegister, Index(1));
+  BuildCompare(Builtins::kGreaterThanOrEqual_Baseline);
 }
 
 void BaselineCompiler::VisitTestReferenceEqual() {
@@ -1510,21 +1502,21 @@ void BaselineCompiler::VisitTestReferenceEqual() {
 }
 
 void BaselineCompiler::VisitTestInstanceOf() {
-  using Descriptor =
-      CallInterfaceDescriptorFor<Builtins::kInstanceOf_Baseline>::type;
-  Register callable = Descriptor::GetRegisterParameter(Descriptor::kRight);
+  Register callable =
+      Builtins::CallInterfaceDescriptorFor(Builtins::kInstanceOf_Baseline)
+          .GetRegisterParameter(Compare_BaselineDescriptor::kRight);
   __ Move(callable, kInterpreterAccumulatorRegister);
-
-  CallBuiltin<Builtins::kInstanceOf_Baseline>(RegisterOperand(0),  // object
-                                              callable,            // callable
-                                              Index(1));           // slot
+  CallBuiltin(Builtins::kInstanceOf_Baseline,
+              RegisterOperand(0),  // object
+              callable,            // callable
+              Index(1));           // slot
 }
 
 void BaselineCompiler::VisitTestIn() {
-  CallBuiltin<Builtins::kKeyedHasICBaseline>(
-      kInterpreterAccumulatorRegister,  // object
-      RegisterOperand(0),               // name
-      IndexAsTagged(1));                // slot
+  CallBuiltin(Builtins::kKeyedHasICBaseline,
+              kInterpreterAccumulatorRegister,  // object
+              RegisterOperand(0),               // name
+              IndexAsTagged(1));                // slot
 }
 
 void BaselineCompiler::VisitTestUndetectable() {
@@ -1735,36 +1727,36 @@ void BaselineCompiler::VisitTestTypeOf() {
 
 void BaselineCompiler::VisitToName() {
   SaveAccumulatorScope save_accumulator(&basm_);
-  CallBuiltin<Builtins::kToName>(kInterpreterAccumulatorRegister);
+  CallBuiltin(Builtins::kToName, kInterpreterAccumulatorRegister);
   StoreRegister(0, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitToNumber() {
-  CallBuiltin<Builtins::kToNumber_Baseline>(kInterpreterAccumulatorRegister,
-                                            Index(0));
+  CallBuiltin(Builtins::kToNumber_Baseline, kInterpreterAccumulatorRegister,
+              Index(0));
 }
 
 void BaselineCompiler::VisitToNumeric() {
-  CallBuiltin<Builtins::kToNumeric_Baseline>(kInterpreterAccumulatorRegister,
-                                             Index(0));
+  CallBuiltin(Builtins::kToNumeric_Baseline, kInterpreterAccumulatorRegister,
+              Index(0));
 }
 
 void BaselineCompiler::VisitToObject() {
   SaveAccumulatorScope save_accumulator(&basm_);
-  CallBuiltin<Builtins::kToObject>(kInterpreterAccumulatorRegister);
+  CallBuiltin(Builtins::kToObject, kInterpreterAccumulatorRegister);
   StoreRegister(0, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitToString() {
-  CallBuiltin<Builtins::kToString>(kInterpreterAccumulatorRegister);
+  CallBuiltin(Builtins::kToString, kInterpreterAccumulatorRegister);
 }
 
 void BaselineCompiler::VisitCreateRegExpLiteral() {
-  CallBuiltin<Builtins::kCreateRegExpLiteral>(
-      FeedbackVector(),         // feedback vector
-      IndexAsTagged(1),         // slot
-      Constant<HeapObject>(0),  // pattern
-      FlagAsSmi(2));            // flags
+  CallBuiltin(Builtins::kCreateRegExpLiteral,
+              FeedbackVector(),         // feedback vector
+              IndexAsTagged(1),         // slot
+              Constant<HeapObject>(0),  // pattern
+              FlagAsSmi(2));            // flags
 }
 
 void BaselineCompiler::VisitCreateArrayLiteral() {
@@ -1773,11 +1765,11 @@ void BaselineCompiler::VisitCreateArrayLiteral() {
       interpreter::CreateArrayLiteralFlags::FlagsBits::decode(flags));
   if (flags &
       interpreter::CreateArrayLiteralFlags::FastCloneSupportedBit::kMask) {
-    CallBuiltin<Builtins::kCreateShallowArrayLiteral>(
-        FeedbackVector(),          // feedback vector
-        IndexAsTagged(1),          // slot
-        Constant<HeapObject>(0),   // constant elements
-        Smi::FromInt(flags_raw));  // flags
+    CallBuiltin(Builtins::kCreateShallowArrayLiteral,
+                FeedbackVector(),          // feedback vector
+                IndexAsTagged(1),          // slot
+                Constant<HeapObject>(0),   // constant elements
+                Smi::FromInt(flags_raw));  // flags
   } else {
     CallRuntime(Runtime::kCreateArrayLiteral,
                 FeedbackVector(),          // feedback vector
@@ -1788,13 +1780,13 @@ void BaselineCompiler::VisitCreateArrayLiteral() {
 }
 
 void BaselineCompiler::VisitCreateArrayFromIterable() {
-  CallBuiltin<Builtins::kIterableToListWithSymbolLookup>(
-      kInterpreterAccumulatorRegister);  // iterable
+  CallBuiltin(Builtins::kIterableToListWithSymbolLookup,
+              kInterpreterAccumulatorRegister);  // iterable
 }
 
 void BaselineCompiler::VisitCreateEmptyArrayLiteral() {
-  CallBuiltin<Builtins::kCreateEmptyArrayLiteral>(FeedbackVector(),
-                                                  IndexAsTagged(0));
+  CallBuiltin(Builtins::kCreateEmptyArrayLiteral, FeedbackVector(),
+              IndexAsTagged(0));
 }
 
 void BaselineCompiler::VisitCreateObjectLiteral() {
@@ -1803,11 +1795,11 @@ void BaselineCompiler::VisitCreateObjectLiteral() {
       interpreter::CreateObjectLiteralFlags::FlagsBits::decode(flags));
   if (flags &
       interpreter::CreateObjectLiteralFlags::FastCloneSupportedBit::kMask) {
-    CallBuiltin<Builtins::kCreateShallowObjectLiteral>(
-        FeedbackVector(),                           // feedback vector
-        IndexAsTagged(1),                           // slot
-        Constant<ObjectBoilerplateDescription>(0),  // boilerplate
-        Smi::FromInt(flags_raw));                   // flags
+    CallBuiltin(Builtins::kCreateShallowObjectLiteral,
+                FeedbackVector(),                           // feedback vector
+                IndexAsTagged(1),                           // slot
+                Constant<ObjectBoilerplateDescription>(0),  // boilerplate
+                Smi::FromInt(flags_raw));                   // flags
   } else {
     CallRuntime(Runtime::kCreateObjectLiteral,
                 FeedbackVector(),                           // feedback vector
@@ -1818,40 +1810,39 @@ void BaselineCompiler::VisitCreateObjectLiteral() {
 }
 
 void BaselineCompiler::VisitCreateEmptyObjectLiteral() {
-  CallBuiltin<Builtins::kCreateEmptyLiteralObject>();
+  CallBuiltin(Builtins::kCreateEmptyLiteralObject);
 }
 
 void BaselineCompiler::VisitCloneObject() {
   uint32_t flags = Flag(1);
   int32_t raw_flags =
       interpreter::CreateObjectLiteralFlags::FlagsBits::decode(flags);
-  CallBuiltin<Builtins::kCloneObjectICBaseline>(
-      RegisterOperand(0),       // source
-      Smi::FromInt(raw_flags),  // flags
-      IndexAsTagged(2));        // slot
+  CallBuiltin(Builtins::kCloneObjectICBaseline,
+              RegisterOperand(0),       // source
+              Smi::FromInt(raw_flags),  // flags
+              IndexAsTagged(2));        // slot
 }
 
 void BaselineCompiler::VisitGetTemplateObject() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
-  CallBuiltin<Builtins::kGetTemplateObject>(
-      shared_function_info_,    // shared function info
-      Constant<HeapObject>(0),  // description
-      Index(1),                 // slot
-      FeedbackVector());        // feedback_vector
+  CallBuiltin(Builtins::kGetTemplateObject,
+              shared_function_info_,    // shared function info
+              Constant<HeapObject>(0),  // description
+              Index(1),                 // slot
+              FeedbackVector());        // feedback_vector
 }
 
 void BaselineCompiler::VisitCreateClosure() {
-  using Descriptor =
-      CallInterfaceDescriptorFor<Builtins::kFastNewClosure>::type;
   Register feedback_cell =
-      Descriptor::GetRegisterParameter(Descriptor::kFeedbackCell);
+      Builtins::CallInterfaceDescriptorFor(Builtins::kFastNewClosure)
+          .GetRegisterParameter(FastNewClosureDescriptor::kFeedbackCell);
   LoadClosureFeedbackArray(feedback_cell);
   __ LoadFixedArrayElement(feedback_cell, feedback_cell, Index(1));
 
   uint32_t flags = Flag(2);
   if (interpreter::CreateClosureFlags::FastNewClosureBit::decode(flags)) {
-    CallBuiltin<Builtins::kFastNewClosure>(Constant<SharedFunctionInfo>(0),
-                                           feedback_cell);
+    CallBuiltin(Builtins::kFastNewClosure, Constant<SharedFunctionInfo>(0),
+                feedback_cell);
   } else {
     Runtime::FunctionId function_id =
         interpreter::CreateClosureFlags::PretenuredBit::decode(flags)
@@ -1877,7 +1868,7 @@ void BaselineCompiler::VisitCreateFunctionContext() {
   if (slot_count < static_cast<uint32_t>(
                        ConstructorBuiltins::MaximumFunctionContextSlots())) {
     DCHECK_EQ(info->scope_type(), ScopeType::FUNCTION_SCOPE);
-    CallBuiltin<Builtins::kFastNewFunctionContextFunction>(info, slot_count);
+    CallBuiltin(Builtins::kFastNewFunctionContextFunction, info, slot_count);
   } else {
     CallRuntime(Runtime::kNewFunctionContext, Constant<ScopeInfo>(0));
   }
@@ -1889,7 +1880,7 @@ void BaselineCompiler::VisitCreateEvalContext() {
   if (slot_count < static_cast<uint32_t>(
                        ConstructorBuiltins::MaximumFunctionContextSlots())) {
     DCHECK_EQ(info->scope_type(), ScopeType::EVAL_SCOPE);
-    CallBuiltin<Builtins::kFastNewFunctionContextEval>(info, slot_count);
+    CallBuiltin(Builtins::kFastNewFunctionContextEval, info, slot_count);
   } else {
     CallRuntime(Runtime::kNewFunctionContext, Constant<ScopeInfo>(0));
   }
@@ -1905,16 +1896,16 @@ void BaselineCompiler::VisitCreateMappedArguments() {
   if (shared_function_info_->has_duplicate_parameters()) {
     CallRuntime(Runtime::kNewSloppyArguments, __ FunctionOperand());
   } else {
-    CallBuiltin<Builtins::kFastNewSloppyArguments>(__ FunctionOperand());
+    CallBuiltin(Builtins::kFastNewSloppyArguments, __ FunctionOperand());
   }
 }
 
 void BaselineCompiler::VisitCreateUnmappedArguments() {
-  CallBuiltin<Builtins::kFastNewStrictArguments>(__ FunctionOperand());
+  CallBuiltin(Builtins::kFastNewStrictArguments, __ FunctionOperand());
 }
 
 void BaselineCompiler::VisitCreateRestParameter() {
-  CallBuiltin<Builtins::kFastNewRestArguments>(__ FunctionOperand());
+  CallBuiltin(Builtins::kFastNewRestArguments, __ FunctionOperand());
 }
 
 void BaselineCompiler::VisitJumpLoop() {
@@ -1928,7 +1919,7 @@ void BaselineCompiler::VisitJumpLoop() {
   int loop_depth = iterator().GetImmediateOperand(1);
   __ CompareByte(osr_level, loop_depth);
   __ JumpIf(Condition::kUnsignedLessThanEqual, &osr_not_armed);
-  CallBuiltin<Builtins::kBaselineOnStackReplacement>();
+  CallBuiltin(Builtins::kBaselineOnStackReplacement);
   __ RecordComment("]");
 
   __ Bind(&osr_not_armed);
@@ -2066,13 +2057,13 @@ void BaselineCompiler::VisitSwitchOnSmiNoFeedback() {
 }
 
 void BaselineCompiler::VisitForInEnumerate() {
-  CallBuiltin<Builtins::kForInEnumerate>(RegisterOperand(0));
+  CallBuiltin(Builtins::kForInEnumerate, RegisterOperand(0));
 }
 
 void BaselineCompiler::VisitForInPrepare() {
   StoreRegister(0, kInterpreterAccumulatorRegister);
-  CallBuiltin<Builtins::kForInPrepare>(kInterpreterAccumulatorRegister,
-                                       IndexAsTagged(1), FeedbackVector());
+  CallBuiltin(Builtins::kForInPrepare, kInterpreterAccumulatorRegister,
+              IndexAsTagged(1), FeedbackVector());
   interpreter::Register first = iterator().GetRegisterOperand(0);
   interpreter::Register second(first.index() + 1);
   interpreter::Register third(first.index() + 2);
@@ -2094,12 +2085,13 @@ void BaselineCompiler::VisitForInContinue() {
 void BaselineCompiler::VisitForInNext() {
   interpreter::Register cache_type, cache_array;
   std::tie(cache_type, cache_array) = iterator().GetRegisterPairOperand(2);
-  CallBuiltin<Builtins::kForInNext>(Index(3),            // vector slot
-                                    RegisterOperand(0),  // object
-                                    cache_array,         // cache array
-                                    cache_type,          // cache type
-                                    RegisterOperand(1),  // index
-                                    FeedbackVector());   // feedback vector
+  CallBuiltin(Builtins::kForInNext,
+              Index(3),            // vector slot
+              RegisterOperand(0),  // object
+              cache_array,         // cache array
+              cache_type,          // cache type
+              RegisterOperand(1),  // index
+              FeedbackVector());   // feedback vector
 }
 
 void BaselineCompiler::VisitForInStep() {
@@ -2139,8 +2131,8 @@ void BaselineCompiler::VisitReturn() {
   int parameter_count_without_receiver =
       parameter_count - 1;  // Exclude the receiver to simplify the
                             // computation. We'll account for it at the end.
-  TailCallBuiltin<Builtins::kBaselineLeaveFrame>(
-      parameter_count_without_receiver, -profiling_weight);
+  TailCallBuiltin(Builtins::kBaselineLeaveFrame,
+                  parameter_count_without_receiver, -profiling_weight);
   __ RecordComment("]");
 }
 
@@ -2243,11 +2235,10 @@ void BaselineCompiler::VisitSuspendGenerator() {
 
     int bytecode_offset =
         BytecodeArray::kHeaderSize + iterator().current_offset();
-    CallBuiltin<Builtins::kSuspendGeneratorBaseline>(
-        generator_object,
-        static_cast<int>(Uint(3)),  // suspend_id
-        bytecode_offset,
-        static_cast<int>(RegisterCount(2)));  // register_count
+    CallBuiltin(Builtins::kSuspendGeneratorBaseline, generator_object,
+                static_cast<int>(Uint(3)),  // suspend_id
+                bytecode_offset,
+                static_cast<int>(RegisterCount(2)));  // register_count
   }
   VisitReturn();
 }
@@ -2257,27 +2248,26 @@ void BaselineCompiler::VisitResumeGenerator() {
   BaselineAssembler::ScratchRegisterScope scratch_scope(&basm_);
   Register generator_object = scratch_scope.AcquireScratch();
   LoadRegister(generator_object, 0);
-  CallBuiltin<Builtins::kResumeGeneratorBaseline>(
-      generator_object,
-      static_cast<int>(RegisterCount(2)));  // register_count
+  CallBuiltin(Builtins::kResumeGeneratorBaseline, generator_object,
+              static_cast<int>(RegisterCount(2)));  // register_count
 }
 
 void BaselineCompiler::VisitGetIterator() {
-  CallBuiltin<Builtins::kGetIteratorBaseline>(RegisterOperand(0),  // receiver
-                                              IndexAsTagged(1),    // load_slot
-                                              IndexAsTagged(2));   // call_slot
+  CallBuiltin(Builtins::kGetIteratorBaseline,
+              RegisterOperand(0),  // receiver
+              IndexAsTagged(1),    // load_slot
+              IndexAsTagged(2));   // call_slot
 }
 
 void BaselineCompiler::VisitDebugger() {
   SaveAccumulatorScope accumulator_scope(&basm_);
-  CallBuiltin<Builtins::kHandleDebuggerStatement>();
+  CallBuiltin(Builtins::kHandleDebuggerStatement);
 }
 
 void BaselineCompiler::VisitIncBlockCounter() {
   SaveAccumulatorScope accumulator_scope(&basm_);
-  CallBuiltin<Builtins::kIncBlockCounter>(
-      __ FunctionOperand(),
-      IndexAsSmi(0));  // coverage array slot
+  CallBuiltin(Builtins::kIncBlockCounter, __ FunctionOperand(),
+              IndexAsSmi(0));  // coverage array slot
 }
 
 void BaselineCompiler::VisitAbort() {
diff --git a/src/baseline/baseline-compiler.h b/src/baseline/baseline-compiler.h
index 458b8a0bb5..2a625a9aac 100644
--- a/src/baseline/baseline-compiler.h
+++ b/src/baseline/baseline-compiler.h
@@ -126,16 +126,26 @@ class BaselineCompiler {
                        Label::Distance distance = Label::kFar);
 
   // Call helpers.
-  template <Builtins::Name kBuiltin, typename... Args>
-  void CallBuiltin(Args... args);
+  template <typename... Args>
+  void CallBuiltin(Builtins::Name builtin, Args... args);
   template <typename... Args>
   void CallRuntime(Runtime::FunctionId function, Args... args);
 
-  template <Builtins::Name kBuiltin, typename... Args>
-  void TailCallBuiltin(Args... args);
+  template <typename... Args>
+  void TailCallBuiltin(Builtins::Name builtin, Args... args);
+
+  void BuildBinop(
+      Builtins::Name builtin_name, bool fast_path = false,
+      bool check_overflow = false,
+      std::function<void(Register, Register)> instruction = [](Register,
+                                                               Register) {});
+  void BuildUnop(Builtins::Name builtin_name);
+  void BuildCompare(Builtins::Name builtin_name);
+  void BuildBinopWithConstant(Builtins::Name builtin_name);
 
-  template <ConvertReceiverMode kMode, typename... Args>
-  void BuildCall(uint32_t slot, uint32_t arg_count, Args... args);
+  template <typename... Args>
+  void BuildCall(ConvertReceiverMode mode, uint32_t slot, uint32_t arg_count,
+                 Args... args);
 
 #ifdef V8_TRACE_UNOPTIMIZED
   void TraceBytecode(Runtime::FunctionId function_id);
diff --git a/src/baseline/ia32/baseline-compiler-ia32-inl.h b/src/baseline/ia32/baseline-compiler-ia32-inl.h
index 4d09f53665..733c05fe18 100644
--- a/src/baseline/ia32/baseline-compiler-ia32-inl.h
+++ b/src/baseline/ia32/baseline-compiler-ia32-inl.h
@@ -18,9 +18,9 @@ namespace baseline {
 void BaselineCompiler::Prologue() {
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
-      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
+              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   PrologueFillFrame();
 }
diff --git a/src/baseline/x64/baseline-assembler-x64-inl.h b/src/baseline/x64/baseline-assembler-x64-inl.h
index 7c59f380e3..202f83c761 100644
--- a/src/baseline/x64/baseline-assembler-x64-inl.h
+++ b/src/baseline/x64/baseline-assembler-x64-inl.h
@@ -7,6 +7,7 @@
 
 #include "src/base/macros.h"
 #include "src/baseline/baseline-assembler.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/x64/register-x64.h"
 
 namespace v8 {
diff --git a/src/baseline/x64/baseline-compiler-x64-inl.h b/src/baseline/x64/baseline-compiler-x64-inl.h
index a4d547b067..73b43770e5 100644
--- a/src/baseline/x64/baseline-compiler-x64-inl.h
+++ b/src/baseline/x64/baseline-compiler-x64-inl.h
@@ -18,9 +18,9 @@ namespace baseline {
 void BaselineCompiler::Prologue() {
   DCHECK_EQ(kJSFunctionRegister, kJavaScriptCallTargetRegister);
   int max_frame_size = bytecode_->frame_size() + max_call_args_;
-  CallBuiltin<Builtins::kBaselineOutOfLinePrologue>(
-      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-      max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
+  CallBuiltin(Builtins::kBaselineOutOfLinePrologue, kContextRegister,
+              kJSFunctionRegister, kJavaScriptCallArgCountRegister,
+              max_frame_size, kJavaScriptCallNewTargetRegister, bytecode_);
 
   PrologueFillFrame();
 }
diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index 33627dc656..37e0bb352b 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -6,7 +6,6 @@
 
 #include "src/api/api-arguments.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index 8856b6d0d2..09733abc3a 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -6,7 +6,6 @@
 
 #include "src/api/api-arguments.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
diff --git a/src/builtins/builtins-array-gen.cc b/src/builtins/builtins-array-gen.cc
index 833627c7b4..6b522fda6c 100644
--- a/src/builtins/builtins-array-gen.cc
+++ b/src/builtins/builtins-array-gen.cc
@@ -10,7 +10,6 @@
 #include "src/builtins/builtins-utils-gen.h"
 #include "src/builtins/builtins.h"
 #include "src/codegen/code-stub-assembler.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/execution/frame-constants.h"
 #include "src/heap/factory-inl.h"
 #include "src/objects/allocation-site-inl.h"
diff --git a/src/builtins/builtins-internal-gen.cc b/src/builtins/builtins-internal-gen.cc
index c2e9767f30..a2015e0d0b 100644
--- a/src/builtins/builtins-internal-gen.cc
+++ b/src/builtins/builtins-internal-gen.cc
@@ -7,7 +7,6 @@
 #include "src/builtins/builtins-utils-gen.h"
 #include "src/builtins/builtins.h"
 #include "src/codegen/code-stub-assembler.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/execution/frame-constants.h"
 #include "src/heap/memory-chunk.h"
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 30fa3ebcc7..4008c01c59 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -8,7 +8,6 @@
 #include "src/base/bits-iterator.h"
 #include "src/base/iterator.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
@@ -1459,7 +1458,7 @@ void Builtins::Generate_InterpreterPushArgsThenConstructImpl(
   // and edi are used as scratch registers.
   Generate_InterpreterPushZeroAndArgsAndReturnAddress(
       masm, eax, ecx, edx, edi,
-      InterpreterPushArgsThenConstructDescriptor::GetStackParameterCount(),
+      InterpreterPushArgsThenConstructDescriptor::kStackArgumentsCount,
       &stack_overflow);
 
   // Call the appropriate constructor. eax and ecx already contain intended
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index d2dff202d2..48398cf9fa 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -8,19 +8,18 @@
 #include "src/base/bits-iterator.h"
 #include "src/base/iterator.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/common/globals.h"
+#include "src/objects/code.h"
 // For interpreter_entry_return_pc_offset. TODO(jkummerow): Drop.
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
 #include "src/codegen/x64/assembler-x64.h"
-#include "src/common/globals.h"
 #include "src/deoptimizer/deoptimizer.h"
 #include "src/execution/frame-constants.h"
 #include "src/execution/frames.h"
 #include "src/heap/heap-inl.h"
 #include "src/logging/counters.h"
 #include "src/objects/cell.h"
-#include "src/objects/code.h"
 #include "src/objects/debug-objects.h"
 #include "src/objects/foreign.h"
 #include "src/objects/heap-number.h"
diff --git a/src/codegen/arm/interface-descriptors-arm-inl.h b/src/codegen/arm/interface-descriptors-arm-inl.h
deleted file mode 100644
index d2ce1204f1..0000000000
--- a/src/codegen/arm/interface-descriptors-arm-inl.h
+++ /dev/null
@@ -1,261 +0,0 @@
-// Copyright 2021 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_CODEGEN_ARM_INTERFACE_DESCRIPTORS_ARM_INL_H_
-#define V8_CODEGEN_ARM_INTERFACE_DESCRIPTORS_ARM_INL_H_
-
-#if V8_TARGET_ARCH_ARM
-
-#include "src/codegen/interface-descriptors.h"
-#include "src/execution/frames.h"
-
-namespace v8 {
-namespace internal {
-
-constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
-  auto registers = RegisterArray(r0, r1, r2, r3, r4);
-  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
-  return registers;
-}
-
-// static
-constexpr auto RecordWriteDescriptor::registers() {
-  return RegisterArray(r0, r1, r2, r3, r4, kReturnRegister0);
-}
-
-// static
-constexpr auto DynamicCheckMapsDescriptor::registers() {
-  return RegisterArray(r0, r1, r2, r3, cp);
-}
-
-// static
-constexpr auto EphemeronKeyBarrierDescriptor::registers() {
-  return RegisterArray(r0, r1, r2, r3, r4, kReturnRegister0);
-}
-
-// static
-constexpr Register LoadDescriptor::ReceiverRegister() { return r1; }
-// static
-constexpr Register LoadDescriptor::NameRegister() { return r2; }
-// static
-constexpr Register LoadDescriptor::SlotRegister() { return r0; }
-
-// static
-constexpr Register LoadWithVectorDescriptor::VectorRegister() { return r3; }
-
-// static
-constexpr Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return r4;
-}
-
-// static
-constexpr Register StoreDescriptor::ReceiverRegister() { return r1; }
-// static
-constexpr Register StoreDescriptor::NameRegister() { return r2; }
-// static
-constexpr Register StoreDescriptor::ValueRegister() { return r0; }
-// static
-constexpr Register StoreDescriptor::SlotRegister() { return r4; }
-
-// static
-constexpr Register StoreWithVectorDescriptor::VectorRegister() { return r3; }
-
-// static
-constexpr Register StoreTransitionDescriptor::MapRegister() { return r5; }
-
-// static
-constexpr Register ApiGetterDescriptor::HolderRegister() { return r0; }
-// static
-constexpr Register ApiGetterDescriptor::CallbackRegister() { return r3; }
-
-// static
-constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return r0; }
-// static
-constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return r3; }
-
-// static
-constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
-  return r3;
-}
-// static
-constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() { return r4; }
-
-// static
-// static
-constexpr Register TypeConversionDescriptor::ArgumentRegister() { return r0; }
-
-// static
-constexpr auto TypeofDescriptor::registers() { return RegisterArray(r3); }
-
-// static
-constexpr auto CallTrampolineDescriptor::registers() {
-  // r0 : number of arguments
-  // r1 : the target to call
-  return RegisterArray(r1, r0);
-}
-
-// static
-constexpr auto CallVarargsDescriptor::registers() {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r4 : arguments list length (untagged)
-  // r2 : arguments list (FixedArray)
-  return RegisterArray(r1, r0, r4, r2);
-}
-
-// static
-constexpr auto CallForwardVarargsDescriptor::registers() {
-  // r0 : number of arguments
-  // r2 : start index (to support rest parameters)
-  // r1 : the target to call
-  return RegisterArray(r1, r0, r2);
-}
-
-// static
-constexpr auto CallFunctionTemplateDescriptor::registers() {
-  // r1 : function template info
-  // r2 : number of arguments (on the stack, not including receiver)
-  return RegisterArray(r1, r2);
-}
-
-// static
-constexpr auto CallWithSpreadDescriptor::registers() {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r2 : the object to spread
-  return RegisterArray(r1, r0, r2);
-}
-
-// static
-constexpr auto CallWithArrayLikeDescriptor::registers() {
-  // r1 : the target to call
-  // r2 : the arguments list
-  return RegisterArray(r1, r2);
-}
-
-// static
-constexpr auto ConstructVarargsDescriptor::registers() {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r3 : the new target
-  // r4 : arguments list length (untagged)
-  // r2 : arguments list (FixedArray)
-  return RegisterArray(r1, r3, r0, r4, r2);
-}
-
-// static
-constexpr auto ConstructForwardVarargsDescriptor::registers() {
-  // r0 : number of arguments
-  // r3 : the new target
-  // r2 : start index (to support rest parameters)
-  // r1 : the target to call
-  return RegisterArray(r1, r3, r0, r2);
-}
-
-// static
-constexpr auto ConstructWithSpreadDescriptor::registers() {
-  // r0 : number of arguments (on the stack, not including receiver)
-  // r1 : the target to call
-  // r3 : the new target
-  // r2 : the object to spread
-  return RegisterArray(r1, r3, r0, r2);
-}
-
-// static
-constexpr auto ConstructWithArrayLikeDescriptor::registers() {
-  // r1 : the target to call
-  // r3 : the new target
-  // r2 : the arguments list
-  return RegisterArray(r1, r3, r2);
-}
-
-// static
-constexpr auto ConstructStubDescriptor::registers() {
-  // r0 : number of arguments
-  // r1 : the target to call
-  // r3 : the new target
-  // r2 : allocation site or undefined
-  return RegisterArray(r1, r3, r0, r2);
-}
-
-// static
-constexpr auto AbortDescriptor::registers() { return RegisterArray(r1); }
-
-// static
-constexpr auto CompareDescriptor::registers() { return RegisterArray(r1, r0); }
-
-// static
-constexpr auto Compare_BaselineDescriptor::registers() {
-  // r1: left operand
-  // r0: right operand
-  // r2: feedback slot
-  return RegisterArray(r1, r0, r2);
-}
-
-// static
-constexpr auto BinaryOpDescriptor::registers() { return RegisterArray(r1, r0); }
-
-// static
-constexpr auto BinaryOp_BaselineDescriptor::registers() {
-  // r1: left operand
-  // r0: right operand
-  // r2: feedback slot
-  return RegisterArray(r1, r0, r2);
-}
-
-// static
-constexpr auto ApiCallbackDescriptor::registers() {
-  return RegisterArray(r1,   // kApiFunctionAddress
-                       r2,   // kArgc
-                       r3,   // kCallData
-                       r0);  // kHolder
-}
-
-// static
-constexpr auto InterpreterDispatchDescriptor::registers() {
-  return RegisterArray(
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
-}
-
-// static
-constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
-  return RegisterArray(r0,   // argument count (not including receiver)
-                       r2,   // address of first argument
-                       r1);  // the target callable to be call
-}
-
-// static
-constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
-  return RegisterArray(
-      r0,   // argument count (not including receiver)
-      r4,   // address of the first argument
-      r1,   // constructor to call
-      r3,   // new target
-      r2);  // allocation site feedback if available, undefined otherwise
-}
-
-// static
-constexpr auto ResumeGeneratorDescriptor::registers() {
-  return RegisterArray(r0,   // the value to pass to the generator
-                       r1);  // the JSGeneratorObject to resume
-}
-
-// static
-constexpr auto FrameDropperTrampolineDescriptor::registers() {
-  return RegisterArray(r1);  // loaded new FP
-}
-
-// static
-constexpr auto RunMicrotasksEntryDescriptor::registers() {
-  return RegisterArray(r0, r1);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_ARM
-
-#endif  // V8_CODEGEN_ARM_INTERFACE_DESCRIPTORS_ARM_INL_H_
diff --git a/src/codegen/arm/interface-descriptors-arm.cc b/src/codegen/arm/interface-descriptors-arm.cc
new file mode 100644
index 0000000000..53992227ab
--- /dev/null
+++ b/src/codegen/arm/interface-descriptors-arm.cc
@@ -0,0 +1,306 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#if V8_TARGET_ARCH_ARM
+
+#include "src/codegen/interface-descriptors.h"
+
+#include "src/execution/frames.h"
+
+namespace v8 {
+namespace internal {
+
+const Register CallInterfaceDescriptor::ContextRegister() { return cp; }
+
+void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
+    CallInterfaceDescriptorData* data, int register_parameter_count) {
+  const Register default_stub_registers[] = {r0, r1, r2, r3, r4};
+  CHECK_LE(static_cast<size_t>(register_parameter_count),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(register_parameter_count,
+                                   default_stub_registers);
+}
+
+void RecordWriteDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {r0, r1, r2, r3, r4};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register default_stub_registers[] = {r0, r1, r2, r3, cp};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {r0, r1, r2, r3, r4};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+const Register LoadDescriptor::ReceiverRegister() { return r1; }
+const Register LoadDescriptor::NameRegister() { return r2; }
+const Register LoadDescriptor::SlotRegister() { return r0; }
+
+const Register LoadWithVectorDescriptor::VectorRegister() { return r3; }
+
+const Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return r4;
+}
+
+const Register StoreDescriptor::ReceiverRegister() { return r1; }
+const Register StoreDescriptor::NameRegister() { return r2; }
+const Register StoreDescriptor::ValueRegister() { return r0; }
+const Register StoreDescriptor::SlotRegister() { return r4; }
+
+const Register StoreWithVectorDescriptor::VectorRegister() { return r3; }
+
+const Register StoreTransitionDescriptor::SlotRegister() { return r4; }
+const Register StoreTransitionDescriptor::VectorRegister() { return r3; }
+const Register StoreTransitionDescriptor::MapRegister() { return r5; }
+
+const Register ApiGetterDescriptor::HolderRegister() { return r0; }
+const Register ApiGetterDescriptor::CallbackRegister() { return r3; }
+
+const Register GrowArrayElementsDescriptor::ObjectRegister() { return r0; }
+const Register GrowArrayElementsDescriptor::KeyRegister() { return r3; }
+
+const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() { return r3; }
+const Register BaselineLeaveFrameDescriptor::WeightRegister() { return r4; }
+
+// static
+const Register TypeConversionDescriptor::ArgumentRegister() { return r0; }
+
+void TypeofDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r3};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments
+  // r1 : the target to call
+  Register registers[] = {r1, r0};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r4 : arguments list length (untagged)
+  // r2 : arguments list (FixedArray)
+  Register registers[] = {r1, r0, r4, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments
+  // r2 : start index (to support rest parameters)
+  // r1 : the target to call
+  Register registers[] = {r1, r0, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r1 : function template info
+  // r2 : number of arguments (on the stack, not including receiver)
+  Register registers[] = {r1, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r2 : the object to spread
+  Register registers[] = {r1, r0, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r1 : the target to call
+  // r2 : the arguments list
+  Register registers[] = {r1, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r3 : the new target
+  // r4 : arguments list length (untagged)
+  // r2 : arguments list (FixedArray)
+  Register registers[] = {r1, r3, r0, r4, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments
+  // r3 : the new target
+  // r2 : start index (to support rest parameters)
+  // r1 : the target to call
+  Register registers[] = {r1, r3, r0, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments (on the stack, not including receiver)
+  // r1 : the target to call
+  // r3 : the new target
+  // r2 : the object to spread
+  Register registers[] = {r1, r3, r0, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r1 : the target to call
+  // r3 : the new target
+  // r2 : the arguments list
+  Register registers[] = {r1, r3, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructStubDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r0 : number of arguments
+  // r1 : the target to call
+  // r3 : the new target
+  // r2 : allocation site or undefined
+  Register registers[] = {r1, r3, r0, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void AbortDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r1};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CompareDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r1, r0};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void Compare_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r1: left operand
+  // r0: right operand
+  // r2: feedback slot
+  Register registers[] = {r1, r0, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOpDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r1, r0};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // r1: left operand
+  // r0: right operand
+  // r2: feedback slot
+  Register registers[] = {r1, r0, r2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ApiCallbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r1,  // kApiFunctionAddress
+      r2,  // kArgc
+      r3,  // kCallData
+      r0,  // kHolder
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterDispatchDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r0,  // argument count (not including receiver)
+      r2,  // address of first argument
+      r1   // the target callable to be call
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r0,  // argument count (not including receiver)
+      r4,  // address of the first argument
+      r1,  // constructor to call
+      r3,  // new target
+      r2,  // allocation site feedback if available, undefined otherwise
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ResumeGeneratorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r0,  // the value to pass to the generator
+      r1   // the JSGeneratorObject to resume
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      r1,  // loaded new FP
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {r0, r1};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_ARM
diff --git a/src/codegen/arm/macro-assembler-arm.cc b/src/codegen/arm/macro-assembler-arm.cc
index 3492911999..f83eee4a91 100644
--- a/src/codegen/arm/macro-assembler-arm.cc
+++ b/src/codegen/arm/macro-assembler-arm.cc
@@ -13,7 +13,6 @@
 #include "src/codegen/callable.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/external-reference-table.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/register-configuration.h"
 #include "src/debug/debug.h"
diff --git a/src/codegen/arm64/interface-descriptors-arm64-inl.h b/src/codegen/arm64/interface-descriptors-arm64-inl.h
deleted file mode 100644
index 0ac1d2adca..0000000000
--- a/src/codegen/arm64/interface-descriptors-arm64-inl.h
+++ /dev/null
@@ -1,270 +0,0 @@
-// Copyright 2021 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_CODEGEN_ARM64_INTERFACE_DESCRIPTORS_ARM64_INL_H_
-#define V8_CODEGEN_ARM64_INTERFACE_DESCRIPTORS_ARM64_INL_H_
-
-#if V8_TARGET_ARCH_ARM64
-
-#include "src/base/template-utils.h"
-#include "src/codegen/interface-descriptors.h"
-#include "src/execution/frames.h"
-
-namespace v8 {
-namespace internal {
-
-constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
-  auto registers = RegisterArray(x0, x1, x2, x3, x4);
-  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
-  return registers;
-}
-
-// static
-constexpr auto RecordWriteDescriptor::registers() {
-  return RegisterArray(x0, x1, x2, x3, x4, kReturnRegister0);
-}
-
-// static
-constexpr auto DynamicCheckMapsDescriptor::registers() {
-  return RegisterArray(x0, x1, x2, x3, cp);
-}
-
-// static
-constexpr auto EphemeronKeyBarrierDescriptor::registers() {
-  return RegisterArray(x0, x1, x2, x3, x4, kReturnRegister0);
-}
-
-// static
-constexpr Register LoadDescriptor::ReceiverRegister() { return x1; }
-// static
-constexpr Register LoadDescriptor::NameRegister() { return x2; }
-// static
-constexpr Register LoadDescriptor::SlotRegister() { return x0; }
-
-// static
-constexpr Register LoadWithVectorDescriptor::VectorRegister() { return x3; }
-
-// static
-constexpr Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return x4;
-}
-
-// static
-constexpr Register StoreDescriptor::ReceiverRegister() { return x1; }
-// static
-constexpr Register StoreDescriptor::NameRegister() { return x2; }
-// static
-constexpr Register StoreDescriptor::ValueRegister() { return x0; }
-// static
-constexpr Register StoreDescriptor::SlotRegister() { return x4; }
-
-// static
-constexpr Register StoreWithVectorDescriptor::VectorRegister() { return x3; }
-
-// static
-constexpr Register StoreTransitionDescriptor::MapRegister() { return x5; }
-
-// static
-constexpr Register ApiGetterDescriptor::HolderRegister() { return x0; }
-// static
-constexpr Register ApiGetterDescriptor::CallbackRegister() { return x3; }
-
-// static
-constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return x0; }
-// static
-constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return x3; }
-
-// static
-constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
-  return x3;
-}
-// static
-constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() { return x4; }
-
-// static
-// static
-constexpr Register TypeConversionDescriptor::ArgumentRegister() { return x0; }
-
-// static
-constexpr auto TypeofDescriptor::registers() { return RegisterArray(x3); }
-
-// static
-constexpr auto CallTrampolineDescriptor::registers() {
-  // x1: target
-  // x0: number of arguments
-  return RegisterArray(x1, x0);
-}
-
-// static
-constexpr auto CallVarargsDescriptor::registers() {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x4 : arguments list length (untagged)
-  // x2 : arguments list (FixedArray)
-  return RegisterArray(x1, x0, x4, x2);
-}
-
-// static
-constexpr auto CallForwardVarargsDescriptor::registers() {
-  // x1: target
-  // x0: number of arguments
-  // x2: start index (to supported rest parameters)
-  return RegisterArray(x1, x0, x2);
-}
-
-// static
-constexpr auto CallFunctionTemplateDescriptor::registers() {
-  // x1 : function template info
-  // x2 : number of arguments (on the stack, not including receiver)
-  return RegisterArray(x1, x2);
-}
-
-// static
-constexpr auto CallWithSpreadDescriptor::registers() {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x2 : the object to spread
-  return RegisterArray(x1, x0, x2);
-}
-
-// static
-constexpr auto CallWithArrayLikeDescriptor::registers() {
-  // x1 : the target to call
-  // x2 : the arguments list
-  return RegisterArray(x1, x2);
-}
-
-// static
-constexpr auto ConstructVarargsDescriptor::registers() {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x3 : the new target
-  // x4 : arguments list length (untagged)
-  // x2 : arguments list (FixedArray)
-  return RegisterArray(x1, x3, x0, x4, x2);
-}
-
-// static
-constexpr auto ConstructForwardVarargsDescriptor::registers() {
-  // x3: new target
-  // x1: target
-  // x0: number of arguments
-  // x2: start index (to supported rest parameters)
-  return RegisterArray(x1, x3, x0, x2);
-}
-
-// static
-constexpr auto ConstructWithSpreadDescriptor::registers() {
-  // x0 : number of arguments (on the stack, not including receiver)
-  // x1 : the target to call
-  // x3 : the new target
-  // x2 : the object to spread
-  return RegisterArray(x1, x3, x0, x2);
-}
-
-// static
-constexpr auto ConstructWithArrayLikeDescriptor::registers() {
-  // x1 : the target to call
-  // x3 : the new target
-  // x2 : the arguments list
-  return RegisterArray(x1, x3, x2);
-}
-
-// static
-constexpr auto ConstructStubDescriptor::registers() {
-  // x3: new target
-  // x1: target
-  // x0: number of arguments
-  // x2: allocation site or undefined
-  return RegisterArray(x1, x3, x0, x2);
-}
-
-// static
-constexpr auto AbortDescriptor::registers() { return RegisterArray(x1); }
-
-// static
-constexpr auto CompareDescriptor::registers() {
-  // x1: left operand
-  // x0: right operand
-  return RegisterArray(x1, x0);
-}
-
-// static
-constexpr auto Compare_BaselineDescriptor::registers() {
-  // x1: left operand
-  // x0: right operand
-  // x2: feedback slot
-  return RegisterArray(x1, x0, x2);
-}
-
-// static
-constexpr auto BinaryOpDescriptor::registers() {
-  // x1: left operand
-  // x0: right operand
-  return RegisterArray(x1, x0);
-}
-
-// static
-constexpr auto BinaryOp_BaselineDescriptor::registers() {
-  // x1: left operand
-  // x0: right operand
-  // x2: feedback slot
-  return RegisterArray(x1, x0, x2);
-}
-
-// static
-constexpr auto ApiCallbackDescriptor::registers() {
-  return RegisterArray(x1,   // kApiFunctionAddress
-                       x2,   // kArgc
-                       x3,   // kCallData
-                       x0);  // kHolder
-}
-
-// static
-constexpr auto InterpreterDispatchDescriptor::registers() {
-  return RegisterArray(
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
-}
-
-// static
-constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
-  return RegisterArray(x0,   // argument count (not including receiver)
-                       x2,   // address of first argument
-                       x1);  // the target callable to be call
-}
-
-// static
-constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
-  return RegisterArray(
-      x0,   // argument count (not including receiver)
-      x4,   // address of the first argument
-      x1,   // constructor to call
-      x3,   // new target
-      x2);  // allocation site feedback if available, undefined otherwise
-}
-
-// static
-constexpr auto ResumeGeneratorDescriptor::registers() {
-  return RegisterArray(x0,   // the value to pass to the generator
-                       x1);  // the JSGeneratorObject to resume
-}
-
-// static
-constexpr auto FrameDropperTrampolineDescriptor::registers() {
-  return RegisterArray(x1);  // loaded new FP
-}
-
-// static
-constexpr auto RunMicrotasksEntryDescriptor::registers() {
-  return RegisterArray(x0, x1);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_ARM64
-
-#endif  // V8_CODEGEN_ARM64_INTERFACE_DESCRIPTORS_ARM64_INL_H_
diff --git a/src/codegen/arm64/interface-descriptors-arm64.cc b/src/codegen/arm64/interface-descriptors-arm64.cc
new file mode 100644
index 0000000000..246d6fc961
--- /dev/null
+++ b/src/codegen/arm64/interface-descriptors-arm64.cc
@@ -0,0 +1,310 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#if V8_TARGET_ARCH_ARM64
+
+#include "src/codegen/interface-descriptors.h"
+
+#include "src/execution/frames.h"
+
+namespace v8 {
+namespace internal {
+
+const Register CallInterfaceDescriptor::ContextRegister() { return cp; }
+
+void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
+    CallInterfaceDescriptorData* data, int register_parameter_count) {
+  const Register default_stub_registers[] = {x0, x1, x2, x3, x4};
+  CHECK_LE(static_cast<size_t>(register_parameter_count),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(register_parameter_count,
+                                   default_stub_registers);
+}
+
+void RecordWriteDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {x0, x1, x2, x3, x4};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register default_stub_registers[] = {x0, x1, x2, x3, cp};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {x0, x1, x2, x3, x4};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+const Register LoadDescriptor::ReceiverRegister() { return x1; }
+const Register LoadDescriptor::NameRegister() { return x2; }
+const Register LoadDescriptor::SlotRegister() { return x0; }
+
+const Register LoadWithVectorDescriptor::VectorRegister() { return x3; }
+
+const Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return x4;
+}
+
+const Register StoreDescriptor::ReceiverRegister() { return x1; }
+const Register StoreDescriptor::NameRegister() { return x2; }
+const Register StoreDescriptor::ValueRegister() { return x0; }
+const Register StoreDescriptor::SlotRegister() { return x4; }
+
+const Register StoreWithVectorDescriptor::VectorRegister() { return x3; }
+
+const Register StoreTransitionDescriptor::SlotRegister() { return x4; }
+const Register StoreTransitionDescriptor::VectorRegister() { return x3; }
+const Register StoreTransitionDescriptor::MapRegister() { return x5; }
+
+const Register ApiGetterDescriptor::HolderRegister() { return x0; }
+const Register ApiGetterDescriptor::CallbackRegister() { return x3; }
+
+const Register GrowArrayElementsDescriptor::ObjectRegister() { return x0; }
+const Register GrowArrayElementsDescriptor::KeyRegister() { return x3; }
+
+const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() { return x3; }
+const Register BaselineLeaveFrameDescriptor::WeightRegister() { return x4; }
+
+// static
+const Register TypeConversionDescriptor::ArgumentRegister() { return x0; }
+
+void TypeofDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {x3};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1: target
+  // x0: number of arguments
+  Register registers[] = {x1, x0};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x4 : arguments list length (untagged)
+  // x2 : arguments list (FixedArray)
+  Register registers[] = {x1, x0, x4, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1: target
+  // x0: number of arguments
+  // x2: start index (to supported rest parameters)
+  Register registers[] = {x1, x0, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1 : function template info
+  // x2 : number of arguments (on the stack, not including receiver)
+  Register registers[] = {x1, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x2 : the object to spread
+  Register registers[] = {x1, x0, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1 : the target to call
+  // x2 : the arguments list
+  Register registers[] = {x1, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x3 : the new target
+  // x4 : arguments list length (untagged)
+  // x2 : arguments list (FixedArray)
+  Register registers[] = {x1, x3, x0, x4, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x3: new target
+  // x1: target
+  // x0: number of arguments
+  // x2: start index (to supported rest parameters)
+  Register registers[] = {x1, x3, x0, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x0 : number of arguments (on the stack, not including receiver)
+  // x1 : the target to call
+  // x3 : the new target
+  // x2 : the object to spread
+  Register registers[] = {x1, x3, x0, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1 : the target to call
+  // x3 : the new target
+  // x2 : the arguments list
+  Register registers[] = {x1, x3, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructStubDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x3: new target
+  // x1: target
+  // x0: number of arguments
+  // x2: allocation site or undefined
+  Register registers[] = {x1, x3, x0, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void AbortDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {x1};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CompareDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1: left operand
+  // x0: right operand
+  Register registers[] = {x1, x0};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void Compare_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1: left operand
+  // x0: right operand
+  // x2: feedback slot
+  Register registers[] = {x1, x0, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOpDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1: left operand
+  // x0: right operand
+  Register registers[] = {x1, x0};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // x1: left operand
+  // x0: right operand
+  // x2: feedback slot
+  Register registers[] = {x1, x0, x2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ApiCallbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      x1,  // kApiFunctionAddress
+      x2,  // kArgc
+      x3,  // kCallData
+      x0,  // kHolder
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterDispatchDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      x0,  // argument count (not including receiver)
+      x2,  // address of first argument
+      x1   // the target callable to be call
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      x0,  // argument count (not including receiver)
+      x4,  // address of the first argument
+      x1,  // constructor to call
+      x3,  // new target
+      x2,  // allocation site feedback if available, undefined otherwise
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ResumeGeneratorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      x0,  // the value to pass to the generator
+      x1   // the JSGeneratorObject to resume
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      x1,  // loaded new FP
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {x0, x1};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_ARM64
diff --git a/src/codegen/arm64/macro-assembler-arm64.cc b/src/codegen/arm64/macro-assembler-arm64.cc
index 4d7bd7ad76..ce41f3dfad 100644
--- a/src/codegen/arm64/macro-assembler-arm64.cc
+++ b/src/codegen/arm64/macro-assembler-arm64.cc
@@ -10,7 +10,6 @@
 #include "src/codegen/callable.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/external-reference-table.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/register-configuration.h"
 #include "src/codegen/reloc-info.h"
diff --git a/src/codegen/ia32/interface-descriptors-ia32-inl.h b/src/codegen/ia32/interface-descriptors-ia32-inl.h
deleted file mode 100644
index 3731f5ba39..0000000000
--- a/src/codegen/ia32/interface-descriptors-ia32-inl.h
+++ /dev/null
@@ -1,272 +0,0 @@
-// Copyright 2021 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_CODEGEN_IA32_INTERFACE_DESCRIPTORS_IA32_INL_H_
-#define V8_CODEGEN_IA32_INTERFACE_DESCRIPTORS_IA32_INL_H_
-
-#if V8_TARGET_ARCH_IA32
-
-#include "src/codegen/interface-descriptors.h"
-
-namespace v8 {
-namespace internal {
-
-constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
-  auto registers = RegisterArray(eax, ecx, edx, edi);
-  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
-  return registers;
-}
-
-// static
-constexpr auto RecordWriteDescriptor::registers() {
-  return RegisterArray(ecx, edx, esi, edi, kReturnRegister0);
-}
-
-// static
-constexpr auto DynamicCheckMapsDescriptor::registers() {
-  return RegisterArray(eax, ecx, edx, edi, esi);
-}
-
-// static
-constexpr auto EphemeronKeyBarrierDescriptor::registers() {
-  return RegisterArray(ecx, edx, esi, edi, kReturnRegister0);
-}
-
-// static
-constexpr Register LoadDescriptor::ReceiverRegister() { return edx; }
-// static
-constexpr Register LoadDescriptor::NameRegister() { return ecx; }
-// static
-constexpr Register LoadDescriptor::SlotRegister() { return eax; }
-
-// static
-constexpr Register LoadWithVectorDescriptor::VectorRegister() { return no_reg; }
-
-// static
-constexpr Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return edi;
-}
-
-// static
-constexpr Register StoreDescriptor::ReceiverRegister() { return edx; }
-// static
-constexpr Register StoreDescriptor::NameRegister() { return ecx; }
-// static
-constexpr Register StoreDescriptor::ValueRegister() { return no_reg; }
-// static
-constexpr Register StoreDescriptor::SlotRegister() { return no_reg; }
-
-// static
-constexpr Register StoreWithVectorDescriptor::VectorRegister() {
-  return no_reg;
-}
-
-// static
-constexpr Register StoreTransitionDescriptor::MapRegister() { return edi; }
-
-// static
-constexpr Register ApiGetterDescriptor::HolderRegister() { return ecx; }
-// static
-constexpr Register ApiGetterDescriptor::CallbackRegister() { return eax; }
-
-// static
-constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return eax; }
-// static
-constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return ecx; }
-
-// static
-constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
-  return esi;
-}
-// static
-constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() {
-  return edi;
-}
-
-// static
-constexpr Register TypeConversionDescriptor::ArgumentRegister() { return eax; }
-
-// static
-constexpr auto TypeofDescriptor::registers() { return RegisterArray(ecx); }
-
-// static
-constexpr auto CallTrampolineDescriptor::registers() {
-  // eax : number of arguments
-  // edi : the target to call
-  return RegisterArray(edi, eax);
-}
-
-// static
-constexpr auto CallVarargsDescriptor::registers() {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // ecx : arguments list length (untagged)
-  // On the stack : arguments list (FixedArray)
-  return RegisterArray(edi, eax, ecx);
-}
-
-// static
-constexpr auto CallForwardVarargsDescriptor::registers() {
-  // eax : number of arguments
-  // ecx : start index (to support rest parameters)
-  // edi : the target to call
-  return RegisterArray(edi, eax, ecx);
-}
-
-// static
-constexpr auto CallFunctionTemplateDescriptor::registers() {
-  // edx : function template info
-  // ecx : number of arguments (on the stack, not including receiver)
-  return RegisterArray(edx, ecx);
-}
-
-// static
-constexpr auto CallWithSpreadDescriptor::registers() {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // ecx : the object to spread
-  return RegisterArray(edi, eax, ecx);
-}
-
-// static
-constexpr auto CallWithArrayLikeDescriptor::registers() {
-  // edi : the target to call
-  // edx : the arguments list
-  return RegisterArray(edi, edx);
-}
-
-// static
-constexpr auto ConstructVarargsDescriptor::registers() {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // edx : the new target
-  // ecx : arguments list length (untagged)
-  // On the stack : arguments list (FixedArray)
-  return RegisterArray(edi, edx, eax, ecx);
-}
-
-// static
-constexpr auto ConstructForwardVarargsDescriptor::registers() {
-  // eax : number of arguments
-  // edx : the new target
-  // ecx : start index (to support rest parameters)
-  // edi : the target to call
-  return RegisterArray(edi, edx, eax, ecx);
-}
-
-// static
-constexpr auto ConstructWithSpreadDescriptor::registers() {
-  // eax : number of arguments (on the stack, not including receiver)
-  // edi : the target to call
-  // edx : the new target
-  // ecx : the object to spread
-  return RegisterArray(edi, edx, eax, ecx);
-}
-
-// static
-constexpr auto ConstructWithArrayLikeDescriptor::registers() {
-  // edi : the target to call
-  // edx : the new target
-  // ecx : the arguments list
-  return RegisterArray(edi, edx, ecx);
-}
-
-// static
-constexpr auto ConstructStubDescriptor::registers() {
-  // eax : number of arguments
-  // edx : the new target
-  // edi : the target to call
-  // ecx : allocation site or undefined
-  // TODO(jgruber): Remove the unused allocation site parameter.
-  return RegisterArray(edi, edx, eax, ecx);
-}
-
-// static
-constexpr auto AbortDescriptor::registers() { return RegisterArray(edx); }
-
-// static
-constexpr auto CompareDescriptor::registers() {
-  return RegisterArray(edx, eax);
-}
-
-// static
-constexpr auto Compare_BaselineDescriptor::registers() {
-  return RegisterArray(edx, eax, ecx);
-}
-
-// static
-constexpr auto BinaryOpDescriptor::registers() {
-  return RegisterArray(edx, eax);
-}
-
-// static
-constexpr auto BinaryOp_BaselineDescriptor::registers() {
-  return RegisterArray(edx, eax, ecx);
-}
-
-// static
-constexpr auto ApiCallbackDescriptor::registers() {
-  return RegisterArray(edx,   // kApiFunctionAddress
-                       ecx,   // kArgc
-                       eax,   // kCallData
-                       edi);  // kHolder
-}
-
-// static
-constexpr auto InterpreterDispatchDescriptor::registers() {
-  return RegisterArray(
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
-}
-
-// static
-constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
-  return RegisterArray(eax,   // argument count (not including receiver)
-                       ecx,   // address of first argument
-                       edi);  // the target callable to be call
-}
-
-// static
-constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
-  return RegisterArray(eax,   // argument count (not including receiver)
-                       ecx);  // address of first argument
-}
-
-// static
-constexpr auto ResumeGeneratorDescriptor::registers() {
-  return RegisterArray(eax,   // the value to pass to the generator
-                       edx);  // the JSGeneratorObject to resume
-}
-
-// static
-constexpr auto FrameDropperTrampolineDescriptor::registers() {
-  return RegisterArray(eax);  // loaded new FP
-}
-
-// static
-constexpr auto RunMicrotasksEntryDescriptor::registers() {
-  return RegisterArray();
-}
-
-// static
-constexpr auto WasmFloat32ToNumberDescriptor::registers() {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  return RegisterArray(ecx);
-}
-
-// static
-constexpr auto WasmFloat64ToNumberDescriptor::registers() {
-  // Work around using eax, whose register code is 0, and leads to the FP
-  // parameter being passed via xmm0, which is not allocatable on ia32.
-  return RegisterArray(ecx);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_IA32
-
-#endif  // V8_CODEGEN_IA32_INTERFACE_DESCRIPTORS_IA32_INL_H_
diff --git a/src/codegen/ia32/interface-descriptors-ia32.cc b/src/codegen/ia32/interface-descriptors-ia32.cc
new file mode 100644
index 0000000000..fd76e01590
--- /dev/null
+++ b/src/codegen/ia32/interface-descriptors-ia32.cc
@@ -0,0 +1,318 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#if V8_TARGET_ARCH_IA32
+
+#include "src/codegen/interface-descriptors.h"
+
+#include "src/execution/frames.h"
+
+namespace v8 {
+namespace internal {
+
+const Register CallInterfaceDescriptor::ContextRegister() { return esi; }
+
+void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
+    CallInterfaceDescriptorData* data, int register_parameter_count) {
+  constexpr Register default_stub_registers[] = {eax, ecx, edx, edi};
+  STATIC_ASSERT(arraysize(default_stub_registers) == kMaxBuiltinRegisterParams);
+  CHECK_LE(static_cast<size_t>(register_parameter_count),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(register_parameter_count,
+                                   default_stub_registers);
+}
+
+void RecordWriteDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  static const Register default_stub_registers[] = {ecx, edx, esi, edi,
+                                                    kReturnRegister0};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register default_stub_registers[] = {eax, ecx, edx, edi, esi};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  static const Register default_stub_registers[] = {ecx, edx, esi, edi,
+                                                    kReturnRegister0};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+const Register LoadDescriptor::ReceiverRegister() { return edx; }
+const Register LoadDescriptor::NameRegister() { return ecx; }
+const Register LoadDescriptor::SlotRegister() { return eax; }
+
+const Register LoadWithVectorDescriptor::VectorRegister() { return no_reg; }
+
+const Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return edi;
+}
+
+const Register StoreDescriptor::ReceiverRegister() { return edx; }
+const Register StoreDescriptor::NameRegister() { return ecx; }
+const Register StoreDescriptor::ValueRegister() { return no_reg; }
+const Register StoreDescriptor::SlotRegister() { return no_reg; }
+
+const Register StoreWithVectorDescriptor::VectorRegister() { return no_reg; }
+
+const Register StoreTransitionDescriptor::SlotRegister() { return no_reg; }
+const Register StoreTransitionDescriptor::VectorRegister() { return no_reg; }
+const Register StoreTransitionDescriptor::MapRegister() { return edi; }
+
+const Register ApiGetterDescriptor::HolderRegister() { return ecx; }
+const Register ApiGetterDescriptor::CallbackRegister() { return eax; }
+
+const Register GrowArrayElementsDescriptor::ObjectRegister() { return eax; }
+const Register GrowArrayElementsDescriptor::KeyRegister() { return ecx; }
+
+const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
+  return esi;
+}
+const Register BaselineLeaveFrameDescriptor::WeightRegister() { return edi; }
+
+// static
+const Register TypeConversionDescriptor::ArgumentRegister() { return eax; }
+
+void TypeofDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments
+  // edi : the target to call
+  Register registers[] = {edi, eax};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // ecx : arguments list length (untagged)
+  // On the stack : arguments list (FixedArray)
+  Register registers[] = {edi, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments
+  // ecx : start index (to support rest parameters)
+  // edi : the target to call
+  Register registers[] = {edi, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // edx : function template info
+  // ecx : number of arguments (on the stack, not including receiver)
+  Register registers[] = {edx, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // ecx : the object to spread
+  Register registers[] = {edi, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // edi : the target to call
+  // edx : the arguments list
+  Register registers[] = {edi, edx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // edx : the new target
+  // ecx : arguments list length (untagged)
+  // On the stack : arguments list (FixedArray)
+  Register registers[] = {edi, edx, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments
+  // edx : the new target
+  // ecx : start index (to support rest parameters)
+  // edi : the target to call
+  Register registers[] = {edi, edx, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments (on the stack, not including receiver)
+  // edi : the target to call
+  // edx : the new target
+  // ecx : the object to spread
+  Register registers[] = {edi, edx, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // edi : the target to call
+  // edx : the new target
+  // ecx : the arguments list
+  Register registers[] = {edi, edx, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructStubDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // eax : number of arguments
+  // edx : the new target
+  // edi : the target to call
+  // ecx : allocation site or undefined
+  // TODO(jgruber): Remove the unused allocation site parameter.
+  Register registers[] = {edi, edx, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void AbortDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {edx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CompareDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {edx, eax};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void Compare_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {edx, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOpDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {edx, eax};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {edx, eax, ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ApiCallbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      edx,  // kApiFunctionAddress
+      ecx,  // kArgc
+      eax,  // kCallData
+      edi,  // kHolder
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterDispatchDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      eax,  // argument count (not including receiver)
+      ecx,  // address of first argument
+      edi   // the target callable to be call
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      eax,  // argument count (not including receiver)
+      ecx,  // address of first argument
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ResumeGeneratorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      eax,  // the value to pass to the generator
+      edx   // the JSGeneratorObject to resume
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      eax,  // loaded new FP
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  data->InitializePlatformSpecific(0, nullptr);
+}
+
+void WasmFloat32ToNumberDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // Work around using eax, whose register code is 0, and leads to the FP
+  // parameter being passed via xmm0, which is not allocatable on ia32.
+  Register registers[] = {ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void WasmFloat64ToNumberDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // Work around using eax, whose register code is 0, and leads to the FP
+  // parameter being passed via xmm0, which is not allocatable on ia32.
+  Register registers[] = {ecx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_IA32
diff --git a/src/codegen/ia32/macro-assembler-ia32.cc b/src/codegen/ia32/macro-assembler-ia32.cc
index 0863b9e828..ff856dc8fc 100644
--- a/src/codegen/ia32/macro-assembler-ia32.cc
+++ b/src/codegen/ia32/macro-assembler-ia32.cc
@@ -19,7 +19,7 @@
 #include "src/codegen/external-reference.h"
 #include "src/codegen/ia32/assembler-ia32.h"
 #include "src/codegen/ia32/register-ia32.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/label.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/register.h"
diff --git a/src/codegen/interface-descriptors-inl.h b/src/codegen/interface-descriptors-inl.h
deleted file mode 100644
index d352626f52..0000000000
--- a/src/codegen/interface-descriptors-inl.h
+++ /dev/null
@@ -1,471 +0,0 @@
-// Copyright 2021 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_CODEGEN_INTERFACE_DESCRIPTORS_INL_H_
-#define V8_CODEGEN_INTERFACE_DESCRIPTORS_INL_H_
-
-#include <utility>
-
-#include "src/codegen/interface-descriptors.h"
-#include "src/codegen/register-arch.h"
-
-#if V8_TARGET_ARCH_X64
-#include "src/codegen/x64/interface-descriptors-x64-inl.h"
-#elif V8_TARGET_ARCH_ARM64
-#include "src/codegen/arm64/interface-descriptors-arm64-inl.h"
-#elif V8_TARGET_ARCH_IA32
-#include "src/codegen/ia32/interface-descriptors-ia32-inl.h"
-#elif V8_TARGET_ARCH_ARM
-#include "src/codegen/arm/interface-descriptors-arm-inl.h"
-#else
-#error Unsupported target architecture.
-#endif
-
-namespace v8 {
-namespace internal {
-
-// static
-constexpr std::array<Register, kJSBuiltinRegisterParams>
-CallInterfaceDescriptor::DefaultJSRegisterArray() {
-  return RegisterArray(
-      kJavaScriptCallTargetRegister, kJavaScriptCallNewTargetRegister,
-      kJavaScriptCallArgCountRegister, kJavaScriptCallExtraArg1Register);
-}
-
-// static
-template <typename DerivedDescriptor>
-constexpr auto StaticCallInterfaceDescriptor<DerivedDescriptor>::registers() {
-  return CallInterfaceDescriptor::DefaultRegisterArray();
-}
-
-// static
-template <typename DerivedDescriptor>
-constexpr auto StaticJSCallInterfaceDescriptor<DerivedDescriptor>::registers() {
-  return CallInterfaceDescriptor::DefaultJSRegisterArray();
-}
-
-template <typename DerivedDescriptor>
-void StaticCallInterfaceDescriptor<DerivedDescriptor>::Initialize(
-    CallInterfaceDescriptorData* data) {
-  // Static local copy of the Registers array, for platform-specific
-  // initialization
-  static auto registers = DerivedDescriptor::registers();
-
-  // The passed pointer should be a modifiable pointer to our own data.
-  DCHECK_EQ(data, this->data());
-  DCHECK(!data->IsInitialized());
-
-  if (DerivedDescriptor::kRestrictAllocatableRegisters) {
-    data->RestrictAllocatableRegisters(registers.data(), registers.size());
-  }
-
-  data->InitializeRegisters(
-      DerivedDescriptor::flags(), DerivedDescriptor::kReturnCount,
-      DerivedDescriptor::GetParameterCount(),
-      DerivedDescriptor::kStackArgumentOrder,
-      DerivedDescriptor::GetRegisterParameterCount(), registers.data());
-
-  // InitializeTypes is customizable by the DerivedDescriptor subclass.
-  DerivedDescriptor::InitializeTypes(data);
-
-  DCHECK(data->IsInitialized());
-  DCHECK(this->CheckFloatingPointParameters(data));
-}
-
-// static
-template <typename DerivedDescriptor>
-constexpr int
-StaticCallInterfaceDescriptor<DerivedDescriptor>::GetReturnCount() {
-  static_assert(
-      DerivedDescriptor::kReturnCount >= 0,
-      "DerivedDescriptor subclass should override return count with a value "
-      "that is greater than 0");
-
-  return DerivedDescriptor::kReturnCount;
-}
-
-// static
-template <typename DerivedDescriptor>
-constexpr int
-StaticCallInterfaceDescriptor<DerivedDescriptor>::GetParameterCount() {
-  static_assert(
-      DerivedDescriptor::kParameterCount >= 0,
-      "DerivedDescriptor subclass should override parameter count with a "
-      "value that is greater than 0");
-
-  return DerivedDescriptor::kParameterCount;
-}
-
-namespace detail {
-
-// Helper trait for statically checking if a type is a std::array<Register,N>.
-template <typename T>
-struct IsRegisterArray : std::false_type {};
-template <int i>
-struct IsRegisterArray<std::array<Register, i>> : std::true_type {};
-template <>
-struct IsRegisterArray<EmptyRegisterArray> : std::true_type {};
-
-// Helper for finding the index of the first invalid register in a register
-// array.
-template <size_t N, size_t Index>
-struct FirstInvalidRegisterHelper {
-  static constexpr int Call(std::array<Register, N> regs) {
-    if (!std::get<Index>(regs).is_valid()) {
-      // All registers after the first invalid one have to also be invalid (this
-      // DCHECK will be checked recursively).
-      CONSTEXPR_DCHECK((FirstInvalidRegisterHelper<N, Index + 1>::Call(regs)) ==
-                       Index + 1);
-      return Index;
-    }
-    return FirstInvalidRegisterHelper<N, Index + 1>::Call(regs);
-  }
-};
-template <size_t N>
-struct FirstInvalidRegisterHelper<N, N> {
-  static constexpr int Call(std::array<Register, N> regs) { return N; }
-};
-template <size_t N, size_t Index = 0>
-constexpr size_t FirstInvalidRegister(std::array<Register, N> regs) {
-  return FirstInvalidRegisterHelper<N, 0>::Call(regs);
-}
-constexpr size_t FirstInvalidRegister(EmptyRegisterArray regs) { return 0; }
-
-}  // namespace detail
-
-// static
-template <typename DerivedDescriptor>
-constexpr int
-StaticCallInterfaceDescriptor<DerivedDescriptor>::GetRegisterParameterCount() {
-  static_assert(
-      detail::IsRegisterArray<decltype(DerivedDescriptor::registers())>::value,
-      "DerivedDescriptor subclass should define a registers() function "
-      "returning a std::array<Register>");
-
-  // The register parameter count is the minimum of:
-  //   1. The number of named parameters in the descriptor, and
-  //   2. The number of valid registers the descriptor provides with its
-  //      registers() function, e.g. for {rax, rbx, no_reg} this number is 2.
-  //   3. The maximum number of register parameters allowed (
-  //      kMaxBuiltinRegisterParams for most builtins,
-  //      kMaxTFSBuiltinRegisterParams for TFS builtins, customizable by the
-  //      subclass otherwise).
-  return std::min<int>({DerivedDescriptor::GetParameterCount(),
-                        static_cast<int>(detail::FirstInvalidRegister(
-                            DerivedDescriptor::registers())),
-                        DerivedDescriptor::kMaxRegisterParams});
-}
-
-// static
-template <typename DerivedDescriptor>
-constexpr int
-StaticCallInterfaceDescriptor<DerivedDescriptor>::GetStackParameterCount() {
-  return DerivedDescriptor::GetParameterCount() -
-         DerivedDescriptor::GetRegisterParameterCount();
-}
-
-// static
-constexpr Register FastNewObjectDescriptor::TargetRegister() {
-  return kJSFunctionRegister;
-}
-
-// static
-constexpr Register FastNewObjectDescriptor::NewTargetRegister() {
-  return kJavaScriptCallNewTargetRegister;
-}
-
-// static
-constexpr Register ApiGetterDescriptor::ReceiverRegister() {
-  return LoadDescriptor::ReceiverRegister();
-}
-
-// static
-constexpr Register LoadGlobalNoFeedbackDescriptor::ICKindRegister() {
-  return LoadDescriptor::SlotRegister();
-}
-
-// static
-constexpr Register LoadNoFeedbackDescriptor::ICKindRegister() {
-  return LoadGlobalNoFeedbackDescriptor::ICKindRegister();
-}
-
-#if V8_TARGET_ARCH_IA32
-// On ia32, LoadWithVectorDescriptor passes vector on the stack and thus we
-// need to choose a new register here.
-// static
-constexpr Register LoadGlobalWithVectorDescriptor::VectorRegister() {
-  STATIC_ASSERT(!LoadWithVectorDescriptor::VectorRegister().is_valid());
-  return LoadDescriptor::ReceiverRegister();
-}
-#else
-// static
-constexpr Register LoadGlobalWithVectorDescriptor::VectorRegister() {
-  return LoadWithVectorDescriptor::VectorRegister();
-}
-#endif
-
-// static
-constexpr auto LoadDescriptor::registers() {
-  return RegisterArray(ReceiverRegister(), NameRegister(), SlotRegister());
-}
-
-// static
-constexpr auto LoadBaselineDescriptor::registers() {
-  return LoadDescriptor::registers();
-}
-
-// static
-constexpr auto LoadGlobalDescriptor::registers() {
-  return RegisterArray(LoadDescriptor::NameRegister(),
-                       LoadDescriptor::SlotRegister());
-}
-
-// static
-constexpr auto LoadGlobalBaselineDescriptor::registers() {
-  return LoadGlobalDescriptor::registers();
-}
-
-// static
-constexpr auto StoreDescriptor::registers() {
-  return RegisterArray(ReceiverRegister(), NameRegister(), ValueRegister(),
-                       SlotRegister());
-}
-
-// static
-constexpr auto StoreBaselineDescriptor::registers() {
-  return StoreDescriptor::registers();
-}
-
-// static
-constexpr auto StoreGlobalDescriptor::registers() {
-  return RegisterArray(StoreDescriptor::NameRegister(),
-                       StoreDescriptor::ValueRegister(),
-                       StoreDescriptor::SlotRegister());
-}
-
-// static
-constexpr auto StoreGlobalBaselineDescriptor::registers() {
-  return StoreGlobalDescriptor::registers();
-}
-
-// static
-constexpr auto LoadWithReceiverBaselineDescriptor::registers() {
-  return RegisterArray(
-      LoadDescriptor::ReceiverRegister(),
-      LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister(),
-      LoadDescriptor::NameRegister(), LoadDescriptor::SlotRegister());
-}
-
-// static
-constexpr auto BaselineOutOfLinePrologueDescriptor::registers() {
-  // TODO(v8:11421): Implement on other platforms.
-#if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_IA32 || \
-    V8_TARGET_ARCH_ARM
-  return RegisterArray(
-      kContextRegister, kJSFunctionRegister, kJavaScriptCallArgCountRegister,
-      kJavaScriptCallExtraArg1Register, kJavaScriptCallNewTargetRegister,
-      kInterpreterBytecodeArrayRegister);
-#else
-  return DefaultRegisterArray();
-#endif
-}
-
-// static
-constexpr auto BaselineLeaveFrameDescriptor::registers() {
-  // TODO(v8:11421): Implement on other platforms.
-#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || \
-    V8_TARGET_ARCH_ARM
-  return RegisterArray(ParamsSizeRegister(), WeightRegister());
-#else
-  return DefaultRegisterArray();
-#endif
-}
-
-// static
-constexpr auto VoidDescriptor::registers() { return RegisterArray(); }
-
-// static
-constexpr auto AllocateDescriptor::registers() {
-  return RegisterArray(kAllocateSizeRegister);
-}
-
-// static
-constexpr auto CEntry1ArgvOnStackDescriptor::registers() {
-  return RegisterArray(kRuntimeCallArgCountRegister,
-                       kRuntimeCallFunctionRegister);
-}
-
-// static
-constexpr auto InterpreterCEntry1Descriptor::registers() {
-  return RegisterArray(kRuntimeCallArgCountRegister, kRuntimeCallArgvRegister,
-                       kRuntimeCallFunctionRegister);
-}
-
-// static
-constexpr auto InterpreterCEntry2Descriptor::registers() {
-  return RegisterArray(kRuntimeCallArgCountRegister, kRuntimeCallArgvRegister,
-                       kRuntimeCallFunctionRegister);
-}
-
-// static
-constexpr auto FastNewObjectDescriptor::registers() {
-  return RegisterArray(TargetRegister(), NewTargetRegister());
-}
-
-// static
-constexpr auto TailCallOptimizedCodeSlotDescriptor::registers() {
-  return RegisterArray(kJavaScriptCallCodeStartRegister);
-}
-
-// static
-constexpr auto LoadNoFeedbackDescriptor::registers() {
-  return RegisterArray(LoadDescriptor::ReceiverRegister(),
-                       LoadDescriptor::NameRegister(), ICKindRegister());
-}
-
-// static
-constexpr auto LoadGlobalNoFeedbackDescriptor::registers() {
-  return RegisterArray(LoadDescriptor::NameRegister(), ICKindRegister());
-}
-
-// static
-constexpr auto LoadGlobalWithVectorDescriptor::registers() {
-  return RegisterArray(LoadDescriptor::NameRegister(),
-                       LoadDescriptor::SlotRegister(), VectorRegister());
-}
-
-// static
-constexpr auto LoadWithReceiverAndVectorDescriptor::registers() {
-  return RegisterArray(
-      LoadDescriptor::ReceiverRegister(), LookupStartObjectRegister(),
-      LoadDescriptor::NameRegister(), LoadDescriptor::SlotRegister(),
-      LoadWithVectorDescriptor::VectorRegister());
-}
-
-// static
-constexpr auto StoreGlobalWithVectorDescriptor::registers() {
-  return RegisterArray(StoreDescriptor::NameRegister(),
-                       StoreDescriptor::ValueRegister(),
-                       StoreDescriptor::SlotRegister(),
-                       StoreWithVectorDescriptor::VectorRegister());
-}
-
-// static
-constexpr auto StoreTransitionDescriptor::registers() {
-  return RegisterArray(StoreDescriptor::ReceiverRegister(),
-                       StoreDescriptor::NameRegister(), MapRegister(),
-                       StoreDescriptor::ValueRegister(),
-                       StoreDescriptor::SlotRegister(),
-                       StoreWithVectorDescriptor::VectorRegister());
-}
-
-// static
-constexpr auto TypeConversionDescriptor::registers() {
-  return RegisterArray(ArgumentRegister());
-}
-
-// static
-constexpr auto TypeConversionNoContextDescriptor::registers() {
-  return RegisterArray(TypeConversionDescriptor::ArgumentRegister());
-}
-
-// static
-constexpr auto SingleParameterOnStackDescriptor::registers() {
-  return RegisterArray();
-}
-
-// static
-constexpr auto AsyncFunctionStackParameterDescriptor::registers() {
-  return RegisterArray();
-}
-
-// static
-constexpr auto GetIteratorStackParameterDescriptor::registers() {
-  return RegisterArray();
-}
-
-// static
-constexpr auto LoadWithVectorDescriptor::registers() {
-  return RegisterArray(LoadDescriptor::ReceiverRegister(),
-                       LoadDescriptor::NameRegister(),
-                       LoadDescriptor::SlotRegister(), VectorRegister());
-}
-
-// static
-constexpr auto StoreWithVectorDescriptor::registers() {
-  return RegisterArray(StoreDescriptor::ReceiverRegister(),
-                       StoreDescriptor::NameRegister(),
-                       StoreDescriptor::ValueRegister(),
-                       StoreDescriptor::SlotRegister(), VectorRegister());
-}
-
-// static
-constexpr auto ApiGetterDescriptor::registers() {
-  return RegisterArray(ReceiverRegister(), HolderRegister(),
-                       CallbackRegister());
-}
-
-// static
-constexpr auto ContextOnlyDescriptor::registers() { return RegisterArray(); }
-
-// static
-constexpr auto NoContextDescriptor::registers() { return RegisterArray(); }
-
-// static
-constexpr auto GrowArrayElementsDescriptor::registers() {
-  return RegisterArray(ObjectRegister(), KeyRegister());
-}
-
-// static
-constexpr auto ArrayNArgumentsConstructorDescriptor::registers() {
-  // Keep the arguments on the same registers as they were in
-  // ArrayConstructorDescriptor to avoid unnecessary register moves.
-  // kFunction, kAllocationSite, kActualArgumentsCount
-  return RegisterArray(kJavaScriptCallTargetRegister,
-                       kJavaScriptCallExtraArg1Register,
-                       kJavaScriptCallArgCountRegister);
-}
-
-// static
-constexpr auto ArrayNoArgumentConstructorDescriptor::registers() {
-  // This descriptor must use the same set of registers as the
-  // ArrayNArgumentsConstructorDescriptor.
-  return ArrayNArgumentsConstructorDescriptor::registers();
-}
-
-// static
-constexpr auto ArraySingleArgumentConstructorDescriptor::registers() {
-  // This descriptor must use the same set of registers as the
-  // ArrayNArgumentsConstructorDescriptor.
-  return ArrayNArgumentsConstructorDescriptor::registers();
-}
-
-// static
-// static
-constexpr Register RunMicrotasksDescriptor::MicrotaskQueueRegister() {
-  return GetRegisterParameter(0);
-}
-
-#define DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER(Name, DescriptorName) \
-  template <>                                                         \
-  struct CallInterfaceDescriptorFor<Builtins::k##Name> {              \
-    using type = DescriptorName##Descriptor;                          \
-  };
-BUILTIN_LIST(IGNORE_BUILTIN, IGNORE_BUILTIN,
-             /*TFC*/ DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER, IGNORE_BUILTIN,
-             /*TFH*/ DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER, IGNORE_BUILTIN,
-             /*ASM*/ DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER)
-#undef DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER
-#define DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER(Name, ...) \
-  template <>                                              \
-  struct CallInterfaceDescriptorFor<Builtins::k##Name> {   \
-    using type = Name##Descriptor;                         \
-  };
-BUILTIN_LIST_TFS(DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER)
-#undef DEFINE_STATIC_BUILTIN_DESCRIPTOR_GETTER
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_CODEGEN_INTERFACE_DESCRIPTORS_INL_H_
diff --git a/src/codegen/interface-descriptors.cc b/src/codegen/interface-descriptors.cc
index d6d7b0dd0a..920aea63d7 100644
--- a/src/codegen/interface-descriptors.cc
+++ b/src/codegen/interface-descriptors.cc
@@ -4,48 +4,49 @@
 
 #include "src/codegen/interface-descriptors.h"
 
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 
 namespace v8 {
 namespace internal {
 
-void CallInterfaceDescriptorData::InitializeRegisters(
-    Flags flags, int return_count, int parameter_count,
-    StackArgumentOrder stack_order, int register_parameter_count,
-    const Register* registers) {
-  DCHECK(!IsInitializedTypes());
+void CallInterfaceDescriptorData::InitializePlatformSpecific(
+    int register_parameter_count, const Register* registers) {
+  DCHECK(!IsInitializedPlatformIndependent());
+
+  register_param_count_ = register_parameter_count;
 
+  // UBSan doesn't like creating zero-length arrays.
+  if (register_parameter_count == 0) return;
+
+  // InterfaceDescriptor owns a copy of the registers array.
+  register_params_ = NewArray<Register>(register_parameter_count, no_reg);
+  for (int i = 0; i < register_parameter_count; i++) {
+    // The value of the root register must be reserved, thus any uses
+    // within the calling convention are disallowed.
 #ifdef DEBUG
-  {
-    // Make sure that the registers are all valid, and don't alias each other.
-    RegList reglist = 0;
-    for (int i = 0; i < register_parameter_count; ++i) {
-      Register reg = registers[i];
-      DCHECK(reg.is_valid());
-      DCHECK_EQ(reglist & reg.bit(), 0);
-      DCHECK_NE(reg, kRootRegister);
+    CHECK_NE(registers[i], kRootRegister);
 #ifdef V8_COMPRESS_POINTERS_IN_SHARED_CAGE
-      DCHECK_NE(reg, kPtrComprCageBaseRegister);
+    CHECK_NE(registers[i], kPtrComprCageBaseRegister);
 #endif
-      reglist = CombineRegLists(reglist, reg.bit());
+    // Check for duplicated registers.
+    for (int j = i + 1; j < register_parameter_count; j++) {
+      CHECK_NE(registers[i], registers[j]);
     }
-  }
 #endif
+    register_params_[i] = registers[i];
+  }
+}
+
+void CallInterfaceDescriptorData::InitializePlatformIndependent(
+    Flags flags, int return_count, int parameter_count,
+    const MachineType* machine_types, int machine_types_length,
+    StackArgumentOrder stack_order) {
+  DCHECK(IsInitializedPlatformSpecific());
 
   flags_ = flags;
   stack_order_ = stack_order;
   return_count_ = return_count;
   param_count_ = parameter_count;
-  register_param_count_ = register_parameter_count;
-
-  // The caller owns the the registers array, so we just set the pointer.
-  register_params_ = registers;
-}
-
-void CallInterfaceDescriptorData::InitializeTypes(
-    const MachineType* machine_types, int machine_types_length) {
-  DCHECK(IsInitializedRegisters());
   const int types_length = return_count_ + param_count_;
 
   // Machine types are either fully initialized or null.
@@ -76,6 +77,7 @@ bool CallInterfaceDescriptorData::AllStackParametersAreTagged() const {
 void CallInterfaceDescriptorData::Reset() {
   delete[] machine_types_;
   machine_types_ = nullptr;
+  delete[] register_params_;
   register_params_ = nullptr;
 }
 
@@ -103,6 +105,27 @@ void CallDescriptors::TearDown() {
   }
 }
 
+void CallInterfaceDescriptor::JSDefaultInitializePlatformSpecific(
+    CallInterfaceDescriptorData* data, int non_js_register_parameter_count) {
+  DCHECK_LE(static_cast<unsigned>(non_js_register_parameter_count), 1);
+
+  // 3 is for kTarget, kNewTarget and kActualArgumentsCount
+  int register_parameter_count = 3 + non_js_register_parameter_count;
+
+  DCHECK(!AreAliased(
+      kJavaScriptCallTargetRegister, kJavaScriptCallNewTargetRegister,
+      kJavaScriptCallArgCountRegister, kJavaScriptCallExtraArg1Register));
+
+  const Register default_js_stub_registers[] = {
+      kJavaScriptCallTargetRegister, kJavaScriptCallNewTargetRegister,
+      kJavaScriptCallArgCountRegister, kJavaScriptCallExtraArg1Register};
+
+  CHECK_LE(static_cast<size_t>(register_parameter_count),
+           arraysize(default_js_stub_registers));
+  data->InitializePlatformSpecific(register_parameter_count,
+                                   default_js_stub_registers);
+}
+
 const char* CallInterfaceDescriptor::DebugName() const {
   CallDescriptors::Key key = CallDescriptors::GetKey(data_);
   switch (key) {
@@ -123,5 +146,487 @@ bool CallInterfaceDescriptor::IsValidFloatParameterRegister(Register reg) {
 }
 #endif
 
+void VoidDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  data->InitializePlatformSpecific(0, nullptr);
+}
+
+void AllocateDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {kAllocateSizeRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CEntry1ArgvOnStackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {kRuntimeCallArgCountRegister,
+                          kRuntimeCallFunctionRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+namespace {
+
+void InterpreterCEntryDescriptor_InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {kRuntimeCallArgCountRegister,
+                          kRuntimeCallArgvRegister,
+                          kRuntimeCallFunctionRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+}  // namespace
+
+void InterpreterCEntry1Descriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);
+}
+
+void InterpreterCEntry2Descriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  InterpreterCEntryDescriptor_InitializePlatformSpecific(data);
+}
+
+void FastNewObjectDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {TargetRegister(), NewTargetRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+const Register FastNewObjectDescriptor::TargetRegister() {
+  return kJSFunctionRegister;
+}
+
+const Register FastNewObjectDescriptor::NewTargetRegister() {
+  return kJavaScriptCallNewTargetRegister;
+}
+
+void TailCallOptimizedCodeSlotDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {kJavaScriptCallCodeStartRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LoadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ReceiverRegister(), NameRegister(), SlotRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LoadBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {LoadDescriptor::ReceiverRegister(),
+                          LoadDescriptor::NameRegister(),
+                          LoadDescriptor::SlotRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LoadNoFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ReceiverRegister(), NameRegister(), ICKindRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LoadGlobalDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {NameRegister(), SlotRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LoadGlobalBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {LoadGlobalDescriptor::NameRegister(),
+                          LoadGlobalDescriptor::SlotRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LookupBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void LoadGlobalNoFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {NameRegister(), ICKindRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LoadGlobalWithVectorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {NameRegister(), SlotRegister(), VectorRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void LoadWithReceiverAndVectorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DCHECK(!AreAliased(ReceiverRegister(), LookupStartObjectRegister(),
+                     NameRegister(), SlotRegister(), VectorRegister()));
+  Register registers[] = {ReceiverRegister(), LookupStartObjectRegister(),
+                          NameRegister(), SlotRegister(), VectorRegister()};
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void LoadWithReceiverBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      LoadWithReceiverAndVectorDescriptor::ReceiverRegister(),
+      LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister(),
+      LoadWithReceiverAndVectorDescriptor::NameRegister(),
+      LoadWithReceiverAndVectorDescriptor::SlotRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void StoreGlobalDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {NameRegister(), ValueRegister(), SlotRegister()};
+
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void StoreGlobalBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {StoreGlobalDescriptor::NameRegister(),
+                          StoreGlobalDescriptor::ValueRegister(),
+                          StoreGlobalDescriptor::SlotRegister()};
+
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void StoreGlobalWithVectorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {NameRegister(), ValueRegister(), SlotRegister(),
+                          VectorRegister()};
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void StoreDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ReceiverRegister(), NameRegister(), ValueRegister(),
+                          SlotRegister()};
+
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void StoreBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      StoreDescriptor::ReceiverRegister(), StoreDescriptor::NameRegister(),
+      StoreDescriptor::ValueRegister(), StoreDescriptor::SlotRegister()};
+
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void StoreTransitionDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      ReceiverRegister(), NameRegister(), MapRegister(),
+      ValueRegister(),    SlotRegister(), VectorRegister(),
+  };
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void BaselineOutOfLinePrologueDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:11421): Implement on other platforms.
+#if V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || V8_TARGET_ARCH_IA32 || \
+    V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_RISCV64
+  Register registers[] = {kContextRegister,
+                          kJSFunctionRegister,
+                          kJavaScriptCallArgCountRegister,
+                          kJavaScriptCallExtraArg1Register,
+                          kJavaScriptCallNewTargetRegister,
+                          kInterpreterBytecodeArrayRegister};
+  data->InitializePlatformSpecific(kParameterCount - kStackArgumentsCount,
+                                   registers);
+#else
+  InitializePlatformUnimplemented(data, kParameterCount);
+#endif
+}
+
+void BaselineLeaveFrameDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // TODO(v8:11421): Implement on other platforms.
+#if V8_TARGET_ARCH_IA32 || V8_TARGET_ARCH_X64 || V8_TARGET_ARCH_ARM64 || \
+    V8_TARGET_ARCH_ARM || V8_TARGET_ARCH_RISCV64
+  Register registers[] = {ParamsSizeRegister(), WeightRegister()};
+  data->InitializePlatformSpecific(kParameterCount, registers);
+#else
+  InitializePlatformUnimplemented(data, kParameterCount);
+#endif
+}
+
+void StringAtDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void StringAtAsStringDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void StringSubstringDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void TypeConversionDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ArgumentRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void TypeConversionNoContextDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {TypeConversionDescriptor::ArgumentRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void TypeConversion_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void SingleParameterOnStackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  data->InitializePlatformSpecific(0, nullptr);
+}
+
+void AsyncFunctionStackParameterDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  data->InitializePlatformSpecific(0, nullptr);
+}
+
+void GetIteratorStackParameterDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  data->InitializePlatformSpecific(0, nullptr);
+}
+
+void LoadWithVectorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ReceiverRegister(), NameRegister(), SlotRegister(),
+                          VectorRegister()};
+  // TODO(jgruber): This DCHECK could be enabled if RegisterBase::ListOf were
+  // to allow no_reg entries.
+  // DCHECK(!AreAliased(ReceiverRegister(), NameRegister(), SlotRegister(),
+  //                    VectorRegister(), kRootRegister));
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+void StoreWithVectorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ReceiverRegister(), NameRegister(), ValueRegister(),
+                          SlotRegister(), VectorRegister()};
+  // TODO(jgruber): This DCHECK could be enabled if RegisterBase::ListOf were
+  // to allow no_reg entries.
+  // DCHECK(!AreAliased(ReceiverRegister(), NameRegister(), kRootRegister));
+  int len = arraysize(registers) - kStackArgumentsCount;
+  data->InitializePlatformSpecific(len, registers);
+}
+
+const Register ApiGetterDescriptor::ReceiverRegister() {
+  return LoadDescriptor::ReceiverRegister();
+}
+
+void ApiGetterDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ReceiverRegister(), HolderRegister(),
+                          CallbackRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ContextOnlyDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  data->InitializePlatformSpecific(0, nullptr);
+}
+
+void NoContextDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  data->InitializePlatformSpecific(0, nullptr);
+}
+
+void GrowArrayElementsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {ObjectRegister(), KeyRegister()};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ArrayNoArgumentConstructorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // This descriptor must use the same set of registers as the
+  // ArrayNArgumentsConstructorDescriptor.
+  ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(data);
+}
+
+void ArraySingleArgumentConstructorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // This descriptor must use the same set of registers as the
+  // ArrayNArgumentsConstructorDescriptor.
+  ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(data);
+}
+
+void ArrayNArgumentsConstructorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // Keep the arguments on the same registers as they were in
+  // ArrayConstructorDescriptor to avoid unnecessary register moves.
+  // kFunction, kAllocationSite, kActualArgumentsCount
+  Register registers[] = {kJavaScriptCallTargetRegister,
+                          kJavaScriptCallExtraArg1Register,
+                          kJavaScriptCallArgCountRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+#if !V8_TARGET_ARCH_IA32
+// We need a custom descriptor on ia32 to avoid using xmm0.
+void WasmFloat32ToNumberDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+// We need a custom descriptor on ia32 to avoid using xmm0.
+void WasmFloat64ToNumberDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+#endif  // !V8_TARGET_ARCH_IA32
+
+#if !defined(V8_TARGET_ARCH_MIPS) && !defined(V8_TARGET_ARCH_MIPS64) && \
+    !defined(V8_TARGET_ARCH_RISCV64)
+void WasmI32AtomicWait32Descriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void WasmI64AtomicWait32Descriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data,
+                                    kParameterCount - kStackArgumentsCount);
+}
+#endif
+
+void CloneObjectWithVectorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void CloneObjectBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+// static
+Register RunMicrotasksDescriptor::MicrotaskQueueRegister() {
+  return CallDescriptors::call_descriptor_data(CallDescriptors::RunMicrotasks)
+      ->register_param(0);
+}
+
+void RunMicrotasksDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void I64ToBigIntDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void I32PairToBigIntDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void BigIntToI64Descriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void BigIntToI32PairDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void BinaryOp_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void CallTrampoline_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void CallTrampoline_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void CallWithArrayLike_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void CallWithSpread_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void CallWithSpread_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void ConstructWithArrayLike_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void ConstructWithSpread_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data,
+                                    kParameterCount - kStackArgumentsCount);
+}
+
+void ConstructWithSpread_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void Compare_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 4);
+}
+
+void UnaryOp_WithFeedbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 3);
+}
+
+void UnaryOp_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, 2);
+}
+
+void ForInPrepareDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void SuspendGeneratorBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
+void ResumeGeneratorBaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  DefaultInitializePlatformSpecific(data, kParameterCount);
+}
+
 }  // namespace internal
 }  // namespace v8
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index c788678e02..8d03907efc 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -7,7 +7,6 @@
 
 #include <memory>
 
-#include "src/base/logging.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/register-arch.h"
 #include "src/codegen/tnode.h"
@@ -152,21 +151,17 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   };
   using Flags = base::Flags<Flag>;
 
-  static constexpr int kUninitializedCount = -1;
-
   CallInterfaceDescriptorData() = default;
 
   CallInterfaceDescriptorData(const CallInterfaceDescriptorData&) = delete;
   CallInterfaceDescriptorData& operator=(const CallInterfaceDescriptorData&) =
       delete;
 
-  // The passed registers are owned by the caller, and their lifetime is
-  // expected to exceed that of this data. In practice, they are expected to
-  // be in a static local.
-  void InitializeRegisters(Flags flags, int return_count, int parameter_count,
-                           StackArgumentOrder stack_order,
-                           int register_parameter_count,
-                           const Register* registers);
+  // A copy of the passed in registers and param_representations is made
+  // and owned by the CallInterfaceDescriptorData.
+
+  void InitializePlatformSpecific(int register_parameter_count,
+                                  const Register* registers);
 
   // if machine_types is null, then an array of size
   // (return_count + parameter_count) will be created with
@@ -176,13 +171,17 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   // (return_count + parameter_count). Those members of the parameter array will
   // be initialized from {machine_types}, and the rest initialized to
   // MachineType::AnyTagged().
-  void InitializeTypes(const MachineType* machine_types,
-                       int machine_types_length);
+  void InitializePlatformIndependent(Flags flags, int return_count,
+                                     int parameter_count,
+                                     const MachineType* machine_types,
+                                     int machine_types_length,
+                                     StackArgumentOrder stack_order);
 
   void Reset();
 
   bool IsInitialized() const {
-    return IsInitializedRegisters() && IsInitializedTypes();
+    return IsInitializedPlatformSpecific() &&
+           IsInitializedPlatformIndependent();
   }
 
   Flags flags() const { return flags_; }
@@ -190,6 +189,7 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   int param_count() const { return param_count_; }
   int register_param_count() const { return register_param_count_; }
   Register register_param(int index) const { return register_params_[index]; }
+  Register* register_params() const { return register_params_; }
   MachineType return_type(int index) const {
     DCHECK_LT(index, return_count_);
     return machine_types_[index];
@@ -200,9 +200,9 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   }
   StackArgumentOrder stack_order() const { return stack_order_; }
 
-  void RestrictAllocatableRegisters(const Register* registers, size_t num) {
+  void RestrictAllocatableRegisters(const Register* registers, int num) {
     DCHECK_EQ(allocatable_registers_, 0);
-    for (size_t i = 0; i < num; ++i) {
+    for (int i = 0; i < num; ++i) {
       allocatable_registers_ |= registers[i].bit();
     }
     DCHECK_GT(NumRegs(allocatable_registers_), 0);
@@ -211,17 +211,17 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   RegList allocatable_registers() const { return allocatable_registers_; }
 
  private:
-  bool IsInitializedRegisters() const {
+  bool IsInitializedPlatformSpecific() const {
     const bool initialized =
-        return_count_ != kUninitializedCount &&
-        param_count_ != kUninitializedCount &&
-        (register_param_count_ == 0 || register_params_ != nullptr);
-    // Register initialization happens before type initialization.
+        (register_param_count_ == 0 && register_params_ == nullptr) ||
+        (register_param_count_ > 0 && register_params_ != nullptr);
+    // Platform-specific initialization happens before platform-independent.
     return initialized;
   }
-  bool IsInitializedTypes() const {
-    const bool initialized = machine_types_ != nullptr;
-    // Register initialization happens before type initialization.
+  bool IsInitializedPlatformIndependent() const {
+    const bool initialized =
+        return_count_ >= 0 && param_count_ >= 0 && machine_types_ != nullptr;
+    // Platform-specific initialization happens before platform-independent.
     return initialized;
   }
 
@@ -229,9 +229,9 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   bool AllStackParametersAreTagged() const;
 #endif  // DEBUG
 
-  int register_param_count_ = kUninitializedCount;
-  int return_count_ = kUninitializedCount;
-  int param_count_ = kUninitializedCount;
+  int register_param_count_ = -1;
+  int return_count_ = -1;
+  int param_count_ = -1;
   Flags flags_ = kNoFlags;
   StackArgumentOrder stack_order_ = StackArgumentOrder::kDefault;
 
@@ -242,10 +242,10 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptorData {
   // |registers_params_| defines registers that are used for parameter passing.
   // |machine_types_| defines machine types for resulting values and incomping
   // parameters.
-  // The register params array is owned by the caller, and it's expected that it
-  // is a static local stored in the caller function. The machine types are
-  // allocated dynamically by the InterfaceDescriptor and freed on destruction.
-  const Register* register_params_ = nullptr;
+  // Both arrays are allocated dynamically by the InterfaceDescriptor and
+  // freed on destruction. This is because static arrays cause creation of
+  // runtime static initializers which we don't want.
+  Register* register_params_ = nullptr;
   MachineType* machine_types_ = nullptr;
 };
 
@@ -278,35 +278,12 @@ class V8_EXPORT_PRIVATE CallDescriptors : public AllStatic {
       call_descriptor_data_[NUMBER_OF_DESCRIPTORS];
 };
 
-#if defined(V8_TARGET_ARCH_IA32)
-// To support all possible cases, we must limit the number of register args for
-// TFS builtins on ia32 to 3. Out of the 6 allocatable registers, esi is taken
-// as the context register and ebx is the root register. One register must
-// remain available to store the jump/call target. Thus 3 registers remain for
-// arguments. The reason this applies to TFS builtins specifically is because
-// this becomes relevant for builtins used as targets of Torque function
-// pointers (which must have a register available to store the target).
-// TODO(jgruber): Ideally we should just decrement kMaxBuiltinRegisterParams but
-// that comes with its own set of complications. It's possible, but requires
-// refactoring the calling convention of other existing stubs.
-constexpr int kMaxBuiltinRegisterParams = 4;
-constexpr int kMaxTFSBuiltinRegisterParams = 3;
-#else
-constexpr int kMaxBuiltinRegisterParams = 5;
-constexpr int kMaxTFSBuiltinRegisterParams = kMaxBuiltinRegisterParams;
-#endif
-STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
-constexpr int kJSBuiltinRegisterParams = 4;
-
-// Polymorphic base class for call interface descriptors, which defines getters
-// for the various descriptor properties via a runtime-loaded
-// CallInterfaceDescriptorData field.
 class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
  public:
   using Flags = CallInterfaceDescriptorData::Flags;
 
   CallInterfaceDescriptor() : data_(nullptr) {}
-  ~CallInterfaceDescriptor() = default;
+  virtual ~CallInterfaceDescriptor() = default;
 
   explicit CallInterfaceDescriptor(CallDescriptors::Key key)
       : data_(CallDescriptors::call_descriptor_data(key)) {}
@@ -356,9 +333,7 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
     return data()->stack_order();
   }
 
-  static constexpr inline Register ContextRegister() {
-    return kContextRegister;
-  }
+  static const Register ContextRegister();
 
   const char* DebugName() const;
 
@@ -369,13 +344,39 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
  protected:
   const CallInterfaceDescriptorData* data() const { return data_; }
 
-  // Helper for defining the default register set.
-  //
-  // Use auto for the return type to allow different architectures to have
-  // differently sized default register arrays.
-  static constexpr inline auto DefaultRegisterArray();
-  static constexpr inline std::array<Register, kJSBuiltinRegisterParams>
-  DefaultJSRegisterArray();
+  virtual void InitializePlatformSpecific(CallInterfaceDescriptorData* data) {
+    UNREACHABLE();
+  }
+
+  // Initializes |data| to an unspecified state, for platforms that haven't
+  // implemented a given builtin.
+  static void InitializePlatformUnimplemented(CallInterfaceDescriptorData* data,
+                                              int register_parameter_count) {
+    DefaultInitializePlatformSpecific(data,
+                                      std::min(register_parameter_count, 4));
+  }
+
+  virtual void InitializePlatformIndependent(
+      CallInterfaceDescriptorData* data) {
+    // Default descriptor configuration: one result, all parameters are passed
+    // in registers and all parameters have MachineType::AnyTagged() type.
+    data->InitializePlatformIndependent(
+        CallInterfaceDescriptorData::kNoFlags, 1, data->register_param_count(),
+        nullptr, 0, StackArgumentOrder::kDefault);
+  }
+
+  // Initializes |data| using the platform dependent default set of registers.
+  // It is intended to be used for TurboFan stubs when particular set of
+  // registers does not matter.
+  static void DefaultInitializePlatformSpecific(
+      CallInterfaceDescriptorData* data, int register_parameter_count);
+
+  // Initializes |data| using the platform dependent default set of registers
+  // for JavaScript-compatible calling convention.
+  // It is intended to be used for TurboFan stubs being called with JavaScript
+  // linkage + additional parameters on registers and stack.
+  static void JSDefaultInitializePlatformSpecific(
+      CallInterfaceDescriptorData* data, int non_js_register_parameter_count);
 
   // Checks if float parameters are not assigned invalid registers.
   bool CheckFloatingPointParameters(CallInterfaceDescriptorData* data) {
@@ -391,165 +392,105 @@ class V8_EXPORT_PRIVATE CallInterfaceDescriptor {
 
   bool IsValidFloatParameterRegister(Register reg);
 
- private:
-  const CallInterfaceDescriptorData* data_;
-};
-
-// CRTP base class for call interface descriptors, which defines static getters
-// for the various descriptor properties based on static values defined in the
-// subclass.
-template <typename DerivedDescriptor>
-class StaticCallInterfaceDescriptor : public CallInterfaceDescriptor {
- public:
-  // ===========================================================================
-  // The following are the descriptor's CRTP configuration points, overwritable
-  // by DerivedDescriptor.
-  static constexpr int kReturnCount =
-      CallInterfaceDescriptorData::kUninitializedCount;
-  static constexpr int kParameterCount =
-      CallInterfaceDescriptorData::kUninitializedCount;
-  static constexpr bool kNoContext = false;
-  static constexpr bool kAllowVarArgs = false;
-  static constexpr bool kNoStackScan = false;
-  static constexpr auto kStackArgumentOrder = StackArgumentOrder::kDefault;
-
-  // The set of registers available to the parameters, as a
-  // std::array<Register,N>. Can be larger or smaller than kParameterCount; if
-  // larger then any remaining registers are ignored; if smaller, any parameters
-  // after registers().size() will be stack registers.
-  //
-  // Defaults to CallInterfaceDescriptor::DefaultRegisterArray().
-  static constexpr inline auto registers();
-
-  // An additional limit on the number of register parameters allowed. This is
-  // here so that it can be overwritten to kMaxTFSBuiltinRegisterParams for TFS
-  // builtins, see comment on kMaxTFSBuiltinRegisterParams above.
-  static constexpr int kMaxRegisterParams = kMaxBuiltinRegisterParams;
-
-  // If set to true, the descriptor will restrict the set of allocatable
-  // registers to the set returned by registers(). Then, it is expected that
-  // the first kParameterCount registers() are the parameters of the builtin.
-  static constexpr bool kRestrictAllocatableRegisters = false;
-
-  // End of customization points.
-  // ===========================================================================
-
-  static constexpr inline Flags flags() {
-    return Flags((DerivedDescriptor::kNoContext
-                      ? CallInterfaceDescriptorData::kNoContext
-                      : 0) |
-                 (DerivedDescriptor::kAllowVarArgs
-                      ? CallInterfaceDescriptorData::kAllowVarArgs
-                      : 0) |
-                 (DerivedDescriptor::kNoStackScan
-                      ? CallInterfaceDescriptorData::kNoStackScan
-                      : 0));
-  }
-  static constexpr inline bool AllowVarArgs() {
-    return DerivedDescriptor::kAllowVarArgs;
-  }
-  static constexpr inline bool HasContextParameter() {
-    return !DerivedDescriptor::kNoContext;
-  }
-
-  static constexpr inline int GetReturnCount();
-  static constexpr inline int GetParameterCount();
-  static constexpr inline int GetRegisterParameterCount();
-  static constexpr inline int GetStackParameterCount();
-  static constexpr inline Register* GetRegisterData();
-
-  static constexpr inline Register GetRegisterParameter(int i) {
-    return DerivedDescriptor::registers()[i];
-  }
-
-  explicit StaticCallInterfaceDescriptor(CallDescriptors::Key key)
-      : CallInterfaceDescriptor(key) {}
-
  private:
   // {CallDescriptors} is allowed to call the private {Initialize} method.
   friend class CallDescriptors;
 
-  inline void Initialize(CallInterfaceDescriptorData* data);
+  const CallInterfaceDescriptorData* data_;
 
-  // Set up the types of the descriptor. This is a static function, so that it
-  // is overwritable by subclasses. By default, all parameters have
-  // MachineType::AnyTagged() type.
-  static void InitializeTypes(CallInterfaceDescriptorData* data) {
-    data->InitializeTypes(nullptr, 0);
+  void Initialize(CallInterfaceDescriptorData* data) {
+    // The passed pointer should be a modifiable pointer to our own data.
+    DCHECK_EQ(data, data_);
+    DCHECK(!data->IsInitialized());
+    InitializePlatformSpecific(data);
+    InitializePlatformIndependent(data);
+    DCHECK(data->IsInitialized());
+    DCHECK(CheckFloatingPointParameters(data));
   }
 };
 
-template <typename Descriptor>
-class StaticJSCallInterfaceDescriptor
-    : public StaticCallInterfaceDescriptor<Descriptor> {
- public:
-  static constexpr auto kStackArgumentOrder = StackArgumentOrder::kJS;
-  static constexpr inline auto registers();
-
-  using StaticCallInterfaceDescriptor<
-      Descriptor>::StaticCallInterfaceDescriptor;
-};
-
-template <Builtins::Name kBuiltin>
-struct CallInterfaceDescriptorFor;
-
-// Stub class replacing std::array<Register, 0>, as a workaround for MSVC's
-// https://github.com/microsoft/STL/issues/942
-struct EmptyRegisterArray {
-  Register* data() { return nullptr; }
-  size_t size() const { return 0; }
-  Register operator[](size_t i) const { UNREACHABLE(); }
-};
-
-// Helper method for defining an array of registers for the various
-// Descriptor::registers() methods.
-template <typename... Registers>
-constexpr std::array<Register, 1 + sizeof...(Registers)> RegisterArray(
-    Register first_reg, Registers... regs) {
-  return {first_reg, regs...};
-}
-constexpr EmptyRegisterArray RegisterArray() { return {}; }
-
-#define DECLARE_DESCRIPTOR_WITH_BASE(name, base)                  \
- public:                                                          \
-  /* StaticCallInterfaceDescriptor can call Initialize methods */ \
-  friend class StaticCallInterfaceDescriptor<name>;               \
-  explicit name() : base(key()) {}                                \
+#define DECLARE_DESCRIPTOR_WITH_BASE(name, base) \
+ public:                                         \
+  explicit name() : base(key()) {}               \
   static inline CallDescriptors::Key key();
 
-#define DECLARE_DEFAULT_DESCRIPTOR(name)                                  \
-  DECLARE_DESCRIPTOR_WITH_BASE(name, StaticCallInterfaceDescriptor)       \
-  static constexpr int kMaxRegisterParams = kMaxTFSBuiltinRegisterParams; \
-                                                                          \
- protected:                                                               \
-  explicit name(CallDescriptors::Key key)                                 \
-      : StaticCallInterfaceDescriptor(key) {}                             \
-                                                                          \
- public:
-
-#define DECLARE_JS_COMPATIBLE_DESCRIPTOR(name)                        \
-  DECLARE_DESCRIPTOR_WITH_BASE(name, StaticJSCallInterfaceDescriptor) \
- protected:                                                           \
-  explicit name(CallDescriptors::Key key)                             \
-      : StaticJSCallInterfaceDescriptor(key) {}                       \
-                                                                      \
- public:
-
-#define DEFINE_RESULT_AND_PARAMETERS(return_count, ...)   \
-  static constexpr int kReturnCount = return_count;       \
-  enum ParameterIndices {                                 \
-    __dummy = -1, /* to be able to pass zero arguments */ \
-    ##__VA_ARGS__,                                        \
-                                                          \
-    kParameterCount,                                      \
-    kContext = kParameterCount /* implicit parameter */   \
+#if defined(V8_TARGET_ARCH_IA32)
+// To support all possible cases, we must limit the number of register args for
+// TFS builtins on ia32 to 3. Out of the 6 allocatable registers, esi is taken
+// as the context register and ebx is the root register. One register must
+// remain available to store the jump/call target. Thus 3 registers remain for
+// arguments. The reason this applies to TFS builtins specifically is because
+// this becomes relevant for builtins used as targets of Torque function
+// pointers (which must have a register available to store the target).
+// TODO(jgruber): Ideally we should just decrement kMaxBuiltinRegisterParams but
+// that comes with its own set of complications. It's possible, but requires
+// refactoring the calling convention of other existing stubs.
+constexpr int kMaxBuiltinRegisterParams = 4;
+constexpr int kMaxTFSBuiltinRegisterParams = 3;
+#else
+constexpr int kMaxBuiltinRegisterParams = 5;
+constexpr int kMaxTFSBuiltinRegisterParams = kMaxBuiltinRegisterParams;
+#endif
+STATIC_ASSERT(kMaxTFSBuiltinRegisterParams <= kMaxBuiltinRegisterParams);
+
+#define DECLARE_DEFAULT_DESCRIPTOR(name, base)                                 \
+  DECLARE_DESCRIPTOR_WITH_BASE(name, base)                                     \
+ protected:                                                                    \
+  static const int kRegisterParams =                                           \
+      kParameterCount > kMaxTFSBuiltinRegisterParams                           \
+          ? kMaxTFSBuiltinRegisterParams                                       \
+          : kParameterCount;                                                   \
+  static const int kStackParams = kParameterCount - kRegisterParams;           \
+  void InitializePlatformSpecific(CallInterfaceDescriptorData* data)           \
+      override {                                                               \
+    DefaultInitializePlatformSpecific(data, kRegisterParams);                  \
+  }                                                                            \
+  void InitializePlatformIndependent(CallInterfaceDescriptorData* data)        \
+      override {                                                               \
+    data->InitializePlatformIndependent(Flags(kDescriptorFlags), kReturnCount, \
+                                        kParameterCount, nullptr, 0,           \
+                                        kStackArgumentOrder);                  \
+  }                                                                            \
+  name(CallDescriptors::Key key) : base(key) {}                                \
+                                                                               \
+ public:
+
+#define DECLARE_JS_COMPATIBLE_DESCRIPTOR(name, base,                        \
+                                         non_js_reg_parameters_count)       \
+  DECLARE_DESCRIPTOR_WITH_BASE(name, base)                                  \
+ protected:                                                                 \
+  void InitializePlatformSpecific(CallInterfaceDescriptorData* data)        \
+      override {                                                            \
+    JSDefaultInitializePlatformSpecific(data, non_js_reg_parameters_count); \
+  }                                                                         \
+  name(CallDescriptors::Key key) : base(key) {}                             \
+                                                                            \
+ public:
+
+#define DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(flags, stack_order,       \
+                                               return_count, ...)        \
+  static constexpr int kDescriptorFlags = flags;                         \
+  static constexpr int kReturnCount = return_count;                      \
+  static constexpr StackArgumentOrder kStackArgumentOrder = stack_order; \
+  enum ParameterIndices {                                                \
+    __dummy = -1, /* to be able to pass zero arguments */                \
+    ##__VA_ARGS__,                                                       \
+                                                                         \
+    kParameterCount,                                                     \
+    kContext = kParameterCount /* implicit parameter */                  \
   };
 
+#define DEFINE_RESULT_AND_PARAMETERS(return_count, ...)                    \
+  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                  \
+      CallInterfaceDescriptorData::kNoFlags, StackArgumentOrder::kDefault, \
+      return_count, ##__VA_ARGS__)
+
 // This is valid only for builtins that use EntryFrame, which does not scan
 // stack arguments on GC.
 #define DEFINE_PARAMETERS_ENTRY(...)                        \
-  static constexpr bool kNoContext = true;                  \
-  static constexpr bool kNoStackScan = true;                \
+  static constexpr int kDescriptorFlags =                   \
+      CallInterfaceDescriptorData::kNoContext |             \
+      CallInterfaceDescriptorData::kNoStackScan;            \
   static constexpr StackArgumentOrder kStackArgumentOrder = \
       StackArgumentOrder::kDefault;                         \
   static constexpr int kReturnCount = 1;                    \
@@ -560,31 +501,37 @@ constexpr EmptyRegisterArray RegisterArray() { return {}; }
     kParameterCount                                         \
   };
 
-#define DEFINE_PARAMETERS(...) DEFINE_RESULT_AND_PARAMETERS(1, ##__VA_ARGS__)
-
-#define DEFINE_PARAMETERS_NO_CONTEXT(...) \
-  DEFINE_PARAMETERS(__VA_ARGS__)          \
-  static constexpr bool kNoContext = true;
+#define DEFINE_PARAMETERS(...)                                                \
+  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                     \
+      CallInterfaceDescriptorData::kNoFlags, StackArgumentOrder::kDefault, 1, \
+      ##__VA_ARGS__)
 
-#define DEFINE_PARAMETERS_VARARGS(...)                      \
-  DEFINE_PARAMETERS(__VA_ARGS__)                            \
-  static constexpr bool kAllowVarArgs = true;               \
-  static constexpr StackArgumentOrder kStackArgumentOrder = \
-      StackArgumentOrder::kJS;
+#define DEFINE_PARAMETERS_NO_CONTEXT(...)                                    \
+  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                    \
+      CallInterfaceDescriptorData::kNoContext, StackArgumentOrder::kDefault, \
+      1, ##__VA_ARGS__)
 
-#define DEFINE_RESULT_AND_PARAMETERS_NO_CONTEXT(return_count, ...) \
-  DEFINE_RESULT_AND_PARAMETERS(return_count, ##__VA_ARGS__)        \
-  static constexpr bool kNoContext = true;
+#define DEFINE_PARAMETERS_VARARGS(...)                                        \
+  DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS(                                     \
+      CallInterfaceDescriptorData::kAllowVarArgs, StackArgumentOrder::kJS, 1, \
+      ##__VA_ARGS__)
 
-#define DEFINE_RESULT_AND_PARAMETER_TYPES(...)                                \
-  static void InitializeTypes(CallInterfaceDescriptorData* data) {            \
+#define DEFINE_RESULT_AND_PARAMETER_TYPES_WITH_FLAG(flag, ...)                \
+  void InitializePlatformIndependent(CallInterfaceDescriptorData* data)       \
+      override {                                                              \
     MachineType machine_types[] = {__VA_ARGS__};                              \
     static_assert(                                                            \
         kReturnCount + kParameterCount == arraysize(machine_types),           \
         "Parameter names definition is not consistent with parameter types"); \
-    data->InitializeTypes(machine_types, arraysize(machine_types));           \
+    data->InitializePlatformIndependent(                                      \
+        Flags(flag | kDescriptorFlags), kReturnCount, kParameterCount,        \
+        machine_types, arraysize(machine_types), kStackArgumentOrder);        \
   }
 
+#define DEFINE_RESULT_AND_PARAMETER_TYPES(...) \
+  DEFINE_RESULT_AND_PARAMETER_TYPES_WITH_FLAG( \
+      CallInterfaceDescriptorData::kNoFlags, __VA_ARGS__)
+
 #define DEFINE_PARAMETER_TYPES(...)                                        \
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged() /* result */, \
                                     ##__VA_ARGS__)
@@ -592,7 +539,8 @@ constexpr EmptyRegisterArray RegisterArray() { return {}; }
 // When the extra arguments described here are located in the stack, they are
 // just above the return address in the frame (first arguments).
 #define DEFINE_JS_PARAMETERS(...)                           \
-  static constexpr bool kAllowVarArgs = true;               \
+  static constexpr int kDescriptorFlags =                   \
+      CallInterfaceDescriptorData::kAllowVarArgs;           \
   static constexpr int kReturnCount = 1;                    \
   static constexpr StackArgumentOrder kStackArgumentOrder = \
       StackArgumentOrder::kJS;                              \
@@ -606,8 +554,9 @@ constexpr EmptyRegisterArray RegisterArray() { return {}; }
   };
 
 #define DEFINE_JS_PARAMETERS_NO_CONTEXT(...)                \
-  static constexpr bool kAllowVarArgs = true;               \
-  static constexpr bool kNoContext = true;                  \
+  static constexpr int kDescriptorFlags =                   \
+      CallInterfaceDescriptorData::kAllowVarArgs |          \
+      CallInterfaceDescriptorData::kNoContext;              \
   static constexpr int kReturnCount = 1;                    \
   static constexpr StackArgumentOrder kStackArgumentOrder = \
       StackArgumentOrder::kJS;                              \
@@ -625,22 +574,63 @@ constexpr EmptyRegisterArray RegisterArray() { return {}; }
                          MachineType::Int32(),     /* kActualArgumentsCount */ \
                          ##__VA_ARGS__)
 
-#define DECLARE_DESCRIPTOR(name)                                    \
-  DECLARE_DESCRIPTOR_WITH_BASE(name, StaticCallInterfaceDescriptor) \
- protected:                                                         \
-  explicit name(CallDescriptors::Key key)                           \
-      : StaticCallInterfaceDescriptor(key) {}                       \
-                                                                    \
+#define DECLARE_DESCRIPTOR(name, base)                                         \
+  DECLARE_DESCRIPTOR_WITH_BASE(name, base)                                     \
+ protected:                                                                    \
+  void InitializePlatformSpecific(CallInterfaceDescriptorData* data) override; \
+  name(CallDescriptors::Key key) : base(key) {}                                \
+                                                                               \
  public:
 
-class V8_EXPORT_PRIVATE VoidDescriptor
-    : public StaticCallInterfaceDescriptor<VoidDescriptor> {
+class V8_EXPORT_PRIVATE VoidDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS()
   DEFINE_PARAMETER_TYPES()
-  DECLARE_DESCRIPTOR(VoidDescriptor)
+  DECLARE_DESCRIPTOR(VoidDescriptor, CallInterfaceDescriptor)
+};
+
+// This class is subclassed by Torque-generated call interface descriptors.
+template <int return_count, int parameter_count, bool has_context_parameter>
+class TorqueInterfaceDescriptor : public CallInterfaceDescriptor {
+ public:
+  static constexpr int kDescriptorFlags =
+      has_context_parameter ? CallInterfaceDescriptorData::kNoFlags
+                            : CallInterfaceDescriptorData::kNoContext;
+  static constexpr int kParameterCount = parameter_count;
+  enum ParameterIndices { kContext = kParameterCount };
+  template <int i>
+  static ParameterIndices ParameterIndex() {
+    STATIC_ASSERT(0 <= i && i < kParameterCount);
+    return static_cast<ParameterIndices>(i);
+  }
+  static constexpr int kReturnCount = return_count;
+
+  using CallInterfaceDescriptor::CallInterfaceDescriptor;
 
-  static constexpr auto registers();
+ protected:
+  static const int kRegisterParams =
+      kParameterCount > kMaxTFSBuiltinRegisterParams
+          ? kMaxTFSBuiltinRegisterParams
+          : kParameterCount;
+  static const int kStackParams = kParameterCount - kRegisterParams;
+  virtual std::vector<MachineType> ReturnType() = 0;
+  virtual std::array<MachineType, kParameterCount> ParameterTypes() = 0;
+  void InitializePlatformSpecific(CallInterfaceDescriptorData* data) override {
+    DefaultInitializePlatformSpecific(data, kRegisterParams);
+  }
+  void InitializePlatformIndependent(
+      CallInterfaceDescriptorData* data) override {
+    std::vector<MachineType> machine_types = ReturnType();
+    DCHECK_EQ(kReturnCount, machine_types.size());
+    auto parameter_types = ParameterTypes();
+    machine_types.insert(machine_types.end(), parameter_types.begin(),
+                         parameter_types.end());
+    DCHECK_EQ(kReturnCount + kParameterCount, machine_types.size());
+    data->InitializePlatformIndependent(Flags(kDescriptorFlags), kReturnCount,
+                                        kParameterCount, machine_types.data(),
+                                        static_cast<int>(machine_types.size()),
+                                        StackArgumentOrder::kDefault);
+  }
 };
 
 // Dummy descriptor used to mark builtins that don't yet have their proper
@@ -656,171 +646,180 @@ using CCallDescriptor = VoidDescriptor;
 // here.
 using DeoptimizationEntryDescriptor = VoidDescriptor;
 
-class AllocateDescriptor
-    : public StaticCallInterfaceDescriptor<AllocateDescriptor> {
+class AllocateDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kRequestedSize)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::TaggedPointer(),  // result 1
                                     MachineType::IntPtr())  // kRequestedSize
-  DECLARE_DESCRIPTOR(AllocateDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(AllocateDescriptor, CallInterfaceDescriptor)
 };
 
 // This descriptor defines the JavaScript calling convention that can be used
 // by stubs: target, new.target, argc (not including the receiver) and context
 // are passed in registers while receiver and the rest of the JS arguments are
 // passed on the stack.
-class JSTrampolineDescriptor
-    : public StaticJSCallInterfaceDescriptor<JSTrampolineDescriptor> {
+class JSTrampolineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_JS_PARAMETERS()
   DEFINE_JS_PARAMETER_TYPES()
 
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(JSTrampolineDescriptor)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(JSTrampolineDescriptor,
+                                   CallInterfaceDescriptor, 0)
 };
 
-class ContextOnlyDescriptor
-    : public StaticCallInterfaceDescriptor<ContextOnlyDescriptor> {
+class ContextOnlyDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS()
   DEFINE_PARAMETER_TYPES()
-  DECLARE_DESCRIPTOR(ContextOnlyDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(ContextOnlyDescriptor, CallInterfaceDescriptor)
 };
 
-class NoContextDescriptor
-    : public StaticCallInterfaceDescriptor<NoContextDescriptor> {
+class NoContextDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT()
   DEFINE_PARAMETER_TYPES()
-  DECLARE_DESCRIPTOR(NoContextDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(NoContextDescriptor, CallInterfaceDescriptor)
 };
 
 // LoadDescriptor is used by all stubs that implement Load/KeyedLoad ICs.
-class LoadDescriptor : public StaticCallInterfaceDescriptor<LoadDescriptor> {
+class LoadDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadDescriptor)
+  DECLARE_DESCRIPTOR(LoadDescriptor, CallInterfaceDescriptor)
 
-  static constexpr inline Register ReceiverRegister();
-  static constexpr inline Register NameRegister();
-  static constexpr inline Register SlotRegister();
-
-  static constexpr auto registers();
+  static const Register ReceiverRegister();
+  static const Register NameRegister();
+  static const Register SlotRegister();
 };
 
 // LoadBaselineDescriptor is a load descriptor that does not take a context as
 // input.
-class LoadBaselineDescriptor
-    : public StaticCallInterfaceDescriptor<LoadBaselineDescriptor> {
+class LoadBaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kReceiver, kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadBaselineDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(LoadBaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class LoadGlobalNoFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<LoadGlobalNoFeedbackDescriptor> {
+class LoadGlobalNoFeedbackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kName, kICKind)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kICKind
-  DECLARE_DESCRIPTOR(LoadGlobalNoFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(LoadGlobalNoFeedbackDescriptor, CallInterfaceDescriptor)
 
-  static constexpr inline Register ICKindRegister();
+  static const Register NameRegister() {
+    return LoadDescriptor::NameRegister();
+  }
 
-  static constexpr auto registers();
+  static const Register ICKindRegister() {
+    return LoadDescriptor::SlotRegister();
+  }
 };
 
-class LoadNoFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<LoadNoFeedbackDescriptor> {
+class LoadNoFeedbackDescriptor : public LoadGlobalNoFeedbackDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kICKind)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kICKind
-  DECLARE_DESCRIPTOR(LoadNoFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(LoadNoFeedbackDescriptor, LoadGlobalNoFeedbackDescriptor)
+
+  static const Register ReceiverRegister() {
+    return LoadDescriptor::ReceiverRegister();
+  }
 
-  static constexpr inline Register ICKindRegister();
+  static const Register NameRegister() {
+    return LoadGlobalNoFeedbackDescriptor::NameRegister();
+  }
 
-  static constexpr auto registers();
+  static const Register ICKindRegister() {
+    return LoadGlobalNoFeedbackDescriptor::ICKindRegister();
+  }
 };
 
-class LoadGlobalDescriptor
-    : public StaticCallInterfaceDescriptor<LoadGlobalDescriptor> {
+class LoadGlobalDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadGlobalDescriptor)
+  DECLARE_DESCRIPTOR(LoadGlobalDescriptor, CallInterfaceDescriptor)
+
+  static const Register NameRegister() {
+    return LoadDescriptor::NameRegister();
+  }
 
-  static constexpr auto registers();
+  static const Register SlotRegister() {
+    return LoadDescriptor::SlotRegister();
+  }
 };
 
-class LoadGlobalBaselineDescriptor
-    : public StaticCallInterfaceDescriptor<LoadGlobalBaselineDescriptor> {
+class LoadGlobalBaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kName, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(LoadGlobalBaselineDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(LoadGlobalBaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class LookupBaselineDescriptor
-    : public StaticCallInterfaceDescriptor<LookupBaselineDescriptor> {
+class LookupBaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kName, kDepth, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged(),  // kDepth
                          MachineType::AnyTagged())  // kSlot
-  DECLARE_DESCRIPTOR(LookupBaselineDescriptor)
+  DECLARE_DESCRIPTOR(LookupBaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class StoreDescriptor : public StaticCallInterfaceDescriptor<StoreDescriptor> {
+class StoreDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreDescriptor)
+  DECLARE_DESCRIPTOR(StoreDescriptor, CallInterfaceDescriptor)
 
-  static constexpr inline Register ReceiverRegister();
-  static constexpr inline Register NameRegister();
-  static constexpr inline Register ValueRegister();
-  static constexpr inline Register SlotRegister();
+  static const Register ReceiverRegister();
+  static const Register NameRegister();
+  static const Register ValueRegister();
+  static const Register SlotRegister();
 
-  static constexpr auto registers();
+#if V8_TARGET_ARCH_IA32
+  static const bool kPassLastArgsOnStack = true;
+#else
+  static const bool kPassLastArgsOnStack = false;
+#endif
+
+  // Pass value and slot through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
 };
 
-class StoreBaselineDescriptor
-    : public StaticCallInterfaceDescriptor<StoreDescriptor> {
+class StoreBaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kReceiver, kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
                          MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreBaselineDescriptor)
+  DECLARE_DESCRIPTOR(StoreBaselineDescriptor, CallInterfaceDescriptor)
+
+#if V8_TARGET_ARCH_IA32
+  static const bool kPassLastArgsOnStack = true;
+#else
+  static const bool kPassLastArgsOnStack = false;
+#endif
 
-  static constexpr auto registers();
+  // Pass value and slot through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
 };
 
-class StoreTransitionDescriptor
-    : public StaticCallInterfaceDescriptor<StoreTransitionDescriptor> {
+class StoreTransitionDescriptor : public StoreDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kMap, kValue, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
@@ -829,15 +828,17 @@ class StoreTransitionDescriptor
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(StoreTransitionDescriptor)
+  DECLARE_DESCRIPTOR(StoreTransitionDescriptor, StoreDescriptor)
 
-  static constexpr inline Register MapRegister();
+  static const Register MapRegister();
+  static const Register SlotRegister();
+  static const Register VectorRegister();
 
-  static constexpr auto registers();
+  // Pass value, slot and vector through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
 };
 
-class StoreWithVectorDescriptor
-    : public StaticCallInterfaceDescriptor<StoreWithVectorDescriptor> {
+class StoreWithVectorDescriptor : public StoreDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kName, kValue, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kReceiver
@@ -845,52 +846,72 @@ class StoreWithVectorDescriptor
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(StoreWithVectorDescriptor)
+  DECLARE_DESCRIPTOR(StoreWithVectorDescriptor, StoreDescriptor)
 
-  static constexpr inline Register VectorRegister();
+  static const Register VectorRegister();
 
-  static constexpr auto registers();
+  // Pass value, slot and vector through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
 };
 
-class StoreGlobalDescriptor
-    : public StaticCallInterfaceDescriptor<StoreGlobalDescriptor> {
+class StoreGlobalDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreGlobalDescriptor)
+  DECLARE_DESCRIPTOR(StoreGlobalDescriptor, CallInterfaceDescriptor)
+
+  static const bool kPassLastArgsOnStack =
+      StoreDescriptor::kPassLastArgsOnStack;
+  // Pass value and slot through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
+
+  static const Register NameRegister() {
+    return StoreDescriptor::NameRegister();
+  }
+
+  static const Register ValueRegister() {
+    return StoreDescriptor::ValueRegister();
+  }
 
-  static constexpr auto registers();
+  static const Register SlotRegister() {
+    return StoreDescriptor::SlotRegister();
+  }
 };
 
-class StoreGlobalBaselineDescriptor
-    : public StaticCallInterfaceDescriptor<StoreGlobalBaselineDescriptor> {
+class StoreGlobalBaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kName, kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(StoreGlobalBaselineDescriptor)
+  DECLARE_DESCRIPTOR(StoreGlobalBaselineDescriptor, CallInterfaceDescriptor)
 
-  static constexpr auto registers();
+  static const bool kPassLastArgsOnStack =
+      StoreDescriptor::kPassLastArgsOnStack;
+  // Pass value and slot through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 2 : 0;
 };
 
-class StoreGlobalWithVectorDescriptor
-    : public StaticCallInterfaceDescriptor<StoreGlobalWithVectorDescriptor> {
+class StoreGlobalWithVectorDescriptor : public StoreGlobalDescriptor {
  public:
   DEFINE_PARAMETERS(kName, kValue, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::AnyTagged(),     // kValue
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(StoreGlobalWithVectorDescriptor)
+  DECLARE_DESCRIPTOR(StoreGlobalWithVectorDescriptor, StoreGlobalDescriptor)
+
+  static const Register VectorRegister() {
+    return StoreWithVectorDescriptor::VectorRegister();
+  }
 
-  static constexpr auto registers();
+  // Pass value, slot and vector through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
 };
 
-class LoadWithVectorDescriptor
-    : public StaticCallInterfaceDescriptor<LoadWithVectorDescriptor> {
+class LoadWithVectorDescriptor : public LoadDescriptor {
  public:
   // TODO(v8:9497): Revert the Machine type for kSlot to the
   // TaggedSigned once Torque can emit better call descriptors
@@ -899,19 +920,24 @@ class LoadWithVectorDescriptor
                          MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged(),  // kSlot
                          MachineType::AnyTagged())  // kVector
-  DECLARE_DESCRIPTOR(LoadWithVectorDescriptor)
+  DECLARE_DESCRIPTOR(LoadWithVectorDescriptor, LoadDescriptor)
+
+  static const Register VectorRegister();
 
-  static constexpr inline Register VectorRegister();
+#if V8_TARGET_ARCH_IA32
+  static const bool kPassLastArgsOnStack = true;
+#else
+  static const bool kPassLastArgsOnStack = false;
+#endif
 
-  static constexpr auto registers();
+  // Pass vector through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
 };
 
 // Like LoadWithVectorDescriptor, except we pass the receiver (the object which
 // should be used as the receiver for accessor function calls) and the lookup
 // start object separately.
-class LoadWithReceiverAndVectorDescriptor
-    : public StaticCallInterfaceDescriptor<
-          LoadWithReceiverAndVectorDescriptor> {
+class LoadWithReceiverAndVectorDescriptor : public LoadWithVectorDescriptor {
  public:
   // TODO(v8:9497): Revert the Machine type for kSlot to the
   // TaggedSigned once Torque can emit better call descriptors
@@ -921,15 +947,22 @@ class LoadWithReceiverAndVectorDescriptor
                          MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged(),  // kSlot
                          MachineType::AnyTagged())  // kVector
-  DECLARE_DESCRIPTOR(LoadWithReceiverAndVectorDescriptor)
+  DECLARE_DESCRIPTOR(LoadWithReceiverAndVectorDescriptor,
+                     LoadWithVectorDescriptor)
+
+  static const Register LookupStartObjectRegister();
 
-  static constexpr inline Register LookupStartObjectRegister();
+#if V8_TARGET_ARCH_IA32
+  static const bool kPassLastArgsOnStack = true;
+#else
+  static const bool kPassLastArgsOnStack = false;
+#endif
 
-  static constexpr auto registers();
+  // Pass vector through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
 };
 
-class LoadWithReceiverBaselineDescriptor
-    : public StaticCallInterfaceDescriptor<LoadWithReceiverBaselineDescriptor> {
+class LoadWithReceiverBaselineDescriptor : public LoadBaselineDescriptor {
  public:
   // TODO(v8:9497): Revert the Machine type for kSlot to the
   // TaggedSigned once Torque can emit better call descriptors
@@ -938,27 +971,29 @@ class LoadWithReceiverBaselineDescriptor
                          MachineType::AnyTagged(),  // kLookupStartObject
                          MachineType::AnyTagged(),  // kName
                          MachineType::AnyTagged())  // kSlot
-  DECLARE_DESCRIPTOR(LoadWithReceiverBaselineDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(LoadWithReceiverBaselineDescriptor, LoadBaselineDescriptor)
 };
 
-class LoadGlobalWithVectorDescriptor
-    : public StaticCallInterfaceDescriptor<LoadGlobalWithVectorDescriptor> {
+class LoadGlobalWithVectorDescriptor : public LoadGlobalDescriptor {
  public:
   DEFINE_PARAMETERS(kName, kSlot, kVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kName
                          MachineType::TaggedSigned(),  // kSlot
                          MachineType::AnyTagged())     // kVector
-  DECLARE_DESCRIPTOR(LoadGlobalWithVectorDescriptor)
-
-  static constexpr inline Register VectorRegister();
+  DECLARE_DESCRIPTOR(LoadGlobalWithVectorDescriptor, LoadGlobalDescriptor)
 
-  static constexpr auto registers();
+#if V8_TARGET_ARCH_IA32
+  // On ia32, LoadWithVectorDescriptor passes vector on the stack and thus we
+  // need to choose a new register here.
+  static const Register VectorRegister() { return edx; }
+#else
+  static const Register VectorRegister() {
+    return LoadWithVectorDescriptor::VectorRegister();
+  }
+#endif
 };
 
-class DynamicCheckMapsDescriptor final
-    : public StaticCallInterfaceDescriptor<DynamicCheckMapsDescriptor> {
+class DynamicCheckMapsDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kMap, kSlot, kHandler)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::Int32(),          // return val
@@ -966,28 +1001,20 @@ class DynamicCheckMapsDescriptor final
                                     MachineType::IntPtr(),         // kSlot
                                     MachineType::TaggedSigned())   // kHandler
 
-  DECLARE_DESCRIPTOR(DynamicCheckMapsDescriptor)
-
-  static constexpr auto registers();
-  static constexpr bool kRestrictAllocatableRegisters = true;
+  DECLARE_DESCRIPTOR(DynamicCheckMapsDescriptor, CallInterfaceDescriptor)
 };
 
-class FastNewObjectDescriptor
-    : public StaticCallInterfaceDescriptor<FastNewObjectDescriptor> {
+class FastNewObjectDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kTarget, kNewTarget)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged())  // kNewTarget
-  DECLARE_DESCRIPTOR(FastNewObjectDescriptor)
-
-  static constexpr inline Register TargetRegister();
-  static constexpr inline Register NewTargetRegister();
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(FastNewObjectDescriptor, CallInterfaceDescriptor)
+  static const Register TargetRegister();
+  static const Register NewTargetRegister();
 };
 
-class RecordWriteDescriptor final
-    : public StaticCallInterfaceDescriptor<RecordWriteDescriptor> {
+class RecordWriteDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kObject, kSlot, kRememberedSet, kFPMode)
   DEFINE_PARAMETER_TYPES(MachineType::TaggedPointer(),  // kObject
@@ -995,119 +1022,90 @@ class RecordWriteDescriptor final
                          MachineType::TaggedSigned(),   // kRememberedSet
                          MachineType::TaggedSigned())   // kFPMode
 
-  DECLARE_DESCRIPTOR(RecordWriteDescriptor)
-
-  static constexpr auto registers();
-  static constexpr bool kRestrictAllocatableRegisters = true;
+  DECLARE_DESCRIPTOR(RecordWriteDescriptor, CallInterfaceDescriptor)
 };
 
-class EphemeronKeyBarrierDescriptor final
-    : public StaticCallInterfaceDescriptor<EphemeronKeyBarrierDescriptor> {
+class EphemeronKeyBarrierDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kObject, kSlotAddress, kFPMode)
   DEFINE_PARAMETER_TYPES(MachineType::TaggedPointer(),  // kObject
                          MachineType::Pointer(),        // kSlotAddress
                          MachineType::TaggedSigned())   // kFPMode
 
-  DECLARE_DESCRIPTOR(EphemeronKeyBarrierDescriptor)
-
-  static constexpr auto registers();
-  static constexpr bool kRestrictAllocatableRegisters = true;
+  DECLARE_DESCRIPTOR(EphemeronKeyBarrierDescriptor, CallInterfaceDescriptor)
 };
 
-class TypeConversionDescriptor final
-    : public StaticCallInterfaceDescriptor<TypeConversionDescriptor> {
+class TypeConversionDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(TypeConversionDescriptor)
-
-  static constexpr inline Register ArgumentRegister();
+  DECLARE_DESCRIPTOR(TypeConversionDescriptor, CallInterfaceDescriptor)
 
-  static constexpr auto registers();
+  static const Register ArgumentRegister();
 };
 
-class TypeConversionNoContextDescriptor final
-    : public StaticCallInterfaceDescriptor<TypeConversionNoContextDescriptor> {
+class TypeConversionNoContextDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(TypeConversionNoContextDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(TypeConversionNoContextDescriptor, CallInterfaceDescriptor)
 };
 
-class TypeConversion_BaselineDescriptor final
-    : public StaticCallInterfaceDescriptor<TypeConversion_BaselineDescriptor> {
+class TypeConversion_BaselineDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kArgument, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(), MachineType::UintPtr())
-  DECLARE_DESCRIPTOR(TypeConversion_BaselineDescriptor)
+  DECLARE_DESCRIPTOR(TypeConversion_BaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class SingleParameterOnStackDescriptor final
-    : public StaticCallInterfaceDescriptor<SingleParameterOnStackDescriptor> {
+class SingleParameterOnStackDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(SingleParameterOnStackDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(SingleParameterOnStackDescriptor, CallInterfaceDescriptor)
 };
 
 class AsyncFunctionStackParameterDescriptor final
-    : public StaticCallInterfaceDescriptor<
-          AsyncFunctionStackParameterDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kPromise, kResult)
   DEFINE_PARAMETER_TYPES(MachineType::TaggedPointer(), MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(AsyncFunctionStackParameterDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(AsyncFunctionStackParameterDescriptor,
+                     CallInterfaceDescriptor)
 };
 
 class GetIteratorStackParameterDescriptor final
-    : public StaticCallInterfaceDescriptor<
-          GetIteratorStackParameterDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kCallSlot, kFeedback, kResult)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(), MachineType::AnyTagged(),
                          MachineType::AnyTagged(), MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(GetIteratorStackParameterDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(GetIteratorStackParameterDescriptor,
+                     CallInterfaceDescriptor)
 };
 
-class GetPropertyDescriptor final
-    : public StaticCallInterfaceDescriptor<GetPropertyDescriptor> {
+class GetPropertyDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kObject, kKey)
-  DECLARE_DEFAULT_DESCRIPTOR(GetPropertyDescriptor)
+  DECLARE_DEFAULT_DESCRIPTOR(GetPropertyDescriptor, CallInterfaceDescriptor)
 };
 
-class TypeofDescriptor
-    : public StaticCallInterfaceDescriptor<TypeofDescriptor> {
+class TypeofDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kObject)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(TypeofDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(TypeofDescriptor, CallInterfaceDescriptor)
 };
 
-class CallTrampolineDescriptor
-    : public StaticCallInterfaceDescriptor<CallTrampolineDescriptor> {
+class CallTrampolineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunction, kActualArgumentsCount)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunction
                          MachineType::Int32())      // kActualArgumentsCount
-  DECLARE_DESCRIPTOR(CallTrampolineDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(CallTrampolineDescriptor, CallInterfaceDescriptor)
 };
 
-class CallVarargsDescriptor
-    : public StaticCallInterfaceDescriptor<CallVarargsDescriptor> {
+class CallVarargsDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kActualArgumentsCount, kArgumentsLength,
                             kArgumentsList)
@@ -1115,60 +1113,46 @@ class CallVarargsDescriptor
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::Int32(),      // kArgumentsLength
                          MachineType::AnyTagged())  // kArgumentsList
-  DECLARE_DESCRIPTOR(CallVarargsDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(CallVarargsDescriptor, CallInterfaceDescriptor)
 };
 
-class CallForwardVarargsDescriptor
-    : public StaticCallInterfaceDescriptor<CallForwardVarargsDescriptor> {
+class CallForwardVarargsDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kActualArgumentsCount, kStartIndex)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::Int32())      // kStartIndex
-  DECLARE_DESCRIPTOR(CallForwardVarargsDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(CallForwardVarargsDescriptor, CallInterfaceDescriptor)
 };
 
-class CallFunctionTemplateDescriptor
-    : public StaticCallInterfaceDescriptor<CallFunctionTemplateDescriptor> {
+class CallFunctionTemplateDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunctionTemplateInfo, kArgumentsCount)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunctionTemplateInfo
                          MachineType::IntPtr())     // kArgumentsCount
-  DECLARE_DESCRIPTOR(CallFunctionTemplateDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(CallFunctionTemplateDescriptor, CallInterfaceDescriptor)
 };
 
-class CallWithSpreadDescriptor
-    : public StaticCallInterfaceDescriptor<CallWithSpreadDescriptor> {
+class CallWithSpreadDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kArgumentsCount, kSpread)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::Int32(),      // kArgumentsCount
                          MachineType::AnyTagged())  // kSpread
-  DECLARE_DESCRIPTOR(CallWithSpreadDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(CallWithSpreadDescriptor, CallInterfaceDescriptor)
 };
 
-class CallWithSpread_BaselineDescriptor
-    : public StaticCallInterfaceDescriptor<CallWithSpread_BaselineDescriptor> {
+class CallWithSpread_BaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kArgumentsCount, kSpread, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::Int32(),      // kArgumentsCount
                          MachineType::AnyTagged(),  // kSpread
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(CallWithSpread_BaselineDescriptor)
+  DECLARE_DESCRIPTOR(CallWithSpread_BaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class CallWithSpread_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<
-          CallWithSpread_WithFeedbackDescriptor> {
+class CallWithSpread_WithFeedbackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kTarget, kArgumentsCount, kSpread, kSlot,
                             kFeedbackVector)
@@ -1177,79 +1161,75 @@ class CallWithSpread_WithFeedbackDescriptor
                          MachineType::AnyTagged(),  // kSpread
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(CallWithSpread_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(CallWithSpread_WithFeedbackDescriptor,
+                     CallInterfaceDescriptor)
 };
 
-class CallWithArrayLikeDescriptor
-    : public StaticCallInterfaceDescriptor<CallWithArrayLikeDescriptor> {
+class CallWithArrayLikeDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kTarget, kArgumentsList)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged())  // kArgumentsList
-  DECLARE_DESCRIPTOR(CallWithArrayLikeDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(CallWithArrayLikeDescriptor, CallInterfaceDescriptor)
 };
 
 class CallWithArrayLike_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<
-          CallWithArrayLike_WithFeedbackDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kTarget, kArgumentsList, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged(),  // kArgumentsList
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(CallWithArrayLike_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(CallWithArrayLike_WithFeedbackDescriptor,
+                     CallInterfaceDescriptor)
 };
 
-class ConstructVarargsDescriptor
-    : public StaticCallInterfaceDescriptor<ConstructVarargsDescriptor> {
+class ConstructVarargsDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_JS_PARAMETERS(kArgumentsLength, kArgumentsList)
   DEFINE_JS_PARAMETER_TYPES(MachineType::Int32(),      // kArgumentsLength
                             MachineType::AnyTagged())  // kArgumentsList
 
-  DECLARE_DESCRIPTOR(ConstructVarargsDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(ConstructVarargsDescriptor, CallInterfaceDescriptor)
 };
 
-class ConstructForwardVarargsDescriptor
-    : public StaticCallInterfaceDescriptor<ConstructForwardVarargsDescriptor> {
+class ConstructForwardVarargsDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_JS_PARAMETERS(kStartIndex)
   DEFINE_JS_PARAMETER_TYPES(MachineType::Int32())
-  DECLARE_DESCRIPTOR(ConstructForwardVarargsDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(ConstructForwardVarargsDescriptor, CallInterfaceDescriptor)
 };
 
-class ConstructWithSpreadDescriptor
-    : public StaticCallInterfaceDescriptor<ConstructWithSpreadDescriptor> {
+class ConstructWithSpreadDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_JS_PARAMETERS(kSpread)
   DEFINE_JS_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(ConstructWithSpreadDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(ConstructWithSpreadDescriptor, CallInterfaceDescriptor)
 };
 
-class ConstructWithSpread_BaselineDescriptor
-    : public StaticCallInterfaceDescriptor<
-          ConstructWithSpread_BaselineDescriptor> {
+class ConstructWithSpread_BaselineDescriptor : public CallInterfaceDescriptor {
  public:
   // Note: kSlot comes before kSpread since as an untagged value it must be
   // passed in a register.
   DEFINE_JS_PARAMETERS(kSlot, kSpread)
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr(),    // kSlot
                             MachineType::AnyTagged())  // kSpread
-  DECLARE_DESCRIPTOR(ConstructWithSpread_BaselineDescriptor)
+  DECLARE_DESCRIPTOR(ConstructWithSpread_BaselineDescriptor,
+                     CallInterfaceDescriptor)
+
+#if V8_TARGET_ARCH_IA32
+  static const bool kPassLastArgsOnStack = true;
+#else
+  static const bool kPassLastArgsOnStack = false;
+#endif
+
+  // Pass spread through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
 };
 
 class ConstructWithSpread_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<
-          ConstructWithSpread_WithFeedbackDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   // Note: kSlot comes before kSpread since as an untagged value it must be
   // passed in a register.
@@ -1257,24 +1237,21 @@ class ConstructWithSpread_WithFeedbackDescriptor
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr(),    // kSlot
                             MachineType::AnyTagged(),  // kSpread
                             MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(ConstructWithSpread_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(ConstructWithSpread_WithFeedbackDescriptor,
+                     CallInterfaceDescriptor)
 };
 
-class ConstructWithArrayLikeDescriptor
-    : public StaticCallInterfaceDescriptor<ConstructWithArrayLikeDescriptor> {
+class ConstructWithArrayLikeDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kTarget, kNewTarget, kArgumentsList)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
                          MachineType::AnyTagged(),  // kNewTarget
                          MachineType::AnyTagged())  // kArgumentsList
-  DECLARE_DESCRIPTOR(ConstructWithArrayLikeDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(ConstructWithArrayLikeDescriptor, CallInterfaceDescriptor)
 };
 
 class ConstructWithArrayLike_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<
-          ConstructWithArrayLike_WithFeedbackDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kTarget, kNewTarget, kArgumentsList, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kTarget
@@ -1282,44 +1259,38 @@ class ConstructWithArrayLike_WithFeedbackDescriptor
                          MachineType::AnyTagged(),  // kArgumentsList
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(ConstructWithArrayLike_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(ConstructWithArrayLike_WithFeedbackDescriptor,
+                     CallInterfaceDescriptor)
 };
 
 // TODO(ishell): consider merging this with ArrayConstructorDescriptor
-class ConstructStubDescriptor
-    : public StaticCallInterfaceDescriptor<ConstructStubDescriptor> {
+class ConstructStubDescriptor : public CallInterfaceDescriptor {
  public:
   // TODO(jgruber): Remove the unused allocation site parameter.
   DEFINE_JS_PARAMETERS(kAllocationSite)
   DEFINE_JS_PARAMETER_TYPES(MachineType::AnyTagged())
 
   // TODO(ishell): Use DECLARE_JS_COMPATIBLE_DESCRIPTOR if registers match
-  DECLARE_DESCRIPTOR(ConstructStubDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(ConstructStubDescriptor, CallInterfaceDescriptor)
 };
 
-class AbortDescriptor : public StaticCallInterfaceDescriptor<AbortDescriptor> {
+class AbortDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kMessageOrMessageId)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())
-  DECLARE_DESCRIPTOR(AbortDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(AbortDescriptor, CallInterfaceDescriptor)
 };
 
-class ArrayConstructorDescriptor
-    : public StaticJSCallInterfaceDescriptor<ArrayConstructorDescriptor> {
+class ArrayConstructorDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_JS_PARAMETERS(kAllocationSite)
   DEFINE_JS_PARAMETER_TYPES(MachineType::AnyTagged())
 
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(ArrayConstructorDescriptor)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(ArrayConstructorDescriptor,
+                                   CallInterfaceDescriptor, 1)
 };
 
-class ArrayNArgumentsConstructorDescriptor
-    : public StaticCallInterfaceDescriptor<
-          ArrayNArgumentsConstructorDescriptor> {
+class ArrayNArgumentsConstructorDescriptor : public CallInterfaceDescriptor {
  public:
   // This descriptor declares only register arguments while respective number
   // of JS arguments stay on the expression stack.
@@ -1329,14 +1300,12 @@ class ArrayNArgumentsConstructorDescriptor
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunction,
                          MachineType::AnyTagged(),  // kAllocationSite
                          MachineType::Int32())      // kActualArgumentsCount
-  DECLARE_DESCRIPTOR(ArrayNArgumentsConstructorDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(ArrayNArgumentsConstructorDescriptor,
+                     CallInterfaceDescriptor)
 };
 
 class ArrayNoArgumentConstructorDescriptor
-    : public StaticCallInterfaceDescriptor<
-          ArrayNoArgumentConstructorDescriptor> {
+    : public ArrayNArgumentsConstructorDescriptor {
  public:
   // This descriptor declares same register arguments as the parent
   // ArrayNArgumentsConstructorDescriptor and it declares indices for
@@ -1347,14 +1316,12 @@ class ArrayNoArgumentConstructorDescriptor
                          MachineType::AnyTagged(),  // kAllocationSite
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::AnyTagged())  // kFunctionParameter
-  DECLARE_DESCRIPTOR(ArrayNoArgumentConstructorDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(ArrayNoArgumentConstructorDescriptor,
+                     ArrayNArgumentsConstructorDescriptor)
 };
 
 class ArraySingleArgumentConstructorDescriptor
-    : public StaticCallInterfaceDescriptor<
-          ArraySingleArgumentConstructorDescriptor> {
+    : public ArrayNArgumentsConstructorDescriptor {
  public:
   // This descriptor declares same register arguments as the parent
   // ArrayNArgumentsConstructorDescriptor and it declares indices for
@@ -1367,56 +1334,44 @@ class ArraySingleArgumentConstructorDescriptor
                          // JS arguments on the stack
                          MachineType::AnyTagged(),  // kArraySizeSmiParameter
                          MachineType::AnyTagged())  // kReceiverParameter
-  DECLARE_DESCRIPTOR(ArraySingleArgumentConstructorDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(ArraySingleArgumentConstructorDescriptor,
+                     ArrayNArgumentsConstructorDescriptor)
 };
 
-class CompareDescriptor
-    : public StaticCallInterfaceDescriptor<CompareDescriptor> {
+class CompareDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kLeft, kRight)
-  DECLARE_DESCRIPTOR(CompareDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(CompareDescriptor, CallInterfaceDescriptor)
 };
 
-class BinaryOpDescriptor
-    : public StaticCallInterfaceDescriptor<BinaryOpDescriptor> {
+class BinaryOpDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kLeft, kRight)
-  DECLARE_DESCRIPTOR(BinaryOpDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(BinaryOpDescriptor, CallInterfaceDescriptor)
 };
 
-class BinaryOp_BaselineDescriptor
-    : public StaticCallInterfaceDescriptor<BinaryOp_BaselineDescriptor> {
+class BinaryOp_BaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kLeft, kRight, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(BinaryOp_BaselineDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(BinaryOp_BaselineDescriptor, CallInterfaceDescriptor)
 };
 
 // This desciptor is shared among String.p.charAt/charCodeAt/codePointAt
 // as they all have the same interface.
-class StringAtDescriptor final
-    : public StaticCallInterfaceDescriptor<StringAtDescriptor> {
+class StringAtDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kPosition)
   // TODO(turbofan): Return untagged value here.
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::TaggedSigned(),  // result 1
                                     MachineType::AnyTagged(),     // kReceiver
                                     MachineType::IntPtr())        // kPosition
-  DECLARE_DESCRIPTOR(StringAtDescriptor)
+  DECLARE_DESCRIPTOR(StringAtDescriptor, CallInterfaceDescriptor)
 };
 
-class StringAtAsStringDescriptor final
-    : public StaticCallInterfaceDescriptor<StringAtAsStringDescriptor> {
+class StringAtAsStringDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kPosition)
   // TODO(turbofan): Return untagged value here.
@@ -1424,11 +1379,10 @@ class StringAtAsStringDescriptor final
       MachineType::TaggedPointer(),  // result string
       MachineType::AnyTagged(),      // kReceiver
       MachineType::IntPtr())         // kPosition
-  DECLARE_DESCRIPTOR(StringAtAsStringDescriptor)
+  DECLARE_DESCRIPTOR(StringAtAsStringDescriptor, CallInterfaceDescriptor)
 };
 
-class StringSubstringDescriptor final
-    : public StaticCallInterfaceDescriptor<StringSubstringDescriptor> {
+class StringSubstringDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kString, kFrom, kTo)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kString
@@ -1436,19 +1390,18 @@ class StringSubstringDescriptor final
                          MachineType::IntPtr())     // kTo
 
   // TODO(turbofan): Allow builtins to return untagged values.
-  DECLARE_DESCRIPTOR(StringSubstringDescriptor)
+  DECLARE_DESCRIPTOR(StringSubstringDescriptor, CallInterfaceDescriptor)
 };
 
-class CppBuiltinAdaptorDescriptor
-    : public StaticJSCallInterfaceDescriptor<CppBuiltinAdaptorDescriptor> {
+class CppBuiltinAdaptorDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_JS_PARAMETERS(kCFunction)
   DEFINE_JS_PARAMETER_TYPES(MachineType::Pointer())
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(CppBuiltinAdaptorDescriptor)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(CppBuiltinAdaptorDescriptor,
+                                   CallInterfaceDescriptor, 1)
 };
 
-class CEntry1ArgvOnStackDescriptor
-    : public StaticCallInterfaceDescriptor<CEntry1ArgvOnStackDescriptor> {
+class CEntry1ArgvOnStackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kArity,          // register argument
                     kCFunction,      // register argument
@@ -1462,13 +1415,10 @@ class CEntry1ArgvOnStackDescriptor
                          MachineType::AnyTagged(),  // kArgcSmi
                          MachineType::AnyTagged(),  // kTargetCopy
                          MachineType::AnyTagged())  // kNewTargetCopy
-  DECLARE_DESCRIPTOR(CEntry1ArgvOnStackDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(CEntry1ArgvOnStackDescriptor, CallInterfaceDescriptor)
 };
 
-class ApiCallbackDescriptor
-    : public StaticCallInterfaceDescriptor<ApiCallbackDescriptor> {
+class ApiCallbackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kApiFunctionAddress, kActualArgumentsCount,
                             kCallData, kHolder)
@@ -1478,56 +1428,44 @@ class ApiCallbackDescriptor
                          MachineType::IntPtr(),     // kActualArgumentsCount
                          MachineType::AnyTagged(),  // kCallData
                          MachineType::AnyTagged())  // kHolder
-  DECLARE_DESCRIPTOR(ApiCallbackDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(ApiCallbackDescriptor, CallInterfaceDescriptor)
 };
 
-class ApiGetterDescriptor
-    : public StaticCallInterfaceDescriptor<ApiGetterDescriptor> {
+class ApiGetterDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kReceiver, kHolder, kCallback)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kReceiver
                          MachineType::AnyTagged(),  // kHolder
                          MachineType::AnyTagged())  // kCallback
-  DECLARE_DESCRIPTOR(ApiGetterDescriptor)
+  DECLARE_DESCRIPTOR(ApiGetterDescriptor, CallInterfaceDescriptor)
 
-  static constexpr inline Register ReceiverRegister();
-  static constexpr inline Register HolderRegister();
-  static constexpr inline Register CallbackRegister();
-
-  static constexpr auto registers();
+  static const Register ReceiverRegister();
+  static const Register HolderRegister();
+  static const Register CallbackRegister();
 };
 
 // TODO(turbofan): We should probably rename this to GrowFastElementsDescriptor.
-class GrowArrayElementsDescriptor
-    : public StaticCallInterfaceDescriptor<GrowArrayElementsDescriptor> {
+class GrowArrayElementsDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kObject, kKey)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kObject
                          MachineType::AnyTagged())  // kKey
-  DECLARE_DESCRIPTOR(GrowArrayElementsDescriptor)
-
-  static constexpr inline Register ObjectRegister();
-  static constexpr inline Register KeyRegister();
+  DECLARE_DESCRIPTOR(GrowArrayElementsDescriptor, CallInterfaceDescriptor)
 
-  static constexpr auto registers();
+  static const Register ObjectRegister();
+  static const Register KeyRegister();
 };
 
 class V8_EXPORT_PRIVATE TailCallOptimizedCodeSlotDescriptor
-    : public StaticCallInterfaceDescriptor<
-          TailCallOptimizedCodeSlotDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kOptimizedCodeEntry)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged())  // kAccumulator
-  DECLARE_DESCRIPTOR(TailCallOptimizedCodeSlotDescriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(TailCallOptimizedCodeSlotDescriptor,
+                     CallInterfaceDescriptor)
 };
 
-class BaselineOutOfLinePrologueDescriptor
-    : public StaticCallInterfaceDescriptor<
-          BaselineOutOfLinePrologueDescriptor> {
+class BaselineOutOfLinePrologueDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kCalleeContext, kClosure,
                                kJavaScriptCallArgCount, kStackFrameSize,
@@ -1539,31 +1477,32 @@ class BaselineOutOfLinePrologueDescriptor
                          MachineType::Int32(),      // kStackFrameSize
                          MachineType::AnyTagged(),  // kJavaScriptCallNewTarget
                          MachineType::AnyTagged())  // kInterpreterBytecodeArray
-  DECLARE_DESCRIPTOR(BaselineOutOfLinePrologueDescriptor)
+  DECLARE_DESCRIPTOR(BaselineOutOfLinePrologueDescriptor,
+                     CallInterfaceDescriptor)
 
-  static constexpr inline auto registers();
+#if V8_TARGET_ARCH_IA32
+  static const bool kPassLastArgsOnStack = true;
+#else
+  static const bool kPassLastArgsOnStack = false;
+#endif
 
-  // We pass the context manually, so we have one extra register.
-  static constexpr int kMaxRegisterParams =
-      StaticCallInterfaceDescriptor::kMaxRegisterParams + 1;
+  // Pass bytecode array through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 1 : 0;
 };
 
-class BaselineLeaveFrameDescriptor
-    : public StaticCallInterfaceDescriptor<BaselineLeaveFrameDescriptor> {
+class BaselineLeaveFrameDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kParamsSize, kWeight)
   DEFINE_PARAMETER_TYPES(MachineType::Int32(),  // kParamsSize
                          MachineType::Int32())  // kWeight
-  DECLARE_DESCRIPTOR(BaselineLeaveFrameDescriptor)
+  DECLARE_DESCRIPTOR(BaselineLeaveFrameDescriptor, CallInterfaceDescriptor)
 
-  static constexpr inline Register ParamsSizeRegister();
-  static constexpr inline Register WeightRegister();
-
-  static constexpr inline auto registers();
+  static const Register ParamsSizeRegister();
+  static const Register WeightRegister();
 };
 
 class V8_EXPORT_PRIVATE InterpreterDispatchDescriptor
-    : public StaticCallInterfaceDescriptor<InterpreterDispatchDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kAccumulator, kBytecodeOffset, kBytecodeArray,
                     kDispatchTable)
@@ -1571,27 +1510,21 @@ class V8_EXPORT_PRIVATE InterpreterDispatchDescriptor
                          MachineType::IntPtr(),     // kBytecodeOffset
                          MachineType::AnyTagged(),  // kBytecodeArray
                          MachineType::IntPtr())     // kDispatchTable
-  DECLARE_DESCRIPTOR(InterpreterDispatchDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(InterpreterDispatchDescriptor, CallInterfaceDescriptor)
 };
 
-class InterpreterPushArgsThenCallDescriptor
-    : public StaticCallInterfaceDescriptor<
-          InterpreterPushArgsThenCallDescriptor> {
+class InterpreterPushArgsThenCallDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kNumberOfArguments, kFirstArgument, kFunction)
   DEFINE_PARAMETER_TYPES(MachineType::Int32(),      // kNumberOfArguments
                          MachineType::Pointer(),    // kFirstArgument
                          MachineType::AnyTagged())  // kFunction
-  DECLARE_DESCRIPTOR(InterpreterPushArgsThenCallDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(InterpreterPushArgsThenCallDescriptor,
+                     CallInterfaceDescriptor)
 };
 
 class InterpreterPushArgsThenConstructDescriptor
-    : public StaticCallInterfaceDescriptor<
-          InterpreterPushArgsThenConstructDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kNumberOfArguments, kFirstArgument, kConstructor,
                     kNewTarget, kFeedbackElement)
@@ -1600,13 +1533,20 @@ class InterpreterPushArgsThenConstructDescriptor
                          MachineType::AnyTagged(),  // kConstructor
                          MachineType::AnyTagged(),  // kNewTarget
                          MachineType::AnyTagged())  // kFeedbackElement
-  DECLARE_DESCRIPTOR(InterpreterPushArgsThenConstructDescriptor)
+  DECLARE_DESCRIPTOR(InterpreterPushArgsThenConstructDescriptor,
+                     CallInterfaceDescriptor)
+
+#if V8_TARGET_ARCH_IA32
+  static const bool kPassLastArgsOnStack = true;
+#else
+  static const bool kPassLastArgsOnStack = false;
+#endif
 
-  static constexpr inline auto registers();
+  // Pass constructor, new target and feedback element through the stack.
+  static const int kStackArgumentsCount = kPassLastArgsOnStack ? 3 : 0;
 };
 
-class InterpreterCEntry1Descriptor
-    : public StaticCallInterfaceDescriptor<InterpreterCEntry1Descriptor> {
+class InterpreterCEntry1Descriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_RESULT_AND_PARAMETERS(1, kNumberOfArguments, kFirstArgument,
                                kFunctionEntry)
@@ -1614,13 +1554,10 @@ class InterpreterCEntry1Descriptor
                                     MachineType::Int32(),  // kNumberOfArguments
                                     MachineType::Pointer(),  // kFirstArgument
                                     MachineType::Pointer())  // kFunctionEntry
-  DECLARE_DESCRIPTOR(InterpreterCEntry1Descriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(InterpreterCEntry1Descriptor, CallInterfaceDescriptor)
 };
 
-class InterpreterCEntry2Descriptor
-    : public StaticCallInterfaceDescriptor<InterpreterCEntry2Descriptor> {
+class InterpreterCEntry2Descriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_RESULT_AND_PARAMETERS(2, kNumberOfArguments, kFirstArgument,
                                kFunctionEntry)
@@ -1629,13 +1566,10 @@ class InterpreterCEntry2Descriptor
                                     MachineType::Int32(),  // kNumberOfArguments
                                     MachineType::Pointer(),  // kFirstArgument
                                     MachineType::Pointer())  // kFunctionEntry
-  DECLARE_DESCRIPTOR(InterpreterCEntry2Descriptor)
-
-  static constexpr auto registers();
+  DECLARE_DESCRIPTOR(InterpreterCEntry2Descriptor, CallInterfaceDescriptor)
 };
 
-class ForInPrepareDescriptor
-    : public StaticCallInterfaceDescriptor<ForInPrepareDescriptor> {
+class ForInPrepareDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_RESULT_AND_PARAMETERS(2, kEnumerator, kVectorIndex, kFeedbackVector)
   DEFINE_RESULT_AND_PARAMETER_TYPES(
@@ -1644,22 +1578,18 @@ class ForInPrepareDescriptor
       MachineType::AnyTagged(),     // kEnumerator
       MachineType::TaggedSigned(),  // kVectorIndex
       MachineType::AnyTagged())     // kFeedbackVector
-  DECLARE_DESCRIPTOR(ForInPrepareDescriptor)
+  DECLARE_DESCRIPTOR(ForInPrepareDescriptor, CallInterfaceDescriptor)
 };
 
-class ResumeGeneratorDescriptor final
-    : public StaticCallInterfaceDescriptor<ResumeGeneratorDescriptor> {
+class ResumeGeneratorDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kValue, kGenerator)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kValue
                          MachineType::AnyTagged())  // kGenerator
-  DECLARE_DESCRIPTOR(ResumeGeneratorDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(ResumeGeneratorDescriptor, CallInterfaceDescriptor)
 };
 
-class ResumeGeneratorBaselineDescriptor final
-    : public StaticCallInterfaceDescriptor<ResumeGeneratorBaselineDescriptor> {
+class ResumeGeneratorBaselineDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kGeneratorObject, kRegisterCount)
   DEFINE_RESULT_AND_PARAMETER_TYPES(
@@ -1667,11 +1597,11 @@ class ResumeGeneratorBaselineDescriptor final
       MachineType::AnyTagged(),     // kGeneratorObject
       MachineType::IntPtr(),        // kRegisterCount
   )
-  DECLARE_DESCRIPTOR(ResumeGeneratorBaselineDescriptor)
+  DECLARE_DESCRIPTOR(ResumeGeneratorBaselineDescriptor, CallInterfaceDescriptor)
 };
 
 class SuspendGeneratorBaselineDescriptor final
-    : public StaticCallInterfaceDescriptor<SuspendGeneratorBaselineDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kGeneratorObject, kSuspendId, kBytecodeOffset,
                     kRegisterCount)
@@ -1680,107 +1610,88 @@ class SuspendGeneratorBaselineDescriptor final
                          MachineType::IntPtr(),     // kBytecodeOffset
                          MachineType::IntPtr(),     // kRegisterCount
   )
-  DECLARE_DESCRIPTOR(SuspendGeneratorBaselineDescriptor)
+  DECLARE_DESCRIPTOR(SuspendGeneratorBaselineDescriptor,
+                     CallInterfaceDescriptor)
 };
 
-class FrameDropperTrampolineDescriptor final
-    : public StaticCallInterfaceDescriptor<FrameDropperTrampolineDescriptor> {
+class FrameDropperTrampolineDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kRestartFp)
   DEFINE_PARAMETER_TYPES(MachineType::Pointer())
-  DECLARE_DESCRIPTOR(FrameDropperTrampolineDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(FrameDropperTrampolineDescriptor, CallInterfaceDescriptor)
 };
 
-class RunMicrotasksEntryDescriptor final
-    : public StaticCallInterfaceDescriptor<RunMicrotasksEntryDescriptor> {
+class RunMicrotasksEntryDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_ENTRY(kRootRegisterValue, kMicrotaskQueue)
   DEFINE_PARAMETER_TYPES(MachineType::Pointer(),  // kRootRegisterValue
                          MachineType::Pointer())  // kMicrotaskQueue
-  DECLARE_DESCRIPTOR(RunMicrotasksEntryDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(RunMicrotasksEntryDescriptor, CallInterfaceDescriptor)
 };
 
-class RunMicrotasksDescriptor final
-    : public StaticCallInterfaceDescriptor<RunMicrotasksDescriptor> {
+class RunMicrotasksDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kMicrotaskQueue)
   DEFINE_PARAMETER_TYPES(MachineType::Pointer())
-  DECLARE_DESCRIPTOR(RunMicrotasksDescriptor)
+  DECLARE_DESCRIPTOR(RunMicrotasksDescriptor, CallInterfaceDescriptor)
 
-  static constexpr inline Register MicrotaskQueueRegister();
+  static Register MicrotaskQueueRegister();
 };
 
-class WasmFloat32ToNumberDescriptor final
-    : public StaticCallInterfaceDescriptor<WasmFloat32ToNumberDescriptor> {
+class WasmFloat32ToNumberDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kValue)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged(),  // result
                                     MachineType::Float32())    // value
-  DECLARE_DESCRIPTOR(WasmFloat32ToNumberDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  // We need a custom descriptor on ia32 to avoid using xmm0.
-  static constexpr inline auto registers();
-#endif
+  DECLARE_DESCRIPTOR(WasmFloat32ToNumberDescriptor, CallInterfaceDescriptor)
 };
 
-class WasmFloat64ToNumberDescriptor final
-    : public StaticCallInterfaceDescriptor<WasmFloat64ToNumberDescriptor> {
+class WasmFloat64ToNumberDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kValue)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged(),  // result
                                     MachineType::Float64())    // value
-  DECLARE_DESCRIPTOR(WasmFloat64ToNumberDescriptor)
-
-#if V8_TARGET_ARCH_IA32
-  // We need a custom descriptor on ia32 to avoid using xmm0.
-  static constexpr inline auto registers();
-#endif
+  DECLARE_DESCRIPTOR(WasmFloat64ToNumberDescriptor, CallInterfaceDescriptor)
 };
 
 class V8_EXPORT_PRIVATE I64ToBigIntDescriptor final
-    : public StaticCallInterfaceDescriptor<I64ToBigIntDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kArgument)
   DEFINE_PARAMETER_TYPES(MachineType::Int64())  // kArgument
-  DECLARE_DESCRIPTOR(I64ToBigIntDescriptor)
+  DECLARE_DESCRIPTOR(I64ToBigIntDescriptor, CallInterfaceDescriptor)
 };
 
 // 32 bits version of the I64ToBigIntDescriptor call interface descriptor
 class V8_EXPORT_PRIVATE I32PairToBigIntDescriptor final
-    : public StaticCallInterfaceDescriptor<I32PairToBigIntDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kLow, kHigh)
   DEFINE_PARAMETER_TYPES(MachineType::Uint32(),  // kLow
                          MachineType::Uint32())  // kHigh
-  DECLARE_DESCRIPTOR(I32PairToBigIntDescriptor)
+  DECLARE_DESCRIPTOR(I32PairToBigIntDescriptor, CallInterfaceDescriptor)
 };
 
 class V8_EXPORT_PRIVATE BigIntToI64Descriptor final
-    : public StaticCallInterfaceDescriptor<BigIntToI64Descriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kArgument)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::Int64(),      // result 1
                                     MachineType::AnyTagged())  // kArgument
-  DECLARE_DESCRIPTOR(BigIntToI64Descriptor)
+  DECLARE_DESCRIPTOR(BigIntToI64Descriptor, CallInterfaceDescriptor)
 };
 
 class V8_EXPORT_PRIVATE BigIntToI32PairDescriptor final
-    : public StaticCallInterfaceDescriptor<BigIntToI32PairDescriptor> {
+    : public CallInterfaceDescriptor {
  public:
   DEFINE_RESULT_AND_PARAMETERS(2, kArgument)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::Uint32(),     // result 1
                                     MachineType::Uint32(),     // result 2
                                     MachineType::AnyTagged())  // kArgument
-  DECLARE_DESCRIPTOR(BigIntToI32PairDescriptor)
+  DECLARE_DESCRIPTOR(BigIntToI32PairDescriptor, CallInterfaceDescriptor)
 };
 
-class WasmI32AtomicWait32Descriptor final
-    : public StaticCallInterfaceDescriptor<WasmI32AtomicWait32Descriptor> {
+class WasmI32AtomicWait32Descriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kAddress, kExpectedValue, kTimeoutLow,
                                kTimeoutHigh)
@@ -1789,30 +1700,36 @@ class WasmI32AtomicWait32Descriptor final
                                     MachineType::Int32(),   // kExpectedValue
                                     MachineType::Uint32(),  // kTimeoutLow
                                     MachineType::Uint32())  // kTimeoutHigh
-  DECLARE_DESCRIPTOR(WasmI32AtomicWait32Descriptor)
+  DECLARE_DESCRIPTOR(WasmI32AtomicWait32Descriptor, CallInterfaceDescriptor)
 };
 
-class WasmI64AtomicWait32Descriptor final
-    : public StaticCallInterfaceDescriptor<WasmI64AtomicWait32Descriptor> {
+class WasmI64AtomicWait32Descriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kAddress, kExpectedValueLow, kExpectedValueHigh,
                                kTimeoutLow, kTimeoutHigh)
 
-  static constexpr bool kNoStackScan = true;
+  DEFINE_RESULT_AND_PARAMETER_TYPES_WITH_FLAG(
+      CallInterfaceDescriptorData::kNoStackScan,  // allow untagged stack params
+      MachineType::Uint32(),                      // result 1
+      MachineType::Uint32(),                      // kAddress
+      MachineType::Uint32(),                      // kExpectedValueLow
+      MachineType::Uint32(),                      // kExpectedValueHigh
+      MachineType::Uint32(),                      // kTimeoutLow
+      MachineType::Uint32())                      // kTimeoutHigh
 
-  DEFINE_RESULT_AND_PARAMETER_TYPES(
-      MachineType::Uint32(),  // result 1
-      MachineType::Uint32(),  // kAddress
-      MachineType::Uint32(),  // kExpectedValueLow
-      MachineType::Uint32(),  // kExpectedValueHigh
-      MachineType::Uint32(),  // kTimeoutLow
-      MachineType::Uint32())  // kTimeoutHigh
+#if V8_TARGET_ARCH_IA32
+  static constexpr bool kPassLastArgOnStack = true;
+#else
+  static constexpr bool kPassLastArgOnStack = false;
+#endif
+
+  // Pass the last parameter through the stack.
+  static constexpr int kStackArgumentsCount = kPassLastArgOnStack ? 1 : 0;
 
-  DECLARE_DESCRIPTOR(WasmI64AtomicWait32Descriptor)
+  DECLARE_DESCRIPTOR(WasmI64AtomicWait32Descriptor, CallInterfaceDescriptor)
 };
 
-class CloneObjectWithVectorDescriptor final
-    : public StaticCallInterfaceDescriptor<CloneObjectWithVectorDescriptor> {
+class CloneObjectWithVectorDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kSource, kFlags, kSlot, kVector)
   DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::TaggedPointer(),  // result 1
@@ -1820,43 +1737,38 @@ class CloneObjectWithVectorDescriptor final
                                     MachineType::TaggedSigned(),   // kFlags
                                     MachineType::TaggedSigned(),   // kSlot
                                     MachineType::AnyTagged())      // kVector
-  DECLARE_DESCRIPTOR(CloneObjectWithVectorDescriptor)
+  DECLARE_DESCRIPTOR(CloneObjectWithVectorDescriptor, CallInterfaceDescriptor)
 };
 
-class CloneObjectBaselineDescriptor final
-    : public StaticCallInterfaceDescriptor<CloneObjectBaselineDescriptor> {
+class CloneObjectBaselineDescriptor final : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kSource, kFlags, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),     // kSource
                          MachineType::TaggedSigned(),  // kFlags
                          MachineType::TaggedSigned())  // kSlot
-  DECLARE_DESCRIPTOR(CloneObjectBaselineDescriptor)
+  DECLARE_DESCRIPTOR(CloneObjectBaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class BinaryOp_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<BinaryOp_WithFeedbackDescriptor> {
+class BinaryOp_WithFeedbackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kLeft, kRight, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(BinaryOp_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(BinaryOp_WithFeedbackDescriptor, CallInterfaceDescriptor)
 };
 
-class CallTrampoline_BaselineDescriptor
-    : public StaticCallInterfaceDescriptor<CallTrampoline_BaselineDescriptor> {
+class CallTrampoline_BaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunction, kActualArgumentsCount, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kFunction
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(CallTrampoline_BaselineDescriptor)
+  DECLARE_DESCRIPTOR(CallTrampoline_BaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class CallTrampoline_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<
-          CallTrampoline_WithFeedbackDescriptor> {
+class CallTrampoline_WithFeedbackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_VARARGS(kFunction, kActualArgumentsCount, kSlot,
                             kFeedbackVector)
@@ -1864,75 +1776,69 @@ class CallTrampoline_WithFeedbackDescriptor
                          MachineType::Int32(),      // kActualArgumentsCount
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(CallTrampoline_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(CallTrampoline_WithFeedbackDescriptor,
+                     CallInterfaceDescriptor)
 };
 
-class Compare_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<Compare_WithFeedbackDescriptor> {
+class Compare_WithFeedbackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kLeft, kRight, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(Compare_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(Compare_WithFeedbackDescriptor, CallInterfaceDescriptor)
 };
 
-class Compare_BaselineDescriptor
-    : public StaticCallInterfaceDescriptor<Compare_BaselineDescriptor> {
+class Compare_BaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS_NO_CONTEXT(kLeft, kRight, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kLeft
                          MachineType::AnyTagged(),  // kRight
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(Compare_BaselineDescriptor)
-
-  static constexpr inline auto registers();
+  DECLARE_DESCRIPTOR(Compare_BaselineDescriptor, CallInterfaceDescriptor)
 };
 
-class Construct_BaselineDescriptor
-    : public StaticJSCallInterfaceDescriptor<Construct_BaselineDescriptor> {
+class Construct_BaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_JS_PARAMETERS_NO_CONTEXT(kSlot)
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr())  // kSlot
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_BaselineDescriptor)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_BaselineDescriptor,
+                                   CallInterfaceDescriptor, 1)
 };
 
-class Construct_WithFeedbackDescriptor
-    : public StaticJSCallInterfaceDescriptor<Construct_WithFeedbackDescriptor> {
+class Construct_WithFeedbackDescriptor : public CallInterfaceDescriptor {
  public:
   // kSlot is passed in a register, kFeedbackVector on the stack.
   DEFINE_JS_PARAMETERS(kSlot, kFeedbackVector)
   DEFINE_JS_PARAMETER_TYPES(MachineType::UintPtr(),    // kSlot
                             MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_WithFeedbackDescriptor)
+  DECLARE_JS_COMPATIBLE_DESCRIPTOR(Construct_WithFeedbackDescriptor,
+                                   CallInterfaceDescriptor, 1)
 };
 
-class UnaryOp_WithFeedbackDescriptor
-    : public StaticCallInterfaceDescriptor<UnaryOp_WithFeedbackDescriptor> {
+class UnaryOp_WithFeedbackDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kValue, kSlot, kFeedbackVector)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kValue
                          MachineType::UintPtr(),    // kSlot
                          MachineType::AnyTagged())  // kFeedbackVector
-  DECLARE_DESCRIPTOR(UnaryOp_WithFeedbackDescriptor)
+  DECLARE_DESCRIPTOR(UnaryOp_WithFeedbackDescriptor, CallInterfaceDescriptor)
 };
 
-class UnaryOp_BaselineDescriptor
-    : public StaticCallInterfaceDescriptor<UnaryOp_BaselineDescriptor> {
+class UnaryOp_BaselineDescriptor : public CallInterfaceDescriptor {
  public:
   DEFINE_PARAMETERS(kValue, kSlot)
   DEFINE_PARAMETER_TYPES(MachineType::AnyTagged(),  // kValue
                          MachineType::UintPtr())    // kSlot
-  DECLARE_DESCRIPTOR(UnaryOp_BaselineDescriptor)
+  DECLARE_DESCRIPTOR(UnaryOp_BaselineDescriptor, CallInterfaceDescriptor)
 };
 
-#define DEFINE_TFS_BUILTIN_DESCRIPTOR(Name, ...)                 \
-  class Name##Descriptor                                         \
-      : public StaticCallInterfaceDescriptor<Name##Descriptor> { \
-   public:                                                       \
-    DEFINE_PARAMETERS(__VA_ARGS__)                               \
-    DECLARE_DEFAULT_DESCRIPTOR(Name##Descriptor)                 \
+#define DEFINE_TFS_BUILTIN_DESCRIPTOR(Name, ...)                          \
+  class Name##Descriptor : public CallInterfaceDescriptor {               \
+   public:                                                                \
+    DEFINE_PARAMETERS(__VA_ARGS__)                                        \
+    DECLARE_DEFAULT_DESCRIPTOR(Name##Descriptor, CallInterfaceDescriptor) \
   };
 BUILTIN_LIST_TFS(DEFINE_TFS_BUILTIN_DESCRIPTOR)
 #undef DEFINE_TFS_BUILTIN_DESCRIPTOR
@@ -1946,12 +1852,11 @@ BUILTIN_LIST_TFS(DEFINE_TFS_BUILTIN_DESCRIPTOR)
 #undef DECLARE_DESCRIPTOR_WITH_BASE
 #undef DECLARE_DESCRIPTOR
 #undef DECLARE_JS_COMPATIBLE_DESCRIPTOR
+#undef DEFINE_FLAGS_AND_RESULT_AND_PARAMETERS
 #undef DEFINE_RESULT_AND_PARAMETERS
-#undef DEFINE_PARAMETERS_ENTRY
 #undef DEFINE_PARAMETERS
 #undef DEFINE_PARAMETERS_VARARGS
 #undef DEFINE_PARAMETERS_NO_CONTEXT
-#undef DEFINE_RESULT_AND_PARAMETERS_NO_CONTEXT
 #undef DEFINE_RESULT_AND_PARAMETER_TYPES
 #undef DEFINE_PARAMETER_TYPES
 #undef DEFINE_JS_PARAMETERS
diff --git a/src/codegen/register-arch.h b/src/codegen/register-arch.h
index eb4cdb8789..3936ee80cc 100644
--- a/src/codegen/register-arch.h
+++ b/src/codegen/register-arch.h
@@ -41,27 +41,6 @@ constexpr bool ShouldPadArguments(int argument_count) {
   return ArgumentPaddingSlots(argument_count) != 0;
 }
 
-#ifdef DEBUG
-struct CountIfValidRegisterFunctor {
-  template <typename RegType>
-  constexpr int operator()(int count, RegType reg) const {
-    return count + (reg.is_valid() ? 1 : 0);
-  }
-};
-
-template <typename RegType, typename... RegTypes,
-          // All arguments must be either Register or DoubleRegister.
-          typename = typename std::enable_if<
-              base::is_same<Register, RegType, RegTypes...>::value ||
-              base::is_same<DoubleRegister, RegType, RegTypes...>::value>::type>
-inline constexpr bool AreAliased(RegType first_reg, RegTypes... regs) {
-  int num_different_regs = NumRegs(RegType::ListOf(first_reg, regs...));
-  int num_given_regs =
-      base::fold(CountIfValidRegisterFunctor{}, 0, first_reg, regs...);
-  return num_different_regs < num_given_regs;
-}
-#endif
-
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/codegen/turbo-assembler.h b/src/codegen/turbo-assembler.h
index 98267fdcfa..ee1eae49c4 100644
--- a/src/codegen/turbo-assembler.h
+++ b/src/codegen/turbo-assembler.h
@@ -165,6 +165,27 @@ class V8_NODISCARD HardAbortScope {
   bool old_value_;
 };
 
+#ifdef DEBUG
+struct CountIfValidRegisterFunctor {
+  template <typename RegType>
+  constexpr int operator()(int count, RegType reg) const {
+    return count + (reg.is_valid() ? 1 : 0);
+  }
+};
+
+template <typename RegType, typename... RegTypes,
+          // All arguments must be either Register or DoubleRegister.
+          typename = typename std::enable_if<
+              base::is_same<Register, RegType, RegTypes...>::value ||
+              base::is_same<DoubleRegister, RegType, RegTypes...>::value>::type>
+inline bool AreAliased(RegType first_reg, RegTypes... regs) {
+  int num_different_regs = NumRegs(RegType::ListOf(first_reg, regs...));
+  int num_given_regs =
+      base::fold(CountIfValidRegisterFunctor{}, 0, first_reg, regs...);
+  return num_different_regs < num_given_regs;
+}
+#endif
+
 }  // namespace internal
 }  // namespace v8
 
diff --git a/src/codegen/x64/interface-descriptors-x64-inl.h b/src/codegen/x64/interface-descriptors-x64-inl.h
deleted file mode 100644
index e5cc5df4f2..0000000000
--- a/src/codegen/x64/interface-descriptors-x64-inl.h
+++ /dev/null
@@ -1,263 +0,0 @@
-// Copyright 2021 the V8 project authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef V8_CODEGEN_X64_INTERFACE_DESCRIPTORS_X64_INL_H_
-#define V8_CODEGEN_X64_INTERFACE_DESCRIPTORS_X64_INL_H_
-
-#if V8_TARGET_ARCH_X64
-
-#include "src/codegen/interface-descriptors.h"
-
-namespace v8 {
-namespace internal {
-
-constexpr auto CallInterfaceDescriptor::DefaultRegisterArray() {
-  auto registers = RegisterArray(rax, rbx, rcx, rdx, rdi);
-  STATIC_ASSERT(registers.size() == kMaxBuiltinRegisterParams);
-  return registers;
-}
-
-// static
-constexpr auto RecordWriteDescriptor::registers() {
-  return RegisterArray(arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4,
-                       kReturnRegister0);
-}
-
-// static
-constexpr auto DynamicCheckMapsDescriptor::registers() {
-  return RegisterArray(kReturnRegister0, arg_reg_1, arg_reg_2, arg_reg_3,
-                       kRuntimeCallFunctionRegister, kContextRegister);
-}
-
-// static
-constexpr auto EphemeronKeyBarrierDescriptor::registers() {
-  return RegisterArray(arg_reg_1, arg_reg_2, arg_reg_3, arg_reg_4,
-                       kReturnRegister0);
-}
-
-// static
-constexpr Register LoadDescriptor::ReceiverRegister() { return rdx; }
-// static
-constexpr Register LoadDescriptor::NameRegister() { return rcx; }
-// static
-constexpr Register LoadDescriptor::SlotRegister() { return rax; }
-
-// static
-constexpr Register LoadWithVectorDescriptor::VectorRegister() { return rbx; }
-
-// static
-constexpr Register
-LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
-  return rdi;
-}
-
-// static
-constexpr Register StoreDescriptor::ReceiverRegister() { return rdx; }
-// static
-constexpr Register StoreDescriptor::NameRegister() { return rcx; }
-// static
-constexpr Register StoreDescriptor::ValueRegister() { return rax; }
-// static
-constexpr Register StoreDescriptor::SlotRegister() { return rdi; }
-
-// static
-constexpr Register StoreWithVectorDescriptor::VectorRegister() { return rbx; }
-
-// static
-constexpr Register StoreTransitionDescriptor::MapRegister() { return r11; }
-
-// static
-constexpr Register ApiGetterDescriptor::HolderRegister() { return rcx; }
-// static
-constexpr Register ApiGetterDescriptor::CallbackRegister() { return rbx; }
-
-// static
-constexpr Register GrowArrayElementsDescriptor::ObjectRegister() { return rax; }
-// static
-constexpr Register GrowArrayElementsDescriptor::KeyRegister() { return rbx; }
-
-// static
-constexpr Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
-  return rbx;
-}
-// static
-constexpr Register BaselineLeaveFrameDescriptor::WeightRegister() {
-  return rcx;
-}
-
-// static
-constexpr Register TypeConversionDescriptor::ArgumentRegister() { return rax; }
-
-// static
-constexpr auto TypeofDescriptor::registers() { return RegisterArray(rbx); }
-
-// static
-constexpr auto CallTrampolineDescriptor::registers() {
-  // rax : number of arguments
-  // rdi : the target to call
-  return RegisterArray(rdi, rax);
-}
-
-// static
-constexpr auto CallVarargsDescriptor::registers() {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rcx : arguments list length (untagged)
-  // rbx : arguments list (FixedArray)
-  return RegisterArray(rdi, rax, rcx, rbx);
-}
-
-// static
-constexpr auto CallForwardVarargsDescriptor::registers() {
-  // rax : number of arguments
-  // rcx : start index (to support rest parameters)
-  // rdi : the target to call
-  return RegisterArray(rdi, rax, rcx);
-}
-
-// static
-constexpr auto CallFunctionTemplateDescriptor::registers() {
-  // rdx: the function template info
-  // rcx: number of arguments (on the stack, not including receiver)
-  return RegisterArray(rdx, rcx);
-}
-
-// static
-constexpr auto CallWithSpreadDescriptor::registers() {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rbx : the object to spread
-  return RegisterArray(rdi, rax, rbx);
-}
-
-// static
-constexpr auto CallWithArrayLikeDescriptor::registers() {
-  // rdi : the target to call
-  // rbx : the arguments list
-  return RegisterArray(rdi, rbx);
-}
-
-// static
-constexpr auto ConstructVarargsDescriptor::registers() {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rdx : the new target
-  // rcx : arguments list length (untagged)
-  // rbx : arguments list (FixedArray)
-  return RegisterArray(rdi, rdx, rax, rcx, rbx);
-}
-
-// static
-constexpr auto ConstructForwardVarargsDescriptor::registers() {
-  // rax : number of arguments
-  // rdx : the new target
-  // rcx : start index (to support rest parameters)
-  // rdi : the target to call
-  return RegisterArray(rdi, rdx, rax, rcx);
-}
-
-// static
-constexpr auto ConstructWithSpreadDescriptor::registers() {
-  // rax : number of arguments (on the stack, not including receiver)
-  // rdi : the target to call
-  // rdx : the new target
-  // rbx : the object to spread
-  return RegisterArray(rdi, rdx, rax, rbx);
-}
-
-// static
-constexpr auto ConstructWithArrayLikeDescriptor::registers() {
-  // rdi : the target to call
-  // rdx : the new target
-  // rbx : the arguments list
-  return RegisterArray(rdi, rdx, rbx);
-}
-
-// static
-constexpr auto ConstructStubDescriptor::registers() {
-  // rax : number of arguments
-  // rdx : the new target
-  // rdi : the target to call
-  // rbx : allocation site or undefined
-  return RegisterArray(rdi, rdx, rax, rbx);
-}
-
-// static
-constexpr auto AbortDescriptor::registers() { return RegisterArray(rdx); }
-
-// static
-constexpr auto CompareDescriptor::registers() {
-  return RegisterArray(rdx, rax);
-}
-
-// static
-constexpr auto BinaryOpDescriptor::registers() {
-  return RegisterArray(rdx, rax);
-}
-
-// static
-constexpr auto Compare_BaselineDescriptor::registers() {
-  return RegisterArray(rdx, rax, rbx);
-}
-
-// static
-constexpr auto BinaryOp_BaselineDescriptor::registers() {
-  return RegisterArray(rdx, rax, rbx);
-}
-
-// static
-constexpr auto ApiCallbackDescriptor::registers() {
-  return RegisterArray(rdx,   // api function address
-                       rcx,   // argument count (not including receiver)
-                       rbx,   // call data
-                       rdi);  // holder
-}
-
-// static
-constexpr auto InterpreterDispatchDescriptor::registers() {
-  return RegisterArray(
-      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
-      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister);
-}
-
-// static
-constexpr auto InterpreterPushArgsThenCallDescriptor::registers() {
-  return RegisterArray(rax,   // argument count (not including receiver)
-                       rbx,   // address of first argument
-                       rdi);  // the target callable to be call
-}
-
-// static
-constexpr auto InterpreterPushArgsThenConstructDescriptor::registers() {
-  return RegisterArray(
-      rax,   // argument count (not including receiver)
-      rcx,   // address of first argument
-      rdi,   // constructor to call
-      rdx,   // new target
-      rbx);  // allocation site feedback if available, undefined otherwise
-}
-
-// static
-constexpr auto ResumeGeneratorDescriptor::registers() {
-  return RegisterArray(
-      rax,   // the value to pass to the generator
-      rdx);  // the JSGeneratorObject / JSAsyncGeneratorObject to resume
-}
-
-// static
-constexpr auto FrameDropperTrampolineDescriptor::registers() {
-  return RegisterArray(rbx);  // loaded new FP
-}
-
-// static
-constexpr auto RunMicrotasksEntryDescriptor::registers() {
-  return RegisterArray(arg_reg_1, arg_reg_2);
-}
-
-}  // namespace internal
-}  // namespace v8
-
-#endif  // V8_TARGET_ARCH_X64
-
-#endif  // V8_CODEGEN_X64_INTERFACE_DESCRIPTORS_X64_INL_H_
diff --git a/src/codegen/x64/interface-descriptors-x64.cc b/src/codegen/x64/interface-descriptors-x64.cc
new file mode 100644
index 0000000000..4029b56d2b
--- /dev/null
+++ b/src/codegen/x64/interface-descriptors-x64.cc
@@ -0,0 +1,309 @@
+// Copyright 2012 the V8 project authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#if V8_TARGET_ARCH_X64
+
+#include "src/codegen/interface-descriptors.h"
+
+#include "src/execution/frames.h"
+
+namespace v8 {
+namespace internal {
+
+const Register CallInterfaceDescriptor::ContextRegister() { return rsi; }
+
+void CallInterfaceDescriptor::DefaultInitializePlatformSpecific(
+    CallInterfaceDescriptorData* data, int register_parameter_count) {
+  const Register default_stub_registers[] = {rax, rbx, rcx, rdx, rdi};
+  CHECK_LE(static_cast<size_t>(register_parameter_count),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(register_parameter_count,
+                                   default_stub_registers);
+}
+
+void RecordWriteDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {arg_reg_1, arg_reg_2, arg_reg_3,
+                                             arg_reg_4, kReturnRegister0};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void DynamicCheckMapsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register default_stub_registers[] = {kReturnRegister0,
+                                       arg_reg_1,
+                                       arg_reg_2,
+                                       arg_reg_3,
+                                       kRuntimeCallFunctionRegister,
+                                       kContextRegister};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+void EphemeronKeyBarrierDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  const Register default_stub_registers[] = {arg_reg_1, arg_reg_2, arg_reg_3,
+                                             arg_reg_4, kReturnRegister0};
+
+  data->RestrictAllocatableRegisters(default_stub_registers,
+                                     arraysize(default_stub_registers));
+
+  CHECK_LE(static_cast<size_t>(kParameterCount),
+           arraysize(default_stub_registers));
+  data->InitializePlatformSpecific(kParameterCount, default_stub_registers);
+}
+
+const Register LoadDescriptor::ReceiverRegister() { return rdx; }
+const Register LoadDescriptor::NameRegister() { return rcx; }
+const Register LoadDescriptor::SlotRegister() { return rax; }
+
+const Register LoadWithVectorDescriptor::VectorRegister() { return rbx; }
+
+const Register
+LoadWithReceiverAndVectorDescriptor::LookupStartObjectRegister() {
+  return rdi;
+}
+
+const Register StoreDescriptor::ReceiverRegister() { return rdx; }
+const Register StoreDescriptor::NameRegister() { return rcx; }
+const Register StoreDescriptor::ValueRegister() { return rax; }
+const Register StoreDescriptor::SlotRegister() { return rdi; }
+
+const Register StoreWithVectorDescriptor::VectorRegister() { return rbx; }
+
+const Register StoreTransitionDescriptor::SlotRegister() { return rdi; }
+const Register StoreTransitionDescriptor::VectorRegister() { return rbx; }
+const Register StoreTransitionDescriptor::MapRegister() { return r11; }
+
+const Register ApiGetterDescriptor::HolderRegister() { return rcx; }
+const Register ApiGetterDescriptor::CallbackRegister() { return rbx; }
+
+const Register GrowArrayElementsDescriptor::ObjectRegister() { return rax; }
+const Register GrowArrayElementsDescriptor::KeyRegister() { return rbx; }
+
+const Register BaselineLeaveFrameDescriptor::ParamsSizeRegister() {
+  return rbx;
+}
+const Register BaselineLeaveFrameDescriptor::WeightRegister() { return rcx; }
+
+void TypeofDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+// static
+const Register TypeConversionDescriptor::ArgumentRegister() { return rax; }
+
+void CallTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments
+  // rdi : the target to call
+  Register registers[] = {rdi, rax};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rcx : arguments list length (untagged)
+  // rbx : arguments list (FixedArray)
+  Register registers[] = {rdi, rax, rcx, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments
+  // rcx : start index (to support rest parameters)
+  // rdi : the target to call
+  Register registers[] = {rdi, rax, rcx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallFunctionTemplateDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rdx: the function template info
+  // rcx: number of arguments (on the stack, not including receiver)
+  Register registers[] = {rdx, rcx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rbx : the object to spread
+  Register registers[] = {rdi, rax, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CallWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rdi : the target to call
+  // rbx : the arguments list
+  Register registers[] = {rdi, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rdx : the new target
+  // rcx : arguments list length (untagged)
+  // rbx : arguments list (FixedArray)
+  Register registers[] = {rdi, rdx, rax, rcx, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructForwardVarargsDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments
+  // rdx : the new target
+  // rcx : start index (to support rest parameters)
+  // rdi : the target to call
+  Register registers[] = {rdi, rdx, rax, rcx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithSpreadDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments (on the stack, not including receiver)
+  // rdi : the target to call
+  // rdx : the new target
+  // rbx : the object to spread
+  Register registers[] = {rdi, rdx, rax, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructWithArrayLikeDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rdi : the target to call
+  // rdx : the new target
+  // rbx : the arguments list
+  Register registers[] = {rdi, rdx, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ConstructStubDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  // rax : number of arguments
+  // rdx : the new target
+  // rdi : the target to call
+  // rbx : allocation site or undefined
+  Register registers[] = {rdi, rdx, rax, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void AbortDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {rdx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void CompareDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {rdx, rax};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void Compare_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {rdx, rax, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOpDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {rdx, rax};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void BinaryOp_BaselineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {rdx, rax, rbx};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ApiCallbackDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      rdx,  // api function address
+      rcx,  // argument count (not including receiver)
+      rbx,  // call data
+      rdi,  // holder
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterDispatchDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      kInterpreterAccumulatorRegister, kInterpreterBytecodeOffsetRegister,
+      kInterpreterBytecodeArrayRegister, kInterpreterDispatchTableRegister};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenCallDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      rax,  // argument count (not including receiver)
+      rbx,  // address of first argument
+      rdi   // the target callable to be call
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void InterpreterPushArgsThenConstructDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      rax,  // argument count (not including receiver)
+      rcx,  // address of first argument
+      rdi,  // constructor to call
+      rdx,  // new target
+      rbx,  // allocation site feedback if available, undefined otherwise
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void ResumeGeneratorDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      rax,  // the value to pass to the generator
+      rdx   // the JSGeneratorObject / JSAsyncGeneratorObject to resume
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void FrameDropperTrampolineDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {
+      rbx,  // loaded new FP
+  };
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+void RunMicrotasksEntryDescriptor::InitializePlatformSpecific(
+    CallInterfaceDescriptorData* data) {
+  Register registers[] = {arg_reg_1, arg_reg_2};
+  data->InitializePlatformSpecific(arraysize(registers), registers);
+}
+
+}  // namespace internal
+}  // namespace v8
+
+#endif  // V8_TARGET_ARCH_X64
diff --git a/src/codegen/x64/macro-assembler-x64.cc b/src/codegen/x64/macro-assembler-x64.cc
index 4992f0b5fb..e3d00e3489 100644
--- a/src/codegen/x64/macro-assembler-x64.cc
+++ b/src/codegen/x64/macro-assembler-x64.cc
@@ -12,7 +12,6 @@
 #include "src/codegen/code-factory.h"
 #include "src/codegen/cpu-features.h"
 #include "src/codegen/external-reference-table.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/register-configuration.h"
 #include "src/codegen/string-constants.h"
diff --git a/src/compiler/backend/instruction-selector.cc b/src/compiler/backend/instruction-selector.cc
index ad59f63944..5a38328832 100644
--- a/src/compiler/backend/instruction-selector.cc
+++ b/src/compiler/backend/instruction-selector.cc
@@ -9,7 +9,6 @@
 #include "src/base/iterator.h"
 #include "src/base/platform/wrappers.h"
 #include "src/codegen/assembler-inl.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/tick-counter.h"
 #include "src/compiler/backend/instruction-selector-impl.h"
 #include "src/compiler/compiler-source-position-table.h"
diff --git a/src/compiler/code-assembler.cc b/src/compiler/code-assembler.cc
index 8ff1777366..a2cb595a5e 100644
--- a/src/compiler/code-assembler.cc
+++ b/src/compiler/code-assembler.cc
@@ -8,7 +8,7 @@
 
 #include "src/base/bits.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/compiler/backend/instruction-selector.h"
diff --git a/src/compiler/effect-control-linearizer.cc b/src/compiler/effect-control-linearizer.cc
index 9bdf7a12dd..9eedc5b8d8 100644
--- a/src/compiler/effect-control-linearizer.cc
+++ b/src/compiler/effect-control-linearizer.cc
@@ -7,7 +7,6 @@
 #include "include/v8-fast-api-calls.h"
 #include "src/base/bits.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/codegen/machine-type.h"
 #include "src/common/ptr-compr-inl.h"
 #include "src/compiler/access-builder.h"
diff --git a/src/compiler/js-generic-lowering.cc b/src/compiler/js-generic-lowering.cc
index 935e4460ce..71a0d43a41 100644
--- a/src/compiler/js-generic-lowering.cc
+++ b/src/compiler/js-generic-lowering.cc
@@ -7,7 +7,6 @@
 #include "src/ast/ast.h"
 #include "src/builtins/builtins-constructor.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/compiler/access-builder.h"
 #include "src/compiler/common-operator.h"
 #include "src/compiler/js-graph.h"
diff --git a/src/compiler/js-typed-lowering.cc b/src/compiler/js-typed-lowering.cc
index 2525b41e8c..008aacdb39 100644
--- a/src/compiler/js-typed-lowering.cc
+++ b/src/compiler/js-typed-lowering.cc
@@ -7,7 +7,6 @@
 #include "src/ast/modules.h"
 #include "src/builtins/builtins-utils.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/compiler/access-builder.h"
 #include "src/compiler/allocation-builder.h"
 #include "src/compiler/graph-assembler.h"
diff --git a/src/compiler/memory-lowering.cc b/src/compiler/memory-lowering.cc
index f27aa9391f..2014fd228d 100644
--- a/src/compiler/memory-lowering.cc
+++ b/src/compiler/memory-lowering.cc
@@ -4,7 +4,7 @@
 
 #include "src/compiler/memory-lowering.h"
 
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/common/external-pointer.h"
 #include "src/compiler/access-builder.h"
 #include "src/compiler/js-graph.h"
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 42e8c76bbc..5669c35355 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -16,7 +16,7 @@
 #include "src/codegen/assembler.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/compiler.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/optimized-compilation-info.h"
 #include "src/compiler/backend/code-generator.h"
diff --git a/src/ic/accessor-assembler.cc b/src/ic/accessor-assembler.cc
index 787c3236e7..7ef16febd8 100644
--- a/src/ic/accessor-assembler.cc
+++ b/src/ic/accessor-assembler.cc
@@ -8,7 +8,6 @@
 #include "src/base/optional.h"
 #include "src/builtins/builtins-constructor-gen.h"
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/ic/handler-configuration.h"
 #include "src/ic/ic.h"
 #include "src/ic/keyed-store-generic.h"
@@ -1508,6 +1507,7 @@ void AccessorAssembler::HandleStoreAccessor(const StoreICParameters* p,
       LoadObjectField(accessor_pair, AccessorPair::kSetterOffset);
   CSA_ASSERT(this, Word32BinaryNot(IsTheHole(setter)));
 
+  Callable callable = CodeFactory::Call(isolate());
   Return(Call(p->context(), setter, p->receiver(), p->value()));
 }
 
diff --git a/src/interpreter/interpreter-assembler.cc b/src/interpreter/interpreter-assembler.cc
index 730e9ee19b..df5b525877 100644
--- a/src/interpreter/interpreter-assembler.cc
+++ b/src/interpreter/interpreter-assembler.cc
@@ -8,7 +8,7 @@
 #include <ostream>
 
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/machine-type.h"
 #include "src/execution/frames.h"
 #include "src/interpreter/bytecodes.h"
diff --git a/src/snapshot/embedded/embedded-data.cc b/src/snapshot/embedded/embedded-data.cc
index 2fac12b6f9..be7a9dd33c 100644
--- a/src/snapshot/embedded/embedded-data.cc
+++ b/src/snapshot/embedded/embedded-data.cc
@@ -6,7 +6,6 @@
 
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/callable.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/objects/objects-inl.h"
 #include "src/snapshot/snapshot-utils.h"
 #include "src/snapshot/snapshot.h"
@@ -188,15 +187,14 @@ bool BuiltinAliasesOffHeapTrampolineRegister(Isolate* isolate, Code code) {
       return false;
   }
 
-  if (CallInterfaceDescriptor::ContextRegister() ==
-      kOffHeapTrampolineRegister) {
-    return true;
-  }
-
   Callable callable = Builtins::CallableFor(
       isolate, static_cast<Builtins::Name>(code.builtin_index()));
   CallInterfaceDescriptor descriptor = callable.descriptor();
 
+  if (descriptor.ContextRegister() == kOffHeapTrampolineRegister) {
+    return true;
+  }
+
   for (int i = 0; i < descriptor.GetRegisterParameterCount(); i++) {
     Register reg = descriptor.GetRegisterParameter(i);
     if (reg == kOffHeapTrampolineRegister) return true;
diff --git a/src/torque/implementation-visitor.cc b/src/torque/implementation-visitor.cc
index d1bd822679..7c4b6a80cc 100644
--- a/src/torque/implementation-visitor.cc
+++ b/src/torque/implementation-visitor.cc
@@ -658,8 +658,8 @@ void ImplementationVisitor::Visit(Builtin* builtin) {
   } else {
     DCHECK(builtin->IsStub());
 
+    bool has_context_parameter = signature.HasContextParameter();
     for (size_t i = 0; i < signature.parameter_names.size(); ++i) {
-      const std::string& parameter_name = signature.parameter_names[i]->value;
       const Type* type = signature.types()[i];
       const bool mark_as_used = signature.implicit_count > i;
       std::string var = AddParameter(i, builtin, &parameters, &parameter_types,
@@ -667,8 +667,14 @@ void ImplementationVisitor::Visit(Builtin* builtin) {
       csa_ccfile() << "  " << type->GetGeneratedTypeName() << " " << var
                    << " = "
                    << "UncheckedParameter<" << type->GetGeneratedTNodeTypeName()
-                   << ">(Descriptor::k" << CamelifyString(parameter_name)
-                   << ");\n";
+                   << ">(";
+      if (i == 0 && has_context_parameter) {
+        csa_ccfile() << "Descriptor::kContext";
+      } else {
+        csa_ccfile() << "Descriptor::ParameterIndex<"
+                     << (has_context_parameter ? i - 1 : i) << ">()";
+      }
+      csa_ccfile() << ");\n";
       csa_ccfile() << "  USE(" << var << ");\n";
     }
   }
@@ -3431,40 +3437,40 @@ void ImplementationVisitor::GenerateBuiltinDefinitionsAndInterfaceDescriptors(
         std::string descriptor_name = builtin->ExternalName() + "Descriptor";
         bool has_context_parameter = builtin->signature().HasContextParameter();
         size_t kFirstNonContextParameter = has_context_parameter ? 1 : 0;
+        size_t parameter_count =
+            builtin->parameter_names().size() - kFirstNonContextParameter;
         TypeVector return_types = LowerType(builtin->signature().return_type);
 
-        interface_descriptors << "class " << descriptor_name
-                              << " : public StaticCallInterfaceDescriptor<"
-                              << descriptor_name << "> {\n";
-
-        interface_descriptors << " public:\n";
-
-        if (has_context_parameter) {
-          interface_descriptors << "  DEFINE_RESULT_AND_PARAMETERS(";
-        } else {
-          interface_descriptors << "  DEFINE_RESULT_AND_PARAMETERS_NO_CONTEXT(";
-        }
-        interface_descriptors << return_types.size();
-        for (size_t i = kFirstNonContextParameter;
-             i < builtin->parameter_names().size(); ++i) {
-          Identifier* parameter = builtin->parameter_names()[i];
-          interface_descriptors << ", k" << CamelifyString(parameter->value);
-        }
-        interface_descriptors << ")\n";
-
-        interface_descriptors << "  DEFINE_RESULT_AND_PARAMETER_TYPES(";
+        interface_descriptors
+            << "class " << descriptor_name
+            << " : public TorqueInterfaceDescriptor<" << return_types.size()
+            << ", " << parameter_count << ", "
+            << (has_context_parameter ? "true" : "false") << "> {\n";
+        interface_descriptors << "  DECLARE_DESCRIPTOR_WITH_BASE("
+                              << descriptor_name
+                              << ", TorqueInterfaceDescriptor)\n";
+
+        interface_descriptors
+            << "  std::vector<MachineType> ReturnType() override {\n";
+        interface_descriptors << "    return {{";
         PrintCommaSeparatedList(interface_descriptors, return_types,
                                 MachineTypeString);
+        interface_descriptors << "}};\n";
+        interface_descriptors << "  }\n";
+
+        interface_descriptors << "  std::array<MachineType, " << parameter_count
+                              << "> ParameterTypes() override {\n";
+        interface_descriptors << "    return {";
         for (size_t i = kFirstNonContextParameter;
              i < builtin->parameter_names().size(); ++i) {
+          bool last = i + 1 == builtin->parameter_names().size();
           const Type* type = builtin->signature().parameter_types.types[i];
-          interface_descriptors << ", " << MachineTypeString(type);
+          interface_descriptors << MachineTypeString(type)
+                                << (last ? "" : ", ");
         }
-        interface_descriptors << ")\n";
-
-        interface_descriptors << "  DECLARE_DEFAULT_DESCRIPTOR("
-                              << descriptor_name << ")\n";
+        interface_descriptors << "};\n";
 
+        interface_descriptors << "  }\n";
         interface_descriptors << "};\n\n";
       } else {
         builtin_definitions << "TFJ(" << builtin->ExternalName();
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index f92b4dd6d4..590f807a9d 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -10,7 +10,7 @@
 #include "src/codegen/assembler-inl.h"
 // TODO(clemensb): Remove dependences on compiler stuff.
 #include "src/codegen/external-reference.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/compiler/linkage.h"
diff --git a/test/cctest/test-code-stub-assembler.cc b/test/cctest/test-code-stub-assembler.cc
index 326e08fb2e..67aafa8709 100644
--- a/test/cctest/test-code-stub-assembler.cc
+++ b/test/cctest/test-code-stub-assembler.cc
@@ -11,7 +11,6 @@
 #include "src/builtins/builtins-string-gen.h"
 #include "src/codegen/code-factory.h"
 #include "src/codegen/code-stub-assembler.h"
-#include "src/codegen/interface-descriptors-inl.h"
 #include "src/compiler/node.h"
 #include "src/debug/debug.h"
 #include "src/execution/isolate.h"
@@ -2025,7 +2024,7 @@ TEST(PopAndReturnFromTFCBuiltinWithStackParameters) {
   // least one argument passed on stack.
   using Descriptor = FlatMapIntoArrayDescriptor;
   Descriptor descriptor;
-  CHECK_LT(0, Descriptor::GetStackParameterCount());
+  CHECK_LT(0, descriptor.GetStackParameterCount());
 
   CodeAssemblerTester asm_tester(isolate, Descriptor());
   {
diff --git a/test/unittests/codegen/code-stub-assembler-unittest.cc b/test/unittests/codegen/code-stub-assembler-unittest.cc
index 121190bdb8..6137b3425a 100644
--- a/test/unittests/codegen/code-stub-assembler-unittest.cc
+++ b/test/unittests/codegen/code-stub-assembler-unittest.cc
@@ -5,7 +5,7 @@
 #include "test/unittests/codegen/code-stub-assembler-unittest.h"
 
 #include "src/codegen/code-factory.h"
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/compiler/node.h"
 #include "src/execution/isolate.h"
 #include "src/objects/objects-inl.h"
diff --git a/test/unittests/compiler/int64-lowering-unittest.cc b/test/unittests/compiler/int64-lowering-unittest.cc
index d8890b866c..8eafd4fe15 100644
--- a/test/unittests/compiler/int64-lowering-unittest.cc
+++ b/test/unittests/compiler/int64-lowering-unittest.cc
@@ -4,7 +4,7 @@
 
 #include "src/compiler/int64-lowering.h"
 
-#include "src/codegen/interface-descriptors-inl.h"
+#include "src/codegen/interface-descriptors.h"
 #include "src/codegen/machine-type.h"
 #include "src/codegen/signature.h"
 #include "src/compiler/common-operator.h"
@@ -1063,20 +1063,20 @@ TEST_F(Int64LoweringTest, WasmBigIntSpecialCaseBigIntToI64) {
 
   CallDescriptor* bigint_to_i64_call_descriptor =
       Linkage::GetStubCallDescriptor(
-          zone(),                                           // zone
-          BigIntToI64Descriptor(),                          // descriptor
-          BigIntToI64Descriptor::GetStackParameterCount(),  // stack parameter
-                                                            // count
-          CallDescriptor::kNoFlags,                         // flags
-          Operator::kNoProperties,                          // properties
-          StubCallMode::kCallCodeObject);                   // stub call mode
+          zone(),                   // zone
+          BigIntToI64Descriptor(),  // descriptor
+          BigIntToI64Descriptor()
+              .GetStackParameterCount(),   // stack parameter count
+          CallDescriptor::kNoFlags,        // flags
+          Operator::kNoProperties,         // properties
+          StubCallMode::kCallCodeObject);  // stub call mode
 
   CallDescriptor* bigint_to_i32_pair_call_descriptor =
       Linkage::GetStubCallDescriptor(
           zone(),                       // zone
           BigIntToI32PairDescriptor(),  // descriptor
-          BigIntToI32PairDescriptor::
-              GetStackParameterCount(),    // stack parameter count
+          BigIntToI32PairDescriptor()
+              .GetStackParameterCount(),   // stack parameter count
           CallDescriptor::kNoFlags,        // flags
           Operator::kNoProperties,         // properties
           StubCallMode::kCallCodeObject);  // stub call mode
@@ -1109,20 +1109,20 @@ TEST_F(Int64LoweringTest, WasmBigIntSpecialCaseI64ToBigInt) {
 
   CallDescriptor* i64_to_bigint_call_descriptor =
       Linkage::GetStubCallDescriptor(
-          zone(),                                           // zone
-          I64ToBigIntDescriptor(),                          // descriptor
-          I64ToBigIntDescriptor::GetStackParameterCount(),  // stack parameter
-                                                            // count
-          CallDescriptor::kNoFlags,                         // flags
-          Operator::kNoProperties,                          // properties
-          StubCallMode::kCallCodeObject);                   // stub call mode
+          zone(),                   // zone
+          I64ToBigIntDescriptor(),  // descriptor
+          I64ToBigIntDescriptor()
+              .GetStackParameterCount(),   // stack parameter count
+          CallDescriptor::kNoFlags,        // flags
+          Operator::kNoProperties,         // properties
+          StubCallMode::kCallCodeObject);  // stub call mode
 
   CallDescriptor* i32_pair_to_bigint_call_descriptor =
       Linkage::GetStubCallDescriptor(
           zone(),                       // zone
           I32PairToBigIntDescriptor(),  // descriptor
-          I32PairToBigIntDescriptor::
-              GetStackParameterCount(),    // stack parameter count
+          I32PairToBigIntDescriptor()
+              .GetStackParameterCount(),   // stack parameter count
           CallDescriptor::kNoFlags,        // flags
           Operator::kNoProperties,         // properties
           StubCallMode::kCallCodeObject);  // stub call mode
-- 
2.35.1


From b8440171c9bb6fab65a6d6a7e00c688e9186c4fd Mon Sep 17 00:00:00 2001
From: Thibaud Michaud <thibaudm@chromium.org>
Date: Fri, 14 Jan 2022 15:20:07 +0100
Subject: [PATCH] [wasm] Add suspend wrapper stub
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

- Add suspend asm builtin stub, and call it from the suspending
wasm-to-js wrapper
- Rename frame type to match both builtins (prompt and suspend)
- Add suspend bool to the import cache key

R=ahaas@chromium.org
CC=​​fgm@chromium.org

Bug: v8:12191
Change-Id: Ie5a8ca7cbe4bcb91697e05b6470e3d632d608993
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3345004
Reviewed-by: Jakob Kummerow <jkummerow@chromium.org>
Reviewed-by: Andreas Haas <ahaas@chromium.org>
Commit-Queue: Thibaud Michaud <thibaudm@chromium.org>
Cr-Commit-Position: refs/heads/main@{#78628}
---
 src/builtins/arm/builtins-arm.cc              |  5 +++
 src/builtins/arm64/builtins-arm64.cc          |  5 +++
 src/builtins/builtins-definitions.h           |  1 +
 src/builtins/ia32/builtins-ia32.cc            |  5 +++
 src/builtins/loong64/builtins-loong64.cc      |  5 +++
 src/builtins/mips/builtins-mips.cc            |  5 +++
 src/builtins/mips64/builtins-mips64.cc        |  5 +++
 src/builtins/ppc/builtins-ppc.cc              |  5 +++
 src/builtins/riscv64/builtins-riscv64.cc      |  5 +++
 src/builtins/s390/builtins-s390.cc            |  5 +++
 src/builtins/x64/builtins-x64.cc              | 11 ++++--
 src/codegen/interface-descriptors.h           |  9 +++++
 src/compiler/wasm-compiler.cc                 | 23 ++++++++++---
 src/compiler/wasm-compiler.h                  |  6 ++--
 src/execution/frames-inl.h                    |  3 +-
 src/execution/frames.cc                       | 18 +++++-----
 src/execution/frames.h                        |  8 ++---
 src/wasm/function-compiler.cc                 |  2 +-
 src/wasm/module-compiler.cc                   | 10 +++---
 src/wasm/module-compiler.h                    |  3 +-
 src/wasm/module-instantiate.cc                | 21 ++++++++----
 src/wasm/wasm-code-manager.h                  |  3 +-
 src/wasm/wasm-import-wrapper-cache.cc         | 10 +++---
 src/wasm/wasm-import-wrapper-cache.h          | 14 ++++----
 src/wasm/wasm-js.cc                           |  6 ++--
 src/wasm/wasm-objects.cc                      | 24 +++++++++----
 .../wasm/test-wasm-import-wrapper-cache.cc    | 34 +++++++++++--------
 test/cctest/wasm/wasm-run-utils.cc            |  5 +--
 tools/v8heapconst.py                          |  2 +-
 29 files changed, 181 insertions(+), 77 deletions(-)

diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index a1365292b3..5e830ee880 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -2766,6 +2766,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index 45e1a8e514..18a5065107 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -3201,6 +3201,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 27f4142cfc..ff1710e937 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -948,6 +948,7 @@ namespace internal {
   /* Wasm */                                                                   \
   IF_WASM(ASM, GenericJSToWasmWrapper, Dummy)                                  \
   IF_WASM(ASM, WasmReturnPromiseOnSuspend, Dummy)                              \
+  IF_WASM(ASM, WasmSuspend, WasmSuspend)                                       \
   IF_WASM(ASM, WasmCompileLazy, Dummy)                                         \
   IF_WASM(ASM, WasmDebugBreak, Dummy)                                          \
   IF_WASM(ASM, WasmOnStackReplace, Dummy)                                      \
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 8ff1bf1858..1472691028 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -3026,6 +3026,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/loong64/builtins-loong64.cc b/src/builtins/loong64/builtins-loong64.cc
index ed8b0daaae..2e9d941a01 100644
--- a/src/builtins/loong64/builtins-loong64.cc
+++ b/src/builtins/loong64/builtins-loong64.cc
@@ -2792,6 +2792,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/mips/builtins-mips.cc b/src/builtins/mips/builtins-mips.cc
index 7be8677ccc..3484acdc02 100644
--- a/src/builtins/mips/builtins-mips.cc
+++ b/src/builtins/mips/builtins-mips.cc
@@ -2729,6 +2729,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/mips64/builtins-mips64.cc b/src/builtins/mips64/builtins-mips64.cc
index d3d8ca73a5..39ad1064a2 100644
--- a/src/builtins/mips64/builtins-mips64.cc
+++ b/src/builtins/mips64/builtins-mips64.cc
@@ -2813,6 +2813,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/ppc/builtins-ppc.cc b/src/builtins/ppc/builtins-ppc.cc
index 08b1dc5772..f66bda9998 100644
--- a/src/builtins/ppc/builtins-ppc.cc
+++ b/src/builtins/ppc/builtins-ppc.cc
@@ -2600,6 +2600,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/riscv64/builtins-riscv64.cc b/src/builtins/riscv64/builtins-riscv64.cc
index 7a485851aa..08e95fa9f1 100644
--- a/src/builtins/riscv64/builtins-riscv64.cc
+++ b/src/builtins/riscv64/builtins-riscv64.cc
@@ -3151,6 +3151,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/s390/builtins-s390.cc b/src/builtins/s390/builtins-s390.cc
index 5bb667d39e..bb65158593 100644
--- a/src/builtins/s390/builtins-s390.cc
+++ b/src/builtins/s390/builtins-s390.cc
@@ -3020,6 +3020,11 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ Trap();
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // TODO(v8:12191): Implement for this platform.
+  __ Trap();
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   // Only needed on x64.
   __ Trap();
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index e70166b762..0f5f82fc45 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -3665,7 +3665,7 @@ void LoadJumpBuffer(MacroAssembler* masm, Register jmpbuf) {
 
 void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   // Set up the stackframe.
-  __ EnterFrame(StackFrame::RETURN_PROMISE_ON_SUSPEND);
+  __ EnterFrame(StackFrame::STACK_SWITCH);
 
   // Parameters.
   Register closure = kJSFunctionRegister;                  // rdi
@@ -3869,12 +3869,19 @@ void Builtins::Generate_WasmReturnPromiseOnSuspend(MacroAssembler* masm) {
   __ movq(
       param_count,
       MemOperand(rbp, ReturnPromiseOnSuspendFrameConstants::kParamCountOffset));
-  __ LeaveFrame(StackFrame::RETURN_PROMISE_ON_SUSPEND);
+  __ LeaveFrame(StackFrame::STACK_SWITCH);
   __ DropArguments(param_count, r8, TurboAssembler::kCountIsInteger,
                    TurboAssembler::kCountExcludesReceiver);
   __ ret(0);
 }
 
+void Builtins::Generate_WasmSuspend(MacroAssembler* masm) {
+  // Set up the stackframe.
+  __ EnterFrame(StackFrame::STACK_SWITCH);
+  __ LeaveFrame(StackFrame::STACK_SWITCH);
+  __ ret(0);
+}
+
 void Builtins::Generate_WasmOnStackReplace(MacroAssembler* masm) {
   MemOperand OSRTargetSlot(rbp, -wasm::kOSRTargetOffset);
   __ movq(kScratchRegister, OSRTargetSlot);
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index b083246fad..679104dfe0 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -124,6 +124,7 @@ namespace internal {
   V(WasmFloat64ToNumber)                 \
   V(WasmI32AtomicWait32)                 \
   V(WasmI64AtomicWait32)                 \
+  V(WasmSuspend)                         \
   V(WriteBarrier)                        \
   BUILTIN_LIST_TFS(V)                    \
   TORQUE_BUILTIN_LIST_TFC(V)
@@ -1787,6 +1788,14 @@ class WasmFloat64ToNumberDescriptor final
 #endif
 };
 
+class WasmSuspendDescriptor final
+    : public StaticCallInterfaceDescriptor<WasmSuspendDescriptor> {
+ public:
+  DEFINE_RESULT_AND_PARAMETERS_NO_CONTEXT(0, kArg)
+  DEFINE_RESULT_AND_PARAMETER_TYPES(MachineType::AnyTagged())  // value
+  DECLARE_DESCRIPTOR(WasmSuspendDescriptor)
+};
+
 class V8_EXPORT_PRIVATE I64ToBigIntDescriptor final
     : public StaticCallInterfaceDescriptor<I64ToBigIntDescriptor> {
  public:
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index 40e1571959..08e9ac7e9a 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -6986,7 +6986,8 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
   }
 
   // For wasm-to-js wrappers, parameter 0 is a WasmApiFunctionRef.
-  bool BuildWasmToJSWrapper(WasmImportCallKind kind, int expected_arity) {
+  bool BuildWasmToJSWrapper(WasmImportCallKind kind, int expected_arity,
+                            wasm::Suspend suspend) {
     int wasm_count = static_cast<int>(sig_->parameter_count());
 
     // Build the start and the parameter nodes.
@@ -7047,6 +7048,14 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
 
         DCHECK_EQ(pos, args.size());
         call = gasm_->Call(call_descriptor, pos, args.begin());
+        if (suspend == wasm::kSuspend) {
+          auto* call_descriptor = GetBuiltinCallDescriptor(
+              Builtin::kWasmSuspend, zone_, StubCallMode::kCallWasmRuntimeStub);
+          Node* call_target = mcgraph()->RelocatableIntPtrConstant(
+              wasm::WasmCode::kWasmSuspend, RelocInfo::WASM_STUB_CALL);
+
+          gasm_->Call(call_descriptor, call_target, call);
+        }
         break;
       }
       // =======================================================================
@@ -7081,6 +7090,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
         auto call_descriptor = Linkage::GetJSCallDescriptor(
             graph()->zone(), false, pushed_count + 1, CallDescriptor::kNoFlags);
         call = gasm_->Call(call_descriptor, pos, args.begin());
+        // TODO(12191): Handle suspending wrapper.
         break;
       }
       // =======================================================================
@@ -7115,6 +7125,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
 
         DCHECK_EQ(pos, args.size());
         call = gasm_->Call(call_descriptor, pos, args.begin());
+        // TODO(12191): Handle suspending wrapper.
         break;
       }
       default:
@@ -7708,7 +7719,8 @@ wasm::WasmCompilationResult CompileWasmMathIntrinsic(
 
 wasm::WasmCompilationResult CompileWasmImportCallWrapper(
     wasm::CompilationEnv* env, WasmImportCallKind kind,
-    const wasm::FunctionSig* sig, bool source_positions, int expected_arity) {
+    const wasm::FunctionSig* sig, bool source_positions, int expected_arity,
+    wasm::Suspend suspend) {
   DCHECK_NE(WasmImportCallKind::kLinkError, kind);
   DCHECK_NE(WasmImportCallKind::kWasmToWasm, kind);
 
@@ -7740,7 +7752,7 @@ wasm::WasmCompilationResult CompileWasmImportCallWrapper(
       &zone, mcgraph, sig, env->module,
       WasmGraphBuilder::kWasmApiFunctionRefMode, nullptr, source_position_table,
       StubCallMode::kCallWasmRuntimeStub, env->enabled_features);
-  builder.BuildWasmToJSWrapper(kind, expected_arity);
+  builder.BuildWasmToJSWrapper(kind, expected_arity, suspend);
 
   // Build a name in the form "wasm-to-js-<kind>-<signature>".
   constexpr size_t kMaxNameLen = 128;
@@ -7812,7 +7824,8 @@ wasm::WasmCode* CompileWasmCapiCallWrapper(wasm::NativeModule* native_module,
 MaybeHandle<Code> CompileWasmToJSWrapper(Isolate* isolate,
                                          const wasm::FunctionSig* sig,
                                          WasmImportCallKind kind,
-                                         int expected_arity) {
+                                         int expected_arity,
+                                         wasm::Suspend suspend) {
   std::unique_ptr<Zone> zone = std::make_unique<Zone>(
       isolate->allocator(), ZONE_NAME, kCompressGraphZone);
 
@@ -7830,7 +7843,7 @@ MaybeHandle<Code> CompileWasmToJSWrapper(Isolate* isolate,
                                   nullptr, nullptr,
                                   StubCallMode::kCallBuiltinPointer,
                                   wasm::WasmFeatures::FromIsolate(isolate));
-  builder.BuildWasmToJSWrapper(kind, expected_arity);
+  builder.BuildWasmToJSWrapper(kind, expected_arity, suspend);
 
   // Build a name in the form "wasm-to-js-<kind>-<signature>".
   constexpr size_t kMaxNameLen = 128;
diff --git a/src/compiler/wasm-compiler.h b/src/compiler/wasm-compiler.h
index 8a85cd6deb..5d93e8b7be 100644
--- a/src/compiler/wasm-compiler.h
+++ b/src/compiler/wasm-compiler.h
@@ -55,6 +55,7 @@ class WasmCode;
 class WasmFeatures;
 class WireBytesStorage;
 enum class LoadTransformationKind : uint8_t;
+enum Suspend : bool { kSuspend = false, kNoSuspend = true };
 }  // namespace wasm
 
 namespace compiler {
@@ -124,7 +125,7 @@ V8_EXPORT_PRIVATE WasmImportData ResolveWasmImportCall(
 // Compiles an import call wrapper, which allows Wasm to call imports.
 V8_EXPORT_PRIVATE wasm::WasmCompilationResult CompileWasmImportCallWrapper(
     wasm::CompilationEnv* env, WasmImportCallKind, const wasm::FunctionSig*,
-    bool source_positions, int expected_arity);
+    bool source_positions, int expected_arity, wasm::Suspend);
 
 // Compiles a host call wrapper, which allows Wasm to call host functions.
 wasm::WasmCode* CompileWasmCapiCallWrapper(wasm::NativeModule*,
@@ -139,7 +140,8 @@ std::unique_ptr<OptimizedCompilationJob> NewJSToWasmCompilationJob(
 MaybeHandle<Code> CompileWasmToJSWrapper(Isolate* isolate,
                                          const wasm::FunctionSig* sig,
                                          WasmImportCallKind kind,
-                                         int expected_arity);
+                                         int expected_arity,
+                                         wasm::Suspend suspend);
 
 // Compiles a stub with JS linkage that serves as an adapter for function
 // objects constructed via {WebAssembly.Function}. It performs a round-trip
diff --git a/src/execution/frames-inl.h b/src/execution/frames-inl.h
index 8db9f4dce4..32a974fbc3 100644
--- a/src/execution/frames-inl.h
+++ b/src/execution/frames-inl.h
@@ -239,8 +239,7 @@ inline WasmToJsFrame::WasmToJsFrame(StackFrameIteratorBase* iterator)
 inline JsToWasmFrame::JsToWasmFrame(StackFrameIteratorBase* iterator)
     : StubFrame(iterator) {}
 
-inline ReturnPromiseOnSuspendFrame::ReturnPromiseOnSuspendFrame(
-    StackFrameIteratorBase* iterator)
+inline StackSwitchFrame::StackSwitchFrame(StackFrameIteratorBase* iterator)
     : ExitFrame(iterator) {}
 
 inline CWasmEntryFrame::CWasmEntryFrame(StackFrameIteratorBase* iterator)
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 387a0efa40..35511a9ddf 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -167,9 +167,9 @@ void StackFrameIterator::Reset(ThreadLocalTop* top, wasm::StackMemory* stack) {
     return;
   }
   StackFrame::State state;
-  ReturnPromiseOnSuspendFrame::GetStateForJumpBuffer(stack->jmpbuf(), &state);
+  StackSwitchFrame::GetStateForJumpBuffer(stack->jmpbuf(), &state);
   handler_ = StackHandler::FromAddress(Isolate::handler(top));
-  frame_ = SingletonFor(StackFrame::RETURN_PROMISE_ON_SUSPEND, &state);
+  frame_ = SingletonFor(StackFrame::STACK_SWITCH, &state);
 }
 #endif
 
@@ -718,7 +718,7 @@ StackFrame::Type StackFrame::ComputeType(const StackFrameIteratorBase* iterator,
     case WASM_EXIT:
     case WASM_DEBUG_BREAK:
     case JS_TO_WASM:
-    case RETURN_PROMISE_ON_SUSPEND:
+    case STACK_SWITCH:
 #endif  // V8_ENABLE_WEBASSEMBLY
       return candidate;
     case OPTIMIZED:
@@ -832,7 +832,7 @@ StackFrame::Type ExitFrame::ComputeFrameType(Address fp) {
     case BUILTIN_EXIT:
 #if V8_ENABLE_WEBASSEMBLY
     case WASM_EXIT:
-    case RETURN_PROMISE_ON_SUSPEND:
+    case STACK_SWITCH:
 #endif  // V8_ENABLE_WEBASSEMBLY
       return frame_type;
     default:
@@ -1107,7 +1107,7 @@ void CommonFrame::IterateCompiledFrame(RootVisitor* v) const {
       case CONSTRUCT:
 #if V8_ENABLE_WEBASSEMBLY
       case JS_TO_WASM:
-      case RETURN_PROMISE_ON_SUSPEND:
+      case STACK_SWITCH:
       case C_WASM_ENTRY:
       case WASM_DEBUG_BREAK:
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -2201,7 +2201,7 @@ void JsToWasmFrame::Iterate(RootVisitor* v) const {
                        spill_slot_limit);
 }
 
-void ReturnPromiseOnSuspendFrame::Iterate(RootVisitor* v) const {
+void StackSwitchFrame::Iterate(RootVisitor* v) const {
   //  See JsToWasmFrame layout.
   //  We cannot DCHECK that the pc matches the expected builtin code here,
   //  because the return address is on a different stack.
@@ -2218,10 +2218,10 @@ void ReturnPromiseOnSuspendFrame::Iterate(RootVisitor* v) const {
 }
 
 // static
-void ReturnPromiseOnSuspendFrame::GetStateForJumpBuffer(
-    wasm::JumpBuffer* jmpbuf, State* state) {
+void StackSwitchFrame::GetStateForJumpBuffer(wasm::JumpBuffer* jmpbuf,
+                                             State* state) {
   DCHECK_NE(jmpbuf->fp, kNullAddress);
-  DCHECK_EQ(ComputeFrameType(jmpbuf->fp), RETURN_PROMISE_ON_SUSPEND);
+  DCHECK_EQ(ComputeFrameType(jmpbuf->fp), STACK_SWITCH);
   FillState(jmpbuf->fp, jmpbuf->sp, state);
   DCHECK_NE(*state->pc_address, kNullAddress);
 }
diff --git a/src/execution/frames.h b/src/execution/frames.h
index b1ece34cb2..9d67d0fd57 100644
--- a/src/execution/frames.h
+++ b/src/execution/frames.h
@@ -102,7 +102,7 @@ class StackHandler {
   IF_WASM(V, WASM, WasmFrame)                                             \
   IF_WASM(V, WASM_TO_JS, WasmToJsFrame)                                   \
   IF_WASM(V, JS_TO_WASM, JsToWasmFrame)                                   \
-  IF_WASM(V, RETURN_PROMISE_ON_SUSPEND, ReturnPromiseOnSuspendFrame)      \
+  IF_WASM(V, STACK_SWITCH, StackSwitchFrame)                              \
   IF_WASM(V, WASM_DEBUG_BREAK, WasmDebugBreakFrame)                       \
   IF_WASM(V, C_WASM_ENTRY, CWasmEntryFrame)                               \
   IF_WASM(V, WASM_EXIT, WasmExitFrame)                                    \
@@ -1052,14 +1052,14 @@ class JsToWasmFrame : public StubFrame {
   friend class StackFrameIteratorBase;
 };
 
-class ReturnPromiseOnSuspendFrame : public ExitFrame {
+class StackSwitchFrame : public ExitFrame {
  public:
-  Type type() const override { return RETURN_PROMISE_ON_SUSPEND; }
+  Type type() const override { return STACK_SWITCH; }
   void Iterate(RootVisitor* v) const override;
   static void GetStateForJumpBuffer(wasm::JumpBuffer* jmpbuf, State* state);
 
  protected:
-  inline explicit ReturnPromiseOnSuspendFrame(StackFrameIteratorBase* iterator);
+  inline explicit StackSwitchFrame(StackFrameIteratorBase* iterator);
 
  private:
   friend class StackFrameIteratorBase;
diff --git a/src/wasm/function-compiler.cc b/src/wasm/function-compiler.cc
index c40181d0a0..4a375326b0 100644
--- a/src/wasm/function-compiler.cc
+++ b/src/wasm/function-compiler.cc
@@ -64,7 +64,7 @@ WasmCompilationResult WasmCompilationUnit::ExecuteImportWrapperCompilation(
   bool source_positions = is_asmjs_module(env->module);
   WasmCompilationResult result = compiler::CompileWasmImportCallWrapper(
       env, kind, sig, source_positions,
-      static_cast<int>(sig->parameter_count()));
+      static_cast<int>(sig->parameter_count()), wasm::kNoSuspend);
   return result;
 }
 
diff --git a/src/wasm/module-compiler.cc b/src/wasm/module-compiler.cc
index 668fe0b410..b71eee219f 100644
--- a/src/wasm/module-compiler.cc
+++ b/src/wasm/module-compiler.cc
@@ -1601,7 +1601,7 @@ int AddImportWrapperUnits(NativeModule* native_module,
     }
     WasmImportWrapperCache::CacheKey key(
         compiler::kDefaultImportCallKind, sig,
-        static_cast<int>(sig->parameter_count()));
+        static_cast<int>(sig->parameter_count()), kNoSuspend);
     auto it = keys.insert(key);
     if (it.second) {
       // Ensure that all keys exist in the cache, so that we can populate the
@@ -3653,7 +3653,7 @@ void CompilationStateImpl::PublishCompilationResults(
           native_module_->module()->functions[func_index].sig;
       WasmImportWrapperCache::CacheKey key(
           compiler::kDefaultImportCallKind, sig,
-          static_cast<int>(sig->parameter_count()));
+          static_cast<int>(sig->parameter_count()), kNoSuspend);
       // If two imported functions have the same key, only one of them should
       // have been added as a compilation unit. So it is always the first time
       // we compile a wrapper for this key here.
@@ -3893,19 +3893,19 @@ void CompileJsToWasmWrappers(Isolate* isolate, const WasmModule* module,
 WasmCode* CompileImportWrapper(
     NativeModule* native_module, Counters* counters,
     compiler::WasmImportCallKind kind, const FunctionSig* sig,
-    int expected_arity,
+    int expected_arity, Suspend suspend,
     WasmImportWrapperCache::ModificationScope* cache_scope) {
   // Entry should exist, so that we don't insert a new one and invalidate
   // other threads' iterators/references, but it should not have been compiled
   // yet.
-  WasmImportWrapperCache::CacheKey key(kind, sig, expected_arity);
+  WasmImportWrapperCache::CacheKey key(kind, sig, expected_arity, suspend);
   DCHECK_NULL((*cache_scope)[key]);
   bool source_positions = is_asmjs_module(native_module->module());
   // Keep the {WasmCode} alive until we explicitly call {IncRef}.
   WasmCodeRefScope code_ref_scope;
   CompilationEnv env = native_module->CreateCompilationEnv();
   WasmCompilationResult result = compiler::CompileWasmImportCallWrapper(
-      &env, kind, sig, source_positions, expected_arity);
+      &env, kind, sig, source_positions, expected_arity, suspend);
   WasmCode* published_code;
   {
     CodeSpaceWriteScope code_space_write_scope(native_module);
diff --git a/src/wasm/module-compiler.h b/src/wasm/module-compiler.h
index 1aab188d29..ecd861d51e 100644
--- a/src/wasm/module-compiler.h
+++ b/src/wasm/module-compiler.h
@@ -70,7 +70,8 @@ V8_EXPORT_PRIVATE
 WasmCode* CompileImportWrapper(
     NativeModule* native_module, Counters* counters,
     compiler::WasmImportCallKind kind, const FunctionSig* sig,
-    int expected_arity, WasmImportWrapperCache::ModificationScope* cache_scope);
+    int expected_arity, Suspend suspend,
+    WasmImportWrapperCache::ModificationScope* cache_scope);
 
 // Triggered by the WasmCompileLazy builtin. The return value indicates whether
 // compilation was successful. Lazy compilation can fail only if validation is
diff --git a/src/wasm/module-instantiate.cc b/src/wasm/module-instantiate.cc
index 8dba8deb3a..8f2fb6f5be 100644
--- a/src/wasm/module-instantiate.cc
+++ b/src/wasm/module-instantiate.cc
@@ -72,7 +72,7 @@ class CompileImportWrapperJob final : public JobTask {
       // TODO(wasm): Batch code publishing, to avoid repeated locking and
       // permission switching.
       CompileImportWrapper(native_module_, counters_, key->kind, key->signature,
-                           key->expected_arity, cache_scope_);
+                           key->expected_arity, key->suspend, cache_scope_);
       if (delegate->ShouldYield()) return;
     }
   }
@@ -1173,14 +1173,15 @@ bool InstanceBuilder::ProcessImportedFunction(
       WasmImportWrapperCache* cache = native_module->import_wrapper_cache();
       // TODO(jkummerow): Consider precompiling CapiCallWrappers in parallel,
       // just like other import wrappers.
-      WasmCode* wasm_code = cache->MaybeGet(kind, expected_sig, expected_arity);
+      WasmCode* wasm_code =
+          cache->MaybeGet(kind, expected_sig, expected_arity, kNoSuspend);
       if (wasm_code == nullptr) {
         WasmCodeRefScope code_ref_scope;
         WasmImportWrapperCache::ModificationScope cache_scope(cache);
         wasm_code =
             compiler::CompileWasmCapiCallWrapper(native_module, expected_sig);
-        WasmImportWrapperCache::CacheKey key(kind, expected_sig,
-                                             expected_arity);
+        WasmImportWrapperCache::CacheKey key(kind, expected_sig, expected_arity,
+                                             kNoSuspend);
         cache_scope[key] = wasm_code;
         wasm_code->IncRef();
         isolate_->counters()->wasm_generated_code_size()->Increment(
@@ -1208,8 +1209,12 @@ bool InstanceBuilder::ProcessImportedFunction(
       }
 
       NativeModule* native_module = instance->module_object().native_module();
+      Suspend suspend =
+          resolved.suspender.is_null() || resolved.suspender->IsUndefined()
+              ? kNoSuspend
+              : kSuspend;
       WasmCode* wasm_code = native_module->import_wrapper_cache()->Get(
-          kind, expected_sig, expected_arity);
+          kind, expected_sig, expected_arity, suspend);
       DCHECK_NOT_NULL(wasm_code);
       ImportedFunctionEntry entry(instance, func_index);
       if (wasm_code->kind() == WasmCode::kWasmToJsWrapper) {
@@ -1619,7 +1624,11 @@ void InstanceBuilder::CompileImportWrappers(
           shared.internal_formal_parameter_count_without_receiver();
     }
 
-    WasmImportWrapperCache::CacheKey key(kind, sig, expected_arity);
+    Suspend suspend =
+        resolved.suspender.is_null() || resolved.suspender->IsUndefined()
+            ? kNoSuspend
+            : kSuspend;
+    WasmImportWrapperCache::CacheKey key(kind, sig, expected_arity, suspend);
     if (cache_scope[key] != nullptr) {
       // Cache entry already exists, no need to compile it again.
       continue;
diff --git a/src/wasm/wasm-code-manager.h b/src/wasm/wasm-code-manager.h
index 368b03258b..934064b761 100644
--- a/src/wasm/wasm-code-manager.h
+++ b/src/wasm/wasm-code-manager.h
@@ -124,7 +124,8 @@ struct WasmModule;
   V(WasmAllocateFreshRtt)                 \
   V(WasmAllocateStructWithRtt)            \
   V(WasmSubtypeCheck)                     \
-  V(WasmOnStackReplace)
+  V(WasmOnStackReplace)                   \
+  V(WasmSuspend)
 
 // Sorted, disjoint and non-overlapping memory regions. A region is of the
 // form [start, end). So there's no [start, end), [end, other_end),
diff --git a/src/wasm/wasm-import-wrapper-cache.cc b/src/wasm/wasm-import-wrapper-cache.cc
index c760634a76..e1a99a3ea5 100644
--- a/src/wasm/wasm-import-wrapper-cache.cc
+++ b/src/wasm/wasm-import-wrapper-cache.cc
@@ -25,20 +25,22 @@ WasmCode*& WasmImportWrapperCache::operator[](
 
 WasmCode* WasmImportWrapperCache::Get(compiler::WasmImportCallKind kind,
                                       const FunctionSig* sig,
-                                      int expected_arity) const {
+                                      int expected_arity,
+                                      Suspend suspend) const {
   base::MutexGuard lock(&mutex_);
 
-  auto it = entry_map_.find({kind, sig, expected_arity});
+  auto it = entry_map_.find({kind, sig, expected_arity, suspend});
   DCHECK(it != entry_map_.end());
   return it->second;
 }
 
 WasmCode* WasmImportWrapperCache::MaybeGet(compiler::WasmImportCallKind kind,
                                            const FunctionSig* sig,
-                                           int expected_arity) const {
+                                           int expected_arity,
+                                           Suspend suspend) const {
   base::MutexGuard lock(&mutex_);
 
-  auto it = entry_map_.find({kind, sig, expected_arity});
+  auto it = entry_map_.find({kind, sig, expected_arity, suspend});
   if (it == entry_map_.end()) return nullptr;
   return it->second;
 }
diff --git a/src/wasm/wasm-import-wrapper-cache.h b/src/wasm/wasm-import-wrapper-cache.h
index 57c92bc6bb..f12b07477f 100644
--- a/src/wasm/wasm-import-wrapper-cache.h
+++ b/src/wasm/wasm-import-wrapper-cache.h
@@ -29,21 +29,23 @@ class WasmImportWrapperCache {
  public:
   struct CacheKey {
     CacheKey(const compiler::WasmImportCallKind& _kind, const FunctionSig* _sig,
-             int _expected_arity)
+             int _expected_arity, Suspend _suspend)
         : kind(_kind),
           signature(_sig),
           expected_arity(_expected_arity == kDontAdaptArgumentsSentinel
                              ? 0
-                             : _expected_arity) {}
+                             : _expected_arity),
+          suspend(_suspend) {}
 
     bool operator==(const CacheKey& rhs) const {
       return kind == rhs.kind && signature == rhs.signature &&
-             expected_arity == rhs.expected_arity;
+             expected_arity == rhs.expected_arity && suspend == rhs.suspend;
     }
 
     compiler::WasmImportCallKind kind;
     const FunctionSig* signature;
     int expected_arity;
+    Suspend suspend;
   };
 
   class CacheKeyHash {
@@ -73,11 +75,11 @@ class WasmImportWrapperCache {
 
   // Thread-safe. Assumes the key exists in the map.
   V8_EXPORT_PRIVATE WasmCode* Get(compiler::WasmImportCallKind kind,
-                                  const FunctionSig* sig,
-                                  int expected_arity) const;
+                                  const FunctionSig* sig, int expected_arity,
+                                  Suspend suspend) const;
   // Thread-safe. Returns nullptr if the key doesn't exist in the map.
   WasmCode* MaybeGet(compiler::WasmImportCallKind kind, const FunctionSig* sig,
-                     int expected_arity) const;
+                     int expected_arity, Suspend suspend) const;
 
   ~WasmImportWrapperCache();
 
diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
index eced795cf2..2acbb84377 100644
--- a/src/wasm/wasm-js.cc
+++ b/src/wasm/wasm-js.cc
@@ -1898,10 +1898,8 @@ void WebAssemblyFunction(const v8::FunctionCallbackInfo<v8::Value>& args) {
     return;
   }
 
-  i::Handle<i::HeapObject> suspender =
-      handle(i::ReadOnlyRoots(i_isolate).undefined_value(), i_isolate);
-  i::Handle<i::JSFunction> result =
-      i::WasmJSFunction::New(i_isolate, sig, callable, suspender);
+  i::Handle<i::JSFunction> result = i::WasmJSFunction::New(
+      i_isolate, sig, callable, i::Handle<i::HeapObject>());
   args.GetReturnValue().Set(Utils::ToLocal(result));
 }
 
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index 4fc8588f87..b4af13beae 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -580,12 +580,14 @@ void WasmTableObject::UpdateDispatchTables(
         instance->module_object().native_module();
     wasm::WasmImportWrapperCache* cache = native_module->import_wrapper_cache();
     auto kind = compiler::WasmImportCallKind::kWasmToCapi;
-    wasm::WasmCode* wasm_code = cache->MaybeGet(kind, &sig, param_count);
+    wasm::WasmCode* wasm_code =
+        cache->MaybeGet(kind, &sig, param_count, wasm::kNoSuspend);
     if (wasm_code == nullptr) {
       wasm::WasmCodeRefScope code_ref_scope;
       wasm::WasmImportWrapperCache::ModificationScope cache_scope(cache);
       wasm_code = compiler::CompileWasmCapiCallWrapper(native_module, &sig);
-      wasm::WasmImportWrapperCache::CacheKey key(kind, &sig, param_count);
+      wasm::WasmImportWrapperCache::CacheKey key(kind, &sig, param_count,
+                                                 wasm::kNoSuspend);
       cache_scope[key] = wasm_code;
       wasm_code->IncRef();
       isolate->counters()->wasm_generated_code_size()->Increment(
@@ -1461,9 +1463,13 @@ void WasmInstanceObject::ImportWasmJSFunctionIntoTable(
                            ->shared()
                            .internal_formal_parameter_count_without_receiver();
     }
+    wasm::Suspend suspend =
+        resolved.suspender.is_null() || resolved.suspender->IsUndefined()
+            ? wasm::kNoSuspend
+            : wasm::kSuspend;
     // TODO(manoskouk): Reuse js_function->wasm_to_js_wrapper_code().
     wasm::WasmCompilationResult result = compiler::CompileWasmImportCallWrapper(
-        &env, kind, sig, false, expected_arity);
+        &env, kind, sig, false, expected_arity, suspend);
     wasm::CodeSpaceWriteScope write_scope(native_module);
     std::unique_ptr<wasm::WasmCode> wasm_code = native_module->AddCode(
         result.func_index, result.code_desc, result.frame_slot_count,
@@ -2083,10 +2089,14 @@ Handle<WasmJSFunction> WasmJSFunction::New(Isolate* isolate,
     }
     // TODO(wasm): Think about caching and sharing the wasm-to-JS wrappers per
     // signature instead of compiling a new one for every instantiation.
-    Handle<CodeT> wasm_to_js_wrapper_code = ToCodeT(
-        compiler::CompileWasmToJSWrapper(isolate, sig, kind, expected_arity)
-            .ToHandleChecked(),
-        isolate);
+    wasm::Suspend suspend =
+        suspender.is_null() ? wasm::kNoSuspend : wasm::kSuspend;
+    DCHECK_IMPLIES(!suspender.is_null(), !suspender->IsUndefined());
+    Handle<CodeT> wasm_to_js_wrapper_code =
+        ToCodeT(compiler::CompileWasmToJSWrapper(isolate, sig, kind,
+                                                 expected_arity, suspend)
+                    .ToHandleChecked(),
+                isolate);
     function_data->internal().set_code(*wasm_to_js_wrapper_code);
   }
 
diff --git a/test/cctest/wasm/test-wasm-import-wrapper-cache.cc b/test/cctest/wasm/test-wasm-import-wrapper-cache.cc
index 239140cc83..0153f02f17 100644
--- a/test/cctest/wasm/test-wasm-import-wrapper-cache.cc
+++ b/test/cctest/wasm/test-wasm-import-wrapper-cache.cc
@@ -39,13 +39,14 @@ TEST(CacheHit) {
   auto sig = sigs.i_i();
   int expected_arity = static_cast<int>(sig->parameter_count());
 
-  WasmCode* c1 = CompileImportWrapper(module.get(), isolate->counters(), kind,
-                                      sig, expected_arity, &cache_scope);
+  WasmCode* c1 =
+      CompileImportWrapper(module.get(), isolate->counters(), kind, sig,
+                           expected_arity, kNoSuspend, &cache_scope);
 
   CHECK_NOT_NULL(c1);
   CHECK_EQ(WasmCode::Kind::kWasmToJsWrapper, c1->kind());
 
-  WasmCode* c2 = cache_scope[{kind, sig, expected_arity}];
+  WasmCode* c2 = cache_scope[{kind, sig, expected_arity, kNoSuspend}];
 
   CHECK_NOT_NULL(c2);
   CHECK_EQ(c1, c2);
@@ -65,13 +66,14 @@ TEST(CacheMissSig) {
   auto sig2 = sigs.i_ii();
   int expected_arity2 = static_cast<int>(sig2->parameter_count());
 
-  WasmCode* c1 = CompileImportWrapper(module.get(), isolate->counters(), kind,
-                                      sig1, expected_arity1, &cache_scope);
+  WasmCode* c1 =
+      CompileImportWrapper(module.get(), isolate->counters(), kind, sig1,
+                           expected_arity1, kNoSuspend, &cache_scope);
 
   CHECK_NOT_NULL(c1);
   CHECK_EQ(WasmCode::Kind::kWasmToJsWrapper, c1->kind());
 
-  WasmCode* c2 = cache_scope[{kind, sig2, expected_arity2}];
+  WasmCode* c2 = cache_scope[{kind, sig2, expected_arity2, kNoSuspend}];
 
   CHECK_NULL(c2);
 }
@@ -89,13 +91,14 @@ TEST(CacheMissKind) {
   auto sig = sigs.i_i();
   int expected_arity = static_cast<int>(sig->parameter_count());
 
-  WasmCode* c1 = CompileImportWrapper(module.get(), isolate->counters(), kind1,
-                                      sig, expected_arity, &cache_scope);
+  WasmCode* c1 =
+      CompileImportWrapper(module.get(), isolate->counters(), kind1, sig,
+                           expected_arity, kNoSuspend, &cache_scope);
 
   CHECK_NOT_NULL(c1);
   CHECK_EQ(WasmCode::Kind::kWasmToJsWrapper, c1->kind());
 
-  WasmCode* c2 = cache_scope[{kind2, sig, expected_arity}];
+  WasmCode* c2 = cache_scope[{kind2, sig, expected_arity, kNoSuspend}];
 
   CHECK_NULL(c2);
 }
@@ -114,27 +117,28 @@ TEST(CacheHitMissSig) {
   auto sig2 = sigs.i_ii();
   int expected_arity2 = static_cast<int>(sig2->parameter_count());
 
-  WasmCode* c1 = CompileImportWrapper(module.get(), isolate->counters(), kind,
-                                      sig1, expected_arity1, &cache_scope);
+  WasmCode* c1 =
+      CompileImportWrapper(module.get(), isolate->counters(), kind, sig1,
+                           expected_arity1, kNoSuspend, &cache_scope);
 
   CHECK_NOT_NULL(c1);
   CHECK_EQ(WasmCode::Kind::kWasmToJsWrapper, c1->kind());
 
-  WasmCode* c2 = cache_scope[{kind, sig2, expected_arity2}];
+  WasmCode* c2 = cache_scope[{kind, sig2, expected_arity2, kNoSuspend}];
 
   CHECK_NULL(c2);
 
   c2 = CompileImportWrapper(module.get(), isolate->counters(), kind, sig2,
-                            expected_arity2, &cache_scope);
+                            expected_arity2, kNoSuspend, &cache_scope);
 
   CHECK_NE(c1, c2);
 
-  WasmCode* c3 = cache_scope[{kind, sig1, expected_arity1}];
+  WasmCode* c3 = cache_scope[{kind, sig1, expected_arity1, kNoSuspend}];
 
   CHECK_NOT_NULL(c3);
   CHECK_EQ(c1, c3);
 
-  WasmCode* c4 = cache_scope[{kind, sig2, expected_arity2}];
+  WasmCode* c4 = cache_scope[{kind, sig2, expected_arity2, kNoSuspend}];
 
   CHECK_NOT_NULL(c4);
   CHECK_EQ(c2, c4);
diff --git a/test/cctest/wasm/wasm-run-utils.cc b/test/cctest/wasm/wasm-run-utils.cc
index e419c9cf94..308f3a5d98 100644
--- a/test/cctest/wasm/wasm-run-utils.cc
+++ b/test/cctest/wasm/wasm-run-utils.cc
@@ -79,13 +79,14 @@ TestingModuleBuilder::TestingModuleBuilder(
         native_module_->import_wrapper_cache());
     WasmImportWrapperCache::CacheKey key(
         kind, maybe_import->sig,
-        static_cast<int>(maybe_import->sig->parameter_count()));
+        static_cast<int>(maybe_import->sig->parameter_count()), kNoSuspend);
     auto import_wrapper = cache_scope[key];
     if (import_wrapper == nullptr) {
       CodeSpaceWriteScope write_scope(native_module_);
       import_wrapper = CompileImportWrapper(
           native_module_, isolate_->counters(), kind, maybe_import->sig,
-          static_cast<int>(maybe_import->sig->parameter_count()), &cache_scope);
+          static_cast<int>(maybe_import->sig->parameter_count()), kNoSuspend,
+          &cache_scope);
     }
 
     ImportedFunctionEntry(instance_object_, maybe_import_index)
diff --git a/tools/v8heapconst.py b/tools/v8heapconst.py
index 09b348ab0f..2125f8dcbc 100644
--- a/tools/v8heapconst.py
+++ b/tools/v8heapconst.py
@@ -560,7 +560,7 @@ FRAME_MARKERS = (
   "WASM",
   "WASM_TO_JS",
   "JS_TO_WASM",
-  "RETURN_PROMISE_ON_SUSPEND",
+  "STACK_SWITCH",
   "WASM_DEBUG_BREAK",
   "C_WASM_ENTRY",
   "WASM_EXIT",
-- 
2.35.1


From 4ae31df132fb1f1345beebaf764976c8742fd631 Mon Sep 17 00:00:00 2001
From: Ross McIlroy <rmcilroy@chromium.org>
Date: Wed, 30 Jun 2021 10:51:14 +0100
Subject: [PATCH] [Turboprop] Enable support for dynamic map checks for
 inlining.

Adds support for a seperate dynamic map checks trampoline that takes the
feedback vector as an argument rather than reading it from the stack
frame, to enable it to work for inlined functions.  Plumbs the logic
through the compiler to select between these trampolines based on the
framestate.

BUG=v8:9684,chromium:1224367

Change-Id: Ibc7facdc78930aedec4a102693a926f64f6de7e2
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2992724
Commit-Queue: Ross McIlroy <rmcilroy@chromium.org>
Reviewed-by: Jakob Gruber <jgruber@chromium.org>
Reviewed-by: Mythri Alle <mythria@chromium.org>
Cr-Commit-Position: refs/heads/master@{#75461}
---
 src/builtins/arm/builtins-arm.cc              | 25 +++++++----
 src/builtins/arm64/builtins-arm64.cc          | 25 +++++++----
 src/builtins/builtins-definitions.h           |  3 ++
 src/builtins/builtins-ic-gen.cc               | 10 +++++
 src/builtins/builtins.h                       |  4 ++
 src/builtins/ia32/builtins-ia32.cc            | 25 +++++++----
 src/builtins/ic-dynamic-check-maps.tq         |  8 ++++
 src/builtins/mips/builtins-mips.cc            | 25 +++++++----
 src/builtins/mips64/builtins-mips64.cc        | 25 +++++++----
 src/builtins/ppc/builtins-ppc.cc              | 25 +++++++----
 src/builtins/riscv64/builtins-riscv64.cc      | 25 +++++++----
 src/builtins/s390/builtins-s390.cc            | 25 +++++++----
 src/builtins/x64/builtins-x64.cc              | 25 +++++++----
 .../arm/interface-descriptors-arm-inl.h       |  6 +++
 .../arm64/interface-descriptors-arm64-inl.h   |  6 +++
 .../ia32/interface-descriptors-ia32-inl.h     |  7 ++++
 src/codegen/interface-descriptors.h           | 19 +++++++++
 .../mips/interface-descriptors-mips-inl.h     |  6 +++
 .../mips64/interface-descriptors-mips64-inl.h |  6 +++
 .../ppc/interface-descriptors-ppc-inl.h       |  6 +++
 .../interface-descriptors-riscv64-inl.h       |  6 +++
 .../s390/interface-descriptors-s390-inl.h     |  7 ++++
 .../x64/interface-descriptors-x64-inl.h       | 12 ++++++
 .../backend/arm64/code-generator-arm64.cc     | 21 ++++++----
 src/compiler/backend/code-generator.cc        | 11 ++++-
 src/compiler/backend/code-generator.h         |  1 +
 src/compiler/backend/instruction-selector.cc  | 42 +++++++++++++------
 src/compiler/common-operator.cc               | 24 ++++++++---
 src/compiler/common-operator.h                |  7 ++--
 src/compiler/effect-control-linearizer.cc     |  7 +++-
 src/compiler/graph-assembler.cc               |  9 ++--
 src/compiler/graph-assembler.h                |  3 +-
 .../js-native-context-specialization.cc       | 10 -----
 src/deoptimizer/deoptimize-reason.h           |  9 ++++
 src/deoptimizer/deoptimizer.cc                |  2 +
 test/mjsunit/const-field-tracking-2.js        |  1 +
 test/mjsunit/mjsunit.status                   |  4 --
 37 files changed, 367 insertions(+), 115 deletions(-)

diff --git a/src/builtins/arm/builtins-arm.cc b/src/builtins/arm/builtins-arm.cc
index 4bb39b4f4f..20312d8336 100644
--- a/src/builtins/arm/builtins-arm.cc
+++ b/src/builtins/arm/builtins-arm.cc
@@ -3623,11 +3623,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -3635,10 +3649,8 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ ldr(handler_arg, MemOperand(fp, CommonFrameConstants::kCallerPCOffset));
   __ ldr(slot_arg, MemOperand(handler_arg,
                               Deoptimizer::kEagerWithResumeImmedArgs1PcOffset));
@@ -3646,8 +3658,7 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
       handler_arg,
       MemOperand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
 
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ cmp_raw_immediate(r0, static_cast<int>(DynamicCheckMapsStatus::kSuccess));
diff --git a/src/builtins/arm64/builtins-arm64.cc b/src/builtins/arm64/builtins-arm64.cc
index 96fe9b9704..1d37f2a3dc 100644
--- a/src/builtins/arm64/builtins-arm64.cc
+++ b/src/builtins/arm64/builtins-arm64.cc
@@ -4150,11 +4150,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -4162,10 +4176,8 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
 
 #ifdef V8_ENABLE_CONTROL_FLOW_INTEGRITY
   // Make sure we can use x16 and x17, and add slot_arg as a temp reg if needed.
@@ -4187,8 +4199,7 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
       handler_arg,
       MemOperand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
 
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ CompareAndBranch(
diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h
index 7cf0e40f5b..e00ad56fe7 100644
--- a/src/builtins/builtins-definitions.h
+++ b/src/builtins/builtins-definitions.h
@@ -272,6 +272,9 @@ namespace internal {
   /* Dynamic check maps */                                                     \
   ASM(DynamicCheckMapsTrampoline, DynamicCheckMaps)                            \
   TFC(DynamicCheckMaps, DynamicCheckMaps)                                      \
+  ASM(DynamicCheckMapsWithFeedbackVectorTrampoline,                            \
+      DynamicCheckMapsWithFeedbackVector)                                      \
+  TFC(DynamicCheckMapsWithFeedbackVector, DynamicCheckMapsWithFeedbackVector)  \
                                                                                \
   /* Microtask helpers */                                                      \
   TFS(EnqueueMicrotask, kMicrotask)                                            \
diff --git a/src/builtins/builtins-ic-gen.cc b/src/builtins/builtins-ic-gen.cc
index e172b5a129..8a525ef45a 100644
--- a/src/builtins/builtins-ic-gen.cc
+++ b/src/builtins/builtins-ic-gen.cc
@@ -234,5 +234,15 @@ TF_BUILTIN(DynamicCheckMaps, CodeStubAssembler) {
   Return(status);
 }
 
+TF_BUILTIN(DynamicCheckMapsWithFeedbackVector, CodeStubAssembler) {
+  auto map = Parameter<Map>(Descriptor::kMap);
+  auto slot = UncheckedParameter<IntPtrT>(Descriptor::kSlot);
+  auto handler = Parameter<Object>(Descriptor::kHandler);
+  auto feedback_vector = Parameter<FeedbackVector>(Descriptor::kFeedbackVector);
+  TNode<Int32T> status =
+      DynamicCheckMapsWithFeedbackVector(map, slot, handler, feedback_vector);
+  Return(status);
+}
+
 }  // namespace internal
 }  // namespace v8
diff --git a/src/builtins/builtins.h b/src/builtins/builtins.h
index 770c353379..2d6f221ebd 100644
--- a/src/builtins/builtins.h
+++ b/src/builtins/builtins.h
@@ -289,6 +289,10 @@ class Builtins {
   static void Generate_InterpreterPushArgsThenConstructImpl(
       MacroAssembler* masm, InterpreterPushArgsMode mode);
 
+  template <class Descriptor>
+  static void Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm,
+                                                  Handle<Code> builtin_target);
+
 #define DECLARE_ASM(Name, ...) \
   static void Generate_##Name(MacroAssembler* masm);
 #define DECLARE_TF(Name, ...) \
diff --git a/src/builtins/ia32/builtins-ia32.cc b/src/builtins/ia32/builtins-ia32.cc
index 6df499ec47..54013e7698 100644
--- a/src/builtins/ia32/builtins-ia32.cc
+++ b/src/builtins/ia32/builtins-ia32.cc
@@ -4255,11 +4255,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -4267,18 +4281,15 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ mov(handler_arg, Operand(ebp, CommonFrameConstants::kCallerPCOffset));
   __ mov(slot_arg,
          Operand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs1PcOffset));
   __ mov(handler_arg,
          Operand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
 
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ cmp(eax, Immediate(static_cast<int>(DynamicCheckMapsStatus::kSuccess)));
diff --git a/src/builtins/ic-dynamic-check-maps.tq b/src/builtins/ic-dynamic-check-maps.tq
index f047bd17f2..691f793b56 100644
--- a/src/builtins/ic-dynamic-check-maps.tq
+++ b/src/builtins/ic-dynamic-check-maps.tq
@@ -84,6 +84,14 @@ macro PerformMonomorphicCheck(
 macro DynamicCheckMaps(
     actualMap: Map, slotIndex: intptr, actualHandler: Smi|DataHandler): int32 {
   const feedbackVector = LoadFeedbackVectorForStubWithTrampoline();
+  return DynamicCheckMapsWithFeedbackVector(
+      actualMap, slotIndex, actualHandler, feedbackVector);
+}
+
+@export
+macro DynamicCheckMapsWithFeedbackVector(
+    actualMap: Map, slotIndex: intptr, actualHandler: Smi|DataHandler,
+    feedbackVector: FeedbackVector): int32 {
   const feedback = feedbackVector[slotIndex];
   try {
     const maybePolymorphicArray =
diff --git a/src/builtins/mips/builtins-mips.cc b/src/builtins/mips/builtins-mips.cc
index 75ec2d6a9d..724a1a2004 100644
--- a/src/builtins/mips/builtins-mips.cc
+++ b/src/builtins/mips/builtins-mips.cc
@@ -4080,11 +4080,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -4092,10 +4106,8 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ Lw(handler_arg, MemOperand(fp, CommonFrameConstants::kCallerPCOffset));
   __ Lw(slot_arg, MemOperand(handler_arg,
                              Deoptimizer::kEagerWithResumeImmedArgs1PcOffset));
@@ -4103,8 +4115,7 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
       handler_arg,
       MemOperand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
 
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ Branch(&deopt, ne, v0,
diff --git a/src/builtins/mips64/builtins-mips64.cc b/src/builtins/mips64/builtins-mips64.cc
index 2a8aefe3da..38770c253b 100644
--- a/src/builtins/mips64/builtins-mips64.cc
+++ b/src/builtins/mips64/builtins-mips64.cc
@@ -3665,11 +3665,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -3677,18 +3691,15 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ Ld(handler_arg, MemOperand(fp, CommonFrameConstants::kCallerPCOffset));
   __ Uld(slot_arg, MemOperand(handler_arg,
                               Deoptimizer::kEagerWithResumeImmedArgs1PcOffset));
   __ Uld(
       handler_arg,
       MemOperand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ Branch(&deopt, ne, v0,
diff --git a/src/builtins/ppc/builtins-ppc.cc b/src/builtins/ppc/builtins-ppc.cc
index dd8d742301..eae43982ae 100644
--- a/src/builtins/ppc/builtins-ppc.cc
+++ b/src/builtins/ppc/builtins-ppc.cc
@@ -3437,11 +3437,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -3449,10 +3463,8 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ LoadU64(handler_arg,
              MemOperand(fp, CommonFrameConstants::kCallerPCOffset));
   __ LoadU64(
@@ -3462,8 +3474,7 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
       handler_arg,
       MemOperand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
 
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ cmpi(r3, Operand(static_cast<int>(DynamicCheckMapsStatus::kSuccess)));
diff --git a/src/builtins/riscv64/builtins-riscv64.cc b/src/builtins/riscv64/builtins-riscv64.cc
index 11b4532b68..03f20057e6 100644
--- a/src/builtins/riscv64/builtins-riscv64.cc
+++ b/src/builtins/riscv64/builtins-riscv64.cc
@@ -3778,11 +3778,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicMapChecks builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -3790,18 +3804,15 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ Ld(handler_arg, MemOperand(fp, CommonFrameConstants::kCallerPCOffset));
   __ Uld(slot_arg, MemOperand(handler_arg,
                               Deoptimizer::kEagerWithResumeImmedArgs1PcOffset));
   __ Uld(
       handler_arg,
       MemOperand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ Branch(&deopt, ne, a0,
diff --git a/src/builtins/s390/builtins-s390.cc b/src/builtins/s390/builtins-s390.cc
index 04eba7a26e..2370f5ed57 100644
--- a/src/builtins/s390/builtins-s390.cc
+++ b/src/builtins/s390/builtins-s390.cc
@@ -3428,11 +3428,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -3440,10 +3454,8 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ LoadU64(handler_arg,
              MemOperand(fp, CommonFrameConstants::kCallerPCOffset));
   __ LoadU64(
@@ -3453,8 +3465,7 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
       handler_arg,
       MemOperand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
 
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ CmpS64(r2, Operand(static_cast<int>(DynamicCheckMapsStatus::kSuccess)));
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index 5fb5b27f18..993f8234af 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -4520,11 +4520,25 @@ void Builtins::Generate_InterpreterOnStackReplacement_ToBaseline(
 }
 
 void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<DynamicCheckMapsDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMaps));
+}
+
+void Builtins::Generate_DynamicCheckMapsWithFeedbackVectorTrampoline(
+    MacroAssembler* masm) {
+  Generate_DynamicCheckMapsTrampoline<
+      DynamicCheckMapsWithFeedbackVectorDescriptor>(
+      masm, BUILTIN_CODE(masm->isolate(), DynamicCheckMapsWithFeedbackVector));
+}
+
+template <class Descriptor>
+void Builtins::Generate_DynamicCheckMapsTrampoline(
+    MacroAssembler* masm, Handle<Code> builtin_target) {
   FrameScope scope(masm, StackFrame::MANUAL);
   __ EnterFrame(StackFrame::INTERNAL);
 
   // Only save the registers that the DynamicCheckMaps builtin can clobber.
-  DynamicCheckMapsDescriptor descriptor;
+  Descriptor descriptor;
   RegList registers = descriptor.allocatable_registers();
   // FLAG_debug_code is enabled CSA checks will call C function and so we need
   // to save all CallerSaved registers too.
@@ -4532,10 +4546,8 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
   __ MaybeSaveRegisters(registers);
 
   // Load the immediate arguments from the deopt exit to pass to the builtin.
-  Register slot_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kSlot);
-  Register handler_arg =
-      descriptor.GetRegisterParameter(DynamicCheckMapsDescriptor::kHandler);
+  Register slot_arg = descriptor.GetRegisterParameter(Descriptor::kSlot);
+  Register handler_arg = descriptor.GetRegisterParameter(Descriptor::kHandler);
   __ movq(handler_arg, Operand(rbp, CommonFrameConstants::kCallerPCOffset));
   __ movq(slot_arg, Operand(handler_arg,
                             Deoptimizer::kEagerWithResumeImmedArgs1PcOffset));
@@ -4543,8 +4555,7 @@ void Builtins::Generate_DynamicCheckMapsTrampoline(MacroAssembler* masm) {
       handler_arg,
       Operand(handler_arg, Deoptimizer::kEagerWithResumeImmedArgs2PcOffset));
 
-  __ Call(BUILTIN_CODE(masm->isolate(), DynamicCheckMaps),
-          RelocInfo::CODE_TARGET);
+  __ Call(builtin_target, RelocInfo::CODE_TARGET);
 
   Label deopt, bailout;
   __ cmpq(rax, Immediate(static_cast<int>(DynamicCheckMapsStatus::kSuccess)));
diff --git a/src/codegen/arm/interface-descriptors-arm-inl.h b/src/codegen/arm/interface-descriptors-arm-inl.h
index b1157a4eeb..83d82fe3ce 100644
--- a/src/codegen/arm/interface-descriptors-arm-inl.h
+++ b/src/codegen/arm/interface-descriptors-arm-inl.h
@@ -47,6 +47,12 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   return RegisterArray(r0, r1, r2, r3, cp);
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(kReturnRegister0 == r0);
+  return RegisterArray(r0, r1, r2, r3, cp);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return r1; }
 // static
diff --git a/src/codegen/arm64/interface-descriptors-arm64-inl.h b/src/codegen/arm64/interface-descriptors-arm64-inl.h
index ec9786f5a6..e8fe4ef1d3 100644
--- a/src/codegen/arm64/interface-descriptors-arm64-inl.h
+++ b/src/codegen/arm64/interface-descriptors-arm64-inl.h
@@ -47,6 +47,12 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   return RegisterArray(x0, x1, x2, x3, cp);
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(kReturnRegister0 == x0);
+  return RegisterArray(x0, x1, x2, x3, cp);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return x1; }
 // static
diff --git a/src/codegen/ia32/interface-descriptors-ia32-inl.h b/src/codegen/ia32/interface-descriptors-ia32-inl.h
index 5ad23d6626..b383b5df76 100644
--- a/src/codegen/ia32/interface-descriptors-ia32-inl.h
+++ b/src/codegen/ia32/interface-descriptors-ia32-inl.h
@@ -42,6 +42,13 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   return RegisterArray(eax, ecx, edx, edi, esi);
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(esi == kContextRegister);
+  STATIC_ASSERT(eax == kReturnRegister0);
+  return RegisterArray(eax, ecx, edx, edi, esi);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return edx; }
 // static
diff --git a/src/codegen/interface-descriptors.h b/src/codegen/interface-descriptors.h
index 2e75adcf93..cf4840bfd7 100644
--- a/src/codegen/interface-descriptors.h
+++ b/src/codegen/interface-descriptors.h
@@ -67,6 +67,7 @@ namespace internal {
   V(ContextOnly)                         \
   V(CppBuiltinAdaptor)                   \
   V(DynamicCheckMaps)                    \
+  V(DynamicCheckMapsWithFeedbackVector)  \
   V(FastNewObject)                       \
   V(ForInPrepare)                        \
   V(GetIteratorStackParameter)           \
@@ -997,6 +998,24 @@ class DynamicCheckMapsDescriptor final
   static constexpr bool kRestrictAllocatableRegisters = true;
 };
 
+class DynamicCheckMapsWithFeedbackVectorDescriptor final
+    : public StaticCallInterfaceDescriptor<
+          DynamicCheckMapsWithFeedbackVectorDescriptor> {
+ public:
+  DEFINE_PARAMETERS(kMap, kFeedbackVector, kSlot, kHandler)
+  DEFINE_RESULT_AND_PARAMETER_TYPES(
+      MachineType::Int32(),          // return val
+      MachineType::TaggedPointer(),  // kMap
+      MachineType::TaggedPointer(),  // kFeedbackVector
+      MachineType::IntPtr(),         // kSlot
+      MachineType::TaggedSigned())   // kHandler
+
+  DECLARE_DESCRIPTOR(DynamicCheckMapsWithFeedbackVectorDescriptor)
+
+  static constexpr auto registers();
+  static constexpr bool kRestrictAllocatableRegisters = true;
+};
+
 class FastNewObjectDescriptor
     : public StaticCallInterfaceDescriptor<FastNewObjectDescriptor> {
  public:
diff --git a/src/codegen/mips/interface-descriptors-mips-inl.h b/src/codegen/mips/interface-descriptors-mips-inl.h
index cf91453701..f4531d5413 100644
--- a/src/codegen/mips/interface-descriptors-mips-inl.h
+++ b/src/codegen/mips/interface-descriptors-mips-inl.h
@@ -43,6 +43,12 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   return RegisterArray(kReturnRegister0, a0, a1, a2, cp);
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(kReturnRegister0 == v0);
+  return RegisterArray(kReturnRegister0, a0, a1, a2, cp);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return a1; }
 // static
diff --git a/src/codegen/mips64/interface-descriptors-mips64-inl.h b/src/codegen/mips64/interface-descriptors-mips64-inl.h
index e7345a9371..3bb84dfa37 100644
--- a/src/codegen/mips64/interface-descriptors-mips64-inl.h
+++ b/src/codegen/mips64/interface-descriptors-mips64-inl.h
@@ -47,6 +47,12 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   return RegisterArray(kReturnRegister0, a0, a1, a2, cp);
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(kReturnRegister0 == v0);
+  return RegisterArray(kReturnRegister0, a0, a1, a2, cp);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return a1; }
 // static
diff --git a/src/codegen/ppc/interface-descriptors-ppc-inl.h b/src/codegen/ppc/interface-descriptors-ppc-inl.h
index 9e00508aeb..adc36e2407 100644
--- a/src/codegen/ppc/interface-descriptors-ppc-inl.h
+++ b/src/codegen/ppc/interface-descriptors-ppc-inl.h
@@ -47,6 +47,12 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   return RegisterArray(r3, r4, r5, r6, cp);
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(kReturnRegister0 == r3);
+  return RegisterArray(r3, r4, r5, r6, cp);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return r4; }
 // static
diff --git a/src/codegen/riscv64/interface-descriptors-riscv64-inl.h b/src/codegen/riscv64/interface-descriptors-riscv64-inl.h
index cda284bf26..1200b138e8 100644
--- a/src/codegen/riscv64/interface-descriptors-riscv64-inl.h
+++ b/src/codegen/riscv64/interface-descriptors-riscv64-inl.h
@@ -48,6 +48,12 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   return RegisterArray(kReturnRegister0, a1, a2, a3, cp);
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(kReturnRegister0 == a0);
+  return RegisterArray(kReturnRegister0, a1, a2, a3, cp);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return a1; }
 // static
diff --git a/src/codegen/s390/interface-descriptors-s390-inl.h b/src/codegen/s390/interface-descriptors-s390-inl.h
index 91c9da0190..a51909b936 100644
--- a/src/codegen/s390/interface-descriptors-s390-inl.h
+++ b/src/codegen/s390/interface-descriptors-s390-inl.h
@@ -46,6 +46,13 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
   STATIC_ASSERT(kReturnRegister0 == r2);
   return RegisterArray(r2, r3, r4, r5, cp);
 }
+
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+  STATIC_ASSERT(kReturnRegister0 == r2);
+  return RegisterArray(r2, r3, r4, r5, cp);
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return r3; }
 // static
diff --git a/src/codegen/x64/interface-descriptors-x64-inl.h b/src/codegen/x64/interface-descriptors-x64-inl.h
index 63e6489b2f..50ba12b836 100644
--- a/src/codegen/x64/interface-descriptors-x64-inl.h
+++ b/src/codegen/x64/interface-descriptors-x64-inl.h
@@ -65,6 +65,18 @@ constexpr auto DynamicCheckMapsDescriptor::registers() {
 #endif  // V8_TARGET_OS_WIN
 }
 
+// static
+constexpr auto DynamicCheckMapsWithFeedbackVectorDescriptor::registers() {
+#if V8_TARGET_OS_WIN
+  return RegisterArray(kReturnRegister0, arg_reg_1, arg_reg_2, arg_reg_3,
+                       kRuntimeCallFunctionRegister, kContextRegister);
+#else
+  STATIC_ASSERT(kContextRegister == arg_reg_2);
+  return RegisterArray(kReturnRegister0, arg_reg_1, arg_reg_2, arg_reg_3,
+                       kRuntimeCallFunctionRegister);
+#endif  // V8_TARGET_OS_WIN
+}
+
 // static
 constexpr Register LoadDescriptor::ReceiverRegister() { return rdx; }
 // static
diff --git a/src/compiler/backend/arm64/code-generator-arm64.cc b/src/compiler/backend/arm64/code-generator-arm64.cc
index 02f71fcc1e..ceb05f0c63 100644
--- a/src/compiler/backend/arm64/code-generator-arm64.cc
+++ b/src/compiler/backend/arm64/code-generator-arm64.cc
@@ -3375,13 +3375,12 @@ void CodeGenerator::PrepareForDeoptimizationExits(
   // Check which deopt kinds exist in this Code object, to avoid emitting jumps
   // to unused entries.
   bool saw_deopt_kind[kDeoptimizeKindCount] = {false};
-  constexpr auto eager_with_resume_reason = DeoptimizeReason::kDynamicCheckMaps;
+  bool saw_deopt_with_resume_reason[kDeoptimizeReasonCount] = {false};
   for (auto exit : *exits) {
-    // TODO(rmcilroy): If we add any other kinds of kEagerWithResume deoptimize
-    // we will need to create a seperate array for each kEagerWithResume builtin
-    DCHECK_IMPLIES(exit->kind() == DeoptimizeKind::kEagerWithResume,
-                   exit->reason() == eager_with_resume_reason);
     saw_deopt_kind[static_cast<int>(exit->kind())] = true;
+    if (exit->kind() == DeoptimizeKind::kEagerWithResume) {
+      saw_deopt_with_resume_reason[static_cast<int>(exit->reason())] = true;
+    }
   }
 
   // Emit the jumps to deoptimization entries.
@@ -3390,13 +3389,17 @@ void CodeGenerator::PrepareForDeoptimizationExits(
   STATIC_ASSERT(static_cast<int>(kFirstDeoptimizeKind) == 0);
   for (int i = 0; i < kDeoptimizeKindCount; i++) {
     if (!saw_deopt_kind[i]) continue;
-    __ bind(&jump_deoptimization_entry_labels_[i]);
     DeoptimizeKind kind = static_cast<DeoptimizeKind>(i);
     if (kind == DeoptimizeKind::kEagerWithResume) {
-      __ LoadEntryFromBuiltin(
-          Deoptimizer::GetDeoptWithResumeBuiltin(eager_with_resume_reason),
-          scratch);
+      for (int j = 0; j < kDeoptimizeReasonCount; j++) {
+        if (!saw_deopt_with_resume_reason[j]) continue;
+        DeoptimizeReason reason = static_cast<DeoptimizeReason>(j);
+        __ bind(&jump_deoptimization_or_resume_entry_labels_[j]);
+        __ LoadEntryFromBuiltin(Deoptimizer::GetDeoptWithResumeBuiltin(reason),
+                                scratch);
+      }
     } else {
+      __ bind(&jump_deoptimization_entry_labels_[i]);
       __ LoadEntryFromBuiltin(Deoptimizer::GetDeoptimizationEntry(kind),
                               scratch);
     }
diff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.cc
index c28d4138e8..9df9498390 100644
--- a/src/compiler/backend/code-generator.cc
+++ b/src/compiler/backend/code-generator.cc
@@ -211,8 +211,15 @@ CodeGenerator::CodeGenResult CodeGenerator::AssembleDeoptimizerCall(
 
   DeoptimizeKind deopt_kind = exit->kind();
   DeoptimizeReason deoptimization_reason = exit->reason();
-  Label* jump_deoptimization_entry_label =
-      &jump_deoptimization_entry_labels_[static_cast<int>(deopt_kind)];
+  Label* jump_deoptimization_entry_label;
+  if (deopt_kind == DeoptimizeKind::kEagerWithResume) {
+    jump_deoptimization_entry_label =
+        &jump_deoptimization_or_resume_entry_labels_[static_cast<int>(
+            deoptimization_reason)];
+  } else {
+    jump_deoptimization_entry_label =
+        &jump_deoptimization_entry_labels_[static_cast<int>(deopt_kind)];
+  }
   if (info()->source_positions()) {
     tasm()->RecordDeoptReason(deoptimization_reason, exit->pos(),
                               deoptimization_id);
diff --git a/src/compiler/backend/code-generator.h b/src/compiler/backend/code-generator.h
index 9428783ca7..7ccb09d5ac 100644
--- a/src/compiler/backend/code-generator.h
+++ b/src/compiler/backend/code-generator.h
@@ -456,6 +456,7 @@ class V8_EXPORT_PRIVATE CodeGenerator final : public GapResolver::Assembler {
   // per Code object. All deopt exits can then near-call to this label. Note:
   // not used on all architectures.
   Label jump_deoptimization_entry_labels_[kDeoptimizeKindCount];
+  Label jump_deoptimization_or_resume_entry_labels_[kDeoptimizeReasonCount];
 
   // The maximal combined height of all frames produced upon deoptimization, and
   // the maximal number of pushed arguments for function calls. Applied as an
diff --git a/src/compiler/backend/instruction-selector.cc b/src/compiler/backend/instruction-selector.cc
index f94bc3ef2c..bf140d38a7 100644
--- a/src/compiler/backend/instruction-selector.cc
+++ b/src/compiler/backend/instruction-selector.cc
@@ -3158,26 +3158,44 @@ void InstructionSelector::VisitDynamicCheckMapsWithDeoptUnless(Node* node) {
   DynamicCheckMapsWithDeoptUnlessNode n(node);
   DeoptimizeParameters p = DeoptimizeParametersOf(node->op());
 
-  DynamicCheckMapsDescriptor descriptor;
-  // Note: We use Operator::kNoDeopt here because this builtin does not lazy
-  // deoptimize (which is the meaning of Operator::kNoDeopt), even though it can
-  // eagerly deoptimize.
-  CallDescriptor* call_descriptor = Linkage::GetStubCallDescriptor(
-      zone(), descriptor, descriptor.GetStackParameterCount(),
-      CallDescriptor::kNoFlags, Operator::kNoDeopt | Operator::kNoThrow);
-  InstructionOperand dynamic_check_args[] = {
-      g.UseLocation(n.map(), call_descriptor->GetInputLocation(1)),
-      g.UseImmediate(n.slot()), g.UseImmediate(n.handler())};
+  CallDescriptor* call_descriptor;
+  ZoneVector<InstructionOperand> dynamic_check_args(zone());
+
+  if (p.reason() == DeoptimizeReason::kDynamicCheckMaps) {
+    DynamicCheckMapsDescriptor descriptor;
+    // Note: We use Operator::kNoDeopt here because this builtin does not lazy
+    // deoptimize (which is the meaning of Operator::kNoDeopt), even though it
+    // can eagerly deoptimize.
+    call_descriptor = Linkage::GetStubCallDescriptor(
+        zone(), descriptor, descriptor.GetStackParameterCount(),
+        CallDescriptor::kNoFlags, Operator::kNoDeopt | Operator::kNoThrow);
+    dynamic_check_args.insert(
+        dynamic_check_args.end(),
+        {g.UseLocation(n.map(), call_descriptor->GetInputLocation(1)),
+         g.UseImmediate(n.slot()), g.UseImmediate(n.handler())});
+  } else {
+    DCHECK_EQ(p.reason(), DeoptimizeReason::kDynamicCheckMapsInlined);
+    DynamicCheckMapsWithFeedbackVectorDescriptor descriptor;
+    call_descriptor = Linkage::GetStubCallDescriptor(
+        zone(), descriptor, descriptor.GetStackParameterCount(),
+        CallDescriptor::kNoFlags, Operator::kNoDeopt | Operator::kNoThrow);
+    dynamic_check_args.insert(
+        dynamic_check_args.end(),
+        {g.UseLocation(n.map(), call_descriptor->GetInputLocation(1)),
+         g.UseLocation(n.feedback_vector(),
+                       call_descriptor->GetInputLocation(2)),
+         g.UseImmediate(n.slot()), g.UseImmediate(n.handler())});
+  }
 
   if (NeedsPoisoning(IsSafetyCheck::kCriticalSafetyCheck)) {
     FlagsContinuation cont = FlagsContinuation::ForDeoptimizeAndPoison(
         kEqual, p.kind(), p.reason(), p.feedback(), n.frame_state(),
-        dynamic_check_args, 3);
+        dynamic_check_args.data(), static_cast<int>(dynamic_check_args.size()));
     VisitWordCompareZero(node, n.condition(), &cont);
   } else {
     FlagsContinuation cont = FlagsContinuation::ForDeoptimize(
         kEqual, p.kind(), p.reason(), p.feedback(), n.frame_state(),
-        dynamic_check_args, 3);
+        dynamic_check_args.data(), static_cast<int>(dynamic_check_args.size()));
     VisitWordCompareZero(node, n.condition(), &cont);
   }
 }
diff --git a/src/compiler/common-operator.cc b/src/compiler/common-operator.cc
index 9d30f4a9e5..5fec8b7731 100644
--- a/src/compiler/common-operator.cc
+++ b/src/compiler/common-operator.cc
@@ -563,6 +563,10 @@ IfValueParameters const& IfValueParametersOf(const Operator* op) {
   V(Eager, WrongInstanceType, SafetyCheck)    \
   V(Eager, WrongMap, SafetyCheck)
 
+#define CACHED_DYNAMIC_CHECK_MAPS_LIST(V) \
+  V(DynamicCheckMaps)                     \
+  V(DynamicCheckMapsInlined)
+
 #define CACHED_TRAP_IF_LIST(V) \
   V(TrapDivUnrepresentable)    \
   V(TrapFloatUnrepresentable)
@@ -801,19 +805,22 @@ struct CommonOperatorGlobalCache final {
   CACHED_DEOPTIMIZE_UNLESS_LIST(CACHED_DEOPTIMIZE_UNLESS)
 #undef CACHED_DEOPTIMIZE_UNLESS
 
+  template <DeoptimizeReason kReason>
   struct DynamicMapCheckOperator final : Operator1<DeoptimizeParameters> {
     DynamicMapCheckOperator()
         : Operator1<DeoptimizeParameters>(                 // --
               IrOpcode::kDynamicCheckMapsWithDeoptUnless,  // opcode
               Operator::kFoldable | Operator::kNoThrow,    // properties
               "DynamicCheckMapsWithDeoptUnless",           // name
-              5, 1, 1, 0, 1, 1,                            // counts
-              DeoptimizeParameters(DeoptimizeKind::kEagerWithResume,
-                                   DeoptimizeReason::kDynamicCheckMaps,
+              6, 1, 1, 0, 1, 1,                            // counts
+              DeoptimizeParameters(DeoptimizeKind::kEagerWithResume, kReason,
                                    FeedbackSource(),
                                    IsSafetyCheck::kCriticalSafetyCheck)) {}
   };
-  DynamicMapCheckOperator kDynamicCheckMapsWithDeoptUnless;
+#define CACHED_DYNAMIC_CHECK_MAPS(Reason) \
+  DynamicMapCheckOperator<DeoptimizeReason::k##Reason> k##Reason##Operator;
+  CACHED_DYNAMIC_CHECK_MAPS_LIST(CACHED_DYNAMIC_CHECK_MAPS)
+#undef CACHED_DYNAMIC_CHECK_MAPS
 
   template <TrapId trap_id>
   struct TrapIfOperator final : public Operator1<TrapId> {
@@ -1052,8 +1059,13 @@ const Operator* CommonOperatorBuilder::DeoptimizeUnless(
       parameter);                                       // parameter
 }
 
-const Operator* CommonOperatorBuilder::DynamicCheckMapsWithDeoptUnless() {
-  return &cache_.kDynamicCheckMapsWithDeoptUnless;
+const Operator* CommonOperatorBuilder::DynamicCheckMapsWithDeoptUnless(
+    bool is_inlined_frame_state) {
+  if (is_inlined_frame_state) {
+    return &cache_.kDynamicCheckMapsInlinedOperator;
+  } else {
+    return &cache_.kDynamicCheckMapsOperator;
+  }
 }
 
 const Operator* CommonOperatorBuilder::TrapIf(TrapId trap_id) {
diff --git a/src/compiler/common-operator.h b/src/compiler/common-operator.h
index a607c77769..a0b26a7298 100644
--- a/src/compiler/common-operator.h
+++ b/src/compiler/common-operator.h
@@ -498,7 +498,7 @@ class V8_EXPORT_PRIVATE CommonOperatorBuilder final
   // DynamicCheckMapsWithDeoptUnless will call the dynamic map check builtin if
   // the condition is false, which may then either deoptimize or resume
   // execution.
-  const Operator* DynamicCheckMapsWithDeoptUnless();
+  const Operator* DynamicCheckMapsWithDeoptUnless(bool is_inlined_frame_state);
   const Operator* TrapIf(TrapId trap_id);
   const Operator* TrapUnless(TrapId trap_id);
   const Operator* Return(int value_input_count = 1);
@@ -784,12 +784,13 @@ class DynamicCheckMapsWithDeoptUnlessNode final : public CommonNodeWrapperBase {
   V(Condition, condition, 0, BoolT) \
   V(Slot, slot, 1, IntPtrT)         \
   V(Map, map, 2, Map)               \
-  V(Handler, handler, 3, Object)
+  V(Handler, handler, 3, Object)    \
+  V(FeedbackVector, feedback_vector, 4, FeedbackVector)
   INPUTS(DEFINE_INPUT_ACCESSORS)
 #undef INPUTS
 
   FrameState frame_state() {
-    return FrameState{NodeProperties::GetValueInput(node(), 4)};
+    return FrameState{NodeProperties::GetValueInput(node(), 5)};
   }
 };
 
diff --git a/src/compiler/effect-control-linearizer.cc b/src/compiler/effect-control-linearizer.cc
index f9412c22b1..8b4ad960e9 100644
--- a/src/compiler/effect-control-linearizer.cc
+++ b/src/compiler/effect-control-linearizer.cc
@@ -1927,12 +1927,14 @@ void EffectControlLinearizer::TryMigrateInstance(Node* value, Node* value_map) {
 }
 
 void EffectControlLinearizer::LowerDynamicCheckMaps(Node* node,
-                                                    Node* frame_state) {
+                                                    Node* frame_state_node) {
   DynamicCheckMapsParameters const& p =
       DynamicCheckMapsParametersOf(node->op());
+  FrameState frame_state(frame_state_node);
   Node* value = node->InputAt(0);
 
   FeedbackSource const& feedback = p.feedback();
+  Node* feedback_vector = __ HeapConstant(feedback.vector);
   Node* slot_index = __ IntPtrConstant(feedback.index());
   Node* value_map = __ LoadField(AccessBuilder::ForMap(), value);
   Node* actual_handler =
@@ -1961,7 +1963,8 @@ void EffectControlLinearizer::LowerDynamicCheckMaps(Node* node,
       }
 
       __ DynamicCheckMapsWithDeoptUnless(check, slot_index, value_map,
-                                         actual_handler, frame_state);
+                                         actual_handler, feedback_vector,
+                                         frame_state);
       __ Goto(&done);
     } else {
       auto next_map = __ MakeLabel();
diff --git a/src/compiler/graph-assembler.cc b/src/compiler/graph-assembler.cc
index 64f5d0c584..7770da9ed6 100644
--- a/src/compiler/graph-assembler.cc
+++ b/src/compiler/graph-assembler.cc
@@ -859,10 +859,13 @@ Node* GraphAssembler::DeoptimizeIfNot(DeoptimizeReason reason,
 Node* GraphAssembler::DynamicCheckMapsWithDeoptUnless(Node* condition,
                                                       Node* slot_index,
                                                       Node* value, Node* map,
-                                                      Node* frame_state) {
-  return AddNode(graph()->NewNode(common()->DynamicCheckMapsWithDeoptUnless(),
+                                                      Node* feedback_vector,
+                                                      FrameState frame_state) {
+  return AddNode(graph()->NewNode(common()->DynamicCheckMapsWithDeoptUnless(
+                                      frame_state.has_outer_frame_state()),
                                   condition, slot_index, value, map,
-                                  frame_state, effect(), control()));
+                                  feedback_vector, frame_state, effect(),
+                                  control()));
 }
 
 TNode<Object> GraphAssembler::Call(const CallDescriptor* call_descriptor,
diff --git a/src/compiler/graph-assembler.h b/src/compiler/graph-assembler.h
index d368f36407..b6f6057519 100644
--- a/src/compiler/graph-assembler.h
+++ b/src/compiler/graph-assembler.h
@@ -349,7 +349,8 @@ class V8_EXPORT_PRIVATE GraphAssembler {
       IsSafetyCheck is_safety_check = IsSafetyCheck::kSafetyCheck);
   Node* DynamicCheckMapsWithDeoptUnless(Node* condition, Node* slot_index,
                                         Node* map, Node* handler,
-                                        Node* frame_state);
+                                        Node* feedback_vector,
+                                        FrameState frame_state);
   TNode<Object> Call(const CallDescriptor* call_descriptor, int inputs_size,
                      Node** inputs);
   TNode<Object> Call(const Operator* op, int inputs_size, Node** inputs);
diff --git a/src/compiler/js-native-context-specialization.cc b/src/compiler/js-native-context-specialization.cc
index 375508bca9..87d44abff5 100644
--- a/src/compiler/js-native-context-specialization.cc
+++ b/src/compiler/js-native-context-specialization.cc
@@ -1092,16 +1092,6 @@ Reduction JSNativeContextSpecialization::ReduceMinimorphicPropertyAccess(
               : SerializationPolicy::kSerializeIfNeeded);
   if (access_info.IsInvalid()) return NoChange();
 
-  // The dynamic map check operator loads the feedback vector from the
-  // function's frame, so we can only use this for non-inlined functions.
-  // TODO(rmcilroy): Add support for using a trampoline like LoadICTrampoline
-  // and otherwise pass feedback vector explicitly if we need support for
-  // inlined functions.
-  // TODO(rmcilroy): Ideally we would check whether we are have an inlined frame
-  // state here, but there isn't a good way to distinguish inlined from OSR
-  // framestates.
-  DCHECK(broker()->is_turboprop());
-
   PropertyAccessBuilder access_builder(jsgraph(), broker(), nullptr);
   CheckMapsFlags flags = CheckMapsFlag::kNone;
   if (feedback.has_migration_target_maps()) {
diff --git a/src/deoptimizer/deoptimize-reason.h b/src/deoptimizer/deoptimize-reason.h
index c7db10e6f8..abf4d263ea 100644
--- a/src/deoptimizer/deoptimize-reason.h
+++ b/src/deoptimizer/deoptimize-reason.h
@@ -18,6 +18,7 @@ namespace internal {
   V(DeoptimizeNow, "%_DeoptimizeNow")                                          \
   V(DivisionByZero, "division by zero")                                        \
   V(DynamicCheckMaps, "dynamic check maps failed")                             \
+  V(DynamicCheckMapsInlined, "dynamic check maps failed")                      \
   V(Hole, "hole")                                                              \
   V(InstanceMigrationFailed, "instance migration failed")                      \
   V(InsufficientTypeFeedbackForCall, "Insufficient type feedback for call")    \
@@ -78,6 +79,14 @@ enum class DeoptimizeReason : uint8_t {
 #undef DEOPTIMIZE_REASON
 };
 
+constexpr DeoptimizeReason kFirstDeoptimizeReason =
+    DeoptimizeReason::kArrayBufferWasDetached;
+constexpr DeoptimizeReason kLastDeoptimizeReason =
+    DeoptimizeReason::kArrayLengthChanged;
+STATIC_ASSERT(static_cast<int>(kFirstDeoptimizeReason) == 0);
+constexpr int kDeoptimizeReasonCount =
+    static_cast<int>(kLastDeoptimizeReason) + 1;
+
 V8_EXPORT_PRIVATE std::ostream& operator<<(std::ostream&, DeoptimizeReason);
 
 size_t hash_value(DeoptimizeReason reason);
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index b7bd889e49..1d5fc0f655 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -638,6 +638,8 @@ Builtin Deoptimizer::GetDeoptWithResumeBuiltin(DeoptimizeReason reason) {
   switch (reason) {
     case DeoptimizeReason::kDynamicCheckMaps:
       return Builtin::kDynamicCheckMapsTrampoline;
+    case DeoptimizeReason::kDynamicCheckMapsInlined:
+      return Builtin::kDynamicCheckMapsWithFeedbackVectorTrampoline;
     default:
       UNREACHABLE();
   }
diff --git a/test/mjsunit/const-field-tracking-2.js b/test/mjsunit/const-field-tracking-2.js
index 86cbb51a3b..34511cc836 100644
--- a/test/mjsunit/const-field-tracking-2.js
+++ b/test/mjsunit/const-field-tracking-2.js
@@ -6,6 +6,7 @@
 // from turboprop.
 //
 // Flags: --allow-natives-syntax --opt --no-always-opt --turboprop
+// Flags: --turbo-dynamic-map-checks
 
 var global = this;
 var unique_id = 0;
diff --git a/test/mjsunit/mjsunit.status b/test/mjsunit/mjsunit.status
index 5f6a9b1be7..b4e245d9d0 100644
--- a/test/mjsunit/mjsunit.status
+++ b/test/mjsunit/mjsunit.status
@@ -176,10 +176,6 @@
   # Needs to be adapted after changes to Function constructor. chromium:1065094
   'cross-realm-filtering': [SKIP],
 
-  # Re-enable again with dynamic map checks. (https://crbug.com/v8/9684)
-  'const-field-tracking-2': [SKIP],
-  'regress/regress-1141502': [SKIP],
-
   # Tests that need to run sequentially (e.g. due to memory consumption).
   'compiler/array-subclass': [PASS, HEAVY],
   'compiler/regress-crbug-11564': [PASS, HEAVY],
-- 
2.35.1


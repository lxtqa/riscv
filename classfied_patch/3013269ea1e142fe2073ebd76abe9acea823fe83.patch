From 3013269ea1e142fe2073ebd76abe9acea823fe83 Mon Sep 17 00:00:00 2001
From: jingpeiyang <jingpeiyang@eswincomputing.com>
Date: Wed, 8 Mar 2023 09:04:04 +0800
Subject: [PATCH] [riscv][simulator]Modify the error of the fsgnj64

Sign-injection instructions(FSGNJ.S) do not set floating-point exception flags, nor do they canonicalize NaNs.

Fix the following errors under the riscv32 architecture:
 - wasm-spec-tests/conversions
 - wasm-spec-tests/float_memory
 - wasm-spec-tests/float_exprs
 - wasm-spec-tests/float_misc
 - wasm-spec-tests/select
 - wasm-spec-tests/proposals/js-types/select
 - wasm-spec-tests/proposals/memory64/float_memory64
 - wasm-spec-tests/proposals/memory64/select

Signed-off-by: jingpeiyang <jingpeiyang@eswincomputing.com>
Change-Id: I7d5d2b1981e6f7764f44641937b3fd3576e2e149
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/4305546
Commit-Queue: Yahan Lu <yahan@iscas.ac.cn>
Reviewed-by: Yahan Lu <yahan@iscas.ac.cn>
Cr-Commit-Position: refs/heads/main@{#86291}
---
 src/execution/riscv/simulator-riscv.h |  2 +-
 test/cctest/test-assembler-riscv32.cc | 45 +++++++++++++++++++++++++++
 test/cctest/test-assembler-riscv64.cc | 22 +++++++++++++
 3 files changed, 68 insertions(+), 1 deletion(-)

diff --git a/src/execution/riscv/simulator-riscv.h b/src/execution/riscv/simulator-riscv.h
index 3464a0f523..c744bf9921 100644
--- a/src/execution/riscv/simulator-riscv.h
+++ b/src/execution/riscv/simulator-riscv.h
@@ -200,7 +200,7 @@ inline double fsgnj64(double rs1, double rs2, bool n, bool x) {
 }
 
 inline Float64 fsgnj64(Float64 rs1, Float64 rs2, bool n, bool x) {
-  u64_f64 a = {.d = rs1.get_scalar()}, b = {.d = rs2.get_scalar()};
+  u64_f64 a = {.u = rs1.get_bits()}, b = {.u = rs2.get_bits()};
   u64_f64 res;
   if (x) {  // RO_FSQNJX_D
     res.u = (a.u & ~F64_SIGN) | ((a.u ^ b.u) & F64_SIGN);
diff --git a/test/cctest/test-assembler-riscv32.cc b/test/cctest/test-assembler-riscv32.cc
index acac163688..83428eb2f1 100644
--- a/test/cctest/test-assembler-riscv32.cc
+++ b/test/cctest/test-assembler-riscv32.cc
@@ -476,6 +476,40 @@ UTEST_R1_FORM_WITH_RES_F(fneg_s, float, 23.5f, -23.5f)
 // UTEST_R1_FORM_WITH_RES_F(fabs_d, double, -23.5, 23.5)
 // UTEST_R1_FORM_WITH_RES_F(fneg_d, double, 23.5, -23.5)
 
+// Test fmv_d
+TEST(RISCV_UTEST_fmv_d_double) {
+  CcTest::InitializeVM();
+
+  double src = base::bit_cast<double>(0xC037800000000000);  // -23.5
+  double dst;
+  auto fn = [](MacroAssembler& assm) {
+    __ fld(ft0, a0, 0);
+    __ fmv_d(fa0, ft0);
+    __ fsd(fa0, a1, 0);
+  };
+  GenAndRunTest<int32_t, double*>(&src, &dst, fn);
+  CHECK_EQ(base::bit_cast<int64_t>(0xC037800000000000),
+           base::bit_cast<int64_t>(dst));
+}
+
+// Test fmv_d
+// double not a canonical NaN
+TEST(RISCV_UTEST_fmv_d_double_NAN_BOX) {
+  CcTest::InitializeVM();
+
+  int64_t src = base::bit_cast<int64_t>(0x7ff4000000000000);
+  int64_t dst;
+  auto fn = [](MacroAssembler& assm) {
+    __ fld(ft0, a0, 0);
+    __ fmv_d(fa0, ft0);
+    __ fsd(fa0, a1, 0);
+  };
+
+  GenAndRunTest<int32_t, int64_t*>(&src, &dst, fn);
+  CHECK_EQ(base::bit_cast<int64_t>(0x7ff4000000000000),
+           base::bit_cast<int64_t>(dst));
+}
+
 // Test LI
 TEST(RISCV0) {
   CcTest::InitializeVM();
@@ -1039,6 +1073,17 @@ TEST(NAN_BOX) {
     CHECK_EQ((uint32_t)base::bit_cast<uint32_t>(1234.56f), res);
   }
 
+  // Test NaN boxing in FMV.S
+  {
+    auto fn = [](MacroAssembler& assm) {
+      __ fmv_w_x(fa0, a0);
+      __ fmv_s(ft1, fa0);
+      __ fmv_s(fa0, ft1);
+    };
+    auto res = GenAndRunTest<uint32_t>(0x7f400000, fn);
+    CHECK_EQ((uint32_t)base::bit_cast<uint32_t>(0x7f400000), res);
+  }
+
   // Test FLW and FSW
   Isolate* isolate = CcTest::i_isolate();
   HandleScope scope(isolate);
diff --git a/test/cctest/test-assembler-riscv64.cc b/test/cctest/test-assembler-riscv64.cc
index ebacbc4c49..36d1cc3749 100644
--- a/test/cctest/test-assembler-riscv64.cc
+++ b/test/cctest/test-assembler-riscv64.cc
@@ -1214,6 +1214,28 @@ TEST(NAN_BOX) {
     CHECK_EQ((uint64_t)base::bit_cast<uint32_t>(1234.56f), res);
   }
 
+  // Test NaN boxing in FMV.S
+  {
+    auto fn = [](MacroAssembler& assm) {
+      __ fmv_w_x(fa0, a0);
+      __ fmv_s(ft1, fa0);
+      __ fmv_s(fa0, ft1);
+    };
+    auto res = GenAndRunTest<uint32_t>(0x7f400000, fn);
+    CHECK_EQ((uint32_t)base::bit_cast<uint32_t>(0x7f400000), res);
+  }
+
+  // Test NaN boxing in FMV.D
+  {
+    auto fn = [](MacroAssembler& assm) {
+      __ fmv_d_x(fa0, a0);
+      __ fmv_d(ft1, fa0);
+      __ fmv_d(fa0, ft1);
+    };
+    auto res = GenAndRunTest<uint64_t>(0x7ff4000000000000, fn);
+    CHECK_EQ((uint64_t)base::bit_cast<uint64_t>(0x7ff4000000000000), res);
+  }
+
   // Test FLW and FSW
   Isolate* isolate = CcTest::i_isolate();
   HandleScope scope(isolate);
-- 
2.35.1


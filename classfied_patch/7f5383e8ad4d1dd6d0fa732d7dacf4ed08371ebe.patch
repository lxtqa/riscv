From 7f5383e8ad4d1dd6d0fa732d7dacf4ed08371ebe Mon Sep 17 00:00:00 2001
From: Dan Elphick <delphick@chromium.org>
Date: Thu, 17 Jun 2021 16:43:55 +0100
Subject: [PATCH] [base] Move utils/vector.h to base/vector.h

The adding of base:: was mostly prepared using git grep and sed:
git grep -l <pattern> | grep -v base/vector.h | \
  xargs sed -i 's/\b<pattern>\b/base::<pattern>/
with lots of manual clean-ups due to the resulting
v8::internal::base::Vectors.

#includes were fixed using:
git grep -l "src/utils/vector.h" | \
  axargs sed -i 's!src/utils/vector.h!src/base/vector.h!'

Bug: v8:11879
Change-Id: I3e6d622987fee4478089c40539724c19735bd625
Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/2968412
Reviewed-by: Clemens Backes <clemensb@chromium.org>
Reviewed-by: Hannes Payer <hpayer@chromium.org>
Commit-Queue: Dan Elphick <delphick@chromium.org>
Cr-Commit-Position: refs/heads/master@{#75243}
---
 BUILD.bazel                                   |   2 +-
 BUILD.gn                                      |   2 +-
 src/api/api.cc                                |  30 ++--
 src/asmjs/asm-js.cc                           |  45 +++---
 src/asmjs/asm-parser.cc                       |  22 +--
 src/asmjs/asm-parser.h                        |  18 +--
 src/asmjs/asm-scanner.cc                      |   2 +-
 src/ast/ast-value-factory.cc                  |  29 ++--
 src/ast/ast-value-factory.h                   |  17 ++-
 src/ast/prettyprinter.cc                      |  31 ++--
 src/{utils => base}/vector.h                  |  10 +-
 src/builtins/builtins-arraybuffer.cc          |   2 +-
 src/builtins/builtins-collections-gen.cc      |   2 +-
 src/builtins/builtins-date.cc                 |  22 +--
 src/builtins/builtins-function.cc             |   2 +-
 src/builtins/builtins-regexp-gen.cc           |   3 +-
 src/builtins/builtins-string.cc               |   2 +-
 src/builtins/builtins.cc                      |   4 +-
 src/codegen/assembler.cc                      |   6 +-
 src/codegen/code-stub-assembler.cc            |   4 +-
 src/codegen/code-stub-assembler.h             |   4 +-
 src/codegen/ia32/assembler-ia32.cc            |   5 +-
 src/codegen/mips/assembler-mips.cc            |   4 +-
 src/codegen/mips64/assembler-mips64.cc        |   4 +-
 src/codegen/optimized-compilation-info.cc     |   8 +-
 src/codegen/optimized-compilation-info.h      |   6 +-
 src/codegen/reloc-info.cc                     |   6 +-
 src/codegen/reloc-info.h                      |   6 +-
 src/codegen/riscv64/assembler-riscv64.cc      |   7 +-
 src/codegen/source-position-table.cc          |  21 +--
 src/codegen/source-position-table.h           |   8 +-
 src/compiler/backend/code-generator.cc        |   8 +-
 src/compiler/backend/code-generator.h         |   4 +-
 src/compiler/backend/register-allocator.cc    |  16 +-
 src/compiler/backend/register-allocator.h     |  10 +-
 src/compiler/code-assembler.cc                |   4 +-
 src/compiler/graph-visualizer.cc              |  10 +-
 src/compiler/pipeline.cc                      |  10 +-
 src/compiler/wasm-compiler.cc                 |  99 ++++++------
 src/compiler/wasm-compiler.h                  |  62 ++++----
 src/date/dateparser-inl.h                     |   2 +-
 src/date/dateparser.h                         |  10 +-
 src/debug/debug-interface.cc                  |   5 +-
 src/debug/debug-interface.h                   |   2 +-
 src/debug/debug-wasm-objects.cc               |  48 +++---
 .../wasm/gdb-server/wasm-module-debug.cc      |   4 +-
 src/deoptimizer/deoptimizer.cc                |   2 +-
 src/diagnostics/arm/disasm-arm.cc             |  12 +-
 src/diagnostics/arm64/disasm-arm64.cc         |   6 +-
 src/diagnostics/code-tracer.h                 |   4 +-
 src/diagnostics/disasm.h                      |   6 +-
 src/diagnostics/disassembler.cc               |   8 +-
 src/diagnostics/gdb-jit.cc                    |  11 +-
 src/diagnostics/ia32/disasm-ia32.cc           |  12 +-
 src/diagnostics/mips/disasm-mips.cc           |  10 +-
 src/diagnostics/mips64/disasm-mips64.cc       |  10 +-
 src/diagnostics/objects-printer.cc            |   4 +-
 src/diagnostics/perf-jit.cc                   |  11 +-
 src/diagnostics/ppc/disasm-ppc.cc             |  10 +-
 src/diagnostics/riscv64/disasm-riscv64.cc     |  10 +-
 src/diagnostics/s390/disasm-s390.cc           |  10 +-
 src/diagnostics/x64/disasm-x64.cc             |  12 +-
 src/execution/arm/simulator-arm.cc            |   8 +-
 src/execution/frames.cc                       |   2 +-
 src/execution/messages.cc                     |   4 +-
 src/execution/mips/simulator-mips.cc          |  10 +-
 src/execution/mips/simulator-mips.h           |   2 +-
 src/execution/mips64/simulator-mips64.cc      |  10 +-
 src/execution/mips64/simulator-mips64.h       |   2 +-
 src/execution/ppc/simulator-ppc.cc            |   8 +-
 src/execution/riscv64/simulator-riscv64.cc    |  12 +-
 src/execution/riscv64/simulator-riscv64.h     |   2 +-
 src/execution/s390/simulator-s390.cc          |   8 +-
 src/extensions/cputracemark-extension.h       |   4 +-
 src/extensions/gc-extension.h                 |   2 +-
 .../vtunedomain-support-extension.h           |   4 +-
 src/flags/flags.cc                            |   2 +-
 src/heap/factory-base.cc                      |  12 +-
 src/heap/factory-base.h                       |   8 +-
 src/heap/factory.cc                           |  43 +++---
 src/heap/factory.h                            |  23 +--
 src/heap/gc-tracer.cc                         |   2 +-
 src/heap/object-stats.cc                      |   2 +-
 src/init/bootstrapper.cc                      |   8 +-
 src/init/bootstrapper.h                       |   4 +-
 src/inspector/DEPS                            |   2 +-
 src/inspector/string-16.cc                    |   8 +-
 src/interpreter/interpreter.cc                |   3 +-
 src/json/json-parser.cc                       |  10 +-
 src/json/json-stringifier.cc                  |  12 +-
 src/logging/code-events.h                     |   4 +-
 src/logging/log-utils.cc                      |   6 +-
 src/logging/log-utils.h                       |  10 +-
 src/logging/log.cc                            |  10 +-
 src/logging/log.h                             |   4 +-
 src/numbers/bignum-dtoa.cc                    |  14 +-
 src/numbers/bignum-dtoa.h                     |   7 +-
 src/numbers/bignum.cc                         |   6 +-
 src/numbers/bignum.h                          |   8 +-
 src/numbers/conversions.cc                    |  58 +++----
 src/numbers/conversions.h                     |  10 +-
 src/numbers/dtoa.cc                           |   3 +-
 src/numbers/dtoa.h                            |   7 +-
 src/numbers/fast-dtoa.cc                      |  23 +--
 src/numbers/fast-dtoa.h                       |   4 +-
 src/numbers/fixed-dtoa.cc                     |  20 ++-
 src/numbers/fixed-dtoa.h                      |   4 +-
 src/numbers/strtod.cc                         |  36 ++---
 src/numbers/strtod.h                          |   4 +-
 src/objects/bigint.cc                         |   3 +-
 src/objects/bigint.h                          |   2 +-
 src/objects/code.cc                           |   2 +-
 src/objects/contexts.cc                       |   2 +-
 src/objects/intl-objects.cc                   |  15 +-
 src/objects/js-objects.cc                     |   8 +-
 src/objects/js-objects.h                      |   2 +-
 src/objects/js-regexp.cc                      |   8 +-
 src/objects/map.cc                            |   6 +-
 src/objects/name.h                            |   2 +-
 src/objects/objects.cc                        |   2 +-
 src/objects/shared-function-info.cc           |   7 +-
 src/objects/source-text-module.cc             |   2 +-
 src/objects/stack-frame-info.cc               |   8 +-
 src/objects/string-inl.h                      |  39 ++---
 src/objects/string-table.cc                   |   2 +-
 src/objects/string.cc                         |  36 ++---
 src/objects/string.h                          |  25 +--
 src/objects/value-serializer.cc               |  46 +++---
 src/objects/value-serializer.h                |  11 +-
 src/parsing/literal-buffer.cc                 |   7 +-
 src/parsing/literal-buffer.h                  |  16 +-
 src/parsing/parser.h                          |   3 +-
 .../pending-compilation-error-handler.cc      |   2 +-
 src/parsing/preparse-data-impl.h              |   3 +-
 src/parsing/preparse-data.cc                  |   6 +-
 src/parsing/preparse-data.h                   |   6 +-
 src/parsing/scanner-inl.h                     |   3 +-
 src/parsing/scanner.cc                        |  10 +-
 src/parsing/scanner.h                         |  16 +-
 src/profiler/allocation-tracker.cc            |   5 +-
 src/profiler/allocation-tracker.h             |   4 +-
 src/profiler/heap-snapshot-generator.cc       |  41 +++--
 src/profiler/profiler-listener.cc             |   7 +-
 src/profiler/profiler-listener.h              |   2 +-
 src/profiler/strings-storage.cc               |   4 +-
 .../arm64/regexp-macro-assembler-arm64.cc     |  10 +-
 .../arm64/regexp-macro-assembler-arm64.h      |   6 +-
 .../experimental/experimental-bytecode.cc     |   2 +-
 .../experimental/experimental-bytecode.h      |   4 +-
 .../experimental/experimental-interpreter.cc  |  30 ++--
 .../experimental/experimental-interpreter.h   |   2 +-
 src/regexp/experimental/experimental.cc       |   6 +-
 src/regexp/regexp-ast.cc                      |   2 +-
 src/regexp/regexp-ast.h                       |   8 +-
 src/regexp/regexp-bytecode-generator.cc       |   6 +-
 src/regexp/regexp-bytecode-generator.h        |   2 +-
 src/regexp/regexp-compiler-tonode.cc          |   4 +-
 src/regexp/regexp-compiler.cc                 |   6 +-
 src/regexp/regexp-dotprinter.cc               |   2 +-
 src/regexp/regexp-interpreter.cc              |  15 +-
 src/regexp/regexp-parser.cc                   |   8 +-
 src/regexp/regexp-utils.cc                    |   4 +-
 src/regexp/regexp.cc                          |   7 +-
 src/runtime/runtime-debug.cc                  |   2 +-
 src/runtime/runtime-function.cc               |   2 +-
 src/runtime/runtime-object.cc                 |   2 +-
 src/runtime/runtime-regexp.cc                 |  46 +++---
 src/runtime/runtime-strings.cc                |   2 +-
 src/runtime/runtime-test-wasm.cc              |   4 +-
 src/runtime/runtime-test.cc                   |  10 +-
 src/snapshot/code-serializer.cc               |   4 +-
 src/snapshot/code-serializer.h                |   6 +-
 src/snapshot/deserializer.cc                  |   2 +-
 src/snapshot/deserializer.h                   |   2 +-
 src/snapshot/embedded/embedded-data.cc        |   6 +-
 src/snapshot/embedded/embedded-file-writer.cc |  17 ++-
 src/snapshot/embedded/embedded-file-writer.h  |   4 +-
 .../platform-embedded-file-writer-win.cc      |   2 +-
 src/snapshot/mksnapshot.cc                    |  15 +-
 src/snapshot/snapshot-compression.cc          |   2 +-
 src/snapshot/snapshot-compression.h           |   4 +-
 src/snapshot/snapshot-data.cc                 |   4 +-
 src/snapshot/snapshot-data.h                  |  10 +-
 src/snapshot/snapshot-source-sink.h           |   4 +-
 src/snapshot/snapshot-utils.cc                |   2 +-
 src/snapshot/snapshot-utils.h                 |   4 +-
 src/snapshot/snapshot.cc                      |  52 ++++---
 src/strings/string-builder-inl.h              |   2 +-
 src/strings/string-hasher.h                   |   5 +-
 src/strings/string-search.h                   |  59 ++++----
 src/strings/string-stream.cc                  |  19 +--
 src/strings/string-stream.h                   |  20 +--
 src/strings/unicode-decoder.cc                |   8 +-
 src/strings/unicode-decoder.h                 |   7 +-
 src/strings/uri.cc                            |  19 +--
 src/tracing/traced-value.cc                   |  10 +-
 src/utils/allocation.cc                       |   2 +-
 src/utils/scoped-list.h                       |  11 +-
 src/utils/utils.cc                            |  11 +-
 src/utils/utils.h                             |  14 +-
 src/utils/version.cc                          |   4 +-
 src/utils/version.h                           |   9 +-
 .../baseline/ia32/liftoff-assembler-ia32.h    |   2 +-
 src/wasm/baseline/liftoff-assembler.cc        |  12 +-
 src/wasm/baseline/liftoff-assembler.h         |   4 +-
 src/wasm/baseline/liftoff-compiler.cc         |  59 ++++----
 src/wasm/baseline/liftoff-compiler.h          |   2 +-
 src/wasm/c-api.cc                             |  10 +-
 src/wasm/compilation-environment.h            |   2 +-
 src/wasm/decoder.h                            |   9 +-
 src/wasm/function-body-decoder-impl.h         |  58 +++----
 src/wasm/function-compiler.cc                 |  16 +-
 src/wasm/function-compiler.h                  |   4 +-
 src/wasm/graph-builder-interface.cc           |  87 +++++------
 src/wasm/memory-tracing.cc                    |   4 +-
 src/wasm/module-compiler.cc                   |  87 ++++++-----
 src/wasm/module-compiler.h                    |   9 +-
 src/wasm/module-decoder.cc                    |  52 ++++---
 src/wasm/module-decoder.h                     |  16 +-
 src/wasm/module-instantiate.cc                |   6 +-
 src/wasm/streaming-decoder.cc                 |  66 ++++----
 src/wasm/streaming-decoder.h                  |  26 ++--
 src/wasm/sync-streaming-decoder.cc            |   4 +-
 src/wasm/wasm-code-manager.cc                 | 102 +++++++------
 src/wasm/wasm-code-manager.h                  |  91 +++++------
 src/wasm/wasm-debug.cc                        |  39 ++---
 src/wasm/wasm-debug.h                         |   8 +-
 src/wasm/wasm-engine.cc                       |  43 +++---
 src/wasm/wasm-engine.h                        |  21 +--
 src/wasm/wasm-import-wrapper-cache.cc         |   2 +-
 src/wasm/wasm-js.cc                           |  10 +-
 src/wasm/wasm-module-builder.cc               |  23 +--
 src/wasm/wasm-module-builder.h                |  35 ++---
 src/wasm/wasm-module.cc                       |  13 +-
 src/wasm/wasm-module.h                        |  21 +--
 src/wasm/wasm-objects.cc                      |  28 ++--
 src/wasm/wasm-objects.h                       |   4 +-
 src/wasm/wasm-result.cc                       |   9 +-
 src/wasm/wasm-serialization.cc                |  48 +++---
 src/wasm/wasm-serialization.h                 |   8 +-
 src/web-snapshot/web-snapshot.cc              |   2 +-
 src/zone/zone-list-inl.h                      |   6 +-
 src/zone/zone-list.h                          |  21 +--
 src/zone/zone-utils.h                         |   8 +-
 test/cctest/cctest.cc                         |   4 +-
 test/cctest/collector.h                       |  34 +++--
 test/cctest/compiler/codegen-tester.cc        |   2 +-
 test/cctest/compiler/codegen-tester.h         |   3 +-
 test/cctest/compiler/test-code-generator.cc   |   6 +-
 test/cctest/compiler/test-linkage.cc          |   6 +-
 test/cctest/compiler/test-multiple-return.cc  |  11 +-
 .../test-run-bytecode-graph-builder.cc        | 118 +++++++--------
 test/cctest/compiler/test-run-native-calls.cc |   2 +-
 test/cctest/compiler/test-run-variables.cc    |   2 +-
 test/cctest/compiler/value-helper.h           |  60 ++++----
 test/cctest/gay-fixed.cc                      |   7 +-
 test/cctest/gay-fixed.h                       |   4 +-
 test/cctest/gay-precision.cc                  |   7 +-
 test/cctest/gay-precision.h                   |   4 +-
 test/cctest/gay-shortest.cc                   |   7 +-
 test/cctest/gay-shortest.h                    |   4 +-
 test/cctest/heap/test-compaction.cc           |   2 +-
 test/cctest/heap/test-heap.cc                 |  52 ++++---
 test/cctest/parsing/test-preparser.cc         |   4 +-
 test/cctest/parsing/test-scanner-streams.cc   |  20 +--
 test/cctest/test-api-array-buffer.cc          |   2 +-
 test/cctest/test-api-stack-traces.cc          |   8 +-
 test/cctest/test-api-typed-array.cc           |   6 +-
 test/cctest/test-api.cc                       |  52 +++----
 test/cctest/test-bignum-dtoa.cc               |  14 +-
 test/cctest/test-bignum.cc                    |   4 +-
 test/cctest/test-code-stub-assembler.cc       |  12 +-
 test/cctest/test-compiler.cc                  |  11 +-
 test/cctest/test-cpu-profiler.cc              |  14 +-
 test/cctest/test-debug.cc                     |   8 +-
 test/cctest/test-deoptimization.cc            |   9 +-
 test/cctest/test-descriptor-array.cc          |   2 +-
 test/cctest/test-disasm-arm.cc                |   2 +-
 test/cctest/test-disasm-mips.cc               |   2 +-
 test/cctest/test-disasm-mips64.cc             |   2 +-
 test/cctest/test-disasm-ppc.cc                |   2 +-
 test/cctest/test-disasm-riscv64.cc            |   2 +-
 test/cctest/test-disasm-s390.cc               |   2 +-
 test/cctest/test-dtoa.cc                      |  14 +-
 test/cctest/test-fast-dtoa.cc                 |  12 +-
 test/cctest/test-fixed-dtoa.cc                |   6 +-
 test/cctest/test-func-name-inference.cc       |   8 +-
 test/cctest/test-heap-profiler.cc             |  67 ++++-----
 test/cctest/test-js-to-wasm.cc                |   5 +-
 test/cctest/test-log-stack-tracer.cc          |   2 +-
 test/cctest/test-log.cc                       |  20 +--
 test/cctest/test-object.cc                    |   2 +-
 test/cctest/test-parsing.cc                   |  34 ++---
 test/cctest/test-profile-generator.cc         |   6 +-
 test/cctest/test-regexp.cc                    |  26 ++--
 test/cctest/test-sampler-api.cc               |   4 +-
 test/cctest/test-serialize.cc                 | 142 +++++++++---------
 test/cctest/test-strings.cc                   |  58 +++----
 test/cctest/test-strtod.cc                    |  27 ++--
 test/cctest/test-transitions.cc               |   4 +-
 test/cctest/test-types.cc                     |   4 +-
 test/cctest/test-utils.cc                     |  19 +--
 test/cctest/test-version.cc                   |   4 +-
 test/cctest/wasm/test-c-wasm-entry.cc         |  11 +-
 test/cctest/wasm/test-compilation-cache.cc    |   9 +-
 test/cctest/wasm/test-gc.cc                   |   4 +-
 test/cctest/wasm/test-grow-memory.cc          |   2 +-
 test/cctest/wasm/test-liftoff-inspection.cc   |   8 +-
 test/cctest/wasm/test-run-wasm-bulk-memory.cc |  10 +-
 test/cctest/wasm/test-run-wasm-js.cc          |   2 +-
 test/cctest/wasm/test-run-wasm-module.cc      |   2 +-
 .../cctest/wasm/test-run-wasm-relaxed-simd.cc |   8 +-
 test/cctest/wasm/test-run-wasm-simd.cc        |   6 +-
 test/cctest/wasm/test-run-wasm-wrappers.cc    |  12 +-
 test/cctest/wasm/test-run-wasm.cc             | 100 ++++++------
 .../cctest/wasm/test-streaming-compilation.cc |  12 +-
 test/cctest/wasm/test-wasm-metrics.cc         |   2 +-
 test/cctest/wasm/test-wasm-serialization.cc   |  12 +-
 test/cctest/wasm/test-wasm-shared-engine.cc   |   2 +-
 test/cctest/wasm/wasm-run-utils.cc            |  35 +++--
 test/cctest/wasm/wasm-run-utils.h             |  16 +-
 test/common/wasm/wasm-module-runner.cc        |  12 +-
 test/common/wasm/wasm-module-runner.h         |   8 +-
 test/fuzzer/inspector-fuzzer.cc               |   4 +-
 test/fuzzer/multi-return.cc                   |   4 +-
 test/fuzzer/parser.cc                         |   2 +-
 test/fuzzer/regexp.cc                         |  10 +-
 test/fuzzer/wasm-code.cc                      |   4 +-
 test/fuzzer/wasm-compile.cc                   |  98 ++++++------
 test/fuzzer/wasm-fuzzer-common.cc             |   8 +-
 test/fuzzer/wasm-fuzzer-common.h              |   5 +-
 test/inspector/inspector-test.cc              |   2 +-
 test/inspector/isolate-data.cc                |   2 +-
 test/inspector/isolate-data.h                 |   2 +-
 test/inspector/task-runner.h                  |   2 +-
 test/unittests/BUILD.gn                       |   2 +-
 .../{utils => base}/vector-unittest.cc        |  45 +++---
 test/unittests/heap/local-factory-unittest.cc |  31 ++--
 .../osr-optimized-code-cache-unittest.cc      |  30 ++--
 .../objects/value-serializer-unittest.cc      |   2 +-
 test/unittests/strings/unicode-unittest.cc    |   4 +-
 test/unittests/utils/utils-unittest.cc        |  51 ++++---
 .../wasm/function-body-decoder-unittest.cc    |  53 ++++---
 .../wasm/streaming-decoder-unittest.cc        |  88 +++++------
 .../wasm/trap-handler-x64-unittest.cc         |   3 +-
 test/wasm-api-tests/callbacks.cc              |  20 +--
 test/wasm-api-tests/finalize.cc               |   8 +-
 test/wasm-api-tests/globals.cc                |  80 +++++-----
 test/wasm-api-tests/hostref.cc                |  16 +-
 test/wasm-api-tests/memory.cc                 |   8 +-
 test/wasm-api-tests/multi-return.cc           |   4 +-
 test/wasm-api-tests/reflect.cc                |   8 +-
 test/wasm-api-tests/serialize.cc              |   5 +-
 test/wasm-api-tests/startup-errors.cc         |   2 +-
 test/wasm-api-tests/table.cc                  |  12 +-
 test/wasm-api-tests/threads.cc                |   6 +-
 test/wasm-api-tests/traps.cc                  |  11 +-
 test/wasm-api-tests/wasm-api-test.h           |   2 +-
 .../crdtp/json_platform_v8.cc                 |   4 +-
 359 files changed, 2656 insertions(+), 2425 deletions(-)
 rename src/{utils => base}/vector.h (98%)
 rename test/unittests/{utils => base}/vector-unittest.cc (69%)

diff --git a/BUILD.bazel b/BUILD.bazel
index 83c288abb8..1c7be0be4c 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -246,6 +246,7 @@ filegroup(
         "src/base/type-traits.h",
         "src/base/utils/random-number-generator.cc",
         "src/base/utils/random-number-generator.h",
+        "src/base/vector.h",
         "src/base/v8-fallthrough.h",
         "src/base/vlq-base64.cc",
         "src/base/vlq-base64.h",
@@ -1599,7 +1600,6 @@ filegroup(
         "src/utils/utils-inl.h",
         "src/utils/utils.cc",
         "src/utils/utils.h",
-        "src/utils/vector.h",
         "src/utils/version.cc",
         "src/utils/version.h",
         "src/web-snapshot/web-snapshot.h",
diff --git a/BUILD.gn b/BUILD.gn
index 6574a6ff38..0c09ab6624 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -3131,7 +3131,6 @@ v8_header_set("v8_internal_headers") {
     "src/utils/scoped-list.h",
     "src/utils/utils-inl.h",
     "src/utils/utils.h",
-    "src/utils/vector.h",
     "src/utils/version.h",
     "src/zone/accounting-allocator.h",
     "src/zone/compressed-zone-ptr.h",
@@ -4705,6 +4704,7 @@ v8_component("v8_libbase") {
     "src/base/type-traits.h",
     "src/base/utils/random-number-generator.cc",
     "src/base/utils/random-number-generator.h",
+    "src/base/vector.h",
     "src/base/vlq-base64.cc",
     "src/base/vlq-base64.h",
     "src/base/vlq.h",
diff --git a/src/api/api.cc b/src/api/api.cc
index 595eb373a1..19b4383b49 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -3255,7 +3255,8 @@ ValueDeserializer::Delegate::GetSharedArrayBufferFromId(Isolate* v8_isolate,
 }
 
 struct ValueDeserializer::PrivateData {
-  PrivateData(i::Isolate* i, i::Vector<const uint8_t> data, Delegate* delegate)
+  PrivateData(i::Isolate* i, base::Vector<const uint8_t> data,
+              Delegate* delegate)
       : isolate(i), deserializer(i, data, delegate) {}
   i::Isolate* isolate;
   i::ValueDeserializer deserializer;
@@ -3272,10 +3273,11 @@ ValueDeserializer::ValueDeserializer(Isolate* isolate, const uint8_t* data,
   if (base::IsValueInRangeForNumericType<int>(size)) {
     private_ = new PrivateData(
         reinterpret_cast<i::Isolate*>(isolate),
-        i::Vector<const uint8_t>(data, static_cast<int>(size)), delegate);
+        base::Vector<const uint8_t>(data, static_cast<int>(size)), delegate);
   } else {
-    private_ = new PrivateData(reinterpret_cast<i::Isolate*>(isolate),
-                               i::Vector<const uint8_t>(nullptr, 0), nullptr);
+    private_ =
+        new PrivateData(reinterpret_cast<i::Isolate*>(isolate),
+                        base::Vector<const uint8_t>(nullptr, 0), nullptr);
     private_->has_aborted = true;
   }
 }
@@ -5351,7 +5353,7 @@ namespace {
 // units until the buffer capacity is reached, would be exceeded by the next
 // unit, or all code units have been written out.
 template <typename Char>
-static int WriteUtf8Impl(i::Vector<const Char> string, char* write_start,
+static int WriteUtf8Impl(base::Vector<const Char> string, char* write_start,
                          int write_capacity, int options,
                          int* utf16_chars_read_out) {
   bool write_null = !(options & v8::String::NO_NULL_TERMINATION);
@@ -6533,7 +6535,7 @@ inline int StringLength(const uint16_t* string) {
 V8_WARN_UNUSED_RESULT
 inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
                                            NewStringType type,
-                                           i::Vector<const char> string) {
+                                           base::Vector<const char> string) {
   if (type == NewStringType::kInternalized) {
     return factory->InternalizeUtf8String(string);
   }
@@ -6543,7 +6545,7 @@ inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
 V8_WARN_UNUSED_RESULT
 inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
                                            NewStringType type,
-                                           i::Vector<const uint8_t> string) {
+                                           base::Vector<const uint8_t> string) {
   if (type == NewStringType::kInternalized) {
     return factory->InternalizeString(string);
   }
@@ -6551,9 +6553,9 @@ inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
 }
 
 V8_WARN_UNUSED_RESULT
-inline i::MaybeHandle<i::String> NewString(i::Factory* factory,
-                                           NewStringType type,
-                                           i::Vector<const uint16_t> string) {
+inline i::MaybeHandle<i::String> NewString(
+    i::Factory* factory, NewStringType type,
+    base::Vector<const uint16_t> string) {
   if (type == NewStringType::kInternalized) {
     return factory->InternalizeString(string);
   }
@@ -6579,7 +6581,7 @@ STATIC_ASSERT(v8::String::kMaxLength == i::String::kMaxLength);
     if (length < 0) length = StringLength(data);                           \
     i::Handle<i::String> handle_result =                                   \
         NewString(i_isolate->factory(), type,                              \
-                  i::Vector<const Char>(data, length))                     \
+                  base::Vector<const Char>(data, length))                  \
             .ToHandleChecked();                                            \
     result = Utils::ToLocal(handle_result);                                \
   }
@@ -6592,7 +6594,7 @@ Local<String> String::NewFromUtf8Literal(Isolate* isolate, const char* literal,
   LOG_API(i_isolate, String, NewFromUtf8Literal);
   i::Handle<i::String> handle_result =
       NewString(i_isolate->factory(), type,
-                i::Vector<const char>(literal, length))
+                base::Vector<const char>(literal, length))
           .ToHandleChecked();
   return Utils::ToLocal(handle_result);
 }
@@ -7538,7 +7540,7 @@ OwnedBuffer CompiledWasmModule::Serialize() {
 
 MemorySpan<const uint8_t> CompiledWasmModule::GetWireBytesRef() {
 #if V8_ENABLE_WEBASSEMBLY
-  i::Vector<const uint8_t> bytes_vec = native_module_->wire_bytes();
+  base::Vector<const uint8_t> bytes_vec = native_module_->wire_bytes();
   return {bytes_vec.begin(), bytes_vec.size()};
 #else
   UNREACHABLE();
@@ -7577,7 +7579,7 @@ MaybeLocal<WasmModuleObject> WasmModuleObject::FromCompiledModule(
   i::Handle<i::WasmModuleObject> module_object =
       i_isolate->wasm_engine()->ImportNativeModule(
           i_isolate, compiled_module.native_module_,
-          i::VectorOf(compiled_module.source_url()));
+          base::VectorOf(compiled_module.source_url()));
   return Local<WasmModuleObject>::Cast(
       Utils::ToLocal(i::Handle<i::JSObject>::cast(module_object)));
 #else
diff --git a/src/asmjs/asm-js.cc b/src/asmjs/asm-js.cc
index a4ececfa6e..4ebe75110d 100644
--- a/src/asmjs/asm-js.cc
+++ b/src/asmjs/asm-js.cc
@@ -9,6 +9,7 @@
 #include "src/ast/ast.h"
 #include "src/base/optional.h"
 #include "src/base/platform/elapsed-timer.h"
+#include "src/base/vector.h"
 #include "src/codegen/compiler.h"
 #include "src/codegen/unoptimized-compilation-info.h"
 #include "src/common/assert-scope.h"
@@ -23,8 +24,6 @@
 #include "src/parsing/parse-info.h"
 #include "src/parsing/scanner-character-streams.h"
 #include "src/parsing/scanner.h"
-#include "src/utils/vector.h"
-
 #include "src/wasm/wasm-engine.h"
 #include "src/wasm/wasm-js.h"
 #include "src/wasm/wasm-limits.h"
@@ -42,7 +41,7 @@ namespace {
 Handle<Object> StdlibMathMember(Isolate* isolate, Handle<JSReceiver> stdlib,
                                 Handle<Name> name) {
   Handle<Name> math_name(
-      isolate->factory()->InternalizeString(StaticCharVector("Math")));
+      isolate->factory()->InternalizeString(base::StaticCharVector("Math")));
   Handle<Object> math = JSReceiver::GetDataProperty(stdlib, math_name);
   if (!math->IsJSReceiver()) return isolate->factory()->undefined_value();
   Handle<JSReceiver> math_receiver = Handle<JSReceiver>::cast(math);
@@ -68,8 +67,8 @@ bool AreStdlibMembersValid(Isolate* isolate, Handle<JSReceiver> stdlib,
 #define STDLIB_MATH_FUNC(fname, FName, ignore1, ignore2)                   \
   if (members.contains(wasm::AsmJsParser::StandardMember::kMath##FName)) { \
     members.Remove(wasm::AsmJsParser::StandardMember::kMath##FName);       \
-    Handle<Name> name(                                                     \
-        isolate->factory()->InternalizeString(StaticCharVector(#fname)));  \
+    Handle<Name> name(isolate->factory()->InternalizeString(               \
+        base::StaticCharVector(#fname)));                                  \
     Handle<Object> value = StdlibMathMember(isolate, stdlib, name);        \
     if (!value->IsJSFunction()) return false;                              \
     SharedFunctionInfo shared = Handle<JSFunction>::cast(value)->shared(); \
@@ -85,23 +84,23 @@ bool AreStdlibMembersValid(Isolate* isolate, Handle<JSReceiver> stdlib,
 #define STDLIB_MATH_CONST(cname, const_value)                               \
   if (members.contains(wasm::AsmJsParser::StandardMember::kMath##cname)) {  \
     members.Remove(wasm::AsmJsParser::StandardMember::kMath##cname);        \
-    Handle<Name> name(                                                      \
-        isolate->factory()->InternalizeString(StaticCharVector(#cname)));   \
+    Handle<Name> name(isolate->factory()->InternalizeString(                \
+        base::StaticCharVector(#cname)));                                   \
     Handle<Object> value = StdlibMathMember(isolate, stdlib, name);         \
     if (!value->IsNumber() || value->Number() != const_value) return false; \
   }
   STDLIB_MATH_VALUE_LIST(STDLIB_MATH_CONST)
 #undef STDLIB_MATH_CONST
-#define STDLIB_ARRAY_TYPE(fname, FName)                                   \
-  if (members.contains(wasm::AsmJsParser::StandardMember::k##FName)) {    \
-    members.Remove(wasm::AsmJsParser::StandardMember::k##FName);          \
-    *is_typed_array = true;                                               \
-    Handle<Name> name(                                                    \
-        isolate->factory()->InternalizeString(StaticCharVector(#FName))); \
-    Handle<Object> value = JSReceiver::GetDataProperty(stdlib, name);     \
-    if (!value->IsJSFunction()) return false;                             \
-    Handle<JSFunction> func = Handle<JSFunction>::cast(value);            \
-    if (!func.is_identical_to(isolate->fname())) return false;            \
+#define STDLIB_ARRAY_TYPE(fname, FName)                                \
+  if (members.contains(wasm::AsmJsParser::StandardMember::k##FName)) { \
+    members.Remove(wasm::AsmJsParser::StandardMember::k##FName);       \
+    *is_typed_array = true;                                            \
+    Handle<Name> name(isolate->factory()->InternalizeString(           \
+        base::StaticCharVector(#FName)));                              \
+    Handle<Object> value = JSReceiver::GetDataProperty(stdlib, name);  \
+    if (!value->IsJSFunction()) return false;                          \
+    Handle<JSFunction> func = Handle<JSFunction>::cast(value);         \
+    if (!func.is_identical_to(isolate->fname())) return false;         \
   }
   STDLIB_ARRAY_TYPE(int8_array_fun, Int8Array)
   STDLIB_ARRAY_TYPE(uint8_array_fun, Uint8Array)
@@ -117,7 +116,7 @@ bool AreStdlibMembersValid(Isolate* isolate, Handle<JSReceiver> stdlib,
   return true;
 }
 
-void Report(Handle<Script> script, int position, Vector<const char> text,
+void Report(Handle<Script> script, int position, base::Vector<const char> text,
             MessageTemplate message_template,
             v8::Isolate::MessageErrorLevel level) {
   Isolate* isolate = script->GetIsolate();
@@ -134,7 +133,7 @@ void Report(Handle<Script> script, int position, Vector<const char> text,
 void ReportCompilationSuccess(Handle<Script> script, int position,
                               double compile_time, size_t module_size) {
   if (FLAG_suppress_asm_messages || !FLAG_trace_asm_time) return;
-  EmbeddedVector<char, 100> text;
+  base::EmbeddedVector<char, 100> text;
   int length = SNPrintF(text, "success, compile time %0.3f ms, %zu bytes",
                         compile_time, module_size);
   CHECK_NE(-1, length);
@@ -155,7 +154,7 @@ void ReportCompilationFailure(ParseInfo* parse_info, int position,
 void ReportInstantiationSuccess(Handle<Script> script, int position,
                                 double instantiate_time) {
   if (FLAG_suppress_asm_messages || !FLAG_trace_asm_time) return;
-  EmbeddedVector<char, 50> text;
+  base::EmbeddedVector<char, 50> text;
   int length = SNPrintF(text, "success, %0.3f ms", instantiate_time);
   CHECK_NE(-1, length);
   text.Truncate(length);
@@ -167,7 +166,7 @@ void ReportInstantiationSuccess(Handle<Script> script, int position,
 void ReportInstantiationFailure(Handle<Script> script, int position,
                                 const char* reason) {
   if (FLAG_suppress_asm_messages) return;
-  Vector<const char> text = CStrVector(reason);
+  base::Vector<const char> text = base::CStrVector(reason);
   Report(script, position, text, MessageTemplate::kAsmJsLinkingFailed,
          v8::Isolate::kMessageWarning);
 }
@@ -270,7 +269,7 @@ UnoptimizedCompilationJob::Status AsmJsCompilationJob::FinalizeJobImpl(
           ->SyncCompileTranslatedAsmJs(
               isolate, &thrower,
               wasm::ModuleWireBytes(module_->begin(), module_->end()),
-              VectorOf(*asm_offsets_), uses_bitset,
+              base::VectorOf(*asm_offsets_), uses_bitset,
               shared_info->language_mode())
           .ToHandleChecked();
   DCHECK(!thrower.error());
@@ -392,7 +391,7 @@ MaybeHandle<Object> AsmJs::InstantiateAsmWasm(Isolate* isolate,
     // and bypass the {ErrorThrower}, this happens in case of a stack overflow.
     if (isolate->has_pending_exception()) isolate->clear_pending_exception();
     if (thrower.error()) {
-      ScopedVector<char> error_reason(100);
+      base::ScopedVector<char> error_reason(100);
       SNPrintF(error_reason, "Internal wasm failure: %s", thrower.error_msg());
       ReportInstantiationFailure(script, position, error_reason.begin());
     } else {
diff --git a/src/asmjs/asm-parser.cc b/src/asmjs/asm-parser.cc
index 18035cf1fd..7c61985518 100644
--- a/src/asmjs/asm-parser.cc
+++ b/src/asmjs/asm-parser.cc
@@ -200,14 +200,16 @@ wasm::AsmJsParser::VarInfo* AsmJsParser::GetVarInfo(
     AsmJsScanner::token_t token) {
   const bool is_global = AsmJsScanner::IsGlobal(token);
   DCHECK(is_global || AsmJsScanner::IsLocal(token));
-  Vector<VarInfo>& var_info = is_global ? global_var_info_ : local_var_info_;
+  base::Vector<VarInfo>& var_info =
+      is_global ? global_var_info_ : local_var_info_;
   size_t old_capacity = var_info.size();
   size_t index = is_global ? AsmJsScanner::GlobalIndex(token)
                            : AsmJsScanner::LocalIndex(token);
   if (is_global && index + 1 > num_globals_) num_globals_ = index + 1;
   if (index + 1 > old_capacity) {
     size_t new_size = std::max(2 * old_capacity, index + 1);
-    Vector<VarInfo> new_info{zone_->NewArray<VarInfo>(new_size), new_size};
+    base::Vector<VarInfo> new_info{zone_->NewArray<VarInfo>(new_size),
+                                   new_size};
     std::uninitialized_fill(new_info.begin(), new_info.end(), VarInfo{});
     std::copy(var_info.begin(), var_info.end(), new_info.begin());
     var_info = new_info;
@@ -220,7 +222,7 @@ uint32_t AsmJsParser::VarIndex(VarInfo* info) {
   return info->index + static_cast<uint32_t>(global_imports_.size());
 }
 
-void AsmJsParser::AddGlobalImport(Vector<const char> name, AsmType* type,
+void AsmJsParser::AddGlobalImport(base::Vector<const char> name, AsmType* type,
                                   ValueType vtype, bool mutable_variable,
                                   VarInfo* info) {
   // Allocate a separate variable for the import.
@@ -256,11 +258,11 @@ uint32_t AsmJsParser::TempVariable(int index) {
   return function_temp_locals_offset_ + index;
 }
 
-Vector<const char> AsmJsParser::CopyCurrentIdentifierString() {
+base::Vector<const char> AsmJsParser::CopyCurrentIdentifierString() {
   const std::string& str = scanner_.GetIdentifierString();
   char* buffer = zone()->NewArray<char>(str.size());
   str.copy(buffer, str.size());
-  return Vector<const char>(buffer, static_cast<int>(str.size()));
+  return base::Vector<const char>(buffer, static_cast<int>(str.size()));
 }
 
 void AsmJsParser::SkipSemicolon() {
@@ -539,13 +541,13 @@ void AsmJsParser::ValidateModuleVarImport(VarInfo* info,
   if (Check('+')) {
     EXPECT_TOKEN(foreign_name_);
     EXPECT_TOKEN('.');
-    Vector<const char> name = CopyCurrentIdentifierString();
+    base::Vector<const char> name = CopyCurrentIdentifierString();
     AddGlobalImport(name, AsmType::Double(), kWasmF64, mutable_variable, info);
     scanner_.Next();
   } else {
     EXPECT_TOKEN(foreign_name_);
     EXPECT_TOKEN('.');
-    Vector<const char> name = CopyCurrentIdentifierString();
+    base::Vector<const char> name = CopyCurrentIdentifierString();
     scanner_.Next();
     if (Check('|')) {
       if (!CheckForZero()) {
@@ -626,7 +628,7 @@ void AsmJsParser::ValidateExport() {
   // clang-format on
   if (Check('{')) {
     for (;;) {
-      Vector<const char> name = CopyCurrentIdentifierString();
+      base::Vector<const char> name = CopyCurrentIdentifierString();
       if (!scanner_.IsGlobal() && !scanner_.IsLocal()) {
         FAIL("Illegal export name");
       }
@@ -656,7 +658,7 @@ void AsmJsParser::ValidateExport() {
     if (info->kind != VarKind::kFunction) {
       FAIL("Single function export must be a function");
     }
-    module_builder_->AddExport(CStrVector(AsmJs::kSingleFunctionName),
+    module_builder_->AddExport(base::CStrVector(AsmJs::kSingleFunctionName),
                                info->function_builder);
   }
 }
@@ -725,7 +727,7 @@ void AsmJsParser::ValidateFunction() {
     FAIL("Expected function name");
   }
 
-  Vector<const char> function_name_str = CopyCurrentIdentifierString();
+  base::Vector<const char> function_name_str = CopyCurrentIdentifierString();
   AsmJsScanner::token_t function_name = Consume();
   VarInfo* function_info = GetVarInfo(function_name);
   if (function_info->kind == VarKind::kUnused) {
diff --git a/src/asmjs/asm-parser.h b/src/asmjs/asm-parser.h
index cd39bcb686..1aa6365817 100644
--- a/src/asmjs/asm-parser.h
+++ b/src/asmjs/asm-parser.h
@@ -11,7 +11,7 @@
 #include "src/asmjs/asm-scanner.h"
 #include "src/asmjs/asm-types.h"
 #include "src/base/enum-set.h"
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 #include "src/wasm/wasm-module-builder.h"
 #include "src/zone/zone-containers.h"
 
@@ -82,11 +82,11 @@ class AsmJsParser {
   // function is used with different signatures. {cache} keeps the wasm
   // imports for the single asm.js import of name {function_name}.
   struct FunctionImportInfo {
-    Vector<const char> function_name;
+    base::Vector<const char> function_name;
     ZoneUnorderedMap<FunctionSig, uint32_t> cache;
 
     // Constructor.
-    FunctionImportInfo(Vector<const char> name, Zone* zone)
+    FunctionImportInfo(base::Vector<const char> name, Zone* zone)
         : function_name(name), cache(zone) {}
   };
 
@@ -102,7 +102,7 @@ class AsmJsParser {
   };
 
   struct GlobalImport {
-    Vector<const char> import_name;
+    base::Vector<const char> import_name;
     ValueType value_type;
     VarInfo* var_info;
   };
@@ -171,8 +171,8 @@ class AsmJsParser {
   AsmType* return_type_ = nullptr;
   uintptr_t stack_limit_;
   StdlibSet stdlib_uses_;
-  Vector<VarInfo> global_var_info_;
-  Vector<VarInfo> local_var_info_;
+  base::Vector<VarInfo> global_var_info_;
+  base::Vector<VarInfo> local_var_info_;
   size_t num_globals_ = 0;
 
   CachedVectors<ValueType> cached_valuetype_vectors_{zone_};
@@ -316,15 +316,15 @@ class AsmJsParser {
   void DeclareGlobal(VarInfo* info, bool mutable_variable, AsmType* type,
                      ValueType vtype, WasmInitExpr init = WasmInitExpr());
   void DeclareStdlibFunc(VarInfo* info, VarKind kind, AsmType* type);
-  void AddGlobalImport(Vector<const char> name, AsmType* type, ValueType vtype,
-                       bool mutable_variable, VarInfo* info);
+  void AddGlobalImport(base::Vector<const char> name, AsmType* type,
+                       ValueType vtype, bool mutable_variable, VarInfo* info);
 
   // Allocates a temporary local variable. The given {index} is absolute within
   // the function body, consider using {TemporaryVariableScope} when nesting.
   uint32_t TempVariable(int index);
 
   // Preserves a copy of the scanner's current identifier string in the zone.
-  Vector<const char> CopyCurrentIdentifierString();
+  base::Vector<const char> CopyCurrentIdentifierString();
 
   // Use to set up block stack layers (including synthetic ones for if-else).
   // Begin/Loop/End below are implemented with these plus code generation.
diff --git a/src/asmjs/asm-scanner.cc b/src/asmjs/asm-scanner.cc
index 3ac9ef2d6f..d9f74628d2 100644
--- a/src/asmjs/asm-scanner.cc
+++ b/src/asmjs/asm-scanner.cc
@@ -310,7 +310,7 @@ void AsmJsScanner::ConsumeNumber(uc32 ch) {
   }
   // Decode numbers.
   double_value_ = StringToDouble(
-      Vector<const uint8_t>::cast(VectorOf(number)),
+      base::Vector<const uint8_t>::cast(base::VectorOf(number)),
       ALLOW_HEX | ALLOW_OCTAL | ALLOW_BINARY | ALLOW_IMPLICIT_OCTAL);
   if (std::isnan(double_value_)) {
     // Check if string to number conversion didn't consume all the characters.
diff --git a/src/ast/ast-value-factory.cc b/src/ast/ast-value-factory.cc
index 3bd9ee4538..307e1d06b7 100644
--- a/src/ast/ast-value-factory.cc
+++ b/src/ast/ast-value-factory.cc
@@ -48,14 +48,14 @@ namespace {
 // For using StringToIndex.
 class OneByteStringStream {
  public:
-  explicit OneByteStringStream(Vector<const byte> lb)
+  explicit OneByteStringStream(base::Vector<const byte> lb)
       : literal_bytes_(lb), pos_(0) {}
 
   bool HasMore() { return pos_ < literal_bytes_.length(); }
   uint16_t GetNext() { return literal_bytes_[pos_++]; }
 
  private:
-  Vector<const byte> literal_bytes_;
+  base::Vector<const byte> literal_bytes_;
   int pos_;
 };
 
@@ -71,7 +71,7 @@ void AstRawString::Internalize(IsolateT* isolate) {
     set_string(isolate->factory()->InternalizeStringWithKey(&key));
   } else {
     TwoByteStringKey key(raw_hash_field_,
-                         Vector<const uint16_t>::cast(literal_bytes_));
+                         base::Vector<const uint16_t>::cast(literal_bytes_));
     set_string(isolate->factory()->InternalizeStringWithKey(&key));
   }
 }
@@ -299,8 +299,9 @@ AstStringConstants::AstStringConstants(Isolate* isolate, uint64_t hash_seed)
 #define F(name, str)                                                         \
   {                                                                          \
     const char* data = str;                                                  \
-    Vector<const uint8_t> literal(reinterpret_cast<const uint8_t*>(data),    \
-                                  static_cast<int>(strlen(data)));           \
+    base::Vector<const uint8_t> literal(                                     \
+        reinterpret_cast<const uint8_t*>(data),                              \
+        static_cast<int>(strlen(data)));                                     \
     uint32_t raw_hash_field = StringHasher::HashSequentialString<uint8_t>(   \
         literal.begin(), literal.length(), hash_seed_);                      \
     name##_string_ = zone_.New<AstRawString>(true, literal, raw_hash_field); \
@@ -314,7 +315,7 @@ AstStringConstants::AstStringConstants(Isolate* isolate, uint64_t hash_seed)
 }
 
 const AstRawString* AstValueFactory::GetOneByteStringInternal(
-    Vector<const uint8_t> literal) {
+    base::Vector<const uint8_t> literal) {
   if (literal.length() == 1 && literal[0] < kMaxOneCharStringValue) {
     int key = literal[0];
     if (V8_UNLIKELY(one_character_strings_[key] == nullptr)) {
@@ -330,10 +331,11 @@ const AstRawString* AstValueFactory::GetOneByteStringInternal(
 }
 
 const AstRawString* AstValueFactory::GetTwoByteStringInternal(
-    Vector<const uint16_t> literal) {
+    base::Vector<const uint16_t> literal) {
   uint32_t raw_hash_field = StringHasher::HashSequentialString<uint16_t>(
       literal.begin(), literal.length(), hash_seed_);
-  return GetString(raw_hash_field, false, Vector<const byte>::cast(literal));
+  return GetString(raw_hash_field, false,
+                   base::Vector<const byte>::cast(literal));
 }
 
 const AstRawString* AstValueFactory::GetString(Handle<String> literal) {
@@ -351,9 +353,10 @@ const AstRawString* AstValueFactory::GetString(Handle<String> literal) {
 
 const AstRawString* AstValueFactory::CloneFromOtherFactory(
     const AstRawString* raw_string) {
-  const AstRawString* result = GetString(
-      raw_string->raw_hash_field(), raw_string->is_one_byte(),
-      Vector<const byte>(raw_string->raw_data(), raw_string->byte_length()));
+  const AstRawString* result =
+      GetString(raw_string->raw_hash_field(), raw_string->is_one_byte(),
+                base::Vector<const byte>(raw_string->raw_data(),
+                                         raw_string->byte_length()));
   return result;
 }
 
@@ -392,7 +395,7 @@ template EXPORT_TEMPLATE_DEFINE(
 
 const AstRawString* AstValueFactory::GetString(
     uint32_t raw_hash_field, bool is_one_byte,
-    Vector<const byte> literal_bytes) {
+    base::Vector<const byte> literal_bytes) {
   // literal_bytes here points to whatever the user passed, and this is OK
   // because we use vector_compare (which checks the contents) to compare
   // against the AstRawStrings which are in the string_table_. We should not
@@ -406,7 +409,7 @@ const AstRawString* AstValueFactory::GetString(
         byte* new_literal_bytes = zone()->NewArray<byte>(length);
         memcpy(new_literal_bytes, literal_bytes.begin(), length);
         AstRawString* new_string = zone()->New<AstRawString>(
-            is_one_byte, Vector<const byte>(new_literal_bytes, length),
+            is_one_byte, base::Vector<const byte>(new_literal_bytes, length),
             raw_hash_field);
         CHECK_NOT_NULL(new_string);
         AddString(new_string);
diff --git a/src/ast/ast-value-factory.h b/src/ast/ast-value-factory.h
index 290da7838f..67c761a8f8 100644
--- a/src/ast/ast-value-factory.h
+++ b/src/ast/ast-value-factory.h
@@ -96,7 +96,7 @@ class AstRawString final : public ZoneObject {
   friend Zone;
 
   // Members accessed only by the AstValueFactory & related classes:
-  AstRawString(bool is_one_byte, const Vector<const byte>& literal_bytes,
+  AstRawString(bool is_one_byte, const base::Vector<const byte>& literal_bytes,
                uint32_t raw_hash_field)
       : next_(nullptr),
         literal_bytes_(literal_bytes),
@@ -125,7 +125,7 @@ class AstRawString final : public ZoneObject {
     Handle<String> string_;
   };
 
-  Vector<const byte> literal_bytes_;  // Memory owned by Zone.
+  base::Vector<const byte> literal_bytes_;  // Memory owned by Zone.
   uint32_t raw_hash_field_;
   bool is_one_byte_;
 #ifdef DEBUG
@@ -331,13 +331,13 @@ class AstValueFactory {
     return zone_;
   }
 
-  const AstRawString* GetOneByteString(Vector<const uint8_t> literal) {
+  const AstRawString* GetOneByteString(base::Vector<const uint8_t> literal) {
     return GetOneByteStringInternal(literal);
   }
   const AstRawString* GetOneByteString(const char* string) {
-    return GetOneByteString(OneByteVector(string));
+    return GetOneByteString(base::OneByteVector(string));
   }
-  const AstRawString* GetTwoByteString(Vector<const uint16_t> literal) {
+  const AstRawString* GetTwoByteString(base::Vector<const uint16_t> literal) {
     return GetTwoByteStringInternal(literal);
   }
   const AstRawString* GetString(Handle<String> literal);
@@ -376,10 +376,11 @@ class AstValueFactory {
     strings_end_ = &strings_;
   }
   V8_EXPORT_PRIVATE const AstRawString* GetOneByteStringInternal(
-      Vector<const uint8_t> literal);
-  const AstRawString* GetTwoByteStringInternal(Vector<const uint16_t> literal);
+      base::Vector<const uint8_t> literal);
+  const AstRawString* GetTwoByteStringInternal(
+      base::Vector<const uint16_t> literal);
   const AstRawString* GetString(uint32_t raw_hash_field, bool is_one_byte,
-                                Vector<const byte> literal_bytes);
+                                base::Vector<const byte> literal_bytes);
 
   // All strings are copied here.
   AstRawStringMap string_table_;
diff --git a/src/ast/prettyprinter.cc b/src/ast/prettyprinter.cc
index cb8d2ec75a..5d96b503b9 100644
--- a/src/ast/prettyprinter.cc
+++ b/src/ast/prettyprinter.cc
@@ -9,10 +9,10 @@
 #include "src/ast/ast-value-factory.h"
 #include "src/ast/scopes.h"
 #include "src/base/platform/platform.h"
+#include "src/base/vector.h"
 #include "src/common/globals.h"
 #include "src/objects/objects-inl.h"
 #include "src/strings/string-builder-inl.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -648,9 +648,8 @@ void AstPrinter::Print(const char* format, ...) {
   for (;;) {
     va_list arguments;
     va_start(arguments, format);
-    int n = VSNPrintF(Vector<char>(output_, size_) + pos_,
-                      format,
-                      arguments);
+    int n =
+        VSNPrintF(base::Vector<char>(output_, size_) + pos_, format, arguments);
     va_end(arguments);
 
     if (n >= 0) {
@@ -802,7 +801,7 @@ void AstPrinter::PrintLiteralWithModeIndented(const char* info, Variable* var,
   if (var == nullptr) {
     PrintLiteralIndented(info, value, true);
   } else {
-    EmbeddedVector<char, 256> buf;
+    base::EmbeddedVector<char, 256> buf;
     int pos =
         SNPrintF(buf, "%s (%p) (mode = %s, assigned = %s", info,
                  reinterpret_cast<void*>(var), VariableMode2String(var->mode()),
@@ -1138,7 +1137,7 @@ void AstPrinter::PrintClassProperty(ClassLiteral::Property* property) {
       prop_kind = "FIELD";
       break;
   }
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "PROPERTY%s%s - %s", property->is_static() ? " - STATIC" : "",
            property->is_private() ? " - PRIVATE" : " - PUBLIC", prop_kind);
   IndentedScope prop(this, buf.begin());
@@ -1191,7 +1190,7 @@ void AstPrinter::VisitRegExpLiteral(RegExpLiteral* node) {
   IndentedScope indent(this, "REGEXP LITERAL", node->position());
   PrintLiteralIndented("PATTERN", node->raw_pattern(), false);
   int i = 0;
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   if (node->flags() & RegExp::kHasIndices) buf[i++] = 'd';
   if (node->flags() & RegExp::kGlobal) buf[i++] = 'g';
   if (node->flags() & RegExp::kIgnoreCase) buf[i++] = 'i';
@@ -1239,7 +1238,7 @@ void AstPrinter::PrintObjectProperties(
         prop_kind = "SPREAD";
         break;
     }
-    EmbeddedVector<char, 128> buf;
+    base::EmbeddedVector<char, 128> buf;
     SNPrintF(buf, "PROPERTY - %s", prop_kind);
     IndentedScope prop(this, buf.begin());
     PrintIndentedVisit("KEY", properties->at(i)->key());
@@ -1260,7 +1259,7 @@ void AstPrinter::VisitArrayLiteral(ArrayLiteral* node) {
 
 
 void AstPrinter::VisitVariableProxy(VariableProxy* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   int pos = SNPrintF(buf, "VAR PROXY");
 
   if (!node->is_resolved()) {
@@ -1307,21 +1306,21 @@ void AstPrinter::VisitCompoundAssignment(CompoundAssignment* node) {
 }
 
 void AstPrinter::VisitYield(Yield* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "YIELD");
   IndentedScope indent(this, buf.begin(), node->position());
   Visit(node->expression());
 }
 
 void AstPrinter::VisitYieldStar(YieldStar* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "YIELD_STAR");
   IndentedScope indent(this, buf.begin(), node->position());
   Visit(node->expression());
 }
 
 void AstPrinter::VisitAwait(Await* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "AWAIT");
   IndentedScope indent(this, buf.begin(), node->position());
   Visit(node->expression());
@@ -1338,7 +1337,7 @@ void AstPrinter::VisitOptionalChain(OptionalChain* node) {
 }
 
 void AstPrinter::VisitProperty(Property* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "PROPERTY");
   IndentedScope indent(this, buf.begin(), node->position());
 
@@ -1377,7 +1376,7 @@ void AstPrinter::VisitProperty(Property* node) {
 }
 
 void AstPrinter::VisitCall(Call* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "CALL");
   IndentedScope indent(this, buf.begin());
 
@@ -1394,7 +1393,7 @@ void AstPrinter::VisitCallNew(CallNew* node) {
 
 
 void AstPrinter::VisitCallRuntime(CallRuntime* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "CALL RUNTIME %s%s", node->debug_name(),
            node->is_jsruntime() ? " (JS function)" : "");
   IndentedScope indent(this, buf.begin(), node->position());
@@ -1409,7 +1408,7 @@ void AstPrinter::VisitUnaryOperation(UnaryOperation* node) {
 
 
 void AstPrinter::VisitCountOperation(CountOperation* node) {
-  EmbeddedVector<char, 128> buf;
+  base::EmbeddedVector<char, 128> buf;
   SNPrintF(buf, "%s %s", (node->is_prefix() ? "PRE" : "POST"),
            Token::Name(node->op()));
   IndentedScope indent(this, buf.begin(), node->position());
diff --git a/src/utils/vector.h b/src/base/vector.h
similarity index 98%
rename from src/utils/vector.h
rename to src/base/vector.h
index 5214ef2cd8..8e7edf3d19 100644
--- a/src/utils/vector.h
+++ b/src/base/vector.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef V8_UTILS_VECTOR_H_
-#define V8_UTILS_VECTOR_H_
+#ifndef V8_BASE_VECTOR_H_
+#define V8_BASE_VECTOR_H_
 
 #include <algorithm>
 #include <cstring>
@@ -16,7 +16,7 @@
 #include "src/base/macros.h"
 
 namespace v8 {
-namespace internal {
+namespace base {
 
 template <typename T>
 class Vector {
@@ -317,7 +317,7 @@ class EmbeddedVector : public Vector<T> {
   T buffer_[kSize];
 };
 
-}  // namespace internal
+}  // namespace base
 }  // namespace v8
 
-#endif  // V8_UTILS_VECTOR_H_
+#endif  // V8_BASE_VECTOR_H_
diff --git a/src/builtins/builtins-arraybuffer.cc b/src/builtins/builtins-arraybuffer.cc
index 2d07847d57..c3a7f1b98c 100644
--- a/src/builtins/builtins-arraybuffer.cc
+++ b/src/builtins/builtins-arraybuffer.cc
@@ -252,7 +252,7 @@ static Object SliceHelper(BuiltinArguments args, Isolate* isolate,
   {
     const int argc = 1;
 
-    ScopedVector<Handle<Object>> argv(argc);
+    base::ScopedVector<Handle<Object>> argv(argc);
     argv[0] = new_len_obj;
 
     Handle<Object> new_obj;
diff --git a/src/builtins/builtins-collections-gen.cc b/src/builtins/builtins-collections-gen.cc
index 54b7c57616..b44c70423e 100644
--- a/src/builtins/builtins-collections-gen.cc
+++ b/src/builtins/builtins-collections-gen.cc
@@ -377,7 +377,7 @@ void BaseCollectionsAssembler::GotoIfInitialAddFunctionModified(
   PrototypeCheckAssembler prototype_check_assembler(
       state(), flags, native_context,
       GetInitialCollectionPrototype(variant, native_context),
-      Vector<DescriptorIndexNameValue>(&property_to_check, 1));
+      base::Vector<DescriptorIndexNameValue>(&property_to_check, 1));
 
   TNode<HeapObject> prototype = LoadMapPrototype(LoadMap(collection));
   Label if_unmodified(this);
diff --git a/src/builtins/builtins-date.cc b/src/builtins/builtins-date.cc
index dd97472276..1de6357cf8 100644
--- a/src/builtins/builtins-date.cc
+++ b/src/builtins/builtins-date.cc
@@ -209,7 +209,7 @@ BUILTIN(DateConstructor) {
     double const time_val = JSDate::CurrentTimeValue(isolate);
     DateBuffer buffer = ToDateString(time_val, isolate->date_cache());
     RETURN_RESULT_OR_FAILURE(
-        isolate, isolate->factory()->NewStringFromUtf8(VectorOf(buffer)));
+        isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
   }
   // [Construct]
   int const argc = args.length() - 1;
@@ -797,7 +797,7 @@ BUILTIN(DatePrototypeToDateString) {
   DateBuffer buffer =
       ToDateString(date->value().Number(), isolate->date_cache(), kDateOnly);
   RETURN_RESULT_OR_FAILURE(
-      isolate, isolate->factory()->NewStringFromUtf8(VectorOf(buffer)));
+      isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
 }
 
 // ES6 section 20.3.4.36 Date.prototype.toISOString ( )
@@ -815,14 +815,14 @@ BUILTIN(DatePrototypeToISOString) {
                                        &hour, &min, &sec, &ms);
   char buffer[128];
   if (year >= 0 && year <= 9999) {
-    SNPrintF(ArrayVector(buffer), "%04d-%02d-%02dT%02d:%02d:%02d.%03dZ", year,
-             month + 1, day, hour, min, sec, ms);
+    SNPrintF(base::ArrayVector(buffer), "%04d-%02d-%02dT%02d:%02d:%02d.%03dZ",
+             year, month + 1, day, hour, min, sec, ms);
   } else if (year < 0) {
-    SNPrintF(ArrayVector(buffer), "-%06d-%02d-%02dT%02d:%02d:%02d.%03dZ", -year,
-             month + 1, day, hour, min, sec, ms);
+    SNPrintF(base::ArrayVector(buffer), "-%06d-%02d-%02dT%02d:%02d:%02d.%03dZ",
+             -year, month + 1, day, hour, min, sec, ms);
   } else {
-    SNPrintF(ArrayVector(buffer), "+%06d-%02d-%02dT%02d:%02d:%02d.%03dZ", year,
-             month + 1, day, hour, min, sec, ms);
+    SNPrintF(base::ArrayVector(buffer), "+%06d-%02d-%02dT%02d:%02d:%02d.%03dZ",
+             year, month + 1, day, hour, min, sec, ms);
   }
   return *isolate->factory()->NewStringFromAsciiChecked(buffer);
 }
@@ -834,7 +834,7 @@ BUILTIN(DatePrototypeToString) {
   DateBuffer buffer =
       ToDateString(date->value().Number(), isolate->date_cache());
   RETURN_RESULT_OR_FAILURE(
-      isolate, isolate->factory()->NewStringFromUtf8(VectorOf(buffer)));
+      isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
 }
 
 // ES6 section 20.3.4.42 Date.prototype.toTimeString ( )
@@ -844,7 +844,7 @@ BUILTIN(DatePrototypeToTimeString) {
   DateBuffer buffer =
       ToDateString(date->value().Number(), isolate->date_cache(), kTimeOnly);
   RETURN_RESULT_OR_FAILURE(
-      isolate, isolate->factory()->NewStringFromUtf8(VectorOf(buffer)));
+      isolate, isolate->factory()->NewStringFromUtf8(base::VectorOf(buffer)));
 }
 
 #ifdef V8_INTL_SUPPORT
@@ -922,7 +922,7 @@ BUILTIN(DatePrototypeToUTCString) {
   int year, month, day, weekday, hour, min, sec, ms;
   isolate->date_cache()->BreakDownTime(time_ms, &year, &month, &day, &weekday,
                                        &hour, &min, &sec, &ms);
-  SNPrintF(ArrayVector(buffer),
+  SNPrintF(base::ArrayVector(buffer),
            (year < 0) ? "%s, %02d %s %05d %02d:%02d:%02d GMT"
                       : "%s, %02d %s %04d %02d:%02d:%02d GMT",
            kShortWeekDays[weekday], day, kShortMonths[month], year, hour, min,
diff --git a/src/builtins/builtins-function.cc b/src/builtins/builtins-function.cc
index 08fdbe5aa0..b12f1ec6ea 100644
--- a/src/builtins/builtins-function.cc
+++ b/src/builtins/builtins-function.cc
@@ -195,7 +195,7 @@ Object DoFunctionBind(Isolate* isolate, BuiltinArguments args) {
   // Allocate the bound function with the given {this_arg} and {args}.
   Handle<JSReceiver> target = args.at<JSReceiver>(0);
   Handle<Object> this_arg = isolate->factory()->undefined_value();
-  ScopedVector<Handle<Object>> argv(std::max(0, args.length() - 2));
+  base::ScopedVector<Handle<Object>> argv(std::max(0, args.length() - 2));
   if (args.length() > 1) {
     this_arg = args.at(1);
     for (int i = 2; i < args.length(); ++i) {
diff --git a/src/builtins/builtins-regexp-gen.cc b/src/builtins/builtins-regexp-gen.cc
index 4434828fbc..dbc922e56a 100644
--- a/src/builtins/builtins-regexp-gen.cc
+++ b/src/builtins/builtins-regexp-gen.cc
@@ -857,7 +857,8 @@ void RegExpBuiltinsAssembler::BranchIfFastRegExp(
 
   PrototypeCheckAssembler prototype_check_assembler(
       state(), prototype_check_flags, native_context, initial_proto_initial_map,
-      Vector<DescriptorIndexNameValue>(properties_to_check, property_count));
+      base::Vector<DescriptorIndexNameValue>(properties_to_check,
+                                             property_count));
 
   TNode<HeapObject> prototype = LoadMapPrototype(map);
   prototype_check_assembler.CheckAndBranch(prototype, if_isunmodified,
diff --git a/src/builtins/builtins-string.cc b/src/builtins/builtins-string.cc
index 7fd1c76381..16326794c9 100644
--- a/src/builtins/builtins-string.cc
+++ b/src/builtins/builtins-string.cc
@@ -82,7 +82,7 @@ BUILTIN(StringFromCodePoint) {
 
   if (index == length) {
     RETURN_RESULT_OR_FAILURE(
-        isolate, isolate->factory()->NewStringFromOneByte(Vector<uint8_t>(
+        isolate, isolate->factory()->NewStringFromOneByte(base::Vector<uint8_t>(
                      one_byte_buffer.data(), one_byte_buffer.size())));
   }
 
diff --git a/src/builtins/builtins.cc b/src/builtins/builtins.cc
index 0f0dd61bff..e2d3acef36 100644
--- a/src/builtins/builtins.cc
+++ b/src/builtins/builtins.cc
@@ -236,8 +236,8 @@ void Builtins::PrintBuiltinCode() {
        ++builtin) {
     const char* builtin_name = name(builtin);
     Handle<Code> code = code_handle(builtin);
-    if (PassesFilter(CStrVector(builtin_name),
-                     CStrVector(FLAG_print_builtin_code_filter))) {
+    if (PassesFilter(base::CStrVector(builtin_name),
+                     base::CStrVector(FLAG_print_builtin_code_filter))) {
       CodeTracer::Scope trace_scope(isolate_->GetCodeTracer());
       OFStream os(trace_scope.file());
       code->Disassemble(builtin_name, os, isolate_);
diff --git a/src/codegen/assembler.cc b/src/codegen/assembler.cc
index eb4448a6bf..2d2c0f10ab 100644
--- a/src/codegen/assembler.cc
+++ b/src/codegen/assembler.cc
@@ -37,6 +37,7 @@
 #ifdef V8_CODE_COMMENTS
 #include <iomanip>
 #endif
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/string-constants.h"
 #include "src/deoptimizer/deoptimizer.h"
@@ -46,7 +47,6 @@
 #include "src/snapshot/embedded/embedded-data.h"
 #include "src/snapshot/snapshot.h"
 #include "src/utils/ostreams.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -99,7 +99,7 @@ namespace {
 class DefaultAssemblerBuffer : public AssemblerBuffer {
  public:
   explicit DefaultAssemblerBuffer(int size)
-      : buffer_(OwnedVector<uint8_t>::NewForOverwrite(size)) {
+      : buffer_(base::OwnedVector<uint8_t>::NewForOverwrite(size)) {
 #ifdef DEBUG
     ZapCode(reinterpret_cast<Address>(buffer_.start()), size);
 #endif
@@ -115,7 +115,7 @@ class DefaultAssemblerBuffer : public AssemblerBuffer {
   }
 
  private:
-  OwnedVector<uint8_t> buffer_;
+  base::OwnedVector<uint8_t> buffer_;
 };
 
 class ExternalAssemblerBufferImpl : public AssemblerBuffer {
diff --git a/src/codegen/code-stub-assembler.cc b/src/codegen/code-stub-assembler.cc
index ba21b20b2f..2c44943cad 100644
--- a/src/codegen/code-stub-assembler.cc
+++ b/src/codegen/code-stub-assembler.cc
@@ -169,7 +169,7 @@ void CodeStubAssembler::FailAssert(
     const char* message, const std::vector<FileAndLine>& files_and_lines,
     std::initializer_list<ExtraNode> extra_nodes) {
   DCHECK_NOT_NULL(message);
-  EmbeddedVector<char, 1024> chars;
+  base::EmbeddedVector<char, 1024> chars;
   std::stringstream stream;
   for (auto it = files_and_lines.rbegin(); it != files_and_lines.rend(); ++it) {
     if (it->first != nullptr) {
@@ -14632,7 +14632,7 @@ void CodeStubAssembler::RemoveFinalizationRegistryCellFromUnregisterTokenMap(
 PrototypeCheckAssembler::PrototypeCheckAssembler(
     compiler::CodeAssemblerState* state, Flags flags,
     TNode<NativeContext> native_context, TNode<Map> initial_prototype_map,
-    Vector<DescriptorIndexNameValue> properties)
+    base::Vector<DescriptorIndexNameValue> properties)
     : CodeStubAssembler(state),
       flags_(flags),
       native_context_(native_context),
diff --git a/src/codegen/code-stub-assembler.h b/src/codegen/code-stub-assembler.h
index ba2a00fcd2..8eddcd475a 100644
--- a/src/codegen/code-stub-assembler.h
+++ b/src/codegen/code-stub-assembler.h
@@ -4195,7 +4195,7 @@ class PrototypeCheckAssembler : public CodeStubAssembler {
   PrototypeCheckAssembler(compiler::CodeAssemblerState* state, Flags flags,
                           TNode<NativeContext> native_context,
                           TNode<Map> initial_prototype_map,
-                          Vector<DescriptorIndexNameValue> properties);
+                          base::Vector<DescriptorIndexNameValue> properties);
 
   void CheckAndBranch(TNode<HeapObject> prototype, Label* if_unmodified,
                       Label* if_modified);
@@ -4204,7 +4204,7 @@ class PrototypeCheckAssembler : public CodeStubAssembler {
   const Flags flags_;
   const TNode<NativeContext> native_context_;
   const TNode<Map> initial_prototype_map_;
-  const Vector<DescriptorIndexNameValue> properties_;
+  const base::Vector<DescriptorIndexNameValue> properties_;
 };
 
 DEFINE_OPERATORS_FOR_FLAGS(CodeStubAssembler::AllocationFlags)
diff --git a/src/codegen/ia32/assembler-ia32.cc b/src/codegen/ia32/assembler-ia32.cc
index 688b038e91..24e926f80d 100644
--- a/src/codegen/ia32/assembler-ia32.cc
+++ b/src/codegen/ia32/assembler-ia32.cc
@@ -3384,8 +3384,9 @@ void Assembler::GrowBuffer() {
   // Relocate pc-relative references.
   int mode_mask = RelocInfo::ModeMask(RelocInfo::OFF_HEAP_TARGET);
   DCHECK_EQ(mode_mask, RelocInfo::kApplyMask & mode_mask);
-  Vector<byte> instructions{buffer_start_, static_cast<size_t>(pc_offset())};
-  Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
+  base::Vector<byte> instructions{buffer_start_,
+                                  static_cast<size_t>(pc_offset())};
+  base::Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
   for (RelocIterator it(instructions, reloc_info, 0, mode_mask); !it.done();
        it.next()) {
     it.rinfo()->apply(pc_delta);
diff --git a/src/codegen/mips/assembler-mips.cc b/src/codegen/mips/assembler-mips.cc
index c254860b14..d79ed6c8a3 100644
--- a/src/codegen/mips/assembler-mips.cc
+++ b/src/codegen/mips/assembler-mips.cc
@@ -3570,8 +3570,8 @@ void Assembler::GrowBuffer() {
                                reloc_info_writer.last_pc() + pc_delta);
 
   // Relocate runtime entries.
-  Vector<byte> instructions{buffer_start_, pc_offset()};
-  Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
+  base::Vector<byte> instructions{buffer_start_, pc_offset()};
+  base::Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
   for (RelocIterator it(instructions, reloc_info, 0); !it.done(); it.next()) {
     RelocInfo::Mode rmode = it.rinfo()->rmode();
     if (rmode == RelocInfo::INTERNAL_REFERENCE_ENCODED ||
diff --git a/src/codegen/mips64/assembler-mips64.cc b/src/codegen/mips64/assembler-mips64.cc
index 70a02ddb6f..5f2ec7d6e7 100644
--- a/src/codegen/mips64/assembler-mips64.cc
+++ b/src/codegen/mips64/assembler-mips64.cc
@@ -3769,8 +3769,8 @@ void Assembler::GrowBuffer() {
                                reloc_info_writer.last_pc() + pc_delta);
 
   // Relocate runtime entries.
-  Vector<byte> instructions{buffer_start_, pc_offset()};
-  Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
+  base::Vector<byte> instructions{buffer_start_, pc_offset()};
+  base::Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
   for (RelocIterator it(instructions, reloc_info, 0); !it.done(); it.next()) {
     RelocInfo::Mode rmode = it.rinfo()->rmode();
     if (rmode == RelocInfo::INTERNAL_REFERENCE) {
diff --git a/src/codegen/optimized-compilation-info.cc b/src/codegen/optimized-compilation-info.cc
index 0a4e9a2ddf..c7101b92bc 100644
--- a/src/codegen/optimized-compilation-info.cc
+++ b/src/codegen/optimized-compilation-info.cc
@@ -53,13 +53,13 @@ OptimizedCompilationInfo::OptimizedCompilationInfo(
 }
 
 OptimizedCompilationInfo::OptimizedCompilationInfo(
-    Vector<const char> debug_name, Zone* zone, CodeKind code_kind)
+    base::Vector<const char> debug_name, Zone* zone, CodeKind code_kind)
     : code_kind_(code_kind),
       zone_(zone),
       optimization_id_(kNoOptimizationId),
       debug_name_(debug_name) {
   SetTracingFlags(
-      PassesFilter(debug_name, CStrVector(FLAG_trace_turbo_filter)));
+      PassesFilter(debug_name, base::CStrVector(FLAG_trace_turbo_filter)));
   ConfigureFlags();
 }
 
@@ -165,8 +165,8 @@ std::unique_ptr<char[]> OptimizedCompilationInfo::GetDebugName() const {
   if (!shared_info().is_null()) {
     return shared_info()->DebugNameCStr();
   }
-  Vector<const char> name_vec = debug_name_;
-  if (name_vec.empty()) name_vec = ArrayVector("unknown");
+  base::Vector<const char> name_vec = debug_name_;
+  if (name_vec.empty()) name_vec = base::ArrayVector("unknown");
   std::unique_ptr<char[]> name(new char[name_vec.length() + 1]);
   memcpy(name.get(), name_vec.begin(), name_vec.length());
   name[name_vec.length()] = '\0';
diff --git a/src/codegen/optimized-compilation-info.h b/src/codegen/optimized-compilation-info.h
index 26eb565ce0..b7ed0d29c4 100644
--- a/src/codegen/optimized-compilation-info.h
+++ b/src/codegen/optimized-compilation-info.h
@@ -7,6 +7,7 @@
 
 #include <memory>
 
+#include "src/base/vector.h"
 #include "src/codegen/bailout-reason.h"
 #include "src/codegen/source-position-table.h"
 #include "src/codegen/tick-counter.h"
@@ -18,7 +19,6 @@
 #include "src/objects/objects.h"
 #include "src/utils/identity-map.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 
@@ -114,7 +114,7 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
       : OptimizedCompilationInfo(zone, isolate, shared, closure, code_kind,
                                  BytecodeOffset::None(), nullptr) {}
   // Construct a compilation info for stub compilation, Wasm, and testing.
-  OptimizedCompilationInfo(Vector<const char> debug_name, Zone* zone,
+  OptimizedCompilationInfo(base::Vector<const char> debug_name, Zone* zone,
                            CodeKind code_kind);
 
   OptimizedCompilationInfo(const OptimizedCompilationInfo&) = delete;
@@ -311,7 +311,7 @@ class V8_EXPORT_PRIVATE OptimizedCompilationInfo final {
   const int optimization_id_;
   unsigned inlined_bytecode_size_ = 0;
 
-  Vector<const char> debug_name_;
+  base::Vector<const char> debug_name_;
   std::unique_ptr<char[]> trace_turbo_filename_;
 
   TickCounter tick_counter_;
diff --git a/src/codegen/reloc-info.cc b/src/codegen/reloc-info.cc
index d818c8d06f..4093dba20c 100644
--- a/src/codegen/reloc-info.cc
+++ b/src/codegen/reloc-info.cc
@@ -288,9 +288,9 @@ RelocIterator::RelocIterator(const CodeDesc& desc, int mode_mask)
                     desc.buffer + desc.buffer_size - desc.reloc_size,
                     mode_mask) {}
 
-RelocIterator::RelocIterator(Vector<byte> instructions,
-                             Vector<const byte> reloc_info, Address const_pool,
-                             int mode_mask)
+RelocIterator::RelocIterator(base::Vector<byte> instructions,
+                             base::Vector<const byte> reloc_info,
+                             Address const_pool, int mode_mask)
     : RelocIterator(Code(), reinterpret_cast<Address>(instructions.begin()),
                     const_pool, reloc_info.begin() + reloc_info.size(),
                     reloc_info.begin(), mode_mask) {}
diff --git a/src/codegen/reloc-info.h b/src/codegen/reloc-info.h
index e8b3c0b98b..f2a2d04523 100644
--- a/src/codegen/reloc-info.h
+++ b/src/codegen/reloc-info.h
@@ -432,9 +432,9 @@ class V8_EXPORT_PRIVATE RelocIterator : public Malloced {
   explicit RelocIterator(const CodeDesc& desc, int mode_mask = -1);
   explicit RelocIterator(const CodeReference code_reference,
                          int mode_mask = -1);
-  explicit RelocIterator(Vector<byte> instructions,
-                         Vector<const byte> reloc_info, Address const_pool,
-                         int mode_mask = -1);
+  explicit RelocIterator(base::Vector<byte> instructions,
+                         base::Vector<const byte> reloc_info,
+                         Address const_pool, int mode_mask = -1);
   RelocIterator(RelocIterator&&) V8_NOEXCEPT = default;
 
   RelocIterator(const RelocIterator&) = delete;
diff --git a/src/codegen/riscv64/assembler-riscv64.cc b/src/codegen/riscv64/assembler-riscv64.cc
index cd0c62af9c..3875a93158 100644
--- a/src/codegen/riscv64/assembler-riscv64.cc
+++ b/src/codegen/riscv64/assembler-riscv64.cc
@@ -798,7 +798,7 @@ void Assembler::disassembleInstr(Instr instr) {
   if (!FLAG_riscv_debug) return;
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
-  EmbeddedVector<char, 128> disasm_buffer;
+  base::EmbeddedVector<char, 128> disasm_buffer;
 
   disasm.InstructionDecode(disasm_buffer, reinterpret_cast<byte*>(&instr));
   DEBUG_PRINTF("%s\n", disasm_buffer.begin());
@@ -2789,8 +2789,9 @@ void Assembler::GrowBuffer() {
                                reloc_info_writer.last_pc() + pc_delta);
 
   // Relocate runtime entries.
-  Vector<byte> instructions{buffer_start_, static_cast<size_t>(pc_offset())};
-  Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
+  base::Vector<byte> instructions{buffer_start_,
+                                  static_cast<size_t>(pc_offset())};
+  base::Vector<const byte> reloc_info{reloc_info_writer.pos(), reloc_size};
   for (RelocIterator it(instructions, reloc_info, 0); !it.done(); it.next()) {
     RelocInfo::Mode rmode = it.rinfo()->rmode();
     if (rmode == RelocInfo::INTERNAL_REFERENCE) {
diff --git a/src/codegen/source-position-table.cc b/src/codegen/source-position-table.cc
index 27466a2690..6579a419fa 100644
--- a/src/codegen/source-position-table.cc
+++ b/src/codegen/source-position-table.cc
@@ -87,7 +87,7 @@ void EncodeEntry(ZoneVector<byte>* bytes, const PositionTableEntry& entry) {
 
 // Helper: Decode an integer.
 template <typename T>
-T DecodeInt(Vector<const byte> bytes, int* index) {
+T DecodeInt(base::Vector<const byte> bytes, int* index) {
   byte current;
   int shift = 0;
   T decoded = 0;
@@ -105,7 +105,7 @@ T DecodeInt(Vector<const byte> bytes, int* index) {
   return decoded;
 }
 
-void DecodeEntry(Vector<const byte> bytes, int* index,
+void DecodeEntry(base::Vector<const byte> bytes, int* index,
                  PositionTableEntry* entry) {
   int tmp = DecodeInt<int>(bytes, index);
   if (tmp >= 0) {
@@ -118,9 +118,9 @@ void DecodeEntry(Vector<const byte> bytes, int* index,
   entry->source_position = DecodeInt<int64_t>(bytes, index);
 }
 
-Vector<const byte> VectorFromByteArray(ByteArray byte_array) {
-  return Vector<const byte>(byte_array.GetDataStartAddress(),
-                            byte_array.length());
+base::Vector<const byte> VectorFromByteArray(ByteArray byte_array) {
+  return base::Vector<const byte>(byte_array.GetDataStartAddress(),
+                                  byte_array.length());
 }
 
 #ifdef ENABLE_SLOW_DCHECKS
@@ -200,11 +200,12 @@ template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
     Handle<ByteArray> SourcePositionTableBuilder::ToSourcePositionTable(
         LocalIsolate* isolate);
 
-OwnedVector<byte> SourcePositionTableBuilder::ToSourcePositionTableVector() {
-  if (bytes_.empty()) return OwnedVector<byte>();
+base::OwnedVector<byte>
+SourcePositionTableBuilder::ToSourcePositionTableVector() {
+  if (bytes_.empty()) return base::OwnedVector<byte>();
   DCHECK(!Omit());
 
-  OwnedVector<byte> table = OwnedVector<byte>::Of(bytes_);
+  base::OwnedVector<byte> table = base::OwnedVector<byte>::Of(bytes_);
 
 #ifdef ENABLE_SLOW_DCHECKS
   // Brute force testing: Record all positions and decode
@@ -250,7 +251,7 @@ SourcePositionTableIterator::SourcePositionTableIterator(
 }
 
 SourcePositionTableIterator::SourcePositionTableIterator(
-    Vector<const byte> bytes, IterationFilter iteration_filter,
+    base::Vector<const byte> bytes, IterationFilter iteration_filter,
     FunctionEntryFilter function_entry_filter)
     : raw_table_(bytes),
       iteration_filter_(iteration_filter),
@@ -263,7 +264,7 @@ SourcePositionTableIterator::SourcePositionTableIterator(
 }
 
 void SourcePositionTableIterator::Advance() {
-  Vector<const byte> bytes =
+  base::Vector<const byte> bytes =
       table_.is_null() ? raw_table_ : VectorFromByteArray(*table_);
   DCHECK(!done());
   DCHECK(index_ >= 0 && index_ <= bytes.length());
diff --git a/src/codegen/source-position-table.h b/src/codegen/source-position-table.h
index afd7cc434c..3e7340da3c 100644
--- a/src/codegen/source-position-table.h
+++ b/src/codegen/source-position-table.h
@@ -6,11 +6,11 @@
 #define V8_CODEGEN_SOURCE_POSITION_TABLE_H_
 
 #include "src/base/export-template.h"
+#include "src/base/vector.h"
 #include "src/codegen/source-position.h"
 #include "src/common/assert-scope.h"
 #include "src/common/checks.h"
 #include "src/common/globals.h"
-#include "src/utils/vector.h"
 #include "src/zone/zone-containers.h"
 
 namespace v8 {
@@ -57,7 +57,7 @@ class V8_EXPORT_PRIVATE SourcePositionTableBuilder {
   template <typename IsolateT>
   EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE)
   Handle<ByteArray> ToSourcePositionTable(IsolateT* isolate);
-  OwnedVector<byte> ToSourcePositionTableVector();
+  base::OwnedVector<byte> ToSourcePositionTableVector();
 
   inline bool Omit() const { return mode_ != RECORD_SOURCE_POSITIONS; }
   inline bool Lazy() const { return mode_ == LAZY_SOURCE_POSITIONS; }
@@ -114,7 +114,7 @@ class V8_EXPORT_PRIVATE SourcePositionTableIterator {
   // Handle-safe iterator based on an a vector located outside the garbage
   // collected heap, allows allocation during its lifetime.
   explicit SourcePositionTableIterator(
-      Vector<const byte> bytes,
+      base::Vector<const byte> bytes,
       IterationFilter iteration_filter = kJavaScriptOnly,
       FunctionEntryFilter function_entry_filter = kSkipFunctionEntry);
 
@@ -152,7 +152,7 @@ class V8_EXPORT_PRIVATE SourcePositionTableIterator {
 
   static const int kDone = -1;
 
-  Vector<const byte> raw_table_;
+  base::Vector<const byte> raw_table_;
   Handle<ByteArray> table_;
   int index_ = 0;
   PositionTableEntry current_;
diff --git a/src/compiler/backend/code-generator.cc b/src/compiler/backend/code-generator.cc
index 85ea94f4c6..ecefffe14c 100644
--- a/src/compiler/backend/code-generator.cc
+++ b/src/compiler/backend/code-generator.cc
@@ -534,13 +534,13 @@ void CodeGenerator::AssembleArchBinarySearchSwitchRange(
   AssembleArchBinarySearchSwitchRange(input, def_block, begin, middle);
 }
 
-OwnedVector<byte> CodeGenerator::GetSourcePositionTable() {
+base::OwnedVector<byte> CodeGenerator::GetSourcePositionTable() {
   return source_position_table_builder_.ToSourcePositionTableVector();
 }
 
-OwnedVector<byte> CodeGenerator::GetProtectedInstructionsData() {
-  return OwnedVector<byte>::Of(
-      Vector<byte>::cast(VectorOf(protected_instructions_)));
+base::OwnedVector<byte> CodeGenerator::GetProtectedInstructionsData() {
+  return base::OwnedVector<byte>::Of(
+      base::Vector<byte>::cast(base::VectorOf(protected_instructions_)));
 }
 
 MaybeHandle<Code> CodeGenerator::FinalizeCode() {
diff --git a/src/compiler/backend/code-generator.h b/src/compiler/backend/code-generator.h
index 5c07f87a95..a6e19ff710 100644
--- a/src/compiler/backend/code-generator.h
+++ b/src/compiler/backend/code-generator.h
@@ -136,8 +136,8 @@ class V8_EXPORT_PRIVATE CodeGenerator final : public GapResolver::Assembler {
   void AssembleCode();  // Does not need to run on main thread.
   MaybeHandle<Code> FinalizeCode();
 
-  OwnedVector<byte> GetSourcePositionTable();
-  OwnedVector<byte> GetProtectedInstructionsData();
+  base::OwnedVector<byte> GetSourcePositionTable();
+  base::OwnedVector<byte> GetProtectedInstructionsData();
 
   InstructionSequence* instructions() const { return instructions_; }
   FrameAccessState* frame_access_state() const { return frame_access_state_; }
diff --git a/src/compiler/backend/register-allocator.cc b/src/compiler/backend/register-allocator.cc
index 8e5cf16f50..06173b1d36 100644
--- a/src/compiler/backend/register-allocator.cc
+++ b/src/compiler/backend/register-allocator.cc
@@ -8,12 +8,12 @@
 
 #include "src/base/iterator.h"
 #include "src/base/small-vector.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/tick-counter.h"
 #include "src/compiler/backend/spill-placer.h"
 #include "src/compiler/linkage.h"
 #include "src/strings/string-stream.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -3916,7 +3916,7 @@ void LinearScanAllocator::GetFPRegisterSet(MachineRepresentation rep,
 }
 
 void LinearScanAllocator::FindFreeRegistersForRange(
-    LiveRange* range, Vector<LifetimePosition> positions) {
+    LiveRange* range, base::Vector<LifetimePosition> positions) {
   int num_regs = num_registers();
   int num_codes = num_allocatable_registers();
   const int* codes = allocatable_register_codes();
@@ -3993,7 +3993,7 @@ void LinearScanAllocator::FindFreeRegistersForRange(
 // which are expensive.
 void LinearScanAllocator::ProcessCurrentRange(LiveRange* current,
                                               SpillMode spill_mode) {
-  EmbeddedVector<LifetimePosition, RegisterConfiguration::kMaxRegisters>
+  base::EmbeddedVector<LifetimePosition, RegisterConfiguration::kMaxRegisters>
       free_until_pos;
   FindFreeRegistersForRange(current, free_until_pos);
   if (!TryAllocatePreferredReg(current, free_until_pos)) {
@@ -4007,7 +4007,7 @@ void LinearScanAllocator::ProcessCurrentRange(LiveRange* current,
 }
 
 bool LinearScanAllocator::TryAllocatePreferredReg(
-    LiveRange* current, const Vector<LifetimePosition>& free_until_pos) {
+    LiveRange* current, const base::Vector<LifetimePosition>& free_until_pos) {
   int hint_register;
   if (current->RegisterFromControlFlow(&hint_register) ||
       current->FirstHintPosition(&hint_register) != nullptr ||
@@ -4032,7 +4032,7 @@ bool LinearScanAllocator::TryAllocatePreferredReg(
 
 int LinearScanAllocator::PickRegisterThatIsAvailableLongest(
     LiveRange* current, int hint_reg,
-    const Vector<LifetimePosition>& free_until_pos) {
+    const base::Vector<LifetimePosition>& free_until_pos) {
   int num_regs = 0;  // used only for the call to GetFPRegisterSet.
   int num_codes = num_allocatable_registers();
   const int* codes = allocatable_register_codes();
@@ -4074,7 +4074,7 @@ int LinearScanAllocator::PickRegisterThatIsAvailableLongest(
 }
 
 bool LinearScanAllocator::TryAllocateFreeReg(
-    LiveRange* current, const Vector<LifetimePosition>& free_until_pos) {
+    LiveRange* current, const base::Vector<LifetimePosition>& free_until_pos) {
   // Compute register hint, if such exists.
   int hint_reg = kUnassignedRegister;
   current->RegisterFromControlFlow(&hint_reg) ||
@@ -4136,9 +4136,9 @@ void LinearScanAllocator::AllocateBlockedReg(LiveRange* current,
   // use_pos keeps track of positions a register/alias is used at.
   // block_pos keeps track of positions where a register/alias is blocked
   // from.
-  EmbeddedVector<LifetimePosition, RegisterConfiguration::kMaxRegisters>
+  base::EmbeddedVector<LifetimePosition, RegisterConfiguration::kMaxRegisters>
       use_pos(LifetimePosition::MaxPosition());
-  EmbeddedVector<LifetimePosition, RegisterConfiguration::kMaxRegisters>
+  base::EmbeddedVector<LifetimePosition, RegisterConfiguration::kMaxRegisters>
       block_pos(LifetimePosition::MaxPosition());
 
   for (LiveRange* range : active_live_ranges()) {
diff --git a/src/compiler/backend/register-allocator.h b/src/compiler/backend/register-allocator.h
index a9c3ca5ae0..01d1f87c9b 100644
--- a/src/compiler/backend/register-allocator.h
+++ b/src/compiler/backend/register-allocator.h
@@ -1477,15 +1477,15 @@ class LinearScanAllocator final : public RegisterAllocator {
   bool TryReuseSpillForPhi(TopLevelLiveRange* range);
   int PickRegisterThatIsAvailableLongest(
       LiveRange* current, int hint_reg,
-      const Vector<LifetimePosition>& free_until_pos);
+      const base::Vector<LifetimePosition>& free_until_pos);
   bool TryAllocateFreeReg(LiveRange* range,
-                          const Vector<LifetimePosition>& free_until_pos);
-  bool TryAllocatePreferredReg(LiveRange* range,
-                               const Vector<LifetimePosition>& free_until_pos);
+                          const base::Vector<LifetimePosition>& free_until_pos);
+  bool TryAllocatePreferredReg(
+      LiveRange* range, const base::Vector<LifetimePosition>& free_until_pos);
   void GetFPRegisterSet(MachineRepresentation rep, int* num_regs,
                         int* num_codes, const int** codes) const;
   void FindFreeRegistersForRange(LiveRange* range,
-                                 Vector<LifetimePosition> free_until_pos);
+                                 base::Vector<LifetimePosition> free_until_pos);
   void ProcessCurrentRange(LiveRange* current, SpillMode spill_mode);
   void AllocateBlockedReg(LiveRange* range, SpillMode spill_mode);
 
diff --git a/src/compiler/code-assembler.cc b/src/compiler/code-assembler.cc
index c9d4c388c9..1b68f07173 100644
--- a/src/compiler/code-assembler.cc
+++ b/src/compiler/code-assembler.cc
@@ -248,7 +248,7 @@ void CodeAssembler::GenerateCheckMaybeObjectIsObject(TNode<MaybeObject> node,
                               IntPtrConstant(kHeapObjectTagMask)),
                       IntPtrConstant(kWeakHeapObjectTag)),
          &ok);
-  EmbeddedVector<char, 1024> message;
+  base::EmbeddedVector<char, 1024> message;
   SNPrintF(message, "no Object: %s", location);
   TNode<String> message_node = StringConstant(message.begin());
   // This somewhat misuses the AbortCSAAssert runtime function. This will print
@@ -306,7 +306,7 @@ TNode<HeapObject> CodeAssembler::UntypedHeapConstant(
 
 TNode<String> CodeAssembler::StringConstant(const char* str) {
   Handle<String> internalized_string =
-      factory()->InternalizeString(OneByteVector(str));
+      factory()->InternalizeString(base::OneByteVector(str));
   return UncheckedCast<String>(HeapConstant(internalized_string));
 }
 
diff --git a/src/compiler/graph-visualizer.cc b/src/compiler/graph-visualizer.cc
index 6d33b2676c..f075e2a270 100644
--- a/src/compiler/graph-visualizer.cc
+++ b/src/compiler/graph-visualizer.cc
@@ -9,6 +9,7 @@
 #include <string>
 
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/codegen/optimized-compilation-info.h"
 #include "src/codegen/source-position.h"
 #include "src/compiler/all-nodes.h"
@@ -28,7 +29,6 @@
 #include "src/objects/script-inl.h"
 #include "src/objects/shared-function-info.h"
 #include "src/utils/ostreams.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -201,7 +201,7 @@ std::unique_ptr<char[]> GetVisualizerLogFileName(OptimizedCompilationInfo* info,
                                                  const char* optional_base_dir,
                                                  const char* phase,
                                                  const char* suffix) {
-  EmbeddedVector<char, 256> filename(0);
+  base::EmbeddedVector<char, 256> filename(0);
   std::unique_ptr<char[]> debug_name = info->GetDebugName();
   int optimization_id = info->IsOptimizing() ? info->optimization_id() : 0;
   if (strlen(debug_name.get()) > 0) {
@@ -213,7 +213,7 @@ std::unique_ptr<char[]> GetVisualizerLogFileName(OptimizedCompilationInfo* info,
   } else {
     SNPrintF(filename, "turbo-none-%i", optimization_id);
   }
-  EmbeddedVector<char, 256> source_file(0);
+  base::EmbeddedVector<char, 256> source_file(0);
   bool source_available = false;
   if (FLAG_trace_file_names && info->has_shared_info() &&
       info->shared_info()->script().IsScript()) {
@@ -233,7 +233,7 @@ std::unique_ptr<char[]> GetVisualizerLogFileName(OptimizedCompilationInfo* info,
   std::replace(filename.begin(), filename.begin() + filename.length(), ':',
                '-');
 
-  EmbeddedVector<char, 256> base_dir;
+  base::EmbeddedVector<char, 256> base_dir;
   if (optional_base_dir != nullptr) {
     SNPrintF(base_dir, "%s%c", optional_base_dir,
              base::OS::DirectorySeparator());
@@ -241,7 +241,7 @@ std::unique_ptr<char[]> GetVisualizerLogFileName(OptimizedCompilationInfo* info,
     base_dir[0] = '\0';
   }
 
-  EmbeddedVector<char, 256> full_filename;
+  base::EmbeddedVector<char, 256> full_filename;
   if (phase == nullptr && !source_available) {
     SNPrintF(full_filename, "%s%s.%s", base_dir.begin(), filename.begin(),
              suffix);
diff --git a/src/compiler/pipeline.cc b/src/compiler/pipeline.cc
index c8543bab52..ffe99c5475 100644
--- a/src/compiler/pipeline.cc
+++ b/src/compiler/pipeline.cc
@@ -2559,7 +2559,7 @@ class WasmHeapStubCompilationJob final : public OptimizedCompilationJob {
       : OptimizedCompilationJob(&info_, "TurboFan",
                                 CompilationJob::State::kReadyToExecute),
         debug_name_(std::move(debug_name)),
-        info_(CStrVector(debug_name_.get()), graph->zone(), kind),
+        info_(base::CStrVector(debug_name_.get()), graph->zone(), kind),
         call_descriptor_(call_descriptor),
         zone_stats_(zone->allocator()),
         zone_(std::move(zone)),
@@ -3012,7 +3012,8 @@ MaybeHandle<Code> Pipeline::GenerateCodeForCodeStub(
     const char* debug_name, Builtin builtin,
     PoisoningMitigationLevel poisoning_level, const AssemblerOptions& options,
     const ProfileDataFromFile* profile_data) {
-  OptimizedCompilationInfo info(CStrVector(debug_name), graph->zone(), kind);
+  OptimizedCompilationInfo info(base::CStrVector(debug_name), graph->zone(),
+                                kind);
   info.set_builtin(builtin);
 
   if (poisoning_level != PoisoningMitigationLevel::kDontPoison) {
@@ -3139,7 +3140,8 @@ wasm::WasmCompilationResult Pipeline::GenerateCodeForWasmNativeStub(
     MachineGraph* mcgraph, CodeKind kind, int wasm_kind, const char* debug_name,
     const AssemblerOptions& options, SourcePositionTable* source_positions) {
   Graph* graph = mcgraph->graph();
-  OptimizedCompilationInfo info(CStrVector(debug_name), graph->zone(), kind);
+  OptimizedCompilationInfo info(base::CStrVector(debug_name), graph->zone(),
+                                kind);
   // Construct a pipeline for scheduling and code generation.
   ZoneStats zone_stats(wasm_engine->allocator());
   NodeOriginTable* node_positions = graph->zone()->New<NodeOriginTable>(graph);
@@ -3458,7 +3460,7 @@ bool Pipeline::AllocateRegistersForTesting(const RegisterConfiguration* config,
                                            InstructionSequence* sequence,
                                            bool use_mid_tier_register_allocator,
                                            bool run_verifier) {
-  OptimizedCompilationInfo info(ArrayVector("testing"), sequence->zone(),
+  OptimizedCompilationInfo info(base::ArrayVector("testing"), sequence->zone(),
                                 CodeKind::FOR_TESTING);
   ZoneStats zone_stats(sequence->isolate()->allocator());
   PipelineData data(&zone_stats, &info, sequence->isolate(), sequence);
diff --git a/src/compiler/wasm-compiler.cc b/src/compiler/wasm-compiler.cc
index d0cb1cefc4..938768d6dd 100644
--- a/src/compiler/wasm-compiler.cc
+++ b/src/compiler/wasm-compiler.cc
@@ -12,6 +12,7 @@
 #include "src/base/platform/wrappers.h"
 #include "src/base/small-vector.h"
 #include "src/base/v8-fallthrough.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/assembler.h"
 #include "src/codegen/code-factory.h"
@@ -43,7 +44,6 @@
 #include "src/roots/roots.h"
 #include "src/tracing/trace-event.h"
 #include "src/trap-handler/trap-handler.h"
-#include "src/utils/vector.h"
 #include "src/wasm/function-body-decoder-impl.h"
 #include "src/wasm/function-compiler.h"
 #include "src/wasm/graph-builder-interface.h"
@@ -1430,7 +1430,7 @@ Node* WasmGraphBuilder::IfDefault(Node* sw) {
   return graph()->NewNode(mcgraph()->common()->IfDefault(), sw);
 }
 
-Node* WasmGraphBuilder::Return(Vector<Node*> vals) {
+Node* WasmGraphBuilder::Return(base::Vector<Node*> vals) {
   unsigned count = static_cast<unsigned>(vals.size());
   base::SmallVector<Node*, 8> buf(count + 3);
 
@@ -2354,7 +2354,7 @@ Node* WasmGraphBuilder::MemoryGrow(Node* input) {
 
 Node* WasmGraphBuilder::Throw(uint32_t exception_index,
                               const wasm::WasmException* exception,
-                              const Vector<Node*> values,
+                              const base::Vector<Node*> values,
                               wasm::WasmCodePosition position) {
   needs_stack_check_ = true;
   uint32_t encoded_size = WasmExceptionPackage::GetEncodedSize(exception);
@@ -2491,7 +2491,7 @@ Node* WasmGraphBuilder::GetExceptionTag(Node* except_obj) {
 
 Node* WasmGraphBuilder::GetExceptionValues(Node* except_obj,
                                            const wasm::WasmException* exception,
-                                           Vector<Node*> values) {
+                                           base::Vector<Node*> values) {
   Node* values_array = gasm_->CallBuiltin(
       Builtin::kWasmGetOwnProperty, Operator::kEliminatable, except_obj,
       LOAD_ROOT(wasm_exception_values_symbol, wasm_exception_values_symbol),
@@ -2855,7 +2855,7 @@ Node* WasmGraphBuilder::BuildCCall(MachineSignature* sig, Node* function,
 }
 
 Node* WasmGraphBuilder::BuildCallNode(const wasm::FunctionSig* sig,
-                                      Vector<Node*> args,
+                                      base::Vector<Node*> args,
                                       wasm::WasmCodePosition position,
                                       Node* instance_node, const Operator* op,
                                       Node* frame_state) {
@@ -2891,12 +2891,10 @@ Node* WasmGraphBuilder::BuildCallNode(const wasm::FunctionSig* sig,
   return call;
 }
 
-Node* WasmGraphBuilder::BuildWasmCall(const wasm::FunctionSig* sig,
-                                      Vector<Node*> args, Vector<Node*> rets,
-                                      wasm::WasmCodePosition position,
-                                      Node* instance_node,
-                                      UseRetpoline use_retpoline,
-                                      Node* frame_state) {
+Node* WasmGraphBuilder::BuildWasmCall(
+    const wasm::FunctionSig* sig, base::Vector<Node*> args,
+    base::Vector<Node*> rets, wasm::WasmCodePosition position,
+    Node* instance_node, UseRetpoline use_retpoline, Node* frame_state) {
   CallDescriptor* call_descriptor =
       GetWasmCallDescriptor(mcgraph()->zone(), sig, use_retpoline,
                             kWasmFunction, frame_state != nullptr);
@@ -2925,7 +2923,7 @@ Node* WasmGraphBuilder::BuildWasmCall(const wasm::FunctionSig* sig,
 }
 
 Node* WasmGraphBuilder::BuildWasmReturnCall(const wasm::FunctionSig* sig,
-                                            Vector<Node*> args,
+                                            base::Vector<Node*> args,
                                             wasm::WasmCodePosition position,
                                             Node* instance_node,
                                             UseRetpoline use_retpoline) {
@@ -2942,7 +2940,8 @@ Node* WasmGraphBuilder::BuildWasmReturnCall(const wasm::FunctionSig* sig,
 }
 
 Node* WasmGraphBuilder::BuildImportCall(const wasm::FunctionSig* sig,
-                                        Vector<Node*> args, Vector<Node*> rets,
+                                        base::Vector<Node*> args,
+                                        base::Vector<Node*> rets,
                                         wasm::WasmCodePosition position,
                                         int func_index,
                                         IsReturnCall continuation) {
@@ -2951,7 +2950,8 @@ Node* WasmGraphBuilder::BuildImportCall(const wasm::FunctionSig* sig,
 }
 
 Node* WasmGraphBuilder::BuildImportCall(const wasm::FunctionSig* sig,
-                                        Vector<Node*> args, Vector<Node*> rets,
+                                        base::Vector<Node*> args,
+                                        base::Vector<Node*> rets,
                                         wasm::WasmCodePosition position,
                                         Node* func_index,
                                         IsReturnCall continuation) {
@@ -2984,8 +2984,8 @@ Node* WasmGraphBuilder::BuildImportCall(const wasm::FunctionSig* sig,
   }
 }
 
-Node* WasmGraphBuilder::CallDirect(uint32_t index, Vector<Node*> args,
-                                   Vector<Node*> rets,
+Node* WasmGraphBuilder::CallDirect(uint32_t index, base::Vector<Node*> args,
+                                   base::Vector<Node*> rets,
                                    wasm::WasmCodePosition position) {
   DCHECK_NULL(args[0]);
   const wasm::FunctionSig* sig = env_->module->functions[index].sig;
@@ -3004,7 +3004,8 @@ Node* WasmGraphBuilder::CallDirect(uint32_t index, Vector<Node*> args,
 }
 
 Node* WasmGraphBuilder::CallIndirect(uint32_t table_index, uint32_t sig_index,
-                                     Vector<Node*> args, Vector<Node*> rets,
+                                     base::Vector<Node*> args,
+                                     base::Vector<Node*> rets,
                                      wasm::WasmCodePosition position) {
   return BuildIndirectCall(table_index, sig_index, args, rets, position,
                            kCallContinues);
@@ -3061,8 +3062,8 @@ void WasmGraphBuilder::LoadIndirectFunctionTable(uint32_t table_index,
 
 Node* WasmGraphBuilder::BuildIndirectCall(uint32_t table_index,
                                           uint32_t sig_index,
-                                          Vector<Node*> args,
-                                          Vector<Node*> rets,
+                                          base::Vector<Node*> args,
+                                          base::Vector<Node*> rets,
                                           wasm::WasmCodePosition position,
                                           IsReturnCall continuation) {
   DCHECK_NOT_NULL(args[0]);
@@ -3167,8 +3168,9 @@ Node* WasmGraphBuilder::BuildLoadCallTargetFromExportedFunctionData(
 }
 
 // TODO(9495): Support CAPI function refs.
-Node* WasmGraphBuilder::BuildCallRef(uint32_t sig_index, Vector<Node*> args,
-                                     Vector<Node*> rets,
+Node* WasmGraphBuilder::BuildCallRef(uint32_t sig_index,
+                                     base::Vector<Node*> args,
+                                     base::Vector<Node*> rets,
                                      CheckForNull null_check,
                                      IsReturnCall continuation,
                                      wasm::WasmCodePosition position) {
@@ -3243,22 +3245,23 @@ Node* WasmGraphBuilder::BuildCallRef(uint32_t sig_index, Vector<Node*> args,
   return call;
 }
 
-Node* WasmGraphBuilder::CallRef(uint32_t sig_index, Vector<Node*> args,
-                                Vector<Node*> rets,
+Node* WasmGraphBuilder::CallRef(uint32_t sig_index, base::Vector<Node*> args,
+                                base::Vector<Node*> rets,
                                 WasmGraphBuilder::CheckForNull null_check,
                                 wasm::WasmCodePosition position) {
   return BuildCallRef(sig_index, args, rets, null_check,
                       IsReturnCall::kCallContinues, position);
 }
 
-Node* WasmGraphBuilder::ReturnCallRef(uint32_t sig_index, Vector<Node*> args,
+Node* WasmGraphBuilder::ReturnCallRef(uint32_t sig_index,
+                                      base::Vector<Node*> args,
                                       WasmGraphBuilder::CheckForNull null_check,
                                       wasm::WasmCodePosition position) {
   return BuildCallRef(sig_index, args, {}, null_check,
                       IsReturnCall::kReturnCall, position);
 }
 
-Node* WasmGraphBuilder::ReturnCall(uint32_t index, Vector<Node*> args,
+Node* WasmGraphBuilder::ReturnCall(uint32_t index, base::Vector<Node*> args,
                                    wasm::WasmCodePosition position) {
   DCHECK_NULL(args[0]);
   const wasm::FunctionSig* sig = env_->module->functions[index].sig;
@@ -3279,7 +3282,7 @@ Node* WasmGraphBuilder::ReturnCall(uint32_t index, Vector<Node*> args,
 
 Node* WasmGraphBuilder::ReturnCallIndirect(uint32_t table_index,
                                            uint32_t sig_index,
-                                           Vector<Node*> args,
+                                           base::Vector<Node*> args,
                                            wasm::WasmCodePosition position) {
   return BuildIndirectCall(table_index, sig_index, args, {}, position,
                            kReturnCall);
@@ -3873,7 +3876,7 @@ void WasmGraphBuilder::TraceFunctionEntry(wasm::WasmCodePosition position) {
   SetSourcePosition(call, position);
 }
 
-void WasmGraphBuilder::TraceFunctionExit(Vector<Node*> vals,
+void WasmGraphBuilder::TraceFunctionExit(base::Vector<Node*> vals,
                                          wasm::WasmCodePosition position) {
   Node* info = gasm_->IntPtrConstant(0);
   size_t num_returns = vals.size();
@@ -5557,7 +5560,8 @@ void WasmGraphBuilder::TableFill(uint32_t table_index, Node* start, Node* value,
 
 Node* WasmGraphBuilder::StructNewWithRtt(uint32_t struct_index,
                                          const wasm::StructType* type,
-                                         Node* rtt, Vector<Node*> fields) {
+                                         Node* rtt,
+                                         base::Vector<Node*> fields) {
   Node* s = gasm_->CallBuiltin(Builtin::kWasmAllocateStructWithRtt,
                                Operator::kEliminatable, rtt);
   for (uint32_t i = 0; i < type->field_count(); i++) {
@@ -6224,7 +6228,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
     return call;
   }
 
-  int AddArgumentNodes(Vector<Node*> args, int pos, int param_count,
+  int AddArgumentNodes(base::Vector<Node*> args, int pos, int param_count,
                        const wasm::FunctionSig* sig) {
     // Convert wasm numbers to JS values.
     for (int i = 0; i < param_count; ++i) {
@@ -6615,13 +6619,13 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
         // Load function index from {WasmExportedFunctionData}.
         Node* function_index = BuildChangeSmiToInt32(
             gasm_->LoadExportedFunctionIndexAsSmi(function_data));
-        BuildImportCall(sig_, VectorOf(args), VectorOf(rets),
+        BuildImportCall(sig_, base::VectorOf(args), base::VectorOf(rets),
                         wasm::kNoCodePosition, function_index, kCallContinues);
       } else {
         // Call to a wasm function defined in this module.
         // The (cached) call target is the jump table slot for that function.
         args[0] = BuildLoadCallTargetFromExportedFunctionData(function_data);
-        BuildWasmCall(sig_, VectorOf(args), VectorOf(rets),
+        BuildWasmCall(sig_, base::VectorOf(args), base::VectorOf(rets),
                       wasm::kNoCodePosition, nullptr, kNoRetpoline,
                       frame_state);
       }
@@ -6891,7 +6895,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
             graph()->zone(), false, wasm_count + 1, CallDescriptor::kNoFlags);
 
         // Convert wasm numbers to JS values.
-        pos = AddArgumentNodes(VectorOf(args), pos, wasm_count, sig_);
+        pos = AddArgumentNodes(base::VectorOf(args), pos, wasm_count, sig_);
 
         args[pos++] = undefined_node;                        // new target
         args[pos++] = Int32Constant(wasm_count);             // argument count
@@ -6917,7 +6921,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
             BuildReceiverNode(callable_node, native_context, undefined_node);
 
         // Convert wasm numbers to JS values.
-        pos = AddArgumentNodes(VectorOf(args), pos, wasm_count, sig_);
+        pos = AddArgumentNodes(base::VectorOf(args), pos, wasm_count, sig_);
         for (int i = wasm_count; i < expected_arity; ++i) {
           args[pos++] = undefined_node;
         }
@@ -6954,7 +6958,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
             StubCallMode::kCallBuiltinPointer);
 
         // Convert wasm numbers to JS values.
-        pos = AddArgumentNodes(VectorOf(args), pos, wasm_count, sig_);
+        pos = AddArgumentNodes(base::VectorOf(args), pos, wasm_count, sig_);
 
         // The native_context is sufficient here, because all kind of callables
         // which depend on the context provide their own context. The context
@@ -6992,7 +6996,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
                                 native_context, sig_->GetReturn(i));
       }
       BuildModifyThreadInWasmFlag(true);
-      Return(VectorOf(wasm_values));
+      Return(base::VectorOf(wasm_values));
     }
 
     if (ContainsInt64(sig_)) LowerInt64(kCalledFromWasm);
@@ -7088,7 +7092,7 @@ class WasmWrapperGraphBuilder : public WasmGraphBuilder {
         returns[i] = val;
         offset += type.element_size_bytes();
       }
-      Return(VectorOf(returns));
+      Return(base::VectorOf(returns));
     }
 
     if (ContainsInt64(sig_)) LowerInt64(kCalledFromWasm);
@@ -7584,9 +7588,10 @@ wasm::WasmCompilationResult CompileWasmImportCallWrapper(
   // Build a name in the form "wasm-to-js-<kind>-<signature>".
   constexpr size_t kMaxNameLen = 128;
   char func_name[kMaxNameLen];
-  int name_prefix_len = SNPrintF(VectorOf(func_name, kMaxNameLen),
+  int name_prefix_len = SNPrintF(base::VectorOf(func_name, kMaxNameLen),
                                  "wasm-to-js-%d-", static_cast<int>(kind));
-  PrintSignature(VectorOf(func_name, kMaxNameLen) + name_prefix_len, sig, '-');
+  PrintSignature(base::VectorOf(func_name, kMaxNameLen) + name_prefix_len, sig,
+                 '-');
 
   // Schedule and compile to machine code.
   CallDescriptor* incoming =
@@ -7679,8 +7684,8 @@ MaybeHandle<Code> CompileWasmToJSWrapper(Isolate* isolate,
   constexpr size_t kNamePrefixLen = 11;
   auto name_buffer = std::unique_ptr<char[]>(new char[kMaxNameLen]);
   memcpy(name_buffer.get(), "wasm-to-js:", kNamePrefixLen);
-  PrintSignature(VectorOf(name_buffer.get(), kMaxNameLen) + kNamePrefixLen,
-                 sig);
+  PrintSignature(
+      base::VectorOf(name_buffer.get(), kMaxNameLen) + kNamePrefixLen, sig);
 
   // Generate the call descriptor.
   CallDescriptor* incoming =
@@ -7731,8 +7736,8 @@ MaybeHandle<Code> CompileJSToJSWrapper(Isolate* isolate,
   constexpr size_t kNamePrefixLen = 9;
   auto name_buffer = std::unique_ptr<char[]>(new char[kMaxNameLen]);
   memcpy(name_buffer.get(), "js-to-js:", kNamePrefixLen);
-  PrintSignature(VectorOf(name_buffer.get(), kMaxNameLen) + kNamePrefixLen,
-                 sig);
+  PrintSignature(
+      base::VectorOf(name_buffer.get(), kMaxNameLen) + kNamePrefixLen, sig);
 
   // Run the compilation job synchronously.
   std::unique_ptr<OptimizedCompilationJob> job(
@@ -7786,8 +7791,8 @@ Handle<Code> CompileCWasmEntry(Isolate* isolate, const wasm::FunctionSig* sig,
   constexpr size_t kNamePrefixLen = 13;
   auto name_buffer = std::unique_ptr<char[]>(new char[kMaxNameLen]);
   memcpy(name_buffer.get(), "c-wasm-entry:", kNamePrefixLen);
-  PrintSignature(VectorOf(name_buffer.get(), kMaxNameLen) + kNamePrefixLen,
-                 sig);
+  PrintSignature(
+      base::VectorOf(name_buffer.get(), kMaxNameLen) + kNamePrefixLen, sig);
 
   // Run the compilation job synchronously.
   std::unique_ptr<OptimizedCompilationJob> job(
@@ -7839,17 +7844,17 @@ bool BuildGraphForWasmFunction(AccountingAllocator* allocator,
   return true;
 }
 
-Vector<const char> GetDebugName(Zone* zone, int index) {
+base::Vector<const char> GetDebugName(Zone* zone, int index) {
   // TODO(herhut): Use name from module if available.
   constexpr int kBufferLength = 24;
 
-  EmbeddedVector<char, kBufferLength> name_vector;
+  base::EmbeddedVector<char, kBufferLength> name_vector;
   int name_len = SNPrintF(name_vector, "wasm-function#%d", index);
   DCHECK(name_len > 0 && name_len < name_vector.length());
 
   char* index_name = zone->NewArray<char>(name_len);
   memcpy(index_name, name_vector.begin(), name_len);
-  return Vector<const char>(index_name, name_len);
+  return base::Vector<const char>(index_name, name_len);
 }
 
 }  // namespace
diff --git a/src/compiler/wasm-compiler.h b/src/compiler/wasm-compiler.h
index d746c8e261..4c151710f0 100644
--- a/src/compiler/wasm-compiler.h
+++ b/src/compiler/wasm-compiler.h
@@ -268,14 +268,15 @@ class WasmGraphBuilder {
              wasm::WasmCodePosition position = wasm::kNoCodePosition);
   Node* MemoryGrow(Node* input);
   Node* Throw(uint32_t exception_index, const wasm::WasmException* exception,
-              const Vector<Node*> values, wasm::WasmCodePosition position);
+              const base::Vector<Node*> values,
+              wasm::WasmCodePosition position);
   Node* Rethrow(Node* except_obj);
   Node* ExceptionTagEqual(Node* caught_tag, Node* expected_tag);
   Node* LoadExceptionTagFromTable(uint32_t exception_index);
   Node* GetExceptionTag(Node* except_obj);
   Node* GetExceptionValues(Node* except_obj,
                            const wasm::WasmException* exception,
-                           Vector<Node*> values_out);
+                           base::Vector<Node*> values_out);
   bool IsPhiWithMerge(Node* phi, Node* merge);
   bool ThrowsException(Node* node, Node** if_success, Node** if_exception);
   void AppendToMerge(Node* merge, Node* from);
@@ -311,31 +312,34 @@ class WasmGraphBuilder {
   Node* Switch(unsigned count, Node* key);
   Node* IfValue(int32_t value, Node* sw);
   Node* IfDefault(Node* sw);
-  Node* Return(Vector<Node*> nodes);
+  Node* Return(base::Vector<Node*> nodes);
   template <typename... Nodes>
   Node* Return(Node* fst, Nodes*... more) {
     Node* arr[] = {fst, more...};
-    return Return(ArrayVector(arr));
+    return Return(base::ArrayVector(arr));
   }
 
   void TraceFunctionEntry(wasm::WasmCodePosition position);
-  void TraceFunctionExit(Vector<Node*> vals, wasm::WasmCodePosition position);
+  void TraceFunctionExit(base::Vector<Node*> vals,
+                         wasm::WasmCodePosition position);
 
   void Trap(wasm::TrapReason reason, wasm::WasmCodePosition position);
 
-  Node* CallDirect(uint32_t index, Vector<Node*> args, Vector<Node*> rets,
-                   wasm::WasmCodePosition position);
+  Node* CallDirect(uint32_t index, base::Vector<Node*> args,
+                   base::Vector<Node*> rets, wasm::WasmCodePosition position);
   Node* CallIndirect(uint32_t table_index, uint32_t sig_index,
-                     Vector<Node*> args, Vector<Node*> rets,
+                     base::Vector<Node*> args, base::Vector<Node*> rets,
                      wasm::WasmCodePosition position);
-  Node* CallRef(uint32_t sig_index, Vector<Node*> args, Vector<Node*> rets,
-                CheckForNull null_check, wasm::WasmCodePosition position);
+  Node* CallRef(uint32_t sig_index, base::Vector<Node*> args,
+                base::Vector<Node*> rets, CheckForNull null_check,
+                wasm::WasmCodePosition position);
 
-  Node* ReturnCall(uint32_t index, Vector<Node*> args,
+  Node* ReturnCall(uint32_t index, base::Vector<Node*> args,
                    wasm::WasmCodePosition position);
   Node* ReturnCallIndirect(uint32_t table_index, uint32_t sig_index,
-                           Vector<Node*> args, wasm::WasmCodePosition position);
-  Node* ReturnCallRef(uint32_t sig_index, Vector<Node*> args,
+                           base::Vector<Node*> args,
+                           wasm::WasmCodePosition position);
+  Node* ReturnCallRef(uint32_t sig_index, base::Vector<Node*> args,
                       CheckForNull null_check, wasm::WasmCodePosition position);
 
   void BrOnNull(Node* ref_object, Node** non_null_node, Node** null_node);
@@ -454,7 +458,7 @@ class WasmGraphBuilder {
   void TableFill(uint32_t table_index, Node* start, Node* value, Node* count);
 
   Node* StructNewWithRtt(uint32_t struct_index, const wasm::StructType* type,
-                         Node* rtt, Vector<Node*> fields);
+                         Node* rtt, base::Vector<Node*> fields);
   Node* StructGet(Node* struct_object, const wasm::StructType* struct_type,
                   uint32_t field_index, CheckForNull null_check, bool is_signed,
                   wasm::WasmCodePosition position);
@@ -561,7 +565,7 @@ class WasmGraphBuilder {
 
   template <typename... Args>
   Node* BuildCCall(MachineSignature* sig, Node* function, Args... args);
-  Node* BuildCallNode(const wasm::FunctionSig* sig, Vector<Node*> args,
+  Node* BuildCallNode(const wasm::FunctionSig* sig, base::Vector<Node*> args,
                       wasm::WasmCodePosition position, Node* instance_node,
                       const Operator* op, Node* frame_state = nullptr);
   // Helper function for {BuildIndirectCall}.
@@ -569,24 +573,28 @@ class WasmGraphBuilder {
                                  Node** ift_sig_ids, Node** ift_targets,
                                  Node** ift_instances);
   Node* BuildIndirectCall(uint32_t table_index, uint32_t sig_index,
-                          Vector<Node*> args, Vector<Node*> rets,
+                          base::Vector<Node*> args, base::Vector<Node*> rets,
                           wasm::WasmCodePosition position,
                           IsReturnCall continuation);
-  Node* BuildWasmCall(const wasm::FunctionSig* sig, Vector<Node*> args,
-                      Vector<Node*> rets, wasm::WasmCodePosition position,
+  Node* BuildWasmCall(const wasm::FunctionSig* sig, base::Vector<Node*> args,
+                      base::Vector<Node*> rets, wasm::WasmCodePosition position,
                       Node* instance_node, UseRetpoline use_retpoline,
                       Node* frame_state = nullptr);
-  Node* BuildWasmReturnCall(const wasm::FunctionSig* sig, Vector<Node*> args,
+  Node* BuildWasmReturnCall(const wasm::FunctionSig* sig,
+                            base::Vector<Node*> args,
                             wasm::WasmCodePosition position,
                             Node* instance_node, UseRetpoline use_retpoline);
-  Node* BuildImportCall(const wasm::FunctionSig* sig, Vector<Node*> args,
-                        Vector<Node*> rets, wasm::WasmCodePosition position,
-                        int func_index, IsReturnCall continuation);
-  Node* BuildImportCall(const wasm::FunctionSig* sig, Vector<Node*> args,
-                        Vector<Node*> rets, wasm::WasmCodePosition position,
-                        Node* func_index, IsReturnCall continuation);
-  Node* BuildCallRef(uint32_t sig_index, Vector<Node*> args, Vector<Node*> rets,
-                     CheckForNull null_check, IsReturnCall continuation,
+  Node* BuildImportCall(const wasm::FunctionSig* sig, base::Vector<Node*> args,
+                        base::Vector<Node*> rets,
+                        wasm::WasmCodePosition position, int func_index,
+                        IsReturnCall continuation);
+  Node* BuildImportCall(const wasm::FunctionSig* sig, base::Vector<Node*> args,
+                        base::Vector<Node*> rets,
+                        wasm::WasmCodePosition position, Node* func_index,
+                        IsReturnCall continuation);
+  Node* BuildCallRef(uint32_t sig_index, base::Vector<Node*> args,
+                     base::Vector<Node*> rets, CheckForNull null_check,
+                     IsReturnCall continuation,
                      wasm::WasmCodePosition position);
 
   Node* BuildF32CopySign(Node* left, Node* right);
diff --git a/src/date/dateparser-inl.h b/src/date/dateparser-inl.h
index 436b144478..d4a153356e 100644
--- a/src/date/dateparser-inl.h
+++ b/src/date/dateparser-inl.h
@@ -13,7 +13,7 @@ namespace v8 {
 namespace internal {
 
 template <typename Char>
-bool DateParser::Parse(Isolate* isolate, Vector<Char> str, double* out) {
+bool DateParser::Parse(Isolate* isolate, base::Vector<Char> str, double* out) {
   InputReader<Char> in(str);
   DateStringTokenizer<Char> scanner(&in);
   TimeZoneComposer tz;
diff --git a/src/date/dateparser.h b/src/date/dateparser.h
index c74a663e1e..9975737c07 100644
--- a/src/date/dateparser.h
+++ b/src/date/dateparser.h
@@ -5,9 +5,9 @@
 #ifndef V8_DATE_DATEPARSER_H_
 #define V8_DATE_DATEPARSER_H_
 
+#include "src/base/vector.h"
 #include "src/strings/char-predicates.h"
 #include "src/utils/allocation.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -38,7 +38,7 @@ class DateParser : public AllStatic {
   // [7]: UTC offset in seconds, or null value if no timezone specified
   // If parsing fails, return false (content of output array is not defined).
   template <typename Char>
-  static bool Parse(Isolate* isolate, Vector<Char> str, double* output);
+  static bool Parse(Isolate* isolate, base::Vector<Char> str, double* output);
 
  private:
   // Range testing
@@ -57,7 +57,9 @@ class DateParser : public AllStatic {
   template <typename Char>
   class InputReader {
    public:
-    explicit InputReader(Vector<Char> s) : index_(0), buffer_(s) { Next(); }
+    explicit InputReader(base::Vector<Char> s) : index_(0), buffer_(s) {
+      Next();
+    }
 
     int position() { return index_; }
 
@@ -117,7 +119,7 @@ class DateParser : public AllStatic {
 
    private:
     int index_;
-    Vector<Char> buffer_;
+    base::Vector<Char> buffer_;
     uint32_t ch_;
   };
 
diff --git a/src/debug/debug-interface.cc b/src/debug/debug-interface.cc
index 8f0fb976db..3de21fdb5d 100644
--- a/src/debug/debug-interface.cc
+++ b/src/debug/debug-interface.cc
@@ -642,7 +642,7 @@ int WasmScript::NumImportedFunctions() const {
 
 MemorySpan<const uint8_t> WasmScript::Bytecode() const {
   i::Handle<i::Script> script = Utils::OpenHandle(this);
-  i::Vector<const uint8_t> wire_bytes =
+  base::Vector<const uint8_t> wire_bytes =
       script->wasm_native_module()->wire_bytes();
   return {wire_bytes.begin(), wire_bytes.size()};
 }
@@ -683,7 +683,8 @@ uint32_t WasmScript::GetFunctionHash(int function_index) {
   DCHECK_GT(module->functions.size(), function_index);
   const i::wasm::WasmFunction& func = module->functions[function_index];
   i::wasm::ModuleWireBytes wire_bytes(native_module->wire_bytes());
-  i::Vector<const i::byte> function_bytes = wire_bytes.GetFunctionBytes(&func);
+  base::Vector<const i::byte> function_bytes =
+      wire_bytes.GetFunctionBytes(&func);
   // TODO(herhut): Maybe also take module, name and signature into account.
   return i::StringHasher::HashSequentialString(function_bytes.begin(),
                                                function_bytes.length(), 0);
diff --git a/src/debug/debug-interface.h b/src/debug/debug-interface.h
index 960a3994ab..d598a8edde 100644
--- a/src/debug/debug-interface.h
+++ b/src/debug/debug-interface.h
@@ -10,9 +10,9 @@
 #include "include/v8-util.h"
 #include "include/v8.h"
 #include "src/base/platform/time.h"
+#include "src/base/vector.h"
 #include "src/common/globals.h"
 #include "src/debug/interface-types.h"
-#include "src/utils/vector.h"
 
 namespace v8_inspector {
 class V8Inspector;
diff --git a/src/debug/debug-wasm-objects.cc b/src/debug/debug-wasm-objects.cc
index 102612341e..08461ef456 100644
--- a/src/debug/debug-wasm-objects.cc
+++ b/src/debug/debug-wasm-objects.cc
@@ -31,7 +31,7 @@ Handle<String> GetNameOrDefault(Isolate* isolate,
                .ToHandleChecked();
     return isolate->factory()->InternalizeString(name);
   }
-  EmbeddedVector<char, 64> value;
+  base::EmbeddedVector<char, 64> value;
   int len = SNPrintF(value, "%s%u", default_name_prefix, index);
   return isolate->factory()->InternalizeString(value.SubVector(0, len));
 }
@@ -45,8 +45,8 @@ MaybeHandle<String> GetNameFromImportsAndExportsOrNull(
 
   auto import_name_ref = debug_info->GetImportName(kind, index);
   if (!import_name_ref.first.is_empty()) {
-    ScopedVector<char> name(import_name_ref.first.length() + 1 +
-                            import_name_ref.second.length());
+    base::ScopedVector<char> name(import_name_ref.first.length() + 1 +
+                                  import_name_ref.second.length());
     auto name_begin = &name.first(), name_end = name_begin;
     auto module_name = wire_bytes.GetNameOrNull(import_name_ref.first);
     name_end = std::copy(module_name.begin(), module_name.end(), name_end);
@@ -54,7 +54,7 @@ MaybeHandle<String> GetNameFromImportsAndExportsOrNull(
     auto field_name = wire_bytes.GetNameOrNull(import_name_ref.second);
     name_end = std::copy(field_name.begin(), field_name.end(), name_end);
     return isolate->factory()->NewStringFromUtf8(
-        VectorOf(name_begin, name_end - name_begin));
+        base::VectorOf(name_begin, name_end - name_begin));
   }
 
   auto export_name_ref = debug_info->GetExportName(kind, index);
@@ -758,7 +758,7 @@ class DebugWasmScopeIterator final : public debug::ScopeIterator {
 Handle<String> WasmSimd128ToString(Isolate* isolate, wasm::Simd128 s128) {
   // We use the canonical format as described in:
   // https://github.com/WebAssembly/simd/blob/master/proposals/simd/TextSIMD.md
-  EmbeddedVector<char, 50> buffer;
+  base::EmbeddedVector<char, 50> buffer;
   auto i32x4 = s128.to_i32x4();
   SNPrintF(buffer, "i32x4 0x%08X 0x%08X 0x%08X 0x%08X", i32x4.val[0],
            i32x4.val[1], i32x4.val[2], i32x4.val[3]);
@@ -772,7 +772,7 @@ Handle<String> GetRefTypeName(Isolate* isolate, wasm::ValueType type,
   // This length only needs to be enough for generated names like
   // "(ref null $type12345)". For names coming from the name section,
   // we'll dynamically allocate an appropriately sized vector.
-  EmbeddedVector<char, 32> type_name;
+  base::EmbeddedVector<char, 32> type_name;
   size_t len;
   if (type.heap_type().is_generic()) {
     const char* generic_name = "";
@@ -803,7 +803,7 @@ Handle<String> GetRefTypeName(Isolate* isolate, wasm::ValueType type,
   } else {
     int type_index = type.ref_index();
     wasm::ModuleWireBytes module_wire_bytes(module->wire_bytes());
-    Vector<const char> name_vec = module_wire_bytes.GetNameOrNull(
+    base::Vector<const char> name_vec = module_wire_bytes.GetNameOrNull(
         module->GetDebugInfo()->GetTypeName(type_index));
     if (name_vec.empty()) {
       len = SNPrintF(type_name, "(ref%s $type%u)", null_str, type_index);
@@ -812,9 +812,10 @@ Handle<String> GetRefTypeName(Isolate* isolate, wasm::ValueType type,
           name_vec.size() +       // length of provided name
           7 +                     // length of "(ref $)"
           (is_nullable ? 5 : 0);  // length of " null" (optional)
-      Vector<char> long_type_name = Vector<char>::New(required_length);
+      base::Vector<char> long_type_name =
+          base::Vector<char>::New(required_length);
       len = SNPrintF(long_type_name, "(ref%s $", null_str);
-      Vector<char> suffix =
+      base::Vector<char> suffix =
           long_type_name.SubVector(len, long_type_name.size());
       // StrNCpy requires that there is room for an assumed trailing \0...
       DCHECK_EQ(suffix.size(), name_vec.size() + 1);
@@ -845,14 +846,15 @@ Handle<WasmValueObject> WasmValueObject::New(Isolate* isolate,
     {  // type
       Descriptor d = Descriptor::DataField(
           isolate,
-          isolate->factory()->InternalizeString(StaticCharVector("type")),
+          isolate->factory()->InternalizeString(base::StaticCharVector("type")),
           WasmValueObject::kTypeIndex, FROZEN, Representation::Tagged());
       map->AppendDescriptor(isolate, &d);
     }
     {  // value
       Descriptor d = Descriptor::DataField(
           isolate,
-          isolate->factory()->InternalizeString(StaticCharVector("value")),
+          isolate->factory()->InternalizeString(
+              base::StaticCharVector("value")),
           WasmValueObject::kValueIndex, FROZEN, Representation::Tagged());
       map->AppendDescriptor(isolate, &d);
     }
@@ -905,7 +907,7 @@ struct StructProxy : NamedDebugProxy<StructProxy, kStructProxy, FixedArray> {
         WasmModuleObject::cast(data->get(kModuleIndex)).native_module();
     int struct_type_index = Smi::ToInt(Smi::cast(data->get(kTypeIndexIndex)));
     wasm::ModuleWireBytes module_wire_bytes(native_module->wire_bytes());
-    Vector<const char> name_vec = module_wire_bytes.GetNameOrNull(
+    base::Vector<const char> name_vec = module_wire_bytes.GetNameOrNull(
         native_module->GetDebugInfo()->GetFieldName(struct_type_index, index));
     return GetNameOrDefault(
         isolate,
@@ -970,46 +972,46 @@ Handle<WasmValueObject> WasmValueObject::New(
     case wasm::kI8: {
       // This can't be reached for most "top-level" things, only via nested
       // calls for struct/array fields.
-      t = isolate->factory()->InternalizeString(StaticCharVector("i8"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("i8"));
       v = isolate->factory()->NewNumber(value.to_i8_unchecked());
       break;
     }
     case wasm::kI16: {
       // This can't be reached for most "top-level" things, only via nested
       // calls for struct/array fields.
-      t = isolate->factory()->InternalizeString(StaticCharVector("i16"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("i16"));
       v = isolate->factory()->NewNumber(value.to_i16_unchecked());
       break;
     }
     case wasm::kI32: {
-      t = isolate->factory()->InternalizeString(StaticCharVector("i32"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("i32"));
       v = isolate->factory()->NewNumberFromInt(value.to_i32_unchecked());
       break;
     }
     case wasm::kI64: {
-      t = isolate->factory()->InternalizeString(StaticCharVector("i64"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("i64"));
       v = BigInt::FromInt64(isolate, value.to_i64_unchecked());
       break;
     }
     case wasm::kF32: {
-      t = isolate->factory()->InternalizeString(StaticCharVector("f32"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("f32"));
       v = isolate->factory()->NewNumber(value.to_f32_unchecked());
       break;
     }
     case wasm::kF64: {
-      t = isolate->factory()->InternalizeString(StaticCharVector("f64"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("f64"));
       v = isolate->factory()->NewNumber(value.to_f64_unchecked());
       break;
     }
     case wasm::kS128: {
-      t = isolate->factory()->InternalizeString(StaticCharVector("v128"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("v128"));
       v = WasmSimd128ToString(isolate, value.to_s128_unchecked());
       break;
     }
     case wasm::kOptRef:
       if (value.type().is_reference_to(wasm::HeapType::kExtern)) {
         t = isolate->factory()->InternalizeString(
-            StaticCharVector("externref"));
+            base::StaticCharVector("externref"));
         v = value.to_ref();
         break;
       }
@@ -1025,7 +1027,7 @@ Handle<WasmValueObject> WasmValueObject::New(
         v = ref;
       } else {
         // Fail gracefully.
-        EmbeddedVector<char, 64> error;
+        base::EmbeddedVector<char, 64> error;
         int len = SNPrintF(error, "unimplemented object type: %d",
                            HeapObject::cast(*ref).map().instance_type());
         v = isolate->factory()->InternalizeString(error.SubVector(0, len));
@@ -1035,9 +1037,9 @@ Handle<WasmValueObject> WasmValueObject::New(
     case wasm::kRtt:
     case wasm::kRttWithDepth: {
       // TODO(7748): Expose RTTs to DevTools.
-      t = isolate->factory()->InternalizeString(StaticCharVector("rtt"));
+      t = isolate->factory()->InternalizeString(base::StaticCharVector("rtt"));
       v = isolate->factory()->InternalizeString(
-          StaticCharVector("(unimplemented)"));
+          base::StaticCharVector("(unimplemented)"));
       break;
     }
     case wasm::kVoid:
diff --git a/src/debug/wasm/gdb-server/wasm-module-debug.cc b/src/debug/wasm/gdb-server/wasm-module-debug.cc
index 373e482261..d6195b333e 100644
--- a/src/debug/wasm/gdb-server/wasm-module-debug.cc
+++ b/src/debug/wasm/gdb-server/wasm-module-debug.cc
@@ -55,14 +55,14 @@ Handle<WasmInstanceObject> WasmModuleDebug::GetFirstWasmInstance() {
   return Handle<WasmInstanceObject>::null();
 }
 
-int GetLEB128Size(Vector<const uint8_t> module_bytes, int offset) {
+int GetLEB128Size(base::Vector<const uint8_t> module_bytes, int offset) {
   int index = offset;
   while (module_bytes[index] & 0x80) index++;
   return index + 1 - offset;
 }
 
 int ReturnPc(const NativeModule* native_module, int pc) {
-  Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
+  base::Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
   uint8_t opcode = wire_bytes[pc];
   switch (opcode) {
     case kExprCallFunction: {
diff --git a/src/deoptimizer/deoptimizer.cc b/src/deoptimizer/deoptimizer.cc
index fa13d3b2e2..ef6c3a621c 100644
--- a/src/deoptimizer/deoptimizer.cc
+++ b/src/deoptimizer/deoptimizer.cc
@@ -1902,7 +1902,7 @@ void Deoptimizer::DoComputeBuiltinContinuation(
       config->num_allocatable_general_registers();
   for (int i = 0; i < allocatable_register_count; ++i) {
     int code = config->GetAllocatableGeneralCode(i);
-    ScopedVector<char> str(128);
+    base::ScopedVector<char> str(128);
     if (verbose_tracing_enabled()) {
       if (BuiltinContinuationModeIsJavaScript(mode) &&
           code == kJavaScriptCallArgCountRegister.code()) {
diff --git a/src/diagnostics/arm/disasm-arm.cc b/src/diagnostics/arm/disasm-arm.cc
index 1be66425db..e23e2a815d 100644
--- a/src/diagnostics/arm/disasm-arm.cc
+++ b/src/diagnostics/arm/disasm-arm.cc
@@ -11,7 +11,7 @@
 //   NameConverter converter;
 //   Disassembler d(converter);
 //   for (byte* pc = begin; pc < end;) {
-//     v8::internal::EmbeddedVector<char, 256> buffer;
+//     v8::base::EmbeddedVector<char, 256> buffer;
 //     byte* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
@@ -32,11 +32,11 @@
 
 #include "src/base/bits.h"
 #include "src/base/platform/platform.h"
+#include "src/base/vector.h"
 #include "src/codegen/arm/assembler-arm.h"
 #include "src/codegen/arm/constants-arm.h"
 #include "src/codegen/arm/register-arm.h"
 #include "src/diagnostics/disasm.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -48,7 +48,7 @@ namespace internal {
 // more informative description.
 class Decoder {
  public:
-  Decoder(const disasm::NameConverter& converter, Vector<char> out_buffer)
+  Decoder(const disasm::NameConverter& converter, base::Vector<char> out_buffer)
       : converter_(converter), out_buffer_(out_buffer), out_buffer_pos_(0) {
     out_buffer_[out_buffer_pos_] = '\0';
   }
@@ -134,7 +134,7 @@ class Decoder {
   void DecodeVmovImmediate(Instruction* instr);
 
   const disasm::NameConverter& converter_;
-  Vector<char> out_buffer_;
+  base::Vector<char> out_buffer_;
   int out_buffer_pos_;
 };
 
@@ -2613,7 +2613,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
@@ -2628,7 +2628,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/diagnostics/arm64/disasm-arm64.cc b/src/diagnostics/arm64/disasm-arm64.cc
index 2b8b84e25f..b51ab9fcd9 100644
--- a/src/diagnostics/arm64/disasm-arm64.cc
+++ b/src/diagnostics/arm64/disasm-arm64.cc
@@ -4358,7 +4358,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 class BufferDisassembler : public v8::internal::DisassemblingDecoder {
  public:
-  explicit BufferDisassembler(v8::internal::Vector<char> out_buffer)
+  explicit BufferDisassembler(v8::base::Vector<char> out_buffer)
       : out_buffer_(out_buffer) {}
 
   ~BufferDisassembler() {}
@@ -4369,10 +4369,10 @@ class BufferDisassembler : public v8::internal::DisassemblingDecoder {
   }
 
  private:
-  v8::internal::Vector<char> out_buffer_;
+  v8::base::Vector<char> out_buffer_;
 };
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instr) {
   USE(converter_);  // avoid unused field warning
   v8::internal::Decoder<v8::internal::DispatchingDecoderVisitor> decoder;
diff --git a/src/diagnostics/code-tracer.h b/src/diagnostics/code-tracer.h
index b859953933..823f023106 100644
--- a/src/diagnostics/code-tracer.h
+++ b/src/diagnostics/code-tracer.h
@@ -7,12 +7,12 @@
 
 #include "src/base/optional.h"
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/common/globals.h"
 #include "src/flags/flags.h"
 #include "src/utils/allocation.h"
 #include "src/utils/ostreams.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -102,7 +102,7 @@ class CodeTracer final : public Malloced {
  private:
   static bool ShouldRedirect() { return FLAG_redirect_code_traces; }
 
-  EmbeddedVector<char, 128> filename_;
+  base::EmbeddedVector<char, 128> filename_;
   FILE* file_;
   int scope_depth_;
 };
diff --git a/src/diagnostics/disasm.h b/src/diagnostics/disasm.h
index 036691877c..aea93a235b 100644
--- a/src/diagnostics/disasm.h
+++ b/src/diagnostics/disasm.h
@@ -5,7 +5,7 @@
 #ifndef V8_DIAGNOSTICS_DISASM_H_
 #define V8_DIAGNOSTICS_DISASM_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace disasm {
 
@@ -31,7 +31,7 @@ class V8_EXPORT_PRIVATE NameConverter {
   virtual const char* RootRelativeName(int offset) const { UNREACHABLE(); }
 
  protected:
-  v8::internal::EmbeddedVector<char, 128> tmp_buffer_;
+  v8::base::EmbeddedVector<char, 128> tmp_buffer_;
 };
 
 // A generic Disassembler interface
@@ -55,7 +55,7 @@ class Disassembler {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  V8_EXPORT_PRIVATE int InstructionDecode(v8::internal::Vector<char> buffer,
+  V8_EXPORT_PRIVATE int InstructionDecode(v8::base::Vector<char> buffer,
                                           byte* instruction);
 
   // Returns -1 if instruction does not mark the beginning of a constant pool,
diff --git a/src/diagnostics/disassembler.cc b/src/diagnostics/disassembler.cc
index 18be458697..d5884ae981 100644
--- a/src/diagnostics/disassembler.cc
+++ b/src/diagnostics/disassembler.cc
@@ -9,6 +9,7 @@
 #include <vector>
 
 #include "src/base/memory.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/code-comments.h"
 #include "src/codegen/code-reference.h"
@@ -22,7 +23,6 @@
 #include "src/objects/objects-inl.h"
 #include "src/snapshot/embedded/embedded-data.h"
 #include "src/strings/string-stream.h"
-#include "src/utils/vector.h"
 
 #if V8_ENABLE_WEBASSEMBLY
 #include "src/wasm/wasm-code-manager.h"
@@ -50,7 +50,7 @@ class V8NameConverter : public disasm::NameConverter {
   Isolate* isolate_;
   CodeReference code_;
 
-  EmbeddedVector<char, 128> v8_buffer_;
+  base::EmbeddedVector<char, 128> v8_buffer_;
 
   // Map from root-register relative offset of the external reference value to
   // the external reference name (stored in the external reference table).
@@ -280,8 +280,8 @@ static int DecodeIt(Isolate* isolate, ExternalReferenceEncoder* ref_encoder,
                     const V8NameConverter& converter, byte* begin, byte* end,
                     Address current_pc) {
   CHECK(!code.is_null());
-  v8::internal::EmbeddedVector<char, 128> decode_buffer;
-  v8::internal::EmbeddedVector<char, kOutBufferSize> out_buffer;
+  v8::base::EmbeddedVector<char, 128> decode_buffer;
+  v8::base::EmbeddedVector<char, kOutBufferSize> out_buffer;
   StringBuilder out(out_buffer.begin(), out_buffer.length());
   byte* pc = begin;
   disasm::Disassembler d(converter,
diff --git a/src/diagnostics/gdb-jit.cc b/src/diagnostics/gdb-jit.cc
index 6d7c677948..e5d9be5020 100644
--- a/src/diagnostics/gdb-jit.cc
+++ b/src/diagnostics/gdb-jit.cc
@@ -13,13 +13,13 @@
 #include "src/base/hashmap.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/execution/frames-inl.h"
 #include "src/execution/frames.h"
 #include "src/handles/global-handles.h"
 #include "src/init/bootstrapper.h"
 #include "src/objects/objects.h"
 #include "src/utils/ostreams.h"
-#include "src/utils/vector.h"
 #include "src/zone/zone-chunk-list.h"
 
 namespace v8 {
@@ -1093,7 +1093,7 @@ class DebugInfoSection : public DebugSection {
       int internal_slots = Context::MIN_CONTEXT_SLOTS;
       int current_abbreviation = 4;
 
-      EmbeddedVector<char, 256> buffer;
+      base::EmbeddedVector<char, 256> buffer;
       StringBuilder builder(buffer.begin(), buffer.length());
 
       for (int param = 0; param < params; ++param) {
@@ -1962,8 +1962,9 @@ static void AddJITCodeEntry(CodeMap* map, const AddressRange& range,
     static const int kMaxFileNameSize = 64;
     char file_name[64];
 
-    SNPrintF(Vector<char>(file_name, kMaxFileNameSize), "/tmp/elfdump%s%d.o",
-             (name_hint != nullptr) ? name_hint : "", file_num++);
+    SNPrintF(base::Vector<char>(file_name, kMaxFileNameSize),
+             "/tmp/elfdump%s%d.o", (name_hint != nullptr) ? name_hint : "",
+             file_num++);
     WriteBytes(file_name, reinterpret_cast<byte*>(entry->symfile_addr_),
                static_cast<int>(entry->symfile_size_));
   }
@@ -2023,7 +2024,7 @@ void EventHandler(const v8::JitCodeEvent* event) {
       Isolate* isolate = reinterpret_cast<Isolate*>(event->isolate);
       Code code = isolate->heap()->GcSafeFindCodeForInnerPointer(addr);
       LineInfo* lineinfo = GetLineInfo(addr);
-      EmbeddedVector<char, 256> buffer;
+      base::EmbeddedVector<char, 256> buffer;
       StringBuilder builder(buffer.begin(), buffer.length());
       builder.AddSubstring(event->name.str, static_cast<int>(event->name.len));
       // It's called UnboundScript in the API but it's a SharedFunctionInfo.
diff --git a/src/diagnostics/ia32/disasm-ia32.cc b/src/diagnostics/ia32/disasm-ia32.cc
index a9a0679e24..3019db9944 100644
--- a/src/diagnostics/ia32/disasm-ia32.cc
+++ b/src/diagnostics/ia32/disasm-ia32.cc
@@ -222,7 +222,7 @@ class DisassemblerIA32 {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(v8::internal::Vector<char> buffer, byte* instruction);
+  int InstructionDecode(v8::base::Vector<char> buffer, byte* instruction);
 
  private:
   const NameConverter& converter_;
@@ -230,7 +230,7 @@ class DisassemblerIA32 {
   byte vex_byte1_;
   byte vex_byte2_;  // only for 3 bytes vex prefix
   InstructionTable* instruction_table_;
-  v8::internal::EmbeddedVector<char, 128> tmp_buffer_;
+  v8::base::EmbeddedVector<char, 128> tmp_buffer_;
   unsigned int tmp_buffer_pos_;
   Disassembler::UnimplementedOpcodeAction unimplemented_opcode_action_;
 
@@ -374,7 +374,7 @@ class DisassemblerIA32 {
 };
 
 void DisassemblerIA32::AppendToBuffer(const char* format, ...) {
-  v8::internal::Vector<char> buf = tmp_buffer_ + tmp_buffer_pos_;
+  v8::base::Vector<char> buf = tmp_buffer_ + tmp_buffer_pos_;
   va_list args;
   va_start(args, format);
   int result = v8::internal::VSNPrintF(buf, format, args);
@@ -1762,7 +1762,7 @@ static const char* F0Mnem(byte f0byte) {
 }
 
 // Disassembled instruction '*instr' and writes it into 'out_buffer'.
-int DisassemblerIA32::InstructionDecode(v8::internal::Vector<char> out_buffer,
+int DisassemblerIA32::InstructionDecode(v8::base::Vector<char> out_buffer,
                                         byte* instr) {
   tmp_buffer_pos_ = 0;  // starting to write as position 0
   byte* data = instr;
@@ -2935,7 +2935,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   DisassemblerIA32 d(converter_, unimplemented_opcode_action());
   return d.InstructionDecode(buffer, instruction);
@@ -2950,7 +2950,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/diagnostics/mips/disasm-mips.cc b/src/diagnostics/mips/disasm-mips.cc
index 28207cef54..9aee24a1d4 100644
--- a/src/diagnostics/mips/disasm-mips.cc
+++ b/src/diagnostics/mips/disasm-mips.cc
@@ -11,7 +11,7 @@
 //   NameConverter converter;
 //   Disassembler d(converter);
 //   for (byte* pc = begin; pc < end;) {
-//     v8::internal::EmbeddedVector<char, 256> buffer;
+//     v8::base::EmbeddedVector<char, 256> buffer;
 //     byte* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
@@ -45,7 +45,7 @@ namespace internal {
 class Decoder {
  public:
   Decoder(const disasm::NameConverter& converter,
-          v8::internal::Vector<char> out_buffer)
+          v8::base::Vector<char> out_buffer)
       : converter_(converter), out_buffer_(out_buffer), out_buffer_pos_(0) {
     out_buffer_[out_buffer_pos_] = '\0';
   }
@@ -151,7 +151,7 @@ class Decoder {
   void DecodeTypeMsa2RF(Instruction* instr);
 
   const disasm::NameConverter& converter_;
-  v8::internal::Vector<char> out_buffer_;
+  v8::base::Vector<char> out_buffer_;
   int out_buffer_pos_;
 };
 
@@ -2709,7 +2709,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
@@ -2723,7 +2723,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/diagnostics/mips64/disasm-mips64.cc b/src/diagnostics/mips64/disasm-mips64.cc
index c116f55918..cc598e41bb 100644
--- a/src/diagnostics/mips64/disasm-mips64.cc
+++ b/src/diagnostics/mips64/disasm-mips64.cc
@@ -11,7 +11,7 @@
 //   NameConverter converter;
 //   Disassembler d(converter);
 //   for (byte* pc = begin; pc < end;) {
-//     v8::internal::EmbeddedVector<char, 256> buffer;
+//     v8::base::EmbeddedVector<char, 256> buffer;
 //     byte* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
@@ -45,7 +45,7 @@ namespace internal {
 class Decoder {
  public:
   Decoder(const disasm::NameConverter& converter,
-          v8::internal::Vector<char> out_buffer)
+          v8::base::Vector<char> out_buffer)
       : converter_(converter), out_buffer_(out_buffer), out_buffer_pos_(0) {
     out_buffer_[out_buffer_pos_] = '\0';
   }
@@ -163,7 +163,7 @@ class Decoder {
   void DecodeTypeMsa2RF(Instruction* instr);
 
   const disasm::NameConverter& converter_;
-  v8::internal::Vector<char> out_buffer_;
+  v8::base::Vector<char> out_buffer_;
   int out_buffer_pos_;
 };
 
@@ -3000,7 +3000,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
@@ -3014,7 +3014,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/diagnostics/objects-printer.cc b/src/diagnostics/objects-printer.cc
index c1c9a08890..9d94783df8 100644
--- a/src/diagnostics/objects-printer.cc
+++ b/src/diagnostics/objects-printer.cc
@@ -1319,7 +1319,7 @@ void JSDate::JSDatePrint(std::ostream& os) {
     os << "\n - time = NaN\n";
   } else {
     // TODO(svenpanne) Add some basic formatting to our streams.
-    ScopedVector<char> buf(100);
+    base::ScopedVector<char> buf(100);
     SNPrintF(buf, "\n - time = %s %04d/%02d/%02d %02d:%02d:%02d\n",
              weekdays[weekday().IsSmi() ? Smi::ToInt(weekday()) + 1 : 0],
              year().IsSmi() ? Smi::ToInt(year()) : -1,
@@ -2528,7 +2528,7 @@ void Name::NameShortPrint() {
 }
 
 // TODO(cbruni): remove once the new maptracer is in place.
-int Name::NameShortPrint(Vector<char> str) {
+int Name::NameShortPrint(base::Vector<char> str) {
   if (this->IsString()) {
     return SNPrintF(str, "%s", String::cast(*this).ToCString().get());
   } else {
diff --git a/src/diagnostics/perf-jit.cc b/src/diagnostics/perf-jit.cc
index e5cc93c1f6..ebffa5ee15 100644
--- a/src/diagnostics/perf-jit.cc
+++ b/src/diagnostics/perf-jit.cc
@@ -130,7 +130,7 @@ void PerfJitLogger::OpenJitDumpFile() {
   perf_output_handle_ = nullptr;
 
   int bufferSize = sizeof(kFilenameFormatString) + kFilenameBufferPadding;
-  ScopedVector<char> perf_dump_name(bufferSize);
+  base::ScopedVector<char> perf_dump_name(bufferSize);
   int size = SNPrintF(perf_dump_name, kFilenameFormatString,
                       base::OS::GetCurrentProcessId());
   CHECK_NE(size, -1);
@@ -308,9 +308,9 @@ size_t GetScriptNameLength(const SourcePositionInfo& info) {
   return kUnknownScriptNameStringLen;
 }
 
-Vector<const char> GetScriptName(const SourcePositionInfo& info,
-                                 std::unique_ptr<char[]>* storage,
-                                 const DisallowGarbageCollection& no_gc) {
+base::Vector<const char> GetScriptName(const SourcePositionInfo& info,
+                                       std::unique_ptr<char[]>* storage,
+                                       const DisallowGarbageCollection& no_gc) {
   if (!info.script.is_null()) {
     Object name_or_url = info.script->GetNameOrSourceURL();
     if (name_or_url.IsSeqOneByteString()) {
@@ -396,7 +396,8 @@ void PerfJitLogger::LogWriteDebugInfo(Handle<Code> code,
     // The extracted name may point into heap-objects, thus disallow GC.
     DisallowGarbageCollection no_gc;
     std::unique_ptr<char[]> name_storage;
-    Vector<const char> name_string = GetScriptName(info, &name_storage, no_gc);
+    base::Vector<const char> name_string =
+        GetScriptName(info, &name_storage, no_gc);
     LogWriteBytes(name_string.begin(),
                   static_cast<uint32_t>(name_string.size()));
     LogWriteBytes(kStringTerminator, 1);
diff --git a/src/diagnostics/ppc/disasm-ppc.cc b/src/diagnostics/ppc/disasm-ppc.cc
index 4578afd070..6df82c0485 100644
--- a/src/diagnostics/ppc/disasm-ppc.cc
+++ b/src/diagnostics/ppc/disasm-ppc.cc
@@ -11,7 +11,7 @@
 //   NameConverter converter;
 //   Disassembler d(converter);
 //   for (byte* pc = begin; pc < end;) {
-//     v8::internal::EmbeddedVector<char, 256> buffer;
+//     v8::base::EmbeddedVector<char, 256> buffer;
 //     byte* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
@@ -45,7 +45,7 @@ namespace internal {
 // more informative description.
 class Decoder {
  public:
-  Decoder(const disasm::NameConverter& converter, Vector<char> out_buffer)
+  Decoder(const disasm::NameConverter& converter, base::Vector<char> out_buffer)
       : converter_(converter), out_buffer_(out_buffer), out_buffer_pos_(0) {
     out_buffer_[out_buffer_pos_] = '\0';
   }
@@ -89,7 +89,7 @@ class Decoder {
   void DecodeExt6(Instruction* instr);
 
   const disasm::NameConverter& converter_;
-  Vector<char> out_buffer_;
+  base::Vector<char> out_buffer_;
   int out_buffer_pos_;
 };
 
@@ -1720,7 +1720,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
@@ -1734,7 +1734,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/diagnostics/riscv64/disasm-riscv64.cc b/src/diagnostics/riscv64/disasm-riscv64.cc
index 3bca14ed38..fa027fa71a 100644
--- a/src/diagnostics/riscv64/disasm-riscv64.cc
+++ b/src/diagnostics/riscv64/disasm-riscv64.cc
@@ -11,7 +11,7 @@
 //   NameConverter converter;
 //   Disassembler d(converter);
 //   for (byte* pc = begin; pc < end;) {
-//     v8::internal::EmbeddedVector<char, 256> buffer;
+//     v8::base::EmbeddedVector<char, 256> buffer;
 //     byte* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
@@ -45,7 +45,7 @@ namespace internal {
 class Decoder {
  public:
   Decoder(const disasm::NameConverter& converter,
-          v8::internal::Vector<char> out_buffer)
+          v8::base::Vector<char> out_buffer)
       : converter_(converter), out_buffer_(out_buffer), out_buffer_pos_(0) {
     out_buffer_[out_buffer_pos_] = '\0';
   }
@@ -136,7 +136,7 @@ class Decoder {
   void Unknown(Instruction* instr);
 
   const disasm::NameConverter& converter_;
-  v8::internal::Vector<char> out_buffer_;
+  v8::base::Vector<char> out_buffer_;
   int out_buffer_pos_;
 };
 
@@ -1888,7 +1888,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
@@ -1904,7 +1904,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/diagnostics/s390/disasm-s390.cc b/src/diagnostics/s390/disasm-s390.cc
index 15d86b94b3..8cf470b4bb 100644
--- a/src/diagnostics/s390/disasm-s390.cc
+++ b/src/diagnostics/s390/disasm-s390.cc
@@ -11,7 +11,7 @@
 //   NameConverter converter;
 //   Disassembler d(converter);
 //   for (byte* pc = begin; pc < end;) {
-//     v8::internal::EmbeddedVector<char, 256> buffer;
+//     v8::base::EmbeddedVector<char, 256> buffer;
 //     byte* prev_pc = pc;
 //     pc += d.InstructionDecode(buffer, pc);
 //     printf("%p    %08x      %s\n",
@@ -45,7 +45,7 @@ namespace internal {
 // more informative description.
 class Decoder {
  public:
-  Decoder(const disasm::NameConverter& converter, Vector<char> out_buffer)
+  Decoder(const disasm::NameConverter& converter, base::Vector<char> out_buffer)
       : converter_(converter), out_buffer_(out_buffer), out_buffer_pos_(0) {
     out_buffer_[out_buffer_pos_] = '\0';
   }
@@ -84,7 +84,7 @@ class Decoder {
   bool DecodeGeneric(Instruction* instr);
 
   const disasm::NameConverter& converter_;
-  Vector<char> out_buffer_;
+  base::Vector<char> out_buffer_;
   int out_buffer_pos_;
 };
 
@@ -1044,7 +1044,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   v8::internal::Decoder d(converter_, buffer);
   return d.InstructionDecode(instruction);
@@ -1058,7 +1058,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/diagnostics/x64/disasm-x64.cc b/src/diagnostics/x64/disasm-x64.cc
index f988741518..e15614f6f0 100644
--- a/src/diagnostics/x64/disasm-x64.cc
+++ b/src/diagnostics/x64/disasm-x64.cc
@@ -301,7 +301,7 @@ class DisassemblerX64 {
 
   // Writes one disassembled instruction into 'buffer' (0-terminated).
   // Returns the length of the disassembled machine instruction in bytes.
-  int InstructionDecode(v8::internal::Vector<char> buffer, byte* instruction);
+  int InstructionDecode(v8::base::Vector<char> buffer, byte* instruction);
 
  private:
   enum OperandSize {
@@ -312,7 +312,7 @@ class DisassemblerX64 {
   };
 
   const NameConverter& converter_;
-  v8::internal::EmbeddedVector<char, 128> tmp_buffer_;
+  v8::base::EmbeddedVector<char, 128> tmp_buffer_;
   unsigned int tmp_buffer_pos_;
   bool abort_on_unimplemented_;
   // Prefixes parsed
@@ -475,7 +475,7 @@ class DisassemblerX64 {
 };
 
 void DisassemblerX64::AppendToBuffer(const char* format, ...) {
-  v8::internal::Vector<char> buf = tmp_buffer_ + tmp_buffer_pos_;
+  v8::base::Vector<char> buf = tmp_buffer_ + tmp_buffer_pos_;
   va_list args;
   va_start(args, format);
   int result = v8::internal::VSNPrintF(buf, format, args);
@@ -2350,7 +2350,7 @@ const char* DisassemblerX64::TwoByteMnemonic(byte opcode) {
 }
 
 // Disassembles the instruction at instr, and writes it into out_buffer.
-int DisassemblerX64::InstructionDecode(v8::internal::Vector<char> out_buffer,
+int DisassemblerX64::InstructionDecode(v8::base::Vector<char> out_buffer,
                                        byte* instr) {
   tmp_buffer_pos_ = 0;  // starting to write as position 0
   byte* data = instr;
@@ -2853,7 +2853,7 @@ const char* NameConverter::NameInCode(byte* addr) const {
 
 //------------------------------------------------------------------------------
 
-int Disassembler::InstructionDecode(v8::internal::Vector<char> buffer,
+int Disassembler::InstructionDecode(v8::base::Vector<char> buffer,
                                     byte* instruction) {
   DisassemblerX64 d(converter_, unimplemented_opcode_action());
   return d.InstructionDecode(buffer, instruction);
@@ -2867,7 +2867,7 @@ void Disassembler::Disassemble(FILE* f, byte* begin, byte* end,
   NameConverter converter;
   Disassembler d(converter, unimplemented_action);
   for (byte* pc = begin; pc < end;) {
-    v8::internal::EmbeddedVector<char, 128> buffer;
+    v8::base::EmbeddedVector<char, 128> buffer;
     buffer[0] = '\0';
     byte* prev_pc = pc;
     pc += d.InstructionDecode(buffer, pc);
diff --git a/src/execution/arm/simulator-arm.cc b/src/execution/arm/simulator-arm.cc
index 247fed8d1a..ee1b5a40d8 100644
--- a/src/execution/arm/simulator-arm.cc
+++ b/src/execution/arm/simulator-arm.cc
@@ -19,6 +19,7 @@
 #include "src/base/overflowing-math.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/codegen/arm/constants-arm.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
@@ -29,7 +30,6 @@
 #include "src/runtime/runtime-utils.h"
 #include "src/utils/ostreams.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 
 // Only build the simulator if not compiling for real ARM hardware.
 namespace v8 {
@@ -201,7 +201,7 @@ void ArmDebugger::Debug() {
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
       // use a reasonably large buffer
-      v8::internal::EmbeddedVector<char, 256> buffer;
+      v8::base::EmbeddedVector<char, 256> buffer;
       dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
       PrintF("  0x%08x  %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
@@ -374,7 +374,7 @@ bool ArmDebugger::ExecDebugCommand(ArrayUniquePtr<char> line_ptr) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // use a reasonably large buffer
-    v8::internal::EmbeddedVector<char, 256> buffer;
+    v8::base::EmbeddedVector<char, 256> buffer;
 
     byte* prev = nullptr;
     byte* cur = nullptr;
@@ -6121,7 +6121,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // use a reasonably large buffer
-    v8::internal::EmbeddedVector<char, 256> buffer;
+    v8::base::EmbeddedVector<char, 256> buffer;
     dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
     PrintF("  0x%08" V8PRIxPTR "  %s\n", reinterpret_cast<intptr_t>(instr),
            buffer.begin());
diff --git a/src/execution/frames.cc b/src/execution/frames.cc
index 9c95b2b160..f8398af75c 100644
--- a/src/execution/frames.cc
+++ b/src/execution/frames.cc
@@ -1867,7 +1867,7 @@ void WasmFrame::Print(StringStream* accumulator, PrintMode mode,
                                   ->code_manager()
                                   ->LookupCode(pc())
                                   ->instruction_start();
-  Vector<const uint8_t> raw_func_name =
+  base::Vector<const uint8_t> raw_func_name =
       module_object().GetRawFunctionName(function_index());
   const int kMaxPrintedFunctionName = 64;
   char func_name[kMaxPrintedFunctionName + 1];
diff --git a/src/execution/messages.cc b/src/execution/messages.cc
index 71770f1ff4..dc12b0186d 100644
--- a/src/execution/messages.cc
+++ b/src/execution/messages.cc
@@ -341,7 +341,7 @@ MaybeHandle<Object> ErrorUtils::FormatStackTrace(Isolate* isolate,
                                    GetStackFrames(isolate, elems), Object);
 
         const int argc = 2;
-        ScopedVector<Handle<Object>> argv(argc);
+        base::ScopedVector<Handle<Object>> argv(argc);
         argv[0] = error;
         argv[1] = sites;
 
@@ -422,7 +422,7 @@ Handle<String> MessageFormatter::Format(Isolate* isolate, MessageTemplate index,
   if (!maybe_result_string.ToHandle(&result_string)) {
     DCHECK(isolate->has_pending_exception());
     isolate->clear_pending_exception();
-    return factory->InternalizeString(StaticCharVector("<error>"));
+    return factory->InternalizeString(base::StaticCharVector("<error>"));
   }
   // A string that has been obtained from JS code in this way is
   // likely to be a complicated ConsString of some sort.  We flatten it
diff --git a/src/execution/mips/simulator-mips.cc b/src/execution/mips/simulator-mips.cc
index c95f08b8d8..49ea63678c 100644
--- a/src/execution/mips/simulator-mips.cc
+++ b/src/execution/mips/simulator-mips.cc
@@ -17,6 +17,7 @@
 #include "src/base/lazy-instance.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/mips/constants-mips.h"
@@ -24,7 +25,6 @@
 #include "src/heap/combined-heap.h"
 #include "src/runtime/runtime-utils.h"
 #include "src/utils/ostreams.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -344,7 +344,7 @@ void MipsDebugger::Debug() {
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
       // Use a reasonably large buffer.
-      v8::internal::EmbeddedVector<char, 256> buffer;
+      v8::base::EmbeddedVector<char, 256> buffer;
       dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
       PrintF("  0x%08x  %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
@@ -536,7 +536,7 @@ void MipsDebugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // Use a reasonably large buffer.
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* cur = nullptr;
         byte* end = nullptr;
@@ -665,7 +665,7 @@ void MipsDebugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // Use a reasonably large buffer.
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* cur = nullptr;
         byte* end = nullptr;
@@ -6911,7 +6911,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
     CheckICache(i_cache(), instr);
   }
   pc_modified_ = false;
-  v8::internal::EmbeddedVector<char, 256> buffer;
+  v8::base::EmbeddedVector<char, 256> buffer;
   if (::v8::internal::FLAG_trace_sim) {
     SNPrintF(trace_buf_, "%s", "");
     disasm::NameConverter converter;
diff --git a/src/execution/mips/simulator-mips.h b/src/execution/mips/simulator-mips.h
index 16f9a1cead..2b36865609 100644
--- a/src/execution/mips/simulator-mips.h
+++ b/src/execution/mips/simulator-mips.h
@@ -404,7 +404,7 @@ class Simulator : public SimulatorBase {
   void TraceMemRd(int32_t addr, T value);
   template <typename T>
   void TraceMemWr(int32_t addr, T value);
-  EmbeddedVector<char, 128> trace_buf_;
+  base::EmbeddedVector<char, 128> trace_buf_;
 
   // Operations depending on endianness.
   // Get Double Higher / Lower word.
diff --git a/src/execution/mips64/simulator-mips64.cc b/src/execution/mips64/simulator-mips64.cc
index 2b4034dcd0..672d3012b2 100644
--- a/src/execution/mips64/simulator-mips64.cc
+++ b/src/execution/mips64/simulator-mips64.cc
@@ -16,6 +16,7 @@
 #include "src/base/bits.h"
 #include "src/base/platform/platform.h"
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/mips64/constants-mips64.h"
@@ -23,7 +24,6 @@
 #include "src/heap/combined-heap.h"
 #include "src/runtime/runtime-utils.h"
 #include "src/utils/ostreams.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -317,7 +317,7 @@ void MipsDebugger::Debug() {
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
       // Use a reasonably large buffer.
-      v8::internal::EmbeddedVector<char, 256> buffer;
+      v8::base::EmbeddedVector<char, 256> buffer;
       dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
       PrintF("  0x%016" PRIx64 "   %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
@@ -478,7 +478,7 @@ void MipsDebugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // Use a reasonably large buffer.
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* cur = nullptr;
         byte* end = nullptr;
@@ -607,7 +607,7 @@ void MipsDebugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // Use a reasonably large buffer.
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* cur = nullptr;
         byte* end = nullptr;
@@ -7316,7 +7316,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
   }
   pc_modified_ = false;
 
-  v8::internal::EmbeddedVector<char, 256> buffer;
+  v8::base::EmbeddedVector<char, 256> buffer;
 
   if (::v8::internal::FLAG_trace_sim) {
     SNPrintF(trace_buf_, " ");
diff --git a/src/execution/mips64/simulator-mips64.h b/src/execution/mips64/simulator-mips64.h
index bb1adb02d3..a5041c1669 100644
--- a/src/execution/mips64/simulator-mips64.h
+++ b/src/execution/mips64/simulator-mips64.h
@@ -618,7 +618,7 @@ class Simulator : public SimulatorBase {
   bool pc_modified_;
   int64_t icount_;
   int break_count_;
-  EmbeddedVector<char, 128> trace_buf_;
+  base::EmbeddedVector<char, 128> trace_buf_;
 
   // Debugger input.
   char* last_debugger_input_;
diff --git a/src/execution/ppc/simulator-ppc.cc b/src/execution/ppc/simulator-ppc.cc
index 52dcb1abbe..89c6565677 100644
--- a/src/execution/ppc/simulator-ppc.cc
+++ b/src/execution/ppc/simulator-ppc.cc
@@ -190,7 +190,7 @@ void PPCDebugger::Debug() {
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
       // use a reasonably large buffer
-      v8::internal::EmbeddedVector<char, 256> buffer;
+      v8::base::EmbeddedVector<char, 256> buffer;
       dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
       PrintF("  0x%08" V8PRIxPTR "  %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
@@ -230,7 +230,7 @@ void PPCDebugger::Debug() {
             disasm::NameConverter converter;
             disasm::Disassembler dasm(converter);
             // use a reasonably large buffer
-            v8::internal::EmbeddedVector<char, 256> buffer;
+            v8::base::EmbeddedVector<char, 256> buffer;
             dasm.InstructionDecode(buffer,
                                    reinterpret_cast<byte*>(sim_->get_pc()));
             PrintF("  0x%08" V8PRIxPTR "  %s\n", sim_->get_pc(),
@@ -411,7 +411,7 @@ void PPCDebugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // use a reasonably large buffer
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* prev = nullptr;
         byte* cur = nullptr;
@@ -5000,7 +5000,7 @@ void Simulator::Trace(Instruction* instr) {
   disasm::NameConverter converter;
   disasm::Disassembler dasm(converter);
   // use a reasonably large buffer
-  v8::internal::EmbeddedVector<char, 256> buffer;
+  v8::base::EmbeddedVector<char, 256> buffer;
   dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
   PrintF("%05d  %08" V8PRIxPTR "  %s\n", icount_,
          reinterpret_cast<intptr_t>(instr), buffer.begin());
diff --git a/src/execution/riscv64/simulator-riscv64.cc b/src/execution/riscv64/simulator-riscv64.cc
index aa87535913..64d7ea96bf 100644
--- a/src/execution/riscv64/simulator-riscv64.cc
+++ b/src/execution/riscv64/simulator-riscv64.cc
@@ -51,6 +51,7 @@
 #include <stdlib.h>
 
 #include "src/base/bits.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
 #include "src/codegen/riscv64/constants-riscv64.h"
@@ -58,7 +59,6 @@
 #include "src/heap/combined-heap.h"
 #include "src/runtime/runtime-utils.h"
 #include "src/utils/ostreams.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -181,7 +181,7 @@ bool RiscvDebugger::GetValue(const char* desc, int64_t* value) {
 
 void RiscvDebugger::PrintRegs(char name_prefix, int start_index,
                               int end_index) {
-  EmbeddedVector<char, 10> name1, name2;
+  base::EmbeddedVector<char, 10> name1, name2;
   DCHECK(name_prefix == 'a' || name_prefix == 't' || name_prefix == 's');
   DCHECK(start_index >= 0 && end_index <= 99);
   int num_registers = (end_index - start_index) + 1;
@@ -260,7 +260,7 @@ void RiscvDebugger::Debug() {
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
       // Use a reasonably large buffer.
-      v8::internal::EmbeddedVector<char, 256> buffer;
+      v8::base::EmbeddedVector<char, 256> buffer;
       const char* name = sim_->builtins_.Lookup((Address)sim_->get_pc());
       if (name != nullptr) {
         PrintF("Call builtin:  %s\n", name);
@@ -426,7 +426,7 @@ void RiscvDebugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // Use a reasonably large buffer.
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* cur = nullptr;
         byte* end = nullptr;
@@ -544,7 +544,7 @@ void RiscvDebugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // Use a reasonably large buffer.
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* cur = nullptr;
         byte* end = nullptr;
@@ -3385,7 +3385,7 @@ void Simulator::InstructionDecode(Instruction* instr) {
   }
   pc_modified_ = false;
 
-  v8::internal::EmbeddedVector<char, 256> buffer;
+  v8::base::EmbeddedVector<char, 256> buffer;
 
   if (::v8::internal::FLAG_trace_sim) {
     SNPrintF(trace_buf_, " ");
diff --git a/src/execution/riscv64/simulator-riscv64.h b/src/execution/riscv64/simulator-riscv64.h
index b263c4af4a..05e403e5e5 100644
--- a/src/execution/riscv64/simulator-riscv64.h
+++ b/src/execution/riscv64/simulator-riscv64.h
@@ -702,7 +702,7 @@ class Simulator : public SimulatorBase {
   bool pc_modified_;
   int64_t icount_;
   int break_count_;
-  EmbeddedVector<char, 128> trace_buf_;
+  base::EmbeddedVector<char, 128> trace_buf_;
 
   // Debugger input.
   char* last_debugger_input_;
diff --git a/src/execution/s390/simulator-s390.cc b/src/execution/s390/simulator-s390.cc
index d90d465985..88a8cb4121 100644
--- a/src/execution/s390/simulator-s390.cc
+++ b/src/execution/s390/simulator-s390.cc
@@ -197,7 +197,7 @@ void S390Debugger::Debug() {
       disasm::NameConverter converter;
       disasm::Disassembler dasm(converter);
       // use a reasonably large buffer
-      v8::internal::EmbeddedVector<char, 256> buffer;
+      v8::base::EmbeddedVector<char, 256> buffer;
       dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(sim_->get_pc()));
       PrintF("  0x%08" V8PRIxPTR "  %s\n", sim_->get_pc(), buffer.begin());
       last_pc = sim_->get_pc();
@@ -236,7 +236,7 @@ void S390Debugger::Debug() {
           disasm::NameConverter converter;
           disasm::Disassembler dasm(converter);
           // use a reasonably large buffer
-          v8::internal::EmbeddedVector<char, 256> buffer;
+          v8::base::EmbeddedVector<char, 256> buffer;
 
           if (GetValue(arg1, &value)) {
             // Interpret a numeric argument as the number of instructions to
@@ -437,7 +437,7 @@ void S390Debugger::Debug() {
         disasm::NameConverter converter;
         disasm::Disassembler dasm(converter);
         // use a reasonably large buffer
-        v8::internal::EmbeddedVector<char, 256> buffer;
+        v8::base::EmbeddedVector<char, 256> buffer;
 
         byte* prev = nullptr;
         byte* cur = nullptr;
@@ -2426,7 +2426,7 @@ void Simulator::ExecuteInstruction(Instruction* instr, bool auto_incr_pc) {
     disasm::NameConverter converter;
     disasm::Disassembler dasm(converter);
     // use a reasonably large buffer
-    v8::internal::EmbeddedVector<char, 256> buffer;
+    v8::base::EmbeddedVector<char, 256> buffer;
     dasm.InstructionDecode(buffer, reinterpret_cast<byte*>(instr));
     PrintF("%05" PRId64 "  %08" V8PRIxPTR "  %s\n", icount_,
            reinterpret_cast<intptr_t>(instr), buffer.begin());
diff --git a/src/extensions/cputracemark-extension.h b/src/extensions/cputracemark-extension.h
index 9110cfe01b..184199f149 100644
--- a/src/extensions/cputracemark-extension.h
+++ b/src/extensions/cputracemark-extension.h
@@ -24,8 +24,8 @@ class CpuTraceMarkExtension : public v8::Extension {
   static void Mark(const v8::FunctionCallbackInfo<v8::Value>& args);
 
   static const char* BuildSource(char* buf, size_t size, const char* fun_name) {
-    SNPrintF(Vector<char>(buf, static_cast<int>(size)), "native function %s();",
-             fun_name);
+    SNPrintF(base::Vector<char>(buf, static_cast<int>(size)),
+             "native function %s();", fun_name);
     return buf;
   }
 
diff --git a/src/extensions/gc-extension.h b/src/extensions/gc-extension.h
index 061bb725a3..29bd45b212 100644
--- a/src/extensions/gc-extension.h
+++ b/src/extensions/gc-extension.h
@@ -37,7 +37,7 @@ class GCExtension : public v8::Extension {
 
  private:
   static const char* BuildSource(char* buf, size_t size, const char* fun_name) {
-    SNPrintF(Vector<char>(buf, static_cast<int>(size)),
+    SNPrintF(base::Vector<char>(buf, static_cast<int>(size)),
              "native function %s();", fun_name);
     return buf;
   }
diff --git a/src/extensions/vtunedomain-support-extension.h b/src/extensions/vtunedomain-support-extension.h
index 394cc3fb21..a695ba66d7 100644
--- a/src/extensions/vtunedomain-support-extension.h
+++ b/src/extensions/vtunedomain-support-extension.h
@@ -33,8 +33,8 @@ class VTuneDomainSupportExtension : public v8::Extension {
   static void Mark(const v8::FunctionCallbackInfo<v8::Value>& args);
 
   static const char* BuildSource(char* buf, size_t size, const char* fun_name) {
-    SNPrintF(Vector<char>(buf, static_cast<int>(size)), "native function %s();",
-             fun_name);
+    SNPrintF(base::Vector<char>(buf, static_cast<int>(size)),
+             "native function %s();", fun_name);
     return buf;
   }
 
diff --git a/src/flags/flags.cc b/src/flags/flags.cc
index 2cd9174148..6fc74e31e0 100644
--- a/src/flags/flags.cc
+++ b/src/flags/flags.cc
@@ -730,7 +730,7 @@ int FlagList::SetFlagsFromString(const char* str, size_t len) {
   }
 
   // allocate argument array
-  ScopedVector<char*> argv(argc);
+  base::ScopedVector<char*> argv(argc);
 
   // split the flags string into arguments
   argc = 1;  // be compatible with SetFlagsFromCommandLine()
diff --git a/src/heap/factory-base.cc b/src/heap/factory-base.cc
index 611a11c819..6c1db3e0e7 100644
--- a/src/heap/factory-base.cc
+++ b/src/heap/factory-base.cc
@@ -468,10 +468,10 @@ Handle<String> FactoryBase<Impl>::MakeOrFindTwoCharacterString(uint16_t c1,
                                                                uint16_t c2) {
   if ((c1 | c2) <= unibrow::Latin1::kMaxChar) {
     uint8_t buffer[] = {static_cast<uint8_t>(c1), static_cast<uint8_t>(c2)};
-    return InternalizeString(Vector<const uint8_t>(buffer, 2));
+    return InternalizeString(base::Vector<const uint8_t>(buffer, 2));
   }
   uint16_t buffer[] = {c1, c2};
-  return InternalizeString(Vector<const uint16_t>(buffer, 2));
+  return InternalizeString(base::Vector<const uint16_t>(buffer, 2));
 }
 
 template <typename Impl>
@@ -503,7 +503,7 @@ template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
 
 template <typename Impl>
 Handle<String> FactoryBase<Impl>::InternalizeString(
-    const Vector<const uint8_t>& string, bool convert_encoding) {
+    const base::Vector<const uint8_t>& string, bool convert_encoding) {
   SequentialStringKey<uint8_t> key(string, HashSeed(read_only_roots()),
                                    convert_encoding);
   return InternalizeStringWithKey(&key);
@@ -511,7 +511,7 @@ Handle<String> FactoryBase<Impl>::InternalizeString(
 
 template <typename Impl>
 Handle<String> FactoryBase<Impl>::InternalizeString(
-    const Vector<const uint16_t>& string, bool convert_encoding) {
+    const base::Vector<const uint16_t>& string, bool convert_encoding) {
   SequentialStringKey<uint16_t> key(string, HashSeed(read_only_roots()),
                                     convert_encoding);
   return InternalizeStringWithKey(&key);
@@ -519,7 +519,7 @@ Handle<String> FactoryBase<Impl>::InternalizeString(
 
 template <typename Impl>
 Handle<SeqOneByteString> FactoryBase<Impl>::NewOneByteInternalizedString(
-    const Vector<const uint8_t>& str, uint32_t raw_hash_field) {
+    const base::Vector<const uint8_t>& str, uint32_t raw_hash_field) {
   Handle<SeqOneByteString> result =
       AllocateRawOneByteInternalizedString(str.length(), raw_hash_field);
   DisallowGarbageCollection no_gc;
@@ -530,7 +530,7 @@ Handle<SeqOneByteString> FactoryBase<Impl>::NewOneByteInternalizedString(
 
 template <typename Impl>
 Handle<SeqTwoByteString> FactoryBase<Impl>::NewTwoByteInternalizedString(
-    const Vector<const uc16>& str, uint32_t raw_hash_field) {
+    const base::Vector<const uc16>& str, uint32_t raw_hash_field) {
   Handle<SeqTwoByteString> result =
       AllocateRawTwoByteInternalizedString(str.length(), raw_hash_field);
   DisallowGarbageCollection no_gc;
diff --git a/src/heap/factory-base.h b/src/heap/factory-base.h
index 1b05335675..ecb73271d9 100644
--- a/src/heap/factory-base.h
+++ b/src/heap/factory-base.h
@@ -171,18 +171,18 @@ class EXPORT_TEMPLATE_DECLARE(V8_EXPORT_PRIVATE) FactoryBase
 
   Handle<CoverageInfo> NewCoverageInfo(const ZoneVector<SourceRange>& slots);
 
-  Handle<String> InternalizeString(const Vector<const uint8_t>& string,
+  Handle<String> InternalizeString(const base::Vector<const uint8_t>& string,
                                    bool convert_encoding = false);
-  Handle<String> InternalizeString(const Vector<const uint16_t>& string,
+  Handle<String> InternalizeString(const base::Vector<const uint16_t>& string,
                                    bool convert_encoding = false);
 
   template <class StringTableKey>
   Handle<String> InternalizeStringWithKey(StringTableKey* key);
 
   Handle<SeqOneByteString> NewOneByteInternalizedString(
-      const Vector<const uint8_t>& str, uint32_t raw_hash_field);
+      const base::Vector<const uint8_t>& str, uint32_t raw_hash_field);
   Handle<SeqTwoByteString> NewTwoByteInternalizedString(
-      const Vector<const uc16>& str, uint32_t raw_hash_field);
+      const base::Vector<const uc16>& str, uint32_t raw_hash_field);
 
   Handle<SeqOneByteString> AllocateRawOneByteInternalizedString(
       int length, uint32_t raw_hash_field);
diff --git a/src/heap/factory.cc b/src/heap/factory.cc
index 924ad6bd88..fe798d3c40 100644
--- a/src/heap/factory.cc
+++ b/src/heap/factory.cc
@@ -589,20 +589,21 @@ Handle<SwissNameDictionary> Factory::CreateCanonicalEmptySwissNameDictionary() {
 
 // Internalized strings are created in the old generation (data space).
 Handle<String> Factory::InternalizeUtf8String(
-    const Vector<const char>& string) {
-  Vector<const uint8_t> utf8_data = Vector<const uint8_t>::cast(string);
+    const base::Vector<const char>& string) {
+  base::Vector<const uint8_t> utf8_data =
+      base::Vector<const uint8_t>::cast(string);
   Utf8Decoder decoder(utf8_data);
   if (decoder.is_ascii()) return InternalizeString(utf8_data);
   if (decoder.is_one_byte()) {
     std::unique_ptr<uint8_t[]> buffer(new uint8_t[decoder.utf16_length()]);
     decoder.Decode(buffer.get(), utf8_data);
     return InternalizeString(
-        Vector<const uint8_t>(buffer.get(), decoder.utf16_length()));
+        base::Vector<const uint8_t>(buffer.get(), decoder.utf16_length()));
   }
   std::unique_ptr<uint16_t[]> buffer(new uint16_t[decoder.utf16_length()]);
   decoder.Decode(buffer.get(), utf8_data);
   return InternalizeString(
-      Vector<const uc16>(buffer.get(), decoder.utf16_length()));
+      base::Vector<const uc16>(buffer.get(), decoder.utf16_length()));
 }
 
 template <typename SeqString>
@@ -621,7 +622,7 @@ template Handle<String> Factory::InternalizeString(
     bool convert_encoding);
 
 MaybeHandle<String> Factory::NewStringFromOneByte(
-    const Vector<const uint8_t>& string, AllocationType allocation) {
+    const base::Vector<const uint8_t>& string, AllocationType allocation) {
   DCHECK_NE(allocation, AllocationType::kReadOnly);
   int length = string.length();
   if (length == 0) return empty_string();
@@ -638,9 +639,10 @@ MaybeHandle<String> Factory::NewStringFromOneByte(
   return result;
 }
 
-MaybeHandle<String> Factory::NewStringFromUtf8(const Vector<const char>& string,
-                                               AllocationType allocation) {
-  Vector<const uint8_t> utf8_data = Vector<const uint8_t>::cast(string);
+MaybeHandle<String> Factory::NewStringFromUtf8(
+    const base::Vector<const char>& string, AllocationType allocation) {
+  base::Vector<const uint8_t> utf8_data =
+      base::Vector<const uint8_t>::cast(string);
   Utf8Decoder decoder(utf8_data);
 
   if (decoder.utf16_length() == 0) return empty_string();
@@ -671,10 +673,11 @@ MaybeHandle<String> Factory::NewStringFromUtf8(const Vector<const char>& string,
 MaybeHandle<String> Factory::NewStringFromUtf8SubString(
     Handle<SeqOneByteString> str, int begin, int length,
     AllocationType allocation) {
-  Vector<const uint8_t> utf8_data;
+  base::Vector<const uint8_t> utf8_data;
   {
     DisallowGarbageCollection no_gc;
-    utf8_data = Vector<const uint8_t>(str->GetChars(no_gc) + begin, length);
+    utf8_data =
+        base::Vector<const uint8_t>(str->GetChars(no_gc) + begin, length);
   }
   Utf8Decoder decoder(utf8_data);
 
@@ -702,7 +705,8 @@ MaybeHandle<String> Factory::NewStringFromUtf8SubString(
     DisallowGarbageCollection no_gc;
     // Update pointer references, since the original string may have moved after
     // allocation.
-    utf8_data = Vector<const uint8_t>(str->GetChars(no_gc) + begin, length);
+    utf8_data =
+        base::Vector<const uint8_t>(str->GetChars(no_gc) + begin, length);
     decoder.Decode(result->GetChars(no_gc), utf8_data);
     return result;
   }
@@ -716,7 +720,7 @@ MaybeHandle<String> Factory::NewStringFromUtf8SubString(
   DisallowGarbageCollection no_gc;
   // Update pointer references, since the original string may have moved after
   // allocation.
-  utf8_data = Vector<const uint8_t>(str->GetChars(no_gc) + begin, length);
+  utf8_data = base::Vector<const uint8_t>(str->GetChars(no_gc) + begin, length);
   decoder.Decode(result->GetChars(no_gc), utf8_data);
   return result;
 }
@@ -745,7 +749,7 @@ MaybeHandle<String> Factory::NewStringFromTwoByte(const uc16* string,
 }
 
 MaybeHandle<String> Factory::NewStringFromTwoByte(
-    const Vector<const uc16>& string, AllocationType allocation) {
+    const base::Vector<const uc16>& string, AllocationType allocation) {
   return NewStringFromTwoByte(string.begin(), string.length(), allocation);
 }
 
@@ -871,12 +875,13 @@ Handle<String> Factory::LookupSingleCharacterStringFromCode(uint16_t code) {
       }
     }
     uint8_t buffer[] = {static_cast<uint8_t>(code)};
-    Handle<String> result = InternalizeString(Vector<const uint8_t>(buffer, 1));
+    Handle<String> result =
+        InternalizeString(base::Vector<const uint8_t>(buffer, 1));
     single_character_string_cache()->set(code, *result);
     return result;
   }
   uint16_t buffer[] = {code};
-  return InternalizeString(Vector<const uint16_t>(buffer, 1));
+  return InternalizeString(base::Vector<const uint16_t>(buffer, 1));
 }
 
 Handle<String> Factory::NewSurrogatePairString(uint16_t lead, uint16_t trail) {
@@ -2808,7 +2813,7 @@ Handle<JSDataView> Factory::NewJSDataView(Handle<JSArrayBuffer> buffer,
 
 MaybeHandle<JSBoundFunction> Factory::NewJSBoundFunction(
     Handle<JSReceiver> target_function, Handle<Object> bound_this,
-    Vector<Handle<Object>> bound_args) {
+    base::Vector<Handle<Object>> bound_args) {
   DCHECK(target_function->IsCallable());
   STATIC_ASSERT(Code::kMaxArguments <= FixedArray::kMaxLength);
   if (bound_args.length() >= Code::kMaxArguments) {
@@ -3070,7 +3075,7 @@ Handle<String> Factory::HeapNumberToString(Handle<HeapNumber> number,
   }
 
   char arr[kNumberToStringBufferSize];
-  Vector<char> buffer(arr, arraysize(arr));
+  base::Vector<char> buffer(arr, arraysize(arr));
   const char* string = DoubleToCString(value, buffer);
   Handle<String> result = CharToString(this, string, mode);
   if (mode != NumberCacheMode::kIgnore) {
@@ -3087,7 +3092,7 @@ inline Handle<String> Factory::SmiToString(Smi number, NumberCacheMode mode) {
   }
 
   char arr[kNumberToStringBufferSize];
-  Vector<char> buffer(arr, arraysize(arr));
+  base::Vector<char> buffer(arr, arraysize(arr));
   const char* string = IntToCString(number.value(), buffer);
   Handle<String> result = CharToString(this, string, mode);
   if (mode != NumberCacheMode::kIgnore) {
@@ -3124,7 +3129,7 @@ Handle<String> Factory::SizeToString(size_t value, bool check_cache) {
     result = HeapNumberToString(NewHeapNumber(double_value), value, cache_mode);
   } else {
     char arr[kNumberToStringBufferSize];
-    Vector<char> buffer(arr, arraysize(arr));
+    base::Vector<char> buffer(arr, arraysize(arr));
     // Build the string backwards from the least significant digit.
     int i = buffer.length();
     size_t value_copy = value;
diff --git a/src/heap/factory.h b/src/heap/factory.h
index 4c9896e66e..1f3c5bbaaa 100644
--- a/src/heap/factory.h
+++ b/src/heap/factory.h
@@ -7,6 +7,7 @@
 
 // Clients of this interface shouldn't depend on lots of heap internals.
 // Do not include anything from src/heap here!
+#include "src/base/vector.h"
 #include "src/baseline/baseline.h"
 #include "src/builtins/builtins.h"
 #include "src/common/globals.h"
@@ -193,17 +194,17 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
 
   // Finds the internalized copy for string in the string table.
   // If not found, a new string is added to the table and returned.
-  Handle<String> InternalizeUtf8String(const Vector<const char>& str);
+  Handle<String> InternalizeUtf8String(const base::Vector<const char>& str);
   Handle<String> InternalizeUtf8String(const char* str) {
-    return InternalizeUtf8String(CStrVector(str));
+    return InternalizeUtf8String(base::CStrVector(str));
   }
 
   // Import InternalizeString overloads from base class.
   using FactoryBase::InternalizeString;
 
-  Handle<String> InternalizeString(Vector<const char> str,
+  Handle<String> InternalizeString(base::Vector<const char> str,
                                    bool convert_encoding = false) {
-    return InternalizeString(Vector<const uint8_t>::cast(str));
+    return InternalizeString(base::Vector<const uint8_t>::cast(str));
   }
 
   template <typename SeqString>
@@ -236,7 +237,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
   //
   // One-byte strings are pretenured when used as keys in the SourceCodeCache.
   V8_WARN_UNUSED_RESULT MaybeHandle<String> NewStringFromOneByte(
-      const Vector<const uint8_t>& str,
+      const base::Vector<const uint8_t>& str,
       AllocationType allocation = AllocationType::kYoung);
 
   template <size_t N>
@@ -244,20 +245,20 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
       const char (&str)[N],
       AllocationType allocation = AllocationType::kYoung) {
     DCHECK_EQ(N, strlen(str) + 1);
-    return NewStringFromOneByte(StaticOneByteVector(str), allocation)
+    return NewStringFromOneByte(base::StaticOneByteVector(str), allocation)
         .ToHandleChecked();
   }
 
   inline Handle<String> NewStringFromAsciiChecked(
       const char* str, AllocationType allocation = AllocationType::kYoung) {
-    return NewStringFromOneByte(OneByteVector(str), allocation)
+    return NewStringFromOneByte(base::OneByteVector(str), allocation)
         .ToHandleChecked();
   }
 
   // UTF8 strings are pretenured when used for regexp literal patterns and
   // flags in the parser.
   V8_WARN_UNUSED_RESULT MaybeHandle<String> NewStringFromUtf8(
-      const Vector<const char>& str,
+      const base::Vector<const char>& str,
       AllocationType allocation = AllocationType::kYoung);
 
   V8_WARN_UNUSED_RESULT MaybeHandle<String> NewStringFromUtf8SubString(
@@ -265,7 +266,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
       AllocationType allocation = AllocationType::kYoung);
 
   V8_WARN_UNUSED_RESULT MaybeHandle<String> NewStringFromTwoByte(
-      const Vector<const uc16>& str,
+      const base::Vector<const uc16>& str,
       AllocationType allocation = AllocationType::kYoung);
 
   V8_WARN_UNUSED_RESULT MaybeHandle<String> NewStringFromTwoByte(
@@ -629,7 +630,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
   // Allocates a bound function.
   MaybeHandle<JSBoundFunction> NewJSBoundFunction(
       Handle<JSReceiver> target_function, Handle<Object> bound_this,
-      Vector<Handle<Object>> bound_args);
+      base::Vector<Handle<Object>> bound_args);
 
   // Allocates a Harmony proxy.
   Handle<JSProxy> NewJSProxy(Handle<JSReceiver> target,
@@ -1002,7 +1003,7 @@ class V8_EXPORT_PRIVATE Factory : public FactoryBase<Factory> {
                                                 uint32_t hash_field);
 
   Handle<String> AllocateTwoByteInternalizedString(
-      const Vector<const uc16>& str, uint32_t hash_field);
+      const base::Vector<const uc16>& str, uint32_t hash_field);
 
   MaybeHandle<String> NewStringFromTwoByte(const uc16* string, int length,
                                            AllocationType allocation);
diff --git a/src/heap/gc-tracer.cc b/src/heap/gc-tracer.cc
index e30d7de648..631d983bf7 100644
--- a/src/heap/gc-tracer.cc
+++ b/src/heap/gc-tracer.cc
@@ -532,7 +532,7 @@ void GCTracer::Output(const char* format, ...) const {
 
   const int kBufferSize = 256;
   char raw_buffer[kBufferSize];
-  Vector<char> buffer(raw_buffer, kBufferSize);
+  base::Vector<char> buffer(raw_buffer, kBufferSize);
   va_list arguments2;
   va_start(arguments2, format);
   VSNPrintF(buffer, format, arguments2);
diff --git a/src/heap/object-stats.cc b/src/heap/object-stats.cc
index 977725401d..512f5db7b8 100644
--- a/src/heap/object-stats.cc
+++ b/src/heap/object-stats.cc
@@ -185,7 +185,7 @@ V8_NOINLINE static void PrintJSONArray(size_t* array, const int len) {
 
 V8_NOINLINE static void DumpJSONArray(std::stringstream& stream, size_t* array,
                                       const int len) {
-  stream << PrintCollection(Vector<size_t>(array, len));
+  stream << PrintCollection(base::Vector<size_t>(array, len));
 }
 
 void ObjectStats::PrintKeyAndId(const char* key, int gc_count) {
diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc
index f575398880..c45c41784a 100644
--- a/src/init/bootstrapper.cc
+++ b/src/init/bootstrapper.cc
@@ -82,7 +82,7 @@ void SourceCodeCache::Iterate(RootVisitor* v) {
   v->VisitRootPointer(Root::kExtensions, nullptr, FullObjectSlot(&cache_));
 }
 
-bool SourceCodeCache::Lookup(Isolate* isolate, Vector<const char> name,
+bool SourceCodeCache::Lookup(Isolate* isolate, base::Vector<const char> name,
                              Handle<SharedFunctionInfo>* handle) {
   for (int i = 0; i < cache_.length(); i += 2) {
     SeqOneByteString str = SeqOneByteString::cast(cache_.get(i));
@@ -95,7 +95,7 @@ bool SourceCodeCache::Lookup(Isolate* isolate, Vector<const char> name,
   return false;
 }
 
-void SourceCodeCache::Add(Isolate* isolate, Vector<const char> name,
+void SourceCodeCache::Add(Isolate* isolate, base::Vector<const char> name,
                           Handle<SharedFunctionInfo> shared) {
   Factory* factory = isolate->factory();
   HandleScope scope(isolate);
@@ -106,7 +106,7 @@ void SourceCodeCache::Add(Isolate* isolate, Vector<const char> name,
   cache_ = *new_array;
   Handle<String> str =
       factory
-          ->NewStringFromOneByte(Vector<const uint8_t>::cast(name),
+          ->NewStringFromOneByte(base::Vector<const uint8_t>::cast(name),
                                  AllocationType::kOld)
           .ToHandleChecked();
   DCHECK(!str.is_null());
@@ -4143,7 +4143,7 @@ bool Genesis::CompileExtension(Isolate* isolate, v8::Extension* extension) {
 
   // If we can't find the function in the cache, we compile a new
   // function and insert it into the cache.
-  Vector<const char> name = CStrVector(extension->name());
+  base::Vector<const char> name = base::CStrVector(extension->name());
   SourceCodeCache* cache = isolate->bootstrapper()->extensions_cache();
   Handle<Context> context(isolate->context(), isolate);
   DCHECK(context->IsNativeContext());
diff --git a/src/init/bootstrapper.h b/src/init/bootstrapper.h
index 7ce83d0ea6..19f028048e 100644
--- a/src/init/bootstrapper.h
+++ b/src/init/bootstrapper.h
@@ -26,10 +26,10 @@ class SourceCodeCache final {
 
   void Iterate(RootVisitor* v);
 
-  bool Lookup(Isolate* isolate, Vector<const char> name,
+  bool Lookup(Isolate* isolate, base::Vector<const char> name,
               Handle<SharedFunctionInfo>* handle);
 
-  void Add(Isolate* isolate, Vector<const char> name,
+  void Add(Isolate* isolate, base::Vector<const char> name,
            Handle<SharedFunctionInfo> shared);
 
  private:
diff --git a/src/inspector/DEPS b/src/inspector/DEPS
index 55d8e7a51e..1c3ef43314 100644
--- a/src/inspector/DEPS
+++ b/src/inspector/DEPS
@@ -19,7 +19,7 @@ include_rules = [
   "+src/tracing",
   "+src/debug/debug-interface.h",
   "+src/debug/interface-types.h",
-  "+src/utils/vector.h",
+  "+src/base/vector.h",
   "+third_party/inspector_protocol/crdtp",
   "+../../third_party/inspector_protocol/crdtp",
 ]
diff --git a/src/inspector/string-16.cc b/src/inspector/string-16.cc
index 466852fa36..00d9987206 100644
--- a/src/inspector/string-16.cc
+++ b/src/inspector/string-16.cc
@@ -68,8 +68,8 @@ String16::String16(std::basic_string<UChar>&& impl) : m_impl(impl) {}
 // static
 String16 String16::fromInteger(int number) {
   char arr[50];
-  v8::internal::Vector<char> buffer(arr, arraysize(arr));
-  return String16(IntToCString(number, buffer));
+  v8::base::Vector<char> buffer(arr, arraysize(arr));
+  return String16(v8::internal::IntToCString(number, buffer));
 }
 
 // static
@@ -94,8 +94,8 @@ String16 String16::fromInteger64(int64_t number) {
 // static
 String16 String16::fromDouble(double number) {
   char arr[50];
-  v8::internal::Vector<char> buffer(arr, arraysize(arr));
-  return String16(DoubleToCString(number, buffer));
+  v8::base::Vector<char> buffer(arr, arraysize(arr));
+  return String16(v8::internal::DoubleToCString(number, buffer));
 }
 
 // static
diff --git a/src/interpreter/interpreter.cc b/src/interpreter/interpreter.cc
index c5fe97650f..a874954157 100644
--- a/src/interpreter/interpreter.cc
+++ b/src/interpreter/interpreter.cc
@@ -158,7 +158,8 @@ bool ShouldPrintBytecode(Handle<SharedFunctionInfo> shared) {
 
   // Checks whether function passed the filter.
   if (shared->is_toplevel()) {
-    Vector<const char> filter = CStrVector(FLAG_print_bytecode_filter);
+    base::Vector<const char> filter =
+        base::CStrVector(FLAG_print_bytecode_filter);
     return (filter.length() == 0) || (filter.length() == 1 && filter[0] == '*');
   } else {
     return shared->PassesFilter(FLAG_print_bytecode_filter);
diff --git a/src/json/json-parser.cc b/src/json/json-parser.cc
index 8d82d10e2c..7fc43405a7 100644
--- a/src/json/json-parser.cc
+++ b/src/json/json-parser.cc
@@ -960,7 +960,7 @@ Handle<Object> JsonParser<Char>::ParseJsonNumber() {
       AdvanceToNonDecimal();
     }
 
-    Vector<const Char> chars(start, cursor_ - start);
+    base::Vector<const Char> chars(start, cursor_ - start);
     number = StringToDouble(chars,
                             NO_FLAGS,  // Hex, octal or trailing junk.
                             std::numeric_limits<double>::quiet_NaN());
@@ -974,7 +974,7 @@ Handle<Object> JsonParser<Char>::ParseJsonNumber() {
 namespace {
 
 template <typename Char>
-bool Matches(const Vector<const Char>& chars, Handle<String> string) {
+bool Matches(const base::Vector<const Char>& chars, Handle<String> string) {
   DCHECK(!string.is_null());
   return string->IsEqualTo(chars);
 }
@@ -999,7 +999,7 @@ Handle<String> JsonParser<Char>::DecodeString(
 
     if (!string.internalize()) return intermediate;
 
-    Vector<const SinkChar> data(dest, string.length());
+    base::Vector<const SinkChar> data(dest, string.length());
     if (!hint.is_null() && Matches(data, hint)) return hint;
   }
 
@@ -1013,7 +1013,7 @@ Handle<String> JsonParser<Char>::MakeString(const JsonString& string,
 
   if (string.internalize() && !string.has_escape()) {
     if (!hint.is_null()) {
-      Vector<const Char> data(chars_ + string.start(), string.length());
+      base::Vector<const Char> data(chars_ + string.start(), string.length());
       if (Matches(data, hint)) return hint;
     }
     if (chars_may_relocate_) {
@@ -1021,7 +1021,7 @@ Handle<String> JsonParser<Char>::MakeString(const JsonString& string,
                                           string.start(), string.length(),
                                           string.needs_conversion());
     }
-    Vector<const Char> chars(chars_ + string.start(), string.length());
+    base::Vector<const Char> chars(chars_ + string.start(), string.length());
     return factory()->InternalizeString(chars, string.needs_conversion());
   }
 
diff --git a/src/json/json-stringifier.cc b/src/json/json-stringifier.cc
index f5391fc882..50f12a920d 100644
--- a/src/json/json-stringifier.cc
+++ b/src/json/json-stringifier.cc
@@ -91,7 +91,7 @@ class JsonStringifier {
 
   template <typename SrcChar, typename DestChar>
   V8_INLINE static void SerializeStringUnchecked_(
-      Vector<const SrcChar> src,
+      base::Vector<const SrcChar> src,
       IncrementalStringBuilder::NoExtend<DestChar>* dest);
 
   template <typename SrcChar, typename DestChar>
@@ -462,7 +462,7 @@ class CircularStructureMessageBuilder {
   void AppendSmi(Smi smi) {
     static const int kBufferSize = 100;
     char chars[kBufferSize];
-    Vector<char> buffer(chars, kBufferSize);
+    base::Vector<char> buffer(chars, kBufferSize);
     builder_.AppendCString(IntToCString(smi.value(), buffer));
   }
 
@@ -620,7 +620,7 @@ JsonStringifier::Result JsonStringifier::SerializeJSPrimitiveWrapper(
 JsonStringifier::Result JsonStringifier::SerializeSmi(Smi object) {
   static const int kBufferSize = 100;
   char chars[kBufferSize];
-  Vector<char> buffer(chars, kBufferSize);
+  base::Vector<char> buffer(chars, kBufferSize);
   builder_.AppendCString(IntToCString(object.value(), buffer));
   return SUCCESS;
 }
@@ -632,7 +632,7 @@ JsonStringifier::Result JsonStringifier::SerializeDouble(double number) {
   }
   static const int kBufferSize = 100;
   char chars[kBufferSize];
-  Vector<char> buffer(chars, kBufferSize);
+  base::Vector<char> buffer(chars, kBufferSize);
   builder_.AppendCString(DoubleToCString(number, buffer));
   return SUCCESS;
 }
@@ -875,7 +875,7 @@ JsonStringifier::Result JsonStringifier::SerializeJSProxy(
 
 template <typename SrcChar, typename DestChar>
 void JsonStringifier::SerializeStringUnchecked_(
-    Vector<const SrcChar> src,
+    base::Vector<const SrcChar> src,
     IncrementalStringBuilder::NoExtend<DestChar>* dest) {
   // Assert that uc16 character is not truncated down to 8 bit.
   // The <uc16, char> version of this method must not be called.
@@ -937,7 +937,7 @@ void JsonStringifier::SerializeString_(Handle<String> string) {
   // part, or we might need to allocate.
   if (int worst_case_length = builder_.EscapedLengthIfCurrentPartFits(length)) {
     DisallowGarbageCollection no_gc;
-    Vector<const SrcChar> vector = string->GetCharVector<SrcChar>(no_gc);
+    base::Vector<const SrcChar> vector = string->GetCharVector<SrcChar>(no_gc);
     IncrementalStringBuilder::NoExtendBuilder<DestChar> no_extend(
         &builder_, worst_case_length, no_gc);
     SerializeStringUnchecked_(vector, &no_extend);
diff --git a/src/logging/code-events.h b/src/logging/code-events.h
index cda7c39fc7..59c7952bd6 100644
--- a/src/logging/code-events.h
+++ b/src/logging/code-events.h
@@ -8,12 +8,12 @@
 #include <unordered_set>
 
 #include "src/base/platform/mutex.h"
+#include "src/base/vector.h"
 #include "src/common/globals.h"
 #include "src/objects/code.h"
 #include "src/objects/name.h"
 #include "src/objects/shared-function-info.h"
 #include "src/objects/string.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -25,7 +25,7 @@ class String;
 
 namespace wasm {
 class WasmCode;
-using WasmName = Vector<const char>;
+using WasmName = base::Vector<const char>;
 }  // namespace wasm
 
 // clang-format off
diff --git a/src/logging/log-utils.cc b/src/logging/log-utils.cc
index ec23b1bdf0..6871fde13f 100644
--- a/src/logging/log-utils.cc
+++ b/src/logging/log-utils.cc
@@ -9,11 +9,11 @@
 
 #include "src/base/platform/mutex.h"
 #include "src/base/platform/platform.h"
+#include "src/base/vector.h"
 #include "src/common/assert-scope.h"
 #include "src/objects/objects-inl.h"
 #include "src/strings/string-stream.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 #include "src/utils/version.h"
 
 namespace v8 {
@@ -119,7 +119,7 @@ void Log::MessageBuilder::AppendString(String str,
   }
 }
 
-void Log::MessageBuilder::AppendString(Vector<const char> str) {
+void Log::MessageBuilder::AppendString(base::Vector<const char> str) {
   for (auto i = str.begin(); i < str.end(); i++) AppendCharacter(*i);
 }
 
@@ -214,7 +214,7 @@ void Log::MessageBuilder::AppendSymbolNameDetails(String str,
 
 int Log::MessageBuilder::FormatStringIntoBuffer(const char* format,
                                                 va_list args) {
-  Vector<char> buf(log_->format_buffer_.get(), Log::kMessageBufferSize);
+  base::Vector<char> buf(log_->format_buffer_.get(), Log::kMessageBufferSize);
   int length = v8::internal::VSNPrintF(buf, format, args);
   // |length| is -1 if output was truncated.
   if (length == -1) length = Log::kMessageBufferSize;
diff --git a/src/logging/log-utils.h b/src/logging/log-utils.h
index bba1186e4f..b996f310e4 100644
--- a/src/logging/log-utils.h
+++ b/src/logging/log-utils.h
@@ -20,11 +20,15 @@
 #include "src/utils/ostreams.h"
 
 namespace v8 {
-namespace internal {
 
-class Logger;
+namespace base {
 template <typename T>
 class Vector;
+}  // namespace base
+
+namespace internal {
+
+class Logger;
 
 enum class LogSeparator { kSeparator };
 
@@ -59,7 +63,7 @@ class Log {
 
     void AppendString(String str,
                       base::Optional<int> length_limit = base::nullopt);
-    void AppendString(Vector<const char> str);
+    void AppendString(base::Vector<const char> str);
     void AppendString(const char* str);
     void AppendString(const char* str, size_t length, bool is_one_byte = true);
     void PRINTF_FORMAT(2, 3) AppendFormatString(const char* format, ...);
diff --git a/src/logging/log.cc b/src/logging/log.cc
index dd12301998..9f88129726 100644
--- a/src/logging/log.cc
+++ b/src/logging/log.cc
@@ -169,7 +169,7 @@ class CodeEventLogger::NameBuffer {
   void AppendInt(int n) {
     int space = kUtf8BufferSize - utf8_pos_;
     if (space <= 0) return;
-    Vector<char> buffer(utf8_buffer_ + utf8_pos_, space);
+    base::Vector<char> buffer(utf8_buffer_ + utf8_pos_, space);
     int size = SNPrintF(buffer, "%d", n);
     if (size > 0 && utf8_pos_ + size <= kUtf8BufferSize) {
       utf8_pos_ += size;
@@ -179,7 +179,7 @@ class CodeEventLogger::NameBuffer {
   void AppendHex(uint32_t n) {
     int space = kUtf8BufferSize - utf8_pos_;
     if (space <= 0) return;
-    Vector<char> buffer(utf8_buffer_ + utf8_pos_, space);
+    base::Vector<char> buffer(utf8_buffer_ + utf8_pos_, space);
     int size = SNPrintF(buffer, "%x", n);
     if (size > 0 && utf8_pos_ + size <= kUtf8BufferSize) {
       utf8_pos_ += size;
@@ -318,7 +318,7 @@ PerfBasicLogger::PerfBasicLogger(Isolate* isolate)
     : CodeEventLogger(isolate), perf_output_handle_(nullptr) {
   // Open the perf JIT dump file.
   int bufferSize = sizeof(kFilenameFormatString) + kFilenameBufferPadding;
-  ScopedVector<char> perf_dump_name(bufferSize);
+  base::ScopedVector<char> perf_dump_name(bufferSize);
   int size = SNPrintF(perf_dump_name, kFilenameFormatString,
                       base::OS::GetCurrentProcessId());
   CHECK_NE(size, -1);
@@ -588,7 +588,7 @@ LowLevelLogger::LowLevelLogger(Isolate* isolate, const char* name)
     : CodeEventLogger(isolate), ll_output_handle_(nullptr) {
   // Open the low-level log file.
   size_t len = strlen(name);
-  ScopedVector<char> ll_name(static_cast<int>(len + sizeof(kLogExt)));
+  base::ScopedVector<char> ll_name(static_cast<int>(len + sizeof(kLogExt)));
   MemCopy(ll_name.begin(), name, len);
   MemCopy(ll_name.begin() + len, kLogExt, sizeof(kLogExt));
   ll_output_handle_ =
@@ -1549,7 +1549,7 @@ void Logger::CodeLinePosInfoRecordEvent(Address code_start,
 }
 
 void Logger::CodeLinePosInfoRecordEvent(
-    Address code_start, Vector<const byte> source_position_table) {
+    Address code_start, base::Vector<const byte> source_position_table) {
   if (!jit_logger_) return;
   SourcePositionTableIterator iter(source_position_table);
   CodeLinePosEvent(*jit_logger_, code_start, iter);
diff --git a/src/logging/log.h b/src/logging/log.h
index ec19032060..45aadd7163 100644
--- a/src/logging/log.h
+++ b/src/logging/log.h
@@ -225,8 +225,8 @@ class Logger : public CodeEventListener {
   // Emits a code line info record event.
   void CodeLinePosInfoRecordEvent(Address code_start,
                                   ByteArray source_position_table);
-  void CodeLinePosInfoRecordEvent(Address code_start,
-                                  Vector<const byte> source_position_table);
+  void CodeLinePosInfoRecordEvent(
+      Address code_start, base::Vector<const byte> source_position_table);
 
   void CodeNameEvent(Address addr, int pos, const char* code_name);
 
diff --git a/src/numbers/bignum-dtoa.cc b/src/numbers/bignum-dtoa.cc
index c0bf514b4a..5fc871a80d 100644
--- a/src/numbers/bignum-dtoa.cc
+++ b/src/numbers/bignum-dtoa.cc
@@ -45,22 +45,22 @@ static void FixupMultiply10(int estimated_power, bool is_even,
 // digits yield the shortest decimal representation of v.
 static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
                                    Bignum* delta_minus, Bignum* delta_plus,
-                                   bool is_even, Vector<char> buffer,
+                                   bool is_even, base::Vector<char> buffer,
                                    int* length);
 // Generates 'requested_digits' after the decimal point.
 static void BignumToFixed(int requested_digits, int* decimal_point,
                           Bignum* numerator, Bignum* denominator,
-                          Vector<char>(buffer), int* length);
+                          base::Vector<char>(buffer), int* length);
 // Generates 'count' digits of numerator/denominator.
 // Once 'count' digits have been produced rounds the result depending on the
 // remainder (remainders of exactly .5 round upwards). Might update the
 // decimal_point when rounding up (for example for 0.9999).
 static void GenerateCountedDigits(int count, int* decimal_point,
                                   Bignum* numerator, Bignum* denominator,
-                                  Vector<char>(buffer), int* length);
+                                  base::Vector<char>(buffer), int* length);
 
 void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
-                Vector<char> buffer, int* length, int* decimal_point) {
+                base::Vector<char> buffer, int* length, int* decimal_point) {
   DCHECK_GT(v, 0);
   DCHECK(!Double(v).IsSpecial());
   uint64_t significand = Double(v).Significand();
@@ -135,7 +135,7 @@ void BignumDtoa(double v, BignumDtoaMode mode, int requested_digits,
 //   will be produced. This should be the standard precondition.
 static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
                                    Bignum* delta_minus, Bignum* delta_plus,
-                                   bool is_even, Vector<char> buffer,
+                                   bool is_even, base::Vector<char> buffer,
                                    int* length) {
   // Small optimization: if delta_minus and delta_plus are the same just reuse
   // one of the two bignums.
@@ -232,7 +232,7 @@ static void GenerateShortestDigits(Bignum* numerator, Bignum* denominator,
 // exponent (decimal_point), when rounding upwards.
 static void GenerateCountedDigits(int count, int* decimal_point,
                                   Bignum* numerator, Bignum* denominator,
-                                  Vector<char>(buffer), int* length) {
+                                  base::Vector<char>(buffer), int* length) {
   DCHECK_GE(count, 0);
   for (int i = 0; i < count - 1; ++i) {
     uint16_t digit;
@@ -273,7 +273,7 @@ static void GenerateCountedDigits(int count, int* decimal_point,
 // Input verifies:  1 <= (numerator + delta) / denominator < 10.
 static void BignumToFixed(int requested_digits, int* decimal_point,
                           Bignum* numerator, Bignum* denominator,
-                          Vector<char>(buffer), int* length) {
+                          base::Vector<char>(buffer), int* length) {
   // Note that we have to look at more than just the requested_digits, since
   // a number could be rounded up. Example: v=0.5 with requested_digits=0.
   // Even though the power of v equals 0 we can't just stop here.
diff --git a/src/numbers/bignum-dtoa.h b/src/numbers/bignum-dtoa.h
index c42d0b865a..8a9737df88 100644
--- a/src/numbers/bignum-dtoa.h
+++ b/src/numbers/bignum-dtoa.h
@@ -5,7 +5,7 @@
 #ifndef V8_NUMBERS_BIGNUM_DTOA_H_
 #define V8_NUMBERS_BIGNUM_DTOA_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -53,8 +53,9 @@ enum BignumDtoaMode {
 // 'BignumDtoa' expects the given buffer to be big enough to hold all digits
 // and a terminating null-character.
 V8_EXPORT_PRIVATE void BignumDtoa(double v, BignumDtoaMode mode,
-                                  int requested_digits, Vector<char> buffer,
-                                  int* length, int* point);
+                                  int requested_digits,
+                                  base::Vector<char> buffer, int* length,
+                                  int* point);
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/numbers/bignum.cc b/src/numbers/bignum.cc
index 8698ec537f..1b91d338b9 100644
--- a/src/numbers/bignum.cc
+++ b/src/numbers/bignum.cc
@@ -59,7 +59,7 @@ void Bignum::AssignBignum(const Bignum& other) {
   used_digits_ = other.used_digits_;
 }
 
-static uint64_t ReadUInt64(Vector<const char> buffer, int from,
+static uint64_t ReadUInt64(base::Vector<const char> buffer, int from,
                            int digits_to_read) {
   uint64_t result = 0;
   int to = from + digits_to_read;
@@ -72,7 +72,7 @@ static uint64_t ReadUInt64(Vector<const char> buffer, int from,
   return result;
 }
 
-void Bignum::AssignDecimalString(Vector<const char> value) {
+void Bignum::AssignDecimalString(base::Vector<const char> value) {
   // 2^64 = 18446744073709551616 > 10^19
   const int kMaxUint64DecimalDigits = 19;
   Zero();
@@ -99,7 +99,7 @@ static int HexCharValue(char c) {
   UNREACHABLE();
 }
 
-void Bignum::AssignHexString(Vector<const char> value) {
+void Bignum::AssignHexString(base::Vector<const char> value) {
   Zero();
   int length = value.length();
 
diff --git a/src/numbers/bignum.h b/src/numbers/bignum.h
index 1fdfa40325..b1721a436c 100644
--- a/src/numbers/bignum.h
+++ b/src/numbers/bignum.h
@@ -5,7 +5,7 @@
 #ifndef V8_NUMBERS_BIGNUM_H_
 #define V8_NUMBERS_BIGNUM_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -24,8 +24,8 @@ class V8_EXPORT_PRIVATE Bignum {
   void AssignUInt64(uint64_t value);
   void AssignBignum(const Bignum& other);
 
-  void AssignDecimalString(Vector<const char> value);
-  void AssignHexString(Vector<const char> value);
+  void AssignDecimalString(base::Vector<const char> value);
+  void AssignHexString(base::Vector<const char> value);
 
   void AssignPowerUInt16(uint16_t base, int exponent);
 
@@ -109,7 +109,7 @@ class V8_EXPORT_PRIVATE Bignum {
   Chunk bigits_buffer_[kBigitCapacity];
   // A vector backed by bigits_buffer_. This way accesses to the array are
   // checked for out-of-bounds errors.
-  Vector<Chunk> bigits_;
+  base::Vector<Chunk> bigits_;
   int used_digits_;
   // The Bignum's value equals value(bigits_) * 2^(exponent_ * kBigitSize).
   int exponent_;
diff --git a/src/numbers/conversions.cc b/src/numbers/conversions.cc
index e7b3bcd233..1ba2fc2950 100644
--- a/src/numbers/conversions.cc
+++ b/src/numbers/conversions.cc
@@ -226,15 +226,15 @@ class StringToIntHelper {
            String::IsOneByteRepresentationUnderneath(*subject_);
   }
 
-  Vector<const uint8_t> GetOneByteVector() {
+  base::Vector<const uint8_t> GetOneByteVector() {
     if (raw_one_byte_subject_ != nullptr) {
-      return Vector<const uint8_t>(raw_one_byte_subject_, length_);
+      return base::Vector<const uint8_t>(raw_one_byte_subject_, length_);
     }
     DisallowGarbageCollection no_gc;
     return subject_->GetFlatContent(no_gc).ToOneByteVector();
   }
 
-  Vector<const uc16> GetTwoByteVector() {
+  base::Vector<const uc16> GetTwoByteVector() {
     DisallowGarbageCollection no_gc;
     return subject_->GetFlatContent(no_gc).ToUC16Vector();
   }
@@ -272,10 +272,10 @@ void StringToIntHelper<IsolateT>::ParseInt() {
   {
     DisallowGarbageCollection no_gc;
     if (IsOneByte()) {
-      Vector<const uint8_t> vector = GetOneByteVector();
+      base::Vector<const uint8_t> vector = GetOneByteVector();
       DetectRadixInternal(vector.begin(), vector.length());
     } else {
-      Vector<const uc16> vector = GetTwoByteVector();
+      base::Vector<const uc16> vector = GetTwoByteVector();
       DetectRadixInternal(vector.begin(), vector.length());
     }
   }
@@ -287,13 +287,13 @@ void StringToIntHelper<IsolateT>::ParseInt() {
     {
       DisallowGarbageCollection no_gc;
       if (IsOneByte()) {
-        Vector<const uint8_t> vector = GetOneByteVector();
+        base::Vector<const uint8_t> vector = GetOneByteVector();
         DCHECK_EQ(length_, vector.length());
         if (ParseChunkInternal(vector.begin())) {
           break;
         }
       } else {
-        Vector<const uc16> vector = GetTwoByteVector();
+        base::Vector<const uc16> vector = GetTwoByteVector();
         DCHECK_EQ(length_, vector.length());
         if (ParseChunkInternal(vector.begin())) {
           break;
@@ -501,12 +501,12 @@ class NumberParseIntHelper : public StringToIntHelper<Isolate> {
     if (!is_power_of_two && radix() != 10) return;
     DisallowGarbageCollection no_gc;
     if (IsOneByte()) {
-      Vector<const uint8_t> vector = GetOneByteVector();
+      base::Vector<const uint8_t> vector = GetOneByteVector();
       DCHECK_EQ(length(), vector.length());
       result_ = is_power_of_two ? HandlePowerOfTwoCase(vector.begin())
                                 : HandleBaseTenCase(vector.begin());
     } else {
-      Vector<const uc16> vector = GetTwoByteVector();
+      base::Vector<const uc16> vector = GetTwoByteVector();
       DCHECK_EQ(length(), vector.length());
       result_ = is_power_of_two ? HandlePowerOfTwoCase(vector.begin())
                                 : HandleBaseTenCase(vector.begin());
@@ -568,7 +568,7 @@ class NumberParseIntHelper : public StringToIntHelper<Isolate> {
 
     SLOW_DCHECK(buffer_pos < kBufferSize);
     buffer[buffer_pos] = '\0';
-    Vector<const char> buffer_vector(buffer, buffer_pos);
+    base::Vector<const char> buffer_vector(buffer, buffer_pos);
     return Strtod(buffer_vector, 0);
   }
 
@@ -833,23 +833,25 @@ parsing_done:
   SLOW_DCHECK(buffer_pos < kBufferSize);
   buffer[buffer_pos] = '\0';
 
-  double converted = Strtod(Vector<const char>(buffer, buffer_pos), exponent);
+  double converted =
+      Strtod(base::Vector<const char>(buffer, buffer_pos), exponent);
   return (sign == NEGATIVE) ? -converted : converted;
 }
 
 double StringToDouble(const char* str, int flags, double empty_string_val) {
-  // We use {OneByteVector} instead of {CStrVector} to avoid instantiating the
-  // InternalStringToDouble() template for {const char*} as well.
-  return StringToDouble(OneByteVector(str), flags, empty_string_val);
+  // We use {base::OneByteVector} instead of {base::CStrVector} to avoid
+  // instantiating the InternalStringToDouble() template for {const char*} as
+  // well.
+  return StringToDouble(base::OneByteVector(str), flags, empty_string_val);
 }
 
-double StringToDouble(Vector<const uint8_t> str, int flags,
+double StringToDouble(base::Vector<const uint8_t> str, int flags,
                       double empty_string_val) {
   return InternalStringToDouble(str.begin(), str.end(), flags,
                                 empty_string_val);
 }
 
-double StringToDouble(Vector<const uc16> str, int flags,
+double StringToDouble(base::Vector<const uc16> str, int flags,
                       double empty_string_val) {
   const uc16* end = str.begin() + str.length();
   return InternalStringToDouble(str.begin(), end, flags, empty_string_val);
@@ -974,7 +976,7 @@ template EXPORT_TEMPLATE_DEFINE(V8_EXPORT_PRIVATE)
     MaybeHandle<BigInt> BigIntLiteral(LocalIsolate* isolate,
                                       const char* string);
 
-const char* DoubleToCString(double v, Vector<char> buffer) {
+const char* DoubleToCString(double v, base::Vector<char> buffer) {
   switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {
     case FP_NAN:
       return "NaN";
@@ -996,8 +998,8 @@ const char* DoubleToCString(double v, Vector<char> buffer) {
       int length;
 
       DoubleToAscii(v, DTOA_SHORTEST, 0,
-                    Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
-                    &length, &decimal_point);
+                    base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity),
+                    &sign, &length, &decimal_point);
 
       if (sign) builder.AddCharacter('-');
 
@@ -1036,7 +1038,7 @@ const char* DoubleToCString(double v, Vector<char> buffer) {
   }
 }
 
-const char* IntToCString(int n, Vector<char> buffer) {
+const char* IntToCString(int n, base::Vector<char> buffer) {
   bool negative = true;
   if (n >= 0) {
     n = -n;
@@ -1071,7 +1073,7 @@ char* DoubleToFixedCString(double value, int f) {
   // use the non-fixed conversion routine.
   if (abs_value >= kFirstNonFixed) {
     char arr[kMaxFractionDigits];
-    Vector<char> buffer(arr, arraysize(arr));
+    base::Vector<char> buffer(arr, arraysize(arr));
     return StrDup(DoubleToCString(value, buffer));
   }
 
@@ -1084,7 +1086,7 @@ char* DoubleToFixedCString(double value, int f) {
   char decimal_rep[kDecimalRepCapacity];
   int decimal_rep_length;
   DoubleToAscii(value, DTOA_FIXED, f,
-                Vector<char>(decimal_rep, kDecimalRepCapacity), &sign,
+                base::Vector<char>(decimal_rep, kDecimalRepCapacity), &sign,
                 &decimal_rep_length, &decimal_point);
 
   // Create a representation that is padded with zeros if needed.
@@ -1179,12 +1181,12 @@ char* DoubleToExponentialCString(double value, int f) {
 
   if (f == -1) {
     DoubleToAscii(value, DTOA_SHORTEST, 0,
-                  Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
+                  base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
                   &decimal_rep_length, &decimal_point);
     f = decimal_rep_length - 1;
   } else {
     DoubleToAscii(value, DTOA_PRECISION, f + 1,
-                  Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
+                  base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
                   &decimal_rep_length, &decimal_point);
   }
   DCHECK_GT(decimal_rep_length, 0);
@@ -1217,7 +1219,7 @@ char* DoubleToPrecisionCString(double value, int p) {
   int decimal_rep_length;
 
   DoubleToAscii(value, DTOA_PRECISION, p,
-                Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
+                base::Vector<char>(decimal_rep, kV8DtoaBufferCapacity), &sign,
                 &decimal_rep_length, &decimal_point);
   DCHECK(decimal_rep_length <= p);
 
@@ -1382,7 +1384,7 @@ base::Optional<double> TryStringToDouble(LocalIsolate* isolate,
   auto buffer = std::make_unique<uc16[]>(max_length_for_conversion);
   SharedStringAccessGuardIfNeeded access_guard(isolate);
   String::WriteToFlat(*object, buffer.get(), 0, length, access_guard);
-  Vector<const uc16> v(buffer.get(), length);
+  base::Vector<const uc16> v(buffer.get(), length);
   return StringToDouble(v, flags);
 }
 
@@ -1431,12 +1433,12 @@ bool IsSpecialIndex(String string) {
     }
   }
   // Slow path: test DoubleToString(StringToDouble(string)) == string.
-  Vector<const uint16_t> vector(buffer, length);
+  base::Vector<const uint16_t> vector(buffer, length);
   double d = StringToDouble(vector, NO_FLAGS);
   if (std::isnan(d)) return false;
   // Compute reverse string.
   char reverse_buffer[kBufferSize + 1];  // Result will be /0 terminated.
-  Vector<char> reverse_vector(reverse_buffer, arraysize(reverse_buffer));
+  base::Vector<char> reverse_vector(reverse_buffer, arraysize(reverse_buffer));
   const char* reverse_string = DoubleToCString(d, reverse_vector);
   for (int i = 0; i < length; ++i) {
     if (static_cast<uint16_t>(reverse_string[i]) != buffer[i]) return false;
diff --git a/src/numbers/conversions.h b/src/numbers/conversions.h
index 935d6f57e2..e7388b2160 100644
--- a/src/numbers/conversions.h
+++ b/src/numbers/conversions.h
@@ -8,8 +8,8 @@
 #include "src/base/export-template.h"
 #include "src/base/logging.h"
 #include "src/base/optional.h"
+#include "src/base/vector.h"
 #include "src/common/globals.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -82,9 +82,9 @@ enum ConversionFlags {
 };
 
 // Converts a string into a double value according to ECMA-262 9.3.1
-double StringToDouble(Vector<const uint8_t> str, int flags,
+double StringToDouble(base::Vector<const uint8_t> str, int flags,
                       double empty_string_val = 0);
-double StringToDouble(Vector<const uc16> str, int flags,
+double StringToDouble(base::Vector<const uc16> str, int flags,
                       double empty_string_val = 0);
 // This version expects a zero-terminated character array.
 double V8_EXPORT_PRIVATE StringToDouble(const char* str, int flags,
@@ -111,11 +111,11 @@ const int kDoubleToCStringMinBufferSize = 100;
 // The buffer should be large enough for any floating point number.
 // 100 characters is enough.
 V8_EXPORT_PRIVATE const char* DoubleToCString(double value,
-                                              Vector<char> buffer);
+                                              base::Vector<char> buffer);
 
 // Convert an int to a null-terminated string. The returned string is
 // located inside the buffer, but not necessarily at the start.
-V8_EXPORT_PRIVATE const char* IntToCString(int n, Vector<char> buffer);
+V8_EXPORT_PRIVATE const char* IntToCString(int n, base::Vector<char> buffer);
 
 // Additional number to string conversions for the number type.
 // The caller is responsible for calling free on the returned pointer.
diff --git a/src/numbers/dtoa.cc b/src/numbers/dtoa.cc
index 34ca651d10..4ab9efafdc 100644
--- a/src/numbers/dtoa.cc
+++ b/src/numbers/dtoa.cc
@@ -31,7 +31,8 @@ static BignumDtoaMode DtoaToBignumDtoaMode(DtoaMode dtoa_mode) {
 }
 
 void DoubleToAscii(double v, DtoaMode mode, int requested_digits,
-                   Vector<char> buffer, int* sign, int* length, int* point) {
+                   base::Vector<char> buffer, int* sign, int* length,
+                   int* point) {
   DCHECK(!Double(v).IsSpecial());
   DCHECK(mode == DTOA_SHORTEST || requested_digits >= 0);
 
diff --git a/src/numbers/dtoa.h b/src/numbers/dtoa.h
index cf540f1213..42caef4a94 100644
--- a/src/numbers/dtoa.h
+++ b/src/numbers/dtoa.h
@@ -5,7 +5,7 @@
 #ifndef V8_NUMBERS_DTOA_H_
 #define V8_NUMBERS_DTOA_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -62,8 +62,9 @@ const int kBase10MaximalLength = 17;
 // at least kBase10MaximalLength + 1. Otherwise, the size of the output is
 // limited to requested_digits digits plus the null terminator.
 V8_EXPORT_PRIVATE void DoubleToAscii(double v, DtoaMode mode,
-                                     int requested_digits, Vector<char> buffer,
-                                     int* sign, int* length, int* point);
+                                     int requested_digits,
+                                     base::Vector<char> buffer, int* sign,
+                                     int* length, int* point);
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/numbers/fast-dtoa.cc b/src/numbers/fast-dtoa.cc
index 746753963d..c9de2ee924 100644
--- a/src/numbers/fast-dtoa.cc
+++ b/src/numbers/fast-dtoa.cc
@@ -39,7 +39,7 @@ static const int kMaximalTargetExponent = -32;
 // Output: returns true if the buffer is guaranteed to contain the closest
 //    representable number to the input.
 //  Modifies the generated digits in the buffer to approach (round towards) w.
-static bool RoundWeed(Vector<char> buffer, int length,
+static bool RoundWeed(base::Vector<char> buffer, int length,
                       uint64_t distance_too_high_w, uint64_t unsafe_interval,
                       uint64_t rest, uint64_t ten_kappa, uint64_t unit) {
   uint64_t small_distance = distance_too_high_w - unit;
@@ -153,8 +153,9 @@ static bool RoundWeed(Vector<char> buffer, int length,
 // unambiguously determined.
 //
 // Precondition: rest < ten_kappa.
-static bool RoundWeedCounted(Vector<char> buffer, int length, uint64_t rest,
-                             uint64_t ten_kappa, uint64_t unit, int* kappa) {
+static bool RoundWeedCounted(base::Vector<char> buffer, int length,
+                             uint64_t rest, uint64_t ten_kappa, uint64_t unit,
+                             int* kappa) {
   DCHECK(rest < ten_kappa);
   // The following tests are done in a specific order to avoid overflows. They
   // will work correctly with any uint64 values of rest < ten_kappa and unit.
@@ -354,7 +355,7 @@ static void BiggestPowerTen(uint32_t number, int number_bits, uint32_t* power,
 // represent 'w' we can stop. Everything inside the interval low - high
 // represents w. However we have to pay attention to low, high and w's
 // imprecision.
-static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, Vector<char> buffer,
+static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, base::Vector<char> buffer,
                      int* length, int* kappa) {
   DCHECK(low.e() == w.e() && w.e() == high.e());
   DCHECK(low.f() + 1 <= high.f() - 1);
@@ -474,8 +475,9 @@ static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, Vector<char> buffer,
 //   numbers. If the precision is not enough to guarantee all the postconditions
 //   then false is returned. This usually happens rarely, but the failure-rate
 //   increases with higher requested_digits.
-static bool DigitGenCounted(DiyFp w, int requested_digits, Vector<char> buffer,
-                            int* length, int* kappa) {
+static bool DigitGenCounted(DiyFp w, int requested_digits,
+                            base::Vector<char> buffer, int* length,
+                            int* kappa) {
   DCHECK(kMinimalTargetExponent <= w.e() && w.e() <= kMaximalTargetExponent);
   DCHECK_GE(kMinimalTargetExponent, -60);
   DCHECK_LE(kMaximalTargetExponent, -32);
@@ -559,7 +561,7 @@ static bool DigitGenCounted(DiyFp w, int requested_digits, Vector<char> buffer,
 // The last digit will be closest to the actual v. That is, even if several
 // digits might correctly yield 'v' when read again, the closest will be
 // computed.
-static bool Grisu3(double v, Vector<char> buffer, int* length,
+static bool Grisu3(double v, base::Vector<char> buffer, int* length,
                    int* decimal_exponent) {
   DiyFp w = Double(v).AsNormalizedDiyFp();
   // boundary_minus and boundary_plus are the boundaries between v and its
@@ -620,8 +622,9 @@ static bool Grisu3(double v, Vector<char> buffer, int* length,
 // and with enough requested digits 0.1 will at some point print as 0.9999999...
 // Grisu3 is too imprecise for real halfway cases (1.5 will not work) and
 // therefore the rounding strategy for halfway cases is irrelevant.
-static bool Grisu3Counted(double v, int requested_digits, Vector<char> buffer,
-                          int* length, int* decimal_exponent) {
+static bool Grisu3Counted(double v, int requested_digits,
+                          base::Vector<char> buffer, int* length,
+                          int* decimal_exponent) {
   DiyFp w = Double(v).AsNormalizedDiyFp();
   DiyFp ten_mk;  // Cached power of ten: 10^-k
   int mk;        // -k
@@ -660,7 +663,7 @@ static bool Grisu3Counted(double v, int requested_digits, Vector<char> buffer,
 }
 
 bool FastDtoa(double v, FastDtoaMode mode, int requested_digits,
-              Vector<char> buffer, int* length, int* decimal_point) {
+              base::Vector<char> buffer, int* length, int* decimal_point) {
   DCHECK_GT(v, 0);
   DCHECK(!Double(v).IsSpecial());
 
diff --git a/src/numbers/fast-dtoa.h b/src/numbers/fast-dtoa.h
index 4b4fb2fcc2..467d095d7b 100644
--- a/src/numbers/fast-dtoa.h
+++ b/src/numbers/fast-dtoa.h
@@ -5,7 +5,7 @@
 #ifndef V8_NUMBERS_FAST_DTOA_H_
 #define V8_NUMBERS_FAST_DTOA_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -51,7 +51,7 @@ const int kFastDtoaMaximalLength = 17;
 //     false.
 // For both modes the buffer must be large enough to hold the result.
 V8_EXPORT_PRIVATE bool FastDtoa(double d, FastDtoaMode mode,
-                                int requested_digits, Vector<char> buffer,
+                                int requested_digits, base::Vector<char> buffer,
                                 int* length, int* decimal_point);
 
 }  // namespace internal
diff --git a/src/numbers/fixed-dtoa.cc b/src/numbers/fixed-dtoa.cc
index 53612fb448..7e71d672aa 100644
--- a/src/numbers/fixed-dtoa.cc
+++ b/src/numbers/fixed-dtoa.cc
@@ -97,7 +97,7 @@ class UInt128 {
 static const int kDoubleSignificandSize = 53;  // Includes the hidden bit.
 
 static void FillDigits32FixedLength(uint32_t number, int requested_length,
-                                    Vector<char> buffer, int* length) {
+                                    base::Vector<char> buffer, int* length) {
   for (int i = requested_length - 1; i >= 0; --i) {
     buffer[(*length) + i] = '0' + number % 10;
     number /= 10;
@@ -105,7 +105,8 @@ static void FillDigits32FixedLength(uint32_t number, int requested_length,
   *length += requested_length;
 }
 
-static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {
+static void FillDigits32(uint32_t number, base::Vector<char> buffer,
+                         int* length) {
   int number_length = 0;
   // We fill the digits in reverse order and exchange them afterwards.
   while (number != 0) {
@@ -128,7 +129,7 @@ static void FillDigits32(uint32_t number, Vector<char> buffer, int* length) {
 }
 
 static void FillDigits64FixedLength(uint64_t number, int requested_length,
-                                    Vector<char> buffer, int* length) {
+                                    base::Vector<char> buffer, int* length) {
   const uint32_t kTen7 = 10000000;
   // For efficiency cut the number into 3 uint32_t parts, and print those.
   uint32_t part2 = static_cast<uint32_t>(number % kTen7);
@@ -141,7 +142,8 @@ static void FillDigits64FixedLength(uint64_t number, int requested_length,
   FillDigits32FixedLength(part2, 7, buffer, length);
 }
 
-static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {
+static void FillDigits64(uint64_t number, base::Vector<char> buffer,
+                         int* length) {
   const uint32_t kTen7 = 10000000;
   // For efficiency cut the number into 3 uint32_t parts, and print those.
   uint32_t part2 = static_cast<uint32_t>(number % kTen7);
@@ -161,7 +163,8 @@ static void FillDigits64(uint64_t number, Vector<char> buffer, int* length) {
   }
 }
 
-static void DtoaRoundUp(Vector<char> buffer, int* length, int* decimal_point) {
+static void DtoaRoundUp(base::Vector<char> buffer, int* length,
+                        int* decimal_point) {
   // An empty buffer represents 0.
   if (*length == 0) {
     buffer[0] = '1';
@@ -202,7 +205,7 @@ static void DtoaRoundUp(Vector<char> buffer, int* length, int* decimal_point) {
 // already contained "199" (thus yielding a buffer of "19999") then a
 // rounding-up will change the contents of the buffer to "20000".
 static void FillFractionals(uint64_t fractionals, int exponent,
-                            int fractional_count, Vector<char> buffer,
+                            int fractional_count, base::Vector<char> buffer,
                             int* length, int* decimal_point) {
   DCHECK(-128 <= exponent && exponent <= 0);
   // 'fractionals' is a fixed-point number, with binary point at bit
@@ -259,7 +262,8 @@ static void FillFractionals(uint64_t fractionals, int exponent,
 
 // Removes leading and trailing zeros.
 // If leading zeros are removed then the decimal point position is adjusted.
-static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {
+static void TrimZeros(base::Vector<char> buffer, int* length,
+                      int* decimal_point) {
   while (*length > 0 && buffer[(*length) - 1] == '0') {
     (*length)--;
   }
@@ -276,7 +280,7 @@ static void TrimZeros(Vector<char> buffer, int* length, int* decimal_point) {
   }
 }
 
-bool FastFixedDtoa(double v, int fractional_count, Vector<char> buffer,
+bool FastFixedDtoa(double v, int fractional_count, base::Vector<char> buffer,
                    int* length, int* decimal_point) {
   const uint32_t kMaxUInt32 = 0xFFFFFFFF;
   uint64_t significand = Double(v).Significand();
diff --git a/src/numbers/fixed-dtoa.h b/src/numbers/fixed-dtoa.h
index d38dbe13be..3a6dbe720d 100644
--- a/src/numbers/fixed-dtoa.h
+++ b/src/numbers/fixed-dtoa.h
@@ -5,7 +5,7 @@
 #ifndef V8_NUMBERS_FIXED_DTOA_H_
 #define V8_NUMBERS_FIXED_DTOA_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -27,7 +27,7 @@ namespace internal {
 // This method only works for some parameters. If it can't handle the input it
 // returns false. The output is null-terminated when the function succeeds.
 V8_EXPORT_PRIVATE bool FastFixedDtoa(double v, int fractional_count,
-                                     Vector<char> buffer, int* length,
+                                     base::Vector<char> buffer, int* length,
                                      int* decimal_point);
 
 }  // namespace internal
diff --git a/src/numbers/strtod.cc b/src/numbers/strtod.cc
index 03f30e6693..6d0fae38c1 100644
--- a/src/numbers/strtod.cc
+++ b/src/numbers/strtod.cc
@@ -70,26 +70,28 @@ static const int kExactPowersOfTenSize = arraysize(exact_powers_of_ten);
 // we round up to 780.
 static const int kMaxSignificantDecimalDigits = 780;
 
-static Vector<const char> TrimLeadingZeros(Vector<const char> buffer) {
+static base::Vector<const char> TrimLeadingZeros(
+    base::Vector<const char> buffer) {
   for (int i = 0; i < buffer.length(); i++) {
     if (buffer[i] != '0') {
       return buffer.SubVector(i, buffer.length());
     }
   }
-  return Vector<const char>(buffer.begin(), 0);
+  return base::Vector<const char>(buffer.begin(), 0);
 }
 
-static Vector<const char> TrimTrailingZeros(Vector<const char> buffer) {
+static base::Vector<const char> TrimTrailingZeros(
+    base::Vector<const char> buffer) {
   for (int i = buffer.length() - 1; i >= 0; --i) {
     if (buffer[i] != '0') {
       return buffer.SubVector(0, i + 1);
     }
   }
-  return Vector<const char>(buffer.begin(), 0);
+  return base::Vector<const char>(buffer.begin(), 0);
 }
 
-static void TrimToMaxSignificantDigits(Vector<const char> buffer, int exponent,
-                                       char* significant_buffer,
+static void TrimToMaxSignificantDigits(base::Vector<const char> buffer,
+                                       int exponent, char* significant_buffer,
                                        int* significant_exponent) {
   for (int i = 0; i < kMaxSignificantDecimalDigits - 1; ++i) {
     significant_buffer[i] = buffer[i];
@@ -109,7 +111,7 @@ static void TrimToMaxSignificantDigits(Vector<const char> buffer, int exponent,
 // When the string starts with "1844674407370955161" no further digit is read.
 // Since 2^64 = 18446744073709551616 it would still be possible read another
 // digit if it was less or equal than 6, but this would complicate the code.
-static uint64_t ReadUint64(Vector<const char> buffer,
+static uint64_t ReadUint64(base::Vector<const char> buffer,
                            int* number_of_read_digits) {
   uint64_t result = 0;
   int i = 0;
@@ -126,7 +128,7 @@ static uint64_t ReadUint64(Vector<const char> buffer,
 // The returned DiyFp is not necessarily normalized.
 // If remaining_decimals is zero then the returned DiyFp is accurate.
 // Otherwise it has been rounded and has error of at most 1/2 ulp.
-static void ReadDiyFp(Vector<const char> buffer, DiyFp* result,
+static void ReadDiyFp(base::Vector<const char> buffer, DiyFp* result,
                       int* remaining_decimals) {
   int read_digits;
   uint64_t significand = ReadUint64(buffer, &read_digits);
@@ -145,7 +147,7 @@ static void ReadDiyFp(Vector<const char> buffer, DiyFp* result,
   }
 }
 
-static bool DoubleStrtod(Vector<const char> trimmed, int exponent,
+static bool DoubleStrtod(base::Vector<const char> trimmed, int exponent,
                          double* result) {
 #if (V8_TARGET_ARCH_IA32 || defined(USE_SIMULATOR)) && !defined(_MSC_VER)
   // On x86 the floating-point stack can be 64 or 80 bits wide. If it is
@@ -231,7 +233,7 @@ static DiyFp AdjustmentPowerOfTen(int exponent) {
 // If the function returns true then the result is the correct double.
 // Otherwise it is either the correct double or the double that is just below
 // the correct double.
-static bool DiyFpStrtod(Vector<const char> buffer, int exponent,
+static bool DiyFpStrtod(base::Vector<const char> buffer, int exponent,
                         double* result) {
   DiyFp input;
   int remaining_decimals;
@@ -345,7 +347,7 @@ static bool DiyFpStrtod(Vector<const char> buffer, int exponent,
 //   buffer.length() + exponent <= kMaxDecimalPower + 1
 //   buffer.length() + exponent > kMinDecimalPower
 //   buffer.length() <= kMaxDecimalSignificantDigits
-static double BignumStrtod(Vector<const char> buffer, int exponent,
+static double BignumStrtod(base::Vector<const char> buffer, int exponent,
                            double guess) {
   if (guess == V8_INFINITY) {
     return guess;
@@ -388,9 +390,9 @@ static double BignumStrtod(Vector<const char> buffer, int exponent,
   }
 }
 
-double Strtod(Vector<const char> buffer, int exponent) {
-  Vector<const char> left_trimmed = TrimLeadingZeros(buffer);
-  Vector<const char> trimmed = TrimTrailingZeros(left_trimmed);
+double Strtod(base::Vector<const char> buffer, int exponent) {
+  base::Vector<const char> left_trimmed = TrimLeadingZeros(buffer);
+  base::Vector<const char> trimmed = TrimTrailingZeros(left_trimmed);
   exponent += left_trimmed.length() - trimmed.length();
   if (trimmed.length() == 0) return 0.0;
   if (trimmed.length() > kMaxSignificantDecimalDigits) {
@@ -398,9 +400,9 @@ double Strtod(Vector<const char> buffer, int exponent) {
     int significant_exponent;
     TrimToMaxSignificantDigits(trimmed, exponent, significant_buffer,
                                &significant_exponent);
-    return Strtod(
-        Vector<const char>(significant_buffer, kMaxSignificantDecimalDigits),
-        significant_exponent);
+    return Strtod(base::Vector<const char>(significant_buffer,
+                                           kMaxSignificantDecimalDigits),
+                  significant_exponent);
   }
   if (exponent + trimmed.length() - 1 >= kMaxDecimalPower) return V8_INFINITY;
   if (exponent + trimmed.length() <= kMinDecimalPower) return 0.0;
diff --git a/src/numbers/strtod.h b/src/numbers/strtod.h
index f0978159ba..6ca23ed1b4 100644
--- a/src/numbers/strtod.h
+++ b/src/numbers/strtod.h
@@ -5,14 +5,14 @@
 #ifndef V8_NUMBERS_STRTOD_H_
 #define V8_NUMBERS_STRTOD_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
 
 // The buffer must only contain digits in the range [0-9]. It must not
 // contain a dot or a sign. It must not start with '0', and must not be empty.
-V8_EXPORT_PRIVATE double Strtod(Vector<const char> buffer, int exponent);
+V8_EXPORT_PRIVATE double Strtod(base::Vector<const char> buffer, int exponent);
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/objects/bigint.cc b/src/objects/bigint.cc
index 711f9fbb7e..4ec5d17eb7 100644
--- a/src/objects/bigint.cc
+++ b/src/objects/bigint.cc
@@ -1739,7 +1739,8 @@ void BigInt::SerializeDigits(uint8_t* storage) {
 // The serialization format MUST NOT CHANGE without updating the format
 // version in value-serializer.cc!
 MaybeHandle<BigInt> BigInt::FromSerializedDigits(
-    Isolate* isolate, uint32_t bitfield, Vector<const uint8_t> digits_storage) {
+    Isolate* isolate, uint32_t bitfield,
+    base::Vector<const uint8_t> digits_storage) {
   int bytelength = LengthBits::decode(bitfield);
   DCHECK(digits_storage.length() == bytelength);
   bool sign = SignBits::decode(bitfield);
diff --git a/src/objects/bigint.h b/src/objects/bigint.h
index 19dfca348a..31241a0158 100644
--- a/src/objects/bigint.h
+++ b/src/objects/bigint.h
@@ -268,7 +268,7 @@ class BigInt : public BigIntBase {
   void SerializeDigits(uint8_t* storage);
   V8_WARN_UNUSED_RESULT static MaybeHandle<BigInt> FromSerializedDigits(
       Isolate* isolate, uint32_t bitfield,
-      Vector<const uint8_t> digits_storage);
+      base::Vector<const uint8_t> digits_storage);
 
   OBJECT_CONSTRUCTORS(BigInt, BigIntBase);
 };
diff --git a/src/objects/code.cc b/src/objects/code.cc
index 74af5d3f7c..71b36c9b07 100644
--- a/src/objects/code.cc
+++ b/src/objects/code.cc
@@ -515,7 +515,7 @@ void Code::Disassemble(const char* name, std::ostream& os, Isolate* isolate,
     if (int pool_size = constant_pool_size()) {
       DCHECK_EQ(pool_size & kPointerAlignmentMask, 0);
       os << "\nConstant Pool (size = " << pool_size << ")\n";
-      Vector<char> buf = Vector<char>::New(50);
+      base::Vector<char> buf = base::Vector<char>::New(50);
       intptr_t* ptr =
           reinterpret_cast<intptr_t*>(MetadataStart() + constant_pool_offset());
       for (int i = 0; i < pool_size; i += kSystemPointerSize, ptr++) {
diff --git a/src/objects/contexts.cc b/src/objects/contexts.cc
index d1788ac4dd..399f0dcbfe 100644
--- a/src/objects/contexts.cc
+++ b/src/objects/contexts.cc
@@ -437,7 +437,7 @@ Handle<Object> Context::ErrorMessageForCodeGenerationFromStrings() {
 }
 
 #define COMPARE_NAME(index, type, name) \
-  if (string->IsOneByteEqualTo(StaticCharVector(#name))) return index;
+  if (string->IsOneByteEqualTo(base::StaticCharVector(#name))) return index;
 
 int Context::IntrinsicIndexForName(Handle<String> string) {
   NATIVE_CONTEXT_INTRINSIC_FUNCTIONS(COMPARE_NAME);
diff --git a/src/objects/intl-objects.cc b/src/objects/intl-objects.cc
index 67ce75885e..8bc7014a21 100644
--- a/src/objects/intl-objects.cc
+++ b/src/objects/intl-objects.cc
@@ -96,7 +96,7 @@ inline constexpr uint16_t ToLatin1Upper(uint16_t ch) {
 }
 
 template <typename Char>
-bool ToUpperFastASCII(const Vector<const Char>& src,
+bool ToUpperFastASCII(const base::Vector<const Char>& src,
                       Handle<SeqOneByteString> result) {
   // Do a faster loop for the case where all the characters are ASCII.
   uint16_t ored = 0;
@@ -112,7 +112,7 @@ bool ToUpperFastASCII(const Vector<const Char>& src,
 const uint16_t sharp_s = 0xDF;
 
 template <typename Char>
-bool ToUpperOneByte(const Vector<const Char>& src, uint8_t* dest,
+bool ToUpperOneByte(const base::Vector<const Char>& src, uint8_t* dest,
                     int* sharp_s_count) {
   // Still pretty-fast path for the input with non-ASCII Latin-1 characters.
 
@@ -138,7 +138,7 @@ bool ToUpperOneByte(const Vector<const Char>& src, uint8_t* dest,
 }
 
 template <typename Char>
-void ToUpperWithSharpS(const Vector<const Char>& src,
+void ToUpperWithSharpS(const base::Vector<const Char>& src,
                        Handle<SeqOneByteString> result) {
   int32_t dest_index = 0;
   for (auto it = src.begin(); it != src.end(); ++it) {
@@ -369,7 +369,7 @@ MaybeHandle<String> Intl::ConvertToUpper(Isolate* isolate, Handle<String> s) {
       String::FlatContent flat = s->GetFlatContent(no_gc);
       uint8_t* dest = result->GetChars(no_gc);
       if (flat.IsOneByte()) {
-        Vector<const uint8_t> src = flat.ToOneByteVector();
+        base::Vector<const uint8_t> src = flat.ToOneByteVector();
         bool has_changed_character = false;
         int index_to_first_unprocessed = FastAsciiConvert<false>(
             reinterpret_cast<char*>(result->GetChars(no_gc)),
@@ -385,7 +385,7 @@ MaybeHandle<String> Intl::ConvertToUpper(Isolate* isolate, Handle<String> s) {
                            dest + index_to_first_unprocessed, &sharp_s_count);
       } else {
         DCHECK(flat.IsTwoByte());
-        Vector<const uint16_t> src = flat.ToUC16Vector();
+        base::Vector<const uint16_t> src = flat.ToUC16Vector();
         if (ToUpperFastASCII(src, result)) return result;
         is_result_single_byte = ToUpperOneByte(src, dest, &sharp_s_count);
       }
@@ -453,7 +453,7 @@ Maybe<icu::Locale> CreateICULocale(const std::string& bcp47_locale) {
 
 MaybeHandle<String> Intl::ToString(Isolate* isolate,
                                    const icu::UnicodeString& string) {
-  return isolate->factory()->NewStringFromTwoByte(Vector<const uint16_t>(
+  return isolate->factory()->NewStringFromTwoByte(base::Vector<const uint16_t>(
       reinterpret_cast<const uint16_t*>(string.getBuffer()), string.length()));
 }
 
@@ -1593,7 +1593,8 @@ MaybeHandle<JSArray> CreateArrayFromList(Isolate* isolate,
     // a. Let status be CreateDataProperty(array, ! ToString(n), e).
     const std::string& part = elements[i];
     Handle<String> value =
-        factory->NewStringFromUtf8(CStrVector(part.c_str())).ToHandleChecked();
+        factory->NewStringFromUtf8(base::CStrVector(part.c_str()))
+            .ToHandleChecked();
     MAYBE_RETURN(JSObject::AddDataElement(array, i, value, attr),
                  MaybeHandle<JSArray>());
   }
diff --git a/src/objects/js-objects.cc b/src/objects/js-objects.cc
index 6e302e6f3b..b43fc1280b 100644
--- a/src/objects/js-objects.cc
+++ b/src/objects/js-objects.cc
@@ -185,7 +185,7 @@ Maybe<bool> JSReceiver::HasInPrototypeChain(Isolate* isolate,
 namespace {
 
 bool HasExcludedProperty(
-    const ScopedVector<Handle<Object>>* excluded_properties,
+    const base::ScopedVector<Handle<Object>>* excluded_properties,
     Handle<Object> search_element) {
   // TODO(gsathya): Change this to be a hashtable.
   for (int i = 0; i < excluded_properties->length(); i++) {
@@ -200,7 +200,8 @@ bool HasExcludedProperty(
 V8_WARN_UNUSED_RESULT Maybe<bool> FastAssign(
     Handle<JSReceiver> target, Handle<Object> source,
     PropertiesEnumerationMode mode,
-    const ScopedVector<Handle<Object>>* excluded_properties, bool use_set) {
+    const base::ScopedVector<Handle<Object>>* excluded_properties,
+    bool use_set) {
   // Non-empty strings are the only non-JSReceivers that need to be handled
   // explicitly by Object.assign.
   if (!source->IsJSReceiver()) {
@@ -334,7 +335,8 @@ V8_WARN_UNUSED_RESULT Maybe<bool> FastAssign(
 Maybe<bool> JSReceiver::SetOrCopyDataProperties(
     Isolate* isolate, Handle<JSReceiver> target, Handle<Object> source,
     PropertiesEnumerationMode mode,
-    const ScopedVector<Handle<Object>>* excluded_properties, bool use_set) {
+    const base::ScopedVector<Handle<Object>>* excluded_properties,
+    bool use_set) {
   Maybe<bool> fast_assign =
       FastAssign(target, source, mode, excluded_properties, use_set);
   if (fast_assign.IsNothing()) return Nothing<bool>();
diff --git a/src/objects/js-objects.h b/src/objects/js-objects.h
index b98e8d7512..6628b619dd 100644
--- a/src/objects/js-objects.h
+++ b/src/objects/js-objects.h
@@ -114,7 +114,7 @@ class JSReceiver : public HeapObject {
   V8_WARN_UNUSED_RESULT static Maybe<bool> SetOrCopyDataProperties(
       Isolate* isolate, Handle<JSReceiver> target, Handle<Object> source,
       PropertiesEnumerationMode mode,
-      const ScopedVector<Handle<Object>>* excluded_properties = nullptr,
+      const base::ScopedVector<Handle<Object>>* excluded_properties = nullptr,
       bool use_set = true);
 
   // Implementation of [[HasProperty]], ECMA-262 5th edition, section 8.12.6.
diff --git a/src/objects/js-regexp.cc b/src/objects/js-regexp.cc
index a40219de42..b5e9978390 100644
--- a/src/objects/js-regexp.cc
+++ b/src/objects/js-regexp.cc
@@ -273,7 +273,7 @@ int CountAdditionalEscapeChars(Handle<String> source, bool* needs_escapes_out) {
   int escapes = 0;
   bool needs_escapes = false;
   bool in_char_class = false;
-  Vector<const Char> src = source->GetCharVector<Char>(no_gc);
+  base::Vector<const Char> src = source->GetCharVector<Char>(no_gc);
   for (int i = 0; i < src.length(); i++) {
     const Char c = src[i];
     if (c == '\\') {
@@ -316,7 +316,7 @@ int CountAdditionalEscapeChars(Handle<String> source, bool* needs_escapes_out) {
 }
 
 template <typename Char>
-void WriteStringToCharVector(Vector<Char> v, int* d, const char* string) {
+void WriteStringToCharVector(base::Vector<Char> v, int* d, const char* string) {
   int s = 0;
   while (string[s] != '\0') v[(*d)++] = string[s++];
 }
@@ -325,8 +325,8 @@ template <typename Char, typename StringType>
 Handle<StringType> WriteEscapedRegExpSource(Handle<String> source,
                                             Handle<StringType> result) {
   DisallowGarbageCollection no_gc;
-  Vector<const Char> src = source->GetCharVector<Char>(no_gc);
-  Vector<Char> dst(result->GetChars(no_gc), result->length());
+  base::Vector<const Char> src = source->GetCharVector<Char>(no_gc);
+  base::Vector<Char> dst(result->GetChars(no_gc), result->length());
   int s = 0;
   int d = 0;
   bool in_char_class = false;
diff --git a/src/objects/map.cc b/src/objects/map.cc
index 3eea0deeb2..50d5728b0e 100644
--- a/src/objects/map.cc
+++ b/src/objects/map.cc
@@ -1891,11 +1891,11 @@ Handle<Map> Map::TransitionToDataProperty(Isolate* isolate, Handle<Map> map,
   if (!maybe_map.ToHandle(&result)) {
     const char* reason = "TooManyFastProperties";
 #if V8_TRACE_MAPS
-    std::unique_ptr<ScopedVector<char>> buffer;
+    std::unique_ptr<base::ScopedVector<char>> buffer;
     if (FLAG_log_maps) {
-      ScopedVector<char> name_buffer(100);
+      base::ScopedVector<char> name_buffer(100);
       name->NameShortPrint(name_buffer);
-      buffer.reset(new ScopedVector<char>(128));
+      buffer.reset(new base::ScopedVector<char>(128));
       SNPrintF(*buffer, "TooManyFastProperties %s", name_buffer.begin());
       reason = buffer->begin();
     }
diff --git a/src/objects/name.h b/src/objects/name.h
index 49d593372d..1d4981f85c 100644
--- a/src/objects/name.h
+++ b/src/objects/name.h
@@ -73,7 +73,7 @@ class Name : public TorqueGeneratedName<Name, PrimitiveHeapObject> {
 
   DECL_PRINTER(Name)
   void NameShortPrint();
-  int NameShortPrint(Vector<char> str);
+  int NameShortPrint(base::Vector<char> str);
 
   // Mask constant for checking if a name has a computed hash code
   // and if it is a string that is an integer index.  The least significant bit
diff --git a/src/objects/objects.cc b/src/objects/objects.cc
index 8a25e81b19..dcc690fdaf 100644
--- a/src/objects/objects.cc
+++ b/src/objects/objects.cc
@@ -4788,7 +4788,7 @@ bool Script::ContainsAsmModule() {
 namespace {
 
 template <typename Char>
-bool GetPositionInfoSlowImpl(const Vector<Char>& source, int position,
+bool GetPositionInfoSlowImpl(const base::Vector<Char>& source, int position,
                              Script::PositionInfo* info) {
   if (position < 0) {
     position = 0;
diff --git a/src/objects/shared-function-info.cc b/src/objects/shared-function-info.cc
index ad9873578b..ec92317d11 100644
--- a/src/objects/shared-function-info.cc
+++ b/src/objects/shared-function-info.cc
@@ -270,7 +270,7 @@ Handle<String> SharedFunctionInfo::DebugName(
   if (shared->HasWasmExportedFunctionData()) {
     return shared->GetIsolate()
         ->factory()
-        ->NewStringFromUtf8(CStrVector(shared->DebugNameCStr().get()))
+        ->NewStringFromUtf8(base::CStrVector(shared->DebugNameCStr().get()))
         .ToHandleChecked();
   }
 #endif  // V8_ENABLE_WEBASSEMBLY
@@ -281,8 +281,9 @@ Handle<String> SharedFunctionInfo::DebugName(
 }
 
 bool SharedFunctionInfo::PassesFilter(const char* raw_filter) {
-  Vector<const char> filter = CStrVector(raw_filter);
-  return v8::internal::PassesFilter(CStrVector(DebugNameCStr().get()), filter);
+  base::Vector<const char> filter = base::CStrVector(raw_filter);
+  return v8::internal::PassesFilter(base::CStrVector(DebugNameCStr().get()),
+                                    filter);
 }
 
 bool SharedFunctionInfo::HasSourceCode() const {
diff --git a/src/objects/source-text-module.cc b/src/objects/source-text-module.cc
index 755f826a87..896145d0f7 100644
--- a/src/objects/source-text-module.cc
+++ b/src/objects/source-text-module.cc
@@ -934,7 +934,7 @@ void SourceTextModule::ExecuteAsyncModule(Isolate* isolate,
   Handle<JSFunction> steps_fulfilled(
       isolate->native_context()->call_async_module_fulfilled(), isolate);
 
-  ScopedVector<Handle<Object>> empty_argv(0);
+  base::ScopedVector<Handle<Object>> empty_argv(0);
 
   // 6. Let onFulfilled be CreateBuiltinFunction(stepsFulfilled,
   //                                             «[[Module]]»).
diff --git a/src/objects/stack-frame-info.cc b/src/objects/stack-frame-info.cc
index ef1135acbe..a4146fbd2a 100644
--- a/src/objects/stack-frame-info.cc
+++ b/src/objects/stack-frame-info.cc
@@ -378,14 +378,14 @@ Handle<Object> StackFrameInfo::GetMethodName(Handle<StackFrameInfo> info) {
 
   // The static initializer function is not a method, so don't add a
   // class name, just return the function name.
-  if (name->HasOneBytePrefix(CStrVector("<static_fields_initializer>"))) {
+  if (name->HasOneBytePrefix(base::CStrVector("<static_fields_initializer>"))) {
     return name;
   }
 
   // ES2015 gives getters and setters name prefixes which must
   // be stripped to find the property name.
-  if (name->HasOneBytePrefix(CStrVector("get ")) ||
-      name->HasOneBytePrefix(CStrVector("set "))) {
+  if (name->HasOneBytePrefix(base::CStrVector("get ")) ||
+      name->HasOneBytePrefix(base::CStrVector("set "))) {
     name = isolate->factory()->NewProperSubString(name, 4, name->length());
   } else if (name->length() == 0) {
     // The function doesn't have a meaningful "name" property, however
@@ -745,7 +745,7 @@ void SerializeWasmStackFrame(Isolate* isolate, Handle<StackFrameInfo> frame,
   builder->AppendCString("]:");
 
   char buffer[16];
-  SNPrintF(ArrayVector(buffer), "0x%x",
+  SNPrintF(base::ArrayVector(buffer), "0x%x",
            StackFrameInfo::GetColumnNumber(frame) - 1);
   builder->AppendCString(buffer);
 
diff --git a/src/objects/string-inl.h b/src/objects/string-inl.h
index 24af68e611..16210cda96 100644
--- a/src/objects/string-inl.h
+++ b/src/objects/string-inl.h
@@ -322,13 +322,13 @@ Char FlatStringReader::Get(int index) const {
 template <typename Char>
 class SequentialStringKey final : public StringTableKey {
  public:
-  SequentialStringKey(const Vector<const Char>& chars, uint64_t seed,
+  SequentialStringKey(const base::Vector<const Char>& chars, uint64_t seed,
                       bool convert = false)
       : SequentialStringKey(StringHasher::HashSequentialString<Char>(
                                 chars.begin(), chars.length(), seed),
                             chars, convert) {}
 
-  SequentialStringKey(int raw_hash_field, const Vector<const Char>& chars,
+  SequentialStringKey(int raw_hash_field, const base::Vector<const Char>& chars,
                       bool convert = false)
       : StringTableKey(raw_hash_field, chars.length()),
         chars_(chars),
@@ -342,23 +342,23 @@ class SequentialStringKey final : public StringTableKey {
   Handle<String> AsHandle(Isolate* isolate) {
     if (sizeof(Char) == 1) {
       return isolate->factory()->NewOneByteInternalizedString(
-          Vector<const uint8_t>::cast(chars_), raw_hash_field());
+          base::Vector<const uint8_t>::cast(chars_), raw_hash_field());
     }
     return isolate->factory()->NewTwoByteInternalizedString(
-        Vector<const uint16_t>::cast(chars_), raw_hash_field());
+        base::Vector<const uint16_t>::cast(chars_), raw_hash_field());
   }
 
   Handle<String> AsHandle(LocalIsolate* isolate) {
     if (sizeof(Char) == 1) {
       return isolate->factory()->NewOneByteInternalizedString(
-          Vector<const uint8_t>::cast(chars_), raw_hash_field());
+          base::Vector<const uint8_t>::cast(chars_), raw_hash_field());
     }
     return isolate->factory()->NewTwoByteInternalizedString(
-        Vector<const uint16_t>::cast(chars_), raw_hash_field());
+        base::Vector<const uint16_t>::cast(chars_), raw_hash_field());
   }
 
  private:
-  Vector<const Char> chars_;
+  base::Vector<const Char> chars_;
   bool convert_;
 };
 
@@ -403,7 +403,7 @@ class SeqSubStringKey final : public StringTableKey {
     DCHECK(!SharedStringAccessGuardIfNeeded::IsNeeded(*string_));
     DisallowGarbageCollection no_gc;
     return string.IsEqualTo<String::EqualityType::kNoLengthCheck>(
-        Vector<const Char>(string_->GetChars(no_gc) + from_, length()),
+        base::Vector<const Char>(string_->GetChars(no_gc) + from_, length()),
         isolate);
   }
 
@@ -453,28 +453,29 @@ bool String::Equals(Isolate* isolate, Handle<String> one, Handle<String> two) {
 }
 
 template <String::EqualityType kEqType, typename Char>
-bool String::IsEqualTo(Vector<const Char> str, Isolate* isolate) const {
+bool String::IsEqualTo(base::Vector<const Char> str, Isolate* isolate) const {
   DCHECK(!SharedStringAccessGuardIfNeeded::IsNeeded(*this));
   return IsEqualToImpl<kEqType>(str, isolate,
                                 SharedStringAccessGuardIfNeeded::NotNeeded());
 }
 
 template <String::EqualityType kEqType, typename Char>
-bool String::IsEqualTo(Vector<const Char> str) const {
+bool String::IsEqualTo(base::Vector<const Char> str) const {
   DCHECK(!SharedStringAccessGuardIfNeeded::IsNeeded(*this));
   return IsEqualToImpl<kEqType>(str, GetPtrComprCageBase(*this),
                                 SharedStringAccessGuardIfNeeded::NotNeeded());
 }
 
 template <String::EqualityType kEqType, typename Char>
-bool String::IsEqualTo(Vector<const Char> str, LocalIsolate* isolate) const {
+bool String::IsEqualTo(base::Vector<const Char> str,
+                       LocalIsolate* isolate) const {
   SharedStringAccessGuardIfNeeded access_guard(isolate);
   return IsEqualToImpl<kEqType>(str, isolate, access_guard);
 }
 
 template <String::EqualityType kEqType, typename Char>
 bool String::IsEqualToImpl(
-    Vector<const Char> str, PtrComprCageBase cage_base,
+    base::Vector<const Char> str, PtrComprCageBase cage_base,
     const SharedStringAccessGuardIfNeeded& access_guard) const {
   size_t len = str.size();
   switch (kEqType) {
@@ -547,7 +548,7 @@ bool String::IsEqualToImpl(
 // static
 template <typename Char>
 bool String::IsConsStringEqualToImpl(
-    ConsString string, int slice_offset, Vector<const Char> str,
+    ConsString string, int slice_offset, base::Vector<const Char> str,
     PtrComprCageBase cage_base,
     const SharedStringAccessGuardIfNeeded& access_guard) {
   // Already checked the len in IsEqualToImpl. Check GE rather than EQ in case
@@ -555,13 +556,13 @@ bool String::IsConsStringEqualToImpl(
   DCHECK_GE(string.length(), str.size());
 
   ConsStringIterator iter(ConsString::cast(string), slice_offset);
-  Vector<const Char> remaining_str = str;
+  base::Vector<const Char> remaining_str = str;
   for (String segment = iter.Next(&slice_offset); !segment.is_null();
        segment = iter.Next(&slice_offset)) {
     // Compare the individual segment against the appropriate subvector of the
     // remaining string.
     size_t len = std::min<size_t>(segment.length(), remaining_str.size());
-    Vector<const Char> sub_str = remaining_str.SubVector(0, len);
+    base::Vector<const Char> sub_str = remaining_str.SubVector(0, len);
     if (!segment.IsEqualToImpl<EqualityType::kNoLengthCheck>(sub_str, cage_base,
                                                              access_guard)) {
       return false;
@@ -574,7 +575,9 @@ bool String::IsConsStringEqualToImpl(
   return true;
 }
 
-bool String::IsOneByteEqualTo(Vector<const char> str) { return IsEqualTo(str); }
+bool String::IsOneByteEqualTo(base::Vector<const char> str) {
+  return IsEqualTo(str);
+}
 
 template <typename Char>
 const Char* String::GetChars(const DisallowGarbageCollection& no_gc) const {
@@ -755,7 +758,7 @@ ConsString String::VisitFlat(
 }
 
 template <>
-inline Vector<const uint8_t> String::GetCharVector(
+inline base::Vector<const uint8_t> String::GetCharVector(
     const DisallowGarbageCollection& no_gc) {
   String::FlatContent flat = GetFlatContent(no_gc);
   DCHECK(flat.IsOneByte());
@@ -763,7 +766,7 @@ inline Vector<const uint8_t> String::GetCharVector(
 }
 
 template <>
-inline Vector<const uc16> String::GetCharVector(
+inline base::Vector<const uc16> String::GetCharVector(
     const DisallowGarbageCollection& no_gc) {
   String::FlatContent flat = GetFlatContent(no_gc);
   DCHECK(flat.IsTwoByte());
diff --git a/src/objects/string-table.cc b/src/objects/string-table.cc
index 977b9e2dca..de275b8977 100644
--- a/src/objects/string-table.cc
+++ b/src/objects/string-table.cc
@@ -581,7 +581,7 @@ Address StringTable::Data::TryStringToIndexOrLookupExisting(Isolate* isolate,
     chars = source.GetChars<Char>(no_gc) + start;
   }
   // TODO(verwaest): Internalize to one-byte when possible.
-  SequentialStringKey<Char> key(Vector<const Char>(chars, length), seed);
+  SequentialStringKey<Char> key(base::Vector<const Char>(chars, length), seed);
 
   // String could be an array index.
   uint32_t raw_hash_field = key.raw_hash_field();
diff --git a/src/objects/string.cc b/src/objects/string.cc
index 8e08407ab7..886c25ecd7 100644
--- a/src/objects/string.cc
+++ b/src/objects/string.cc
@@ -150,7 +150,7 @@ bool String::MakeExternal(v8::String::ExternalStringResource* resource) {
   if (FLAG_enable_slow_asserts) {
     // Assert that the resource and the string are equivalent.
     DCHECK(static_cast<size_t>(this->length()) == resource->length());
-    ScopedVector<uc16> smart_chars(this->length());
+    base::ScopedVector<uc16> smart_chars(this->length());
     String::WriteToFlat(*this, smart_chars.begin(), 0, this->length());
     DCHECK_EQ(0, memcmp(smart_chars.begin(), resource->data(),
                         resource->length() * sizeof(smart_chars[0])));
@@ -224,11 +224,11 @@ bool String::MakeExternal(v8::String::ExternalOneByteStringResource* resource) {
     // Assert that the resource and the string are equivalent.
     DCHECK(static_cast<size_t>(this->length()) == resource->length());
     if (this->IsTwoByteRepresentation()) {
-      ScopedVector<uint16_t> smart_chars(this->length());
+      base::ScopedVector<uint16_t> smart_chars(this->length());
       String::WriteToFlat(*this, smart_chars.begin(), 0, this->length());
       DCHECK(String::IsOneByte(smart_chars.begin(), this->length()));
     }
-    ScopedVector<char> smart_chars(this->length());
+    base::ScopedVector<char> smart_chars(this->length());
     String::WriteToFlat(*this, smart_chars.begin(), 0, this->length());
     DCHECK_EQ(0, memcmp(smart_chars.begin(), resource->data(),
                         resource->length() * sizeof(smart_chars[0])));
@@ -716,7 +716,7 @@ void String::WriteToFlat(String source, sinkchar* sink, int from, int to,
 
 template <typename SourceChar>
 static void CalculateLineEndsImpl(std::vector<int>* line_ends,
-                                  Vector<const SourceChar> src,
+                                  base::Vector<const SourceChar> src,
                                   bool include_ending_line) {
   const int src_len = src.length();
   for (int i = 0; i < src_len - 1; i++) {
@@ -923,21 +923,21 @@ ComparisonResult String::Compare(Isolate* isolate, Handle<String> x,
   String::FlatContent x_content = x->GetFlatContent(no_gc);
   String::FlatContent y_content = y->GetFlatContent(no_gc);
   if (x_content.IsOneByte()) {
-    Vector<const uint8_t> x_chars = x_content.ToOneByteVector();
+    base::Vector<const uint8_t> x_chars = x_content.ToOneByteVector();
     if (y_content.IsOneByte()) {
-      Vector<const uint8_t> y_chars = y_content.ToOneByteVector();
+      base::Vector<const uint8_t> y_chars = y_content.ToOneByteVector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     } else {
-      Vector<const uc16> y_chars = y_content.ToUC16Vector();
+      base::Vector<const uc16> y_chars = y_content.ToUC16Vector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     }
   } else {
-    Vector<const uc16> x_chars = x_content.ToUC16Vector();
+    base::Vector<const uc16> x_chars = x_content.ToUC16Vector();
     if (y_content.IsOneByte()) {
-      Vector<const uint8_t> y_chars = y_content.ToOneByteVector();
+      base::Vector<const uint8_t> y_chars = y_content.ToOneByteVector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     } else {
-      Vector<const uc16> y_chars = y_content.ToUC16Vector();
+      base::Vector<const uc16> y_chars = y_content.ToUC16Vector();
       r = CompareChars(x_chars.begin(), y_chars.begin(), prefix_length);
     }
   }
@@ -988,7 +988,7 @@ namespace {
 
 template <typename T>
 int SearchString(Isolate* isolate, String::FlatContent receiver_content,
-                 Vector<T> pat_vector, int start_index) {
+                 base::Vector<T> pat_vector, int start_index) {
   if (receiver_content.IsOneByte()) {
     return SearchString(isolate, receiver_content.ToOneByteVector(), pat_vector,
                         start_index);
@@ -1020,11 +1020,11 @@ int String::IndexOf(Isolate* isolate, Handle<String> receiver,
 
   // dispatch on type of strings
   if (search_content.IsOneByte()) {
-    Vector<const uint8_t> pat_vector = search_content.ToOneByteVector();
+    base::Vector<const uint8_t> pat_vector = search_content.ToOneByteVector();
     return SearchString<const uint8_t>(isolate, receiver_content, pat_vector,
                                        start_index);
   }
-  Vector<const uc16> pat_vector = search_content.ToUC16Vector();
+  base::Vector<const uc16> pat_vector = search_content.ToUC16Vector();
   return SearchString<const uc16>(isolate, receiver_content, pat_vector,
                                   start_index);
 }
@@ -1192,8 +1192,8 @@ MaybeHandle<String> String::GetSubstitution(Isolate* isolate, Match* match,
 namespace {  // for String.Prototype.lastIndexOf
 
 template <typename schar, typename pchar>
-int StringMatchBackwards(Vector<const schar> subject,
-                         Vector<const pchar> pattern, int idx) {
+int StringMatchBackwards(base::Vector<const schar> subject,
+                         base::Vector<const pchar> pattern, int idx) {
   int pattern_length = pattern.length();
   DCHECK_GE(pattern_length, 1);
   DCHECK(idx + pattern_length <= subject.length());
@@ -1276,7 +1276,7 @@ Object String::LastIndexOf(Isolate* isolate, Handle<Object> receiver,
   String::FlatContent search_content = search_string->GetFlatContent(no_gc);
 
   if (search_content.IsOneByte()) {
-    Vector<const uint8_t> pat_vector = search_content.ToOneByteVector();
+    base::Vector<const uint8_t> pat_vector = search_content.ToOneByteVector();
     if (receiver_content.IsOneByte()) {
       last_index = StringMatchBackwards(receiver_content.ToOneByteVector(),
                                         pat_vector, start_index);
@@ -1285,7 +1285,7 @@ Object String::LastIndexOf(Isolate* isolate, Handle<Object> receiver,
                                         pat_vector, start_index);
     }
   } else {
-    Vector<const uc16> pat_vector = search_content.ToUC16Vector();
+    base::Vector<const uc16> pat_vector = search_content.ToUC16Vector();
     if (receiver_content.IsOneByte()) {
       last_index = StringMatchBackwards(receiver_content.ToOneByteVector(),
                                         pat_vector, start_index);
@@ -1297,7 +1297,7 @@ Object String::LastIndexOf(Isolate* isolate, Handle<Object> receiver,
   return Smi::FromInt(last_index);
 }
 
-bool String::HasOneBytePrefix(Vector<const char> str) {
+bool String::HasOneBytePrefix(base::Vector<const char> str) {
   DCHECK(!SharedStringAccessGuardIfNeeded::IsNeeded(*this));
   return IsEqualToImpl<EqualityType::kPrefix>(
       str, GetPtrComprCageBase(*this),
diff --git a/src/objects/string.h b/src/objects/string.h
index ecae91d5e7..f56c0a971c 100644
--- a/src/objects/string.h
+++ b/src/objects/string.h
@@ -118,15 +118,15 @@ class String : public TorqueGeneratedString<String, Name> {
 
     // Return the one byte content of the string. Only use if IsOneByte()
     // returns true.
-    Vector<const uint8_t> ToOneByteVector() const {
+    base::Vector<const uint8_t> ToOneByteVector() const {
       DCHECK_EQ(ONE_BYTE, state_);
-      return Vector<const uint8_t>(onebyte_start, length_);
+      return base::Vector<const uint8_t>(onebyte_start, length_);
     }
     // Return the two-byte content of the string. Only use if IsTwoByte()
     // returns true.
-    Vector<const uc16> ToUC16Vector() const {
+    base::Vector<const uc16> ToUC16Vector() const {
       DCHECK_EQ(TWO_BYTE, state_);
-      return Vector<const uc16>(twobyte_start, length_);
+      return base::Vector<const uc16>(twobyte_start, length_);
     }
 
     uc16 Get(int i) const {
@@ -174,7 +174,7 @@ class String : public TorqueGeneratedString<String, Name> {
   void MakeThin(Isolate* isolate, String canonical);
 
   template <typename Char>
-  V8_INLINE Vector<const Char> GetCharVector(
+  V8_INLINE base::Vector<const Char> GetCharVector(
       const DisallowGarbageCollection& no_gc);
 
   // Get chars from sequential or external strings. May only be called when a
@@ -332,7 +332,7 @@ class String : public TorqueGeneratedString<String, Name> {
   // The Isolate is passed as "evidence" that this call is on the main thread,
   // and to distiguish from the LocalIsolate overload.
   template <EqualityType kEqType = EqualityType::kWholeString, typename Char>
-  inline bool IsEqualTo(Vector<const Char> str, Isolate* isolate) const;
+  inline bool IsEqualTo(base::Vector<const Char> str, Isolate* isolate) const;
 
   // Check if this string matches the given vector of characters, either as a
   // whole string or just a prefix.
@@ -340,7 +340,7 @@ class String : public TorqueGeneratedString<String, Name> {
   // This is main-thread only, like the Isolate* overload, but additionally
   // computes the PtrComprCageBase for IsEqualToImpl.
   template <EqualityType kEqType = EqualityType::kWholeString, typename Char>
-  inline bool IsEqualTo(Vector<const Char> str) const;
+  inline bool IsEqualTo(base::Vector<const Char> str) const;
 
   // Check if this string matches the given vector of characters, either as a
   // whole string or just a prefix.
@@ -348,10 +348,11 @@ class String : public TorqueGeneratedString<String, Name> {
   // The LocalIsolate is passed to provide access to the string access lock,
   // which is taken when reading the string's contents on a background thread.
   template <EqualityType kEqType = EqualityType::kWholeString, typename Char>
-  inline bool IsEqualTo(Vector<const Char> str, LocalIsolate* isolate) const;
+  inline bool IsEqualTo(base::Vector<const Char> str,
+                        LocalIsolate* isolate) const;
 
-  V8_EXPORT_PRIVATE bool HasOneBytePrefix(Vector<const char> str);
-  V8_EXPORT_PRIVATE inline bool IsOneByteEqualTo(Vector<const char> str);
+  V8_EXPORT_PRIVATE bool HasOneBytePrefix(base::Vector<const char> str);
+  V8_EXPORT_PRIVATE inline bool IsOneByteEqualTo(base::Vector<const char> str);
 
   // Return a UTF8 representation of the string.  The string is null
   // terminated but may optionally contain nulls.  Length is returned
@@ -552,13 +553,13 @@ class String : public TorqueGeneratedString<String, Name> {
   // Implementation of the IsEqualTo() public methods. Do not use directly.
   template <EqualityType kEqType, typename Char>
   V8_INLINE bool IsEqualToImpl(
-      Vector<const Char> str, PtrComprCageBase cage_base,
+      base::Vector<const Char> str, PtrComprCageBase cage_base,
       const SharedStringAccessGuardIfNeeded& access_guard) const;
 
   // Out-of-line IsEqualToImpl for ConsString.
   template <typename Char>
   V8_NOINLINE static bool IsConsStringEqualToImpl(
-      ConsString string, int slice_offset, Vector<const Char> str,
+      ConsString string, int slice_offset, base::Vector<const Char> str,
       PtrComprCageBase cage_base,
       const SharedStringAccessGuardIfNeeded& access_guard);
 
diff --git a/src/objects/value-serializer.cc b/src/objects/value-serializer.cc
index 0cc2342884..6b302b2973 100644
--- a/src/objects/value-serializer.cc
+++ b/src/objects/value-serializer.cc
@@ -310,12 +310,12 @@ void ValueSerializer::WriteDouble(double value) {
   WriteRawBytes(&value, sizeof(value));
 }
 
-void ValueSerializer::WriteOneByteString(Vector<const uint8_t> chars) {
+void ValueSerializer::WriteOneByteString(base::Vector<const uint8_t> chars) {
   WriteVarint<uint32_t>(chars.length());
   WriteRawBytes(chars.begin(), chars.length() * sizeof(uint8_t));
 }
 
-void ValueSerializer::WriteTwoByteString(Vector<const uc16> chars) {
+void ValueSerializer::WriteTwoByteString(base::Vector<const uc16> chars) {
   // Warning: this uses host endianness.
   WriteVarint<uint32_t>(chars.length() * sizeof(uc16));
   WriteRawBytes(chars.begin(), chars.length() * sizeof(uc16));
@@ -493,11 +493,11 @@ void ValueSerializer::WriteString(Handle<String> string) {
   String::FlatContent flat = string->GetFlatContent(no_gc);
   DCHECK(flat.IsFlat());
   if (flat.IsOneByte()) {
-    Vector<const uint8_t> chars = flat.ToOneByteVector();
+    base::Vector<const uint8_t> chars = flat.ToOneByteVector();
     WriteTag(SerializationTag::kOneByteString);
     WriteOneByteString(chars);
   } else if (flat.IsTwoByte()) {
-    Vector<const uc16> chars = flat.ToUC16Vector();
+    base::Vector<const uc16> chars = flat.ToUC16Vector();
     uint32_t byte_length = chars.length() * sizeof(uc16);
     // The existing reading code expects 16-byte strings to be aligned.
     if ((buffer_size_ + 1 + BytesNeededForVarint(byte_length)) & 1)
@@ -955,17 +955,17 @@ Maybe<bool> ValueSerializer::WriteJSError(Handle<JSObject> error) {
     return Nothing<bool>();
   }
 
-  if (name->IsOneByteEqualTo(CStrVector("EvalError"))) {
+  if (name->IsOneByteEqualTo(base::CStrVector("EvalError"))) {
     WriteVarint(static_cast<uint8_t>(ErrorTag::kEvalErrorPrototype));
-  } else if (name->IsOneByteEqualTo(CStrVector("RangeError"))) {
+  } else if (name->IsOneByteEqualTo(base::CStrVector("RangeError"))) {
     WriteVarint(static_cast<uint8_t>(ErrorTag::kRangeErrorPrototype));
-  } else if (name->IsOneByteEqualTo(CStrVector("ReferenceError"))) {
+  } else if (name->IsOneByteEqualTo(base::CStrVector("ReferenceError"))) {
     WriteVarint(static_cast<uint8_t>(ErrorTag::kReferenceErrorPrototype));
-  } else if (name->IsOneByteEqualTo(CStrVector("SyntaxError"))) {
+  } else if (name->IsOneByteEqualTo(base::CStrVector("SyntaxError"))) {
     WriteVarint(static_cast<uint8_t>(ErrorTag::kSyntaxErrorPrototype));
-  } else if (name->IsOneByteEqualTo(CStrVector("TypeError"))) {
+  } else if (name->IsOneByteEqualTo(base::CStrVector("TypeError"))) {
     WriteVarint(static_cast<uint8_t>(ErrorTag::kTypeErrorPrototype));
-  } else if (name->IsOneByteEqualTo(CStrVector("URIError"))) {
+  } else if (name->IsOneByteEqualTo(base::CStrVector("URIError"))) {
     WriteVarint(static_cast<uint8_t>(ErrorTag::kUriErrorPrototype));
   } else {
     // The default prototype in the deserialization side is Error.prototype, so
@@ -1112,7 +1112,7 @@ void ValueSerializer::ThrowDataCloneError(MessageTemplate index,
 }
 
 ValueDeserializer::ValueDeserializer(Isolate* isolate,
-                                     Vector<const uint8_t> data,
+                                     base::Vector<const uint8_t> data,
                                      v8::ValueDeserializer::Delegate* delegate)
     : isolate_(isolate),
       delegate_(delegate),
@@ -1232,11 +1232,11 @@ Maybe<double> ValueDeserializer::ReadDouble() {
   return Just(value);
 }
 
-Maybe<Vector<const uint8_t>> ValueDeserializer::ReadRawBytes(int size) {
-  if (size > end_ - position_) return Nothing<Vector<const uint8_t>>();
+Maybe<base::Vector<const uint8_t>> ValueDeserializer::ReadRawBytes(int size) {
+  if (size > end_ - position_) return Nothing<base::Vector<const uint8_t>>();
   const uint8_t* start = position_;
   position_ += size;
-  return Just(Vector<const uint8_t>(start, size));
+  return Just(base::Vector<const uint8_t>(start, size));
 }
 
 bool ValueDeserializer::ReadUint32(uint32_t* value) {
@@ -1409,7 +1409,7 @@ MaybeHandle<BigInt> ValueDeserializer::ReadBigInt() {
   uint32_t bitfield;
   if (!ReadVarint<uint32_t>().To(&bitfield)) return MaybeHandle<BigInt>();
   int bytelength = BigInt::DigitsByteLengthForBitfield(bitfield);
-  Vector<const uint8_t> digits_storage;
+  base::Vector<const uint8_t> digits_storage;
   if (!ReadRawBytes(bytelength).To(&digits_storage)) {
     return MaybeHandle<BigInt>();
   }
@@ -1418,7 +1418,7 @@ MaybeHandle<BigInt> ValueDeserializer::ReadBigInt() {
 
 MaybeHandle<String> ValueDeserializer::ReadUtf8String() {
   uint32_t utf8_length;
-  Vector<const uint8_t> utf8_bytes;
+  base::Vector<const uint8_t> utf8_bytes;
   if (!ReadVarint<uint32_t>().To(&utf8_length) ||
       utf8_length >
           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()) ||
@@ -1426,12 +1426,12 @@ MaybeHandle<String> ValueDeserializer::ReadUtf8String() {
     return MaybeHandle<String>();
   }
   return isolate_->factory()->NewStringFromUtf8(
-      Vector<const char>::cast(utf8_bytes));
+      base::Vector<const char>::cast(utf8_bytes));
 }
 
 MaybeHandle<String> ValueDeserializer::ReadOneByteString() {
   uint32_t byte_length;
-  Vector<const uint8_t> bytes;
+  base::Vector<const uint8_t> bytes;
   if (!ReadVarint<uint32_t>().To(&byte_length) ||
       byte_length >
           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()) ||
@@ -1443,7 +1443,7 @@ MaybeHandle<String> ValueDeserializer::ReadOneByteString() {
 
 MaybeHandle<String> ValueDeserializer::ReadTwoByteString() {
   uint32_t byte_length;
-  Vector<const uint8_t> bytes;
+  base::Vector<const uint8_t> bytes;
   if (!ReadVarint<uint32_t>().To(&byte_length) ||
       byte_length >
           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()) ||
@@ -1476,7 +1476,7 @@ bool ValueDeserializer::ReadExpectedString(Handle<String> expected) {
 
   SerializationTag tag;
   uint32_t byte_length;
-  Vector<const uint8_t> bytes;
+  base::Vector<const uint8_t> bytes;
   if (!ReadTag().To(&tag) || !ReadVarint<uint32_t>().To(&byte_length) ||
       byte_length >
           static_cast<uint32_t>(std::numeric_limits<int32_t>::max()) ||
@@ -1490,19 +1490,19 @@ bool ValueDeserializer::ReadExpectedString(Handle<String> expected) {
   // If the bytes are verbatim what is in the flattened string, then the string
   // is successfully consumed.
   if (tag == SerializationTag::kOneByteString && flat.IsOneByte()) {
-    Vector<const uint8_t> chars = flat.ToOneByteVector();
+    base::Vector<const uint8_t> chars = flat.ToOneByteVector();
     if (byte_length == static_cast<size_t>(chars.length()) &&
         memcmp(bytes.begin(), chars.begin(), byte_length) == 0) {
       return true;
     }
   } else if (tag == SerializationTag::kTwoByteString && flat.IsTwoByte()) {
-    Vector<const uc16> chars = flat.ToUC16Vector();
+    base::Vector<const uc16> chars = flat.ToUC16Vector();
     if (byte_length == static_cast<unsigned>(chars.length()) * sizeof(uc16) &&
         memcmp(bytes.begin(), chars.begin(), byte_length) == 0) {
       return true;
     }
   } else if (tag == SerializationTag::kUtf8String && flat.IsOneByte()) {
-    Vector<const uint8_t> chars = flat.ToOneByteVector();
+    base::Vector<const uint8_t> chars = flat.ToOneByteVector();
     if (byte_length == static_cast<size_t>(chars.length()) &&
         String::IsAscii(chars.begin(), chars.length()) &&
         memcmp(bytes.begin(), chars.begin(), byte_length) == 0) {
diff --git a/src/objects/value-serializer.h b/src/objects/value-serializer.h
index d4304ab22c..3b9e3a7361 100644
--- a/src/objects/value-serializer.h
+++ b/src/objects/value-serializer.h
@@ -11,10 +11,10 @@
 #include "include/v8.h"
 #include "src/base/compiler-specific.h"
 #include "src/base/macros.h"
+#include "src/base/vector.h"
 #include "src/common/message-template.h"
 #include "src/handles/maybe-handles.h"
 #include "src/utils/identity-map.h"
-#include "src/utils/vector.h"
 #include "src/zone/zone.h"
 
 namespace v8 {
@@ -105,8 +105,8 @@ class ValueSerializer {
   void WriteVarint(T value);
   template <typename T>
   void WriteZigZag(T value);
-  void WriteOneByteString(Vector<const uint8_t> chars);
-  void WriteTwoByteString(Vector<const uc16> chars);
+  void WriteOneByteString(base::Vector<const uint8_t> chars);
+  void WriteTwoByteString(base::Vector<const uc16> chars);
   void WriteBigIntContents(BigInt bigint);
   Maybe<uint8_t*> ReserveRawBytes(size_t bytes);
 
@@ -182,7 +182,7 @@ class ValueSerializer {
  */
 class ValueDeserializer {
  public:
-  ValueDeserializer(Isolate* isolate, Vector<const uint8_t> data,
+  ValueDeserializer(Isolate* isolate, base::Vector<const uint8_t> data,
                     v8::ValueDeserializer::Delegate* delegate);
   ValueDeserializer(Isolate* isolate, const uint8_t* data, size_t size);
   ~ValueDeserializer();
@@ -244,7 +244,8 @@ class ValueDeserializer {
   template <typename T>
   Maybe<T> ReadZigZag() V8_WARN_UNUSED_RESULT;
   Maybe<double> ReadDouble() V8_WARN_UNUSED_RESULT;
-  Maybe<Vector<const uint8_t>> ReadRawBytes(int size) V8_WARN_UNUSED_RESULT;
+  Maybe<base::Vector<const uint8_t>> ReadRawBytes(int size)
+      V8_WARN_UNUSED_RESULT;
 
   // Reads a string if it matches the one provided.
   // Returns true if this was the case. Otherwise, nothing is consumed.
diff --git a/src/parsing/literal-buffer.cc b/src/parsing/literal-buffer.cc
index a3e665a5c3..de74b4d9f1 100644
--- a/src/parsing/literal-buffer.cc
+++ b/src/parsing/literal-buffer.cc
@@ -31,7 +31,8 @@ int LiteralBuffer::NewCapacity(int min_capacity) {
 
 void LiteralBuffer::ExpandBuffer() {
   int min_capacity = std::max({kInitialCapacity, backing_store_.length()});
-  Vector<byte> new_store = Vector<byte>::New(NewCapacity(min_capacity));
+  base::Vector<byte> new_store =
+      base::Vector<byte>::New(NewCapacity(min_capacity));
   if (position_ > 0) {
     MemCopy(new_store.begin(), backing_store_.begin(), position_);
   }
@@ -41,12 +42,12 @@ void LiteralBuffer::ExpandBuffer() {
 
 void LiteralBuffer::ConvertToTwoByte() {
   DCHECK(is_one_byte());
-  Vector<byte> new_store;
+  base::Vector<byte> new_store;
   int new_content_size = position_ * kUC16Size;
   if (new_content_size >= backing_store_.length()) {
     // Ensure room for all currently read code units as UC16 as well
     // as the code unit about to be stored.
-    new_store = Vector<byte>::New(NewCapacity(new_content_size));
+    new_store = base::Vector<byte>::New(NewCapacity(new_content_size));
   } else {
     new_store = backing_store_;
   }
diff --git a/src/parsing/literal-buffer.h b/src/parsing/literal-buffer.h
index 3a3457082c..0f28b16b34 100644
--- a/src/parsing/literal-buffer.h
+++ b/src/parsing/literal-buffer.h
@@ -5,8 +5,8 @@
 #ifndef V8_PARSING_LITERAL_BUFFER_H_
 #define V8_PARSING_LITERAL_BUFFER_H_
 
+#include "src/base/vector.h"
 #include "src/strings/unicode-decoder.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -39,22 +39,24 @@ class LiteralBuffer final {
 
   bool is_one_byte() const { return is_one_byte_; }
 
-  bool Equals(Vector<const char> keyword) const {
+  bool Equals(base::Vector<const char> keyword) const {
     return is_one_byte() && keyword.length() == position_ &&
            (memcmp(keyword.begin(), backing_store_.begin(), position_) == 0);
   }
 
-  Vector<const uint16_t> two_byte_literal() const {
+  base::Vector<const uint16_t> two_byte_literal() const {
     return literal<uint16_t>();
   }
 
-  Vector<const uint8_t> one_byte_literal() const { return literal<uint8_t>(); }
+  base::Vector<const uint8_t> one_byte_literal() const {
+    return literal<uint8_t>();
+  }
 
   template <typename Char>
-  Vector<const Char> literal() const {
+  base::Vector<const Char> literal() const {
     DCHECK_EQ(is_one_byte_, sizeof(Char) == 1);
     DCHECK_EQ(position_ & (sizeof(Char) - 1), 0);
-    return Vector<const Char>(
+    return base::Vector<const Char>(
         reinterpret_cast<const Char*>(backing_store_.begin()),
         position_ >> (sizeof(Char) - 1));
   }
@@ -94,7 +96,7 @@ class LiteralBuffer final {
   void ExpandBuffer();
   void ConvertToTwoByte();
 
-  Vector<byte> backing_store_;
+  base::Vector<byte> backing_store_;
   int position_;
 
   bool is_one_byte_;
diff --git a/src/parsing/parser.h b/src/parsing/parser.h
index 07efef277e..64d57d992f 100644
--- a/src/parsing/parser.h
+++ b/src/parsing/parser.h
@@ -772,7 +772,8 @@ class V8_EXPORT_PRIVATE Parser : public NON_EXPORTED_BASE(ParserBase<Parser>) {
   V8_INLINE const AstRawString* GetNumberAsSymbol() const {
     double double_value = scanner()->DoubleValue();
     char array[100];
-    const char* string = DoubleToCString(double_value, ArrayVector(array));
+    const char* string =
+        DoubleToCString(double_value, base::ArrayVector(array));
     return ast_value_factory()->GetOneByteString(string);
   }
 
diff --git a/src/parsing/pending-compilation-error-handler.cc b/src/parsing/pending-compilation-error-handler.cc
index 2ab5b3eb1a..60bc8ada27 100644
--- a/src/parsing/pending-compilation-error-handler.cc
+++ b/src/parsing/pending-compilation-error-handler.cc
@@ -61,7 +61,7 @@ Handle<String> PendingCompilationErrorHandler::MessageDetails::ArgumentString(
       return isolate->factory()->undefined_string();
     case kConstCharString:
       return isolate->factory()
-          ->NewStringFromUtf8(CStrVector(char_arg_), AllocationType::kOld)
+          ->NewStringFromUtf8(base::CStrVector(char_arg_), AllocationType::kOld)
           .ToHandleChecked();
     case kAstRawString:
       UNREACHABLE();
diff --git a/src/parsing/preparse-data-impl.h b/src/parsing/preparse-data-impl.h
index 937244f30b..eb528fa645 100644
--- a/src/parsing/preparse-data-impl.h
+++ b/src/parsing/preparse-data-impl.h
@@ -195,7 +195,8 @@ class OnHeapConsumedPreparseData final
 // A serialized PreparseData in zone memory (as apposed to being on-heap).
 class ZonePreparseData : public ZoneObject {
  public:
-  V8_EXPORT_PRIVATE ZonePreparseData(Zone* zone, Vector<uint8_t>* byte_data,
+  V8_EXPORT_PRIVATE ZonePreparseData(Zone* zone,
+                                     base::Vector<uint8_t>* byte_data,
                                      int child_length);
 
   ZonePreparseData(const ZonePreparseData&) = delete;
diff --git a/src/parsing/preparse-data.cc b/src/parsing/preparse-data.cc
index 06968fe0c2..1643c6ba1a 100644
--- a/src/parsing/preparse-data.cc
+++ b/src/parsing/preparse-data.cc
@@ -136,7 +136,7 @@ void PreparseDataBuilder::ByteData::Finalize(Zone* zone) {
   uint8_t* raw_zone_data = zone->NewArray<uint8_t, RawPreparseData>(index_);
   memcpy(raw_zone_data, byte_data_->data(), index_);
   byte_data_->resize(0);
-  zone_byte_data_ = Vector<uint8_t>(raw_zone_data, index_);
+  zone_byte_data_ = base::Vector<uint8_t>(raw_zone_data, index_);
 #ifdef DEBUG
   is_finalized_ = true;
 #endif
@@ -255,7 +255,7 @@ void PreparseDataBuilder::AddChild(PreparseDataBuilder* child) {
 
 void PreparseDataBuilder::FinalizeChildren(Zone* zone) {
   DCHECK(!finalized_children_);
-  Vector<PreparseDataBuilder*> children =
+  base::Vector<PreparseDataBuilder*> children =
       CloneVector(zone, children_buffer_.ToConstVector());
   children_buffer_.Rewind();
   children_ = children;
@@ -774,7 +774,7 @@ OnHeapConsumedPreparseData::OnHeapConsumedPreparseData(
   DCHECK(VerifyDataStart());
 }
 
-ZonePreparseData::ZonePreparseData(Zone* zone, Vector<uint8_t>* byte_data,
+ZonePreparseData::ZonePreparseData(Zone* zone, base::Vector<uint8_t>* byte_data,
                                    int children_length)
     : byte_data_(byte_data->begin(), byte_data->end(), zone),
       children_(children_length, zone) {}
diff --git a/src/parsing/preparse-data.h b/src/parsing/preparse-data.h
index 1c4695a0ae..8132ac1dc5 100644
--- a/src/parsing/preparse-data.h
+++ b/src/parsing/preparse-data.h
@@ -7,11 +7,11 @@
 
 #include <memory>
 
+#include "src/base/vector.h"
 #include "src/common/globals.h"
 #include "src/handles/handles.h"
 #include "src/handles/maybe-handles.h"
 #include "src/utils/scoped-list.h"
-#include "src/utils/vector.h"
 #include "src/zone/zone-chunk-list.h"
 #include "src/zone/zone-containers.h"
 
@@ -168,7 +168,7 @@ class V8_EXPORT_PRIVATE PreparseDataBuilder : public ZoneObject,
       };
       // Once the data is finalized, it lives in a Zone, this implies
       // is_finalized_ == true.
-      Vector<uint8_t> zone_byte_data_;
+      base::Vector<uint8_t> zone_byte_data_;
     };
     uint8_t free_quarters_in_last_byte_;
 
@@ -228,7 +228,7 @@ class V8_EXPORT_PRIVATE PreparseDataBuilder : public ZoneObject,
   ByteData byte_data_;
   union {
     ScopedPtrList<PreparseDataBuilder> children_buffer_;
-    Vector<PreparseDataBuilder*> children_;
+    base::Vector<PreparseDataBuilder*> children_;
   };
 
   DeclarationScope* function_scope_;
diff --git a/src/parsing/scanner-inl.h b/src/parsing/scanner-inl.h
index b255dccc05..6bcc12cfd9 100644
--- a/src/parsing/scanner-inl.h
+++ b/src/parsing/scanner-inl.h
@@ -296,7 +296,8 @@ V8_INLINE Token::Value Scanner::ScanIdentifierOrKeywordInner() {
       if (V8_LIKELY(!IdentifierNeedsSlowPath(scan_flags))) {
         if (!CanBeKeyword(scan_flags)) return Token::IDENTIFIER;
         // Could be a keyword or identifier.
-        Vector<const uint8_t> chars = next().literal_chars.one_byte_literal();
+        base::Vector<const uint8_t> chars =
+            next().literal_chars.one_byte_literal();
         return KeywordOrIdentifierToken(chars.begin(), chars.length());
       }
 
diff --git a/src/parsing/scanner.cc b/src/parsing/scanner.cc
index ecaecd7b4a..6dd3dbcb0f 100644
--- a/src/parsing/scanner.cc
+++ b/src/parsing/scanner.cc
@@ -237,11 +237,11 @@ void Scanner::TryToParseSourceURLComment() {
     Advance();
   }
   if (!name.is_one_byte()) return;
-  Vector<const uint8_t> name_literal = name.one_byte_literal();
+  base::Vector<const uint8_t> name_literal = name.one_byte_literal();
   LiteralBuffer* value;
-  if (name_literal == StaticOneByteVector("sourceURL")) {
+  if (name_literal == base::StaticOneByteVector("sourceURL")) {
     value = &source_url_;
-  } else if (name_literal == StaticOneByteVector("sourceMappingURL")) {
+  } else if (name_literal == base::StaticOneByteVector("sourceMappingURL")) {
     value = &source_mapping_url_;
   } else {
     return;
@@ -922,7 +922,7 @@ Token::Value Scanner::ScanIdentifierOrKeywordInnerSlow(bool escaped,
   }
 
   if (can_be_keyword && next().literal_chars.is_one_byte()) {
-    Vector<const uint8_t> chars = next().literal_chars.one_byte_literal();
+    base::Vector<const uint8_t> chars = next().literal_chars.one_byte_literal();
     Token::Value token =
         KeywordOrIdentifierToken(chars.begin(), chars.length());
     if (base::IsInRange(token, Token::IDENTIFIER, Token::YIELD)) return token;
@@ -1043,7 +1043,7 @@ double Scanner::DoubleValue() {
 
 const char* Scanner::CurrentLiteralAsCString(Zone* zone) const {
   DCHECK(is_literal_one_byte());
-  Vector<const uint8_t> vector = literal_one_byte_string();
+  base::Vector<const uint8_t> vector = literal_one_byte_string();
   int length = vector.length();
   char* buffer = zone->NewArray<char>(length + 1);
   memcpy(buffer, vector.begin(), length);
diff --git a/src/parsing/scanner.h b/src/parsing/scanner.h
index d93f581366..fc1eb7b0c1 100644
--- a/src/parsing/scanner.h
+++ b/src/parsing/scanner.h
@@ -350,7 +350,7 @@ class V8_EXPORT_PRIVATE Scanner {
     if (!is_next_literal_one_byte()) return false;
     if (peek_location().length() != N + 1) return false;
 
-    Vector<const uint8_t> next = next_literal_one_byte_string();
+    base::Vector<const uint8_t> next = next_literal_one_byte_string();
     const char* chars = reinterpret_cast<const char*>(next.begin());
     return next.length() == N - 1 && strncmp(s, chars, N - 1) == 0;
   }
@@ -360,7 +360,7 @@ class V8_EXPORT_PRIVATE Scanner {
     DCHECK(current().CanAccessLiteral());
     if (!is_literal_one_byte()) return false;
 
-    Vector<const uint8_t> current = literal_one_byte_string();
+    base::Vector<const uint8_t> current = literal_one_byte_string();
     const char* chars = reinterpret_cast<const char*>(current.begin());
     return current.length() == N - 1 && strncmp(s, chars, N - 1) == 0;
   }
@@ -579,12 +579,12 @@ class V8_EXPORT_PRIVATE Scanner {
   // requested for tokens that do not have a literal. Hence, we treat any
   // token as a one-byte literal. E.g. Token::FUNCTION pretends to have a
   // literal "function".
-  Vector<const uint8_t> literal_one_byte_string() const {
+  base::Vector<const uint8_t> literal_one_byte_string() const {
     DCHECK(current().CanAccessLiteral() || Token::IsKeyword(current().token) ||
            current().token == Token::ESCAPED_KEYWORD);
     return current().literal_chars.one_byte_literal();
   }
-  Vector<const uint16_t> literal_two_byte_string() const {
+  base::Vector<const uint16_t> literal_two_byte_string() const {
     DCHECK(current().CanAccessLiteral() || Token::IsKeyword(current().token) ||
            current().token == Token::ESCAPED_KEYWORD);
     return current().literal_chars.two_byte_literal();
@@ -596,11 +596,11 @@ class V8_EXPORT_PRIVATE Scanner {
   }
   // Returns the literal string for the next token (the token that
   // would be returned if Next() were called).
-  Vector<const uint8_t> next_literal_one_byte_string() const {
+  base::Vector<const uint8_t> next_literal_one_byte_string() const {
     DCHECK(next().CanAccessLiteral());
     return next().literal_chars.one_byte_literal();
   }
-  Vector<const uint16_t> next_literal_two_byte_string() const {
+  base::Vector<const uint16_t> next_literal_two_byte_string() const {
     DCHECK(next().CanAccessLiteral());
     return next().literal_chars.two_byte_literal();
   }
@@ -608,11 +608,11 @@ class V8_EXPORT_PRIVATE Scanner {
     DCHECK(next().CanAccessLiteral());
     return next().literal_chars.is_one_byte();
   }
-  Vector<const uint8_t> raw_literal_one_byte_string() const {
+  base::Vector<const uint8_t> raw_literal_one_byte_string() const {
     DCHECK(current().CanAccessRawLiteral());
     return current().raw_literal_chars.one_byte_literal();
   }
-  Vector<const uint16_t> raw_literal_two_byte_string() const {
+  base::Vector<const uint16_t> raw_literal_two_byte_string() const {
     DCHECK(current().CanAccessRawLiteral());
     return current().raw_literal_chars.two_byte_literal();
   }
diff --git a/src/profiler/allocation-tracker.cc b/src/profiler/allocation-tracker.cc
index 4181fbfae3..9bba48521c 100644
--- a/src/profiler/allocation-tracker.cc
+++ b/src/profiler/allocation-tracker.cc
@@ -76,7 +76,7 @@ AllocationTraceTree::AllocationTraceTree()
 }
 
 AllocationTraceNode* AllocationTraceTree::AddPathFromEnd(
-    const Vector<unsigned>& path) {
+    const base::Vector<unsigned>& path) {
   AllocationTraceNode* node = root();
   for (unsigned* entry = path.begin() + path.length() - 1;
        entry != path.begin() - 1; --entry) {
@@ -85,7 +85,6 @@ AllocationTraceNode* AllocationTraceTree::AddPathFromEnd(
   return node;
 }
 
-
 void AllocationTraceTree::Print(AllocationTracker* tracker) {
   base::OS::Print("[AllocationTraceTree:]\n");
   base::OS::Print("Total size | Allocation count | Function id | id\n");
@@ -225,7 +224,7 @@ void AllocationTracker::AllocationEvent(Address addr, int size) {
     }
   }
   AllocationTraceNode* top_node = trace_tree_.AddPathFromEnd(
-      Vector<unsigned>(allocation_trace_buffer_, length));
+      base::Vector<unsigned>(allocation_trace_buffer_, length));
   top_node->AddAllocation(size);
 
   address_to_trace_.AddRange(addr, size, top_node->id());
diff --git a/src/profiler/allocation-tracker.h b/src/profiler/allocation-tracker.h
index 2c17ec6980..36b9e91883 100644
--- a/src/profiler/allocation-tracker.h
+++ b/src/profiler/allocation-tracker.h
@@ -10,7 +10,7 @@
 
 #include "include/v8-profiler.h"
 #include "src/base/hashmap.h"
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 #include "src/handles/handles.h"
 
 namespace v8 {
@@ -60,7 +60,7 @@ class AllocationTraceTree {
   ~AllocationTraceTree() = default;
   AllocationTraceTree(const AllocationTraceTree&) = delete;
   AllocationTraceTree& operator=(const AllocationTraceTree&) = delete;
-  AllocationTraceNode* AddPathFromEnd(const Vector<unsigned>& path);
+  AllocationTraceNode* AddPathFromEnd(const base::Vector<unsigned>& path);
   AllocationTraceNode* root() { return &root_; }
   unsigned next_node_id() { return next_node_id_++; }
   V8_EXPORT_PRIVATE void Print(AllocationTracker* tracker);
diff --git a/src/profiler/heap-snapshot-generator.cc b/src/profiler/heap-snapshot-generator.cc
index 6e93a91189..6d11f65291 100644
--- a/src/profiler/heap-snapshot-generator.cc
+++ b/src/profiler/heap-snapshot-generator.cc
@@ -8,6 +8,7 @@
 
 #include "src/api/api-inl.h"
 #include "src/base/optional.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/common/globals.h"
 #include "src/debug/debug.h"
@@ -37,7 +38,6 @@
 #include "src/profiler/allocation-tracker.h"
 #include "src/profiler/heap-profiler.h"
 #include "src/profiler/heap-snapshot-generator-inl.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -126,7 +126,7 @@ void HeapEntry::Print(const char* prefix, const char* edge_name, int max_depth,
   for (auto i = children_begin(); i != children_end(); ++i) {
     HeapGraphEdge& edge = **i;
     const char* edge_prefix = "";
-    EmbeddedVector<char, 64> index;
+    base::EmbeddedVector<char, 64> index;
     const char* edge_name = index.begin();
     switch (edge.type()) {
       case HeapGraphEdge::kContextVariable:
@@ -1323,7 +1323,7 @@ void V8HeapExplorer::ExtractNumberReference(HeapEntry* entry, Object number) {
 
   // Must be large enough to fit any double, int, or size_t.
   char arr[32];
-  Vector<char> buffer(arr, arraysize(arr));
+  base::Vector<char> buffer(arr, arraysize(arr));
 
   const char* string;
   if (number.IsSmi()) {
@@ -2339,7 +2339,7 @@ class OutputStreamWriter {
       chunk_pos_ += result;
       MaybeWriteChunk();
     } else {
-      EmbeddedVector<char, kMaxNumberSize> buffer;
+      base::EmbeddedVector<char, kMaxNumberSize> buffer;
       int result = SNPrintF(buffer, format, n);
       USE(result);
       DCHECK_NE(result, -1);
@@ -2362,7 +2362,7 @@ class OutputStreamWriter {
 
   v8::OutputStream* stream_;
   int chunk_size_;
-  ScopedVector<char> chunk_;
+  base::ScopedVector<char> chunk_;
   int chunk_pos_;
   bool aborted_;
 };
@@ -2459,9 +2459,9 @@ template<> struct ToUnsigned<8> {
 
 }  // namespace
 
-
-template<typename T>
-static int utoa_impl(T value, const Vector<char>& buffer, int buffer_pos) {
+template <typename T>
+static int utoa_impl(T value, const base::Vector<char>& buffer,
+                     int buffer_pos) {
   STATIC_ASSERT(static_cast<T>(-1) > 0);  // Check that T is unsigned
   int number_of_digits = 0;
   T t = value;
@@ -2479,21 +2479,19 @@ static int utoa_impl(T value, const Vector<char>& buffer, int buffer_pos) {
   return result;
 }
 
-
-template<typename T>
-static int utoa(T value, const Vector<char>& buffer, int buffer_pos) {
+template <typename T>
+static int utoa(T value, const base::Vector<char>& buffer, int buffer_pos) {
   typename ToUnsigned<sizeof(value)>::Type unsigned_value = value;
   STATIC_ASSERT(sizeof(value) == sizeof(unsigned_value));
   return utoa_impl(unsigned_value, buffer, buffer_pos);
 }
 
-
 void HeapSnapshotJSONSerializer::SerializeEdge(HeapGraphEdge* edge,
                                                bool first_edge) {
   // The buffer needs space for 3 unsigned ints, 3 commas, \n and \0
   static const int kBufferSize =
       MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned * 3 + 3 + 2;  // NOLINT
-  EmbeddedVector<char, kBufferSize> buffer;
+  base::EmbeddedVector<char, kBufferSize> buffer;
   int edge_name_or_index = edge->type() == HeapGraphEdge::kElement
       || edge->type() == HeapGraphEdge::kHidden
       ? edge->index() : GetStringId(edge->name());
@@ -2528,7 +2526,7 @@ void HeapSnapshotJSONSerializer::SerializeNode(const HeapEntry* entry) {
       5 * MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned  // NOLINT
       + MaxDecimalDigitsIn<sizeof(size_t)>::kUnsigned      // NOLINT
       + MaxDecimalDigitsIn<sizeof(uint8_t)>::kUnsigned + 7 + 1 + 1;
-  EmbeddedVector<char, kBufferSize> buffer;
+  base::EmbeddedVector<char, kBufferSize> buffer;
   int buffer_pos = 0;
   if (to_node_index(entry) != 0) {
     buffer[buffer_pos++] = ',';
@@ -2676,7 +2674,7 @@ void HeapSnapshotJSONSerializer::SerializeTraceNode(AllocationTraceNode* node) {
   const int kBufferSize =
       4 * MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned  // NOLINT
       + 4 + 1 + 1;
-  EmbeddedVector<char, kBufferSize> buffer;
+  base::EmbeddedVector<char, kBufferSize> buffer;
   int buffer_pos = 0;
   buffer_pos = utoa(node->id(), buffer, buffer_pos);
   buffer[buffer_pos++] = ',';
@@ -2702,7 +2700,7 @@ void HeapSnapshotJSONSerializer::SerializeTraceNode(AllocationTraceNode* node) {
 
 
 // 0-based position is converted to 1-based during the serialization.
-static int SerializePosition(int position, const Vector<char>& buffer,
+static int SerializePosition(int position, const base::Vector<char>& buffer,
                              int buffer_pos) {
   if (position == -1) {
     buffer[buffer_pos++] = '0';
@@ -2713,7 +2711,6 @@ static int SerializePosition(int position, const Vector<char>& buffer,
   return buffer_pos;
 }
 
-
 void HeapSnapshotJSONSerializer::SerializeTraceNodeInfos() {
   AllocationTracker* tracker = snapshot_->profiler()->allocation_tracker();
   if (!tracker) return;
@@ -2721,7 +2718,7 @@ void HeapSnapshotJSONSerializer::SerializeTraceNodeInfos() {
   const int kBufferSize =
       6 * MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned  // NOLINT
       + 6 + 1 + 1;
-  EmbeddedVector<char, kBufferSize> buffer;
+  base::EmbeddedVector<char, kBufferSize> buffer;
   int i = 0;
   for (AllocationTracker::FunctionInfo* info : tracker->function_info_list()) {
     int buffer_pos = 0;
@@ -2758,7 +2755,7 @@ void HeapSnapshotJSONSerializer::SerializeSamples() {
                               base::TimeDelta().InMicroseconds())>::kUnsigned +
                           MaxDecimalDigitsIn<sizeof(samples[0].id)>::kUnsigned +
                           2 + 1 + 1;
-  EmbeddedVector<char, kBufferSize> buffer;
+  base::EmbeddedVector<char, kBufferSize> buffer;
   int i = 0;
   for (const HeapObjectsMap::TimeInterval& sample : samples) {
     int buffer_pos = 0;
@@ -2827,8 +2824,8 @@ void HeapSnapshotJSONSerializer::SerializeString(const unsigned char* s) {
 
 
 void HeapSnapshotJSONSerializer::SerializeStrings() {
-  ScopedVector<const unsigned char*> sorted_strings(
-      strings_.occupancy() + 1);
+  base::ScopedVector<const unsigned char*> sorted_strings(strings_.occupancy() +
+                                                          1);
   for (base::HashMap::Entry* entry = strings_.Start(); entry != nullptr;
        entry = strings_.Next(entry)) {
     int index = static_cast<int>(reinterpret_cast<uintptr_t>(entry->value));
@@ -2847,7 +2844,7 @@ void HeapSnapshotJSONSerializer::SerializeLocation(
   // The buffer needs space for 4 unsigned ints, 3 commas, \n and \0
   static const int kBufferSize =
       MaxDecimalDigitsIn<sizeof(unsigned)>::kUnsigned * 4 + 3 + 2;
-  EmbeddedVector<char, kBufferSize> buffer;
+  base::EmbeddedVector<char, kBufferSize> buffer;
   int buffer_pos = 0;
   buffer_pos = utoa(to_node_index(location.entry_index), buffer, buffer_pos);
   buffer[buffer_pos++] = ',';
diff --git a/src/profiler/profiler-listener.cc b/src/profiler/profiler-listener.cc
index 3c14e20e66..290c888439 100644
--- a/src/profiler/profiler-listener.cc
+++ b/src/profiler/profiler-listener.cc
@@ -6,6 +6,7 @@
 
 #include <algorithm>
 
+#include "src/base/vector.h"
 #include "src/codegen/reloc-info.h"
 #include "src/codegen/source-position-table.h"
 #include "src/deoptimizer/deoptimizer.h"
@@ -18,7 +19,6 @@
 #include "src/objects/string-inl.h"
 #include "src/profiler/cpu-profiler.h"
 #include "src/profiler/profile-generator-inl.h"
-#include "src/utils/vector.h"
 
 #if V8_ENABLE_WEBASSEMBLY
 #include "src/wasm/wasm-code-manager.h"
@@ -351,9 +351,10 @@ void ProfilerListener::OnHeapObjectDeletion(CodeEntry* entry) {
 
 void ProfilerListener::CodeSweepEvent() { weak_code_registry_.Sweep(this); }
 
-const char* ProfilerListener::GetName(Vector<const char> name) {
+const char* ProfilerListener::GetName(base::Vector<const char> name) {
   // TODO(all): Change {StringsStorage} to accept non-null-terminated strings.
-  OwnedVector<char> null_terminated = OwnedVector<char>::New(name.size() + 1);
+  base::OwnedVector<char> null_terminated =
+      base::OwnedVector<char>::New(name.size() + 1);
   std::copy(name.begin(), name.end(), null_terminated.begin());
   null_terminated[name.size()] = '\0';
   return GetName(null_terminated.begin());
diff --git a/src/profiler/profiler-listener.h b/src/profiler/profiler-listener.h
index de2d1ec997..bcdd1b7b05 100644
--- a/src/profiler/profiler-listener.h
+++ b/src/profiler/profiler-listener.h
@@ -84,7 +84,7 @@ class V8_EXPORT_PRIVATE ProfilerListener : public CodeEventListener,
   const char* GetName(const char* name) {
     return code_entries_.strings().GetCopy(name);
   }
-  const char* GetName(Vector<const char> name);
+  const char* GetName(base::Vector<const char> name);
   const char* GetConsName(const char* prefix, Name name) {
     return code_entries_.strings().GetConsName(prefix, name);
   }
diff --git a/src/profiler/strings-storage.cc b/src/profiler/strings-storage.cc
index f149920820..1c8a23cadc 100644
--- a/src/profiler/strings-storage.cc
+++ b/src/profiler/strings-storage.cc
@@ -31,7 +31,7 @@ const char* StringsStorage::GetCopy(const char* src) {
   int len = static_cast<int>(strlen(src));
   base::HashMap::Entry* entry = GetEntry(src, len);
   if (entry->value == nullptr) {
-    Vector<char> dst = Vector<char>::New(len + 1);
+    base::Vector<char> dst = base::Vector<char>::New(len + 1);
     StrNCpy(dst, src, len);
     dst[len] = '\0';
     entry->key = dst.begin();
@@ -64,7 +64,7 @@ const char* StringsStorage::AddOrDisposeString(char* str, int len) {
 }
 
 const char* StringsStorage::GetVFormatted(const char* format, va_list args) {
-  Vector<char> str = Vector<char>::New(1024);
+  base::Vector<char> str = base::Vector<char>::New(1024);
   int len = VSNPrintF(str, format, args);
   if (len == -1) {
     DeleteArray(str.begin());
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.cc b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
index 72821e61c5..72186cfc25 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.cc
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.cc
@@ -258,11 +258,10 @@ void RegExpMacroAssemblerARM64::CheckCharacterLT(uc16 limit, Label* on_less) {
   CompareAndBranchOrBacktrack(current_character(), limit, lo, on_less);
 }
 
-
-void RegExpMacroAssemblerARM64::CheckCharacters(Vector<const uc16> str,
-                                              int cp_offset,
-                                              Label* on_failure,
-                                              bool check_end_of_string) {
+void RegExpMacroAssemblerARM64::CheckCharacters(base::Vector<const uc16> str,
+                                                int cp_offset,
+                                                Label* on_failure,
+                                                bool check_end_of_string) {
   // This method is only ever called from the cctests.
 
   if (check_end_of_string) {
@@ -290,7 +289,6 @@ void RegExpMacroAssemblerARM64::CheckCharacters(Vector<const uc16> str,
   }
 }
 
-
 void RegExpMacroAssemblerARM64::CheckGreedyLoop(Label* on_equal) {
   __ Ldr(w10, MemOperand(backtrack_stackpointer()));
   __ Cmp(current_input_offset(), w10);
diff --git a/src/regexp/arm64/regexp-macro-assembler-arm64.h b/src/regexp/arm64/regexp-macro-assembler-arm64.h
index ad4695b164..253bdec8fb 100644
--- a/src/regexp/arm64/regexp-macro-assembler-arm64.h
+++ b/src/regexp/arm64/regexp-macro-assembler-arm64.h
@@ -31,10 +31,8 @@ class V8_EXPORT_PRIVATE RegExpMacroAssemblerARM64
                                       Label* on_equal);
   virtual void CheckCharacterGT(uc16 limit, Label* on_greater);
   virtual void CheckCharacterLT(uc16 limit, Label* on_less);
-  virtual void CheckCharacters(Vector<const uc16> str,
-                               int cp_offset,
-                               Label* on_failure,
-                               bool check_end_of_string);
+  virtual void CheckCharacters(base::Vector<const uc16> str, int cp_offset,
+                               Label* on_failure, bool check_end_of_string);
   // A "greedy loop" is a loop that is both greedy and with a simple
   // body. It has a particularly simple implementation.
   virtual void CheckGreedyLoop(Label* on_tos_equals_current_position);
diff --git a/src/regexp/experimental/experimental-bytecode.cc b/src/regexp/experimental/experimental-bytecode.cc
index d61bc3afd1..8dc51d1696 100644
--- a/src/regexp/experimental/experimental-bytecode.cc
+++ b/src/regexp/experimental/experimental-bytecode.cc
@@ -91,7 +91,7 @@ int DigitsRequiredBelow(int n) {
 }  // namespace
 
 std::ostream& operator<<(std::ostream& os,
-                         Vector<const RegExpInstruction> insts) {
+                         base::Vector<const RegExpInstruction> insts) {
   int inst_num = insts.length();
   int line_digit_num = DigitsRequiredBelow(inst_num);
 
diff --git a/src/regexp/experimental/experimental-bytecode.h b/src/regexp/experimental/experimental-bytecode.h
index 4e9bc9396b..39b3dd5ef3 100644
--- a/src/regexp/experimental/experimental-bytecode.h
+++ b/src/regexp/experimental/experimental-bytecode.h
@@ -7,8 +7,8 @@
 
 #include <ios>
 
+#include "src/base/vector.h"
 #include "src/regexp/regexp-ast.h"
-#include "src/utils/vector.h"
 
 // ----------------------------------------------------------------------------
 // Definition and semantics of the EXPERIMENTAL bytecode.
@@ -202,7 +202,7 @@ STATIC_ASSERT(sizeof(RegExpInstruction) == 8);
 
 std::ostream& operator<<(std::ostream& os, const RegExpInstruction& inst);
 std::ostream& operator<<(std::ostream& os,
-                         Vector<const RegExpInstruction> insts);
+                         base::Vector<const RegExpInstruction> insts);
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/regexp/experimental/experimental-interpreter.cc b/src/regexp/experimental/experimental-interpreter.cc
index f870de9bfe..e688468b71 100644
--- a/src/regexp/experimental/experimental-interpreter.cc
+++ b/src/regexp/experimental/experimental-interpreter.cc
@@ -22,7 +22,7 @@ constexpr int kUndefinedRegisterValue = -1;
 
 template <class Character>
 bool SatisfiesAssertion(RegExpAssertion::AssertionType type,
-                        Vector<const Character> context, int position) {
+                        base::Vector<const Character> context, int position) {
   DCHECK_LE(position, context.length());
   DCHECK_GE(position, 0);
 
@@ -53,21 +53,21 @@ bool SatisfiesAssertion(RegExpAssertion::AssertionType type,
   }
 }
 
-Vector<RegExpInstruction> ToInstructionVector(
+base::Vector<RegExpInstruction> ToInstructionVector(
     ByteArray raw_bytes, const DisallowGarbageCollection& no_gc) {
   RegExpInstruction* inst_begin =
       reinterpret_cast<RegExpInstruction*>(raw_bytes.GetDataStartAddress());
   int inst_num = raw_bytes.length() / sizeof(RegExpInstruction);
   DCHECK_EQ(sizeof(RegExpInstruction) * inst_num, raw_bytes.length());
-  return Vector<RegExpInstruction>(inst_begin, inst_num);
+  return base::Vector<RegExpInstruction>(inst_begin, inst_num);
 }
 
 template <class Character>
-Vector<const Character> ToCharacterVector(
+base::Vector<const Character> ToCharacterVector(
     String str, const DisallowGarbageCollection& no_gc);
 
 template <>
-Vector<const uint8_t> ToCharacterVector<uint8_t>(
+base::Vector<const uint8_t> ToCharacterVector<uint8_t>(
     String str, const DisallowGarbageCollection& no_gc) {
   DCHECK(str.IsFlat());
   String::FlatContent content = str.GetFlatContent(no_gc);
@@ -76,7 +76,7 @@ Vector<const uint8_t> ToCharacterVector<uint8_t>(
 }
 
 template <>
-Vector<const uc16> ToCharacterVector<uc16>(
+base::Vector<const uc16> ToCharacterVector<uc16>(
     String str, const DisallowGarbageCollection& no_gc) {
   DCHECK(str.IsFlat());
   String::FlatContent content = str.GetFlatContent(no_gc);
@@ -174,7 +174,7 @@ class NfaInterpreter {
 
       if (!FoundMatch()) break;
 
-      Vector<int> registers = *best_match_registers_;
+      base::Vector<int> registers = *best_match_registers_;
       output_registers =
           std::copy(registers.begin(), registers.end(), output_registers);
 
@@ -390,8 +390,8 @@ class NfaInterpreter {
         case RegExpInstruction::FORK: {
           InterpreterThread fork{inst.payload.pc,
                                  NewRegisterArrayUninitialized()};
-          Vector<int> fork_registers = GetRegisterArray(fork);
-          Vector<int> t_registers = GetRegisterArray(t);
+          base::Vector<int> fork_registers = GetRegisterArray(fork);
+          base::Vector<int> t_registers = GetRegisterArray(t);
           DCHECK_EQ(fork_registers.length(), t_registers.length());
           std::copy(t_registers.begin(), t_registers.end(),
                     fork_registers.begin());
@@ -460,8 +460,8 @@ class NfaInterpreter {
 
   bool FoundMatch() const { return best_match_registers_.has_value(); }
 
-  Vector<int> GetRegisterArray(InterpreterThread t) {
-    return Vector<int>(t.register_array_begin, register_count_per_match_);
+  base::Vector<int> GetRegisterArray(InterpreterThread t) {
+    return base::Vector<int>(t.register_array_begin, register_count_per_match_);
   }
 
   int* NewRegisterArrayUninitialized() {
@@ -515,20 +515,20 @@ class NfaInterpreter {
   DisallowGarbageCollection no_gc_;
 
   ByteArray bytecode_object_;
-  Vector<const RegExpInstruction> bytecode_;
+  base::Vector<const RegExpInstruction> bytecode_;
 
   // Number of registers used per thread.
   const int register_count_per_match_;
 
   String input_object_;
-  Vector<const Character> input_;
+  base::Vector<const Character> input_;
   int input_index_;
 
   // pc_last_input_index_[k] records the value of input_index_ the last
   // time a thread t such that t.pc == k was activated, i.e. put on
   // active_threads_.  Thus pc_last_input_index.size() == bytecode.size().  See
   // also `RunActiveThread`.
-  Vector<int> pc_last_input_index_;
+  base::Vector<int> pc_last_input_index_;
 
   // Active threads can potentially (but not necessarily) continue without
   // input.  Sorted from low to high priority.
@@ -547,7 +547,7 @@ class NfaInterpreter {
   // search.  If several threads ACCEPTed, then this will be the register array
   // of the accepting thread with highest priority.  Should be deallocated with
   // `register_array_allocator_`.
-  base::Optional<Vector<int>> best_match_registers_;
+  base::Optional<base::Vector<int>> best_match_registers_;
 
   Zone* zone_;
 };
diff --git a/src/regexp/experimental/experimental-interpreter.h b/src/regexp/experimental/experimental-interpreter.h
index 3da50e3902..d65299499b 100644
--- a/src/regexp/experimental/experimental-interpreter.h
+++ b/src/regexp/experimental/experimental-interpreter.h
@@ -5,11 +5,11 @@
 #ifndef V8_REGEXP_EXPERIMENTAL_EXPERIMENTAL_INTERPRETER_H_
 #define V8_REGEXP_EXPERIMENTAL_EXPERIMENTAL_INTERPRETER_H_
 
+#include "src/base/vector.h"
 #include "src/objects/fixed-array.h"
 #include "src/objects/string.h"
 #include "src/regexp/experimental/experimental-bytecode.h"
 #include "src/regexp/regexp.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
diff --git a/src/regexp/experimental/experimental.cc b/src/regexp/experimental/experimental.cc
index 3394fe9c57..bff2d7da66 100644
--- a/src/regexp/experimental/experimental.cc
+++ b/src/regexp/experimental/experimental.cc
@@ -46,7 +46,7 @@ bool ExperimentalRegExp::IsCompiled(Handle<JSRegExp> re, Isolate* isolate) {
 }
 
 template <class T>
-Handle<ByteArray> VectorToByteArray(Isolate* isolate, Vector<T> data) {
+Handle<ByteArray> VectorToByteArray(Isolate* isolate, base::Vector<T> data) {
   STATIC_ASSERT(std::is_trivial<T>::value);
 
   int byte_length = sizeof(T) * data.length();
@@ -131,12 +131,12 @@ bool ExperimentalRegExp::Compile(Isolate* isolate, Handle<JSRegExp> re) {
   return true;
 }
 
-Vector<RegExpInstruction> AsInstructionSequence(ByteArray raw_bytes) {
+base::Vector<RegExpInstruction> AsInstructionSequence(ByteArray raw_bytes) {
   RegExpInstruction* inst_begin =
       reinterpret_cast<RegExpInstruction*>(raw_bytes.GetDataStartAddress());
   int inst_num = raw_bytes.length() / sizeof(RegExpInstruction);
   DCHECK_EQ(sizeof(RegExpInstruction) * inst_num, raw_bytes.length());
-  return Vector<RegExpInstruction>(inst_begin, inst_num);
+  return base::Vector<RegExpInstruction>(inst_begin, inst_num);
 }
 
 namespace {
diff --git a/src/regexp/regexp-ast.cc b/src/regexp/regexp-ast.cc
index aaca95b64c..661713d686 100644
--- a/src/regexp/regexp-ast.cc
+++ b/src/regexp/regexp-ast.cc
@@ -219,7 +219,7 @@ void* RegExpUnparser::VisitAssertion(RegExpAssertion* that, void* data) {
 
 void* RegExpUnparser::VisitAtom(RegExpAtom* that, void* data) {
   os_ << "'";
-  Vector<const uc16> chardata = that->data();
+  base::Vector<const uc16> chardata = that->data();
   for (int i = 0; i < chardata.length(); i++) {
     os_ << AsUC16(chardata[i]);
   }
diff --git a/src/regexp/regexp-ast.h b/src/regexp/regexp-ast.h
index 89f523bf2e..7b55a97330 100644
--- a/src/regexp/regexp-ast.h
+++ b/src/regexp/regexp-ast.h
@@ -91,7 +91,7 @@ class CharacterRange {
   V8_EXPORT_PRIVATE static void AddClassEscape(
       char type, ZoneList<CharacterRange>* ranges,
       bool add_unicode_case_equivalents, Zone* zone);
-  static Vector<const int> GetWordBounds();
+  static base::Vector<const int> GetWordBounds();
   static inline CharacterRange Singleton(uc32 value) {
     return CharacterRange(value, value);
   }
@@ -369,7 +369,7 @@ class RegExpCharacterClass final : public RegExpTree {
 
 class RegExpAtom final : public RegExpTree {
  public:
-  explicit RegExpAtom(Vector<const uc16> data, JSRegExp::Flags flags)
+  explicit RegExpAtom(base::Vector<const uc16> data, JSRegExp::Flags flags)
       : data_(data), flags_(flags) {}
   void* Accept(RegExpVisitor* visitor, void* data) override;
   RegExpNode* ToNode(RegExpCompiler* compiler, RegExpNode* on_success) override;
@@ -379,13 +379,13 @@ class RegExpAtom final : public RegExpTree {
   int min_match() override { return data_.length(); }
   int max_match() override { return data_.length(); }
   void AppendToText(RegExpText* text, Zone* zone) override;
-  Vector<const uc16> data() { return data_; }
+  base::Vector<const uc16> data() { return data_; }
   int length() { return data_.length(); }
   JSRegExp::Flags flags() const { return flags_; }
   bool ignore_case() const { return (flags_ & JSRegExp::kIgnoreCase) != 0; }
 
  private:
-  Vector<const uc16> data_;
+  base::Vector<const uc16> data_;
   const JSRegExp::Flags flags_;
 };
 
diff --git a/src/regexp/regexp-bytecode-generator.cc b/src/regexp/regexp-bytecode-generator.cc
index dbfaab5cb3..8145ff9488 100644
--- a/src/regexp/regexp-bytecode-generator.cc
+++ b/src/regexp/regexp-bytecode-generator.cc
@@ -16,7 +16,7 @@ namespace internal {
 
 RegExpBytecodeGenerator::RegExpBytecodeGenerator(Isolate* isolate, Zone* zone)
     : RegExpMacroAssembler(isolate, zone),
-      buffer_(Vector<byte>::New(1024)),
+      buffer_(base::Vector<byte>::New(1024)),
       pc_(0),
       advance_current_end_(kInvalidPC),
       jump_edges_(zone),
@@ -395,8 +395,8 @@ void RegExpBytecodeGenerator::Copy(byte* a) {
 }
 
 void RegExpBytecodeGenerator::Expand() {
-  Vector<byte> old_buffer = buffer_;
-  buffer_ = Vector<byte>::New(old_buffer.length() * 2);
+  base::Vector<byte> old_buffer = buffer_;
+  buffer_ = base::Vector<byte>::New(old_buffer.length() * 2);
   MemCopy(buffer_.begin(), old_buffer.begin(), old_buffer.length());
   old_buffer.Dispose();
 }
diff --git a/src/regexp/regexp-bytecode-generator.h b/src/regexp/regexp-bytecode-generator.h
index 6307a802d9..534ebbe0a3 100644
--- a/src/regexp/regexp-bytecode-generator.h
+++ b/src/regexp/regexp-bytecode-generator.h
@@ -92,7 +92,7 @@ class V8_EXPORT_PRIVATE RegExpBytecodeGenerator : public RegExpMacroAssembler {
   void Copy(byte* a);
 
   // The buffer into which code and relocation info are generated.
-  Vector<byte> buffer_;
+  base::Vector<byte> buffer_;
   // The program counter.
   int pc_;
   Label backtrack_;
diff --git a/src/regexp/regexp-compiler-tonode.cc b/src/regexp/regexp-compiler-tonode.cc
index 276cdb3522..9c02b04c72 100644
--- a/src/regexp/regexp-compiler-tonode.cc
+++ b/src/regexp/regexp-compiler-tonode.cc
@@ -1134,8 +1134,8 @@ void CharacterRange::AddClassEscape(char type, ZoneList<CharacterRange>* ranges,
   }
 }
 
-Vector<const int> CharacterRange::GetWordBounds() {
-  return Vector<const int>(kWordRanges, kWordRangeCount - 1);
+base::Vector<const int> CharacterRange::GetWordBounds() {
+  return base::Vector<const int>(kWordRanges, kWordRangeCount - 1);
 }
 
 // static
diff --git a/src/regexp/regexp-compiler.cc b/src/regexp/regexp-compiler.cc
index 40b8ac3999..74d78b58dc 100644
--- a/src/regexp/regexp-compiler.cc
+++ b/src/regexp/regexp-compiler.cc
@@ -1579,7 +1579,7 @@ void TextNode::GetQuickCheckDetails(QuickCheckDetails* details,
   for (int k = 0; k < elements()->length(); k++) {
     TextElement elm = elements()->at(k);
     if (elm.text_type() == TextElement::ATOM) {
-      Vector<const uc16> quarks = elm.atom()->data();
+      base::Vector<const uc16> quarks = elm.atom()->data();
       for (int i = 0; i < characters && i < quarks.length(); i++) {
         QuickCheckDetails::Position* pos =
             details->positions(characters_filled_in);
@@ -1851,7 +1851,7 @@ RegExpNode* TextNode::FilterOneByte(int depth) {
   for (int i = 0; i < element_count; i++) {
     TextElement elm = elements()->at(i);
     if (elm.text_type() == TextElement::ATOM) {
-      Vector<const uc16> quarks = elm.atom()->data();
+      base::Vector<const uc16> quarks = elm.atom()->data();
       for (int j = 0; j < quarks.length(); j++) {
         uc16 c = quarks[j];
         if (elm.atom()->ignore_case()) {
@@ -2314,7 +2314,7 @@ void TextNode::TextEmitPass(RegExpCompiler* compiler, TextEmitPassType pass,
     int cp_offset = trace->cp_offset() + elm.cp_offset() + backward_offset;
     if (elm.text_type() == TextElement::ATOM) {
       if (SkipPass(pass, elm.atom()->ignore_case())) continue;
-      Vector<const uc16> quarks = elm.atom()->data();
+      base::Vector<const uc16> quarks = elm.atom()->data();
       for (int j = preloaded ? 0 : quarks.length() - 1; j >= 0; j--) {
         if (first_element_checked && i == 0 && j == 0) continue;
         if (DeterminedAlready(quick_check, elm.cp_offset() + j)) continue;
diff --git a/src/regexp/regexp-dotprinter.cc b/src/regexp/regexp-dotprinter.cc
index 513b2148e2..323e725cfb 100644
--- a/src/regexp/regexp-dotprinter.cc
+++ b/src/regexp/regexp-dotprinter.cc
@@ -128,7 +128,7 @@ void DotPrinterImpl::VisitText(TextNode* that) {
     TextElement elm = that->elements()->at(i);
     switch (elm.text_type()) {
       case TextElement::ATOM: {
-        Vector<const uc16> data = elm.atom()->data();
+        base::Vector<const uc16> data = elm.atom()->data();
         for (int i = 0; i < data.length(); i++) {
           os_ << static_cast<char>(data[i]);
         }
diff --git a/src/regexp/regexp-interpreter.cc b/src/regexp/regexp-interpreter.cc
index ac2654cd5f..76b685095a 100644
--- a/src/regexp/regexp-interpreter.cc
+++ b/src/regexp/regexp-interpreter.cc
@@ -35,7 +35,7 @@ namespace internal {
 namespace {
 
 bool BackRefMatchesNoCase(Isolate* isolate, int from, int current, int len,
-                          Vector<const uc16> subject, bool unicode) {
+                          base::Vector<const uc16> subject, bool unicode) {
   Address offset_a =
       reinterpret_cast<Address>(const_cast<uc16*>(&subject.at(from)));
   Address offset_b =
@@ -51,7 +51,7 @@ bool BackRefMatchesNoCase(Isolate* isolate, int from, int current, int len,
 }
 
 bool BackRefMatchesNoCase(Isolate* isolate, int from, int current, int len,
-                          Vector<const uint8_t> subject, bool unicode) {
+                          base::Vector<const uint8_t> subject, bool unicode) {
   // For Latin1 characters the unicode flag makes no difference.
   for (int i = 0; i < len; i++) {
     unsigned int old_char = subject[from++];
@@ -229,7 +229,7 @@ void UpdateCodeAndSubjectReferences(
     Isolate* isolate, Handle<ByteArray> code_array,
     Handle<String> subject_string, ByteArray* code_array_out,
     const byte** code_base_out, const byte** pc_out, String* subject_string_out,
-    Vector<const Char>* subject_string_vector_out) {
+    base::Vector<const Char>* subject_string_vector_out) {
   DisallowGarbageCollection no_gc;
 
   if (*code_base_out != code_array->GetDataStartAddress()) {
@@ -251,7 +251,7 @@ template <typename Char>
 IrregexpInterpreter::Result HandleInterrupts(
     Isolate* isolate, RegExp::CallOrigin call_origin, ByteArray* code_array_out,
     String* subject_string_out, const byte** code_base_out,
-    Vector<const Char>* subject_string_vector_out, const byte** pc_out) {
+    base::Vector<const Char>* subject_string_vector_out, const byte** pc_out) {
   DisallowGarbageCollection no_gc;
 
   StackLimitCheck check(isolate);
@@ -380,7 +380,7 @@ bool IndexIsInBounds(int index, int length) {
 template <typename Char>
 IrregexpInterpreter::Result RawMatch(
     Isolate* isolate, ByteArray code_array, String subject_string,
-    Vector<const Char> subject, int* output_registers,
+    base::Vector<const Char> subject, int* output_registers,
     int output_register_count, int total_register_count, int current,
     uint32_t current_char, RegExp::CallOrigin call_origin,
     const uint32_t backtrack_limit) {
@@ -1083,7 +1083,8 @@ IrregexpInterpreter::Result IrregexpInterpreter::MatchInternal(
   uc16 previous_char = '\n';
   String::FlatContent subject_content = subject_string.GetFlatContent(no_gc);
   if (subject_content.IsOneByte()) {
-    Vector<const uint8_t> subject_vector = subject_content.ToOneByteVector();
+    base::Vector<const uint8_t> subject_vector =
+        subject_content.ToOneByteVector();
     if (start_position != 0) previous_char = subject_vector[start_position - 1];
     return RawMatch(isolate, code_array, subject_string, subject_vector,
                     output_registers, output_register_count,
@@ -1091,7 +1092,7 @@ IrregexpInterpreter::Result IrregexpInterpreter::MatchInternal(
                     call_origin, backtrack_limit);
   } else {
     DCHECK(subject_content.IsTwoByte());
-    Vector<const uc16> subject_vector = subject_content.ToUC16Vector();
+    base::Vector<const uc16> subject_vector = subject_content.ToUC16Vector();
     if (start_position != 0) previous_char = subject_vector[start_position - 1];
     return RawMatch(isolate, code_array, subject_string, subject_vector,
                     output_registers, output_register_count,
diff --git a/src/regexp/regexp-parser.cc b/src/regexp/regexp-parser.cc
index dc8711d8a7..7d1d247877 100644
--- a/src/regexp/regexp-parser.cc
+++ b/src/regexp/regexp-parser.cc
@@ -1014,8 +1014,8 @@ Handle<FixedArray> RegExpParser::CreateCaptureNameMap() {
 
   int i = 0;
   for (const auto& capture : sorted_named_captures) {
-    Vector<const uc16> capture_name(capture->name()->data(),
-                                    capture->name()->size());
+    base::Vector<const uc16> capture_name(capture->name()->data(),
+                                          capture->name()->size());
     // CSA code in ConstructNewResultFromMatchInfo requires these strings to be
     // internalized so they can be used as property names in the 'exec' results.
     Handle<String> name = factory->InternalizeString(capture_name);
@@ -2087,10 +2087,10 @@ bool RegExpBuilder::AddQuantifierToAtom(
   if (characters_ != nullptr) {
     DCHECK(last_added_ == ADD_CHAR);
     // Last atom was character.
-    Vector<const uc16> char_vector = characters_->ToConstVector();
+    base::Vector<const uc16> char_vector = characters_->ToConstVector();
     int num_chars = char_vector.length();
     if (num_chars > 1) {
-      Vector<const uc16> prefix = char_vector.SubVector(0, num_chars - 1);
+      base::Vector<const uc16> prefix = char_vector.SubVector(0, num_chars - 1);
       text_.Add(zone()->New<RegExpAtom>(prefix, flags_), zone());
       char_vector = char_vector.SubVector(num_chars - 1, num_chars);
     }
diff --git a/src/regexp/regexp-utils.cc b/src/regexp/regexp-utils.cc
index 8bb243d611..1e72a124c9 100644
--- a/src/regexp/regexp-utils.cc
+++ b/src/regexp/regexp-utils.cc
@@ -84,7 +84,7 @@ MaybeHandle<Object> RegExpUtils::RegExpExec(Isolate* isolate,
 
   if (exec->IsCallable()) {
     const int argc = 1;
-    ScopedVector<Handle<Object>> argv(argc);
+    base::ScopedVector<Handle<Object>> argv(argc);
     argv[0] = string;
 
     Handle<Object> result;
@@ -113,7 +113,7 @@ MaybeHandle<Object> RegExpUtils::RegExpExec(Isolate* isolate,
     Handle<JSFunction> regexp_exec = isolate->regexp_exec_function();
 
     const int argc = 1;
-    ScopedVector<Handle<Object>> argv(argc);
+    base::ScopedVector<Handle<Object>> argv(argc);
     argv[0] = string;
 
     return Execution::Call(isolate, regexp_exec, regexp, argc, argv.begin());
diff --git a/src/regexp/regexp.cc b/src/regexp/regexp.cc
index 16c4066f26..16485203d2 100644
--- a/src/regexp/regexp.cc
+++ b/src/regexp/regexp.cc
@@ -105,10 +105,11 @@ MaybeHandle<Object> RegExp::ThrowRegExpException(Isolate* isolate,
                                                  Handle<JSRegExp> re,
                                                  Handle<String> pattern,
                                                  RegExpError error) {
-  Vector<const char> error_data = CStrVector(RegExpErrorString(error));
+  base::Vector<const char> error_data =
+      base::CStrVector(RegExpErrorString(error));
   Handle<String> error_text =
       isolate->factory()
-          ->NewStringFromOneByte(Vector<const uint8_t>::cast(error_data))
+          ->NewStringFromOneByte(base::Vector<const uint8_t>::cast(error_data))
           .ToHandleChecked();
   THROW_NEW_ERROR(
       isolate,
@@ -218,7 +219,7 @@ MaybeHandle<Object> RegExp::Compile(Isolate* isolate, Handle<JSRegExp> re,
     RegExpAtom* atom = parse_result.tree->AsAtom();
     // The pattern source might (?) contain escape sequences, but they're
     // resolved in atom_string.
-    Vector<const uc16> atom_pattern = atom->data();
+    base::Vector<const uc16> atom_pattern = atom->data();
     Handle<String> atom_string;
     ASSIGN_RETURN_ON_EXCEPTION(
         isolate, atom_string,
diff --git a/src/runtime/runtime-debug.cc b/src/runtime/runtime-debug.cc
index 840b06e4ba..d22e3b6394 100644
--- a/src/runtime/runtime-debug.cc
+++ b/src/runtime/runtime-debug.cc
@@ -331,7 +331,7 @@ MaybeHandle<JSArray> Runtime::GetInternalProperties(Isolate* isolate,
                          isolate->factory()->NewNumberFromSize(byte_length));
 
       // Use the backing store pointer as a unique ID
-      EmbeddedVector<char, 32> buffer_data_vec;
+      base::EmbeddedVector<char, 32> buffer_data_vec;
       int len =
           SNPrintF(buffer_data_vec, V8PRIxPTR_FMT,
                    reinterpret_cast<Address>(js_array_buffer->backing_store()));
diff --git a/src/runtime/runtime-function.cc b/src/runtime/runtime-function.cc
index 0d1879c16a..98df87ceed 100644
--- a/src/runtime/runtime-function.cc
+++ b/src/runtime/runtime-function.cc
@@ -80,7 +80,7 @@ RUNTIME_FUNCTION(Runtime_Call) {
   int const argc = args.length() - 2;
   CONVERT_ARG_HANDLE_CHECKED(Object, target, 0);
   CONVERT_ARG_HANDLE_CHECKED(Object, receiver, 1);
-  ScopedVector<Handle<Object>> argv(argc);
+  base::ScopedVector<Handle<Object>> argv(argc);
   for (int i = 0; i < argc; ++i) {
     argv[i] = args.at(2 + i);
   }
diff --git a/src/runtime/runtime-object.cc b/src/runtime/runtime-object.cc
index 13493125da..fb3db626d2 100644
--- a/src/runtime/runtime-object.cc
+++ b/src/runtime/runtime-object.cc
@@ -1216,7 +1216,7 @@ RUNTIME_FUNCTION(Runtime_CopyDataPropertiesWithExcludedProperties) {
                                                     MaybeHandle<Object>());
   }
 
-  ScopedVector<Handle<Object>> excluded_properties(args.length() - 1);
+  base::ScopedVector<Handle<Object>> excluded_properties(args.length() - 1);
   for (int i = 1; i < args.length(); i++) {
     Handle<Object> property = args.at(i);
     uint32_t property_num;
diff --git a/src/runtime/runtime-regexp.cc b/src/runtime/runtime-regexp.cc
index f80316e34d..61a4fb3202 100644
--- a/src/runtime/runtime-regexp.cc
+++ b/src/runtime/runtime-regexp.cc
@@ -149,7 +149,7 @@ class CompiledReplacement {
   };
 
   template <typename Char>
-  bool ParseReplacementPattern(Vector<Char> characters,
+  bool ParseReplacementPattern(base::Vector<Char> characters,
                                FixedArray capture_name_map, int capture_count,
                                int subject_length) {
     // Equivalent to String::GetSubstitution, except that this method converts
@@ -269,7 +269,7 @@ class CompiledReplacement {
               break;
             }
 
-            Vector<Char> requested_name =
+            base::Vector<Char> requested_name =
                 characters.SubVector(name_start_index, closing_bracket_index);
 
             // Let capture be ? Get(namedCaptures, groupName).
@@ -410,8 +410,9 @@ void CompiledReplacement::Apply(ReplacementStringBuilder* builder,
   }
 }
 
-void FindOneByteStringIndices(Vector<const uint8_t> subject, uint8_t pattern,
-                              std::vector<int>* indices, unsigned int limit) {
+void FindOneByteStringIndices(base::Vector<const uint8_t> subject,
+                              uint8_t pattern, std::vector<int>* indices,
+                              unsigned int limit) {
   DCHECK_LT(0, limit);
   // Collect indices of pattern in subject using memchr.
   // Stop after finding at most limit values.
@@ -428,8 +429,9 @@ void FindOneByteStringIndices(Vector<const uint8_t> subject, uint8_t pattern,
   }
 }
 
-void FindTwoByteStringIndices(const Vector<const uc16> subject, uc16 pattern,
-                              std::vector<int>* indices, unsigned int limit) {
+void FindTwoByteStringIndices(const base::Vector<const uc16> subject,
+                              uc16 pattern, std::vector<int>* indices,
+                              unsigned int limit) {
   DCHECK_LT(0, limit);
   const uc16* subject_start = subject.begin();
   const uc16* subject_end = subject_start + subject.length();
@@ -442,8 +444,9 @@ void FindTwoByteStringIndices(const Vector<const uc16> subject, uc16 pattern,
 }
 
 template <typename SubjectChar, typename PatternChar>
-void FindStringIndices(Isolate* isolate, Vector<const SubjectChar> subject,
-                       Vector<const PatternChar> pattern,
+void FindStringIndices(Isolate* isolate,
+                       base::Vector<const SubjectChar> subject,
+                       base::Vector<const PatternChar> pattern,
                        std::vector<int>* indices, unsigned int limit) {
   DCHECK_LT(0, limit);
   // Collect indices of pattern in subject.
@@ -469,9 +472,10 @@ void FindStringIndicesDispatch(Isolate* isolate, String subject, String pattern,
     DCHECK(subject_content.IsFlat());
     DCHECK(pattern_content.IsFlat());
     if (subject_content.IsOneByte()) {
-      Vector<const uint8_t> subject_vector = subject_content.ToOneByteVector();
+      base::Vector<const uint8_t> subject_vector =
+          subject_content.ToOneByteVector();
       if (pattern_content.IsOneByte()) {
-        Vector<const uint8_t> pattern_vector =
+        base::Vector<const uint8_t> pattern_vector =
             pattern_content.ToOneByteVector();
         if (pattern_vector.length() == 1) {
           FindOneByteStringIndices(subject_vector, pattern_vector[0], indices,
@@ -485,9 +489,9 @@ void FindStringIndicesDispatch(Isolate* isolate, String subject, String pattern,
                           pattern_content.ToUC16Vector(), indices, limit);
       }
     } else {
-      Vector<const uc16> subject_vector = subject_content.ToUC16Vector();
+      base::Vector<const uc16> subject_vector = subject_content.ToUC16Vector();
       if (pattern_content.IsOneByte()) {
-        Vector<const uint8_t> pattern_vector =
+        base::Vector<const uint8_t> pattern_vector =
             pattern_content.ToOneByteVector();
         if (pattern_vector.length() == 1) {
           FindTwoByteStringIndices(subject_vector, pattern_vector[0], indices,
@@ -497,7 +501,8 @@ void FindStringIndicesDispatch(Isolate* isolate, String subject, String pattern,
                             limit);
         }
       } else {
-        Vector<const uc16> pattern_vector = pattern_content.ToUC16Vector();
+        base::Vector<const uc16> pattern_vector =
+            pattern_content.ToUC16Vector();
         if (pattern_vector.length() == 1) {
           FindTwoByteStringIndices(subject_vector, pattern_vector[0], indices,
                                    limit);
@@ -1058,7 +1063,8 @@ class VectorBackedMatch : public String::Match {
  public:
   VectorBackedMatch(Isolate* isolate, Handle<String> subject,
                     Handle<String> match, int match_position,
-                    Vector<Handle<Object>> captures, Handle<Object> groups_obj)
+                    base::Vector<Handle<Object>> captures,
+                    Handle<Object> groups_obj)
       : isolate_(isolate),
         match_(match),
         match_position_(match_position),
@@ -1118,7 +1124,7 @@ class VectorBackedMatch : public String::Match {
   Handle<String> subject_;
   Handle<String> match_;
   const int match_position_;
-  Vector<Handle<Object>> captures_;
+  base::Vector<Handle<Object>> captures_;
 
   bool has_named_captures_;
   Handle<JSReceiver> groups_obj_;
@@ -1559,7 +1565,7 @@ RUNTIME_FUNCTION(Runtime_StringReplaceNonGlobalRegExpWithFunction) {
     THROW_NEW_ERROR_RETURN_FAILURE(
         isolate, NewRangeError(MessageTemplate::kTooManyArguments));
   }
-  ScopedVector<Handle<Object>> argv(argc);
+  base::ScopedVector<Handle<Object>> argv(argc);
 
   int cursor = 0;
   for (int j = 0; j < m; j++) {
@@ -1669,7 +1675,7 @@ RUNTIME_FUNCTION(Runtime_RegExpSplit) {
   {
     const int argc = 2;
 
-    ScopedVector<Handle<Object>> argv(argc);
+    base::ScopedVector<Handle<Object>> argv(argc);
     argv[0] = recv;
     argv[1] = new_flags;
 
@@ -1931,7 +1937,7 @@ RUNTIME_FUNCTION(Runtime_RegExpReplaceRT) {
             isolate, NewRangeError(MessageTemplate::kTooManyArguments));
       }
 
-      ScopedVector<Handle<Object>> argv(argc);
+      base::ScopedVector<Handle<Object>> argv(argc);
 
       int cursor = 0;
       for (uint32_t j = 0; j < captures_length; j++) {
@@ -1958,8 +1964,8 @@ RUNTIME_FUNCTION(Runtime_RegExpReplaceRT) {
         ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
             isolate, groups_obj, Object::ToObject(isolate, groups_obj));
       }
-      VectorBackedMatch m(isolate, string, match, position, VectorOf(captures),
-                          groups_obj);
+      VectorBackedMatch m(isolate, string, match, position,
+                          base::VectorOf(captures), groups_obj);
       ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
           isolate, replacement, String::GetSubstitution(isolate, &m, replace));
     }
diff --git a/src/runtime/runtime-strings.cc b/src/runtime/runtime-strings.cc
index bd651c646c..78759e8a59 100644
--- a/src/runtime/runtime-strings.cc
+++ b/src/runtime/runtime-strings.cc
@@ -320,7 +320,7 @@ RUNTIME_FUNCTION(Runtime_StringToArray) {
     DisallowGarbageCollection no_gc;
     String::FlatContent content = s->GetFlatContent(no_gc);
     if (content.IsOneByte()) {
-      Vector<const uint8_t> chars = content.ToOneByteVector();
+      base::Vector<const uint8_t> chars = content.ToOneByteVector();
       // Note, this will initialize all elements (not only the prefix)
       // to prevent GC from seeing partially initialized array.
       position = CopyCachedOneByteCharsToArray(isolate->heap(), chars.begin(),
diff --git a/src/runtime/runtime-test-wasm.cc b/src/runtime/runtime-test-wasm.cc
index f1cd04d9bd..e6447e5c3c 100644
--- a/src/runtime/runtime-test-wasm.cc
+++ b/src/runtime/runtime-test-wasm.cc
@@ -355,11 +355,11 @@ RUNTIME_FUNCTION(Runtime_DeserializeWasmModule) {
   CHECK(!wire_bytes->WasDetached());
 
   Handle<JSArrayBuffer> wire_bytes_buffer = wire_bytes->GetBuffer();
-  Vector<const uint8_t> wire_bytes_vec{
+  base::Vector<const uint8_t> wire_bytes_vec{
       reinterpret_cast<const uint8_t*>(wire_bytes_buffer->backing_store()) +
           wire_bytes->byte_offset(),
       wire_bytes->byte_length()};
-  Vector<uint8_t> buffer_vec{
+  base::Vector<uint8_t> buffer_vec{
       reinterpret_cast<uint8_t*>(buffer->backing_store()),
       buffer->byte_length()};
 
diff --git a/src/runtime/runtime-test.cc b/src/runtime/runtime-test.cc
index 5a38d46519..50fa78f008 100644
--- a/src/runtime/runtime-test.cc
+++ b/src/runtime/runtime-test.cc
@@ -271,7 +271,7 @@ Object OptimizeFunctionOnNextCall(RuntimeArguments& args, Isolate* isolate,
     CONVERT_ARG_HANDLE_CHECKED(Object, type, 1);
     if (!type->IsString()) return CrashUnlessFuzzing(isolate);
     if (Handle<String>::cast(type)->IsOneByteEqualTo(
-            StaticCharVector("concurrent")) &&
+            base::StaticCharVector("concurrent")) &&
         isolate->concurrent_recompilation_enabled()) {
       concurrency_mode = ConcurrencyMode::kConcurrent;
     }
@@ -389,7 +389,7 @@ RUNTIME_FUNCTION(Runtime_PrepareFunctionForOptimization) {
     if (!sync_object->IsString()) return CrashUnlessFuzzing(isolate);
     Handle<String> sync = Handle<String>::cast(sync_object);
     if (sync->IsOneByteEqualTo(
-            StaticCharVector("allow heuristic optimization"))) {
+            base::StaticCharVector("allow heuristic optimization"))) {
       allow_heuristic_optimization = true;
     }
   }
@@ -562,9 +562,9 @@ RUNTIME_FUNCTION(Runtime_GetOptimizationStatus) {
     CONVERT_ARG_HANDLE_CHECKED(Object, sync_object, 1);
     if (!sync_object->IsString()) return CrashUnlessFuzzing(isolate);
     Handle<String> sync = Handle<String>::cast(sync_object);
-    if (sync->IsOneByteEqualTo(StaticCharVector("no sync"))) {
+    if (sync->IsOneByteEqualTo(base::StaticCharVector("no sync"))) {
       sync_with_compiler_thread = false;
-    } else if (sync->IsOneByteEqualTo(StaticCharVector("sync")) ||
+    } else if (sync->IsOneByteEqualTo(base::StaticCharVector("sync")) ||
                sync->length() == 0) {
       DCHECK(sync_with_compiler_thread);
     } else {
@@ -869,7 +869,7 @@ RUNTIME_FUNCTION(Runtime_DebugTrackRetainingPath) {
   if (args.length() == 2) {
     CONVERT_ARG_HANDLE_CHECKED(String, str, 1);
     const char track_ephemeron_path[] = "track-ephemeron-path";
-    if (str->IsOneByteEqualTo(StaticCharVector(track_ephemeron_path))) {
+    if (str->IsOneByteEqualTo(base::StaticCharVector(track_ephemeron_path))) {
       option = RetainingPathOption::kTrackEphemeronPath;
     } else {
       CHECK_EQ(str->length(), 0);
diff --git a/src/snapshot/code-serializer.cc b/src/snapshot/code-serializer.cc
index 14ad247ff0..dc31572c14 100644
--- a/src/snapshot/code-serializer.cc
+++ b/src/snapshot/code-serializer.cc
@@ -479,12 +479,12 @@ ScriptData* SerializedCodeData::GetScriptData() {
   return result;
 }
 
-Vector<const byte> SerializedCodeData::Payload() const {
+base::Vector<const byte> SerializedCodeData::Payload() const {
   const byte* payload = data_ + kHeaderSize;
   DCHECK(IsAligned(reinterpret_cast<intptr_t>(payload), kPointerAlignment));
   int length = GetHeaderValue(kPayloadLengthOffset);
   DCHECK_EQ(data_ + size_, payload + length);
-  return Vector<const byte>(payload, length);
+  return base::Vector<const byte>(payload, length);
 }
 
 SerializedCodeData::SerializedCodeData(ScriptData* data)
diff --git a/src/snapshot/code-serializer.h b/src/snapshot/code-serializer.h
index 88cfee822b..229c62f99a 100644
--- a/src/snapshot/code-serializer.h
+++ b/src/snapshot/code-serializer.h
@@ -117,7 +117,7 @@ class SerializedCodeData : public SerializedData {
   // Return ScriptData object and relinquish ownership over it to the caller.
   ScriptData* GetScriptData();
 
-  Vector<const byte> Payload() const;
+  base::Vector<const byte> Payload() const;
 
   static uint32_t SourceHash(Handle<String> source,
                              ScriptOriginOptions origin_options);
@@ -127,8 +127,8 @@ class SerializedCodeData : public SerializedData {
   SerializedCodeData(const byte* data, int size)
       : SerializedData(const_cast<byte*>(data), size) {}
 
-  Vector<const byte> ChecksummedContent() const {
-    return Vector<const byte>(data_ + kHeaderSize, size_ - kHeaderSize);
+  base::Vector<const byte> ChecksummedContent() const {
+    return base::Vector<const byte>(data_ + kHeaderSize, size_ - kHeaderSize);
   }
 
   SanityCheckResult SanityCheck(uint32_t expected_source_hash) const;
diff --git a/src/snapshot/deserializer.cc b/src/snapshot/deserializer.cc
index 6be06c2dc8..84eac89f33 100644
--- a/src/snapshot/deserializer.cc
+++ b/src/snapshot/deserializer.cc
@@ -206,7 +206,7 @@ int Deserializer::WriteExternalPointer(TSlot dest, Address value,
   return (kExternalPointerSize / TSlot::kSlotDataSize);
 }
 
-Deserializer::Deserializer(Isolate* isolate, Vector<const byte> payload,
+Deserializer::Deserializer(Isolate* isolate, base::Vector<const byte> payload,
                            uint32_t magic_number, bool deserializing_user_code,
                            bool can_rehash)
     : isolate_(isolate),
diff --git a/src/snapshot/deserializer.h b/src/snapshot/deserializer.h
index 8debb06d8a..e665bbffc1 100644
--- a/src/snapshot/deserializer.h
+++ b/src/snapshot/deserializer.h
@@ -61,7 +61,7 @@ class V8_EXPORT_PRIVATE Deserializer : public SerializerDeserializer {
 
  protected:
   // Create a deserializer from a snapshot byte source.
-  Deserializer(Isolate* isolate, Vector<const byte> payload,
+  Deserializer(Isolate* isolate, base::Vector<const byte> payload,
                uint32_t magic_number, bool deserializing_user_code,
                bool can_rehash);
 
diff --git a/src/snapshot/embedded/embedded-data.cc b/src/snapshot/embedded/embedded-data.cc
index a3f3fbcd5b..427e09c73a 100644
--- a/src/snapshot/embedded/embedded-data.cc
+++ b/src/snapshot/embedded/embedded-data.cc
@@ -440,14 +440,14 @@ size_t EmbeddedData::CreateEmbeddedBlobDataHash() const {
   static constexpr uint32_t kFirstHashedDataOffset = IsolateHashOffset();
   // Hash the entire data section except the embedded blob hash fields
   // themselves.
-  Vector<const byte> payload(data_ + kFirstHashedDataOffset,
-                             data_size_ - kFirstHashedDataOffset);
+  base::Vector<const byte> payload(data_ + kFirstHashedDataOffset,
+                                   data_size_ - kFirstHashedDataOffset);
   return Checksum(payload);
 }
 
 size_t EmbeddedData::CreateEmbeddedBlobCodeHash() const {
   CHECK(FLAG_text_is_readable);
-  Vector<const byte> payload(code_, code_size_);
+  base::Vector<const byte> payload(code_, code_size_);
   return Checksum(payload);
 }
 
diff --git a/src/snapshot/embedded/embedded-file-writer.cc b/src/snapshot/embedded/embedded-file-writer.cc
index 3700068355..6462cc7cac 100644
--- a/src/snapshot/embedded/embedded-file-writer.cc
+++ b/src/snapshot/embedded/embedded-file-writer.cc
@@ -52,7 +52,7 @@ void EmbeddedFileWriter::WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
   const bool is_default_variant =
       std::strcmp(embedded_variant_, kDefaultEmbeddedVariant) == 0;
 
-  i::EmbeddedVector<char, kTemporaryStringLength> builtin_symbol;
+  base::EmbeddedVector<char, kTemporaryStringLength> builtin_symbol;
   if (is_default_variant) {
     // Create nicer symbol names for the default mode.
     i::SNPrintF(builtin_symbol, "Builtins_%s", i::Builtins::name(builtin));
@@ -71,7 +71,8 @@ void EmbeddedFileWriter::WriteBuiltin(PlatformEmbeddedFileWriterBase* w,
   const std::vector<byte>& current_positions = source_positions_[builtin_id];
   // The code below interleaves bytes of assembly code for the builtin
   // function with source positions at the appropriate offsets.
-  Vector<const byte> vpos(current_positions.data(), current_positions.size());
+  base::Vector<const byte> vpos(current_positions.data(),
+                                current_positions.size());
   v8::internal::SourcePositionTableIterator positions(
       vpos, SourcePositionTableIterator::kExternalOnly);
 
@@ -168,7 +169,8 @@ void EmbeddedFileWriter::WriteCodeSection(PlatformEmbeddedFileWriterBase* w,
 void EmbeddedFileWriter::WriteFileEpilogue(PlatformEmbeddedFileWriterBase* w,
                                            const i::EmbeddedData* blob) const {
   {
-    i::EmbeddedVector<char, kTemporaryStringLength> embedded_blob_code_symbol;
+    base::EmbeddedVector<char, kTemporaryStringLength>
+        embedded_blob_code_symbol;
     i::SNPrintF(embedded_blob_code_symbol, "v8_%s_embedded_blob_code_",
                 embedded_variant_);
 
@@ -179,7 +181,8 @@ void EmbeddedFileWriter::WriteFileEpilogue(PlatformEmbeddedFileWriterBase* w,
                               EmbeddedBlobCodeDataSymbol().c_str());
     w->Newline();
 
-    i::EmbeddedVector<char, kTemporaryStringLength> embedded_blob_data_symbol;
+    base::EmbeddedVector<char, kTemporaryStringLength>
+        embedded_blob_data_symbol;
     i::SNPrintF(embedded_blob_data_symbol, "v8_%s_embedded_blob_data_",
                 embedded_variant_);
 
@@ -191,7 +194,7 @@ void EmbeddedFileWriter::WriteFileEpilogue(PlatformEmbeddedFileWriterBase* w,
   }
 
   {
-    i::EmbeddedVector<char, kTemporaryStringLength>
+    base::EmbeddedVector<char, kTemporaryStringLength>
         embedded_blob_code_size_symbol;
     i::SNPrintF(embedded_blob_code_size_symbol,
                 "v8_%s_embedded_blob_code_size_", embedded_variant_);
@@ -202,7 +205,7 @@ void EmbeddedFileWriter::WriteFileEpilogue(PlatformEmbeddedFileWriterBase* w,
     w->DeclareUint32(embedded_blob_code_size_symbol.begin(), blob->code_size());
     w->Newline();
 
-    i::EmbeddedVector<char, kTemporaryStringLength>
+    base::EmbeddedVector<char, kTemporaryStringLength>
         embedded_blob_data_size_symbol;
     i::SNPrintF(embedded_blob_data_size_symbol,
                 "v8_%s_embedded_blob_data_size_", embedded_variant_);
@@ -214,7 +217,7 @@ void EmbeddedFileWriter::WriteFileEpilogue(PlatformEmbeddedFileWriterBase* w,
 
 #if defined(V8_OS_WIN64)
   {
-    i::EmbeddedVector<char, kTemporaryStringLength> unwind_info_symbol;
+    base::EmbeddedVector<char, kTemporaryStringLength> unwind_info_symbol;
     i::SNPrintF(unwind_info_symbol, "%s_Builtins_UnwindInfo",
                 embedded_variant_);
 
diff --git a/src/snapshot/embedded/embedded-file-writer.h b/src/snapshot/embedded/embedded-file-writer.h
index 53048d37f5..486ca4ecb8 100644
--- a/src/snapshot/embedded/embedded-file-writer.h
+++ b/src/snapshot/embedded/embedded-file-writer.h
@@ -125,7 +125,7 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
   static constexpr int kTemporaryStringLength = 256;
 
   std::string EmbeddedBlobCodeDataSymbol() const {
-    i::EmbeddedVector<char, kTemporaryStringLength>
+    base::EmbeddedVector<char, kTemporaryStringLength>
         embedded_blob_code_data_symbol;
     i::SNPrintF(embedded_blob_code_data_symbol,
                 "v8_%s_embedded_blob_code_data_", embedded_variant_);
@@ -133,7 +133,7 @@ class EmbeddedFileWriter : public EmbeddedFileWriterInterface {
   }
 
   std::string EmbeddedBlobDataDataSymbol() const {
-    i::EmbeddedVector<char, kTemporaryStringLength>
+    base::EmbeddedVector<char, kTemporaryStringLength>
         embedded_blob_data_data_symbol;
     i::SNPrintF(embedded_blob_data_data_symbol,
                 "v8_%s_embedded_blob_data_data_", embedded_variant_);
diff --git a/src/snapshot/embedded/platform-embedded-file-writer-win.cc b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
index 2cc8abfb01..a494777cbe 100644
--- a/src/snapshot/embedded/platform-embedded-file-writer-win.cc
+++ b/src/snapshot/embedded/platform-embedded-file-writer-win.cc
@@ -182,7 +182,7 @@ void EmitUnwindData(PlatformEmbeddedFileWriterWin* w,
 
   // Fairly arbitrary but should fit all symbol names.
   static constexpr int kTemporaryStringLength = 256;
-  i::EmbeddedVector<char, kTemporaryStringLength> unwind_info_full_symbol;
+  base::EmbeddedVector<char, kTemporaryStringLength> unwind_info_full_symbol;
 
   // Emit a RUNTIME_FUNCTION (PDATA) entry for each builtin function, as
   // documented here:
diff --git a/src/snapshot/mksnapshot.cc b/src/snapshot/mksnapshot.cc
index 9a1e988bf8..4e5b43b23f 100644
--- a/src/snapshot/mksnapshot.cc
+++ b/src/snapshot/mksnapshot.cc
@@ -12,6 +12,7 @@
 #include "src/base/platform/platform.h"
 #include "src/base/platform/wrappers.h"
 #include "src/base/sanitizer/msan.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-arch.h"
 #include "src/codegen/source-position-table.h"
 #include "src/flags/flags.h"
@@ -37,14 +38,15 @@ class SnapshotFileWriter {
     // we end up with a corrupted snapshot file. The build step would succeed,
     // but the build target is unusable. Ideally we would write out temporary
     // files and only move them to the final destination as last step.
-    i::Vector<const i::byte> blob_vector(
+    v8::base::Vector<const i::byte> blob_vector(
         reinterpret_cast<const i::byte*>(blob.data), blob.raw_size);
     MaybeWriteSnapshotFile(blob_vector);
     MaybeWriteStartupBlob(blob_vector);
   }
 
  private:
-  void MaybeWriteStartupBlob(const i::Vector<const i::byte>& blob) const {
+  void MaybeWriteStartupBlob(
+      const v8::base::Vector<const i::byte>& blob) const {
     if (!snapshot_blob_path_) return;
 
     FILE* fp = GetFileDescriptorOrDie(snapshot_blob_path_);
@@ -57,7 +59,8 @@ class SnapshotFileWriter {
     }
   }
 
-  void MaybeWriteSnapshotFile(const i::Vector<const i::byte>& blob) const {
+  void MaybeWriteSnapshotFile(
+      const v8::base::Vector<const i::byte>& blob) const {
     if (!snapshot_cpp_path_) return;
 
     FILE* fp = GetFileDescriptorOrDie(snapshot_cpp_path_);
@@ -86,8 +89,8 @@ class SnapshotFileWriter {
     fprintf(fp, "}  // namespace v8\n");
   }
 
-  static void WriteSnapshotFileData(FILE* fp,
-                                    const i::Vector<const i::byte>& blob) {
+  static void WriteSnapshotFileData(
+      FILE* fp, const v8::base::Vector<const i::byte>& blob) {
     fprintf(fp,
             "alignas(kPointerAlignment) static const byte blob_data[] = {\n");
     WriteBinaryContentsAsCArray(fp, blob);
@@ -98,7 +101,7 @@ class SnapshotFileWriter {
   }
 
   static void WriteBinaryContentsAsCArray(
-      FILE* fp, const i::Vector<const i::byte>& blob) {
+      FILE* fp, const v8::base::Vector<const i::byte>& blob) {
     for (int i = 0; i < blob.length(); i++) {
       if ((i & 0x1F) == 0x1F) fprintf(fp, "\n");
       if (i > 0) fprintf(fp, ",");
diff --git a/src/snapshot/snapshot-compression.cc b/src/snapshot/snapshot-compression.cc
index 09ac2eecda..81e983f263 100644
--- a/src/snapshot/snapshot-compression.cc
+++ b/src/snapshot/snapshot-compression.cc
@@ -62,7 +62,7 @@ SnapshotData SnapshotCompression::Compress(
 }
 
 SnapshotData SnapshotCompression::Decompress(
-    Vector<const byte> compressed_data) {
+    base::Vector<const byte> compressed_data) {
   SnapshotData snapshot_data;
   base::ElapsedTimer timer;
   if (FLAG_profile_deserialization) timer.Start();
diff --git a/src/snapshot/snapshot-compression.h b/src/snapshot/snapshot-compression.h
index fe637bd1a6..bff4c1653c 100644
--- a/src/snapshot/snapshot-compression.h
+++ b/src/snapshot/snapshot-compression.h
@@ -5,8 +5,8 @@
 #ifndef V8_SNAPSHOT_SNAPSHOT_COMPRESSION_H_
 #define V8_SNAPSHOT_SNAPSHOT_COMPRESSION_H_
 
+#include "src/base/vector.h"
 #include "src/snapshot/snapshot-data.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -16,7 +16,7 @@ class SnapshotCompression : public AllStatic {
   V8_EXPORT_PRIVATE static SnapshotData Compress(
       const SnapshotData* uncompressed_data);
   V8_EXPORT_PRIVATE static SnapshotData Decompress(
-      Vector<const byte> compressed_data);
+      base::Vector<const byte> compressed_data);
 };
 
 }  // namespace internal
diff --git a/src/snapshot/snapshot-data.cc b/src/snapshot/snapshot-data.cc
index 0a5bbaaf2a..d3fc7f1004 100644
--- a/src/snapshot/snapshot-data.cc
+++ b/src/snapshot/snapshot-data.cc
@@ -46,11 +46,11 @@ SnapshotData::SnapshotData(const Serializer* serializer) {
             static_cast<size_t>(payload->size()));
 }
 
-Vector<const byte> SnapshotData::Payload() const {
+base::Vector<const byte> SnapshotData::Payload() const {
   const byte* payload = data_ + kHeaderSize;
   uint32_t length = GetHeaderValue(kPayloadLengthOffset);
   DCHECK_EQ(data_ + size_, payload + length);
-  return Vector<const byte>(payload, length);
+  return base::Vector<const byte>(payload, length);
 }
 
 }  // namespace internal
diff --git a/src/snapshot/snapshot-data.h b/src/snapshot/snapshot-data.h
index a7d6872bc6..2127cca719 100644
--- a/src/snapshot/snapshot-data.h
+++ b/src/snapshot/snapshot-data.h
@@ -7,9 +7,9 @@
 
 #include "src/base/bit-field.h"
 #include "src/base/memory.h"
+#include "src/base/vector.h"
 #include "src/codegen/external-reference-table.h"
 #include "src/utils/memcopy.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -73,14 +73,14 @@ class V8_EXPORT_PRIVATE SnapshotData : public SerializedData {
   explicit SnapshotData(const Serializer* serializer);
 
   // Used when consuming.
-  explicit SnapshotData(const Vector<const byte> snapshot)
+  explicit SnapshotData(const base::Vector<const byte> snapshot)
       : SerializedData(const_cast<byte*>(snapshot.begin()), snapshot.length()) {
   }
 
-  virtual Vector<const byte> Payload() const;
+  virtual base::Vector<const byte> Payload() const;
 
-  Vector<const byte> RawData() const {
-    return Vector<const byte>(data_, size_);
+  base::Vector<const byte> RawData() const {
+    return base::Vector<const byte>(data_, size_);
   }
 
  protected:
diff --git a/src/snapshot/snapshot-source-sink.h b/src/snapshot/snapshot-source-sink.h
index 964b0495f4..e14e76cb04 100644
--- a/src/snapshot/snapshot-source-sink.h
+++ b/src/snapshot/snapshot-source-sink.h
@@ -30,7 +30,7 @@ class SnapshotByteSource final {
         length_(length),
         position_(0) {}
 
-  explicit SnapshotByteSource(Vector<const byte> payload)
+  explicit SnapshotByteSource(base::Vector<const byte> payload)
       : data_(payload.begin()), length_(payload.length()), position_(0) {}
 
   ~SnapshotByteSource() = default;
@@ -104,7 +104,7 @@ class SnapshotByteSource final {
   void set_position(int position) { position_ = position; }
 
   uint32_t GetChecksum() const {
-    return Checksum(Vector<const byte>(data_, length_));
+    return Checksum(base::Vector<const byte>(data_, length_));
   }
 
  private:
diff --git a/src/snapshot/snapshot-utils.cc b/src/snapshot/snapshot-utils.cc
index df53dfe751..6db6698d7e 100644
--- a/src/snapshot/snapshot-utils.cc
+++ b/src/snapshot/snapshot-utils.cc
@@ -10,7 +10,7 @@
 namespace v8 {
 namespace internal {
 
-uint32_t Checksum(Vector<const byte> payload) {
+uint32_t Checksum(base::Vector<const byte> payload) {
 #ifdef MEMORY_SANITIZER
   // Computing the checksum includes padding bytes for objects like strings.
   // Mark every object as initialized in the code serializer.
diff --git a/src/snapshot/snapshot-utils.h b/src/snapshot/snapshot-utils.h
index 631de89e21..f21195a4ac 100644
--- a/src/snapshot/snapshot-utils.h
+++ b/src/snapshot/snapshot-utils.h
@@ -5,13 +5,13 @@
 #ifndef V8_SNAPSHOT_SNAPSHOT_UTILS_H_
 #define V8_SNAPSHOT_SNAPSHOT_UTILS_H_
 
+#include "src/base/vector.h"
 #include "src/common/globals.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
 
-V8_EXPORT_PRIVATE uint32_t Checksum(Vector<const byte> payload);
+V8_EXPORT_PRIVATE uint32_t Checksum(base::Vector<const byte> payload);
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/snapshot/snapshot.cc b/src/snapshot/snapshot.cc
index 249ef21e09..3d78e83061 100644
--- a/src/snapshot/snapshot.cc
+++ b/src/snapshot/snapshot.cc
@@ -44,10 +44,12 @@ class SnapshotImpl : public AllStatic {
   static uint32_t ExtractNumContexts(const v8::StartupData* data);
   static uint32_t ExtractContextOffset(const v8::StartupData* data,
                                        uint32_t index);
-  static Vector<const byte> ExtractStartupData(const v8::StartupData* data);
-  static Vector<const byte> ExtractReadOnlyData(const v8::StartupData* data);
-  static Vector<const byte> ExtractContextData(const v8::StartupData* data,
-                                               uint32_t index);
+  static base::Vector<const byte> ExtractStartupData(
+      const v8::StartupData* data);
+  static base::Vector<const byte> ExtractReadOnlyData(
+      const v8::StartupData* data);
+  static base::Vector<const byte> ExtractContextData(
+      const v8::StartupData* data, uint32_t index);
 
   static uint32_t GetHeaderValue(const v8::StartupData* data, uint32_t offset) {
     return base::ReadLittleEndianValue<uint32_t>(
@@ -87,10 +89,11 @@ class SnapshotImpl : public AllStatic {
   static const uint32_t kFirstContextOffsetOffset =
       kReadOnlyOffsetOffset + kUInt32Size;
 
-  static Vector<const byte> ChecksummedContent(const v8::StartupData* data) {
+  static base::Vector<const byte> ChecksummedContent(
+      const v8::StartupData* data) {
     STATIC_ASSERT(kVersionStringOffset == kChecksumOffset + kUInt32Size);
     const uint32_t kChecksumStart = kVersionStringOffset;
-    return Vector<const byte>(
+    return base::Vector<const byte>(
         reinterpret_cast<const byte*>(data->data + kChecksumStart),
         data->raw_size - kChecksumStart);
   }
@@ -107,7 +110,7 @@ class SnapshotImpl : public AllStatic {
 
 }  // namespace
 
-SnapshotData MaybeDecompress(const Vector<const byte>& snapshot_data) {
+SnapshotData MaybeDecompress(const base::Vector<const byte>& snapshot_data) {
 #ifdef V8_SNAPSHOT_COMPRESSION
   return SnapshotCompression::Decompress(snapshot_data);
 #else
@@ -137,7 +140,8 @@ bool Snapshot::VersionIsValid(const v8::StartupData* data) {
   CHECK_LT(
       SnapshotImpl::kVersionStringOffset + SnapshotImpl::kVersionStringLength,
       static_cast<uint32_t>(data->raw_size));
-  Version::GetString(Vector<char>(version, SnapshotImpl::kVersionStringLength));
+  Version::GetString(
+      base::Vector<char>(version, SnapshotImpl::kVersionStringLength));
   return strncmp(version, data->data + SnapshotImpl::kVersionStringOffset,
                  SnapshotImpl::kVersionStringLength) == 0;
 }
@@ -151,8 +155,10 @@ bool Snapshot::Initialize(Isolate* isolate) {
   const v8::StartupData* blob = isolate->snapshot_blob();
   SnapshotImpl::CheckVersion(blob);
   CHECK(VerifyChecksum(blob));
-  Vector<const byte> startup_data = SnapshotImpl::ExtractStartupData(blob);
-  Vector<const byte> read_only_data = SnapshotImpl::ExtractReadOnlyData(blob);
+  base::Vector<const byte> startup_data =
+      SnapshotImpl::ExtractStartupData(blob);
+  base::Vector<const byte> read_only_data =
+      SnapshotImpl::ExtractReadOnlyData(blob);
 
   SnapshotData startup_snapshot_data(MaybeDecompress(startup_data));
   SnapshotData read_only_snapshot_data(MaybeDecompress(read_only_data));
@@ -178,7 +184,7 @@ MaybeHandle<Context> Snapshot::NewContextFromSnapshot(
 
   const v8::StartupData* blob = isolate->snapshot_blob();
   bool can_rehash = ExtractRehashability(blob);
-  Vector<const byte> context_data = SnapshotImpl::ExtractContextData(
+  base::Vector<const byte> context_data = SnapshotImpl::ExtractContextData(
       blob, static_cast<uint32_t>(context_index));
   SnapshotData snapshot_data(MaybeDecompress(context_data));
 
@@ -470,8 +476,9 @@ v8::StartupData SnapshotImpl::CreateSnapshotBlob(
   // Write version string into snapshot data.
   memset(data + SnapshotImpl::kVersionStringOffset, 0,
          SnapshotImpl::kVersionStringLength);
-  Version::GetString(Vector<char>(data + SnapshotImpl::kVersionStringOffset,
-                                  SnapshotImpl::kVersionStringLength));
+  Version::GetString(
+      base::Vector<char>(data + SnapshotImpl::kVersionStringOffset,
+                         SnapshotImpl::kVersionStringLength));
 
   // Startup snapshot (isolate-specific data).
   uint32_t payload_offset = startup_snapshot_offset;
@@ -565,18 +572,19 @@ bool Snapshot::ExtractRehashability(const v8::StartupData* data) {
 }
 
 namespace {
-Vector<const byte> ExtractData(const v8::StartupData* snapshot,
-                               uint32_t start_offset, uint32_t end_offset) {
+base::Vector<const byte> ExtractData(const v8::StartupData* snapshot,
+                                     uint32_t start_offset,
+                                     uint32_t end_offset) {
   CHECK_LT(start_offset, end_offset);
   CHECK_LT(end_offset, snapshot->raw_size);
   uint32_t length = end_offset - start_offset;
   const byte* data =
       reinterpret_cast<const byte*>(snapshot->data + start_offset);
-  return Vector<const byte>(data, length);
+  return base::Vector<const byte>(data, length);
 }
 }  // namespace
 
-Vector<const byte> SnapshotImpl::ExtractStartupData(
+base::Vector<const byte> SnapshotImpl::ExtractStartupData(
     const v8::StartupData* data) {
   DCHECK(Snapshot::SnapshotIsValid(data));
 
@@ -585,7 +593,7 @@ Vector<const byte> SnapshotImpl::ExtractStartupData(
                      GetHeaderValue(data, kReadOnlyOffsetOffset));
 }
 
-Vector<const byte> SnapshotImpl::ExtractReadOnlyData(
+base::Vector<const byte> SnapshotImpl::ExtractReadOnlyData(
     const v8::StartupData* data) {
   DCHECK(Snapshot::SnapshotIsValid(data));
 
@@ -593,8 +601,8 @@ Vector<const byte> SnapshotImpl::ExtractReadOnlyData(
                      GetHeaderValue(data, ContextSnapshotOffsetOffset(0)));
 }
 
-Vector<const byte> SnapshotImpl::ExtractContextData(const v8::StartupData* data,
-                                                    uint32_t index) {
+base::Vector<const byte> SnapshotImpl::ExtractContextData(
+    const v8::StartupData* data, uint32_t index) {
   uint32_t num_contexts = ExtractNumContexts(data);
   CHECK_LT(index, num_contexts);
 
@@ -610,7 +618,7 @@ Vector<const byte> SnapshotImpl::ExtractContextData(const v8::StartupData* data,
   const byte* context_data =
       reinterpret_cast<const byte*>(data->data + context_offset);
   uint32_t context_length = next_context_offset - context_offset;
-  return Vector<const byte>(context_data, context_length);
+  return base::Vector<const byte>(context_data, context_length);
 }
 
 void SnapshotImpl::CheckVersion(const v8::StartupData* data) {
@@ -619,7 +627,7 @@ void SnapshotImpl::CheckVersion(const v8::StartupData* data) {
     memset(version, 0, kVersionStringLength);
     CHECK_LT(kVersionStringOffset + kVersionStringLength,
              static_cast<uint32_t>(data->raw_size));
-    Version::GetString(Vector<char>(version, kVersionStringLength));
+    Version::GetString(base::Vector<char>(version, kVersionStringLength));
     FATAL(
         "Version mismatch between V8 binary and snapshot.\n"
         "#   V8 binary version: %.*s\n"
diff --git a/src/strings/string-builder-inl.h b/src/strings/string-builder-inl.h
index 80b88963c0..d37b96b554 100644
--- a/src/strings/string-builder-inl.h
+++ b/src/strings/string-builder-inl.h
@@ -150,7 +150,7 @@ class IncrementalStringBuilder {
   V8_INLINE void AppendInt(int i) {
     char buffer[kIntToCStringBufferSize];
     const char* str =
-        IntToCString(i, Vector<char>(buffer, kIntToCStringBufferSize));
+        IntToCString(i, base::Vector<char>(buffer, kIntToCStringBufferSize));
     AppendCString(str);
   }
 
diff --git a/src/strings/string-hasher.h b/src/strings/string-hasher.h
index 839fbc46a2..c26fe79426 100644
--- a/src/strings/string-hasher.h
+++ b/src/strings/string-hasher.h
@@ -8,10 +8,13 @@
 #include "src/common/globals.h"
 
 namespace v8 {
-namespace internal {
 
+namespace base {
 template <typename T>
 class Vector;
+}  // namespace base
+
+namespace internal {
 
 // Helper class for incrementally calculating string hashes in a form suitable
 // for storing into Name::raw_hash_field.
diff --git a/src/strings/string-search.h b/src/strings/string-search.h
index 410e078daa..f922489d23 100644
--- a/src/strings/string-search.h
+++ b/src/strings/string-search.h
@@ -5,8 +5,8 @@
 #ifndef V8_STRINGS_STRING_SEARCH_H_
 #define V8_STRINGS_STRING_SEARCH_H_
 
+#include "src/base/vector.h"
 #include "src/execution/isolate.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -40,11 +40,11 @@ class StringSearchBase {
   // to compensate for the algorithmic overhead compared to simple brute force.
   static const int kBMMinPatternLength = 7;
 
-  static inline bool IsOneByteString(Vector<const uint8_t> string) {
+  static inline bool IsOneByteString(base::Vector<const uint8_t> string) {
     return true;
   }
 
-  static inline bool IsOneByteString(Vector<const uc16> string) {
+  static inline bool IsOneByteString(base::Vector<const uc16> string) {
     return String::IsOneByte(string.begin(), string.length());
   }
 
@@ -54,7 +54,7 @@ class StringSearchBase {
 template <typename PatternChar, typename SubjectChar>
 class StringSearch : private StringSearchBase {
  public:
-  StringSearch(Isolate* isolate, Vector<const PatternChar> pattern)
+  StringSearch(Isolate* isolate, base::Vector<const PatternChar> pattern)
       : isolate_(isolate),
         pattern_(pattern),
         start_(std::max(0, pattern.length() - kBMMaxShift)) {
@@ -76,7 +76,7 @@ class StringSearch : private StringSearchBase {
     strategy_ = &InitialSearch;
   }
 
-  int Search(Vector<const SubjectChar> subject, int index) {
+  int Search(base::Vector<const SubjectChar> subject, int index) {
     return strategy_(this, subject, index);
   }
 
@@ -93,29 +93,31 @@ class StringSearch : private StringSearchBase {
 
  private:
   using SearchFunction = int (*)(StringSearch<PatternChar, SubjectChar>*,
-                                 Vector<const SubjectChar>, int);
+                                 base::Vector<const SubjectChar>, int);
 
   static int FailSearch(StringSearch<PatternChar, SubjectChar>*,
-                        Vector<const SubjectChar>, int) {
+                        base::Vector<const SubjectChar>, int) {
     return -1;
   }
 
   static int SingleCharSearch(StringSearch<PatternChar, SubjectChar>* search,
-                              Vector<const SubjectChar> subject,
+                              base::Vector<const SubjectChar> subject,
                               int start_index);
 
   static int LinearSearch(StringSearch<PatternChar, SubjectChar>* search,
-                          Vector<const SubjectChar> subject, int start_index);
+                          base::Vector<const SubjectChar> subject,
+                          int start_index);
 
   static int InitialSearch(StringSearch<PatternChar, SubjectChar>* search,
-                           Vector<const SubjectChar> subject, int start_index);
+                           base::Vector<const SubjectChar> subject,
+                           int start_index);
 
   static int BoyerMooreHorspoolSearch(
       StringSearch<PatternChar, SubjectChar>* search,
-      Vector<const SubjectChar> subject, int start_index);
+      base::Vector<const SubjectChar> subject, int start_index);
 
   static int BoyerMooreSearch(StringSearch<PatternChar, SubjectChar>* search,
-                              Vector<const SubjectChar> subject,
+                              base::Vector<const SubjectChar> subject,
                               int start_index);
 
   void PopulateBoyerMooreHorspoolTable();
@@ -170,7 +172,7 @@ class StringSearch : private StringSearchBase {
 
   Isolate* isolate_;
   // The pattern to search for.
-  Vector<const PatternChar> pattern_;
+  base::Vector<const PatternChar> pattern_;
   // Pointer to implementation of the search.
   SearchFunction strategy_;
   // Cache value of max(0, pattern_length() - kBMMaxShift)
@@ -191,8 +193,9 @@ inline uint8_t GetHighestValueByte(uc16 character) {
 inline uint8_t GetHighestValueByte(uint8_t character) { return character; }
 
 template <typename PatternChar, typename SubjectChar>
-inline int FindFirstCharacter(Vector<const PatternChar> pattern,
-                              Vector<const SubjectChar> subject, int index) {
+inline int FindFirstCharacter(base::Vector<const PatternChar> pattern,
+                              base::Vector<const SubjectChar> subject,
+                              int index) {
   const PatternChar pattern_first_char = pattern[0];
   const int max_n = (subject.length() - pattern.length() + 1);
 
@@ -229,7 +232,7 @@ inline int FindFirstCharacter(Vector<const PatternChar> pattern,
 template <typename PatternChar, typename SubjectChar>
 int StringSearch<PatternChar, SubjectChar>::SingleCharSearch(
     StringSearch<PatternChar, SubjectChar>* search,
-    Vector<const SubjectChar> subject, int index) {
+    base::Vector<const SubjectChar> subject, int index) {
   DCHECK_EQ(1, search->pattern_.length());
   PatternChar pattern_first_char = search->pattern_[0];
   if (sizeof(PatternChar) > sizeof(SubjectChar)) {
@@ -262,8 +265,8 @@ inline bool CharCompare(const PatternChar* pattern, const SubjectChar* subject,
 template <typename PatternChar, typename SubjectChar>
 int StringSearch<PatternChar, SubjectChar>::LinearSearch(
     StringSearch<PatternChar, SubjectChar>* search,
-    Vector<const SubjectChar> subject, int index) {
-  Vector<const PatternChar> pattern = search->pattern_;
+    base::Vector<const SubjectChar> subject, int index) {
+  base::Vector<const PatternChar> pattern = search->pattern_;
   DCHECK_GT(pattern.length(), 1);
   int pattern_length = pattern.length();
   int i = index;
@@ -290,8 +293,8 @@ int StringSearch<PatternChar, SubjectChar>::LinearSearch(
 template <typename PatternChar, typename SubjectChar>
 int StringSearch<PatternChar, SubjectChar>::BoyerMooreSearch(
     StringSearch<PatternChar, SubjectChar>* search,
-    Vector<const SubjectChar> subject, int start_index) {
-  Vector<const PatternChar> pattern = search->pattern_;
+    base::Vector<const SubjectChar> subject, int start_index) {
+  base::Vector<const PatternChar> pattern = search->pattern_;
   int subject_length = subject.length();
   int pattern_length = pattern.length();
   // Only preprocess at most kBMMaxShift last characters of pattern.
@@ -409,8 +412,8 @@ void StringSearch<PatternChar, SubjectChar>::PopulateBoyerMooreTable() {
 template <typename PatternChar, typename SubjectChar>
 int StringSearch<PatternChar, SubjectChar>::BoyerMooreHorspoolSearch(
     StringSearch<PatternChar, SubjectChar>* search,
-    Vector<const SubjectChar> subject, int start_index) {
-  Vector<const PatternChar> pattern = search->pattern_;
+    base::Vector<const SubjectChar> subject, int start_index) {
+  base::Vector<const PatternChar> pattern = search->pattern_;
   int subject_length = subject.length();
   int pattern_length = pattern.length();
   int* char_occurrences = search->bad_char_table();
@@ -491,8 +494,8 @@ void StringSearch<PatternChar, SubjectChar>::PopulateBoyerMooreHorspoolTable() {
 template <typename PatternChar, typename SubjectChar>
 int StringSearch<PatternChar, SubjectChar>::InitialSearch(
     StringSearch<PatternChar, SubjectChar>* search,
-    Vector<const SubjectChar> subject, int index) {
-  Vector<const PatternChar> pattern = search->pattern_;
+    base::Vector<const SubjectChar> subject, int index) {
+  base::Vector<const PatternChar> pattern = search->pattern_;
   int pattern_length = pattern.length();
   // Badness is a count of how much work we have done.  When we have
   // done enough work we decide it's probably worth switching to a better
@@ -532,8 +535,8 @@ int StringSearch<PatternChar, SubjectChar>::InitialSearch(
 // object should be constructed once and the Search function then called
 // for each search.
 template <typename SubjectChar, typename PatternChar>
-int SearchString(Isolate* isolate, Vector<const SubjectChar> subject,
-                 Vector<const PatternChar> pattern, int start_index) {
+int SearchString(Isolate* isolate, base::Vector<const SubjectChar> subject,
+                 base::Vector<const PatternChar> pattern, int start_index) {
   StringSearch<PatternChar, SubjectChar> search(isolate, pattern);
   return search.Search(subject, start_index);
 }
@@ -546,8 +549,8 @@ intptr_t SearchStringRaw(Isolate* isolate, const SubjectChar* subject_ptr,
                          int subject_length, const PatternChar* pattern_ptr,
                          int pattern_length, int start_index) {
   DisallowGarbageCollection no_gc;
-  Vector<const SubjectChar> subject(subject_ptr, subject_length);
-  Vector<const PatternChar> pattern(pattern_ptr, pattern_length);
+  base::Vector<const SubjectChar> subject(subject_ptr, subject_length);
+  base::Vector<const PatternChar> pattern(pattern_ptr, pattern_length);
   return SearchString(isolate, subject, pattern, start_index);
 }
 
diff --git a/src/strings/string-stream.cc b/src/strings/string-stream.cc
index ed1939ae0f..44af1ddcfe 100644
--- a/src/strings/string-stream.cc
+++ b/src/strings/string-stream.cc
@@ -6,12 +6,12 @@
 
 #include <memory>
 
+#include "src/base/vector.h"
 #include "src/handles/handles-inl.h"
 #include "src/logging/log.h"
 #include "src/objects/js-array-inl.h"
 #include "src/objects/objects-inl.h"
 #include "src/objects/prototype.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -85,7 +85,8 @@ static bool IsControlChar(char c) {
   }
 }
 
-void StringStream::Add(Vector<const char> format, Vector<FmtElm> elms) {
+void StringStream::Add(base::Vector<const char> format,
+                       base::Vector<FmtElm> elms) {
   // If we already ran out of space then return immediately.
   if (full()) return;
   int offset = 0;
@@ -97,7 +98,7 @@ void StringStream::Add(Vector<const char> format, Vector<FmtElm> elms) {
       continue;
     }
     // Read this formatting directive into a temporary buffer
-    EmbeddedVector<char, 24> temp;
+    base::EmbeddedVector<char, 24> temp;
     int format_length = 0;
     // Skip over the whole control character sequence until the
     // format element type
@@ -119,7 +120,7 @@ void StringStream::Add(Vector<const char> format, Vector<FmtElm> elms) {
       }
       case 'w': {
         DCHECK_EQ(FmtElm::LC_STR, current.type_);
-        Vector<const uc16> value = *current.data_.u_lc_str_;
+        base::Vector<const uc16> value = *current.data_.u_lc_str_;
         for (int i = 0; i < value.length(); i++)
           Put(static_cast<char>(value[i]));
         break;
@@ -149,9 +150,9 @@ void StringStream::Add(Vector<const char> format, Vector<FmtElm> elms) {
       case 'c':
       case 'X': {
         int value = current.data_.u_int_;
-        EmbeddedVector<char, 24> formatted;
+        base::EmbeddedVector<char, 24> formatted;
         int length = SNPrintF(formatted, temp.begin(), value);
-        Add(Vector<const char>(formatted.begin(), length));
+        Add(base::Vector<const char>(formatted.begin(), length));
         break;
       }
       case 'f':
@@ -168,7 +169,7 @@ void StringStream::Add(Vector<const char> format, Vector<FmtElm> elms) {
         } else if (std::isnan(value)) {
           Add("nan");
         } else {
-          EmbeddedVector<char, 28> formatted;
+          base::EmbeddedVector<char, 28> formatted;
           SNPrintF(formatted, temp.begin(), value);
           Add(formatted.begin());
         }
@@ -176,7 +177,7 @@ void StringStream::Add(Vector<const char> format, Vector<FmtElm> elms) {
       }
       case 'p': {
         void* value = current.data_.u_pointer_;
-        EmbeddedVector<char, 20> formatted;
+        base::EmbeddedVector<char, 20> formatted;
         SNPrintF(formatted, temp.begin(), value);
         Add(formatted.begin());
         break;
@@ -248,7 +249,7 @@ void StringStream::OutputToFile(FILE* out) {
 
 Handle<String> StringStream::ToString(Isolate* isolate) {
   return isolate->factory()
-      ->NewStringFromUtf8(Vector<const char>(buffer_, length_))
+      ->NewStringFromUtf8(base::Vector<const char>(buffer_, length_))
       .ToHandleChecked();
 }
 
diff --git a/src/strings/string-stream.h b/src/strings/string-stream.h
index d0624abb6e..9a470267bf 100644
--- a/src/strings/string-stream.h
+++ b/src/strings/string-stream.h
@@ -8,10 +8,10 @@
 #include <memory>
 
 #include "src/base/small-vector.h"
+#include "src/base/vector.h"
 #include "src/handles/handles.h"
 #include "src/objects/heap-object.h"
 #include "src/utils/allocation.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -98,7 +98,7 @@ class StringStream final {
     FmtElm(const char* value) : FmtElm(C_STR) {  // NOLINT
       data_.u_c_str_ = value;
     }
-    FmtElm(const Vector<const uc16>& value) : FmtElm(LC_STR) {  // NOLINT
+    FmtElm(const base::Vector<const uc16>& value) : FmtElm(LC_STR) {  // NOLINT
       data_.u_lc_str_ = &value;
     }
     FmtElm(Object value) : FmtElm(OBJ) {  // NOLINT
@@ -126,7 +126,7 @@ class StringStream final {
       int u_int_;
       double u_double_;
       const char* u_c_str_;
-      const Vector<const uc16>* u_lc_str_;
+      const base::Vector<const uc16>* u_lc_str_;
       Address u_obj_;
       Address* u_handle_;
       void* u_pointer_;
@@ -148,18 +148,20 @@ class StringStream final {
   bool Put(char c);
   bool Put(String str);
   bool Put(String str, int start, int end);
-  void Add(const char* format) { Add(CStrVector(format)); }
-  void Add(Vector<const char> format) { Add(format, Vector<FmtElm>()); }
+  void Add(const char* format) { Add(base::CStrVector(format)); }
+  void Add(base::Vector<const char> format) {
+    Add(format, base::Vector<FmtElm>());
+  }
 
   template <typename... Args>
   void Add(const char* format, Args... args) {
-    Add(CStrVector(format), args...);
+    Add(base::CStrVector(format), args...);
   }
 
   template <typename... Args>
-  void Add(Vector<const char> format, Args... args) {
+  void Add(base::Vector<const char> format, Args... args) {
     FmtElm elems[]{args...};
-    Add(format, ArrayVector(elems));
+    Add(format, base::ArrayVector(elems));
   }
 
   // Getting the message out.
@@ -196,7 +198,7 @@ class StringStream final {
   static const int kInitialCapacity = 16;
 
  private:
-  void Add(Vector<const char> format, Vector<FmtElm> elms);
+  void Add(base::Vector<const char> format, base::Vector<FmtElm> elms);
   void PrintObject(Object obj);
 
   StringAllocator* allocator_;
diff --git a/src/strings/unicode-decoder.cc b/src/strings/unicode-decoder.cc
index b8d3c3e8ba..b4cc7b9b55 100644
--- a/src/strings/unicode-decoder.cc
+++ b/src/strings/unicode-decoder.cc
@@ -10,7 +10,7 @@
 namespace v8 {
 namespace internal {
 
-Utf8Decoder::Utf8Decoder(const Vector<const uint8_t>& chars)
+Utf8Decoder::Utf8Decoder(const base::Vector<const uint8_t>& chars)
     : encoding_(Encoding::kAscii),
       non_ascii_start_(NonAsciiStart(chars.begin(), chars.length())),
       utf16_length_(non_ascii_start_) {
@@ -43,7 +43,7 @@ Utf8Decoder::Utf8Decoder(const Vector<const uint8_t>& chars)
 }
 
 template <typename Char>
-void Utf8Decoder::Decode(Char* out, const Vector<const uint8_t>& data) {
+void Utf8Decoder::Decode(Char* out, const base::Vector<const uint8_t>& data) {
   CopyChars(out, data.begin(), non_ascii_start_);
 
   out += non_ascii_start_;
@@ -72,10 +72,10 @@ void Utf8Decoder::Decode(Char* out, const Vector<const uint8_t>& data) {
 }
 
 template V8_EXPORT_PRIVATE void Utf8Decoder::Decode(
-    uint8_t* out, const Vector<const uint8_t>& data);
+    uint8_t* out, const base::Vector<const uint8_t>& data);
 
 template V8_EXPORT_PRIVATE void Utf8Decoder::Decode(
-    uint16_t* out, const Vector<const uint8_t>& data);
+    uint16_t* out, const base::Vector<const uint8_t>& data);
 
 }  // namespace internal
 }  // namespace v8
diff --git a/src/strings/unicode-decoder.h b/src/strings/unicode-decoder.h
index e35d176770..464869351b 100644
--- a/src/strings/unicode-decoder.h
+++ b/src/strings/unicode-decoder.h
@@ -5,8 +5,8 @@
 #ifndef V8_STRINGS_UNICODE_DECODER_H_
 #define V8_STRINGS_UNICODE_DECODER_H_
 
+#include "src/base/vector.h"
 #include "src/strings/unicode.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -52,7 +52,7 @@ class V8_EXPORT_PRIVATE Utf8Decoder final {
  public:
   enum class Encoding : uint8_t { kAscii, kLatin1, kUtf16 };
 
-  explicit Utf8Decoder(const Vector<const uint8_t>& chars);
+  explicit Utf8Decoder(const base::Vector<const uint8_t>& chars);
 
   bool is_ascii() const { return encoding_ == Encoding::kAscii; }
   bool is_one_byte() const { return encoding_ <= Encoding::kLatin1; }
@@ -60,7 +60,8 @@ class V8_EXPORT_PRIVATE Utf8Decoder final {
   int non_ascii_start() const { return non_ascii_start_; }
 
   template <typename Char>
-  V8_EXPORT_PRIVATE void Decode(Char* out, const Vector<const uint8_t>& data);
+  V8_EXPORT_PRIVATE void Decode(Char* out,
+                                const base::Vector<const uint8_t>& data);
 
  private:
   Encoding encoding_;
diff --git a/src/strings/uri.cc b/src/strings/uri.cc
index 925a5fca72..befecc308b 100644
--- a/src/strings/uri.cc
+++ b/src/strings/uri.cc
@@ -183,7 +183,7 @@ MaybeHandle<String> Uri::Decode(Isolate* isolate, Handle<String> uri,
   }
 
   if (two_byte_buffer.empty()) {
-    return isolate->factory()->NewStringFromOneByte(Vector<const uint8_t>(
+    return isolate->factory()->NewStringFromOneByte(base::Vector<const uint8_t>(
         one_byte_buffer.data(), static_cast<int>(one_byte_buffer.size())));
   }
 
@@ -313,13 +313,14 @@ MaybeHandle<String> Uri::Encode(Isolate* isolate, Handle<String> uri,
     }
   }
 
-  return isolate->factory()->NewStringFromOneByte(VectorOf(buffer));
+  return isolate->factory()->NewStringFromOneByte(base::VectorOf(buffer));
 }
 
 namespace {  // Anonymous namespace for Escape and Unescape
 
 template <typename Char>
-int UnescapeChar(Vector<const Char> vector, int i, int length, int* step) {
+int UnescapeChar(base::Vector<const Char> vector, int i, int length,
+                 int* step) {
   uint16_t character = vector[i];
   int32_t hi = 0;
   int32_t lo = 0;
@@ -347,7 +348,7 @@ MaybeHandle<String> UnescapeSlow(Isolate* isolate, Handle<String> string,
   int unescaped_length = 0;
   {
     DisallowGarbageCollection no_gc;
-    Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
+    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
     for (int i = start_index; i < length; unescaped_length++) {
       int step;
       if (UnescapeChar(vector, i, length, &step) >
@@ -370,7 +371,7 @@ MaybeHandle<String> UnescapeSlow(Isolate* isolate, Handle<String> string,
                                         ->NewRawOneByteString(unescaped_length)
                                         .ToHandleChecked();
     DisallowGarbageCollection no_gc;
-    Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
+    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
     for (int i = start_index; i < length; dest_position++) {
       int step;
       dest->SeqOneByteStringSet(dest_position,
@@ -383,7 +384,7 @@ MaybeHandle<String> UnescapeSlow(Isolate* isolate, Handle<String> string,
                                         ->NewRawTwoByteString(unescaped_length)
                                         .ToHandleChecked();
     DisallowGarbageCollection no_gc;
-    Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
+    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
     for (int i = start_index; i < length; dest_position++) {
       int step;
       dest->SeqTwoByteStringSet(dest_position,
@@ -420,7 +421,7 @@ static MaybeHandle<String> UnescapePrivate(Isolate* isolate,
   int index;
   {
     DisallowGarbageCollection no_gc;
-    StringSearch<uint8_t, Char> search(isolate, StaticOneByteVector("%"));
+    StringSearch<uint8_t, Char> search(isolate, base::StaticOneByteVector("%"));
     index = search.Search(source->GetCharVector<Char>(no_gc), 0);
     if (index < 0) return source;
   }
@@ -436,7 +437,7 @@ static MaybeHandle<String> EscapePrivate(Isolate* isolate,
 
   {
     DisallowGarbageCollection no_gc;
-    Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
+    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
     for (int i = 0; i < length; i++) {
       uint16_t c = vector[i];
       if (c >= 256) {
@@ -464,7 +465,7 @@ static MaybeHandle<String> EscapePrivate(Isolate* isolate,
 
   {
     DisallowGarbageCollection no_gc;
-    Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
+    base::Vector<const Char> vector = string->GetCharVector<Char>(no_gc);
     for (int i = 0; i < length; i++) {
       uint16_t c = vector[i];
       if (c >= 256) {
diff --git a/src/tracing/traced-value.cc b/src/tracing/traced-value.cc
index bc5398a567..bada0f8a5f 100644
--- a/src/tracing/traced-value.cc
+++ b/src/tracing/traced-value.cc
@@ -5,8 +5,8 @@
 #include "src/tracing/traced-value.h"
 
 #include "src/base/platform/platform.h"
+#include "src/base/vector.h"
 #include "src/numbers/conversions.h"
-#include "src/utils/vector.h"
 
 #ifdef V8_USE_PERFETTO
 #include "protos/perfetto/trace/track_event/debug_annotation.pbzero.h"
@@ -95,8 +95,8 @@ void TracedValue::SetInteger(const char* name, int value) {
 void TracedValue::SetDouble(const char* name, double value) {
   DCHECK_CURRENT_CONTAINER_IS(kStackTypeDict);
   WriteName(name);
-  i::EmbeddedVector<char, 100> buffer;
-  data_ += DoubleToCString(value, buffer);
+  base::EmbeddedVector<char, 100> buffer;
+  data_ += internal::DoubleToCString(value, buffer);
 }
 
 void TracedValue::SetBoolean(const char* name, bool value) {
@@ -144,8 +144,8 @@ void TracedValue::AppendInteger(int value) {
 void TracedValue::AppendDouble(double value) {
   DCHECK_CURRENT_CONTAINER_IS(kStackTypeArray);
   WriteComma();
-  i::EmbeddedVector<char, 100> buffer;
-  data_ += DoubleToCString(value, buffer);
+  base::EmbeddedVector<char, 100> buffer;
+  data_ += internal::DoubleToCString(value, buffer);
 }
 
 void TracedValue::AppendBoolean(bool value) {
diff --git a/src/utils/allocation.cc b/src/utils/allocation.cc
index 0c7c468d82..68eb666b24 100644
--- a/src/utils/allocation.cc
+++ b/src/utils/allocation.cc
@@ -13,10 +13,10 @@
 #include "src/base/page-allocator.h"
 #include "src/base/platform/platform.h"
 #include "src/base/sanitizer/lsan-page-allocator.h"
+#include "src/base/vector.h"
 #include "src/flags/flags.h"
 #include "src/init/v8.h"
 #include "src/utils/memcopy.h"
-#include "src/utils/vector.h"
 
 #if V8_LIBC_BIONIC
 #include <malloc.h>
diff --git a/src/utils/scoped-list.h b/src/utils/scoped-list.h
index 76ffe36573..38400a0640 100644
--- a/src/utils/scoped-list.h
+++ b/src/utils/scoped-list.h
@@ -11,10 +11,13 @@
 #include "src/base/logging.h"
 
 namespace v8 {
-namespace internal {
 
+namespace base {
 template <typename T>
 class Vector;
+}  // namespace base
+
+namespace internal {
 
 template <typename T>
 class ZoneList;
@@ -67,9 +70,9 @@ class V8_NODISCARD ScopedList final {
     return *reinterpret_cast<T*>(&buffer_[index]);
   }
 
-  Vector<const T> ToConstVector() const {
+  base::Vector<const T> ToConstVector() const {
     T* data = reinterpret_cast<T*>(buffer_.data() + start_);
-    return Vector<const T>(data, length());
+    return base::Vector<const T>(data, length());
   }
 
   void Add(const T& value) {
@@ -78,7 +81,7 @@ class V8_NODISCARD ScopedList final {
     ++end_;
   }
 
-  void AddAll(const Vector<const T>& list) {
+  void AddAll(const base::Vector<const T>& list) {
     DCHECK_EQ(buffer_.size(), end_);
     buffer_.reserve(buffer_.size() + list.length());
     for (int i = 0; i < list.length(); i++) {
diff --git a/src/utils/utils.cc b/src/utils/utils.cc
index 203476b157..2df3a14c4b 100644
--- a/src/utils/utils.cc
+++ b/src/utils/utils.cc
@@ -19,7 +19,7 @@ namespace v8 {
 namespace internal {
 
 SimpleStringBuilder::SimpleStringBuilder(int size) {
-  buffer_ = Vector<char>::New(size);
+  buffer_ = base::Vector<char>::New(size);
   position_ = 0;
 }
 
@@ -119,7 +119,7 @@ void PrintIsolate(void* isolate, const char* format, ...) {
   va_end(arguments);
 }
 
-int SNPrintF(Vector<char> str, const char* format, ...) {
+int SNPrintF(base::Vector<char> str, const char* format, ...) {
   va_list args;
   va_start(args, format);
   int result = VSNPrintF(str, format, args);
@@ -127,11 +127,11 @@ int SNPrintF(Vector<char> str, const char* format, ...) {
   return result;
 }
 
-int VSNPrintF(Vector<char> str, const char* format, va_list args) {
+int VSNPrintF(base::Vector<char> str, const char* format, va_list args) {
   return base::OS::VSNPrintF(str.begin(), str.length(), format, args);
 }
 
-void StrNCpy(Vector<char> dest, const char* src, size_t n) {
+void StrNCpy(base::Vector<char> dest, const char* src, size_t n) {
   base::OS::StrNCpy(dest.begin(), dest.length(), src, n);
 }
 
@@ -321,7 +321,8 @@ uintptr_t GetCurrentStackPosition() {
 //   "name"   only the function "name"
 //   "name*"  only functions starting with "name"
 //   "~"      none; the tilde is not an identifier
-bool PassesFilter(Vector<const char> name, Vector<const char> filter) {
+bool PassesFilter(base::Vector<const char> name,
+                  base::Vector<const char> filter) {
   if (filter.size() == 0) return name.size() == 0;
   auto filter_it = filter.begin();
   bool positive_filter = true;
diff --git a/src/utils/utils.h b/src/utils/utils.h
index b0d7910aa9..511027892f 100644
--- a/src/utils/utils.h
+++ b/src/utils/utils.h
@@ -20,9 +20,9 @@
 #include "src/base/platform/platform.h"
 #include "src/base/safe_conversions.h"
 #include "src/base/v8-fallthrough.h"
+#include "src/base/vector.h"
 #include "src/common/globals.h"
 #include "src/utils/allocation.h"
-#include "src/utils/vector.h"
 
 #if defined(V8_USE_SIPHASH)
 #include "src/third_party/siphash/halfsiphash.h"
@@ -453,7 +453,7 @@ class SimpleStringBuilder {
   char* Finalize();
 
  protected:
-  Vector<char> buffer_;
+  base::Vector<char> buffer_;
   int position_;
 
   bool is_finalized() const { return position_ < 0; }
@@ -629,11 +629,11 @@ void PRINTF_FORMAT(2, 3) PrintIsolate(void* isolate, const char* format, ...);
 // Safe formatting print. Ensures that str is always null-terminated.
 // Returns the number of chars written, or -1 if output was truncated.
 V8_EXPORT_PRIVATE int PRINTF_FORMAT(2, 3)
-    SNPrintF(Vector<char> str, const char* format, ...);
+    SNPrintF(base::Vector<char> str, const char* format, ...);
 V8_EXPORT_PRIVATE int PRINTF_FORMAT(2, 0)
-    VSNPrintF(Vector<char> str, const char* format, va_list args);
+    VSNPrintF(base::Vector<char> str, const char* format, va_list args);
 
-void StrNCpy(Vector<char> dest, const char* src, size_t n);
+void StrNCpy(base::Vector<char> dest, const char* src, size_t n);
 
 // Read a line of characters after printing the prompt to stdout. The resulting
 // char* needs to be disposed off with DeleteArray by the caller.
@@ -752,8 +752,8 @@ T FpOpWorkaround(T input, T value) {
 }
 #endif
 
-V8_EXPORT_PRIVATE bool PassesFilter(Vector<const char> name,
-                                    Vector<const char> filter);
+V8_EXPORT_PRIVATE bool PassesFilter(base::Vector<const char> name,
+                                    base::Vector<const char> filter);
 
 // Zap the specified area with a specific byte pattern. This currently defaults
 // to int3 on x64 and ia32. On other architectures this will produce unspecified
diff --git a/src/utils/version.cc b/src/utils/version.cc
index 4b7653051d..51af0b90b9 100644
--- a/src/utils/version.cc
+++ b/src/utils/version.cc
@@ -26,7 +26,7 @@ const char* Version::soname_ = SONAME;
 const char* Version::version_string_ = V8_VERSION_STRING;
 
 // Calculate the V8 version string.
-void Version::GetString(Vector<char> str) {
+void Version::GetString(base::Vector<char> str) {
   const char* candidate = IsCandidate() ? " (candidate)" : "";
   if (GetPatch() > 0) {
     SNPrintF(str, "%d.%d.%d.%d%s%s", GetMajor(), GetMinor(), GetBuild(),
@@ -38,7 +38,7 @@ void Version::GetString(Vector<char> str) {
 }
 
 // Calculate the SONAME for the V8 shared library.
-void Version::GetSONAME(Vector<char> str) {
+void Version::GetSONAME(base::Vector<char> str) {
   if (soname_ == nullptr || *soname_ == '\0') {
     // Generate generic SONAME if no specific SONAME is defined.
     const char* candidate = IsCandidate() ? "-candidate" : "";
diff --git a/src/utils/version.h b/src/utils/version.h
index 1479636d8e..fb6783b63c 100644
--- a/src/utils/version.h
+++ b/src/utils/version.h
@@ -10,10 +10,13 @@
 #include "src/base/functional.h"
 
 namespace v8 {
-namespace internal {
 
+namespace base {
 template <typename T>
 class Vector;
+}  // namespace base
+
+namespace internal {
 
 class V8_EXPORT Version {
  public:
@@ -30,10 +33,10 @@ class V8_EXPORT Version {
   }
 
   // Calculate the V8 version string.
-  static void GetString(Vector<char> str);
+  static void GetString(base::Vector<char> str);
 
   // Calculate the SONAME for the V8 shared library.
-  static void GetSONAME(Vector<char> str);
+  static void GetSONAME(base::Vector<char> str);
 
   static const char* GetVersion() { return version_string_; }
 
diff --git a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
index 952d3fa69a..ff031d4396 100644
--- a/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
+++ b/src/wasm/baseline/ia32/liftoff-assembler-ia32.h
@@ -1675,7 +1675,7 @@ inline void Emit64BitShiftOperation(
 
   reg_moves.emplace_back(dst, src, kI64);
   reg_moves.emplace_back(ecx, amount, kI32);
-  assm->ParallelRegisterMove(VectorOf(reg_moves));
+  assm->ParallelRegisterMove(base::VectorOf(reg_moves));
 
   // Do the actual shift.
   (assm->*emit_shift)(dst.high_gp(), dst.low_gp());
diff --git a/src/wasm/baseline/liftoff-assembler.cc b/src/wasm/baseline/liftoff-assembler.cc
index 7810bb11ae..10182b56fb 100644
--- a/src/wasm/baseline/liftoff-assembler.cc
+++ b/src/wasm/baseline/liftoff-assembler.cc
@@ -466,10 +466,11 @@ void LiftoffAssembler::CacheState::InitMerge(const CacheState& source,
   // multiple times need to be copied to another free register. Compute the list
   // of used registers.
   LiftoffRegList used_regs;
-  for (auto& src : VectorOf(source_begin, num_locals)) {
+  for (auto& src : base::VectorOf(source_begin, num_locals)) {
     if (src.is_reg()) used_regs.set(src.reg());
   }
-  for (auto& src : VectorOf(source_begin + stack_base + discarded, arity)) {
+  for (auto& src :
+       base::VectorOf(source_begin + stack_base + discarded, arity)) {
     if (src.is_reg()) used_regs.set(src.reg());
   }
 
@@ -685,8 +686,9 @@ void LiftoffAssembler::MaterializeMergedConstants(uint32_t arity) {
   // Materialize constants on top of the stack ({arity} many), and locals.
   VarState* stack_base = cache_state_.stack_state.data();
   for (auto slots :
-       {VectorOf(stack_base + cache_state_.stack_state.size() - arity, arity),
-        VectorOf(stack_base, num_locals())}) {
+       {base::VectorOf(stack_base + cache_state_.stack_state.size() - arity,
+                       arity),
+        base::VectorOf(stack_base, num_locals())}) {
     for (VarState& slot : slots) {
       if (!slot.is_const()) continue;
       RegClass rc = reg_class_for(slot.kind());
@@ -1078,7 +1080,7 @@ void LiftoffAssembler::Move(LiftoffRegister dst, LiftoffRegister src,
 }
 
 void LiftoffAssembler::ParallelRegisterMove(
-    Vector<const ParallelRegisterMoveTuple> tuples) {
+    base::Vector<const ParallelRegisterMoveTuple> tuples) {
   StackTransferRecipe stack_transfers(this);
   for (auto tuple : tuples) {
     if (tuple.dst == tuple.src) continue;
diff --git a/src/wasm/baseline/liftoff-assembler.h b/src/wasm/baseline/liftoff-assembler.h
index 38a8bffb9c..37c9d04301 100644
--- a/src/wasm/baseline/liftoff-assembler.h
+++ b/src/wasm/baseline/liftoff-assembler.h
@@ -626,11 +626,11 @@ class LiftoffAssembler : public TurboAssembler {
         : dst(dst), src(src), kind(kind) {}
   };
 
-  void ParallelRegisterMove(Vector<const ParallelRegisterMoveTuple>);
+  void ParallelRegisterMove(base::Vector<const ParallelRegisterMoveTuple>);
 
   void ParallelRegisterMove(
       std::initializer_list<ParallelRegisterMoveTuple> moves) {
-    ParallelRegisterMove(VectorOf(moves));
+    ParallelRegisterMove(base::VectorOf(moves));
   }
 
   void MoveToReturnLocations(const FunctionSig*,
diff --git a/src/wasm/baseline/liftoff-compiler.cc b/src/wasm/baseline/liftoff-compiler.cc
index 5ab536efa9..a63129a976 100644
--- a/src/wasm/baseline/liftoff-compiler.cc
+++ b/src/wasm/baseline/liftoff-compiler.cc
@@ -209,14 +209,15 @@ class DebugSideTableBuilder {
   };
 
   // Adds a new entry in regular code.
-  void NewEntry(int pc_offset, Vector<DebugSideTable::Entry::Value> values) {
+  void NewEntry(int pc_offset,
+                base::Vector<DebugSideTable::Entry::Value> values) {
     entries_.emplace_back(pc_offset, static_cast<int>(values.size()),
                           GetChangedStackValues(last_values_, values));
   }
 
   // Adds a new entry for OOL code, and returns a pointer to a builder for
   // modifying that entry.
-  EntryBuilder* NewOOLEntry(Vector<DebugSideTable::Entry::Value> values) {
+  EntryBuilder* NewOOLEntry(base::Vector<DebugSideTable::Entry::Value> values) {
     constexpr int kNoPcOffsetYet = -1;
     ool_entries_.emplace_back(kNoPcOffsetYet, static_cast<int>(values.size()),
                               GetChangedStackValues(last_ool_values_, values));
@@ -252,7 +253,7 @@ class DebugSideTableBuilder {
  private:
   static std::vector<Value> GetChangedStackValues(
       std::vector<Value>& last_values,
-      Vector<DebugSideTable::Entry::Value> values) {
+      base::Vector<DebugSideTable::Entry::Value> values) {
     std::vector<Value> changed_values;
     int old_stack_size = static_cast<int>(last_values.size());
     last_values.resize(values.size());
@@ -456,8 +457,8 @@ class LiftoffCompiler {
                   std::unique_ptr<AssemblerBuffer> buffer,
                   DebugSideTableBuilder* debug_sidetable_builder,
                   ForDebugging for_debugging, int func_index,
-                  Vector<const int> breakpoints = {}, int dead_breakpoint = 0,
-                  int* max_steps = nullptr)
+                  base::Vector<const int> breakpoints = {},
+                  int dead_breakpoint = 0, int* max_steps = nullptr)
       : asm_(std::move(buffer)),
         descriptor_(
             GetLoweredCallDescriptor(compilation_zone, call_descriptor)),
@@ -488,13 +489,13 @@ class LiftoffCompiler {
                  handler_table_offset_);
   }
 
-  OwnedVector<uint8_t> GetSourcePositionTable() {
+  base::OwnedVector<uint8_t> GetSourcePositionTable() {
     return source_position_table_builder_.ToSourcePositionTableVector();
   }
 
-  OwnedVector<uint8_t> GetProtectedInstructionsData() const {
-    return OwnedVector<uint8_t>::Of(
-        Vector<const uint8_t>::cast(VectorOf(protected_instructions_)));
+  base::OwnedVector<uint8_t> GetProtectedInstructionsData() const {
+    return base::OwnedVector<uint8_t>::Of(base::Vector<const uint8_t>::cast(
+        base::VectorOf(protected_instructions_)));
   }
 
   uint32_t GetTotalFrameSlotCountForGC() const {
@@ -553,7 +554,7 @@ class LiftoffCompiler {
       default:
         UNREACHABLE();
     }
-    EmbeddedVector<char, 128> buffer;
+    base::EmbeddedVector<char, 128> buffer;
     SNPrintF(buffer, "%s %s", name(kind), context);
     unsupported(decoder, bailout_reason, buffer.begin());
     return false;
@@ -1132,7 +1133,7 @@ class LiftoffCompiler {
 
   void CatchException(FullDecoder* decoder,
                       const ExceptionIndexImmediate<validate>& imm,
-                      Control* block, Vector<Value> values) {
+                      Control* block, base::Vector<Value> values) {
     DCHECK(block->is_try_catch());
     __ emit_jump(block->label.get());
 
@@ -2189,7 +2190,7 @@ class LiftoffCompiler {
     LocalSet(imm.index, true);
   }
 
-  void AllocateLocals(FullDecoder* decoder, Vector<Value> local_values) {
+  void AllocateLocals(FullDecoder* decoder, base::Vector<Value> local_values) {
     // TODO(7748): Introduce typed functions bailout reason
     unsupported(decoder, kGC, "let");
   }
@@ -3107,12 +3108,14 @@ class LiftoffCompiler {
     }
   }
 
-  OwnedVector<DebugSideTable::Entry::Value> GetCurrentDebugSideTableEntries(
+  base::OwnedVector<DebugSideTable::Entry::Value>
+  GetCurrentDebugSideTableEntries(
       FullDecoder* decoder,
       DebugSideTableBuilder::AssumeSpilling assume_spilling) {
     auto& stack_state = __ cache_state()->stack_state;
-    auto values = OwnedVector<DebugSideTable::Entry::Value>::NewForOverwrite(
-        stack_state.size());
+    auto values =
+        base::OwnedVector<DebugSideTable::Entry::Value>::NewForOverwrite(
+            stack_state.size());
 
     // For function calls, the decoder still has the arguments on the stack, but
     // Liftoff already popped them. Hence {decoder->stack_size()} can be bigger
@@ -3329,7 +3332,7 @@ class LiftoffCompiler {
     __ PushRegister(kS128, dst);
   }
 
-  void SimdOp(FullDecoder* decoder, WasmOpcode opcode, Vector<Value> args,
+  void SimdOp(FullDecoder* decoder, WasmOpcode opcode, base::Vector<Value> args,
               Value* result) {
     if (!CpuFeatures::SupportsWasmSimd128()) {
       return unsupported(decoder, kSimd, "simd");
@@ -3865,7 +3868,7 @@ class LiftoffCompiler {
 
   void SimdLaneOp(FullDecoder* decoder, WasmOpcode opcode,
                   const SimdLaneImmediate<validate>& imm,
-                  const Vector<Value> inputs, Value* result) {
+                  const base::Vector<Value> inputs, Value* result) {
     if (!CpuFeatures::SupportsWasmSimd128()) {
       return unsupported(decoder, kSimd, "simd");
     }
@@ -4206,7 +4209,7 @@ class LiftoffCompiler {
   }
 
   void Throw(FullDecoder* decoder, const ExceptionIndexImmediate<validate>& imm,
-             const Vector<Value>& /* args */) {
+             const base::Vector<Value>& /* args */) {
     LiftoffRegList pinned;
 
     // Load the encoded size in a register for the builtin call.
@@ -4592,7 +4595,8 @@ class LiftoffCompiler {
   V(I64AtomicCompareExchange16U, kI64Store16) \
   V(I64AtomicCompareExchange32U, kI64Store32)
 
-  void AtomicOp(FullDecoder* decoder, WasmOpcode opcode, Vector<Value> args,
+  void AtomicOp(FullDecoder* decoder, WasmOpcode opcode,
+                base::Vector<Value> args,
                 const MemoryAccessImmediate<validate>& imm, Value* result) {
     switch (opcode) {
 #define ATOMIC_STORE_OP(name, type)                \
@@ -4746,7 +4750,7 @@ class LiftoffCompiler {
   }
 
   void TableInit(FullDecoder* decoder, const TableInitImmediate<validate>& imm,
-                 Vector<Value> args) {
+                 base::Vector<Value> args) {
     LiftoffRegList pinned;
     LiftoffRegister table_index_reg =
         pinned.set(__ GetUnusedRegister(kGpReg, pinned));
@@ -4795,7 +4799,7 @@ class LiftoffCompiler {
   }
 
   void TableCopy(FullDecoder* decoder, const TableCopyImmediate<validate>& imm,
-                 Vector<Value> args) {
+                 base::Vector<Value> args) {
     LiftoffRegList pinned;
 
     LiftoffRegister table_dst_index_reg =
@@ -6176,7 +6180,8 @@ constexpr base::EnumSet<ValueKind> LiftoffCompiler::kExternRefSupported;
 WasmCompilationResult ExecuteLiftoffCompilation(
     AccountingAllocator* allocator, CompilationEnv* env,
     const FunctionBody& func_body, int func_index, ForDebugging for_debugging,
-    Counters* counters, WasmFeatures* detected, Vector<const int> breakpoints,
+    Counters* counters, WasmFeatures* detected,
+    base::Vector<const int> breakpoints,
     std::unique_ptr<DebugSideTable>* debug_sidetable, int dead_breakpoint,
     int* max_steps) {
   int func_body_size = static_cast<int>(func_body.end - func_body.start);
@@ -6243,7 +6248,8 @@ std::unique_ptr<DebugSideTable> GenerateLiftoffDebugSideTable(
   auto* native_module = code->native_module();
   auto* function = &native_module->module()->functions[code->index()];
   ModuleWireBytes wire_bytes{native_module->wire_bytes()};
-  Vector<const byte> function_bytes = wire_bytes.GetFunctionBytes(function);
+  base::Vector<const byte> function_bytes =
+      wire_bytes.GetFunctionBytes(function);
   CompilationEnv env = native_module->CreateCompilationEnv();
   FunctionBody func_body{function->sig, 0, function_bytes.begin(),
                          function_bytes.end()};
@@ -6256,9 +6262,10 @@ std::unique_ptr<DebugSideTable> GenerateLiftoffDebugSideTable(
   constexpr int kSteppingBreakpoints[] = {0};
   DCHECK(code->for_debugging() == kForDebugging ||
          code->for_debugging() == kForStepping);
-  Vector<const int> breakpoints = code->for_debugging() == kForStepping
-                                      ? ArrayVector(kSteppingBreakpoints)
-                                      : Vector<const int>{};
+  base::Vector<const int> breakpoints =
+      code->for_debugging() == kForStepping
+          ? base::ArrayVector(kSteppingBreakpoints)
+          : base::Vector<const int>{};
   WasmFullDecoder<Decoder::kBooleanValidation, LiftoffCompiler> decoder(
       &zone, native_module->module(), env.enabled_features, &detected,
       func_body, call_descriptor, &env, &zone,
diff --git a/src/wasm/baseline/liftoff-compiler.h b/src/wasm/baseline/liftoff-compiler.h
index 872df180de..95b0f0c9f2 100644
--- a/src/wasm/baseline/liftoff-compiler.h
+++ b/src/wasm/baseline/liftoff-compiler.h
@@ -56,7 +56,7 @@ enum LiftoffBailoutReason : int8_t {
 V8_EXPORT_PRIVATE WasmCompilationResult ExecuteLiftoffCompilation(
     AccountingAllocator*, CompilationEnv*, const FunctionBody&, int func_index,
     ForDebugging, Counters*, WasmFeatures* detected_features,
-    Vector<const int> breakpoints = {},
+    base::Vector<const int> breakpoints = {},
     std::unique_ptr<DebugSideTable>* = nullptr, int dead_breakpoint = 0,
     int* max_steps = nullptr);
 
diff --git a/src/wasm/c-api.cc b/src/wasm/c-api.cc
index 4f3f4fc682..9ba09e24fe 100644
--- a/src/wasm/c-api.cc
+++ b/src/wasm/c-api.cc
@@ -117,7 +117,7 @@ i::wasm::ValueType WasmValKindToV8(ValKind kind) {
 }
 
 Name GetNameFromWireBytes(const i::wasm::WireBytesRef& ref,
-                          const i::Vector<const uint8_t>& wire_bytes) {
+                          const v8::base::Vector<const uint8_t>& wire_bytes) {
   DCHECK_LE(ref.offset(), wire_bytes.length());
   DCHECK_LE(ref.end_offset(), wire_bytes.length());
   if (ref.length() == 0) return Name::make();
@@ -1143,7 +1143,8 @@ auto Module::imports() const -> ownvec<ImportType> {
   const i::wasm::NativeModule* native_module =
       impl(this)->v8_object()->native_module();
   const i::wasm::WasmModule* module = native_module->module();
-  const i::Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
+  const v8::base::Vector<const uint8_t> wire_bytes =
+      native_module->wire_bytes();
   const std::vector<i::wasm::WasmImport>& import_table = module->import_table;
   size_t size = import_table.size();
   ownvec<ImportType> imports = ownvec<ImportType>::make_uninitialized(size);
@@ -1161,7 +1162,8 @@ auto Module::imports() const -> ownvec<ImportType> {
 ownvec<ExportType> ExportsImpl(i::Handle<i::WasmModuleObject> module_obj) {
   const i::wasm::NativeModule* native_module = module_obj->native_module();
   const i::wasm::WasmModule* module = native_module->module();
-  const i::Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
+  const v8::base::Vector<const uint8_t> wire_bytes =
+      native_module->wire_bytes();
   const std::vector<i::wasm::WasmExport>& export_table = module->export_table;
   size_t size = export_table.size();
   ownvec<ExportType> exports = ownvec<ExportType>::make_uninitialized(size);
@@ -1181,7 +1183,7 @@ auto Module::exports() const -> ownvec<ExportType> {
 auto Module::serialize() const -> vec<byte_t> {
   i::wasm::NativeModule* native_module =
       impl(this)->v8_object()->native_module();
-  i::Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
+  v8::base::Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
   size_t binary_size = wire_bytes.size();
   // We can only serialize after top-tier compilation (TurboFan) finished.
   native_module->compilation_state()->WaitForTopTierFinished();
diff --git a/src/wasm/compilation-environment.h b/src/wasm/compilation-environment.h
index 46c1440e43..8099892414 100644
--- a/src/wasm/compilation-environment.h
+++ b/src/wasm/compilation-environment.h
@@ -90,7 +90,7 @@ struct CompilationEnv {
 class WireBytesStorage {
  public:
   virtual ~WireBytesStorage() = default;
-  virtual Vector<const uint8_t> GetCode(WireBytesRef) const = 0;
+  virtual base::Vector<const uint8_t> GetCode(WireBytesRef) const = 0;
 };
 
 // Callbacks will receive either {kFailedCompilation} or both
diff --git a/src/wasm/decoder.h b/src/wasm/decoder.h
index c181c8df87..379f846b58 100644
--- a/src/wasm/decoder.h
+++ b/src/wasm/decoder.h
@@ -15,9 +15,9 @@
 
 #include "src/base/compiler-specific.h"
 #include "src/base/memory.h"
+#include "src/base/vector.h"
 #include "src/codegen/signature.h"
 #include "src/flags/flags.h"
-#include "src/utils/vector.h"
 #include "src/wasm/wasm-opcodes.h"
 #include "src/wasm/wasm-result.h"
 #include "src/zone/zone-containers.h"
@@ -53,7 +53,8 @@ class Decoder {
 
   Decoder(const byte* start, const byte* end, uint32_t buffer_offset = 0)
       : Decoder(start, start, end, buffer_offset) {}
-  explicit Decoder(const Vector<const byte> bytes, uint32_t buffer_offset = 0)
+  explicit Decoder(const base::Vector<const byte> bytes,
+                   uint32_t buffer_offset = 0)
       : Decoder(bytes.begin(), bytes.begin() + bytes.length(), buffer_offset) {}
   Decoder(const byte* start, const byte* pc, const byte* end,
           uint32_t buffer_offset = 0)
@@ -304,7 +305,7 @@ class Decoder {
     error_ = {};
   }
 
-  void Reset(Vector<const uint8_t> bytes, uint32_t buffer_offset = 0) {
+  void Reset(base::Vector<const uint8_t> bytes, uint32_t buffer_offset = 0) {
     Reset(bytes.begin(), bytes.end(), buffer_offset);
   }
 
@@ -354,7 +355,7 @@ class Decoder {
     // Only report the first error.
     if (!ok()) return;
     constexpr int kMaxErrorMsg = 256;
-    EmbeddedVector<char, kMaxErrorMsg> buffer;
+    base::EmbeddedVector<char, kMaxErrorMsg> buffer;
     int len = VSNPrintF(buffer, format, args);
     CHECK_LT(0, len);
     error_ = {offset, {buffer.begin(), static_cast<size_t>(len)}};
diff --git a/src/wasm/function-body-decoder-impl.h b/src/wasm/function-body-decoder-impl.h
index 36071e2305..64b7a0db13 100644
--- a/src/wasm/function-body-decoder-impl.h
+++ b/src/wasm/function-body-decoder-impl.h
@@ -948,7 +948,7 @@ struct ControlBase : public PcForErrors<validate> {
   F(LocalSet, const Value& value, const IndexImmediate<validate>& imm)        \
   F(LocalTee, const Value& value, Value* result,                              \
     const IndexImmediate<validate>& imm)                                      \
-  F(AllocateLocals, Vector<Value> local_values)                               \
+  F(AllocateLocals, base::Vector<Value> local_values)                         \
   F(DeallocateLocals, uint32_t count)                                         \
   F(GlobalGet, Value* result, const GlobalIndexImmediate<validate>& imm)      \
   F(GlobalSet, const Value& value, const GlobalIndexImmediate<validate>& imm) \
@@ -993,20 +993,20 @@ struct ControlBase : public PcForErrors<validate> {
     const CallIndirectImmediate<validate>& imm, const Value args[])           \
   F(BrOnNull, const Value& ref_object, uint32_t depth)                        \
   F(BrOnNonNull, const Value& ref_object, uint32_t depth)                     \
-  F(SimdOp, WasmOpcode opcode, Vector<Value> args, Value* result)             \
+  F(SimdOp, WasmOpcode opcode, base::Vector<Value> args, Value* result)       \
   F(SimdLaneOp, WasmOpcode opcode, const SimdLaneImmediate<validate>& imm,    \
-    const Vector<Value> inputs, Value* result)                                \
+    const base::Vector<Value> inputs, Value* result)                          \
   F(S128Const, const Simd128Immediate<validate>& imm, Value* result)          \
   F(Simd8x16ShuffleOp, const Simd128Immediate<validate>& imm,                 \
     const Value& input0, const Value& input1, Value* result)                  \
   F(Throw, const ExceptionIndexImmediate<validate>& imm,                      \
-    const Vector<Value>& args)                                                \
+    const base::Vector<Value>& args)                                          \
   F(Rethrow, Control* block)                                                  \
   F(CatchException, const ExceptionIndexImmediate<validate>& imm,             \
-    Control* block, Vector<Value> caught_values)                              \
+    Control* block, base::Vector<Value> caught_values)                        \
   F(Delegate, uint32_t depth, Control* block)                                 \
   F(CatchAll, Control* block)                                                 \
-  F(AtomicOp, WasmOpcode opcode, Vector<Value> args,                          \
+  F(AtomicOp, WasmOpcode opcode, base::Vector<Value> args,                    \
     const MemoryAccessImmediate<validate>& imm, Value* result)                \
   F(AtomicFence)                                                              \
   F(MemoryInit, const MemoryInitImmediate<validate>& imm, const Value& dst,   \
@@ -1016,9 +1016,11 @@ struct ControlBase : public PcForErrors<validate> {
     const Value& src, const Value& size)                                      \
   F(MemoryFill, const MemoryIndexImmediate<validate>& imm, const Value& dst,  \
     const Value& value, const Value& size)                                    \
-  F(TableInit, const TableInitImmediate<validate>& imm, Vector<Value> args)   \
+  F(TableInit, const TableInitImmediate<validate>& imm,                       \
+    base::Vector<Value> args)                                                 \
   F(ElemDrop, const IndexImmediate<validate>& imm)                            \
-  F(TableCopy, const TableCopyImmediate<validate>& imm, Vector<Value> args)   \
+  F(TableCopy, const TableCopyImmediate<validate>& imm,                       \
+    base::Vector<Value> args)                                                 \
   F(TableGrow, const IndexImmediate<validate>& imm, const Value& value,       \
     const Value& delta, Value* result)                                        \
   F(TableSize, const IndexImmediate<validate>& imm, Value* result)            \
@@ -2105,7 +2107,7 @@ template <Decoder::ValidateFlag validate, typename Interface>
 class WasmFullDecoder : public WasmDecoder<validate> {
   using Value = typename Interface::Value;
   using Control = typename Interface::Control;
-  using ArgVector = Vector<Value>;
+  using ArgVector = base::Vector<Value>;
   using ReturnVector = base::SmallVector<Value, 2>;
 
   // All Value types should be trivially copyable for performance. We push, pop,
@@ -2296,7 +2298,7 @@ class WasmFullDecoder : public WasmDecoder<validate> {
       va_list va_args;
       va_start(va_args, format);
       size_t remaining_len = kMaxLen - len_;
-      Vector<char> remaining_msg_space(buffer_ + len_, remaining_len);
+      base::Vector<char> remaining_msg_space(buffer_ + len_, remaining_len);
       int len = VSNPrintF(remaining_msg_space, format, va_args);
       va_end(va_args);
       len_ += len < 0 ? remaining_len : len;
@@ -2410,7 +2412,7 @@ class WasmFullDecoder : public WasmDecoder<validate> {
     ExceptionIndexImmediate<validate> imm(this, this->pc_ + 1);
     if (!this->Validate(this->pc_ + 1, imm)) return 0;
     ArgVector args = PeekArgs(imm.exception->ToFunctionSig());
-    CALL_INTERFACE_IF_OK_AND_REACHABLE(Throw, imm, VectorOf(args));
+    CALL_INTERFACE_IF_OK_AND_REACHABLE(Throw, imm, base::VectorOf(args));
     DropArgs(imm.exception->ToFunctionSig());
     EndControl();
     return 1 + imm.length;
@@ -2458,7 +2460,7 @@ class WasmFullDecoder : public WasmDecoder<validate> {
     for (size_t i = 0, e = sig->parameter_count(); i < e; ++i) {
       Push(CreateValue(sig->GetParam(i)));
     }
-    Vector<Value> values(stack_ + c->stack_depth, sig->parameter_count());
+    base::Vector<Value> values(stack_ + c->stack_depth, sig->parameter_count());
     current_catch_ = c->previous_catch;  // Pop try scope.
     CALL_INTERFACE_IF_OK_AND_PARENT_REACHABLE(CatchException, imm, c, values);
     current_code_reachable_and_ok_ = this->ok() && c->reachable();
@@ -2613,14 +2615,14 @@ class WasmFullDecoder : public WasmDecoder<validate> {
     }
     ArgVector let_local_values =
         PeekArgs(static_cast<uint32_t>(imm.in_arity()),
-                 VectorOf(this->local_types_.data(), new_locals_count));
+                 base::VectorOf(this->local_types_.data(), new_locals_count));
     ArgVector args = PeekArgs(imm.sig, new_locals_count);
     Control* let_block = PushControl(kControlLet, new_locals_count,
                                      let_local_values.length() + args.length());
     SetBlockType(let_block, imm, args.begin());
     CALL_INTERFACE_IF_OK_AND_REACHABLE(Block, let_block);
     CALL_INTERFACE_IF_OK_AND_REACHABLE(AllocateLocals,
-                                       VectorOf(let_local_values));
+                                       base::VectorOf(let_local_values));
     Drop(new_locals_count);  // Drop {let_local_values}.
     DropArgs(imm.sig);       // Drop {args}.
     PushMergeValues(let_block, &let_block->start_merge);
@@ -3538,7 +3540,7 @@ class WasmFullDecoder : public WasmDecoder<validate> {
   }
 
   V8_INLINE ArgVector PeekArgs(uint32_t base_index,
-                               Vector<ValueType> arg_types) {
+                               base::Vector<ValueType> arg_types) {
     int size = static_cast<int>(arg_types.size());
     EnsureStackArguments(size);
     ArgVector args(stack_value(size), arg_types.size());
@@ -3689,7 +3691,7 @@ class WasmFullDecoder : public WasmDecoder<validate> {
       Value inputs[] = {Peek(0, 0, kWasmS128)};
       Value result = CreateValue(type);
       CALL_INTERFACE_IF_OK_AND_REACHABLE(SimdLaneOp, opcode, imm,
-                                         ArrayVector(inputs), &result);
+                                         base::ArrayVector(inputs), &result);
       Drop(1);
       Push(result);
     }
@@ -3703,7 +3705,7 @@ class WasmFullDecoder : public WasmDecoder<validate> {
       Value inputs[2] = {Peek(1, 0, kWasmS128), Peek(0, 1, type)};
       Value result = CreateValue(kWasmS128);
       CALL_INTERFACE_IF_OK_AND_REACHABLE(SimdLaneOp, opcode, imm,
-                                         ArrayVector(inputs), &result);
+                                         base::ArrayVector(inputs), &result);
       Drop(2);
       Push(result);
     }
@@ -3836,13 +3838,13 @@ class WasmFullDecoder : public WasmDecoder<validate> {
         }
         ArgVector args = PeekArgs(sig);
         if (sig->return_count() == 0) {
-          CALL_INTERFACE_IF_OK_AND_REACHABLE(SimdOp, opcode, VectorOf(args),
-                                             nullptr);
+          CALL_INTERFACE_IF_OK_AND_REACHABLE(SimdOp, opcode,
+                                             base::VectorOf(args), nullptr);
           DropArgs(sig);
         } else {
           ReturnVector results = CreateReturnValues(sig);
-          CALL_INTERFACE_IF_OK_AND_REACHABLE(SimdOp, opcode, VectorOf(args),
-                                             results.begin());
+          CALL_INTERFACE_IF_OK_AND_REACHABLE(
+              SimdOp, opcode, base::VectorOf(args), results.begin());
           DropArgs(sig);
           PushReturns(results);
         }
@@ -4588,13 +4590,13 @@ class WasmFullDecoder : public WasmDecoder<validate> {
     CHECK(!this->module_->is_memory64);
     ArgVector args = PeekArgs(sig);
     if (ret_type == kWasmVoid) {
-      CALL_INTERFACE_IF_OK_AND_REACHABLE(AtomicOp, opcode, VectorOf(args), imm,
-                                         nullptr);
+      CALL_INTERFACE_IF_OK_AND_REACHABLE(AtomicOp, opcode, base::VectorOf(args),
+                                         imm, nullptr);
       DropArgs(sig);
     } else {
       Value result = CreateValue(GetReturnType(sig));
-      CALL_INTERFACE_IF_OK_AND_REACHABLE(AtomicOp, opcode, VectorOf(args), imm,
-                                         &result);
+      CALL_INTERFACE_IF_OK_AND_REACHABLE(AtomicOp, opcode, base::VectorOf(args),
+                                         imm, &result);
       DropArgs(sig);
       Push(result);
     }
@@ -4662,7 +4664,8 @@ class WasmFullDecoder : public WasmDecoder<validate> {
         TableInitImmediate<validate> imm(this, this->pc_ + opcode_length);
         if (!this->Validate(this->pc_ + opcode_length, imm)) return 0;
         ArgVector args = PeekArgs(sig);
-        CALL_INTERFACE_IF_OK_AND_REACHABLE(TableInit, imm, VectorOf(args));
+        CALL_INTERFACE_IF_OK_AND_REACHABLE(TableInit, imm,
+                                           base::VectorOf(args));
         DropArgs(sig);
         return opcode_length + imm.length;
       }
@@ -4679,7 +4682,8 @@ class WasmFullDecoder : public WasmDecoder<validate> {
         TableCopyImmediate<validate> imm(this, this->pc_ + opcode_length);
         if (!this->Validate(this->pc_ + opcode_length, imm)) return 0;
         ArgVector args = PeekArgs(sig);
-        CALL_INTERFACE_IF_OK_AND_REACHABLE(TableCopy, imm, VectorOf(args));
+        CALL_INTERFACE_IF_OK_AND_REACHABLE(TableCopy, imm,
+                                           base::VectorOf(args));
         DropArgs(sig);
         return opcode_length + imm.length;
       }
diff --git a/src/wasm/function-compiler.cc b/src/wasm/function-compiler.cc
index 99b0eb663f..e70c1e0c8c 100644
--- a/src/wasm/function-compiler.cc
+++ b/src/wasm/function-compiler.cc
@@ -27,7 +27,7 @@ class WasmInstructionBufferImpl {
  public:
   class View : public AssemblerBuffer {
    public:
-    View(Vector<uint8_t> buffer, WasmInstructionBufferImpl* holder)
+    View(base::Vector<uint8_t> buffer, WasmInstructionBufferImpl* holder)
         : buffer_(buffer), holder_(holder) {}
 
     ~View() override {
@@ -50,17 +50,17 @@ class WasmInstructionBufferImpl {
       DCHECK_LT(size(), new_size);
 
       holder_->old_buffer_ = std::move(holder_->buffer_);
-      holder_->buffer_ = OwnedVector<uint8_t>::NewForOverwrite(new_size);
+      holder_->buffer_ = base::OwnedVector<uint8_t>::NewForOverwrite(new_size);
       return std::make_unique<View>(holder_->buffer_.as_vector(), holder_);
     }
 
    private:
-    const Vector<uint8_t> buffer_;
+    const base::Vector<uint8_t> buffer_;
     WasmInstructionBufferImpl* const holder_;
   };
 
   explicit WasmInstructionBufferImpl(size_t size)
-      : buffer_(OwnedVector<uint8_t>::NewForOverwrite(size)) {}
+      : buffer_(base::OwnedVector<uint8_t>::NewForOverwrite(size)) {}
 
   std::unique_ptr<AssemblerBuffer> CreateView() {
     DCHECK_NOT_NULL(buffer_);
@@ -77,11 +77,11 @@ class WasmInstructionBufferImpl {
 
  private:
   // The current buffer used to emit code.
-  OwnedVector<uint8_t> buffer_;
+  base::OwnedVector<uint8_t> buffer_;
 
   // While the buffer is grown, we need to temporarily also keep the old buffer
   // alive.
-  OwnedVector<uint8_t> old_buffer_;
+  base::OwnedVector<uint8_t> old_buffer_;
 };
 
 WasmInstructionBufferImpl* Impl(WasmInstructionBuffer* buf) {
@@ -162,7 +162,7 @@ WasmCompilationResult WasmCompilationUnit::ExecuteFunctionCompilation(
     const WireBytesStorage* wire_bytes_storage, Counters* counters,
     WasmFeatures* detected) {
   auto* func = &env->module->functions[func_index_];
-  Vector<const uint8_t> code = wire_bytes_storage->GetCode(func->code);
+  base::Vector<const uint8_t> code = wire_bytes_storage->GetCode(func->code);
   wasm::FunctionBody func_body{func->sig, func->code.offset(), code.begin(),
                                code.end()};
 
@@ -237,7 +237,7 @@ void RecordWasmHeapStubCompilation(Isolate* isolate, Handle<Code> code,
                                    const char* format, ...) {
   DCHECK(must_record_function_compilation(isolate));
 
-  ScopedVector<char> buffer(128);
+  base::ScopedVector<char> buffer(128);
   va_list arguments;
   va_start(arguments, format);
   int len = VSNPrintF(buffer, format, arguments);
diff --git a/src/wasm/function-compiler.h b/src/wasm/function-compiler.h
index 09a4f0a0c2..c10e2d74b7 100644
--- a/src/wasm/function-compiler.h
+++ b/src/wasm/function-compiler.h
@@ -68,8 +68,8 @@ struct WasmCompilationResult {
   std::unique_ptr<uint8_t[]> instr_buffer;
   uint32_t frame_slot_count = 0;
   uint32_t tagged_parameter_slots = 0;
-  OwnedVector<byte> source_positions;
-  OwnedVector<byte> protected_instructions_data;
+  base::OwnedVector<byte> source_positions;
+  base::OwnedVector<byte> protected_instructions_data;
   int func_index = kAnonymousFuncIndex;
   ExecutionTier requested_tier;
   ExecutionTier result_tier;
diff --git a/src/wasm/graph-builder-interface.cc b/src/wasm/graph-builder-interface.cc
index c1462480d4..706c271978 100644
--- a/src/wasm/graph-builder-interface.cc
+++ b/src/wasm/graph-builder-interface.cc
@@ -379,7 +379,7 @@ class WasmGraphBuildingInterface {
     ssa_env_->locals[imm.index] = value.node;
   }
 
-  void AllocateLocals(FullDecoder* decoder, Vector<Value> local_values) {
+  void AllocateLocals(FullDecoder* decoder, base::Vector<Value> local_values) {
     ZoneVector<TFNode*>* locals = &ssa_env_->locals;
     locals->insert(locals->begin(), local_values.size(), nullptr);
     for (uint32_t i = 0; i < local_values.size(); i++) {
@@ -460,7 +460,7 @@ class WasmGraphBuildingInterface {
       auto stack_values = CopyStackValues(decoder, ret_count, drop_values);
       BuildNestedLoopExits(decoder, decoder->control_depth() - 1, false,
                            stack_values);
-      GetNodes(values.begin(), VectorOf(stack_values));
+      GetNodes(values.begin(), base::VectorOf(stack_values));
     } else {
       Value* stack_base = ret_count == 0
                               ? nullptr
@@ -468,9 +468,9 @@ class WasmGraphBuildingInterface {
       GetNodes(values.begin(), stack_base, ret_count);
     }
     if (FLAG_trace_wasm) {
-      builder_->TraceFunctionExit(VectorOf(values), decoder->position());
+      builder_->TraceFunctionExit(base::VectorOf(values), decoder->position());
     }
-    builder_->Return(VectorOf(values));
+    builder_->Return(base::VectorOf(values));
     SetEnv(internal_env);
   }
 
@@ -683,7 +683,7 @@ class WasmGraphBuildingInterface {
     SetEnv(false_env);
   }
 
-  void SimdOp(FullDecoder* decoder, WasmOpcode opcode, Vector<Value> args,
+  void SimdOp(FullDecoder* decoder, WasmOpcode opcode, base::Vector<Value> args,
               Value* result) {
     NodeVector inputs(args.size());
     GetNodes(inputs.begin(), args);
@@ -692,8 +692,8 @@ class WasmGraphBuildingInterface {
   }
 
   void SimdLaneOp(FullDecoder* decoder, WasmOpcode opcode,
-                  const SimdLaneImmediate<validate>& imm, Vector<Value> inputs,
-                  Value* result) {
+                  const SimdLaneImmediate<validate>& imm,
+                  base::Vector<Value> inputs, Value* result) {
     NodeVector nodes(inputs.size());
     GetNodes(nodes.begin(), inputs);
     result->node = builder_->SimdLaneOp(opcode, imm.lane, nodes.begin());
@@ -708,15 +708,15 @@ class WasmGraphBuildingInterface {
   }
 
   void Throw(FullDecoder* decoder, const ExceptionIndexImmediate<validate>& imm,
-             const Vector<Value>& value_args) {
+             const base::Vector<Value>& value_args) {
     int count = value_args.length();
     ZoneVector<TFNode*> args(count, decoder->zone());
     for (int i = 0; i < count; ++i) {
       args[i] = value_args[i].node;
     }
-    CheckForException(decoder,
-                      builder_->Throw(imm.index, imm.exception, VectorOf(args),
-                                      decoder->position()));
+    CheckForException(
+        decoder, builder_->Throw(imm.index, imm.exception, base::VectorOf(args),
+                                 decoder->position()));
     TerminateThrow(decoder);
   }
 
@@ -730,7 +730,7 @@ class WasmGraphBuildingInterface {
 
   void CatchException(FullDecoder* decoder,
                       const ExceptionIndexImmediate<validate>& imm,
-                      Control* block, Vector<Value> values) {
+                      Control* block, base::Vector<Value> values) {
     DCHECK(block->is_try_catch());
     // The catch block is unreachable if no possible throws in the try block
     // exist. We only build a landing pad if some node in the try block can
@@ -764,7 +764,7 @@ class WasmGraphBuildingInterface {
     // push them onto the operand stack using the passed {values} vector.
     SetEnv(if_catch_env);
     NodeVector caught_values(values.size());
-    Vector<TFNode*> caught_vector = VectorOf(caught_values);
+    base::Vector<TFNode*> caught_vector = base::VectorOf(caught_values);
     builder_->GetExceptionValues(exception, imm.exception, caught_vector);
     for (size_t i = 0, e = values.size(); i < e; ++i) {
       values[i].node = caught_values[i];
@@ -821,7 +821,8 @@ class WasmGraphBuildingInterface {
     SetEnv(block->try_info->catch_env);
   }
 
-  void AtomicOp(FullDecoder* decoder, WasmOpcode opcode, Vector<Value> args,
+  void AtomicOp(FullDecoder* decoder, WasmOpcode opcode,
+                base::Vector<Value> args,
                 const MemoryAccessImmediate<validate>& imm, Value* result) {
     NodeVector inputs(args.size());
     GetNodes(inputs.begin(), args);
@@ -856,7 +857,7 @@ class WasmGraphBuildingInterface {
   }
 
   void TableInit(FullDecoder* decoder, const TableInitImmediate<validate>& imm,
-                 Vector<Value> args) {
+                 base::Vector<Value> args) {
     builder_->TableInit(imm.table.index, imm.element_segment.index,
                         args[0].node, args[1].node, args[2].node,
                         decoder->position());
@@ -867,7 +868,7 @@ class WasmGraphBuildingInterface {
   }
 
   void TableCopy(FullDecoder* decoder, const TableCopyImmediate<validate>& imm,
-                 Vector<Value> args) {
+                 base::Vector<Value> args) {
     builder_->TableCopy(imm.table_dst.index, imm.table_src.index, args[0].node,
                         args[1].node, args[2].node, decoder->position());
   }
@@ -895,8 +896,8 @@ class WasmGraphBuildingInterface {
     for (uint32_t i = 0; i < field_count; i++) {
       arg_nodes[i] = args[i].node;
     }
-    result->node = builder_->StructNewWithRtt(imm.index, imm.struct_type,
-                                              rtt.node, VectorOf(arg_nodes));
+    result->node = builder_->StructNewWithRtt(
+        imm.index, imm.struct_type, rtt.node, base::VectorOf(arg_nodes));
   }
   void StructNewDefault(FullDecoder* decoder,
                         const StructIndexImmediate<validate>& imm,
@@ -906,8 +907,8 @@ class WasmGraphBuildingInterface {
     for (uint32_t i = 0; i < field_count; i++) {
       arg_nodes[i] = DefaultValue(imm.struct_type->field(i));
     }
-    result->node = builder_->StructNewWithRtt(imm.index, imm.struct_type,
-                                              rtt.node, VectorOf(arg_nodes));
+    result->node = builder_->StructNewWithRtt(
+        imm.index, imm.struct_type, rtt.node, base::VectorOf(arg_nodes));
   }
 
   void StructGet(FullDecoder* decoder, const Value& struct_object,
@@ -1174,7 +1175,7 @@ class WasmGraphBuildingInterface {
     }
   }
 
-  void GetNodes(TFNode** nodes, Vector<Value> values) {
+  void GetNodes(TFNode** nodes, base::Vector<Value> values) {
     GetNodes(nodes, values.begin(), values.size());
   }
 
@@ -1439,22 +1440,22 @@ class WasmGraphBuildingInterface {
     }
     switch (call_mode) {
       case kCallIndirect:
-        CheckForException(decoder,
-                          builder_->CallIndirect(
-                              table_index, sig_index, VectorOf(arg_nodes),
-                              VectorOf(return_nodes), decoder->position()));
+        CheckForException(
+            decoder, builder_->CallIndirect(
+                         table_index, sig_index, base::VectorOf(arg_nodes),
+                         base::VectorOf(return_nodes), decoder->position()));
         break;
       case kCallDirect:
         CheckForException(
-            decoder,
-            builder_->CallDirect(sig_index, VectorOf(arg_nodes),
-                                 VectorOf(return_nodes), decoder->position()));
+            decoder, builder_->CallDirect(sig_index, base::VectorOf(arg_nodes),
+                                          base::VectorOf(return_nodes),
+                                          decoder->position()));
         break;
       case kCallRef:
-        CheckForException(decoder,
-                          builder_->CallRef(sig_index, VectorOf(arg_nodes),
-                                            VectorOf(return_nodes), null_check,
-                                            decoder->position()));
+        CheckForException(
+            decoder, builder_->CallRef(sig_index, base::VectorOf(arg_nodes),
+                                       base::VectorOf(return_nodes), null_check,
+                                       decoder->position()));
         break;
     }
     for (size_t i = 0; i < return_count; ++i) {
@@ -1482,24 +1483,24 @@ class WasmGraphBuildingInterface {
     }
 
     NodeVector arg_nodes(arg_count + 1);
-    GetNodes(arg_nodes.data(), VectorOf(arg_values));
+    GetNodes(arg_nodes.data(), base::VectorOf(arg_values));
 
     switch (call_mode) {
       case kCallIndirect:
-        CheckForException(decoder,
-                          builder_->ReturnCallIndirect(table_index, sig_index,
-                                                       VectorOf(arg_nodes),
-                                                       decoder->position()));
+        CheckForException(
+            decoder, builder_->ReturnCallIndirect(table_index, sig_index,
+                                                  base::VectorOf(arg_nodes),
+                                                  decoder->position()));
         break;
       case kCallDirect:
-        CheckForException(decoder,
-                          builder_->ReturnCall(sig_index, VectorOf(arg_nodes),
-                                               decoder->position()));
+        CheckForException(
+            decoder, builder_->ReturnCall(sig_index, base::VectorOf(arg_nodes),
+                                          decoder->position()));
         break;
       case kCallRef:
-        CheckForException(
-            decoder, builder_->ReturnCallRef(sig_index, VectorOf(arg_nodes),
-                                             null_check, decoder->position()));
+        CheckForException(decoder, builder_->ReturnCallRef(
+                                       sig_index, base::VectorOf(arg_nodes),
+                                       null_check, decoder->position()));
         break;
     }
   }
diff --git a/src/wasm/memory-tracing.cc b/src/wasm/memory-tracing.cc
index 68310a03f3..5460fbcf4b 100644
--- a/src/wasm/memory-tracing.cc
+++ b/src/wasm/memory-tracing.cc
@@ -7,8 +7,8 @@
 #include <cinttypes>
 
 #include "src/base/memory.h"
+#include "src/base/vector.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -17,7 +17,7 @@ namespace wasm {
 void TraceMemoryOperation(base::Optional<ExecutionTier> tier,
                           const MemoryTracingInfo* info, int func_index,
                           int position, uint8_t* mem_start) {
-  EmbeddedVector<char, 91> value;
+  base::EmbeddedVector<char, 91> value;
   auto mem_rep = static_cast<MachineRepresentation>(info->mem_rep);
   Address address = reinterpret_cast<Address>(mem_start) + info->offset;
   switch (mem_rep) {
diff --git a/src/wasm/module-compiler.cc b/src/wasm/module-compiler.cc
index cd92cb8708..6ac597c942 100644
--- a/src/wasm/module-compiler.cc
+++ b/src/wasm/module-compiler.cc
@@ -186,8 +186,8 @@ class CompilationUnitQueues {
     return {};
   }
 
-  void AddUnits(Vector<WasmCompilationUnit> baseline_units,
-                Vector<WasmCompilationUnit> top_tier_units,
+  void AddUnits(base::Vector<WasmCompilationUnit> baseline_units,
+                base::Vector<WasmCompilationUnit> top_tier_units,
                 const WasmModule* module) {
     DCHECK_LT(0, baseline_units.size() + top_tier_units.size());
     // Add to the individual queues in a round-robin fashion. No special care is
@@ -209,7 +209,7 @@ class CompilationUnitQueues {
     for (auto pair : {std::make_pair(int{kBaseline}, baseline_units),
                       std::make_pair(int{kTopTier}, top_tier_units)}) {
       int tier = pair.first;
-      Vector<WasmCompilationUnit> units = pair.second;
+      base::Vector<WasmCompilationUnit> units = pair.second;
       if (units.empty()) continue;
       num_units_[tier].fetch_add(units.size(), std::memory_order_relaxed);
       for (WasmCompilationUnit unit : units) {
@@ -570,9 +570,9 @@ class CompilationStateImpl {
 
   // Inserts new functions to compile and kicks off compilation.
   void AddCompilationUnits(
-      Vector<WasmCompilationUnit> baseline_units,
-      Vector<WasmCompilationUnit> top_tier_units,
-      Vector<std::shared_ptr<JSToWasmWrapperCompilationUnit>>
+      base::Vector<WasmCompilationUnit> baseline_units,
+      base::Vector<WasmCompilationUnit> top_tier_units,
+      base::Vector<std::shared_ptr<JSToWasmWrapperCompilationUnit>>
           js_to_wasm_wrapper_units);
   void AddTopTierCompilationUnit(WasmCompilationUnit);
   void AddTopTierPriorityCompilationUnit(WasmCompilationUnit, size_t);
@@ -587,7 +587,7 @@ class CompilationStateImpl {
   void FinalizeJSToWasmWrappers(Isolate* isolate, const WasmModule* module,
                                 Handle<FixedArray>* export_wrappers_out);
 
-  void OnFinishedUnits(Vector<WasmCode*>);
+  void OnFinishedUnits(base::Vector<WasmCode*>);
   void OnFinishedJSToWasmWrapperUnits(int num);
 
   void OnCompilationStopped(WasmFeatures detected);
@@ -658,7 +658,7 @@ class CompilationStateImpl {
 
   void PublishCompilationResults(
       std::vector<std::unique_ptr<WasmCode>> unpublished_code);
-  void PublishCode(Vector<std::unique_ptr<WasmCode>> codes);
+  void PublishCode(base::Vector<std::unique_ptr<WasmCode>> codes);
 
   NativeModule* const native_module_;
   std::weak_ptr<NativeModule> const native_module_weak_;
@@ -1007,8 +1007,8 @@ class CompilationUnitBuilder {
       return false;
     }
     compilation_state()->AddCompilationUnits(
-        VectorOf(baseline_units_), VectorOf(tiering_units_),
-        VectorOf(js_to_wasm_wrapper_units_));
+        base::VectorOf(baseline_units_), base::VectorOf(tiering_units_),
+        base::VectorOf(js_to_wasm_wrapper_units_));
     Clear();
     return true;
   }
@@ -1049,7 +1049,7 @@ void SetCompileError(ErrorThrower* thrower, ModuleWireBytes wire_bytes,
 }
 
 DecodeResult ValidateSingleFunction(const WasmModule* module, int func_index,
-                                    Vector<const uint8_t> code,
+                                    base::Vector<const uint8_t> code,
                                     Counters* counters,
                                     AccountingAllocator* allocator,
                                     WasmFeatures enabled_features) {
@@ -1087,7 +1087,7 @@ void ValidateSequentially(
 
     ModuleWireBytes wire_bytes{native_module->wire_bytes()};
     const WasmFunction* func = &module->functions[func_index];
-    Vector<const uint8_t> code = wire_bytes.GetFunctionBytes(func);
+    base::Vector<const uint8_t> code = wire_bytes.GetFunctionBytes(func);
     DecodeResult result = ValidateSingleFunction(
         module, func_index, code, counters, allocator, enabled_features);
     if (result.failed()) {
@@ -1139,7 +1139,7 @@ bool CompileLazy(Isolate* isolate, Handle<WasmModuleObject> module_object,
   const WasmFunction* func = &module->functions[func_index];
   if (result.failed()) {
     ErrorThrower thrower(isolate, nullptr);
-    Vector<const uint8_t> code =
+    base::Vector<const uint8_t> code =
         compilation_state->GetWireBytesStorage()->GetCode(func->code);
     DecodeResult decode_result = ValidateSingleFunction(
         module, func_index, code, counters, isolate->wasm_engine()->allocator(),
@@ -1335,7 +1335,7 @@ CompilationExecutionResult ExecuteCompilationUnits(
                 queue, baseline_only))) {
         std::vector<std::unique_ptr<WasmCode>> unpublished_code =
             compile_scope.native_module()->AddCompiledCode(
-                VectorOf(std::move(results_to_publish)));
+                base::VectorOf(std::move(results_to_publish)));
         results_to_publish.clear();
         compile_scope.compilation_state()->SchedulePublishCompilationResults(
             std::move(unpublished_code));
@@ -1356,7 +1356,7 @@ CompilationExecutionResult ExecuteCompilationUnits(
       if (batch_full || liftoff_finished) {
         std::vector<std::unique_ptr<WasmCode>> unpublished_code =
             compile_scope.native_module()->AddCompiledCode(
-                VectorOf(std::move(results_to_publish)));
+                base::VectorOf(std::move(results_to_publish)));
         results_to_publish.clear();
         compile_scope.compilation_state()->SchedulePublishCompilationResults(
             std::move(unpublished_code));
@@ -1668,8 +1668,8 @@ std::shared_ptr<NativeModule> CompileToNativeModule(
     std::shared_ptr<const WasmModule> module, const ModuleWireBytes& wire_bytes,
     Handle<FixedArray>* export_wrappers_out, int compilation_id) {
   const WasmModule* wasm_module = module.get();
-  OwnedVector<uint8_t> wire_bytes_copy =
-      OwnedVector<uint8_t>::Of(wire_bytes.module_bytes());
+  base::OwnedVector<uint8_t> wire_bytes_copy =
+      base::OwnedVector<uint8_t>::Of(wire_bytes.module_bytes());
   // Prefer {wire_bytes_copy} to {wire_bytes.module_bytes()} for the temporary
   // cache key. When we eventually install the module in the cache, the wire
   // bytes of the temporary key and the new key have the same base pointer and
@@ -1795,10 +1795,11 @@ class AsyncStreamingProcessor final : public StreamingProcessor {
 
   ~AsyncStreamingProcessor() override;
 
-  bool ProcessModuleHeader(Vector<const uint8_t> bytes,
+  bool ProcessModuleHeader(base::Vector<const uint8_t> bytes,
                            uint32_t offset) override;
 
-  bool ProcessSection(SectionCode section_code, Vector<const uint8_t> bytes,
+  bool ProcessSection(SectionCode section_code,
+                      base::Vector<const uint8_t> bytes,
                       uint32_t offset) override;
 
   bool ProcessCodeSectionHeader(int num_functions,
@@ -1807,19 +1808,19 @@ class AsyncStreamingProcessor final : public StreamingProcessor {
                                 int code_section_start,
                                 int code_section_length) override;
 
-  bool ProcessFunctionBody(Vector<const uint8_t> bytes,
+  bool ProcessFunctionBody(base::Vector<const uint8_t> bytes,
                            uint32_t offset) override;
 
   void OnFinishedChunk() override;
 
-  void OnFinishedStream(OwnedVector<uint8_t> bytes) override;
+  void OnFinishedStream(base::OwnedVector<uint8_t> bytes) override;
 
   void OnError(const WasmError&) override;
 
   void OnAbort() override;
 
-  bool Deserialize(Vector<const uint8_t> wire_bytes,
-                   Vector<const uint8_t> module_bytes) override;
+  bool Deserialize(base::Vector<const uint8_t> wire_bytes,
+                   base::Vector<const uint8_t> module_bytes) override;
 
  private:
   // Finishes the AsyncCompileJob with an error.
@@ -1906,7 +1907,7 @@ void AsyncCompileJob::PrepareRuntimeObjects() {
   // Create heap objects for script and module bytes to be stored in the
   // module object. Asm.js is not compiled asynchronously.
   DCHECK(module_object_.is_null());
-  auto source_url = stream_ ? stream_->url() : Vector<const char>();
+  auto source_url = stream_ ? stream_->url() : base::Vector<const char>();
   auto script = isolate_->wasm_engine()->GetOrCreateScript(
       isolate_, native_module_, source_url);
   Handle<WasmModuleObject> module_object =
@@ -2255,7 +2256,7 @@ class AsyncCompileJob::DecodeModule : public AsyncCompileJob::CompileStep {
 
           for (int func_index = start; func_index < end; func_index++) {
             const WasmFunction* func = &module->functions[func_index];
-            Vector<const uint8_t> code =
+            base::Vector<const uint8_t> code =
                 job->wire_bytes_.GetFunctionBytes(func);
 
             CompileStrategy strategy = GetCompileStrategy(
@@ -2500,8 +2501,8 @@ void AsyncStreamingProcessor::FinishAsyncCompileJobWithError(
 }
 
 // Process the module header.
-bool AsyncStreamingProcessor::ProcessModuleHeader(Vector<const uint8_t> bytes,
-                                                  uint32_t offset) {
+bool AsyncStreamingProcessor::ProcessModuleHeader(
+    base::Vector<const uint8_t> bytes, uint32_t offset) {
   TRACE_STREAMING("Process module header...\n");
   decoder_.StartDecoding(
       job_->isolate()->counters(), job_->isolate()->metrics_recorder(),
@@ -2517,7 +2518,7 @@ bool AsyncStreamingProcessor::ProcessModuleHeader(Vector<const uint8_t> bytes,
 
 // Process all sections except for the code section.
 bool AsyncStreamingProcessor::ProcessSection(SectionCode section_code,
-                                             Vector<const uint8_t> bytes,
+                                             base::Vector<const uint8_t> bytes,
                                              uint32_t offset) {
   TRACE_STREAMING("Process section %d ...\n", section_code);
   if (compilation_unit_builder_) {
@@ -2619,8 +2620,8 @@ bool AsyncStreamingProcessor::ProcessCodeSectionHeader(
 }
 
 // Process a function body.
-bool AsyncStreamingProcessor::ProcessFunctionBody(Vector<const uint8_t> bytes,
-                                                  uint32_t offset) {
+bool AsyncStreamingProcessor::ProcessFunctionBody(
+    base::Vector<const uint8_t> bytes, uint32_t offset) {
   TRACE_STREAMING("Process function body %d ...\n", num_functions_);
 
   decoder_.DecodeFunctionBody(
@@ -2684,7 +2685,8 @@ void AsyncStreamingProcessor::OnFinishedChunk() {
 }
 
 // Finish the processing of the stream.
-void AsyncStreamingProcessor::OnFinishedStream(OwnedVector<uint8_t> bytes) {
+void AsyncStreamingProcessor::OnFinishedStream(
+    base::OwnedVector<uint8_t> bytes) {
   TRACE_STREAMING("Finish stream...\n");
   DCHECK_EQ(NativeModuleCache::PrefixHash(bytes.as_vector()), prefix_hash_);
   ModuleResult result = decoder_.FinishDecoding(false);
@@ -2788,8 +2790,9 @@ class DeserializationTimeScope {
 };
 }  // namespace
 
-bool AsyncStreamingProcessor::Deserialize(Vector<const uint8_t> module_bytes,
-                                          Vector<const uint8_t> wire_bytes) {
+bool AsyncStreamingProcessor::Deserialize(
+    base::Vector<const uint8_t> module_bytes,
+    base::Vector<const uint8_t> wire_bytes) {
   TRACE_EVENT0("v8.wasm", "wasm.Deserialize");
   DeserializationTimeScope time_scope(
       job_->isolate()->counters()->wasm_deserialization_time());
@@ -3036,9 +3039,9 @@ void CompilationStateImpl::AddCallback(CompilationState::callback_t callback) {
 }
 
 void CompilationStateImpl::AddCompilationUnits(
-    Vector<WasmCompilationUnit> baseline_units,
-    Vector<WasmCompilationUnit> top_tier_units,
-    Vector<std::shared_ptr<JSToWasmWrapperCompilationUnit>>
+    base::Vector<WasmCompilationUnit> baseline_units,
+    base::Vector<WasmCompilationUnit> top_tier_units,
+    base::Vector<std::shared_ptr<JSToWasmWrapperCompilationUnit>>
         js_to_wasm_wrapper_units) {
   if (!js_to_wasm_wrapper_units.empty()) {
     // |js_to_wasm_wrapper_units_| will only be initialized once.
@@ -3117,7 +3120,8 @@ CompilationStateImpl::GetNextCompilationUnit(
   return compilation_unit_queues_.GetNextUnit(queue, baseline_only);
 }
 
-void CompilationStateImpl::OnFinishedUnits(Vector<WasmCode*> code_vector) {
+void CompilationStateImpl::OnFinishedUnits(
+    base::Vector<WasmCode*> code_vector) {
   TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT("v8.wasm.detailed"),
                "wasm.OnFinishedUnits", "units", code_vector.size());
 
@@ -3314,19 +3318,20 @@ void CompilationStateImpl::PublishCompilationResults(
       code->IncRef();
     }
   }
-  PublishCode(VectorOf(unpublished_code));
+  PublishCode(base::VectorOf(unpublished_code));
 }
 
-void CompilationStateImpl::PublishCode(Vector<std::unique_ptr<WasmCode>> code) {
+void CompilationStateImpl::PublishCode(
+    base::Vector<std::unique_ptr<WasmCode>> code) {
   WasmCodeRefScope code_ref_scope;
   std::vector<WasmCode*> published_code =
       native_module_->PublishCode(std::move(code));
   // Defer logging code in case wire bytes were not fully received yet.
   if (native_module_->HasWireBytes()) {
-    native_module_->engine()->LogCode(VectorOf(published_code));
+    native_module_->engine()->LogCode(base::VectorOf(published_code));
   }
 
-  OnFinishedUnits(VectorOf(std::move(published_code)));
+  OnFinishedUnits(base::VectorOf(std::move(published_code)));
 }
 
 void CompilationStateImpl::SchedulePublishCompilationResults(
diff --git a/src/wasm/module-compiler.h b/src/wasm/module-compiler.h
index c45ca2a03e..371eea9e61 100644
--- a/src/wasm/module-compiler.h
+++ b/src/wasm/module-compiler.h
@@ -23,6 +23,12 @@
 #include "src/wasm/wasm-module.h"
 
 namespace v8 {
+
+namespace base {
+template <typename T>
+class Vector;
+}  // namespace base
+
 namespace internal {
 
 class JSArrayBuffer;
@@ -31,9 +37,6 @@ class Counters;
 class WasmModuleObject;
 class WasmInstanceObject;
 
-template <typename T>
-class Vector;
-
 namespace wasm {
 
 struct CompilationEnv;
diff --git a/src/wasm/module-decoder.cc b/src/wasm/module-decoder.cc
index 0b69957c7e..a7a1c5f4a6 100644
--- a/src/wasm/module-decoder.cc
+++ b/src/wasm/module-decoder.cc
@@ -142,18 +142,20 @@ SectionCode IdentifyUnknownSectionInternal(Decoder* decoder) {
         static_cast<int>(section_name_start - decoder->start()),
         string.length() < 20 ? string.length() : 20, section_name_start);
 
-  using SpecialSectionPair = std::pair<Vector<const char>, SectionCode>;
+  using SpecialSectionPair = std::pair<base::Vector<const char>, SectionCode>;
   static constexpr SpecialSectionPair kSpecialSections[]{
-      {StaticCharVector(kNameString), kNameSectionCode},
-      {StaticCharVector(kSourceMappingURLString), kSourceMappingURLSectionCode},
-      {StaticCharVector(kCompilationHintsString), kCompilationHintsSectionCode},
-      {StaticCharVector(kBranchHintsString), kBranchHintsSectionCode},
-      {StaticCharVector(kDebugInfoString), kDebugInfoSectionCode},
-      {StaticCharVector(kExternalDebugInfoString),
+      {base::StaticCharVector(kNameString), kNameSectionCode},
+      {base::StaticCharVector(kSourceMappingURLString),
+       kSourceMappingURLSectionCode},
+      {base::StaticCharVector(kCompilationHintsString),
+       kCompilationHintsSectionCode},
+      {base::StaticCharVector(kBranchHintsString), kBranchHintsSectionCode},
+      {base::StaticCharVector(kDebugInfoString), kDebugInfoSectionCode},
+      {base::StaticCharVector(kExternalDebugInfoString),
        kExternalDebugInfoSectionCode}};
 
-  auto name_vec =
-      Vector<const char>::cast(VectorOf(section_name_start, string.length()));
+  auto name_vec = base::Vector<const char>::cast(
+      base::VectorOf(section_name_start, string.length()));
   for (auto& special_section : kSpecialSections) {
     if (name_vec == special_section.first) return special_section.second;
   }
@@ -184,7 +186,7 @@ class WasmSectionIterator {
     return static_cast<uint32_t>(section_end_ - section_start_);
   }
 
-  Vector<const uint8_t> payload() const {
+  base::Vector<const uint8_t> payload() const {
     return {payload_start_, payload_length()};
   }
 
@@ -298,7 +300,7 @@ class ModuleDecoderImpl : public Decoder {
     pc_ = end_;  // On error, terminate section decoding loop.
   }
 
-  void DumpModule(const Vector<const byte> module_bytes) {
+  void DumpModule(const base::Vector<const byte> module_bytes) {
     std::string path;
     if (FLAG_dump_wasm_module_path) {
       path = FLAG_dump_wasm_module_path;
@@ -309,7 +311,7 @@ class ModuleDecoderImpl : public Decoder {
     }
     // File are named `HASH.{ok,failed}.wasm`.
     size_t hash = base::hash_range(module_bytes.begin(), module_bytes.end());
-    EmbeddedVector<char, 32> buf;
+    base::EmbeddedVector<char, 32> buf;
     SNPrintF(buf, "%016zx.%s.wasm", hash, ok() ? "ok" : "failed");
     path += buf.begin();
     size_t rv = 0;
@@ -334,7 +336,7 @@ class ModuleDecoderImpl : public Decoder {
     module_->origin = origin_;
   }
 
-  void DecodeModuleHeader(Vector<const uint8_t> bytes, uint8_t offset) {
+  void DecodeModuleHeader(base::Vector<const uint8_t> bytes, uint8_t offset) {
     if (failed()) return;
     Reset(bytes, offset);
 
@@ -385,8 +387,9 @@ class ModuleDecoderImpl : public Decoder {
     return true;
   }
 
-  void DecodeSection(SectionCode section_code, Vector<const uint8_t> bytes,
-                     uint32_t offset, bool verify_functions = true) {
+  void DecodeSection(SectionCode section_code,
+                     base::Vector<const uint8_t> bytes, uint32_t offset,
+                     bool verify_functions = true) {
     if (failed()) return;
     Reset(bytes, offset);
     TRACE("Section: %s\n", SectionName(section_code));
@@ -1319,8 +1322,8 @@ class ModuleDecoderImpl : public Decoder {
                             bool verify_functions = true) {
     StartDecoding(counters, allocator);
     uint32_t offset = 0;
-    Vector<const byte> orig_bytes(start(), end() - start());
-    DecodeModuleHeader(VectorOf(start(), end() - start()), offset);
+    base::Vector<const byte> orig_bytes(start(), end() - start());
+    DecodeModuleHeader(base::VectorOf(start(), end() - start()), offset);
     if (failed()) {
       return FinishDecoding(verify_functions);
     }
@@ -2395,14 +2398,14 @@ void ModuleDecoder::StartDecoding(
   impl_->StartDecoding(counters, allocator);
 }
 
-void ModuleDecoder::DecodeModuleHeader(Vector<const uint8_t> bytes,
+void ModuleDecoder::DecodeModuleHeader(base::Vector<const uint8_t> bytes,
                                        uint32_t offset) {
   impl_->DecodeModuleHeader(bytes, offset);
 }
 
 void ModuleDecoder::DecodeSection(SectionCode section_code,
-                                  Vector<const uint8_t> bytes, uint32_t offset,
-                                  bool verify_functions) {
+                                  base::Vector<const uint8_t> bytes,
+                                  uint32_t offset, bool verify_functions) {
   impl_->DecodeSection(section_code, bytes, offset, verify_functions);
 }
 
@@ -2427,7 +2430,7 @@ void ModuleDecoder::set_code_section(uint32_t offset, uint32_t size) {
 }
 
 size_t ModuleDecoder::IdentifyUnknownSection(ModuleDecoder* decoder,
-                                             Vector<const uint8_t> bytes,
+                                             base::Vector<const uint8_t> bytes,
                                              uint32_t offset,
                                              SectionCode* result) {
   if (!decoder->ok()) return 0;
@@ -2473,7 +2476,8 @@ FunctionResult DecodeWasmFunctionForTesting(
                                       std::make_unique<WasmFunction>());
 }
 
-AsmJsOffsetsResult DecodeAsmJsOffsets(Vector<const uint8_t> encoded_offsets) {
+AsmJsOffsetsResult DecodeAsmJsOffsets(
+    base::Vector<const uint8_t> encoded_offsets) {
   std::vector<AsmJsOffsetFunctionEntries> functions;
 
   Decoder decoder(encoded_offsets);
@@ -2620,7 +2624,7 @@ void DecodeFunctionNames(const byte* module_start, const byte* module_end,
   }
 }
 
-NameMap DecodeNameMap(Vector<const uint8_t> module_bytes,
+NameMap DecodeNameMap(base::Vector<const uint8_t> module_bytes,
                       uint8_t name_section_kind) {
   Decoder decoder(module_bytes);
   if (!FindNameSection(&decoder)) return NameMap{{}};
@@ -2652,7 +2656,7 @@ NameMap DecodeNameMap(Vector<const uint8_t> module_bytes,
   return NameMap{std::move(names)};
 }
 
-IndirectNameMap DecodeIndirectNameMap(Vector<const uint8_t> module_bytes,
+IndirectNameMap DecodeIndirectNameMap(base::Vector<const uint8_t> module_bytes,
                                       uint8_t name_section_kind) {
   Decoder decoder(module_bytes);
   if (!FindNameSection(&decoder)) return IndirectNameMap{{}};
diff --git a/src/wasm/module-decoder.h b/src/wasm/module-decoder.h
index 2af2760ab4..617a45c1dd 100644
--- a/src/wasm/module-decoder.h
+++ b/src/wasm/module-decoder.h
@@ -185,7 +185,8 @@ V8_EXPORT_PRIVATE std::vector<CustomSectionOffset> DecodeCustomSections(
 
 // Extracts the mapping from wasm byte offset to asm.js source position per
 // function.
-AsmJsOffsetsResult DecodeAsmJsOffsets(Vector<const uint8_t> encoded_offsets);
+AsmJsOffsetsResult DecodeAsmJsOffsets(
+    base::Vector<const uint8_t> encoded_offsets);
 
 // Decode the function names from the name section. Returns the result as an
 // unordered map. Only names with valid utf8 encoding are stored and conflicts
@@ -197,9 +198,9 @@ void DecodeFunctionNames(const byte* module_start, const byte* module_end,
 // The result will be empty if no name section is present. On encountering an
 // error in the name section, returns all information decoded up to the first
 // error.
-NameMap DecodeNameMap(Vector<const uint8_t> module_bytes,
+NameMap DecodeNameMap(base::Vector<const uint8_t> module_bytes,
                       uint8_t name_section_kind);
-IndirectNameMap DecodeIndirectNameMap(Vector<const uint8_t> module_bytes,
+IndirectNameMap DecodeIndirectNameMap(base::Vector<const uint8_t> module_bytes,
                                       uint8_t name_section_kind);
 
 class ModuleDecoderImpl;
@@ -215,10 +216,11 @@ class ModuleDecoder {
                      AccountingAllocator* allocator,
                      ModuleOrigin origin = ModuleOrigin::kWasmOrigin);
 
-  void DecodeModuleHeader(Vector<const uint8_t> bytes, uint32_t offset);
+  void DecodeModuleHeader(base::Vector<const uint8_t> bytes, uint32_t offset);
 
-  void DecodeSection(SectionCode section_code, Vector<const uint8_t> bytes,
-                     uint32_t offset, bool verify_functions = true);
+  void DecodeSection(SectionCode section_code,
+                     base::Vector<const uint8_t> bytes, uint32_t offset,
+                     bool verify_functions = true);
 
   void StartCodeSection();
 
@@ -243,7 +245,7 @@ class ModuleDecoder {
   // the identifier string of the unknown section.
   // The return value is the number of bytes that were consumed.
   static size_t IdentifyUnknownSection(ModuleDecoder* decoder,
-                                       Vector<const uint8_t> bytes,
+                                       base::Vector<const uint8_t> bytes,
                                        uint32_t offset, SectionCode* result);
 
  private:
diff --git a/src/wasm/module-instantiate.cc b/src/wasm/module-instantiate.cc
index 55bd6d58e2..0736034969 100644
--- a/src/wasm/module-instantiate.cc
+++ b/src/wasm/module-instantiate.cc
@@ -93,7 +93,7 @@ Handle<DescriptorArray> CreateStructDescriptorArray(
   MaybeObject any_type = MaybeObject::FromObject(FieldType::Any());
   DCHECK(any_type->IsSmi());
 
-  i::EmbeddedVector<char, 128> name_buffer;
+  base::EmbeddedVector<char, 128> name_buffer;
   for (uint32_t i = 0; i < field_count; i++) {
     // TODO(ishell): consider introducing a cache of first N internalized field
     // names similar to LookupSingleCharacterStringFromCode().
@@ -854,7 +854,7 @@ MaybeHandle<Object> InstanceBuilder::LookupImportAsm(
 
 // Load data segments into the memory.
 void InstanceBuilder::LoadDataSegments(Handle<WasmInstanceObject> instance) {
-  Vector<const uint8_t> wire_bytes =
+  base::Vector<const uint8_t> wire_bytes =
       module_object_->native_module()->wire_bytes();
   for (const WasmDataSegment& segment : module_->data_segments) {
     uint32_t size = segment.source.length();
@@ -902,7 +902,7 @@ void InstanceBuilder::WriteGlobalValue(const WasmGlobal& global,
 }
 
 void InstanceBuilder::SanitizeImports() {
-  Vector<const uint8_t> wire_bytes =
+  base::Vector<const uint8_t> wire_bytes =
       module_object_->native_module()->wire_bytes();
   for (size_t index = 0; index < module_->import_table.size(); ++index) {
     const WasmImport& import = module_->import_table[index];
diff --git a/src/wasm/streaming-decoder.cc b/src/wasm/streaming-decoder.cc
index 0bb4b8f26a..22bc7d259a 100644
--- a/src/wasm/streaming-decoder.cc
+++ b/src/wasm/streaming-decoder.cc
@@ -33,7 +33,7 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
   AsyncStreamingDecoder& operator=(const AsyncStreamingDecoder&) = delete;
 
   // The buffer passed into OnBytesReceived is owned by the caller.
-  void OnBytesReceived(Vector<const uint8_t> bytes) override;
+  void OnBytesReceived(base::Vector<const uint8_t> bytes) override;
 
   void Finish() override;
 
@@ -56,10 +56,10 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
     // payload_length: The length of the payload.
     // length_bytes: The section length, as it is encoded in the module bytes.
     SectionBuffer(uint32_t module_offset, uint8_t id, size_t payload_length,
-                  Vector<const uint8_t> length_bytes)
+                  base::Vector<const uint8_t> length_bytes)
         :  // ID + length + payload
           module_offset_(module_offset),
-          bytes_(OwnedVector<uint8_t>::NewForOverwrite(
+          bytes_(base::OwnedVector<uint8_t>::NewForOverwrite(
               1 + length_bytes.length() + payload_length)),
           payload_offset_(1 + length_bytes.length()) {
       bytes_.start()[0] = id;
@@ -70,7 +70,7 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
       return static_cast<SectionCode>(bytes_.start()[0]);
     }
 
-    Vector<const uint8_t> GetCode(WireBytesRef ref) const final {
+    base::Vector<const uint8_t> GetCode(WireBytesRef ref) const final {
       DCHECK_LE(module_offset_, ref.offset());
       uint32_t offset_in_code_buffer = ref.offset() - module_offset_;
       return bytes().SubVector(offset_in_code_buffer,
@@ -78,14 +78,14 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
     }
 
     uint32_t module_offset() const { return module_offset_; }
-    Vector<uint8_t> bytes() const { return bytes_.as_vector(); }
-    Vector<uint8_t> payload() const { return bytes() + payload_offset_; }
+    base::Vector<uint8_t> bytes() const { return bytes_.as_vector(); }
+    base::Vector<uint8_t> payload() const { return bytes() + payload_offset_; }
     size_t length() const { return bytes_.size(); }
     size_t payload_offset() const { return payload_offset_; }
 
    private:
     const uint32_t module_offset_;
-    const OwnedVector<uint8_t> bytes_;
+    const base::OwnedVector<uint8_t> bytes_;
     const size_t payload_offset_;
   };
 
@@ -122,13 +122,13 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
     // Reads the bytes for the current state and returns the number of read
     // bytes.
     virtual size_t ReadBytes(AsyncStreamingDecoder* streaming,
-                             Vector<const uint8_t> bytes);
+                             base::Vector<const uint8_t> bytes);
 
     // Returns the next state of the streaming decoding.
     virtual std::unique_ptr<DecodingState> Next(
         AsyncStreamingDecoder* streaming) = 0;
     // The buffer to store the received bytes.
-    virtual Vector<uint8_t> buffer() = 0;
+    virtual base::Vector<uint8_t> buffer() = 0;
     // The number of bytes which were already received.
     size_t offset() const { return offset_; }
     void set_offset(size_t value) { offset_ = value; }
@@ -154,7 +154,7 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
   // Creates a buffer for the next section of the module.
   SectionBuffer* CreateNewBuffer(uint32_t module_offset, uint8_t section_id,
                                  size_t length,
-                                 Vector<const uint8_t> length_bytes);
+                                 base::Vector<const uint8_t> length_bytes);
 
   std::unique_ptr<DecodingState> Error(const WasmError& error) {
     if (ok()) processor_->OnError(error);
@@ -194,7 +194,7 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
     }
   }
 
-  void ProcessFunctionBody(Vector<const uint8_t> bytes,
+  void ProcessFunctionBody(base::Vector<const uint8_t> bytes,
                            uint32_t module_offset) {
     if (!ok()) return;
     if (!processor_->ProcessFunctionBody(bytes, module_offset)) Fail();
@@ -223,7 +223,7 @@ class V8_EXPORT_PRIVATE AsyncStreamingDecoder : public StreamingDecoder {
   std::vector<uint8_t> wire_bytes_for_deserializing_;
 };
 
-void AsyncStreamingDecoder::OnBytesReceived(Vector<const uint8_t> bytes) {
+void AsyncStreamingDecoder::OnBytesReceived(base::Vector<const uint8_t> bytes) {
   if (deserializing()) {
     wire_bytes_for_deserializing_.insert(wire_bytes_for_deserializing_.end(),
                                          bytes.begin(), bytes.end());
@@ -249,8 +249,8 @@ void AsyncStreamingDecoder::OnBytesReceived(Vector<const uint8_t> bytes) {
 }
 
 size_t AsyncStreamingDecoder::DecodingState::ReadBytes(
-    AsyncStreamingDecoder* streaming, Vector<const uint8_t> bytes) {
-  Vector<uint8_t> remaining_buf = buffer() + offset();
+    AsyncStreamingDecoder* streaming, base::Vector<const uint8_t> bytes) {
+  base::Vector<uint8_t> remaining_buf = buffer() + offset();
   size_t num_bytes = std::min(bytes.size(), remaining_buf.size());
   TRACE_STREAMING("ReadBytes(%zu bytes)\n", num_bytes);
   memcpy(remaining_buf.begin(), &bytes.first(), num_bytes);
@@ -265,7 +265,8 @@ void AsyncStreamingDecoder::Finish() {
   if (!ok()) return;
 
   if (deserializing()) {
-    Vector<const uint8_t> wire_bytes = VectorOf(wire_bytes_for_deserializing_);
+    base::Vector<const uint8_t> wire_bytes =
+        base::VectorOf(wire_bytes_for_deserializing_);
     // Try to deserialize the module from wire bytes and module bytes.
     if (processor_->Deserialize(compiled_module_bytes_, wire_bytes)) return;
 
@@ -282,8 +283,8 @@ void AsyncStreamingDecoder::Finish() {
     return;
   }
 
-  OwnedVector<uint8_t> bytes =
-      OwnedVector<uint8_t>::NewForOverwrite(total_size_);
+  base::OwnedVector<uint8_t> bytes =
+      base::OwnedVector<uint8_t>::NewForOverwrite(total_size_);
   uint8_t* cursor = bytes.start();
   {
 #define BYTES(x) (x & 0xFF), (x >> 8) & 0xFF, (x >> 16) & 0xFF, (x >> 24) & 0xFF
@@ -359,10 +360,12 @@ class AsyncStreamingDecoder::DecodeVarInt32 : public DecodingState {
   explicit DecodeVarInt32(size_t max_value, const char* field_name)
       : max_value_(max_value), field_name_(field_name) {}
 
-  Vector<uint8_t> buffer() override { return ArrayVector(byte_buffer_); }
+  base::Vector<uint8_t> buffer() override {
+    return base::ArrayVector(byte_buffer_);
+  }
 
   size_t ReadBytes(AsyncStreamingDecoder* streaming,
-                   Vector<const uint8_t> bytes) override;
+                   base::Vector<const uint8_t> bytes) override;
 
   std::unique_ptr<DecodingState> Next(
       AsyncStreamingDecoder* streaming) override;
@@ -382,7 +385,9 @@ class AsyncStreamingDecoder::DecodeVarInt32 : public DecodingState {
 
 class AsyncStreamingDecoder::DecodeModuleHeader : public DecodingState {
  public:
-  Vector<uint8_t> buffer() override { return ArrayVector(byte_buffer_); }
+  base::Vector<uint8_t> buffer() override {
+    return base::ArrayVector(byte_buffer_);
+  }
 
   std::unique_ptr<DecodingState> Next(
       AsyncStreamingDecoder* streaming) override;
@@ -401,7 +406,7 @@ class AsyncStreamingDecoder::DecodeSectionID : public DecodingState {
   explicit DecodeSectionID(uint32_t module_offset)
       : module_offset_(module_offset) {}
 
-  Vector<uint8_t> buffer() override { return {&id_, 1}; }
+  base::Vector<uint8_t> buffer() override { return {&id_, 1}; }
   bool is_finishing_allowed() const override { return true; }
 
   std::unique_ptr<DecodingState> Next(
@@ -434,7 +439,7 @@ class AsyncStreamingDecoder::DecodeSectionPayload : public DecodingState {
   explicit DecodeSectionPayload(SectionBuffer* section_buffer)
       : section_buffer_(section_buffer) {}
 
-  Vector<uint8_t> buffer() override { return section_buffer_->payload(); }
+  base::Vector<uint8_t> buffer() override { return section_buffer_->payload(); }
 
   std::unique_ptr<DecodingState> Next(
       AsyncStreamingDecoder* streaming) override;
@@ -490,8 +495,8 @@ class AsyncStreamingDecoder::DecodeFunctionBody : public DecodingState {
         num_remaining_functions_(num_remaining_functions),
         module_offset_(module_offset) {}
 
-  Vector<uint8_t> buffer() override {
-    Vector<uint8_t> remaining_buffer =
+  base::Vector<uint8_t> buffer() override {
+    base::Vector<uint8_t> remaining_buffer =
         section_buffer_->bytes() + buffer_offset_;
     return remaining_buffer.SubVector(0, function_body_length_);
   }
@@ -508,9 +513,9 @@ class AsyncStreamingDecoder::DecodeFunctionBody : public DecodingState {
 };
 
 size_t AsyncStreamingDecoder::DecodeVarInt32::ReadBytes(
-    AsyncStreamingDecoder* streaming, Vector<const uint8_t> bytes) {
-  Vector<uint8_t> buf = buffer();
-  Vector<uint8_t> remaining_buf = buf + offset();
+    AsyncStreamingDecoder* streaming, base::Vector<const uint8_t> bytes) {
+  base::Vector<uint8_t> buf = buffer();
+  base::Vector<uint8_t> remaining_buf = buf + offset();
   size_t new_bytes = std::min(bytes.size(), remaining_buf.size());
   TRACE_STREAMING("ReadBytes of a VarInt\n");
   memcpy(remaining_buf.begin(), &bytes.first(), new_bytes);
@@ -623,7 +628,7 @@ AsyncStreamingDecoder::DecodeNumberOfFunctions::NextWithValue(
     AsyncStreamingDecoder* streaming) {
   TRACE_STREAMING("DecodeNumberOfFunctions(%zu)\n", value_);
   // Copy the bytes we read into the section buffer.
-  Vector<uint8_t> payload_buf = section_buffer_->payload();
+  base::Vector<uint8_t> payload_buf = section_buffer_->payload();
   if (payload_buf.size() < bytes_consumed_) {
     return streaming->Error("invalid code section length");
   }
@@ -658,7 +663,8 @@ AsyncStreamingDecoder::DecodeFunctionLength::NextWithValue(
     AsyncStreamingDecoder* streaming) {
   TRACE_STREAMING("DecodeFunctionLength(%zu)\n", value_);
   // Copy the bytes we consumed into the section buffer.
-  Vector<uint8_t> fun_length_buffer = section_buffer_->bytes() + buffer_offset_;
+  base::Vector<uint8_t> fun_length_buffer =
+      section_buffer_->bytes() + buffer_offset_;
   if (fun_length_buffer.size() < bytes_consumed_) {
     return streaming->Error("read past code section end");
   }
@@ -703,7 +709,7 @@ AsyncStreamingDecoder::AsyncStreamingDecoder(
 
 AsyncStreamingDecoder::SectionBuffer* AsyncStreamingDecoder::CreateNewBuffer(
     uint32_t module_offset, uint8_t section_id, size_t length,
-    Vector<const uint8_t> length_bytes) {
+    base::Vector<const uint8_t> length_bytes) {
   // Section buffers are allocated in the same order they appear in the module,
   // they will be processed and later on concatenated in that same order.
   section_buffers_.emplace_back(std::make_shared<SectionBuffer>(
diff --git a/src/wasm/streaming-decoder.h b/src/wasm/streaming-decoder.h
index 0dfbf1bf78..2c5e1eae3c 100644
--- a/src/wasm/streaming-decoder.h
+++ b/src/wasm/streaming-decoder.h
@@ -13,7 +13,7 @@
 #include <vector>
 
 #include "src/base/macros.h"
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 #include "src/wasm/compilation-environment.h"
 #include "src/wasm/wasm-constants.h"
 #include "src/wasm/wasm-engine.h"
@@ -31,13 +31,14 @@ class V8_EXPORT_PRIVATE StreamingProcessor {
   virtual ~StreamingProcessor() = default;
   // Process the first 8 bytes of a WebAssembly module. Returns true if the
   // processing finished successfully and the decoding should continue.
-  virtual bool ProcessModuleHeader(Vector<const uint8_t> bytes,
+  virtual bool ProcessModuleHeader(base::Vector<const uint8_t> bytes,
                                    uint32_t offset) = 0;
 
   // Process all sections but the code section. Returns true if the processing
   // finished successfully and the decoding should continue.
   virtual bool ProcessSection(SectionCode section_code,
-                              Vector<const uint8_t> bytes, uint32_t offset) = 0;
+                              base::Vector<const uint8_t> bytes,
+                              uint32_t offset) = 0;
 
   // Process the start of the code section. Returns true if the processing
   // finished successfully and the decoding should continue.
@@ -48,7 +49,7 @@ class V8_EXPORT_PRIVATE StreamingProcessor {
 
   // Process a function body. Returns true if the processing finished
   // successfully and the decoding should continue.
-  virtual bool ProcessFunctionBody(Vector<const uint8_t> bytes,
+  virtual bool ProcessFunctionBody(base::Vector<const uint8_t> bytes,
                                    uint32_t offset) = 0;
 
   // Report the end of a chunk.
@@ -56,15 +57,15 @@ class V8_EXPORT_PRIVATE StreamingProcessor {
   // Report the end of the stream. If the stream was successful, all
   // received bytes are passed by parameter. If there has been an error, an
   // empty array is passed.
-  virtual void OnFinishedStream(OwnedVector<uint8_t> bytes) = 0;
+  virtual void OnFinishedStream(base::OwnedVector<uint8_t> bytes) = 0;
   // Report an error detected in the StreamingDecoder.
   virtual void OnError(const WasmError&) = 0;
   // Report the abortion of the stream.
   virtual void OnAbort() = 0;
 
   // Attempt to deserialize the module. Supports embedder caching.
-  virtual bool Deserialize(Vector<const uint8_t> module_bytes,
-                           Vector<const uint8_t> wire_bytes) = 0;
+  virtual bool Deserialize(base::Vector<const uint8_t> module_bytes,
+                           base::Vector<const uint8_t> wire_bytes) = 0;
 };
 
 // The StreamingDecoder takes a sequence of byte arrays, each received by a call
@@ -75,7 +76,7 @@ class V8_EXPORT_PRIVATE StreamingDecoder {
   virtual ~StreamingDecoder() = default;
 
   // The buffer passed into OnBytesReceived is owned by the caller.
-  virtual void OnBytesReceived(Vector<const uint8_t> bytes) = 0;
+  virtual void OnBytesReceived(base::Vector<const uint8_t> bytes) = 0;
 
   virtual void Finish() = 0;
 
@@ -95,7 +96,8 @@ class V8_EXPORT_PRIVATE StreamingDecoder {
   }
 
   // Passes previously compiled module bytes from the embedder's cache.
-  bool SetCompiledModuleBytes(Vector<const uint8_t> compiled_module_bytes) {
+  bool SetCompiledModuleBytes(
+      base::Vector<const uint8_t> compiled_module_bytes) {
     compiled_module_bytes_ = compiled_module_bytes;
     return true;
   }
@@ -103,9 +105,9 @@ class V8_EXPORT_PRIVATE StreamingDecoder {
   virtual void NotifyNativeModuleCreated(
       const std::shared_ptr<NativeModule>& native_module) = 0;
 
-  Vector<const char> url() { return VectorOf(url_); }
+  base::Vector<const char> url() { return base::VectorOf(url_); }
 
-  void SetUrl(Vector<const char> url) {
+  void SetUrl(base::Vector<const char> url) {
     url_.assign(url.begin(), url.length());
   }
 
@@ -122,7 +124,7 @@ class V8_EXPORT_PRIVATE StreamingDecoder {
 
   std::string url_;
   ModuleCompiledCallback module_compiled_callback_;
-  Vector<const uint8_t> compiled_module_bytes_;
+  base::Vector<const uint8_t> compiled_module_bytes_;
 };
 
 }  // namespace wasm
diff --git a/src/wasm/sync-streaming-decoder.cc b/src/wasm/sync-streaming-decoder.cc
index 7152806d9d..44b135ebf7 100644
--- a/src/wasm/sync-streaming-decoder.cc
+++ b/src/wasm/sync-streaming-decoder.cc
@@ -25,7 +25,7 @@ class V8_EXPORT_PRIVATE SyncStreamingDecoder : public StreamingDecoder {
         resolver_(resolver) {}
 
   // The buffer passed into OnBytesReceived is owned by the caller.
-  void OnBytesReceived(Vector<const uint8_t> bytes) override {
+  void OnBytesReceived(base::Vector<const uint8_t> bytes) override {
     buffer_.emplace_back(bytes.size());
     CHECK_EQ(buffer_.back().size(), bytes.size());
     std::memcpy(buffer_.back().data(), bytes.data(), bytes.size());
@@ -49,7 +49,7 @@ class V8_EXPORT_PRIVATE SyncStreamingDecoder : public StreamingDecoder {
 
       MaybeHandle<WasmModuleObject> module_object = DeserializeNativeModule(
           isolate_, compiled_module_bytes_,
-          Vector<const uint8_t>(bytes.get(), buffer_size_), url());
+          base::Vector<const uint8_t>(bytes.get(), buffer_size_), url());
 
       if (!module_object.is_null()) {
         Handle<WasmModuleObject> module = module_object.ToHandleChecked();
diff --git a/src/wasm/wasm-code-manager.cc b/src/wasm/wasm-code-manager.cc
index 905fba367a..49be05aae7 100644
--- a/src/wasm/wasm-code-manager.cc
+++ b/src/wasm/wasm-code-manager.cc
@@ -11,6 +11,7 @@
 #include "src/base/macros.h"
 #include "src/base/platform/platform.h"
 #include "src/base/small-vector.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/codegen/macro-assembler.h"
@@ -21,7 +22,6 @@
 #include "src/objects/objects-inl.h"
 #include "src/snapshot/embedded/embedded-data.h"
 #include "src/utils/ostreams.h"
-#include "src/utils/vector.h"
 #include "src/wasm/code-space-access.h"
 #include "src/wasm/compilation-environment.h"
 #include "src/wasm/function-compiler.h"
@@ -177,7 +177,7 @@ int WasmCode::code_comments_size() const {
 }
 
 std::unique_ptr<const byte[]> WasmCode::ConcatenateBytes(
-    std::initializer_list<Vector<const byte>> vectors) {
+    std::initializer_list<base::Vector<const byte>> vectors) {
   size_t total_size = 0;
   for (auto& vec : vectors) total_size += vec.size();
   // Use default-initialization (== no initialization).
@@ -253,21 +253,21 @@ void WasmCode::LogCode(Isolate* isolate, const char* source_url,
     constexpr size_t kMaxSigLength = 128;
     name_buffer.resize(prefix_len + kMaxSigLength);
     const FunctionSig* sig = module->functions[index_].sig;
-    size_t sig_length =
-        PrintSignature(VectorOf(&name_buffer[prefix_len], kMaxSigLength), sig);
+    size_t sig_length = PrintSignature(
+        base::VectorOf(&name_buffer[prefix_len], kMaxSigLength), sig);
     name_buffer.resize(prefix_len + sig_length);
     // If the import has a name, also append that (separated by "-").
     if (!name.empty()) {
       name_buffer += '-';
       name_buffer.append(name.begin(), name.size());
     }
-    name = VectorOf(name_buffer);
+    name = base::VectorOf(name_buffer);
   } else if (name.empty()) {
     name_buffer.resize(32);
     name_buffer.resize(
-        SNPrintF(VectorOf(&name_buffer.front(), name_buffer.size()),
+        SNPrintF(base::VectorOf(&name_buffer.front(), name_buffer.size()),
                  "wasm-function[%d]", index()));
-    name = VectorOf(name_buffer);
+    name = base::VectorOf(name_buffer);
   }
   // TODO(clemensb): Remove this #if once this compilation unit is excluded in
   // no-wasm builds.
@@ -486,7 +486,7 @@ V8_WARN_UNUSED_RESULT bool WasmCode::DecRefOnPotentiallyDeadCode() {
 }
 
 // static
-void WasmCode::DecrementRefCount(Vector<WasmCode* const> code_vec) {
+void WasmCode::DecrementRefCount(base::Vector<WasmCode* const> code_vec) {
   // Decrement the ref counter of all given code objects. Keep the ones whose
   // ref count drops to zero.
   WasmEngine::DeadCodeMap dead_code;
@@ -523,7 +523,7 @@ WasmCodeAllocator::WasmCodeAllocator(WasmCodeManager* code_manager,
 }
 
 WasmCodeAllocator::~WasmCodeAllocator() {
-  code_manager_->FreeNativeModule(VectorOf(owned_code_space_),
+  code_manager_->FreeNativeModule(base::VectorOf(owned_code_space_),
                                   committed_code_space());
 }
 
@@ -629,12 +629,12 @@ std::pair<size_t, size_t> ReservationSize(size_t code_size_estimate,
 
 }  // namespace
 
-Vector<byte> WasmCodeAllocator::AllocateForCode(NativeModule* native_module,
-                                                size_t size) {
+base::Vector<byte> WasmCodeAllocator::AllocateForCode(
+    NativeModule* native_module, size_t size) {
   return AllocateForCodeInRegion(native_module, size, kUnrestrictedRegion);
 }
 
-Vector<byte> WasmCodeAllocator::AllocateForCodeInRegion(
+base::Vector<byte> WasmCodeAllocator::AllocateForCodeInRegion(
     NativeModule* native_module, size_t size, base::AddressRegion region) {
   DCHECK_EQ(code_manager_, native_module->engine()->code_manager());
   DCHECK_LT(0, size);
@@ -791,7 +791,7 @@ bool WasmCodeAllocator::SetThreadWritable(bool writable) {
   return SetPermissionsForMemoryProtectionKey(key, permissions);
 }
 
-void WasmCodeAllocator::FreeCode(Vector<WasmCode* const> codes) {
+void WasmCodeAllocator::FreeCode(base::Vector<WasmCode* const> codes) {
   // Zap code area and collect freed code regions.
   DisjointAllocationPool freed_regions;
   size_t code_size = 0;
@@ -939,22 +939,22 @@ WasmCode* NativeModule::AddCodeForTesting(Handle<Code> code) {
   CODE_SPACE_WRITE_SCOPE
   NativeModuleModificationScope native_module_modification_scope(this);
   const size_t relocation_size = code->relocation_size();
-  OwnedVector<byte> reloc_info;
+  base::OwnedVector<byte> reloc_info;
   if (relocation_size > 0) {
-    reloc_info = OwnedVector<byte>::Of(
-        Vector<byte>{code->relocation_start(), relocation_size});
+    reloc_info = base::OwnedVector<byte>::Of(
+        base::Vector<byte>{code->relocation_start(), relocation_size});
   }
   Handle<ByteArray> source_pos_table(code->source_position_table(),
                                      code->GetIsolate());
-  OwnedVector<byte> source_pos =
-      OwnedVector<byte>::NewForOverwrite(source_pos_table->length());
+  base::OwnedVector<byte> source_pos =
+      base::OwnedVector<byte>::NewForOverwrite(source_pos_table->length());
   if (source_pos_table->length() > 0) {
     source_pos_table->copy_out(0, source_pos.start(),
                                source_pos_table->length());
   }
   CHECK(!code->is_off_heap_trampoline());
   STATIC_ASSERT(Code::kOnHeapBodyIsContiguous);
-  Vector<const byte> instructions(
+  base::Vector<const byte> instructions(
       reinterpret_cast<byte*>(code->raw_body_start()),
       static_cast<size_t>(code->raw_body_size()));
   const int stack_slots = code->has_safepoint_info() ? code->stack_slots() : 0;
@@ -973,7 +973,7 @@ WasmCode* NativeModule::AddCodeForTesting(Handle<Code> code) {
   const int code_comments_offset = base_offset + code->code_comments_offset();
 
   base::RecursiveMutexGuard guard{&allocation_mutex_};
-  Vector<uint8_t> dst_code_bytes =
+  base::Vector<uint8_t> dst_code_bytes =
       code_allocator_.AllocateForCode(this, instructions.size());
   memcpy(dst_code_bytes.begin(), instructions.begin(), instructions.size());
 
@@ -1065,10 +1065,10 @@ void NativeModule::UseLazyStub(uint32_t func_index) {
 std::unique_ptr<WasmCode> NativeModule::AddCode(
     int index, const CodeDesc& desc, int stack_slots,
     uint32_t tagged_parameter_slots,
-    Vector<const byte> protected_instructions_data,
-    Vector<const byte> source_position_table, WasmCode::Kind kind,
+    base::Vector<const byte> protected_instructions_data,
+    base::Vector<const byte> source_position_table, WasmCode::Kind kind,
     ExecutionTier tier, ForDebugging for_debugging) {
-  Vector<byte> code_space;
+  base::Vector<byte> code_space;
   NativeModule::JumpTablesRef jump_table_ref;
   {
     base::RecursiveMutexGuard guard{&allocation_mutex_};
@@ -1087,12 +1087,13 @@ std::unique_ptr<WasmCode> NativeModule::AddCode(
 std::unique_ptr<WasmCode> NativeModule::AddCodeWithCodeSpace(
     int index, const CodeDesc& desc, int stack_slots,
     uint32_t tagged_parameter_slots,
-    Vector<const byte> protected_instructions_data,
-    Vector<const byte> source_position_table, WasmCode::Kind kind,
+    base::Vector<const byte> protected_instructions_data,
+    base::Vector<const byte> source_position_table, WasmCode::Kind kind,
     ExecutionTier tier, ForDebugging for_debugging,
-    Vector<uint8_t> dst_code_bytes, const JumpTablesRef& jump_tables) {
-  Vector<byte> reloc_info{desc.buffer + desc.buffer_size - desc.reloc_size,
-                          static_cast<size_t>(desc.reloc_size)};
+    base::Vector<uint8_t> dst_code_bytes, const JumpTablesRef& jump_tables) {
+  base::Vector<byte> reloc_info{
+      desc.buffer + desc.buffer_size - desc.reloc_size,
+      static_cast<size_t>(desc.reloc_size)};
   UpdateCodeSize(desc.instr_size, tier, for_debugging);
 
   // TODO(jgruber,v8:8758): Remove this translation. It exists only because
@@ -1162,7 +1163,7 @@ WasmCode* NativeModule::PublishCode(std::unique_ptr<WasmCode> code) {
 }
 
 std::vector<WasmCode*> NativeModule::PublishCode(
-    Vector<std::unique_ptr<WasmCode>> codes) {
+    base::Vector<std::unique_ptr<WasmCode>> codes) {
   TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT("v8.wasm.detailed"),
                "wasm.PublishCode", "number", codes.size());
   std::vector<WasmCode*> published_code;
@@ -1285,10 +1286,10 @@ void NativeModule::ReinstallDebugCode(WasmCode* code) {
   PatchJumpTablesLocked(slot_idx, code->instruction_start());
 }
 
-std::pair<Vector<uint8_t>, NativeModule::JumpTablesRef>
+std::pair<base::Vector<uint8_t>, NativeModule::JumpTablesRef>
 NativeModule::AllocateForDeserializedCode(size_t total_code_size) {
   base::RecursiveMutexGuard guard{&allocation_mutex_};
-  Vector<uint8_t> code_space =
+  base::Vector<uint8_t> code_space =
       code_allocator_.AllocateForCode(this, total_code_size);
   auto jump_tables =
       FindJumpTablesForRegionLocked(base::AddressRegionOf(code_space));
@@ -1296,13 +1297,14 @@ NativeModule::AllocateForDeserializedCode(size_t total_code_size) {
 }
 
 std::unique_ptr<WasmCode> NativeModule::AddDeserializedCode(
-    int index, Vector<byte> instructions, int stack_slots,
+    int index, base::Vector<byte> instructions, int stack_slots,
     uint32_t tagged_parameter_slots, int safepoint_table_offset,
     int handler_table_offset, int constant_pool_offset,
     int code_comments_offset, int unpadded_binary_size,
-    Vector<const byte> protected_instructions_data,
-    Vector<const byte> reloc_info, Vector<const byte> source_position_table,
-    WasmCode::Kind kind, ExecutionTier tier) {
+    base::Vector<const byte> protected_instructions_data,
+    base::Vector<const byte> reloc_info,
+    base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+    ExecutionTier tier) {
   UpdateCodeSize(instructions.size(), tier, kNoDebugging);
 
   return std::unique_ptr<WasmCode>{new WasmCode{
@@ -1316,7 +1318,7 @@ std::vector<WasmCode*> NativeModule::SnapshotCodeTable() const {
   base::RecursiveMutexGuard lock(&allocation_mutex_);
   WasmCode** start = code_table_.get();
   WasmCode** end = start + module_->num_declared_functions;
-  for (WasmCode* code : VectorOf(start, end - start)) {
+  for (WasmCode* code : base::VectorOf(start, end - start)) {
     if (code) WasmCodeRefScope::AddRef(code);
   }
   return std::vector<WasmCode*>{start, end};
@@ -1354,7 +1356,7 @@ WasmCode* NativeModule::CreateEmptyJumpTableInRegionLocked(
   allocation_mutex_.AssertHeld();
   // Only call this if we really need a jump table.
   DCHECK_LT(0, jump_table_size);
-  Vector<uint8_t> code_space =
+  base::Vector<uint8_t> code_space =
       code_allocator_.AllocateForCodeInRegion(this, jump_table_size, region);
   DCHECK(!code_space.empty());
   UpdateCodeSize(jump_table_size, ExecutionTier::kNone, kNoDebugging);
@@ -1445,7 +1447,7 @@ void NativeModule::AddCodeSpaceLocked(base::AddressRegion region) {
           ->CanRegisterUnwindInfoForNonABICompliantCodeRange()) {
     size_t size = Heap::GetCodeRangeReservedAreaSize();
     DCHECK_LT(0, size);
-    Vector<byte> padding =
+    base::Vector<byte> padding =
         code_allocator_.AllocateForCodeInRegion(this, size, region);
     CHECK_EQ(reinterpret_cast<Address>(padding.begin()), region.begin());
     win64_unwindinfo::RegisterNonABICompliantCodeRange(
@@ -1531,23 +1533,23 @@ namespace {
 class NativeModuleWireBytesStorage final : public WireBytesStorage {
  public:
   explicit NativeModuleWireBytesStorage(
-      std::shared_ptr<OwnedVector<const uint8_t>> wire_bytes)
+      std::shared_ptr<base::OwnedVector<const uint8_t>> wire_bytes)
       : wire_bytes_(std::move(wire_bytes)) {}
 
-  Vector<const uint8_t> GetCode(WireBytesRef ref) const final {
+  base::Vector<const uint8_t> GetCode(WireBytesRef ref) const final {
     return std::atomic_load(&wire_bytes_)
         ->as_vector()
         .SubVector(ref.offset(), ref.end_offset());
   }
 
  private:
-  const std::shared_ptr<OwnedVector<const uint8_t>> wire_bytes_;
+  const std::shared_ptr<base::OwnedVector<const uint8_t>> wire_bytes_;
 };
 }  // namespace
 
-void NativeModule::SetWireBytes(OwnedVector<const uint8_t> wire_bytes) {
+void NativeModule::SetWireBytes(base::OwnedVector<const uint8_t> wire_bytes) {
   auto shared_wire_bytes =
-      std::make_shared<OwnedVector<const uint8_t>>(std::move(wire_bytes));
+      std::make_shared<base::OwnedVector<const uint8_t>>(std::move(wire_bytes));
   std::atomic_store(&wire_bytes_, shared_wire_bytes);
   if (!shared_wire_bytes->empty()) {
     compilation_state_->SetWireBytesStorage(
@@ -2083,7 +2085,7 @@ std::unique_ptr<WasmCode> NativeModule::AddCompiledCode(
 }
 
 std::vector<std::unique_ptr<WasmCode>> NativeModule::AddCompiledCode(
-    Vector<WasmCompilationResult> results) {
+    base::Vector<WasmCompilationResult> results) {
   TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT("v8.wasm.detailed"),
                "wasm.AddCompiledCode", "num", results.size());
   DCHECK(!results.empty());
@@ -2093,7 +2095,7 @@ std::vector<std::unique_ptr<WasmCode>> NativeModule::AddCompiledCode(
     DCHECK(result.succeeded());
     total_code_space += RoundUp<kCodeAlignment>(result.code_desc.instr_size);
   }
-  Vector<byte> code_space;
+  base::Vector<byte> code_space;
   NativeModule::JumpTablesRef jump_tables;
   {
     base::RecursiveMutexGuard guard{&allocation_mutex_};
@@ -2120,7 +2122,7 @@ std::vector<std::unique_ptr<WasmCode>> NativeModule::AddCompiledCode(
   for (auto& result : results) {
     DCHECK_EQ(result.code_desc.buffer, result.instr_buffer.get());
     size_t code_size = RoundUp<kCodeAlignment>(result.code_desc.instr_size);
-    Vector<byte> this_code_space = code_space.SubVector(0, code_size);
+    base::Vector<byte> this_code_space = code_space.SubVector(0, code_size);
     code_space += code_size;
     generated_code.emplace_back(AddCodeWithCodeSpace(
         result.func_index, result.code_desc, result.frame_slot_count,
@@ -2218,7 +2220,7 @@ std::vector<int> NativeModule::FindFunctionsToRecompile(
   return function_indexes;
 }
 
-void NativeModule::FreeCode(Vector<WasmCode* const> codes) {
+void NativeModule::FreeCode(base::Vector<WasmCode* const> codes) {
   base::RecursiveMutexGuard guard(&allocation_mutex_);
   CODE_SPACE_WRITE_SCOPE
   // Get writable permission already here (and not inside the loop in
@@ -2256,8 +2258,8 @@ DebugInfo* NativeModule::GetDebugInfo() {
   return debug_info_.get();
 }
 
-void WasmCodeManager::FreeNativeModule(Vector<VirtualMemory> owned_code_space,
-                                       size_t committed_size) {
+void WasmCodeManager::FreeNativeModule(
+    base::Vector<VirtualMemory> owned_code_space, size_t committed_size) {
   base::MutexGuard lock(&native_modules_mutex_);
   for (auto& code_space : owned_code_space) {
     DCHECK(code_space.IsReserved());
@@ -2352,7 +2354,7 @@ WasmCodeRefScope::WasmCodeRefScope()
 WasmCodeRefScope::~WasmCodeRefScope() {
   DCHECK_EQ(this, current_code_refs_scope);
   current_code_refs_scope = previous_scope_;
-  WasmCode::DecrementRefCount(VectorOf(code_ptrs_));
+  WasmCode::DecrementRefCount(base::VectorOf(code_ptrs_));
 }
 
 // static
diff --git a/src/wasm/wasm-code-manager.h b/src/wasm/wasm-code-manager.h
index 8d7e1e0f8d..3141721ed8 100644
--- a/src/wasm/wasm-code-manager.h
+++ b/src/wasm/wasm-code-manager.h
@@ -20,11 +20,11 @@
 #include "src/base/bit-field.h"
 #include "src/base/macros.h"
 #include "src/base/optional.h"
+#include "src/base/vector.h"
 #include "src/builtins/builtins.h"
 #include "src/handles/handles.h"
 #include "src/tasks/operations-barrier.h"
 #include "src/trap-handler/trap-handler.h"
-#include "src/utils/vector.h"
 #include "src/wasm/compilation-environment.h"
 #include "src/wasm/memory-protection-key.h"
 #include "src/wasm/wasm-features.h"
@@ -224,17 +224,18 @@ class V8_EXPORT_PRIVATE WasmCode final {
   }
 #endif  // V8_IS_TSAN
 
-  Vector<byte> instructions() const {
-    return VectorOf(instructions_, static_cast<size_t>(instructions_size_));
+  base::Vector<byte> instructions() const {
+    return base::VectorOf(instructions_,
+                          static_cast<size_t>(instructions_size_));
   }
   Address instruction_start() const {
     return reinterpret_cast<Address>(instructions_);
   }
-  Vector<const byte> reloc_info() const {
+  base::Vector<const byte> reloc_info() const {
     return {protected_instructions_data().end(),
             static_cast<size_t>(reloc_info_size_)};
   }
-  Vector<const byte> source_positions() const {
+  base::Vector<const byte> source_positions() const {
     return {reloc_info().end(), static_cast<size_t>(source_positions_size_)};
   }
 
@@ -274,14 +275,14 @@ class V8_EXPORT_PRIVATE WasmCode final {
   // (otherwise debug side table positions would not match up).
   bool is_inspectable() const { return is_liftoff() && for_debugging(); }
 
-  Vector<const uint8_t> protected_instructions_data() const {
+  base::Vector<const uint8_t> protected_instructions_data() const {
     return {meta_data_.get(),
             static_cast<size_t>(protected_instructions_size_)};
   }
 
-  Vector<const trap_handler::ProtectedInstructionData> protected_instructions()
-      const {
-    return Vector<const trap_handler::ProtectedInstructionData>::cast(
+  base::Vector<const trap_handler::ProtectedInstructionData>
+  protected_instructions() const {
+    return base::Vector<const trap_handler::ProtectedInstructionData>::cast(
         protected_instructions_data());
   }
 
@@ -336,7 +337,7 @@ class V8_EXPORT_PRIVATE WasmCode final {
 
   // Decrement the ref count on a set of {WasmCode} objects, potentially
   // belonging to different {NativeModule}s. Dead code will be deleted.
-  static void DecrementRefCount(Vector<WasmCode* const>);
+  static void DecrementRefCount(base::Vector<WasmCode* const>);
 
   // Returns the last source position before {offset}.
   int GetSourcePositionBefore(int offset);
@@ -353,14 +354,14 @@ class V8_EXPORT_PRIVATE WasmCode final {
  private:
   friend class NativeModule;
 
-  WasmCode(NativeModule* native_module, int index, Vector<byte> instructions,
-           int stack_slots, uint32_t tagged_parameter_slots,
-           int safepoint_table_offset, int handler_table_offset,
-           int constant_pool_offset, int code_comments_offset,
-           int unpadded_binary_size,
-           Vector<const byte> protected_instructions_data,
-           Vector<const byte> reloc_info,
-           Vector<const byte> source_position_table, Kind kind,
+  WasmCode(NativeModule* native_module, int index,
+           base::Vector<byte> instructions, int stack_slots,
+           uint32_t tagged_parameter_slots, int safepoint_table_offset,
+           int handler_table_offset, int constant_pool_offset,
+           int code_comments_offset, int unpadded_binary_size,
+           base::Vector<const byte> protected_instructions_data,
+           base::Vector<const byte> reloc_info,
+           base::Vector<const byte> source_position_table, Kind kind,
            ExecutionTier tier, ForDebugging for_debugging)
       : native_module_(native_module),
         instructions_(instructions.begin()),
@@ -387,7 +388,7 @@ class V8_EXPORT_PRIVATE WasmCode final {
   }
 
   std::unique_ptr<const byte[]> ConcatenateBytes(
-      std::initializer_list<Vector<const byte>>);
+      std::initializer_list<base::Vector<const byte>>);
 
   // Code objects that have been registered with the global trap handler within
   // this process, will have a {trap_handler_index} associated with them.
@@ -498,13 +499,13 @@ class WasmCodeAllocator {
 
   // Allocate code space. Returns a valid buffer or fails with OOM (crash).
   // Hold the {NativeModule}'s {allocation_mutex_} when calling this method.
-  Vector<byte> AllocateForCode(NativeModule*, size_t size);
+  base::Vector<byte> AllocateForCode(NativeModule*, size_t size);
 
   // Allocate code space within a specific region. Returns a valid buffer or
   // fails with OOM (crash).
   // Hold the {NativeModule}'s {allocation_mutex_} when calling this method.
-  Vector<byte> AllocateForCodeInRegion(NativeModule*, size_t size,
-                                       base::AddressRegion);
+  base::Vector<byte> AllocateForCodeInRegion(NativeModule*, size_t size,
+                                             base::AddressRegion);
 
   // Sets permissions of all owned code space to read-write or read-only (if
   // {writable} is false). Returns true on success.
@@ -519,7 +520,7 @@ class WasmCodeAllocator {
 
   // Free memory pages of all given code objects. Used for wasm code GC.
   // Hold the {NativeModule}'s {allocation_mutex_} when calling this method.
-  void FreeCode(Vector<WasmCode* const>);
+  void FreeCode(base::Vector<WasmCode* const>);
 
   // Retrieve the number of separately reserved code spaces.
   // Hold the {NativeModule}'s {allocation_mutex_} when calling this method.
@@ -574,19 +575,18 @@ class V8_EXPORT_PRIVATE NativeModule final {
   // {AddCode} is thread safe w.r.t. other calls to {AddCode} or methods adding
   // code below, i.e. it can be called concurrently from background threads.
   // The returned code still needs to be published via {PublishCode}.
-  std::unique_ptr<WasmCode> AddCode(int index, const CodeDesc& desc,
-                                    int stack_slots,
-                                    uint32_t tagged_parameter_slots,
-                                    Vector<const byte> protected_instructions,
-                                    Vector<const byte> source_position_table,
-                                    WasmCode::Kind kind, ExecutionTier tier,
-                                    ForDebugging for_debugging);
+  std::unique_ptr<WasmCode> AddCode(
+      int index, const CodeDesc& desc, int stack_slots,
+      uint32_t tagged_parameter_slots,
+      base::Vector<const byte> protected_instructions,
+      base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+      ExecutionTier tier, ForDebugging for_debugging);
 
   // {PublishCode} makes the code available to the system by entering it into
   // the code table and patching the jump table. It returns a raw pointer to the
   // given {WasmCode} object. Ownership is transferred to the {NativeModule}.
   WasmCode* PublishCode(std::unique_ptr<WasmCode>);
-  std::vector<WasmCode*> PublishCode(Vector<std::unique_ptr<WasmCode>>);
+  std::vector<WasmCode*> PublishCode(base::Vector<std::unique_ptr<WasmCode>>);
 
   // ReinstallDebugCode does a subset of PublishCode: It installs the code in
   // the code table and patches the jump table. The given code must be debug
@@ -602,17 +602,18 @@ class V8_EXPORT_PRIVATE NativeModule final {
     bool is_valid() const { return far_jump_table_start != kNullAddress; }
   };
 
-  std::pair<Vector<uint8_t>, JumpTablesRef> AllocateForDeserializedCode(
+  std::pair<base::Vector<uint8_t>, JumpTablesRef> AllocateForDeserializedCode(
       size_t total_code_size);
 
   std::unique_ptr<WasmCode> AddDeserializedCode(
-      int index, Vector<byte> instructions, int stack_slots,
+      int index, base::Vector<byte> instructions, int stack_slots,
       uint32_t tagged_parameter_slots, int safepoint_table_offset,
       int handler_table_offset, int constant_pool_offset,
       int code_comments_offset, int unpadded_binary_size,
-      Vector<const byte> protected_instructions_data,
-      Vector<const byte> reloc_info, Vector<const byte> source_position_table,
-      WasmCode::Kind kind, ExecutionTier tier);
+      base::Vector<const byte> protected_instructions_data,
+      base::Vector<const byte> reloc_info,
+      base::Vector<const byte> source_position_table, WasmCode::Kind kind,
+      ExecutionTier tier);
 
   // Adds anonymous code for testing purposes.
   WasmCode* AddCodeForTesting(Handle<Code> code);
@@ -695,7 +696,7 @@ class V8_EXPORT_PRIVATE NativeModule final {
   UseTrapHandler use_trap_handler() const { return use_trap_handler_; }
   void set_lazy_compile_frozen(bool frozen) { lazy_compile_frozen_ = frozen; }
   bool lazy_compile_frozen() const { return lazy_compile_frozen_; }
-  Vector<const uint8_t> wire_bytes() const {
+  base::Vector<const uint8_t> wire_bytes() const {
     return std::atomic_load(&wire_bytes_)->as_vector();
   }
   const WasmModule* module() const { return module_.get(); }
@@ -715,7 +716,7 @@ class V8_EXPORT_PRIVATE NativeModule final {
     auto wire_bytes = std::atomic_load(&wire_bytes_);
     return wire_bytes && !wire_bytes->empty();
   }
-  void SetWireBytes(OwnedVector<const uint8_t> wire_bytes);
+  void SetWireBytes(base::OwnedVector<const uint8_t> wire_bytes);
 
   WasmCode* Lookup(Address) const;
 
@@ -736,7 +737,7 @@ class V8_EXPORT_PRIVATE NativeModule final {
   V8_WARN_UNUSED_RESULT std::unique_ptr<WasmCode> AddCompiledCode(
       WasmCompilationResult);
   V8_WARN_UNUSED_RESULT std::vector<std::unique_ptr<WasmCode>> AddCompiledCode(
-      Vector<WasmCompilationResult>);
+      base::Vector<WasmCompilationResult>);
 
   // Set a new tiering state, but don't trigger any recompilation yet; use
   // {RecompileForTiering} for that. The two steps are split because In some
@@ -762,7 +763,7 @@ class V8_EXPORT_PRIVATE NativeModule final {
   // {WasmCode} objects must not be used any more.
   // Should only be called via {WasmEngine::FreeDeadCode}, so the engine can do
   // its accounting.
-  void FreeCode(Vector<WasmCode* const>);
+  void FreeCode(base::Vector<WasmCode* const>);
 
   // Retrieve the number of separately reserved code spaces for this module.
   size_t GetNumberOfCodeSpacesForTesting() const;
@@ -799,10 +800,10 @@ class V8_EXPORT_PRIVATE NativeModule final {
   std::unique_ptr<WasmCode> AddCodeWithCodeSpace(
       int index, const CodeDesc& desc, int stack_slots,
       uint32_t tagged_parameter_slots,
-      Vector<const byte> protected_instructions_data,
-      Vector<const byte> source_position_table, WasmCode::Kind kind,
+      base::Vector<const byte> protected_instructions_data,
+      base::Vector<const byte> source_position_table, WasmCode::Kind kind,
       ExecutionTier tier, ForDebugging for_debugging,
-      Vector<uint8_t> code_space, const JumpTablesRef& jump_tables_ref);
+      base::Vector<uint8_t> code_space, const JumpTablesRef& jump_tables_ref);
 
   WasmCode* CreateEmptyJumpTableInRegionLocked(int jump_table_size,
                                                base::AddressRegion);
@@ -856,7 +857,7 @@ class V8_EXPORT_PRIVATE NativeModule final {
 
   // Wire bytes, held in a shared_ptr so they can be kept alive by the
   // {WireBytesStorage}, held by background compile tasks.
-  std::shared_ptr<OwnedVector<const uint8_t>> wire_bytes_;
+  std::shared_ptr<base::OwnedVector<const uint8_t>> wire_bytes_;
 
   // The first allocated jump table. Always used by external calls (from JS).
   // Wasm calls might use one of the other jump tables stored in
@@ -983,7 +984,7 @@ class V8_EXPORT_PRIVATE WasmCodeManager final {
   void Commit(base::AddressRegion);
   void Decommit(base::AddressRegion);
 
-  void FreeNativeModule(Vector<VirtualMemory> owned_code,
+  void FreeNativeModule(base::Vector<VirtualMemory> owned_code,
                         size_t committed_size);
 
   void AssignRange(base::AddressRegion, NativeModule*);
diff --git a/src/wasm/wasm-debug.cc b/src/wasm/wasm-debug.cc
index a59d051daa..f1dee7cb65 100644
--- a/src/wasm/wasm-debug.cc
+++ b/src/wasm/wasm-debug.cc
@@ -41,7 +41,7 @@ enum ReturnLocation { kAfterBreakpoint, kAfterWasmCall };
 
 Address FindNewPC(WasmFrame* frame, WasmCode* wasm_code, int byte_offset,
                   ReturnLocation return_location) {
-  Vector<const uint8_t> new_pos_table = wasm_code->source_positions();
+  base::Vector<const uint8_t> new_pos_table = wasm_code->source_positions();
 
   DCHECK_LE(0, byte_offset);
 
@@ -49,7 +49,7 @@ Address FindNewPC(WasmFrame* frame, WasmCode* wasm_code, int byte_offset,
   // source position entry to the return address.
   WasmCode* old_code = frame->wasm_code();
   int pc_offset = static_cast<int>(frame->pc() - old_code->instruction_start());
-  Vector<const uint8_t> old_pos_table = old_code->source_positions();
+  base::Vector<const uint8_t> old_pos_table = old_code->source_positions();
   SourcePositionTableIterator old_it(old_pos_table);
   int call_offset = -1;
   while (!old_it.done() && old_it.code_offset() < pc_offset) {
@@ -221,7 +221,7 @@ class DebugInfoImpl {
   // position. Return 0 otherwise.
   // This is used to generate a "dead breakpoint" in Liftoff, which is necessary
   // for OSR to find the correct return address.
-  int DeadBreakpoint(WasmFrame* frame, Vector<const int> breakpoints) {
+  int DeadBreakpoint(WasmFrame* frame, base::Vector<const int> breakpoints) {
     const auto& function =
         native_module_->module()->functions[frame->function_index()];
     int offset = frame->position() - function.code.offset();
@@ -233,7 +233,7 @@ class DebugInfoImpl {
 
   // Find the dead breakpoint (see above) for the top wasm frame, if that frame
   // is in the function of the given index.
-  int DeadBreakpoint(int func_index, Vector<const int> breakpoints,
+  int DeadBreakpoint(int func_index, base::Vector<const int> breakpoints,
                      Isolate* isolate) {
     StackTraceFrameIterator it(isolate);
     if (it.done() || !it.is_wasm()) return 0;
@@ -243,7 +243,7 @@ class DebugInfoImpl {
   }
 
   WasmCode* RecompileLiftoffWithBreakpoints(int func_index,
-                                            Vector<const int> offsets,
+                                            base::Vector<const int> offsets,
                                             int dead_breakpoint) {
     DCHECK(!mutex_.TryLock());  // Mutex is held externally.
 
@@ -272,7 +272,7 @@ class DebugInfoImpl {
     // Not thread-safe. The caller is responsible for locking {mutex_}.
     CompilationEnv env = native_module_->CreateCompilationEnv();
     auto* function = &native_module_->module()->functions[func_index];
-    Vector<const uint8_t> wire_bytes = native_module_->wire_bytes();
+    base::Vector<const uint8_t> wire_bytes = native_module_->wire_bytes();
     FunctionBody body{function->sig, function->code.offset(),
                       wire_bytes.begin() + function->code.offset(),
                       wire_bytes.begin() + function->code.end_offset()};
@@ -304,7 +304,7 @@ class DebugInfoImpl {
     // Insert new code into the cache. Insert before existing elements for LRU.
     cached_debugging_code_.insert(
         cached_debugging_code_.begin(),
-        CachedDebuggingCode{func_index, OwnedVector<int>::Of(offsets),
+        CachedDebuggingCode{func_index, base::OwnedVector<int>::Of(offsets),
                             dead_breakpoint, new_code});
     // Increase the ref count (for the cache entry).
     new_code->IncRef();
@@ -363,9 +363,9 @@ class DebugInfoImpl {
     } else {
       all_breakpoints.insert(insertion_point, offset);
       int dead_breakpoint =
-          DeadBreakpoint(func_index, VectorOf(all_breakpoints), isolate);
+          DeadBreakpoint(func_index, base::VectorOf(all_breakpoints), isolate);
       new_code = RecompileLiftoffWithBreakpoints(
-          func_index, VectorOf(all_breakpoints), dead_breakpoint);
+          func_index, base::VectorOf(all_breakpoints), dead_breakpoint);
     }
     UpdateReturnAddresses(isolate, new_code, isolate_data.stepping_frame);
   }
@@ -381,7 +381,7 @@ class DebugInfoImpl {
     return {breakpoints.begin(), breakpoints.end()};
   }
 
-  void UpdateBreakpoints(int func_index, Vector<int> breakpoints,
+  void UpdateBreakpoints(int func_index, base::Vector<int> breakpoints,
                          Isolate* isolate, StackFrameId stepping_frame,
                          int dead_breakpoint) {
     DCHECK(!mutex_.TryLock());  // Mutex is held externally.
@@ -397,7 +397,7 @@ class DebugInfoImpl {
     // Generate an additional source position for the current byte offset.
     base::MutexGuard guard(&mutex_);
     WasmCode* new_code = RecompileLiftoffWithBreakpoints(
-        frame->function_index(), ArrayVector(kFloodingBreakpoints), 0);
+        frame->function_index(), base::ArrayVector(kFloodingBreakpoints), 0);
     UpdateReturnAddress(frame, new_code, return_location);
 
     per_isolate_data_[frame->isolate()].stepping_frame = frame->id();
@@ -426,9 +426,9 @@ class DebugInfoImpl {
     if (code->for_debugging() != kForStepping) return;
     int func_index = code->index();
     std::vector<int> breakpoints = FindAllBreakpoints(func_index);
-    int dead_breakpoint = DeadBreakpoint(frame, VectorOf(breakpoints));
+    int dead_breakpoint = DeadBreakpoint(frame, base::VectorOf(breakpoints));
     WasmCode* new_code = RecompileLiftoffWithBreakpoints(
-        func_index, VectorOf(breakpoints), dead_breakpoint);
+        func_index, base::VectorOf(breakpoints), dead_breakpoint);
     UpdateReturnAddress(frame, new_code, kAfterBreakpoint);
   }
 
@@ -474,12 +474,12 @@ class DebugInfoImpl {
     DCHECK(std::is_sorted(remaining.begin(), remaining.end()));
     if (std::binary_search(remaining.begin(), remaining.end(), offset)) return;
     int dead_breakpoint =
-        DeadBreakpoint(func_index, VectorOf(remaining), isolate);
-    UpdateBreakpoints(func_index, VectorOf(remaining), isolate,
+        DeadBreakpoint(func_index, base::VectorOf(remaining), isolate);
+    UpdateBreakpoints(func_index, base::VectorOf(remaining), isolate,
                       isolate_data.stepping_frame, dead_breakpoint);
   }
 
-  void RemoveDebugSideTables(Vector<WasmCode* const> codes) {
+  void RemoveDebugSideTables(base::Vector<WasmCode* const> codes) {
     base::MutexGuard guard(&debug_side_tables_mutex_);
     for (auto* code : codes) {
       debug_side_tables_.erase(code);
@@ -520,7 +520,8 @@ class DebugInfoImpl {
       std::vector<int>& removed = entry.second;
       std::vector<int> remaining = FindAllBreakpoints(func_index);
       if (HasRemovedBreakpoints(removed, remaining)) {
-        RecompileLiftoffWithBreakpoints(func_index, VectorOf(remaining), 0);
+        RecompileLiftoffWithBreakpoints(func_index, base::VectorOf(remaining),
+                                        0);
       }
     }
   }
@@ -757,7 +758,7 @@ class DebugInfoImpl {
   static constexpr size_t kMaxCachedDebuggingCode = 3;
   struct CachedDebuggingCode {
     int func_index;
-    OwnedVector<const int> breakpoint_offsets;
+    base::OwnedVector<const int> breakpoint_offsets;
     int dead_breakpoint;
     WasmCode* code;
   };
@@ -855,7 +856,7 @@ void DebugInfo::RemoveBreakpoint(int func_index, int offset,
   impl_->RemoveBreakpoint(func_index, offset, current_isolate);
 }
 
-void DebugInfo::RemoveDebugSideTables(Vector<WasmCode* const> code) {
+void DebugInfo::RemoveDebugSideTables(base::Vector<WasmCode* const> code) {
   impl_->RemoveDebugSideTables(code);
 }
 
diff --git a/src/wasm/wasm-debug.h b/src/wasm/wasm-debug.h
index 1babd0650f..7e5e60ceda 100644
--- a/src/wasm/wasm-debug.h
+++ b/src/wasm/wasm-debug.h
@@ -17,7 +17,7 @@
 #include "src/base/iterator.h"
 #include "src/base/logging.h"
 #include "src/base/macros.h"
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 #include "src/wasm/value-type.h"
 
 namespace v8 {
@@ -87,8 +87,8 @@ class DebugSideTable {
     // Stack height, including locals.
     int stack_height() const { return stack_height_; }
 
-    Vector<const Value> changed_values() const {
-      return VectorOf(changed_values_);
+    base::Vector<const Value> changed_values() const {
+      return base::VectorOf(changed_values_);
     }
 
     const Value* FindChangedValue(int stack_index) const {
@@ -217,7 +217,7 @@ class V8_EXPORT_PRIVATE DebugInfo {
 
   void RemoveBreakpoint(int func_index, int offset, Isolate* current_isolate);
 
-  void RemoveDebugSideTables(Vector<WasmCode* const>);
+  void RemoveDebugSideTables(base::Vector<WasmCode* const>);
 
   // Return the debug side table for the given code object, but only if it has
   // already been created. This will never trigger generation of the table.
diff --git a/src/wasm/wasm-engine.cc b/src/wasm/wasm-engine.cc
index 74fd475cdf..05c98fb366 100644
--- a/src/wasm/wasm-engine.cc
+++ b/src/wasm/wasm-engine.cc
@@ -180,7 +180,7 @@ class WeakScriptHandle {
 }  // namespace
 
 std::shared_ptr<NativeModule> NativeModuleCache::MaybeGetNativeModule(
-    ModuleOrigin origin, Vector<const uint8_t> wire_bytes) {
+    ModuleOrigin origin, base::Vector<const uint8_t> wire_bytes) {
   if (origin != kWasmOrigin) return nullptr;
   base::MutexGuard lock(&mutex_);
   size_t prefix_hash = PrefixHash(wire_bytes);
@@ -240,7 +240,7 @@ std::shared_ptr<NativeModule> NativeModuleCache::Update(
     std::shared_ptr<NativeModule> native_module, bool error) {
   DCHECK_NOT_NULL(native_module);
   if (native_module->module()->origin != kWasmOrigin) return native_module;
-  Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
+  base::Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
   DCHECK(!wire_bytes.empty());
   size_t prefix_hash = PrefixHash(native_module->wire_bytes());
   base::MutexGuard lock(&mutex_);
@@ -281,14 +281,14 @@ void NativeModuleCache::Erase(NativeModule* native_module) {
 }
 
 // static
-size_t NativeModuleCache::WireBytesHash(Vector<const uint8_t> bytes) {
+size_t NativeModuleCache::WireBytesHash(base::Vector<const uint8_t> bytes) {
   return StringHasher::HashSequentialString(
       reinterpret_cast<const char*>(bytes.begin()), bytes.length(),
       kZeroHashSeed);
 }
 
 // static
-size_t NativeModuleCache::PrefixHash(Vector<const uint8_t> wire_bytes) {
+size_t NativeModuleCache::PrefixHash(base::Vector<const uint8_t> wire_bytes) {
   // Compute the hash as a combined hash of the sections up to the code section
   // header, to mirror the way streaming compilation does it.
   Decoder decoder(wire_bytes.begin(), wire_bytes.end());
@@ -310,7 +310,7 @@ size_t NativeModuleCache::PrefixHash(Vector<const uint8_t> wire_bytes) {
     const uint8_t* payload_start = decoder.pc();
     decoder.consume_bytes(section_size, "section payload");
     size_t section_hash = NativeModuleCache::WireBytesHash(
-        Vector<const uint8_t>(payload_start, section_size));
+        base::Vector<const uint8_t>(payload_start, section_size));
     hash = base::hash_combine(hash, section_hash);
   }
   return hash;
@@ -474,7 +474,7 @@ bool WasmEngine::SyncValidate(Isolate* isolate, const WasmFeatures& enabled,
 
 MaybeHandle<AsmWasmData> WasmEngine::SyncCompileTranslatedAsmJs(
     Isolate* isolate, ErrorThrower* thrower, const ModuleWireBytes& bytes,
-    Vector<const byte> asm_js_offset_table_bytes,
+    base::Vector<const byte> asm_js_offset_table_bytes,
     Handle<HeapNumber> uses_bitset, LanguageMode language_mode) {
   int compilation_id = next_compilation_id_.fetch_add(1);
   TRACE_EVENT1("v8.wasm", "wasm.SyncCompileTranslatedAsmJs", "id",
@@ -555,7 +555,7 @@ MaybeHandle<WasmModuleObject> WasmEngine::SyncCompile(
   }
 #endif
 
-  constexpr Vector<const char> kNoSourceUrl;
+  constexpr base::Vector<const char> kNoSourceUrl;
   Handle<Script> script =
       GetOrCreateScript(isolate, native_module, kNoSourceUrl);
 
@@ -760,14 +760,14 @@ std::shared_ptr<NativeModule> WasmEngine::ExportNativeModule(
 namespace {
 Handle<Script> CreateWasmScript(Isolate* isolate,
                                 std::shared_ptr<NativeModule> native_module,
-                                Vector<const char> source_url) {
+                                base::Vector<const char> source_url) {
   Handle<Script> script =
       isolate->factory()->NewScript(isolate->factory()->undefined_value());
   script->set_compilation_state(Script::COMPILATION_STATE_COMPILED);
   script->set_context_data(isolate->native_context()->debug_context_id());
   script->set_type(Script::TYPE_WASM);
 
-  Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
+  base::Vector<const uint8_t> wire_bytes = native_module->wire_bytes();
 
   // The source URL of the script is
   // - the original source URL if available (from the streaming API),
@@ -784,7 +784,7 @@ Handle<Script> CreateWasmScript(Isolate* isolate,
         reinterpret_cast<const char*>(wire_bytes.begin()), wire_bytes.length(),
         kZeroHashSeed);
 
-    EmbeddedVector<char, 32> buffer;
+    base::EmbeddedVector<char, 32> buffer;
     if (module->name.is_empty()) {
       // Build the URL in the form "wasm://wasm/<hash>".
       int url_len = SNPrintF(buffer, "wasm://wasm/%08x", hash);
@@ -820,7 +820,7 @@ Handle<Script> CreateWasmScript(Isolate* isolate,
   const WasmDebugSymbols& debug_symbols = module->debug_symbols;
   if (debug_symbols.type == WasmDebugSymbols::Type::SourceMap &&
       !debug_symbols.external_url.is_empty()) {
-    Vector<const char> external_url =
+    base::Vector<const char> external_url =
         ModuleWireBytes(wire_bytes).GetNameOrNull(debug_symbols.external_url);
     MaybeHandle<String> src_map_str = isolate->factory()->NewStringFromUtf8(
         external_url, AllocationType::kOld);
@@ -846,7 +846,7 @@ Handle<Script> CreateWasmScript(Isolate* isolate,
 
 Handle<WasmModuleObject> WasmEngine::ImportNativeModule(
     Isolate* isolate, std::shared_ptr<NativeModule> shared_native_module,
-    Vector<const char> source_url) {
+    base::Vector<const char> source_url) {
   DCHECK_EQ(this, shared_native_module->engine());
   NativeModule* native_module = shared_native_module.get();
   ModuleWireBytes wire_bytes(native_module->wire_bytes());
@@ -1052,14 +1052,14 @@ void WasmEngine::RemoveIsolate(Isolate* isolate) {
   if (auto* task = info->log_codes_task) {
     task->Cancel();
     for (auto& log_entry : info->code_to_log) {
-      WasmCode::DecrementRefCount(VectorOf(log_entry.second.code));
+      WasmCode::DecrementRefCount(base::VectorOf(log_entry.second.code));
     }
     info->code_to_log.clear();
   }
   DCHECK(info->code_to_log.empty());
 }
 
-void WasmEngine::LogCode(Vector<WasmCode*> code_vec) {
+void WasmEngine::LogCode(base::Vector<WasmCode*> code_vec) {
   if (code_vec.empty()) return;
   base::MutexGuard guard(&mutex_);
   NativeModule* native_module = code_vec[0]->native_module();
@@ -1122,7 +1122,7 @@ void WasmEngine::LogOutstandingCodesForIsolate(Isolate* isolate) {
         code->LogCode(isolate, pair.second.source_url.get(), pair.first);
       }
     }
-    WasmCode::DecrementRefCount(VectorOf(pair.second.code));
+    WasmCode::DecrementRefCount(base::VectorOf(pair.second.code));
   }
 }
 
@@ -1167,7 +1167,8 @@ std::shared_ptr<NativeModule> WasmEngine::NewNativeModule(
 }
 
 std::shared_ptr<NativeModule> WasmEngine::MaybeGetNativeModule(
-    ModuleOrigin origin, Vector<const uint8_t> wire_bytes, Isolate* isolate) {
+    ModuleOrigin origin, base::Vector<const uint8_t> wire_bytes,
+    Isolate* isolate) {
   std::shared_ptr<NativeModule> native_module =
       native_module_cache_.MaybeGetNativeModule(origin, wire_bytes);
   bool recompile_module = false;
@@ -1312,7 +1313,7 @@ void WasmEngine::SampleTopTierCodeSizeInAllIsolates(
 }
 
 void WasmEngine::ReportLiveCodeForGC(Isolate* isolate,
-                                     Vector<WasmCode*> live_code) {
+                                     base::Vector<WasmCode*> live_code) {
   TRACE_EVENT0("v8.wasm", "wasm.ReportLiveCodeForGC");
   TRACE_CODE_GC("Isolate %d reporting %zu live code objects.\n", isolate->id(),
                 live_code.size());
@@ -1350,8 +1351,8 @@ void WasmEngine::ReportLiveCodeFromStackForGC(Isolate* isolate) {
 
   CheckNoArchivedThreads(isolate);
 
-  ReportLiveCodeForGC(isolate,
-                      OwnedVector<WasmCode*>::Of(live_wasm_code).as_vector());
+  ReportLiveCodeForGC(
+      isolate, base::OwnedVector<WasmCode*>::Of(live_wasm_code).as_vector());
 }
 
 bool WasmEngine::AddPotentiallyDeadCode(WasmCode* code) {
@@ -1411,13 +1412,13 @@ void WasmEngine::FreeDeadCodeLocked(const DeadCodeMap& dead_code) {
       DCHECK_EQ(1, info->dead_code.count(code));
       info->dead_code.erase(code);
     }
-    native_module->FreeCode(VectorOf(code_vec));
+    native_module->FreeCode(base::VectorOf(code_vec));
   }
 }
 
 Handle<Script> WasmEngine::GetOrCreateScript(
     Isolate* isolate, const std::shared_ptr<NativeModule>& native_module,
-    Vector<const char> source_url) {
+    base::Vector<const char> source_url) {
   {
     base::MutexGuard guard(&mutex_);
     DCHECK_EQ(1, isolates_.count(isolate));
diff --git a/src/wasm/wasm-engine.h b/src/wasm/wasm-engine.h
index d4736036cb..88aedfe042 100644
--- a/src/wasm/wasm-engine.h
+++ b/src/wasm/wasm-engine.h
@@ -68,7 +68,7 @@ class NativeModuleCache {
     // Store the prefix hash as part of the key for faster lookup, and to
     // quickly check existing prefixes for streaming compilation.
     size_t prefix_hash;
-    Vector<const uint8_t> bytes;
+    base::Vector<const uint8_t> bytes;
 
     bool operator==(const Key& other) const {
       bool eq = bytes == other.bytes;
@@ -98,7 +98,7 @@ class NativeModuleCache {
   };
 
   std::shared_ptr<NativeModule> MaybeGetNativeModule(
-      ModuleOrigin origin, Vector<const uint8_t> wire_bytes);
+      ModuleOrigin origin, base::Vector<const uint8_t> wire_bytes);
   bool GetStreamingCompilationOwnership(size_t prefix_hash);
   void StreamingCompilationFailed(size_t prefix_hash);
   std::shared_ptr<NativeModule> Update(
@@ -107,13 +107,13 @@ class NativeModuleCache {
 
   bool empty() { return map_.empty(); }
 
-  static size_t WireBytesHash(Vector<const uint8_t> bytes);
+  static size_t WireBytesHash(base::Vector<const uint8_t> bytes);
 
   // Hash the wire bytes up to the code section header. Used as a heuristic to
   // avoid streaming compilation of modules that are likely already in the
   // cache. See {GetStreamingCompilationOwnership}. Assumes that the bytes have
   // already been validated.
-  static size_t PrefixHash(Vector<const uint8_t> wire_bytes);
+  static size_t PrefixHash(base::Vector<const uint8_t> wire_bytes);
 
  private:
   // Each key points to the corresponding native module's wire bytes, so they
@@ -155,7 +155,7 @@ class V8_EXPORT_PRIVATE WasmEngine {
   // asm.js module.
   MaybeHandle<AsmWasmData> SyncCompileTranslatedAsmJs(
       Isolate* isolate, ErrorThrower* thrower, const ModuleWireBytes& bytes,
-      Vector<const byte> asm_js_offset_table_bytes,
+      base::Vector<const byte> asm_js_offset_table_bytes,
       Handle<HeapNumber> uses_bitset, LanguageMode language_mode);
   Handle<WasmModuleObject> FinalizeTranslatedAsmJs(
       Isolate* isolate, Handle<AsmWasmData> asm_wasm_data,
@@ -214,7 +214,7 @@ class V8_EXPORT_PRIVATE WasmEngine {
   // the the same engine, recreating a full module object in the given Isolate.
   Handle<WasmModuleObject> ImportNativeModule(
       Isolate* isolate, std::shared_ptr<NativeModule> shared_module,
-      Vector<const char> source_url);
+      base::Vector<const char> source_url);
 
   WasmCodeManager* code_manager() { return &code_manager_; }
 
@@ -259,7 +259,7 @@ class V8_EXPORT_PRIVATE WasmEngine {
   // Trigger code logging for the given code objects in all Isolates which have
   // access to the NativeModule containing this code. This method can be called
   // from background threads.
-  void LogCode(Vector<WasmCode*>);
+  void LogCode(base::Vector<WasmCode*>);
 
   // Enable code logging for the given Isolate. Initially, code logging is
   // enabled if {WasmCode::ShouldBeLogged(Isolate*)} returns true during
@@ -288,7 +288,8 @@ class V8_EXPORT_PRIVATE WasmEngine {
   // threads. The {wire_bytes}' underlying array should be valid at least until
   // the call to {UpdateNativeModuleCache}.
   std::shared_ptr<NativeModule> MaybeGetNativeModule(
-      ModuleOrigin origin, Vector<const uint8_t> wire_bytes, Isolate* isolate);
+      ModuleOrigin origin, base::Vector<const uint8_t> wire_bytes,
+      Isolate* isolate);
 
   // Replace the temporary {nullopt} with the new native module, or
   // erase it if any error occurred. Wake up blocked threads waiting for this
@@ -326,7 +327,7 @@ class V8_EXPORT_PRIVATE WasmEngine {
   // Called by each Isolate to report its live code for a GC cycle. First
   // version reports an externally determined set of live code (might be empty),
   // second version gets live code from the execution stack of that isolate.
-  void ReportLiveCodeForGC(Isolate*, Vector<WasmCode*>);
+  void ReportLiveCodeForGC(Isolate*, base::Vector<WasmCode*>);
   void ReportLiveCodeFromStackForGC(Isolate*);
 
   // Add potentially dead code. The occurrence in the set of potentially dead
@@ -343,7 +344,7 @@ class V8_EXPORT_PRIVATE WasmEngine {
 
   Handle<Script> GetOrCreateScript(Isolate*,
                                    const std::shared_ptr<NativeModule>&,
-                                   Vector<const char> source_url);
+                                   base::Vector<const char> source_url);
 
   // Returns a barrier allowing background compile operations if valid and
   // preventing this object from being destroyed.
diff --git a/src/wasm/wasm-import-wrapper-cache.cc b/src/wasm/wasm-import-wrapper-cache.cc
index 877784fce2..c760634a76 100644
--- a/src/wasm/wasm-import-wrapper-cache.cc
+++ b/src/wasm/wasm-import-wrapper-cache.cc
@@ -51,7 +51,7 @@ WasmImportWrapperCache::~WasmImportWrapperCache() {
       ptrs.push_back(e.second);
     }
   }
-  WasmCode::DecrementRefCount(VectorOf(ptrs));
+  WasmCode::DecrementRefCount(base::VectorOf(ptrs));
 }
 
 }  // namespace wasm
diff --git a/src/wasm/wasm-js.cc b/src/wasm/wasm-js.cc
index 494d030035..7b6342c120 100644
--- a/src/wasm/wasm-js.cc
+++ b/src/wasm/wasm-js.cc
@@ -55,7 +55,7 @@ class WasmStreaming::WasmStreamingImpl {
   }
 
   void OnBytesReceived(const uint8_t* bytes, size_t size) {
-    streaming_decoder_->OnBytesReceived(i::VectorOf(bytes, size));
+    streaming_decoder_->OnBytesReceived(base::VectorOf(bytes, size));
   }
   void Finish() { streaming_decoder_->Finish(); }
 
@@ -81,16 +81,14 @@ class WasmStreaming::WasmStreamingImpl {
     streaming_decoder_->SetModuleCompiledCallback(
         [client, streaming_decoder = streaming_decoder_](
             const std::shared_ptr<i::wasm::NativeModule>& native_module) {
-          i::Vector<const char> url = streaming_decoder->url();
+          base::Vector<const char> url = streaming_decoder->url();
           auto compiled_wasm_module =
               CompiledWasmModule(native_module, url.begin(), url.size());
           client->OnModuleCompiled(compiled_wasm_module);
         });
   }
 
-  void SetUrl(internal::Vector<const char> url) {
-    streaming_decoder_->SetUrl(url);
-  }
+  void SetUrl(base::Vector<const char> url) { streaming_decoder_->SetUrl(url); }
 
  private:
   Isolate* const isolate_;
@@ -134,7 +132,7 @@ void WasmStreaming::SetClient(std::shared_ptr<Client> client) {
 
 void WasmStreaming::SetUrl(const char* url, size_t length) {
   TRACE_EVENT0("v8.wasm", "wasm.SetUrl");
-  impl_->SetUrl(internal::VectorOf(url, length));
+  impl_->SetUrl(base::VectorOf(url, length));
 }
 
 // static
diff --git a/src/wasm/wasm-module-builder.cc b/src/wasm/wasm-module-builder.cc
index 2e0f641267..f2c6100401 100644
--- a/src/wasm/wasm-module-builder.cc
+++ b/src/wasm/wasm-module-builder.cc
@@ -148,7 +148,9 @@ void WasmFunctionBuilder::EmitDirectCallIndex(uint32_t index) {
   EmitCode(placeholder_bytes, arraysize(placeholder_bytes));
 }
 
-void WasmFunctionBuilder::SetName(Vector<const char> name) { name_ = name; }
+void WasmFunctionBuilder::SetName(base::Vector<const char> name) {
+  name_ = name;
+}
 
 void WasmFunctionBuilder::AddAsmWasmOffset(size_t call_position,
                                            size_t to_number_position) {
@@ -373,16 +375,17 @@ uint32_t WasmModuleBuilder::AddTable(ValueType type, uint32_t min_size,
   return static_cast<uint32_t>(tables_.size() - 1);
 }
 
-uint32_t WasmModuleBuilder::AddImport(Vector<const char> name, FunctionSig* sig,
-                                      Vector<const char> module) {
+uint32_t WasmModuleBuilder::AddImport(base::Vector<const char> name,
+                                      FunctionSig* sig,
+                                      base::Vector<const char> module) {
   DCHECK(adding_imports_allowed_);
   function_imports_.push_back({module, name, AddSignature(sig)});
   return static_cast<uint32_t>(function_imports_.size() - 1);
 }
 
-uint32_t WasmModuleBuilder::AddGlobalImport(Vector<const char> name,
+uint32_t WasmModuleBuilder::AddGlobalImport(base::Vector<const char> name,
                                             ValueType type, bool mutability,
-                                            Vector<const char> module) {
+                                            base::Vector<const char> module) {
   global_imports_.push_back({module, name, type.value_type_code(), mutability});
   return static_cast<uint32_t>(global_imports_.size() - 1);
 }
@@ -391,7 +394,7 @@ void WasmModuleBuilder::MarkStartFunction(WasmFunctionBuilder* function) {
   start_function_index_ = function->func_index();
 }
 
-void WasmModuleBuilder::AddExport(Vector<const char> name,
+void WasmModuleBuilder::AddExport(base::Vector<const char> name,
                                   ImportExportKindCode kind, uint32_t index) {
   DCHECK_LE(index, std::numeric_limits<int>::max());
   exports_.push_back({name, kind, static_cast<int>(index)});
@@ -399,13 +402,13 @@ void WasmModuleBuilder::AddExport(Vector<const char> name,
 
 uint32_t WasmModuleBuilder::AddExportedGlobal(ValueType type, bool mutability,
                                               WasmInitExpr init,
-                                              Vector<const char> name) {
+                                              base::Vector<const char> name) {
   uint32_t index = AddGlobal(type, mutability, std::move(init));
   AddExport(name, kExternalGlobal, index);
   return index;
 }
 
-void WasmModuleBuilder::ExportImportedFunction(Vector<const char> name,
+void WasmModuleBuilder::ExportImportedFunction(base::Vector<const char> name,
                                                int import_index) {
 #if DEBUG
   // The size of function_imports_ must not change any more.
@@ -772,7 +775,7 @@ void WasmModuleBuilder::WriteTo(ZoneBuffer* buffer) const {
     // Emit a placeholder for section length.
     size_t start = buffer->reserve_u32v();
     // Emit custom section name.
-    buffer->write_string(CStrVector("compilationHints"));
+    buffer->write_string(base::CStrVector("compilationHints"));
     // Emit hint count.
     buffer->write_size(functions_.size());
     // Emit hint bytes.
@@ -817,7 +820,7 @@ void WasmModuleBuilder::WriteTo(ZoneBuffer* buffer) const {
     // Emit a placeholder for the length.
     size_t start = buffer->reserve_u32v();
     // Emit the section string.
-    buffer->write_string(CStrVector("name"));
+    buffer->write_string(base::CStrVector("name"));
     // Emit a subsection for the function names.
     buffer->write_u8(NameSectionKindCode::kFunction);
     // Emit a placeholder for the subsection length.
diff --git a/src/wasm/wasm-module-builder.h b/src/wasm/wasm-module-builder.h
index a089e6b0c9..7ea84c5dc9 100644
--- a/src/wasm/wasm-module-builder.h
+++ b/src/wasm/wasm-module-builder.h
@@ -11,8 +11,8 @@
 
 #include "src/base/memory.h"
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/codegen/signature.h"
-#include "src/utils/vector.h"
 #include "src/wasm/leb-helper.h"
 #include "src/wasm/local-decl-encoder.h"
 #include "src/wasm/value-type.h"
@@ -97,7 +97,7 @@ class ZoneBuffer : public ZoneObject {
     pos_ += size;
   }
 
-  void write_string(Vector<const char> name) {
+  void write_string(base::Vector<const char> name) {
     write_size(name.length());
     write(reinterpret_cast<const byte*>(name.begin()), name.length());
   }
@@ -187,7 +187,7 @@ class V8_EXPORT_PRIVATE WasmFunctionBuilder : public ZoneObject {
   void EmitWithI32V(WasmOpcode opcode, int32_t immediate);
   void EmitWithU32V(WasmOpcode opcode, uint32_t immediate);
   void EmitDirectCallIndex(uint32_t index);
-  void SetName(Vector<const char> name);
+  void SetName(base::Vector<const char> name);
   void AddAsmWasmOffset(size_t call_position, size_t to_number_position);
   void SetAsmFunctionStartPosition(size_t function_position);
   void SetCompilationHint(WasmCompilationHintStrategy strategy,
@@ -223,7 +223,7 @@ class V8_EXPORT_PRIVATE WasmFunctionBuilder : public ZoneObject {
   uint32_t signature_index_;
   uint32_t func_index_;
   ZoneBuffer body_;
-  Vector<const char> name_;
+  base::Vector<const char> name_;
   ZoneVector<uint32_t> i32_temps_;
   ZoneVector<uint32_t> i64_temps_;
   ZoneVector<uint32_t> f32_temps_;
@@ -245,13 +245,14 @@ class V8_EXPORT_PRIVATE WasmModuleBuilder : public ZoneObject {
   WasmModuleBuilder& operator=(const WasmModuleBuilder&) = delete;
 
   // Building methods.
-  uint32_t AddImport(Vector<const char> name, FunctionSig* sig,
-                     Vector<const char> module = {});
+  uint32_t AddImport(base::Vector<const char> name, FunctionSig* sig,
+                     base::Vector<const char> module = {});
   WasmFunctionBuilder* AddFunction(FunctionSig* sig = nullptr);
   uint32_t AddGlobal(ValueType type, bool mutability = true,
                      WasmInitExpr init = WasmInitExpr());
-  uint32_t AddGlobalImport(Vector<const char> name, ValueType type,
-                           bool mutability, Vector<const char> module = {});
+  uint32_t AddGlobalImport(base::Vector<const char> name, ValueType type,
+                           bool mutability,
+                           base::Vector<const char> module = {});
   void AddDataSegment(const byte* data, uint32_t size, uint32_t dest);
   uint32_t AddSignature(FunctionSig* sig);
   uint32_t AddException(FunctionSig* type);
@@ -268,14 +269,14 @@ class V8_EXPORT_PRIVATE WasmModuleBuilder : public ZoneObject {
   uint32_t AddTable(ValueType type, uint32_t min_size, uint32_t max_size,
                     WasmInitExpr init);
   void MarkStartFunction(WasmFunctionBuilder* builder);
-  void AddExport(Vector<const char> name, ImportExportKindCode kind,
+  void AddExport(base::Vector<const char> name, ImportExportKindCode kind,
                  uint32_t index);
-  void AddExport(Vector<const char> name, WasmFunctionBuilder* builder) {
+  void AddExport(base::Vector<const char> name, WasmFunctionBuilder* builder) {
     AddExport(name, kExternalFunction, builder->func_index());
   }
   uint32_t AddExportedGlobal(ValueType type, bool mutability, WasmInitExpr init,
-                             Vector<const char> name);
-  void ExportImportedFunction(Vector<const char> name, int import_index);
+                             base::Vector<const char> name);
+  void ExportImportedFunction(base::Vector<const char> name, int import_index);
   void SetMinMemorySize(uint32_t value);
   void SetMaxMemorySize(uint32_t value);
   void SetHasSharedMemory();
@@ -317,20 +318,20 @@ class V8_EXPORT_PRIVATE WasmModuleBuilder : public ZoneObject {
   };
 
   struct WasmFunctionImport {
-    Vector<const char> module;
-    Vector<const char> name;
+    base::Vector<const char> module;
+    base::Vector<const char> name;
     uint32_t sig_index;
   };
 
   struct WasmGlobalImport {
-    Vector<const char> module;
-    Vector<const char> name;
+    base::Vector<const char> module;
+    base::Vector<const char> name;
     ValueTypeCode type_code;
     bool mutability;
   };
 
   struct WasmExport {
-    Vector<const char> name;
+    base::Vector<const char> name;
     ImportExportKindCode kind;
     int index;  // Can be negative for re-exported imports.
   };
diff --git a/src/wasm/wasm-module.cc b/src/wasm/wasm-module.cc
index 651040c16a..65c78e0b95 100644
--- a/src/wasm/wasm-module.cc
+++ b/src/wasm/wasm-module.cc
@@ -113,8 +113,8 @@ void LazilyGeneratedNames::AddForTesting(int function_index,
 }
 
 AsmJsOffsetInformation::AsmJsOffsetInformation(
-    Vector<const byte> encoded_offsets)
-    : encoded_offsets_(OwnedVector<const uint8_t>::Of(encoded_offsets)) {}
+    base::Vector<const byte> encoded_offsets)
+    : encoded_offsets_(base::OwnedVector<const uint8_t>::Of(encoded_offsets)) {}
 
 AsmJsOffsetInformation::~AsmJsOffsetInformation() = default;
 
@@ -222,7 +222,8 @@ namespace {
 // reflective functions. Should be kept in sync with the {GetValueType} helper.
 Handle<String> ToValueTypeString(Isolate* isolate, ValueType type) {
   return isolate->factory()->InternalizeUtf8String(
-      type == kWasmFuncRef ? CStrVector("anyfunc") : VectorOf(type.name()));
+      type == kWasmFuncRef ? base::CStrVector("anyfunc")
+                           : base::VectorOf(type.name()));
 }
 }  // namespace
 
@@ -303,7 +304,7 @@ Handle<JSObject> GetTypeForTable(Isolate* isolate, ValueType type,
     // place and then use that constant everywhere.
     element = factory->InternalizeUtf8String("anyfunc");
   } else {
-    element = factory->InternalizeUtf8String(VectorOf(type.name()));
+    element = factory->InternalizeUtf8String(base::VectorOf(type.name()));
   }
 
   Handle<JSFunction> object_function = isolate->object_function();
@@ -522,7 +523,7 @@ Handle<JSArray> GetCustomSections(Isolate* isolate,
                                   Handle<String> name, ErrorThrower* thrower) {
   Factory* factory = isolate->factory();
 
-  Vector<const uint8_t> wire_bytes =
+  base::Vector<const uint8_t> wire_bytes =
       module_object->native_module()->wire_bytes();
   std::vector<CustomSectionOffset> custom_sections =
       DecodeCustomSections(wire_bytes.begin(), wire_bytes.end());
@@ -604,7 +605,7 @@ size_t EstimateStoredSize(const WasmModule* module) {
          VectorSize(module->elem_segments);
 }
 
-size_t PrintSignature(Vector<char> buffer, const wasm::FunctionSig* sig,
+size_t PrintSignature(base::Vector<char> buffer, const wasm::FunctionSig* sig,
                       char delimiter) {
   if (buffer.empty()) return 0;
   size_t old_size = buffer.size();
diff --git a/src/wasm/wasm-module.h b/src/wasm/wasm-module.h
index d58099aa03..8b6ca84cf1 100644
--- a/src/wasm/wasm-module.h
+++ b/src/wasm/wasm-module.h
@@ -13,9 +13,9 @@
 
 #include "src/base/optional.h"
 #include "src/base/platform/wrappers.h"
+#include "src/base/vector.h"
 #include "src/common/globals.h"
 #include "src/handles/handles.h"
-#include "src/utils/vector.h"
 #include "src/wasm/branch-hint-map.h"
 #include "src/wasm/signature-map.h"
 #include "src/wasm/struct-types.h"
@@ -30,7 +30,7 @@ class WasmModuleObject;
 
 namespace wasm {
 
-using WasmName = Vector<const char>;
+using WasmName = base::Vector<const char>;
 
 struct AsmJsOffsets;
 class ErrorThrower;
@@ -208,7 +208,7 @@ class V8_EXPORT_PRIVATE LazilyGeneratedNames {
 
 class V8_EXPORT_PRIVATE AsmJsOffsetInformation {
  public:
-  explicit AsmJsOffsetInformation(Vector<const byte> encoded_offsets);
+  explicit AsmJsOffsetInformation(base::Vector<const byte> encoded_offsets);
 
   // Destructor defined in wasm-module.cc, where the definition of
   // {AsmJsOffsets} is available.
@@ -228,7 +228,7 @@ class V8_EXPORT_PRIVATE AsmJsOffsetInformation {
   mutable base::Mutex mutex_;
 
   // Holds the encoded offset table bytes.
-  OwnedVector<const uint8_t> encoded_offsets_;
+  base::OwnedVector<const uint8_t> encoded_offsets_;
 
   // Holds the decoded offset table.
   std::unique_ptr<AsmJsOffsets> decoded_offsets_;
@@ -414,7 +414,7 @@ int GetNearestWasmFunction(const WasmModule* module, uint32_t byte_offset);
 // on module_bytes, as this storage is only guaranteed to be alive as long as
 // this struct is alive.
 struct V8_EXPORT_PRIVATE ModuleWireBytes {
-  explicit ModuleWireBytes(Vector<const byte> module_bytes)
+  explicit ModuleWireBytes(base::Vector<const byte> module_bytes)
       : module_bytes_(module_bytes) {}
   ModuleWireBytes(const byte* start, const byte* end)
       : module_bytes_(start, static_cast<int>(end - start)) {
@@ -434,18 +434,19 @@ struct V8_EXPORT_PRIVATE ModuleWireBytes {
     return ref.offset() <= size && ref.length() <= size - ref.offset();
   }
 
-  Vector<const byte> GetFunctionBytes(const WasmFunction* function) const {
+  base::Vector<const byte> GetFunctionBytes(
+      const WasmFunction* function) const {
     return module_bytes_.SubVector(function->code.offset(),
                                    function->code.end_offset());
   }
 
-  Vector<const byte> module_bytes() const { return module_bytes_; }
+  base::Vector<const byte> module_bytes() const { return module_bytes_; }
   const byte* start() const { return module_bytes_.begin(); }
   const byte* end() const { return module_bytes_.end(); }
   size_t length() const { return module_bytes_.length(); }
 
  private:
-  Vector<const byte> module_bytes_;
+  base::Vector<const byte> module_bytes_;
 };
 
 // A helper for printing out the names of functions.
@@ -501,7 +502,7 @@ class TruncatedUserString {
 
  public:
   template <typename T>
-  explicit TruncatedUserString(Vector<T> name)
+  explicit TruncatedUserString(base::Vector<T> name)
       : TruncatedUserString(name.begin(), name.length()) {}
 
   TruncatedUserString(const byte* start, size_t len)
@@ -530,7 +531,7 @@ class TruncatedUserString {
 // between parameter types and return types. If {buffer} is non-empty, it will
 // be null-terminated, even if the signature is cut off. Returns the number of
 // characters written, excluding the terminating null-byte.
-size_t PrintSignature(Vector<char> buffer, const wasm::FunctionSig*,
+size_t PrintSignature(base::Vector<char> buffer, const wasm::FunctionSig*,
                       char delimiter = ':');
 
 }  // namespace wasm
diff --git a/src/wasm/wasm-objects.cc b/src/wasm/wasm-objects.cc
index b0815fb624..74e7a644d3 100644
--- a/src/wasm/wasm-objects.cc
+++ b/src/wasm/wasm-objects.cc
@@ -5,6 +5,7 @@
 #include "src/wasm/wasm-objects.h"
 
 #include "src/base/iterator.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/code-factory.h"
 #include "src/compiler/wasm-compiler.h"
@@ -16,7 +17,6 @@
 #include "src/objects/struct-inl.h"
 #include "src/trap-handler/trap-handler.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 #include "src/wasm/jump-table-assembler.h"
 #include "src/wasm/module-compiler.h"
 #include "src/wasm/module-decoder.h"
@@ -190,24 +190,25 @@ Handle<WasmModuleObject> WasmModuleObject::New(
 Handle<String> WasmModuleObject::ExtractUtf8StringFromModuleBytes(
     Isolate* isolate, Handle<WasmModuleObject> module_object,
     wasm::WireBytesRef ref, InternalizeString internalize) {
-  Vector<const uint8_t> wire_bytes =
+  base::Vector<const uint8_t> wire_bytes =
       module_object->native_module()->wire_bytes();
   return ExtractUtf8StringFromModuleBytes(isolate, wire_bytes, ref,
                                           internalize);
 }
 
 Handle<String> WasmModuleObject::ExtractUtf8StringFromModuleBytes(
-    Isolate* isolate, Vector<const uint8_t> wire_bytes, wasm::WireBytesRef ref,
-    InternalizeString internalize) {
-  Vector<const uint8_t> name_vec =
+    Isolate* isolate, base::Vector<const uint8_t> wire_bytes,
+    wasm::WireBytesRef ref, InternalizeString internalize) {
+  base::Vector<const uint8_t> name_vec =
       wire_bytes.SubVector(ref.offset(), ref.end_offset());
   // UTF8 validation happens at decode time.
   DCHECK(unibrow::Utf8::ValidateEncoding(name_vec.begin(), name_vec.length()));
   auto* factory = isolate->factory();
   return internalize
              ? factory->InternalizeUtf8String(
-                   Vector<const char>::cast(name_vec))
-             : factory->NewStringFromUtf8(Vector<const char>::cast(name_vec))
+                   base::Vector<const char>::cast(name_vec))
+             : factory
+                   ->NewStringFromUtf8(base::Vector<const char>::cast(name_vec))
                    .ToHandleChecked();
 }
 
@@ -232,9 +233,10 @@ MaybeHandle<String> WasmModuleObject::GetFunctionNameOrNull(
                                           kNoInternalize);
 }
 
-Vector<const uint8_t> WasmModuleObject::GetRawFunctionName(int func_index) {
+base::Vector<const uint8_t> WasmModuleObject::GetRawFunctionName(
+    int func_index) {
   if (func_index == wasm::kAnonymousFuncIndex) {
-    return Vector<const uint8_t>({nullptr, 0});
+    return base::Vector<const uint8_t>({nullptr, 0});
   }
   DCHECK_GT(module()->functions.size(), func_index);
   wasm::ModuleWireBytes wire_bytes(native_module()->wire_bytes());
@@ -242,7 +244,7 @@ Vector<const uint8_t> WasmModuleObject::GetRawFunctionName(int func_index) {
       module()->lazily_generated_names.LookupFunctionName(wire_bytes,
                                                           func_index);
   wasm::WasmName name = wire_bytes.GetNameOrNull(name_ref);
-  return Vector<const uint8_t>::cast(name);
+  return base::Vector<const uint8_t>::cast(name);
 }
 
 Handle<WasmTableObject> WasmTableObject::New(
@@ -1940,11 +1942,11 @@ Handle<WasmExportedFunction> WasmExportedFunction::New(
   }
   Handle<String> name;
   if (!maybe_name.ToHandle(&name)) {
-    EmbeddedVector<char, 16> buffer;
+    base::EmbeddedVector<char, 16> buffer;
     int length = SNPrintF(buffer, "%d", func_index);
     name = factory
                ->NewStringFromOneByte(
-                   Vector<uint8_t>::cast(buffer.SubVector(0, length)))
+                   base::Vector<uint8_t>::cast(buffer.SubVector(0, length)))
                .ToHandleChecked();
   }
   Handle<Map> function_map;
@@ -2019,7 +2021,7 @@ std::unique_ptr<char[]> WasmExportedFunction::GetDebugName(
   constexpr const char kPrefix[] = "js-to-wasm:";
   // prefix + parameters + delimiter + returns + zero byte
   size_t len = strlen(kPrefix) + sig->all().size() + 2;
-  auto buffer = OwnedVector<char>::New(len);
+  auto buffer = base::OwnedVector<char>::New(len);
   memcpy(buffer.start(), kPrefix, strlen(kPrefix));
   PrintSignature(buffer.as_vector() + strlen(kPrefix), sig);
   return buffer.ReleaseData();
diff --git a/src/wasm/wasm-objects.h b/src/wasm/wasm-objects.h
index 7fadfb965e..da1b7e7056 100644
--- a/src/wasm/wasm-objects.h
+++ b/src/wasm/wasm-objects.h
@@ -171,7 +171,7 @@ class WasmModuleObject : public JSObject {
   // given index.
   // Meant to be used for debugging or frame printing.
   // Does not allocate, hence gc-safe.
-  Vector<const uint8_t> GetRawFunctionName(int func_index);
+  base::Vector<const uint8_t> GetRawFunctionName(int func_index);
 
   // Extract a portion of the wire bytes as UTF-8 string, optionally
   // internalized. (Prefer to internalize early if the string will be used for a
@@ -180,7 +180,7 @@ class WasmModuleObject : public JSObject {
       Isolate*, Handle<WasmModuleObject>, wasm::WireBytesRef,
       InternalizeString);
   static Handle<String> ExtractUtf8StringFromModuleBytes(
-      Isolate*, Vector<const uint8_t> wire_byte, wasm::WireBytesRef,
+      Isolate*, base::Vector<const uint8_t> wire_byte, wasm::WireBytesRef,
       InternalizeString);
 
   OBJECT_CONSTRUCTORS(WasmModuleObject, JSObject);
diff --git a/src/wasm/wasm-result.cc b/src/wasm/wasm-result.cc
index fc1104b8d0..342aa66ddc 100644
--- a/src/wasm/wasm-result.cc
+++ b/src/wasm/wasm-result.cc
@@ -28,9 +28,10 @@ void VPrintFToString(std::string* str, size_t str_offset, const char* format,
     str->resize(len);
     va_list args_copy;
     va_copy(args_copy, args);
-    int written = VSNPrintF(Vector<char>(&str->front() + str_offset,
-                                         static_cast<int>(len - str_offset)),
-                            format, args_copy);
+    int written =
+        VSNPrintF(base::Vector<char>(&str->front() + str_offset,
+                                     static_cast<int>(len - str_offset)),
+                  format, args_copy);
     va_end(args_copy);
     if (written < 0) continue;  // not enough space.
     str->resize(str_offset + written);
@@ -127,7 +128,7 @@ Handle<Object> ErrorThrower::Reify() {
       break;
   }
   Handle<String> message = isolate_->factory()
-                               ->NewStringFromUtf8(VectorOf(error_msg_))
+                               ->NewStringFromUtf8(base::VectorOf(error_msg_))
                                .ToHandleChecked();
   Reset();
   return isolate_->factory()->NewError(constructor, message);
diff --git a/src/wasm/wasm-serialization.cc b/src/wasm/wasm-serialization.cc
index 40d670a803..1b41c18af8 100644
--- a/src/wasm/wasm-serialization.cc
+++ b/src/wasm/wasm-serialization.cc
@@ -35,13 +35,13 @@ namespace {
 // in Wasm, e.g. StreamProcessor and ZoneBuffer, with these.
 class Writer {
  public:
-  explicit Writer(Vector<byte> buffer)
+  explicit Writer(base::Vector<byte> buffer)
       : start_(buffer.begin()), end_(buffer.end()), pos_(buffer.begin()) {}
 
   size_t bytes_written() const { return pos_ - start_; }
   byte* current_location() const { return pos_; }
   size_t current_size() const { return end_ - pos_; }
-  Vector<byte> current_buffer() const {
+  base::Vector<byte> current_buffer() const {
     return {current_location(), current_size()};
   }
 
@@ -56,7 +56,7 @@ class Writer {
     }
   }
 
-  void WriteVector(const Vector<const byte> v) {
+  void WriteVector(const base::Vector<const byte> v) {
     DCHECK_GE(current_size(), v.size());
     if (v.size() > 0) {
       memcpy(current_location(), v.begin(), v.size());
@@ -78,13 +78,13 @@ class Writer {
 
 class Reader {
  public:
-  explicit Reader(Vector<const byte> buffer)
+  explicit Reader(base::Vector<const byte> buffer)
       : start_(buffer.begin()), end_(buffer.end()), pos_(buffer.begin()) {}
 
   size_t bytes_read() const { return pos_ - start_; }
   const byte* current_location() const { return pos_; }
   size_t current_size() const { return end_ - pos_; }
-  Vector<const byte> current_buffer() const {
+  base::Vector<const byte> current_buffer() const {
     return {current_location(), current_size()};
   }
 
@@ -102,16 +102,16 @@ class Reader {
   }
 
   template <typename T>
-  Vector<const T> ReadVector(size_t size) {
+  base::Vector<const T> ReadVector(size_t size) {
     DCHECK_GE(current_size(), size);
-    Vector<const byte> bytes{pos_, size * sizeof(T)};
+    base::Vector<const byte> bytes{pos_, size * sizeof(T)};
     pos_ += size * sizeof(T);
     if (FLAG_trace_wasm_serialization) {
       StdoutStream{} << "read vector of " << size << " elements of size "
                      << sizeof(T) << " (total size " << size * sizeof(T) << ")"
                      << std::endl;
     }
-    return Vector<const T>::cast(bytes);
+    return base::Vector<const T>::cast(bytes);
   }
 
   void Skip(size_t size) { pos_ += size; }
@@ -275,7 +275,7 @@ static_assert(std::is_trivially_destructible<ExternalReferenceList>::value,
 
 class V8_EXPORT_PRIVATE NativeModuleSerializer {
  public:
-  NativeModuleSerializer(const NativeModule*, Vector<WasmCode* const>);
+  NativeModuleSerializer(const NativeModule*, base::Vector<WasmCode* const>);
   NativeModuleSerializer(const NativeModuleSerializer&) = delete;
   NativeModuleSerializer& operator=(const NativeModuleSerializer&) = delete;
 
@@ -288,13 +288,13 @@ class V8_EXPORT_PRIVATE NativeModuleSerializer {
   bool WriteCode(const WasmCode*, Writer*);
 
   const NativeModule* const native_module_;
-  const Vector<WasmCode* const> code_table_;
+  const base::Vector<WasmCode* const> code_table_;
   bool write_called_ = false;
   size_t total_written_code_ = 0;
 };
 
 NativeModuleSerializer::NativeModuleSerializer(
-    const NativeModule* module, Vector<WasmCode* const> code_table)
+    const NativeModule* module, base::Vector<WasmCode* const> code_table)
     : native_module_(module), code_table_(code_table) {
   DCHECK_NOT_NULL(native_module_);
   // TODO(mtrofin): persist the export wrappers. Ideally, we'd only persist
@@ -464,12 +464,14 @@ WasmSerializer::WasmSerializer(NativeModule* native_module)
       code_table_(native_module->SnapshotCodeTable()) {}
 
 size_t WasmSerializer::GetSerializedNativeModuleSize() const {
-  NativeModuleSerializer serializer(native_module_, VectorOf(code_table_));
+  NativeModuleSerializer serializer(native_module_,
+                                    base::VectorOf(code_table_));
   return kHeaderSize + serializer.Measure();
 }
 
-bool WasmSerializer::SerializeNativeModule(Vector<byte> buffer) const {
-  NativeModuleSerializer serializer(native_module_, VectorOf(code_table_));
+bool WasmSerializer::SerializeNativeModule(base::Vector<byte> buffer) const {
+  NativeModuleSerializer serializer(native_module_,
+                                    base::VectorOf(code_table_));
   size_t measured_size = kHeaderSize + serializer.Measure();
   if (buffer.size() < measured_size) return false;
 
@@ -482,7 +484,7 @@ bool WasmSerializer::SerializeNativeModule(Vector<byte> buffer) const {
 }
 
 struct DeserializationUnit {
-  Vector<const byte> src_code_buffer;
+  base::Vector<const byte> src_code_buffer;
   std::unique_ptr<WasmCode> code;
   NativeModule::JumpTablesRef jump_tables;
 };
@@ -550,7 +552,7 @@ class V8_EXPORT_PRIVATE NativeModuleDeserializer {
 
   // Updated in {ReadCode}.
   size_t remaining_code_size_ = 0;
-  Vector<byte> current_code_space_;
+  base::Vector<byte> current_code_space_;
   NativeModule::JumpTablesRef current_jump_tables_;
 };
 
@@ -727,7 +729,8 @@ DeserializationUnit NativeModuleDeserializer::ReadCode(int fn_index,
   auto protected_instructions =
       reader->ReadVector<byte>(protected_instructions_size);
 
-  Vector<uint8_t> instructions = current_code_space_.SubVector(0, code_size);
+  base::Vector<uint8_t> instructions =
+      current_code_space_.SubVector(0, code_size);
   current_code_space_ += code_size;
   remaining_code_size_ -= code_size;
 
@@ -802,14 +805,14 @@ void NativeModuleDeserializer::Publish(std::vector<DeserializationUnit> batch) {
   for (auto& unit : batch) {
     codes.emplace_back(std::move(unit).code);
   }
-  auto published_codes = native_module_->PublishCode(VectorOf(codes));
+  auto published_codes = native_module_->PublishCode(base::VectorOf(codes));
   for (auto* wasm_code : published_codes) {
     wasm_code->MaybePrint();
     wasm_code->Validate();
   }
 }
 
-bool IsSupportedVersion(Vector<const byte> header) {
+bool IsSupportedVersion(base::Vector<const byte> header) {
   if (header.size() < WasmSerializer::kHeaderSize) return false;
   byte current_version[WasmSerializer::kHeaderSize];
   Writer writer({current_version, WasmSerializer::kHeaderSize});
@@ -819,14 +822,15 @@ bool IsSupportedVersion(Vector<const byte> header) {
 }
 
 MaybeHandle<WasmModuleObject> DeserializeNativeModule(
-    Isolate* isolate, Vector<const byte> data,
-    Vector<const byte> wire_bytes_vec, Vector<const char> source_url) {
+    Isolate* isolate, base::Vector<const byte> data,
+    base::Vector<const byte> wire_bytes_vec,
+    base::Vector<const char> source_url) {
   if (!IsWasmCodegenAllowed(isolate, isolate->native_context())) return {};
   if (!IsSupportedVersion(data)) return {};
 
   // Make the copy of the wire bytes early, so we use the same memory for
   // decoding, lookup in the native module cache, and insertion into the cache.
-  auto owned_wire_bytes = OwnedVector<uint8_t>::Of(wire_bytes_vec);
+  auto owned_wire_bytes = base::OwnedVector<uint8_t>::Of(wire_bytes_vec);
 
   // TODO(titzer): module features should be part of the serialization format.
   WasmEngine* wasm_engine = isolate->wasm_engine();
diff --git a/src/wasm/wasm-serialization.h b/src/wasm/wasm-serialization.h
index a8aff9a6b8..dc33dcf5cc 100644
--- a/src/wasm/wasm-serialization.h
+++ b/src/wasm/wasm-serialization.h
@@ -28,7 +28,7 @@ class V8_EXPORT_PRIVATE WasmSerializer {
 
   // Serialize the {NativeModule} into the provided {buffer}. Returns true on
   // success and false if the given buffer it too small for serialization.
-  bool SerializeNativeModule(Vector<byte> buffer) const;
+  bool SerializeNativeModule(base::Vector<byte> buffer) const;
 
   // The data header consists of uint32_t-sized entries (see {WriteVersion}):
   // [0] magic number
@@ -54,12 +54,12 @@ class V8_EXPORT_PRIVATE WasmSerializer {
 
 // Support for deserializing WebAssembly {NativeModule} objects.
 // Checks the version header of the data against the current version.
-bool IsSupportedVersion(Vector<const byte> data);
+bool IsSupportedVersion(base::Vector<const byte> data);
 
 // Deserializes the given data to create a Wasm module object.
 V8_EXPORT_PRIVATE MaybeHandle<WasmModuleObject> DeserializeNativeModule(
-    Isolate*, Vector<const byte> data, Vector<const byte> wire_bytes,
-    Vector<const char> source_url);
+    Isolate*, base::Vector<const byte> data,
+    base::Vector<const byte> wire_bytes, base::Vector<const char> source_url);
 
 }  // namespace wasm
 }  // namespace internal
diff --git a/src/web-snapshot/web-snapshot.cc b/src/web-snapshot/web-snapshot.cc
index 6a10d59d09..39c65ab9dd 100644
--- a/src/web-snapshot/web-snapshot.cc
+++ b/src/web-snapshot/web-snapshot.cc
@@ -245,7 +245,7 @@ void WebSnapshotSerializer::SerializeString(Handle<String> string,
   String::FlatContent flat = string->GetFlatContent(no_gc);
   DCHECK(flat.IsFlat());
   if (flat.IsOneByte()) {
-    Vector<const uint8_t> chars = flat.ToOneByteVector();
+    base::Vector<const uint8_t> chars = flat.ToOneByteVector();
     string_serializer_.WriteUint32(chars.length());
     string_serializer_.WriteRawBytes(chars.begin(),
                                      chars.length() * sizeof(uint8_t));
diff --git a/src/zone/zone-list-inl.h b/src/zone/zone-list-inl.h
index 2c0aa4fa6d..fba12abd17 100644
--- a/src/zone/zone-list-inl.h
+++ b/src/zone/zone-list-inl.h
@@ -29,7 +29,7 @@ void ZoneList<T>::AddAll(const ZoneList<T>& other, Zone* zone) {
 }
 
 template <typename T>
-void ZoneList<T>::AddAll(const Vector<const T>& other, Zone* zone) {
+void ZoneList<T>::AddAll(const base::Vector<const T>& other, Zone* zone) {
   int length = other.length();
   if (length == 0) return;
 
@@ -80,10 +80,10 @@ void ZoneList<T>::Resize(int new_capacity, Zone* zone) {
 }
 
 template <typename T>
-Vector<T> ZoneList<T>::AddBlock(T value, int count, Zone* zone) {
+base::Vector<T> ZoneList<T>::AddBlock(T value, int count, Zone* zone) {
   int start = length_;
   for (int i = 0; i < count; i++) Add(value, zone);
-  return Vector<T>(&data_[start], count);
+  return base::Vector<T>(&data_[start], count);
 }
 
 template <typename T>
diff --git a/src/zone/zone-list.h b/src/zone/zone-list.h
index f0e3e532de..e24d9610dc 100644
--- a/src/zone/zone-list.h
+++ b/src/zone/zone-list.h
@@ -9,10 +9,13 @@
 #include "src/zone/zone.h"
 
 namespace v8 {
-namespace internal {
 
+namespace base {
 template <typename T>
 class Vector;
+}  // namespace base
+
+namespace internal {
 
 // ZoneLists are growable lists with constant-time access to the elements.
 // The list itself and all its elements are supposed to be allocated in zone
@@ -41,7 +44,7 @@ class ZoneList final : public ZoneObject {
   }
 
   // Construct a new ZoneList by copying the elements of the given vector.
-  ZoneList(const Vector<const T>& other, Zone* zone)
+  ZoneList(const base::Vector<const T>& other, Zone* zone)
       : ZoneList(other.length(), zone) {
     AddAll(other, zone);
   }
@@ -93,14 +96,14 @@ class ZoneList final : public ZoneObject {
   V8_INLINE int length() const { return length_; }
   V8_INLINE int capacity() const { return capacity_; }
 
-  Vector<T> ToVector() const { return Vector<T>(data_, length_); }
-  Vector<T> ToVector(int start, int length) const {
+  base::Vector<T> ToVector() const { return base::Vector<T>(data_, length_); }
+  base::Vector<T> ToVector(int start, int length) const {
     DCHECK_LE(start, length_);
-    return Vector<T>(&data_[start], std::min(length_ - start, length));
+    return base::Vector<T>(&data_[start], std::min(length_ - start, length));
   }
 
-  Vector<const T> ToConstVector() const {
-    return Vector<const T>(data_, length_);
+  base::Vector<const T> ToConstVector() const {
+    return base::Vector<const T>(data_, length_);
   }
 
   // Adds a copy of the given 'element' to the end of the list,
@@ -109,14 +112,14 @@ class ZoneList final : public ZoneObject {
   // Add all the elements from the argument list to this list.
   void AddAll(const ZoneList<T>& other, Zone* zone);
   // Add all the elements from the vector to this list.
-  void AddAll(const Vector<const T>& other, Zone* zone);
+  void AddAll(const base::Vector<const T>& other, Zone* zone);
   // Inserts the element at the specific index.
   void InsertAt(int index, const T& element, Zone* zone);
 
   // Added 'count' elements with the value 'value' and returns a
   // vector that allows access to the elements. The vector is valid
   // until the next change is made to this list.
-  Vector<T> AddBlock(T value, int count, Zone* zone);
+  base::Vector<T> AddBlock(T value, int count, Zone* zone);
 
   // Overwrites the element at the specific index.
   void Set(int index, const T& element);
diff --git a/src/zone/zone-utils.h b/src/zone/zone-utils.h
index 5cdbb8ccd5..1c08fcac0c 100644
--- a/src/zone/zone-utils.h
+++ b/src/zone/zone-utils.h
@@ -8,16 +8,16 @@
 #include <algorithm>
 #include <type_traits>
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 #include "src/zone/zone.h"
 
 namespace v8 {
 namespace internal {
 
 template <typename T>
-Vector<T> CloneVector(Zone* zone, const Vector<const T>& other) {
+base::Vector<T> CloneVector(Zone* zone, const base::Vector<const T>& other) {
   int length = other.length();
-  if (length == 0) return Vector<T>();
+  if (length == 0) return base::Vector<T>();
 
   T* data = zone->NewArray<T>(length);
   if (std::is_trivially_copyable<T>::value) {
@@ -25,7 +25,7 @@ Vector<T> CloneVector(Zone* zone, const Vector<const T>& other) {
   } else {
     std::copy(other.begin(), other.end(), data);
   }
-  return Vector<T>(data, length);
+  return base::Vector<T>(data, length);
 }
 
 }  // namespace internal
diff --git a/test/cctest/cctest.cc b/test/cctest/cctest.cc
index 195ef93291..5868db125e 100644
--- a/test/cctest/cctest.cc
+++ b/test/cctest/cctest.cc
@@ -170,8 +170,8 @@ i::Handle<i::String> CcTest::MakeString(const char* str) {
 }
 
 i::Handle<i::String> CcTest::MakeName(const char* str, int suffix) {
-  i::EmbeddedVector<char, 128> buffer;
-  SNPrintF(buffer, "%s%d", str, suffix);
+  v8::base::EmbeddedVector<char, 128> buffer;
+  i::SNPrintF(buffer, "%s%d", str, suffix);
   return CcTest::MakeString(buffer.begin());
 }
 
diff --git a/test/cctest/collector.h b/test/cctest/collector.h
index 0e7251f4bb..9f21d17b9f 100644
--- a/test/cctest/collector.h
+++ b/test/cctest/collector.h
@@ -7,8 +7,8 @@
 
 #include <vector>
 
+#include "src/base/vector.h"
 #include "src/common/checks.h"
-#include "src/utils/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -27,7 +27,7 @@ class Collector {
  public:
   explicit Collector(int initial_capacity = kMinCapacity)
       : index_(0), size_(0) {
-    current_chunk_ = Vector<T>::New(initial_capacity);
+    current_chunk_ = base::Vector<T>::New(initial_capacity);
   }
 
   virtual ~Collector() {
@@ -52,7 +52,7 @@ class Collector {
   // memory area.
   // A basic Collector will keep this vector valid as long as the Collector
   // is alive.
-  inline Vector<T> AddBlock(int size, T initial_value) {
+  inline base::Vector<T> AddBlock(int size, T initial_value) {
     DCHECK_GT(size, 0);
     if (size > current_chunk_.length() - index_) {
       Grow(size);
@@ -63,14 +63,14 @@ class Collector {
     for (int i = 0; i < size; i++) {
       position[i] = initial_value;
     }
-    return Vector<T>(position, size);
+    return base::Vector<T>(position, size);
   }
 
   // Add a contiguous block of elements and return a vector backed
   // by the added block.
   // A basic Collector will keep this vector valid as long as the Collector
   // is alive.
-  inline Vector<T> AddBlock(Vector<const T> source) {
+  inline base::Vector<T> AddBlock(base::Vector<const T> source) {
     if (source.length() > current_chunk_.length() - index_) {
       Grow(source.length());
     }
@@ -80,14 +80,14 @@ class Collector {
     for (int i = 0; i < source.length(); i++) {
       position[i] = source[i];
     }
-    return Vector<T>(position, source.length());
+    return base::Vector<T>(position, source.length());
   }
 
   // Write the contents of the collector into the provided vector.
-  void WriteTo(Vector<T> destination) {
+  void WriteTo(base::Vector<T> destination) {
     DCHECK(size_ <= destination.length());
     int position = 0;
-    for (const Vector<T>& chunk : chunks_) {
+    for (const base::Vector<T>& chunk : chunks_) {
       for (int j = 0; j < chunk.length(); j++) {
         destination[position] = chunk[j];
         position++;
@@ -103,8 +103,8 @@ class Collector {
   // elements to the vector, and return it.
   // The caller is responsible for freeing the memory of the returned
   // vector (e.g., using Vector::Dispose).
-  Vector<T> ToVector() {
-    Vector<T> new_store = Vector<T>::New(size_);
+  base::Vector<T> ToVector() {
+    base::Vector<T> new_store = base::Vector<T>::New(size_);
     WriteTo(new_store);
     return new_store;
   }
@@ -124,8 +124,9 @@ class Collector {
 
  protected:
   static const int kMinCapacity = 16;
-  std::vector<Vector<T>> chunks_;
-  Vector<T> current_chunk_;  // Block of memory currently being written into.
+  std::vector<base::Vector<T>> chunks_;
+  base::Vector<T>
+      current_chunk_;        // Block of memory currently being written into.
   int index_;                // Current index in current chunk.
   int size_;                 // Total number of elements in collector.
 
@@ -157,7 +158,7 @@ class Collector {
   // the current index_ value to represent data no longer in the current chunk.
   // Returns the initial index of the new chunk (after copied data).
   virtual void NewChunk(int new_capacity) {
-    Vector<T> new_chunk = Vector<T>::New(new_capacity);
+    base::Vector<T> new_chunk = base::Vector<T>::New(new_capacity);
     if (index_ > 0) {
       chunks_.push_back(current_chunk_.SubVector(0, index_));
     } else {
@@ -191,11 +192,11 @@ class SequenceCollector : public Collector<T, growth_factor, max_growth> {
     sequence_start_ = this->index_;
   }
 
-  Vector<T> EndSequence() {
+  base::Vector<T> EndSequence() {
     DCHECK_NE(sequence_start_, kNoSequence);
     int sequence_start = sequence_start_;
     sequence_start_ = kNoSequence;
-    if (sequence_start == this->index_) return Vector<T>();
+    if (sequence_start == this->index_) return base::Vector<T>();
     return this->current_chunk_.SubVector(sequence_start, this->index_);
   }
 
@@ -225,7 +226,8 @@ class SequenceCollector : public Collector<T, growth_factor, max_growth> {
       return;
     }
     int sequence_length = this->index_ - sequence_start_;
-    Vector<T> new_chunk = Vector<T>::New(sequence_length + new_capacity);
+    base::Vector<T> new_chunk =
+        base::Vector<T>::New(sequence_length + new_capacity);
     DCHECK(sequence_length < new_chunk.length());
     for (int i = 0; i < sequence_length; i++) {
       new_chunk[i] = this->current_chunk_[sequence_start_ + i];
diff --git a/test/cctest/compiler/codegen-tester.cc b/test/cctest/compiler/codegen-tester.cc
index e73a182905..d80803c0ef 100644
--- a/test/cctest/compiler/codegen-tester.cc
+++ b/test/cctest/compiler/codegen-tester.cc
@@ -279,7 +279,7 @@ TEST(CompareWrapper) {
 
 
 void Int32BinopInputShapeTester::TestAllInputShapes() {
-  Vector<const int32_t> inputs = ValueHelper::int32_vector();
+  base::Vector<const int32_t> inputs = ValueHelper::int32_vector();
   int num_int_inputs = static_cast<int>(inputs.size());
   if (num_int_inputs > 16) num_int_inputs = 16;  // limit to 16 inputs
 
diff --git a/test/cctest/compiler/codegen-tester.h b/test/cctest/compiler/codegen-tester.h
index f1e75f8b55..18919b2c30 100644
--- a/test/cctest/compiler/codegen-tester.h
+++ b/test/cctest/compiler/codegen-tester.h
@@ -82,7 +82,8 @@ class RawMachineAssemblerTester : public HandleAndZoneScope,
       Schedule* schedule = this->ExportForTest();
       auto call_descriptor = this->call_descriptor();
       Graph* graph = this->graph();
-      OptimizedCompilationInfo info(ArrayVector("testing"), main_zone(), kind_);
+      OptimizedCompilationInfo info(base::ArrayVector("testing"), main_zone(),
+                                    kind_);
       code_ = Pipeline::GenerateCodeForTesting(
           &info, main_isolate(), call_descriptor, graph,
           AssemblerOptions::Default(main_isolate()), schedule);
diff --git a/test/cctest/compiler/test-code-generator.cc b/test/cctest/compiler/test-code-generator.cc
index 0b85a4e15b..0a2c123ee1 100644
--- a/test/cctest/compiler/test-code-generator.cc
+++ b/test/cctest/compiler/test-code-generator.cc
@@ -971,7 +971,7 @@ class CodeGeneratorTester {
   explicit CodeGeneratorTester(TestEnvironment* environment,
                                int extra_stack_space = 0)
       : zone_(environment->main_zone()),
-        info_(ArrayVector("test"), environment->main_zone(),
+        info_(base::ArrayVector("test"), environment->main_zone(),
               CodeKind::FOR_TESTING),
         linkage_(environment->test_descriptor()),
         frame_(environment->test_descriptor()->CalculateFixedFrameSize(
@@ -1490,8 +1490,8 @@ TEST(Regress_1171759) {
 
   m.Return(m.Int32Constant(0));
 
-  OptimizedCompilationInfo info(ArrayVector("testing"), handles.main_zone(),
-                                CodeKind::WASM_FUNCTION);
+  OptimizedCompilationInfo info(base::ArrayVector("testing"),
+                                handles.main_zone(), CodeKind::WASM_FUNCTION);
   Handle<Code> code =
       Pipeline::GenerateCodeForTesting(
           &info, handles.main_isolate(), desc, m.graph(),
diff --git a/test/cctest/compiler/test-linkage.cc b/test/cctest/compiler/test-linkage.cc
index d07ced6b4a..7157dfdf39 100644
--- a/test/cctest/compiler/test-linkage.cc
+++ b/test/cctest/compiler/test-linkage.cc
@@ -30,7 +30,7 @@ static Operator dummy_operator(IrOpcode::kParameter, Operator::kNoWrite,
 static Handle<JSFunction> Compile(const char* source) {
   Isolate* isolate = CcTest::i_isolate();
   Handle<String> source_code = isolate->factory()
-                                   ->NewStringFromUtf8(CStrVector(source))
+                                   ->NewStringFromUtf8(base::CStrVector(source))
                                    .ToHandleChecked();
   Handle<SharedFunctionInfo> shared =
       Compiler::GetSharedFunctionInfoForScript(
@@ -108,7 +108,7 @@ TEST(TestLinkageStubCall) {
   Isolate* isolate = CcTest::InitIsolateOnce();
   Zone zone(isolate->allocator(), ZONE_NAME);
   Callable callable = Builtins::CallableFor(isolate, Builtin::kToNumber);
-  OptimizedCompilationInfo info(ArrayVector("test"), &zone,
+  OptimizedCompilationInfo info(base::ArrayVector("test"), &zone,
                                 CodeKind::FOR_TESTING);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       &zone, callable.descriptor(), 0, CallDescriptor::kNoFlags,
@@ -130,7 +130,7 @@ TEST(TestFPLinkageStubCall) {
   Zone zone(isolate->allocator(), ZONE_NAME);
   Callable callable =
       Builtins::CallableFor(isolate, Builtin::kWasmFloat64ToNumber);
-  OptimizedCompilationInfo info(ArrayVector("test"), &zone,
+  OptimizedCompilationInfo info(base::ArrayVector("test"), &zone,
                                 CodeKind::FOR_TESTING);
   auto call_descriptor = Linkage::GetStubCallDescriptor(
       &zone, callable.descriptor(), 0, CallDescriptor::kNoFlags,
diff --git a/test/cctest/compiler/test-multiple-return.cc b/test/cctest/compiler/test-multiple-return.cc
index 8693d5fa76..c5ae53a6dd 100644
--- a/test/cctest/compiler/test-multiple-return.cc
+++ b/test/cctest/compiler/test-multiple-return.cc
@@ -160,7 +160,8 @@ void TestReturnMultipleValues(MachineType type, int min_count, int max_count) {
       }
       m.Return(count, returns.get());
 
-      OptimizedCompilationInfo info(ArrayVector("testing"), handles.main_zone(),
+      OptimizedCompilationInfo info(base::ArrayVector("testing"),
+                                    handles.main_zone(),
                                     CodeKind::WASM_FUNCTION);
       Handle<Code> code = Pipeline::GenerateCodeForTesting(
                               &info, handles.main_isolate(), desc, m.graph(),
@@ -272,8 +273,8 @@ void ReturnLastValue(MachineType type) {
 
     m.Return(return_count, returns.get());
 
-    OptimizedCompilationInfo info(ArrayVector("testing"), handles.main_zone(),
-                                  CodeKind::WASM_FUNCTION);
+    OptimizedCompilationInfo info(base::ArrayVector("testing"),
+                                  handles.main_zone(), CodeKind::WASM_FUNCTION);
     Handle<Code> code = Pipeline::GenerateCodeForTesting(
                             &info, handles.main_isolate(), desc, m.graph(),
                             AssemblerOptions::Default(handles.main_isolate()),
@@ -335,8 +336,8 @@ void ReturnSumOfReturns(MachineType type) {
 
     m.Return(return_count, returns.get());
 
-    OptimizedCompilationInfo info(ArrayVector("testing"), handles.main_zone(),
-                                  CodeKind::WASM_FUNCTION);
+    OptimizedCompilationInfo info(base::ArrayVector("testing"),
+                                  handles.main_zone(), CodeKind::WASM_FUNCTION);
     Handle<Code> code = Pipeline::GenerateCodeForTesting(
                             &info, handles.main_isolate(), desc, m.graph(),
                             AssemblerOptions::Default(handles.main_isolate()),
diff --git a/test/cctest/compiler/test-run-bytecode-graph-builder.cc b/test/cctest/compiler/test-run-bytecode-graph-builder.cc
index c8e0c8ecee..0be9306e29 100644
--- a/test/cctest/compiler/test-run-bytecode-graph-builder.cc
+++ b/test/cctest/compiler/test-run-bytecode-graph-builder.cc
@@ -207,7 +207,7 @@ TEST(BytecodeGraphBuilderReturnStatements) {
       {"return NaN;", {factory->nan_value()}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -232,7 +232,7 @@ TEST(BytecodeGraphBuilderPrimitiveExpressions) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -288,7 +288,7 @@ TEST(BytecodeGraphBuilderTwoParameterTests) {
         factory->NewStringFromStaticChars("def")}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1, p2) { %s }\n%s(0, 0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -331,7 +331,7 @@ TEST(BytecodeGraphBuilderNamedLoad) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1) { %s };\n%s(0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -385,7 +385,7 @@ TEST(BytecodeGraphBuilderKeyedLoad) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1, p2) { %s };\n%s(0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -434,7 +434,7 @@ void TestBytecodeGraphBuilderNamedStore(size_t shard) {
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
     if ((i % 2) != shard) continue;
-    ScopedVector<char> script(3072);
+    base::ScopedVector<char> script(3072);
     SNPrintF(script, "function %s(p1) { %s };\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -492,7 +492,7 @@ void TestBytecodeGraphBuilderKeyedStore(size_t shard) {
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
     if ((i % 2) != shard) continue;
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1, p2) { %s };\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -526,7 +526,7 @@ TEST(BytecodeGraphBuilderPropertyCall) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1) { %s };\n%s({func() {}});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -718,7 +718,7 @@ TEST(BytecodeGraphBuilderToName) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -747,7 +747,7 @@ TEST(BytecodeGraphBuilderLogicalNot) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s }\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -782,7 +782,7 @@ TEST(BytecodeGraphBuilderTypeOf) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s }\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -826,7 +826,7 @@ TEST(BytecodeGraphBuilderCompareTypeOf) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s }\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -878,7 +878,7 @@ TEST(BytecodeGraphBuilderCountOperation) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s }\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -915,7 +915,7 @@ TEST(BytecodeGraphBuilderDelete) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s }\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -967,7 +967,7 @@ TEST(BytecodeGraphBuilderDeleteGlobal) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s %s({});", snippets[i].code_snippet, kFunctionName);
 
     BytecodeGraphTester tester(isolate, script.begin());
@@ -1001,7 +1001,7 @@ TEST(BytecodeGraphBuilderDeleteLookupSlot) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s %s %s", function_prologue, snippets[i].code_snippet,
              function_epilogue);
 
@@ -1040,7 +1040,7 @@ TEST(BytecodeGraphBuilderLookupSlot) {
        {factory->NewNumber(23.456)}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s %s %s", function_prologue, snippets[i].code_snippet,
              function_epilogue);
 
@@ -1066,7 +1066,7 @@ TEST(BytecodeGraphBuilderLookupContextSlot) {
       {"'use strict'; eval('var x = 1'); return x;", {factory->NewNumber(0)}}};
 
   for (size_t i = 0; i < arraysize(inner_eval_snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s %s %s } ; %s() ;", kFunctionName,
              inner_eval_prologue, inner_eval_snippets[i].code_snippet,
              inner_eval_epilogue, kFunctionName);
@@ -1088,7 +1088,7 @@ TEST(BytecodeGraphBuilderLookupContextSlot) {
       {"'use strict'; var x = 0; eval('var x = 1');", {factory->NewNumber(0)}}};
 
   for (size_t i = 0; i < arraysize(outer_eval_snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s %s %s } ; %s() ;", kFunctionName,
              outer_eval_prologue, outer_eval_snippets[i].code_snippet,
              outer_eval_epilogue, kFunctionName);
@@ -1115,7 +1115,7 @@ TEST(BytecodeGraphBuilderLookupGlobalSlot) {
       {"'use strict'; eval('var x = 1'); return x;", {factory->NewNumber(0)}}};
 
   for (size_t i = 0; i < arraysize(inner_eval_snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s %s %s } ; %s() ;", kFunctionName,
              inner_eval_prologue, inner_eval_snippets[i].code_snippet,
              inner_eval_epilogue, kFunctionName);
@@ -1137,7 +1137,7 @@ TEST(BytecodeGraphBuilderLookupGlobalSlot) {
       {"'use strict'; x = 0; eval('var x = 1');", {factory->NewNumber(0)}}};
 
   for (size_t i = 0; i < arraysize(outer_eval_snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s %s %s } ; %s() ;", kFunctionName,
              outer_eval_prologue, outer_eval_snippets[i].code_snippet,
              outer_eval_epilogue, kFunctionName);
@@ -1179,7 +1179,7 @@ TEST(BytecodeGraphBuilderLookupSlotWide) {
        {factory->NewNumber(23.456)}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(3072);
+    base::ScopedVector<char> script(3072);
     SNPrintF(script, "%s %s %s", function_prologue, snippets[i].code_snippet,
              function_epilogue);
 
@@ -1207,7 +1207,7 @@ TEST(BytecodeGraphBuilderCallLookupSlot) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
     BytecodeGraphTester tester(isolate, script.begin());
@@ -1257,7 +1257,7 @@ TEST(BytecodeGraphBuilderEval) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
     BytecodeGraphTester tester(isolate, script.begin());
@@ -1283,7 +1283,7 @@ TEST(BytecodeGraphBuilderEvalParams) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s }\n%s(0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
     BytecodeGraphTester tester(isolate, script.begin());
@@ -1384,7 +1384,7 @@ TEST(BytecodeGraphBuilderCompare) {
                                  factory->NewNumberFromInt(SMI_MIN)};
 
   for (size_t i = 0; i < arraysize(kCompareOperators); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1, p2) { %s }\n%s({}, {});", kFunctionName,
              get_code_snippet(kCompareOperators[i]), kFunctionName);
 
@@ -1436,7 +1436,7 @@ TEST(BytecodeGraphBuilderTestIn) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1, p2) { %s }\n%s({}, {});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1466,7 +1466,7 @@ TEST(BytecodeGraphBuilderTestInstanceOf) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s(p1) { %s }\n%s({});", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1495,7 +1495,7 @@ TEST(BytecodeGraphBuilderTryCatch) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1532,7 +1532,7 @@ TEST(BytecodeGraphBuilderTryFinally1) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1555,7 +1555,7 @@ TEST(BytecodeGraphBuilderTryFinally2) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1583,7 +1583,7 @@ TEST(BytecodeGraphBuilderThrow) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1643,7 +1643,7 @@ TEST(BytecodeGraphBuilderContext) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s", snippets[i].code_snippet);
 
     BytecodeGraphTester tester(isolate, script.begin(), "f");
@@ -1706,7 +1706,7 @@ TEST(BytecodeGraphBuilderLoadContext) {
        {factory->NewNumberFromInt(24), factory->NewNumberFromInt(4)}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s", snippets[i].code_snippet);
 
     BytecodeGraphTester tester(isolate, script.begin(), "*");
@@ -1736,7 +1736,7 @@ TEST(BytecodeGraphBuilderCreateArgumentsNoParameters) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s\n%s();", snippets[i].code_snippet, kFunctionName);
 
     BytecodeGraphTester tester(isolate, script.begin());
@@ -1777,7 +1777,7 @@ TEST(BytecodeGraphBuilderCreateArguments) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s\n%s();", snippets[i].code_snippet, kFunctionName);
 
     BytecodeGraphTester tester(isolate, script.begin());
@@ -1819,7 +1819,7 @@ TEST(BytecodeGraphBuilderCreateRestArguments) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s\n%s();", snippets[i].code_snippet, kFunctionName);
 
     BytecodeGraphTester tester(isolate, script.begin());
@@ -1856,7 +1856,7 @@ TEST(BytecodeGraphBuilderRegExpLiterals) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(4096);
+    base::ScopedVector<char> script(4096);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1894,7 +1894,7 @@ TEST(BytecodeGraphBuilderArrayLiterals) {
        {factory->NewStringFromStaticChars("1t")}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(4096);
+    base::ScopedVector<char> script(4096);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -1957,7 +1957,7 @@ TEST(BytecodeGraphBuilderObjectLiterals) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(4096);
+    base::ScopedVector<char> script(4096);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
     BytecodeGraphTester tester(isolate, script.begin());
@@ -2063,7 +2063,7 @@ TEST(BytecodeGraphBuilderIf) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1) { %s };\n%s(0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2092,7 +2092,7 @@ TEST(BytecodeGraphBuilderConditionalOperator) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1) { %s };\n%s(0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2138,7 +2138,7 @@ TEST(BytecodeGraphBuilderSwitch) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1) { %s };\n%s(0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2186,7 +2186,7 @@ TEST(BytecodeGraphBuilderSwitchMerge) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1) { %s };\n%s(0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2244,7 +2244,7 @@ TEST(BytecodeGraphBuilderNestedSwitch) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(2048);
+    base::ScopedVector<char> script(2048);
     SNPrintF(script, "function %s(p1, p2) { %s };\n%s(0, 0);", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2285,7 +2285,7 @@ TEST(BytecodeGraphBuilderBreakableBlocks) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2332,7 +2332,7 @@ TEST(BytecodeGraphBuilderWhile) {
        {factory->NewNumberFromInt(16)}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2379,7 +2379,7 @@ TEST(BytecodeGraphBuilderDo) {
        {factory->NewNumber(3)}}};
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2471,7 +2471,7 @@ TEST(BytecodeGraphBuilderFor) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2541,7 +2541,7 @@ TEST(BytecodeGraphBuilderForIn) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2632,7 +2632,7 @@ TEST(BytecodeGraphBuilderForOf) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2710,7 +2710,7 @@ TEST(BytecodeGraphBuilderWithStatement) {
   };
 
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2756,7 +2756,7 @@ TEST(BytecodeGraphBuilderConstDeclaration) {
 
   // Tests for sloppy mode.
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2768,7 +2768,7 @@ TEST(BytecodeGraphBuilderConstDeclaration) {
 
   // Tests for strict mode.
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() {'use strict'; %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2797,7 +2797,7 @@ TEST(BytecodeGraphBuilderConstDeclarationLookupSlots) {
 
   // Tests for sloppy mode.
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2809,7 +2809,7 @@ TEST(BytecodeGraphBuilderConstDeclarationLookupSlots) {
 
   // Tests for strict mode.
   for (size_t i = 0; i < arraysize(snippets); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() {'use strict'; %s }\n%s();", kFunctionName,
              snippets[i].code_snippet, kFunctionName);
 
@@ -2856,7 +2856,7 @@ TEST(BytecodeGraphBuilderConstInLookupContextChain) {
        {handle(Smi::FromInt(-1), isolate)}}};
 
   for (size_t i = 0; i < arraysize(const_decl); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "%s %s %s", prologue, const_decl[i].code_snippet,
              epilogue);
 
@@ -2888,7 +2888,7 @@ TEST(BytecodeGraphBuilderIllegalConstDeclaration) {
 
   // Tests for sloppy mode.
   for (size_t i = 0; i < arraysize(illegal_const_decl); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() { %s }\n%s();", kFunctionName,
              illegal_const_decl[i].code_snippet, kFunctionName);
 
@@ -2903,7 +2903,7 @@ TEST(BytecodeGraphBuilderIllegalConstDeclaration) {
 
   // Tests for strict mode.
   for (size_t i = 0; i < arraysize(illegal_const_decl); i++) {
-    ScopedVector<char> script(1024);
+    base::ScopedVector<char> script(1024);
     SNPrintF(script, "function %s() {'use strict'; %s }\n%s();", kFunctionName,
              illegal_const_decl[i].code_snippet, kFunctionName);
 
diff --git a/test/cctest/compiler/test-run-native-calls.cc b/test/cctest/compiler/test-run-native-calls.cc
index c103d37aae..f90b86dbf6 100644
--- a/test/cctest/compiler/test-run-native-calls.cc
+++ b/test/cctest/compiler/test-run-native-calls.cc
@@ -245,7 +245,7 @@ class Int32Signature : public MachineSignature {
 Handle<Code> CompileGraph(const char* name, CallDescriptor* call_descriptor,
                           Graph* graph, Schedule* schedule = nullptr) {
   Isolate* isolate = CcTest::InitIsolateOnce();
-  OptimizedCompilationInfo info(ArrayVector("testing"), graph->zone(),
+  OptimizedCompilationInfo info(base::ArrayVector("testing"), graph->zone(),
                                 CodeKind::FOR_TESTING);
   Handle<Code> code = Pipeline::GenerateCodeForTesting(
                           &info, isolate, call_descriptor, graph,
diff --git a/test/cctest/compiler/test-run-variables.cc b/test/cctest/compiler/test-run-variables.cc
index 0097de584b..59137f4fe1 100644
--- a/test/cctest/compiler/test-run-variables.cc
+++ b/test/cctest/compiler/test-run-variables.cc
@@ -57,7 +57,7 @@ static const char* store_tests[] = {
     "'use strict'; let x = (a?4:5); x = a; r = x", "123", "0", nullptr};
 
 static void RunVariableTests(const char* source, const char* tests[]) {
-  EmbeddedVector<char, 512> buffer;
+  base::EmbeddedVector<char, 512> buffer;
 
   for (int i = 0; tests[i] != nullptr; i += 3) {
     SNPrintF(buffer, source, tests[i]);
diff --git a/test/cctest/compiler/value-helper.h b/test/cctest/compiler/value-helper.h
index e395c885ac..c8cd9833ff 100644
--- a/test/cctest/compiler/value-helper.h
+++ b/test/cctest/compiler/value-helper.h
@@ -170,8 +170,8 @@ class ValueHelper {
       std::numeric_limits<float>::quiet_NaN(),
       -std::numeric_limits<float>::quiet_NaN()};
 
-  static constexpr Vector<const float> float32_vector() {
-    return ArrayVector(float32_array);
+  static constexpr base::Vector<const float> float32_vector() {
+    return base::ArrayVector(float32_array);
   }
 
   static constexpr double float64_array[] = {
@@ -225,8 +225,8 @@ class ValueHelper {
       std::numeric_limits<double>::quiet_NaN(),
       -std::numeric_limits<double>::quiet_NaN()};
 
-  static constexpr Vector<const double> float64_vector() {
-    return ArrayVector(float64_array);
+  static constexpr base::Vector<const double> float64_vector() {
+    return base::ArrayVector(float64_array);
   }
 
   static constexpr uint32_t uint32_array[] = {
@@ -244,12 +244,12 @@ class ValueHelper {
       // additional payload.
       0x7FC00000, 0x7F800000, 0x7FFFFFFF, 0x7F876543};
 
-  static constexpr Vector<const uint32_t> uint32_vector() {
-    return ArrayVector(uint32_array);
+  static constexpr base::Vector<const uint32_t> uint32_vector() {
+    return base::ArrayVector(uint32_array);
   }
 
-  static Vector<const int32_t> int32_vector() {
-    return Vector<const int32_t>::cast(uint32_vector());
+  static base::Vector<const int32_t> int32_vector() {
+    return base::Vector<const int32_t>::cast(uint32_vector());
   }
 
   static constexpr uint64_t uint64_array[] = {
@@ -280,80 +280,80 @@ class ValueHelper {
       0x7FF8000000000000, 0x7FF0000000000000, 0x7FF8123456789ABC,
       0x7FF7654321FEDCBA};
 
-  static constexpr Vector<const uint64_t> uint64_vector() {
-    return ArrayVector(uint64_array);
+  static constexpr base::Vector<const uint64_t> uint64_vector() {
+    return base::ArrayVector(uint64_array);
   }
 
-  static Vector<const int64_t> int64_vector() {
-    return Vector<const int64_t>::cast(uint64_vector());
+  static base::Vector<const int64_t> int64_vector() {
+    return base::Vector<const int64_t>::cast(uint64_vector());
   }
 
   static constexpr int16_t int16_array[] = {
       0, 1, 2, INT16_MAX - 1, INT16_MAX, INT16_MIN, INT16_MIN + 1, -2, -1};
 
-  static constexpr Vector<const int16_t> int16_vector() {
-    return ArrayVector(int16_array);
+  static constexpr base::Vector<const int16_t> int16_vector() {
+    return base::ArrayVector(int16_array);
   }
 
-  static Vector<const uint16_t> uint16_vector() {
-    return Vector<const uint16_t>::cast(int16_vector());
+  static base::Vector<const uint16_t> uint16_vector() {
+    return base::Vector<const uint16_t>::cast(int16_vector());
   }
 
   static constexpr int8_t int8_array[] = {
       0, 1, 2, INT8_MAX - 1, INT8_MAX, INT8_MIN, INT8_MIN + 1, -2, -1};
 
-  static constexpr Vector<const int8_t> int8_vector() {
-    return ArrayVector(int8_array);
+  static constexpr base::Vector<const int8_t> int8_vector() {
+    return base::ArrayVector(int8_array);
   }
 
-  static Vector<const uint8_t> uint8_vector() {
-    return Vector<const uint8_t>::cast(ArrayVector(int8_array));
+  static base::Vector<const uint8_t> uint8_vector() {
+    return base::Vector<const uint8_t>::cast(base::ArrayVector(int8_array));
   }
 
   static constexpr uint32_t ror_array[31] = {
       1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31};
 
-  static constexpr Vector<const uint32_t> ror_vector() {
-    return ArrayVector(ror_array);
+  static constexpr base::Vector<const uint32_t> ror_vector() {
+    return base::ArrayVector(ror_array);
   }
 
   template <typename T>
-  static inline Vector<const T> GetVector();
+  static inline base::Vector<const T> GetVector();
 };
 
 template <>
-inline Vector<const int8_t> ValueHelper::GetVector() {
+inline base::Vector<const int8_t> ValueHelper::GetVector() {
   return int8_vector();
 }
 
 template <>
-inline Vector<const uint8_t> ValueHelper::GetVector() {
+inline base::Vector<const uint8_t> ValueHelper::GetVector() {
   return uint8_vector();
 }
 
 template <>
-inline Vector<const int16_t> ValueHelper::GetVector() {
+inline base::Vector<const int16_t> ValueHelper::GetVector() {
   return int16_vector();
 }
 
 template <>
-inline Vector<const uint16_t> ValueHelper::GetVector() {
+inline base::Vector<const uint16_t> ValueHelper::GetVector() {
   return uint16_vector();
 }
 
 template <>
-inline Vector<const int32_t> ValueHelper::GetVector() {
+inline base::Vector<const int32_t> ValueHelper::GetVector() {
   return int32_vector();
 }
 
 template <>
-inline Vector<const uint32_t> ValueHelper::GetVector() {
+inline base::Vector<const uint32_t> ValueHelper::GetVector() {
   return uint32_vector();
 }
 
 template <>
-inline Vector<const int64_t> ValueHelper::GetVector() {
+inline base::Vector<const int64_t> ValueHelper::GetVector() {
   return int64_vector();
 }
 
diff --git a/test/cctest/gay-fixed.cc b/test/cctest/gay-fixed.cc
index 5dae8e5072..fb10779611 100644
--- a/test/cctest/gay-fixed.cc
+++ b/test/cctest/gay-fixed.cc
@@ -100039,12 +100039,11 @@ static const PrecomputedFixed kFixedTestNumbers[] = {
   {1.8209753351049137115478516e+09, 16, "18209753351049137115478516", 10}
 };
 
-
-Vector<const PrecomputedFixed> PrecomputedFixedRepresentations() {
+base::Vector<const PrecomputedFixed> PrecomputedFixedRepresentations() {
   int number_elements = sizeof(kFixedTestNumbers) / sizeof(PrecomputedFixed);
-  return Vector<const PrecomputedFixed>(kFixedTestNumbers, number_elements);
+  return base::Vector<const PrecomputedFixed>(kFixedTestNumbers,
+                                              number_elements);
 }
 
-
 }  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/gay-fixed.h b/test/cctest/gay-fixed.h
index 3219ed3b73..63278f85c0 100644
--- a/test/cctest/gay-fixed.h
+++ b/test/cctest/gay-fixed.h
@@ -28,7 +28,7 @@
 #ifndef GAY_FIXED_H_
 #define GAY_FIXED_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -42,7 +42,7 @@ struct PrecomputedFixed {
 
 // Returns precomputed values of dtoa. The strings have been generated using
 // Gay's dtoa in mode "fixed".
-Vector<const PrecomputedFixed> PrecomputedFixedRepresentations();
+base::Vector<const PrecomputedFixed> PrecomputedFixedRepresentations();
 
 }  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/gay-precision.cc b/test/cctest/gay-precision.cc
index 34615fbda3..4030963135 100644
--- a/test/cctest/gay-precision.cc
+++ b/test/cctest/gay-precision.cc
@@ -100039,12 +100039,11 @@ static const PrecomputedPrecision kPrecisionTestNumbers[] = {
   {5.9485998555293638609297584e+88, 2, "59", 89},
 };
 
-
-Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations() {
+base::Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations() {
   int number_elements =
       sizeof(kPrecisionTestNumbers) / sizeof(PrecomputedPrecision);
-  return Vector<const PrecomputedPrecision>(kPrecisionTestNumbers,
-                                            number_elements);
+  return base::Vector<const PrecomputedPrecision>(kPrecisionTestNumbers,
+                                                  number_elements);
 }
 
 }  // namespace internal
diff --git a/test/cctest/gay-precision.h b/test/cctest/gay-precision.h
index e3dcac6755..5115e3c0b0 100644
--- a/test/cctest/gay-precision.h
+++ b/test/cctest/gay-precision.h
@@ -28,7 +28,7 @@
 #ifndef GAY_PRECISION_H_
 #define GAY_PRECISION_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -42,7 +42,7 @@ struct PrecomputedPrecision {
 
 // Returns precomputed values of dtoa. The strings have been generated using
 // Gay's dtoa in mode "precision".
-Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations();
+base::Vector<const PrecomputedPrecision> PrecomputedPrecisionRepresentations();
 
 }  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/gay-shortest.cc b/test/cctest/gay-shortest.cc
index 53f7fc2741..d6010498dd 100644
--- a/test/cctest/gay-shortest.cc
+++ b/test/cctest/gay-shortest.cc
@@ -100039,12 +100039,11 @@ static const PrecomputedShortest kShortestTestNumbers[] = {
   {8.1205022656023800444116331e-271, "812050226560238", -270}
 };
 
-
-Vector<const PrecomputedShortest> PrecomputedShortestRepresentations() {
+base::Vector<const PrecomputedShortest> PrecomputedShortestRepresentations() {
   int number_elements =
       sizeof(kShortestTestNumbers) / sizeof(PrecomputedShortest);
-  return Vector<const PrecomputedShortest>(kShortestTestNumbers,
-                                           number_elements);
+  return base::Vector<const PrecomputedShortest>(kShortestTestNumbers,
+                                                 number_elements);
 }
 
 }  // namespace internal
diff --git a/test/cctest/gay-shortest.h b/test/cctest/gay-shortest.h
index 0d4efbce47..730e7e0ad0 100644
--- a/test/cctest/gay-shortest.h
+++ b/test/cctest/gay-shortest.h
@@ -28,7 +28,7 @@
 #ifndef GAY_SHORTEST_H_
 #define GAY_SHORTEST_H_
 
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
@@ -39,7 +39,7 @@ struct PrecomputedShortest {
   int decimal_point;
 };
 
-Vector<const PrecomputedShortest> PrecomputedShortestRepresentations();
+base::Vector<const PrecomputedShortest> PrecomputedShortestRepresentations();
 
 }  // namespace internal
 }  // namespace v8
diff --git a/test/cctest/heap/test-compaction.cc b/test/cctest/heap/test-compaction.cc
index cad0d900ae..857238bcee 100644
--- a/test/cctest/heap/test-compaction.cc
+++ b/test/cctest/heap/test-compaction.cc
@@ -466,7 +466,7 @@ HEAP_TEST(CompactionPartiallyAbortedPageWithRememberedSetEntries) {
       // object.
       Address broken_address = holder->address() + 2 * kTaggedSize + 1;
       // Convert it to a vector to create a string from it.
-      Vector<const uint8_t> string_to_broken_addresss(
+      base::Vector<const uint8_t> string_to_broken_addresss(
           reinterpret_cast<const uint8_t*>(&broken_address), kTaggedSize);
 
       Handle<String> string;
diff --git a/test/cctest/heap/test-heap.cc b/test/cctest/heap/test-heap.cc
index a46dbbff12..93ad151cd3 100644
--- a/test/cctest/heap/test-heap.cc
+++ b/test/cctest/heap/test-heap.cc
@@ -159,13 +159,13 @@ static void CheckOddball(Isolate* isolate, Object obj, const char* string) {
   CHECK(obj.IsOddball());
   Handle<Object> handle(obj, isolate);
   Object print_string = *Object::ToString(isolate, handle).ToHandleChecked();
-  CHECK(String::cast(print_string).IsOneByteEqualTo(CStrVector(string)));
+  CHECK(String::cast(print_string).IsOneByteEqualTo(base::CStrVector(string)));
 }
 
 static void CheckSmi(Isolate* isolate, int value, const char* string) {
   Handle<Object> handle(Smi::FromInt(value), isolate);
   Object print_string = *Object::ToString(isolate, handle).ToHandleChecked();
-  CHECK(String::cast(print_string).IsOneByteEqualTo(CStrVector(string)));
+  CHECK(String::cast(print_string).IsOneByteEqualTo(base::CStrVector(string)));
 }
 
 
@@ -174,7 +174,7 @@ static void CheckNumber(Isolate* isolate, double value, const char* string) {
   CHECK(number->IsNumber());
   Handle<Object> print_string =
       Object::ToString(isolate, number).ToHandleChecked();
-  CHECK(String::cast(*print_string).IsOneByteEqualTo(CStrVector(string)));
+  CHECK(String::cast(*print_string).IsOneByteEqualTo(base::CStrVector(string)));
 }
 
 void CheckEmbeddedObjectsAreEqual(Handle<Code> lhs, Handle<Code> rhs) {
@@ -433,7 +433,7 @@ TEST(GarbageCollection) {
 static void VerifyStringAllocation(Isolate* isolate, const char* string) {
   HandleScope scope(isolate);
   Handle<String> s = isolate->factory()
-                         ->NewStringFromUtf8(CStrVector(string))
+                         ->NewStringFromUtf8(base::CStrVector(string))
                          .ToHandleChecked();
   CHECK_EQ(strlen(string), s->length());
   for (int index = 0; index < s->length(); index++) {
@@ -729,15 +729,15 @@ static void CheckInternalizedStrings(const char** strings) {
        string = *strings++) {
     HandleScope scope(isolate);
     Handle<String> a =
-        isolate->factory()->InternalizeUtf8String(CStrVector(string));
+        isolate->factory()->InternalizeUtf8String(base::CStrVector(string));
     // InternalizeUtf8String may return a failure if a GC is needed.
     CHECK(a->IsInternalizedString());
     Handle<String> b = factory->InternalizeUtf8String(string);
     CHECK_EQ(*b, *a);
-    CHECK(b->IsOneByteEqualTo(CStrVector(string)));
-    b = isolate->factory()->InternalizeUtf8String(CStrVector(string));
+    CHECK(b->IsOneByteEqualTo(base::CStrVector(string)));
+    b = isolate->factory()->InternalizeUtf8String(base::CStrVector(string));
     CHECK_EQ(*b, *a);
-    CHECK(b->IsOneByteEqualTo(CStrVector(string)));
+    CHECK(b->IsOneByteEqualTo(base::CStrVector(string)));
   }
 }
 
@@ -1018,18 +1018,20 @@ TEST(StringAllocation) {
       non_one_byte[3 * i + 2] = chars[2];
     }
     Handle<String> non_one_byte_sym = factory->InternalizeUtf8String(
-        Vector<const char>(non_one_byte, 3 * length));
+        base::Vector<const char>(non_one_byte, 3 * length));
     CHECK_EQ(length, non_one_byte_sym->length());
     Handle<String> one_byte_sym =
-        factory->InternalizeString(OneByteVector(one_byte, length));
+        factory->InternalizeString(base::OneByteVector(one_byte, length));
     CHECK_EQ(length, one_byte_sym->length());
     CHECK(one_byte_sym->HasHashCode());
     Handle<String> non_one_byte_str =
-        factory->NewStringFromUtf8(Vector<const char>(non_one_byte, 3 * length))
+        factory
+            ->NewStringFromUtf8(
+                base::Vector<const char>(non_one_byte, 3 * length))
             .ToHandleChecked();
     CHECK_EQ(length, non_one_byte_str->length());
     Handle<String> one_byte_str =
-        factory->NewStringFromUtf8(Vector<const char>(one_byte, length))
+        factory->NewStringFromUtf8(base::Vector<const char>(one_byte, length))
             .ToHandleChecked();
     CHECK_EQ(length, one_byte_str->length());
     DeleteArray(non_one_byte);
@@ -1528,7 +1530,7 @@ TEST(CompilationCacheCachingBehavior) {
 
 static void OptimizeEmptyFunction(const char* name) {
   HandleScope scope(CcTest::i_isolate());
-  EmbeddedVector<char, 256> source;
+  base::EmbeddedVector<char, 256> source;
   SNPrintF(source,
            "function %s() { return 0; }"
            "%%PrepareFunctionForOptimization(%s);"
@@ -2509,7 +2511,7 @@ TEST(OptimizedPretenuringAllocationFolding) {
   v8::Local<v8::Context> ctx = CcTest::isolate()->GetCurrentContext();
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array();"
@@ -2560,7 +2562,7 @@ TEST(OptimizedPretenuringObjectArrayLiterals) {
 
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -2600,7 +2602,7 @@ TEST(OptimizedPretenuringNestedInObjectProperties) {
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
   // Keep the nested literal alive while its root is freed
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "let number_elements = %d;"
               "let elements = new Array(number_elements);"
@@ -2640,7 +2642,7 @@ TEST(OptimizedPretenuringMixedInObjectProperties) {
 
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -2687,7 +2689,7 @@ TEST(OptimizedPretenuringDoubleArrayProperties) {
 
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -2726,7 +2728,7 @@ TEST(OptimizedPretenuringDoubleArrayLiterals) {
 
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -2764,7 +2766,7 @@ TEST(OptimizedPretenuringNestedMixedArrayLiterals) {
   v8::Local<v8::Context> ctx = CcTest::isolate()->GetCurrentContext();
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -2814,7 +2816,7 @@ TEST(OptimizedPretenuringNestedObjectLiterals) {
   v8::Local<v8::Context> ctx = CcTest::isolate()->GetCurrentContext();
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -2864,7 +2866,7 @@ TEST(OptimizedPretenuringNestedDoubleLiterals) {
   v8::Local<v8::Context> ctx = CcTest::isolate()->GetCurrentContext();
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -2960,7 +2962,7 @@ TEST(Regress1465) {
   {
     AlwaysAllocateScopeForTesting always_allocate(CcTest::i_isolate()->heap());
     for (int i = 0; i < transitions_count; i++) {
-      EmbeddedVector<char, 64> buffer;
+      base::EmbeddedVector<char, 64> buffer;
       SNPrintF(buffer, "var o = new F; o.prop%d = %d;", i, i);
       CompileRun(buffer.begin());
     }
@@ -2998,7 +3000,7 @@ static i::Handle<JSObject> GetByName(const char* name) {
 static void AddTransitions(int transitions_count) {
   AlwaysAllocateScopeForTesting always_allocate(CcTest::i_isolate()->heap());
   for (int i = 0; i < transitions_count; i++) {
-    EmbeddedVector<char, 64> buffer;
+    base::EmbeddedVector<char, 64> buffer;
     SNPrintF(buffer, "var o = new F; o.prop%d = %d;", i, i);
     CompileRun(buffer.begin());
   }
@@ -4317,7 +4319,7 @@ TEST(ObjectsInEagerlyDeoptimizedCodeAreWeak) {
 
 static Handle<JSFunction> OptimizeDummyFunction(v8::Isolate* isolate,
                                                 const char* name) {
-  EmbeddedVector<char, 256> source;
+  base::EmbeddedVector<char, 256> source;
   SNPrintF(source,
            "function %s() { return 0; }"
            "%%PrepareFunctionForOptimization(%s);"
diff --git a/test/cctest/parsing/test-preparser.cc b/test/cctest/parsing/test-preparser.cc
index 84e52fb2c7..f4a7fda155 100644
--- a/test/cctest/parsing/test-preparser.cc
+++ b/test/cctest/parsing/test-preparser.cc
@@ -4,13 +4,13 @@
 
 #include "src/api/api-inl.h"
 #include "src/ast/ast.h"
+#include "src/base/vector.h"
 #include "src/codegen/compiler.h"
 #include "src/objects/objects-inl.h"
 #include "src/parsing/parse-info.h"
 #include "src/parsing/parsing.h"
 #include "src/parsing/preparse-data-impl.h"
 #include "src/parsing/preparse-data.h"
-
 #include "test/cctest/cctest.h"
 #include "test/cctest/scope-test-helper.h"
 #include "test/cctest/unicode-helpers.h"
@@ -680,7 +680,7 @@ TEST(PreParserScopeAnalysis) {
       int source_len = Utf8LengthHelper(inner.source);
       int len = code_len + params_len + source_len;
 
-      i::ScopedVector<char> program(len + 1);
+      v8::base::ScopedVector<char> program(len + 1);
       i::SNPrintF(program, code, inner.params, inner.source);
 
       i::HandleScope scope(isolate);
diff --git a/test/cctest/parsing/test-scanner-streams.cc b/test/cctest/parsing/test-scanner-streams.cc
index b7bb1f3b2a..4e3469e93f 100644
--- a/test/cctest/parsing/test-scanner-streams.cc
+++ b/test/cctest/parsing/test-scanner-streams.cc
@@ -492,8 +492,8 @@ void TestCharacterStreams(const char* one_byte_source, unsigned length,
 
   // 2-byte external string
   std::unique_ptr<i::uc16[]> uc16_buffer(new i::uc16[length]);
-  i::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(),
-                                           static_cast<int>(length));
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(),
+                                                  static_cast<int>(length));
   {
     for (unsigned i = 0; i < length; i++) {
       uc16_buffer[i] = static_cast<i::uc16>(one_byte_source[i]);
@@ -512,8 +512,8 @@ void TestCharacterStreams(const char* one_byte_source, unsigned length,
   }
 
   // 1-byte external string
-  i::Vector<const uint8_t> one_byte_vector =
-      i::OneByteVector(one_byte_source, static_cast<int>(length));
+  v8::base::Vector<const uint8_t> one_byte_vector =
+      v8::base::OneByteVector(one_byte_source, static_cast<int>(length));
   i::Handle<i::String> one_byte_string =
       factory->NewStringFromOneByte(one_byte_vector).ToHandleChecked();
   {
@@ -759,7 +759,7 @@ TEST(RelocatingCharacterStream) {
   for (int i = 0; i < length; i++) {
     uc16_buffer[i] = string[i];
   }
-  i::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(), length);
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(), length);
   i::Handle<i::String> two_byte_string =
       i_isolate->factory()
           ->NewStringFromTwoByte(two_byte_vector, i::AllocationType::kYoung)
@@ -792,7 +792,7 @@ TEST(RelocatingUnbufferedCharacterStream) {
   for (int i = 0; i < length; i++) {
     uc16_buffer[i] = string[i];
   }
-  i::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(), length);
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(), length);
   i::Handle<i::String> two_byte_string =
       i_isolate->factory()
           ->NewStringFromTwoByte(two_byte_vector, i::AllocationType::kYoung)
@@ -832,8 +832,8 @@ TEST(CloneCharacterStreams) {
 
   // 2-byte external string
   std::unique_ptr<i::uc16[]> uc16_buffer(new i::uc16[length]);
-  i::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(),
-                                           static_cast<int>(length));
+  v8::base::Vector<const i::uc16> two_byte_vector(uc16_buffer.get(),
+                                                  static_cast<int>(length));
   {
     for (unsigned i = 0; i < length; i++) {
       uc16_buffer[i] = static_cast<i::uc16>(one_byte_source[i]);
@@ -860,8 +860,8 @@ TEST(CloneCharacterStreams) {
   }
 
   // 1-byte external string
-  i::Vector<const uint8_t> one_byte_vector =
-      i::OneByteVector(one_byte_source, static_cast<int>(length));
+  v8::base::Vector<const uint8_t> one_byte_vector =
+      v8::base::OneByteVector(one_byte_source, static_cast<int>(length));
   i::Handle<i::String> one_byte_string =
       factory->NewStringFromOneByte(one_byte_vector).ToHandleChecked();
   {
diff --git a/test/cctest/test-api-array-buffer.cc b/test/cctest/test-api-array-buffer.cc
index 9875098d1f..b0f76c7d1f 100644
--- a/test/cctest/test-api-array-buffer.cc
+++ b/test/cctest/test-api-array-buffer.cc
@@ -25,7 +25,7 @@ void CheckIsDetached(v8::Local<v8::TypedArray> ta) {
 }
 
 void CheckIsTypedArrayVarDetached(const char* name) {
-  i::ScopedVector<char> source(1024);
+  v8::base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "%s.byteLength == 0 && %s.byteOffset == 0 && %s.length == 0",
               name, name, name);
diff --git a/test/cctest/test-api-stack-traces.cc b/test/cctest/test-api-stack-traces.cc
index 6230081404..125fcb2baa 100644
--- a/test/cctest/test-api-stack-traces.cc
+++ b/test/cctest/test-api-stack-traces.cc
@@ -714,7 +714,7 @@ TEST(SourceURLInStackTrace) {
       "}\n"
       "eval('(' + outer +')()%s');";
 
-  i::ScopedVector<char> code(1024);
+  v8::base::ScopedVector<char> code(1024);
   i::SNPrintF(code, source, "//# sourceURL=eval_url");
   CHECK(CompileRun(code.begin())->IsUndefined());
   i::SNPrintF(code, source, "//@ sourceURL=eval_url");
@@ -792,7 +792,7 @@ TEST(InlineScriptWithSourceURLInStackTrace) {
       "}\n"
       "outer()\n%s";
 
-  i::ScopedVector<char> code(1024);
+  v8::base::ScopedVector<char> code(1024);
   i::SNPrintF(code, source, "//# sourceURL=source_url");
   CHECK(CompileRunWithOrigin(code.begin(), "url", 0, 1)->IsUndefined());
   i::SNPrintF(code, source, "//@ sourceURL=source_url");
@@ -836,7 +836,7 @@ TEST(DynamicWithSourceURLInStackTrace) {
       "}\n"
       "outer()\n%s";
 
-  i::ScopedVector<char> code(1024);
+  v8::base::ScopedVector<char> code(1024);
   i::SNPrintF(code, source, "//# sourceURL=source_url");
   CHECK(CompileRunWithOrigin(code.begin(), "url", 0, 0)->IsUndefined());
   i::SNPrintF(code, source, "//@ sourceURL=source_url");
@@ -856,7 +856,7 @@ TEST(DynamicWithSourceURLInStackTraceString) {
       "}\n"
       "outer()\n%s";
 
-  i::ScopedVector<char> code(1024);
+  v8::base::ScopedVector<char> code(1024);
   i::SNPrintF(code, source, "//# sourceURL=source_url");
   v8::TryCatch try_catch(context->GetIsolate());
   CompileRunWithOrigin(code.begin(), "", 0, 0);
diff --git a/test/cctest/test-api-typed-array.cc b/test/cctest/test-api-typed-array.cc
index a35aad8e37..ad5fc11783 100644
--- a/test/cctest/test-api-typed-array.cc
+++ b/test/cctest/test-api-typed-array.cc
@@ -103,7 +103,7 @@ void ObjectWithExternalArrayTestHelper(Local<Context> context,
       "sum;");
   CHECK_EQ(28, result->Int32Value(context).FromJust());
 
-  i::ScopedVector<char> test_buf(1024);
+  v8::base::ScopedVector<char> test_buf(1024);
 
   // Check legal boundary conditions.
   // The repeated loads and stores ensure the ICs are exercised.
@@ -577,7 +577,7 @@ void TestOnHeapHasBuffer(const char* array_name, size_t elem_size) {
   v8::Isolate* isolate = env->GetIsolate();
   v8::HandleScope handle_scope(isolate);
 
-  i::ScopedVector<char> source(128);
+  v8::base::ScopedVector<char> source(128);
   // Test on-heap sizes.
   for (size_t size = 0; size <= i::JSTypedArray::kMaxSizeInHeap;
        size += elem_size) {
@@ -609,7 +609,7 @@ void TestOffHeapHasBuffer(const char* array_name, size_t elem_size) {
   v8::Isolate* isolate = env->GetIsolate();
   v8::HandleScope handle_scope(isolate);
 
-  i::ScopedVector<char> source(128);
+  v8::base::ScopedVector<char> source(128);
   // Test off-heap sizes.
   size_t size = i::JSTypedArray::kMaxSizeInHeap;
   for (int i = 0; i < 3; i++) {
diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
index 18169e5832..23f3af6ff1 100644
--- a/test/cctest/test-api.cc
+++ b/test/cctest/test-api.cc
@@ -214,7 +214,7 @@ THREADED_TEST(IsolateOfContext) {
 
 static void TestSignatureLooped(const char* operation, Local<Value> receiver,
                                 v8::Isolate* isolate) {
-  i::ScopedVector<char> source(200);
+  v8::base::ScopedVector<char> source(200);
   i::SNPrintF(source,
               "for (var i = 0; i < 10; i++) {"
               "  %s"
@@ -240,7 +240,7 @@ static void TestSignatureLooped(const char* operation, Local<Value> receiver,
 
 static void TestSignatureOptimized(const char* operation, Local<Value> receiver,
                                    v8::Isolate* isolate) {
-  i::ScopedVector<char> source(200);
+  v8::base::ScopedVector<char> source(200);
   i::SNPrintF(source,
               "function test() {"
               "  %s"
@@ -363,7 +363,7 @@ THREADED_TEST(ReceiverSignature) {
       "unrelated",    "inherited",        "inherited_direct"};
   unsigned bad_signature_start_offset = 3;
   for (unsigned i = 0; i < arraysize(test_objects); i++) {
-    i::ScopedVector<char> source(200);
+    v8::base::ScopedVector<char> source(200);
     i::SNPrintF(
         source, "var test_object = %s; test_object", test_objects[i]);
     Local<Value> test_object = CompileRun(source.begin());
@@ -2992,7 +2992,7 @@ THREADED_TEST(InternalFieldsOfRegularObjects) {
 
   const char* sources[] = {"new Object()", "{ a: 'a property' }", "arguments"};
   for (size_t i = 0; i < arraysize(sources); ++i) {
-    i::ScopedVector<char> source(128);
+    v8::base::ScopedVector<char> source(128);
     i::SNPrintF(source, "(function() { return %s })()", sources[i]);
     v8::Local<v8::Object> obj = CompileRun(source.begin()).As<v8::Object>();
     CHECK_EQ(0, obj->InternalFieldCount());
@@ -4129,7 +4129,7 @@ class TwoPassCallbackData {
         trigger_gc_(false),
         metadata_(metadata) {
     HandleScope scope(isolate);
-    i::ScopedVector<char> buffer(40);
+    v8::base::ScopedVector<char> buffer(40);
     i::SNPrintF(buffer, "%p", static_cast<void*>(this));
     auto string =
         v8::String::NewFromUtf8(isolate, buffer.begin()).ToLocalChecked();
@@ -4249,7 +4249,7 @@ TEST(TwoPassPhantomCallbacksTriggeredByStringAlloc) {
   data->SetWeak();
   CHECK_EQ(metadata.instance_counter, 1);
 
-  i::ScopedVector<uint8_t> source(200000);
+  v8::base::ScopedVector<uint8_t> source(200000);
   v8::HandleScope handle_scope(isolate);
   // Creating a few large strings suffices to trigger GC.
   while (metadata.instance_counter == 1) {
@@ -7280,7 +7280,7 @@ TEST(ExtensionWithSourceLength) {
   for (int source_len = kEmbeddedExtensionSourceValidLen - 1;
        source_len <= kEmbeddedExtensionSourceValidLen + 1; ++source_len) {
     v8::HandleScope handle_scope(CcTest::isolate());
-    i::ScopedVector<char> extension_name(32);
+    v8::base::ScopedVector<char> extension_name(32);
     i::SNPrintF(extension_name, "ext #%d", source_len);
     v8::RegisterExtension(std::make_unique<Extension>(extension_name.begin(),
                                                       kEmbeddedExtensionSource,
@@ -10939,7 +10939,7 @@ THREADED_TEST(Regress91517) {
   t4->InstanceTemplate()->Set(isolate, "baz", v8_num(4));
 
   // Force dictionary-based properties.
-  i::ScopedVector<char> name_buf(1024);
+  v8::base::ScopedVector<char> name_buf(1024);
   for (int i = 1; i <= 1000; i++) {
     i::SNPrintF(name_buf, "sdf%d", i);
     t2->InstanceTemplate()->Set(v8_str(name_buf.begin()), v8_num(2));
@@ -14739,7 +14739,7 @@ TEST(ObjectClone) {
 
 class OneByteVectorResource : public v8::String::ExternalOneByteStringResource {
  public:
-  explicit OneByteVectorResource(i::Vector<const char> vector)
+  explicit OneByteVectorResource(v8::base::Vector<const char> vector)
       : data_(vector) {}
   ~OneByteVectorResource() override = default;
   size_t length() const override { return data_.length(); }
@@ -14747,13 +14747,13 @@ class OneByteVectorResource : public v8::String::ExternalOneByteStringResource {
   void Dispose() override {}
 
  private:
-  i::Vector<const char> data_;
+  v8::base::Vector<const char> data_;
 };
 
 
 class UC16VectorResource : public v8::String::ExternalStringResource {
  public:
-  explicit UC16VectorResource(i::Vector<const i::uc16> vector)
+  explicit UC16VectorResource(v8::base::Vector<const i::uc16> vector)
       : data_(vector) {}
   ~UC16VectorResource() override = default;
   size_t length() const override { return data_.length(); }
@@ -14761,7 +14761,7 @@ class UC16VectorResource : public v8::String::ExternalStringResource {
   void Dispose() override {}
 
  private:
-  i::Vector<const i::uc16> data_;
+  v8::base::Vector<const i::uc16> data_;
 };
 
 static void MorphAString(i::String string,
@@ -14803,9 +14803,9 @@ THREADED_TEST(MorphCompositeStringTest) {
     i::Isolate* i_isolate = CcTest::i_isolate();
     v8::HandleScope scope(isolate);
     OneByteVectorResource one_byte_resource(
-        i::Vector<const char>(c_string, strlen(c_string)));
+        v8::base::Vector<const char>(c_string, strlen(c_string)));
     UC16VectorResource uc16_resource(
-        i::Vector<const uint16_t>(two_byte_string, strlen(c_string)));
+        v8::base::Vector<const uint16_t>(two_byte_string, strlen(c_string)));
 
     Local<String> lhs(v8::Utils::ToLocal(
         factory->NewExternalStringFromOneByte(&one_byte_resource)
@@ -15595,8 +15595,8 @@ TEST(ErrorLevelWarning) {
                                             v8::Isolate::kMessageAll);
   for (size_t i = 0; i < arraysize(levels); i++) {
     i::MessageLocation location(script, 0, 0);
-    i::Handle<i::String> msg(
-        i_isolate->factory()->InternalizeString(i::StaticCharVector("test")));
+    i::Handle<i::String> msg(i_isolate->factory()->InternalizeString(
+        v8::base::StaticCharVector("test")));
     i::Handle<i::JSMessageObject> message =
         i::MessageHandler::MakeMessageObject(
             i_isolate, i::MessageTemplate::kAsmJsInvalid, &location, msg,
@@ -18618,7 +18618,7 @@ static int CalcFibonacci(v8::Isolate* isolate, int limit) {
   v8::Isolate::Scope isolate_scope(isolate);
   v8::HandleScope scope(isolate);
   LocalContext context(isolate);
-  i::ScopedVector<char> code(1024);
+  v8::base::ScopedVector<char> code(1024);
   i::SNPrintF(code, "function fib(n) {"
                     "  if (n <= 2) return 1;"
                     "  return fib(n-1) + fib(n-2);"
@@ -19928,7 +19928,7 @@ void RecursiveCall(const v8::FunctionCallbackInfo<v8::Value>& args) {
     level++;
     v8::base::OS::Print("Entering recursion level %d.\n", level);
     char script[64];
-    i::Vector<char> script_vector(script, sizeof(script));
+    v8::base::Vector<char> script_vector(script, sizeof(script));
     i::SNPrintF(script_vector, "recursion(%d)", level);
     CompileRun(script_vector.begin());
     v8::base::OS::Print("Leaving recursion level %d.\n", level);
@@ -21381,7 +21381,7 @@ void CheckCorrectThrow(const char* script) {
   // The subsequent try-catch should run without any exception.
   access_check_fail_thrown = false;
   catch_callback_called = false;
-  i::ScopedVector<char> source(1024);
+  v8::base::ScopedVector<char> source(1024);
   i::SNPrintF(source, "try { %s; } catch (e) { catcher(e); }", script);
   CompileRun(source.begin());
   CHECK(access_check_fail_thrown);
@@ -21483,10 +21483,10 @@ const int kSubjectStringLength = arraysize(kOneByteSubjectString) - 1;
 STATIC_ASSERT(arraysize(kOneByteSubjectString) ==
               arraysize(kTwoByteSubjectString));
 
-OneByteVectorResource one_byte_string_resource(
-    i::Vector<const char>(&kOneByteSubjectString[0], kSubjectStringLength));
-UC16VectorResource two_byte_string_resource(
-    i::Vector<const i::uc16>(&kTwoByteSubjectString[0], kSubjectStringLength));
+OneByteVectorResource one_byte_string_resource(v8::base::Vector<const char>(
+    &kOneByteSubjectString[0], kSubjectStringLength));
+UC16VectorResource two_byte_string_resource(v8::base::Vector<const i::uc16>(
+    &kTwoByteSubjectString[0], kSubjectStringLength));
 
 class RegExpInterruptTest {
  public:
@@ -22374,7 +22374,7 @@ class ApiCallOptimizationChecker {
     // With no signature, the holder is not set.
     if (signature_type == kNoSignature) holder = receiver;
     // build wrap_function
-    i::ScopedVector<char> wrap_function(200);
+    v8::base::ScopedVector<char> wrap_function(200);
     if (global) {
       i::SNPrintF(
           wrap_function,
@@ -22391,7 +22391,7 @@ class ApiCallOptimizationChecker {
           key, key, key);
     }
     // build source string
-    i::ScopedVector<char> source(1000);
+    v8::base::ScopedVector<char> source(1000);
     i::SNPrintF(source,
                 "%s\n"  // wrap functions
                 "function wrap_f() { return wrap_f_%d(); }\n"
@@ -25678,7 +25678,7 @@ TEST(ObjectTemplateArrayProtoIntrinsics) {
   };
 
   for (unsigned i = 0; i < arraysize(intrinsics_comparisons); i++) {
-    i::ScopedVector<char> test_string(64);
+    v8::base::ScopedVector<char> test_string(64);
 
     i::SNPrintF(test_string, "typeof obj1.%s",
                 intrinsics_comparisons[i].object_property_name);
diff --git a/test/cctest/test-bignum-dtoa.cc b/test/cctest/test-bignum-dtoa.cc
index e59264b8db..8a4946a280 100644
--- a/test/cctest/test-bignum-dtoa.cc
+++ b/test/cctest/test-bignum-dtoa.cc
@@ -55,7 +55,7 @@ static const int kBufferSize = 100;
 
 TEST(BignumDtoaVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
@@ -253,11 +253,11 @@ TEST(BignumDtoaVariousDoubles) {
 
 TEST(BignumDtoaGayShortest) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
-  Vector<const PrecomputedShortest> precomputed =
+  base::Vector<const PrecomputedShortest> precomputed =
       PrecomputedShortestRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedShortest current_test = precomputed[i];
@@ -271,11 +271,11 @@ TEST(BignumDtoaGayShortest) {
 
 TEST(BignumDtoaGayFixed) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
-  Vector<const PrecomputedFixed> precomputed =
+  base::Vector<const PrecomputedFixed> precomputed =
       PrecomputedFixedRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedFixed current_test = precomputed[i];
@@ -292,11 +292,11 @@ TEST(BignumDtoaGayFixed) {
 
 TEST(BignumDtoaGayPrecision) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
-  Vector<const PrecomputedPrecision> precomputed =
+  base::Vector<const PrecomputedPrecision> precomputed =
       PrecomputedPrecisionRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedPrecision current_test = precomputed[i];
diff --git a/test/cctest/test-bignum.cc b/test/cctest/test-bignum.cc
index 2014f66d65..50a5d041fe 100644
--- a/test/cctest/test-bignum.cc
+++ b/test/cctest/test-bignum.cc
@@ -40,11 +40,11 @@ namespace test_bignum {
 static const int kBufferSize = 1024;
 
 static void AssignHexString(Bignum* bignum, const char* str) {
-  bignum->AssignHexString(CStrVector(str));
+  bignum->AssignHexString(base::CStrVector(str));
 }
 
 static void AssignDecimalString(Bignum* bignum, const char* str) {
-  bignum->AssignDecimalString(CStrVector(str));
+  bignum->AssignDecimalString(base::CStrVector(str));
 }
 
 TEST(Assign) {
diff --git a/test/cctest/test-code-stub-assembler.cc b/test/cctest/test-code-stub-assembler.cc
index ae024dc27b..fda8434257 100644
--- a/test/cctest/test-code-stub-assembler.cc
+++ b/test/cctest/test-code-stub-assembler.cc
@@ -779,7 +779,7 @@ TEST(TryToName) {
     // TryToName(<thin two-byte string>) => internalized version.
     uc16 array1[] = {2001, 2002, 2003};
     Handle<String> s = isolate->factory()
-                           ->NewStringFromTwoByte(ArrayVector(array1))
+                           ->NewStringFromTwoByte(base::ArrayVector(array1))
                            .ToHandleChecked();
     Handle<String> internalized = isolate->factory()->InternalizeString(s);
     ft.CheckTrue(s, expect_unique, internalized);
@@ -2198,7 +2198,7 @@ TEST(OneToTwoByteStringCopy) {
   Handle<String> string1 = isolate->factory()->InternalizeUtf8String("abcde");
   uc16 array[] = {1000, 1001, 1002, 1003, 1004};
   Handle<String> string2 = isolate->factory()
-                               ->NewStringFromTwoByte(ArrayVector(array))
+                               ->NewStringFromTwoByte(base::ArrayVector(array))
                                .ToHandleChecked();
   FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
   ft.Call(string1, string2);
@@ -2231,7 +2231,7 @@ TEST(OneToOneByteStringCopy) {
   Handle<String> string1 = isolate->factory()->InternalizeUtf8String("abcde");
   uint8_t array[] = {100, 101, 102, 103, 104};
   Handle<String> string2 = isolate->factory()
-                               ->NewStringFromOneByte(ArrayVector(array))
+                               ->NewStringFromOneByte(base::ArrayVector(array))
                                .ToHandleChecked();
   FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
   ft.Call(string1, string2);
@@ -2264,7 +2264,7 @@ TEST(OneToOneByteStringCopyNonZeroStart) {
   Handle<String> string1 = isolate->factory()->InternalizeUtf8String("abcde");
   uint8_t array[] = {100, 101, 102, 103, 104};
   Handle<String> string2 = isolate->factory()
-                               ->NewStringFromOneByte(ArrayVector(array))
+                               ->NewStringFromOneByte(base::ArrayVector(array))
                                .ToHandleChecked();
   FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
   ft.Call(string1, string2);
@@ -2293,11 +2293,11 @@ TEST(TwoToTwoByteStringCopy) {
 
   uc16 array1[] = {2000, 2001, 2002, 2003, 2004};
   Handle<String> string1 = isolate->factory()
-                               ->NewStringFromTwoByte(ArrayVector(array1))
+                               ->NewStringFromTwoByte(base::ArrayVector(array1))
                                .ToHandleChecked();
   uc16 array2[] = {1000, 1001, 1002, 1003, 1004};
   Handle<String> string2 = isolate->factory()
-                               ->NewStringFromTwoByte(ArrayVector(array2))
+                               ->NewStringFromTwoByte(base::ArrayVector(array2))
                                .ToHandleChecked();
   FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
   ft.Call(string1, string2);
diff --git a/test/cctest/test-compiler.cc b/test/cctest/test-compiler.cc
index d044c7c405..702046ade6 100644
--- a/test/cctest/test-compiler.cc
+++ b/test/cctest/test-compiler.cc
@@ -67,8 +67,9 @@ static void SetGlobalProperty(const char* name, Object value) {
 
 static Handle<JSFunction> Compile(const char* source) {
   Isolate* isolate = CcTest::i_isolate();
-  Handle<String> source_code = isolate->factory()->NewStringFromUtf8(
-      CStrVector(source)).ToHandleChecked();
+  Handle<String> source_code = isolate->factory()
+                                   ->NewStringFromUtf8(base::CStrVector(source))
+                                   .ToHandleChecked();
   Handle<SharedFunctionInfo> shared =
       Compiler::GetSharedFunctionInfoForScript(
           isolate, source_code, Compiler::ScriptDetails(),
@@ -83,7 +84,7 @@ static Handle<JSFunction> Compile(const char* source) {
 
 static double Inc(Isolate* isolate, int x) {
   const char* source = "result = %d + 1;";
-  EmbeddedVector<char, 512> buffer;
+  base::EmbeddedVector<char, 512> buffer;
   SNPrintF(buffer, source, x);
 
   Handle<JSFunction> fun = Compile(buffer.begin());
@@ -247,7 +248,7 @@ TEST(C2JSFrames) {
   CHECK(fun1->IsJSFunction());
 
   Handle<Object> argv[] = {
-      isolate->factory()->InternalizeString(StaticCharVector("hello"))};
+      isolate->factory()->InternalizeString(base::StaticCharVector("hello"))};
   Execution::Call(isolate,
                   Handle<JSFunction>::cast(fun1),
                   global,
@@ -280,7 +281,7 @@ TEST(GetScriptLineNumber) {
   const char function_f[] = "function f() {}";
   const int max_rows = 1000;
   const int buffer_size = max_rows + sizeof(function_f);
-  ScopedVector<char> buffer(buffer_size);
+  base::ScopedVector<char> buffer(buffer_size);
   memset(buffer.begin(), '\n', buffer_size - 1);
   buffer[buffer_size - 1] = '\0';
 
diff --git a/test/cctest/test-cpu-profiler.cc b/test/cctest/test-cpu-profiler.cc
index f0a6a06079..94542387cf 100644
--- a/test/cctest/test-cpu-profiler.cc
+++ b/test/cctest/test-cpu-profiler.cc
@@ -138,8 +138,8 @@ class TestSetup {
 
 i::AbstractCode CreateCode(i::Isolate* isolate, LocalContext* env) {
   static int counter = 0;
-  i::EmbeddedVector<char, 256> script;
-  i::EmbeddedVector<char, 32> name;
+  base::EmbeddedVector<char, 256> script;
+  base::EmbeddedVector<char, 32> name;
 
   i::SNPrintF(name, "function_%d", ++counter);
   const char* name_start = name.begin();
@@ -1225,9 +1225,9 @@ static void TickLines(bool optimize) {
   i::Factory* factory = isolate->factory();
   i::HandleScope scope(isolate);
 
-  i::EmbeddedVector<char, 512> script;
-  i::EmbeddedVector<char, 64> prepare_opt;
-  i::EmbeddedVector<char, 64> optimize_call;
+  base::EmbeddedVector<char, 512> script;
+  base::EmbeddedVector<char, 64> prepare_opt;
+  base::EmbeddedVector<char, 64> optimize_call;
 
   const char* func_name = "func";
   if (optimize) {
@@ -1328,7 +1328,7 @@ static void TickLines(bool optimize) {
 
   unsigned int line_count = func_node->GetHitLineCount();
   CHECK_EQ(2u, line_count);  // Expect two hit source lines - #1 and #5.
-  ScopedVector<v8::CpuProfileNode::LineTick> entries(line_count);
+  base::ScopedVector<v8::CpuProfileNode::LineTick> entries(line_count);
   CHECK(func_node->GetLineTicks(&entries[0], line_count));
   int value = 0;
   for (int i = 0; i < entries.length(); i++)
@@ -2481,7 +2481,7 @@ TEST(CollectDeoptEvents) {
       "\n";
 
   for (int i = 0; i < 3; ++i) {
-    i::EmbeddedVector<char, sizeof(opt_source) + 100> buffer;
+    base::EmbeddedVector<char, sizeof(opt_source) + 100> buffer;
     i::SNPrintF(buffer, opt_source, i, i);
     v8::Script::Compile(env, v8_str(buffer.begin()))
         .ToLocalChecked()
diff --git a/test/cctest/test-debug.cc b/test/cctest/test-debug.cc
index c83c6a64ce..d48d6cf925 100644
--- a/test/cctest/test-debug.cc
+++ b/test/cctest/test-debug.cc
@@ -3256,7 +3256,7 @@ class EmptyExternalStringResource : public v8::String::ExternalStringResource {
   const uint16_t* data() const override { return empty_.begin(); }
 
  private:
-  ::v8::internal::EmbeddedVector<uint16_t, 1> empty_;
+  ::v8::base::EmbeddedVector<uint16_t, 1> empty_;
 };
 
 TEST(DebugScriptLineEndsAreAscending) {
@@ -3694,9 +3694,9 @@ static void TestDebugBreakInLoop(const char* loop_head,
     // Perform a lazy deoptimization after various numbers of breaks
     // have been hit.
 
-    i::EmbeddedVector<char, 1024> buffer;
-    SNPrintF(buffer, "function f() {%s%s%s}", loop_head, loop_bodies[i],
-             loop_tail);
+    v8::base::EmbeddedVector<char, 1024> buffer;
+    i::SNPrintF(buffer, "function f() {%s%s%s}", loop_head, loop_bodies[i],
+                loop_tail);
 
     i::PrintF("%s\n", buffer.begin());
 
diff --git a/test/cctest/test-deoptimization.cc b/test/cctest/test-deoptimization.cc
index 7861537d11..ea2a4d827f 100644
--- a/test/cctest/test-deoptimization.cc
+++ b/test/cctest/test-deoptimization.cc
@@ -38,9 +38,9 @@
 #include "src/objects/objects-inl.h"
 #include "test/cctest/cctest.h"
 
+using ::v8::base::EmbeddedVector;
 using ::v8::base::OS;
 using ::v8::internal::Deoptimizer;
-using ::v8::internal::EmbeddedVector;
 using ::v8::internal::Handle;
 using ::v8::internal::JSFunction;
 
@@ -478,10 +478,9 @@ static void CompileConstructorWithDeoptimizingValueOf() {
 static void TestDeoptimizeBinaryOpHelper(LocalContext* env,
                                          const char* binary_op) {
   i::Isolate* i_isolate = reinterpret_cast<i::Isolate*>((*env)->GetIsolate());
-  EmbeddedVector<char, SMALL_STRING_BUFFER_SIZE> f_source_buffer;
-  SNPrintF(f_source_buffer,
-           "function f(x, y) { return x %s y; };",
-           binary_op);
+  v8::base::EmbeddedVector<char, SMALL_STRING_BUFFER_SIZE> f_source_buffer;
+  i::SNPrintF(f_source_buffer, "function f(x, y) { return x %s y; };",
+              binary_op);
   char* f_source = f_source_buffer.begin();
 
   AllowNativesSyntaxNoInlining options;
diff --git a/test/cctest/test-descriptor-array.cc b/test/cctest/test-descriptor-array.cc
index 1d933d2190..2e265fcf2a 100644
--- a/test/cctest/test-descriptor-array.cc
+++ b/test/cctest/test-descriptor-array.cc
@@ -35,7 +35,7 @@ Handle<Name> NewNameWithHash(Isolate* isolate, const char* str, uint32_t hash,
     hash_field |= Name::kIsNotIntegerIndexMask;
   }
   Handle<Name> name = isolate->factory()->NewOneByteInternalizedString(
-      OneByteVector(str), hash_field);
+      base::OneByteVector(str), hash_field);
   name->set_raw_hash_field(hash_field);
   CHECK(name->IsUniqueName());
   return name;
diff --git a/test/cctest/test-disasm-arm.cc b/test/cctest/test-disasm-arm.cc
index 71cc19704a..07a12f3500 100644
--- a/test/cctest/test-disasm-arm.cc
+++ b/test/cctest/test-disasm-arm.cc
@@ -55,7 +55,7 @@ bool DisassembleAndCompare(byte* begin, UseRegex use_regex,
                            S... expected_strings) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
-  EmbeddedVector<char, 128> buffer;
+  base::EmbeddedVector<char, 128> buffer;
 
   std::vector<std::string> expected_disassembly = {expected_strings...};
   size_t n_expected = expected_disassembly.size();
diff --git a/test/cctest/test-disasm-mips.cc b/test/cctest/test-disasm-mips.cc
index 929e4e4777..ae949e3813 100644
--- a/test/cctest/test-disasm-mips.cc
+++ b/test/cctest/test-disasm-mips.cc
@@ -45,7 +45,7 @@ bool prev_instr_compact_branch = false;
 bool DisassembleAndCompare(byte* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
-  EmbeddedVector<char, 128> disasm_buffer;
+  base::EmbeddedVector<char, 128> disasm_buffer;
 
   if (prev_instr_compact_branch) {
     disasm.InstructionDecode(disasm_buffer, pc);
diff --git a/test/cctest/test-disasm-mips64.cc b/test/cctest/test-disasm-mips64.cc
index 4e6324589d..f79b151c6e 100644
--- a/test/cctest/test-disasm-mips64.cc
+++ b/test/cctest/test-disasm-mips64.cc
@@ -45,7 +45,7 @@ bool prev_instr_compact_branch = false;
 bool DisassembleAndCompare(byte* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
-  EmbeddedVector<char, 128> disasm_buffer;
+  base::EmbeddedVector<char, 128> disasm_buffer;
 
   if (prev_instr_compact_branch) {
     disasm.InstructionDecode(disasm_buffer, pc);
diff --git a/test/cctest/test-disasm-ppc.cc b/test/cctest/test-disasm-ppc.cc
index f28ebf4dac..f746016177 100644
--- a/test/cctest/test-disasm-ppc.cc
+++ b/test/cctest/test-disasm-ppc.cc
@@ -43,7 +43,7 @@ namespace internal {
 bool DisassembleAndCompare(byte* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
-  EmbeddedVector<char, 128> disasm_buffer;
+  base::EmbeddedVector<char, 128> disasm_buffer;
 
   disasm.InstructionDecode(disasm_buffer, pc);
 
diff --git a/test/cctest/test-disasm-riscv64.cc b/test/cctest/test-disasm-riscv64.cc
index b798556e46..01f2888fb3 100644
--- a/test/cctest/test-disasm-riscv64.cc
+++ b/test/cctest/test-disasm-riscv64.cc
@@ -44,7 +44,7 @@ bool prev_instr_compact_branch = false;
 bool DisassembleAndCompare(byte* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
-  EmbeddedVector<char, 128> disasm_buffer;
+  base::EmbeddedVector<char, 128> disasm_buffer;
 
   if (prev_instr_compact_branch) {
     disasm.InstructionDecode(disasm_buffer, pc);
diff --git a/test/cctest/test-disasm-s390.cc b/test/cctest/test-disasm-s390.cc
index a01760b6ba..f44b3e1599 100644
--- a/test/cctest/test-disasm-s390.cc
+++ b/test/cctest/test-disasm-s390.cc
@@ -43,7 +43,7 @@ namespace internal {
 bool DisassembleAndCompare(byte* pc, const char* compare_string) {
   disasm::NameConverter converter;
   disasm::Disassembler disasm(converter);
-  EmbeddedVector<char, 128> disasm_buffer;
+  base::EmbeddedVector<char, 128> disasm_buffer;
 
   disasm.InstructionDecode(disasm_buffer, pc);
 
diff --git a/test/cctest/test-dtoa.cc b/test/cctest/test-dtoa.cc
index d1d7fe1e8a..5d2679f4f9 100644
--- a/test/cctest/test-dtoa.cc
+++ b/test/cctest/test-dtoa.cc
@@ -55,7 +55,7 @@ static const int kBufferSize = 100;
 
 TEST(DtoaVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
   int sign;
@@ -263,12 +263,12 @@ TEST(DtoaVariousDoubles) {
 
 TEST(DtoaGayShortest) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int sign;
   int length;
   int point;
 
-  Vector<const PrecomputedShortest> precomputed =
+  base::Vector<const PrecomputedShortest> precomputed =
       PrecomputedShortestRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedShortest current_test = precomputed[i];
@@ -283,12 +283,12 @@ TEST(DtoaGayShortest) {
 
 TEST(DtoaGayFixed) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int sign;
   int length;
   int point;
 
-  Vector<const PrecomputedFixed> precomputed =
+  base::Vector<const PrecomputedFixed> precomputed =
       PrecomputedFixedRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedFixed current_test = precomputed[i];
@@ -306,12 +306,12 @@ TEST(DtoaGayFixed) {
 
 TEST(DtoaGayPrecision) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int sign;
   int length;
   int point;
 
-  Vector<const PrecomputedPrecision> precomputed =
+  base::Vector<const PrecomputedPrecision> precomputed =
       PrecomputedPrecisionRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedPrecision current_test = precomputed[i];
diff --git a/test/cctest/test-fast-dtoa.cc b/test/cctest/test-fast-dtoa.cc
index ac617a3c11..13dd67c1d2 100644
--- a/test/cctest/test-fast-dtoa.cc
+++ b/test/cctest/test-fast-dtoa.cc
@@ -53,7 +53,7 @@ static void TrimRepresentation(char* representation) {
 
 TEST(FastDtoaShortestVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
   int status;
@@ -123,7 +123,7 @@ TEST(FastDtoaShortestVariousDoubles) {
 
 TEST(FastDtoaPrecisionVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
   int status;
@@ -224,7 +224,7 @@ TEST(FastDtoaPrecisionVariousDoubles) {
 
 TEST(FastDtoaGayShortest) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   bool status;
   int length;
   int point;
@@ -232,7 +232,7 @@ TEST(FastDtoaGayShortest) {
   int total = 0;
   bool needed_max_length = false;
 
-  Vector<const PrecomputedShortest> precomputed =
+  base::Vector<const PrecomputedShortest> precomputed =
       PrecomputedShortestRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedShortest current_test = precomputed[i];
@@ -253,7 +253,7 @@ TEST(FastDtoaGayShortest) {
 
 TEST(FastDtoaGayPrecision) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   bool status;
   int length;
   int point;
@@ -263,7 +263,7 @@ TEST(FastDtoaGayPrecision) {
   int succeeded_15 = 0;
   int total_15 = 0;
 
-  Vector<const PrecomputedPrecision> precomputed =
+  base::Vector<const PrecomputedPrecision> precomputed =
       PrecomputedPrecisionRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedPrecision current_test = precomputed[i];
diff --git a/test/cctest/test-fixed-dtoa.cc b/test/cctest/test-fixed-dtoa.cc
index 62629c4e8f..e50f5a29ae 100644
--- a/test/cctest/test-fixed-dtoa.cc
+++ b/test/cctest/test-fixed-dtoa.cc
@@ -42,7 +42,7 @@ static const int kBufferSize = 500;
 
 TEST(FastFixedVariousDoubles) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   int length;
   int point;
 
@@ -492,12 +492,12 @@ TEST(FastFixedVariousDoubles) {
 
 TEST(FastFixedDtoaGayFixed) {
   char buffer_container[kBufferSize];
-  Vector<char> buffer(buffer_container, kBufferSize);
+  base::Vector<char> buffer(buffer_container, kBufferSize);
   bool status;
   int length;
   int point;
 
-  Vector<const PrecomputedFixed> precomputed =
+  base::Vector<const PrecomputedFixed> precomputed =
       PrecomputedFixedRepresentations();
   for (int i = 0; i < precomputed.length(); ++i) {
     const PrecomputedFixed current_test = precomputed[i];
diff --git a/test/cctest/test-func-name-inference.cc b/test/cctest/test-func-name-inference.cc
index 2331c61bc6..410556093a 100644
--- a/test/cctest/test-func-name-inference.cc
+++ b/test/cctest/test-func-name-inference.cc
@@ -35,15 +35,14 @@
 #include "src/strings/string-search.h"
 #include "test/cctest/cctest.h"
 
-
-using ::v8::internal::CStrVector;
+using ::v8::base::CStrVector;
+using ::v8::base::Vector;
 using ::v8::internal::Factory;
 using ::v8::internal::Handle;
 using ::v8::internal::Heap;
 using ::v8::internal::JSFunction;
 using ::v8::internal::Runtime;
 using ::v8::internal::SharedFunctionInfo;
-using ::v8::internal::Vector;
 
 
 static void CheckFunctionName(v8::Local<v8::Script> script,
@@ -70,7 +69,8 @@ static void CheckFunctionName(v8::Local<v8::Script> script,
   int func_pos;
   {
     i::DisallowGarbageCollection no_gc;
-    Vector<const uint8_t> func_pos_str = i::OneByteVector(func_pos_src);
+    v8::base::Vector<const uint8_t> func_pos_str =
+        v8::base::OneByteVector(func_pos_src);
     i::String::FlatContent script_content = script_src->GetFlatContent(no_gc);
     func_pos = SearchString(isolate, script_content.ToOneByteVector(),
                             func_pos_str, 0);
diff --git a/test/cctest/test-heap-profiler.cc b/test/cctest/test-heap-profiler.cc
index 1cc9640644..d53cc74a19 100644
--- a/test/cctest/test-heap-profiler.cc
+++ b/test/cctest/test-heap-profiler.cc
@@ -51,10 +51,10 @@
 using i::AllocationTraceNode;
 using i::AllocationTraceTree;
 using i::AllocationTracker;
-using i::ArrayVector;
 using i::SourceLocation;
-using i::Vector;
+using v8::base::ArrayVector;
 using v8::base::Optional;
+using v8::base::Vector;
 using v8::internal::heap::GrowNewSpaceToMaximumCapacity;
 
 namespace {
@@ -200,7 +200,7 @@ static bool HasString(v8::Isolate* isolate, const v8::HeapGraphNode* node,
 static void EnsureNoUninstrumentedInternals(v8::Isolate* isolate,
                                             const v8::HeapGraphNode* node) {
   for (int i = 0; i < 20; ++i) {
-    i::ScopedVector<char> buffer(10);
+    v8::base::ScopedVector<char> buffer(10);
     const v8::HeapGraphNode* internal =
         GetProperty(isolate, node, v8::HeapGraphEdge::kInternal,
                     i::IntToCString(i, buffer));
@@ -1055,14 +1055,14 @@ class TestJSONStream : public v8::OutputStream {
     if (abort_countdown_ > 0) --abort_countdown_;
     if (abort_countdown_ == 0) return kAbort;
     CHECK_GT(chars_written, 0);
-    i::Vector<char> chunk = buffer_.AddBlock(chars_written, '\0');
+    v8::base::Vector<char> chunk = buffer_.AddBlock(chars_written, '\0');
     i::MemCopy(chunk.begin(), buffer, chars_written);
     return kContinue;
   }
   virtual WriteResult WriteUint32Chunk(uint32_t* buffer, int chars_written) {
     UNREACHABLE();
   }
-  void WriteTo(i::Vector<char> dest) { buffer_.WriteTo(dest); }
+  void WriteTo(v8::base::Vector<char> dest) { buffer_.WriteTo(dest); }
   int eos_signaled() { return eos_signaled_; }
   int size() { return buffer_.size(); }
 
@@ -1074,7 +1074,8 @@ class TestJSONStream : public v8::OutputStream {
 
 class OneByteResource : public v8::String::ExternalOneByteStringResource {
  public:
-  explicit OneByteResource(i::Vector<char> string) : data_(string.begin()) {
+  explicit OneByteResource(v8::base::Vector<char> string)
+      : data_(string.begin()) {
     length_ = string.length();
   }
   const char* data() const override { return data_; }
@@ -1107,7 +1108,7 @@ TEST(HeapSnapshotJSONSerialization) {
   snapshot->Serialize(&stream, v8::HeapSnapshot::kJSON);
   CHECK_GT(stream.size(), 0);
   CHECK_EQ(1, stream.eos_signaled());
-  i::ScopedVector<char> json(stream.size());
+  v8::base::ScopedVector<char> json(stream.size());
   stream.WriteTo(json);
 
   // Verify that snapshot string is valid JSON.
@@ -2622,7 +2623,7 @@ TEST(ManyLocalsInSharedContext) {
   // Check all the objects have got their names.
   // ... well check just every 15th because otherwise it's too slow in debug.
   for (int i = 0; i < num_objects - 1; i += 15) {
-    i::EmbeddedVector<char, 100> var_name;
+    v8::base::EmbeddedVector<char, 100> var_name;
     i::SNPrintF(var_name, "f_%d", i);
     const v8::HeapGraphNode* f_object =
         GetProperty(env->GetIsolate(), context_object,
@@ -2727,7 +2728,7 @@ static const v8::HeapGraphNode* GetNodeByPath(v8::Isolate* isolate,
       const v8::HeapGraphNode* to_node = edge->GetToNode();
       v8::String::Utf8Value edge_name(isolate, edge->GetName());
       v8::String::Utf8Value node_name(isolate, to_node->GetName());
-      i::EmbeddedVector<char, 100> name;
+      v8::base::EmbeddedVector<char, 100> name;
       i::SNPrintF(name, "%s::%s", *edge_name, *node_name);
       if (strstr(name.begin(), path[current_depth])) {
         node = to_node;
@@ -2805,9 +2806,8 @@ static const char* record_trace_tree_source =
 "\n"
 "for (var i = 0; i < 100; i++) start();\n";
 
-
 static AllocationTraceNode* FindNode(
-    AllocationTracker* tracker, const Vector<const char*>& names) {
+    AllocationTracker* tracker, const v8::base::Vector<const char*>& names) {
   AllocationTraceNode* node = tracker->trace_tree()->root();
   for (int i = 0; node != nullptr && i < names.length(); i++) {
     const char* name = names[i];
@@ -2826,7 +2826,6 @@ static AllocationTraceNode* FindNode(
   return node;
 }
 
-
 TEST(ArrayGrowLeftTrim) {
   LocalContext env;
   v8::HandleScope scope(env->GetIsolate());
@@ -2849,7 +2848,7 @@ TEST(ArrayGrowLeftTrim) {
   // Print for better diagnostics in case of failure.
   tracker->trace_tree()->Print(tracker);
 
-  AllocationTraceNode* node = FindNode(tracker, ArrayVector(names));
+  AllocationTraceNode* node = FindNode(tracker, v8::base::ArrayVector(names));
   CHECK(node);
   CHECK_GE(node->allocation_count(), 2u);
   CHECK_GE(node->allocation_size(), 4u * 5u);
@@ -2874,7 +2873,7 @@ TEST(TrackHeapAllocationsWithInlining) {
   tracker->trace_tree()->Print(tracker);
 
   const char* names[] = {"", "start", "f_0_0"};
-  AllocationTraceNode* node = FindNode(tracker, ArrayVector(names));
+  AllocationTraceNode* node = FindNode(tracker, v8::base::ArrayVector(names));
   CHECK(node);
   // In lite mode, there is feedback and feedback metadata.
   unsigned int num_nodes = (i::FLAG_lite_mode) ? 6 : 8;
@@ -2908,7 +2907,7 @@ TEST(TrackHeapAllocationsWithoutInlining) {
   tracker->trace_tree()->Print(tracker);
 
   const char* names[] = {"", "start", "f_0_0", "f_0_1", "f_0_2"};
-  AllocationTraceNode* node = FindNode(tracker, ArrayVector(names));
+  AllocationTraceNode* node = FindNode(tracker, v8::base::ArrayVector(names));
   CHECK(node);
   CHECK_GE(node->allocation_count(), 100u);
   CHECK_GE(node->allocation_size(), 4 * node->allocation_count());
@@ -2957,7 +2956,7 @@ TEST(TrackBumpPointerAllocations) {
     // Print for better diagnostics in case of failure.
     tracker->trace_tree()->Print(tracker);
 
-    AllocationTraceNode* node = FindNode(tracker, ArrayVector(names));
+    AllocationTraceNode* node = FindNode(tracker, v8::base::ArrayVector(names));
     CHECK(node);
     CHECK_GE(node->allocation_count(), 100u);
     CHECK_GE(node->allocation_size(), 4 * node->allocation_count());
@@ -2982,7 +2981,7 @@ TEST(TrackBumpPointerAllocations) {
     // Print for better diagnostics in case of failure.
     tracker->trace_tree()->Print(tracker);
 
-    AllocationTraceNode* node = FindNode(tracker, ArrayVector(names));
+    AllocationTraceNode* node = FindNode(tracker, v8::base::ArrayVector(names));
     CHECK(node);
     CHECK_LT(node->allocation_count(), 100u);
 
@@ -3011,7 +3010,7 @@ TEST(TrackV8ApiAllocation) {
   // Print for better diagnostics in case of failure.
   tracker->trace_tree()->Print(tracker);
 
-  AllocationTraceNode* node = FindNode(tracker, ArrayVector(names));
+  AllocationTraceNode* node = FindNode(tracker, v8::base::ArrayVector(names));
   CHECK(node);
   CHECK_GE(node->allocation_count(), 2u);
   CHECK_GE(node->allocation_size(), 4 * node->allocation_count());
@@ -3610,7 +3609,7 @@ TEST(AddressToTraceMap) {
 
 static const v8::AllocationProfile::Node* FindAllocationProfileNode(
     v8::Isolate* isolate, v8::AllocationProfile* profile,
-    const Vector<const char*>& names) {
+    const v8::base::Vector<const char*>& names) {
   v8::AllocationProfile::Node* node = profile->GetRootNode();
   for (int i = 0; node != nullptr && i < names.length(); ++i) {
     const char* name = names[i];
@@ -3682,7 +3681,7 @@ TEST(SamplingHeapProfiler) {
 
     const char* names[] = {"", "foo", "bar"};
     auto node_bar = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                              ArrayVector(names));
+                                              v8::base::ArrayVector(names));
     CHECK(node_bar);
 
     heap_profiler->StopSamplingHeapProfiler();
@@ -3706,12 +3705,12 @@ TEST(SamplingHeapProfiler) {
 
     const char* names1[] = {"", "start", "f_0_0", "f_0_1", "f_0_2"};
     auto node1 = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                           ArrayVector(names1));
+                                           v8::base::ArrayVector(names1));
     CHECK(node1);
 
     const char* names2[] = {"", "generateFunctions"};
     auto node2 = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                           ArrayVector(names2));
+                                           v8::base::ArrayVector(names2));
     CHECK(node2);
 
     heap_profiler->StopSamplingHeapProfiler();
@@ -3768,12 +3767,12 @@ TEST(SamplingHeapProfilerRateAgnosticEstimates) {
     CHECK(profile);
 
     const char* path_to_foo[] = {"", "foo"};
-    auto node_foo = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                              ArrayVector(path_to_foo));
+    auto node_foo = FindAllocationProfileNode(
+        env->GetIsolate(), profile.get(), v8::base::ArrayVector(path_to_foo));
     CHECK(node_foo);
     const char* path_to_bar[] = {"", "foo", "bar"};
-    auto node_bar = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                              ArrayVector(path_to_bar));
+    auto node_bar = FindAllocationProfileNode(
+        env->GetIsolate(), profile.get(), v8::base::ArrayVector(path_to_bar));
     CHECK(node_bar);
 
     // Function bar can be inlined in foo.
@@ -3792,12 +3791,12 @@ TEST(SamplingHeapProfilerRateAgnosticEstimates) {
     CHECK(profile);
 
     const char* path_to_foo[] = {"", "foo"};
-    auto node_foo = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                              ArrayVector(path_to_foo));
+    auto node_foo = FindAllocationProfileNode(
+        env->GetIsolate(), profile.get(), v8::base::ArrayVector(path_to_foo));
     CHECK(node_foo);
     const char* path_to_bar[] = {"", "foo", "bar"};
-    auto node_bar = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                              ArrayVector(path_to_bar));
+    auto node_bar = FindAllocationProfileNode(
+        env->GetIsolate(), profile.get(), v8::base::ArrayVector(path_to_bar));
     CHECK(node_bar);
 
     // Function bar can be inlined in foo.
@@ -3836,7 +3835,7 @@ TEST(SamplingHeapProfilerApiAllocation) {
   CHECK(profile);
   const char* names[] = {"(V8 API)"};
   auto node = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                        ArrayVector(names));
+                                        v8::base::ArrayVector(names));
   CHECK(node);
 
   heap_profiler->StopSamplingHeapProfiler();
@@ -3933,7 +3932,7 @@ TEST(SamplingHeapProfilerPretenuredInlineAllocations) {
 
   GrowNewSpaceToMaximumCapacity(CcTest::heap());
 
-  i::ScopedVector<char> source(1024);
+  v8::base::ScopedVector<char> source(1024);
   i::SNPrintF(source,
               "var number_elements = %d;"
               "var elements = new Array(number_elements);"
@@ -3974,7 +3973,7 @@ TEST(SamplingHeapProfilerPretenuredInlineAllocations) {
 
   const char* names[] = {"f"};
   auto node_f = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                          ArrayVector(names));
+                                          v8::base::ArrayVector(names));
   CHECK(node_f);
 
   int count = 0;
@@ -4004,7 +4003,7 @@ TEST(SamplingHeapProfilerLargeInterval) {
   CHECK(profile);
   const char* names[] = {"(EXTERNAL)"};
   auto node = FindAllocationProfileNode(env->GetIsolate(), profile.get(),
-                                        ArrayVector(names));
+                                        v8::base::ArrayVector(names));
   CHECK(node);
 
   heap_profiler->StopSamplingHeapProfiler();
diff --git a/test/cctest/test-js-to-wasm.cc b/test/cctest/test-js-to-wasm.cc
index 21cfa77b21..ce4eac0cfe 100644
--- a/test/cctest/test-js-to-wasm.cc
+++ b/test/cctest/test-js-to-wasm.cc
@@ -272,7 +272,8 @@ class FastJSWasmCallTester {
 
   void DeclareCallback(const char* name, FunctionSig* signature,
                        const char* module) {
-    builder_->AddImport(CStrVector(name), signature, CStrVector(module));
+    builder_->AddImport(base::CStrVector(name), signature,
+                        base::CStrVector(module));
   }
 
   void AddExportedFunction(const ExportedFunction& exported_func) {
@@ -281,7 +282,7 @@ class FastJSWasmCallTester {
     func->EmitCode(exported_func.code.data(),
                    static_cast<uint32_t>(exported_func.code.size()));
     func->Emit(kExprEnd);
-    builder_->AddExport(CStrVector(exported_func.name.c_str()),
+    builder_->AddExport(base::CStrVector(exported_func.name.c_str()),
                         kExternalFunction, func->func_index());
 
     // JS-to-Wasm inlining is disabled when targeting 32 bits if the Wasm
diff --git a/test/cctest/test-log-stack-tracer.cc b/test/cctest/test-log-stack-tracer.cc
index 61e9a2b965..c9c5971d9b 100644
--- a/test/cctest/test-log-stack-tracer.cc
+++ b/test/cctest/test-log-stack-tracer.cc
@@ -120,7 +120,7 @@ void CreateFramePointerGrabberConstructor(v8::Local<v8::Context> context,
 static void CreateTraceCallerFunction(v8::Local<v8::Context> context,
                                       const char* func_name,
                                       const char* trace_func_name) {
-  i::EmbeddedVector<char, 256> trace_call_buf;
+  v8::base::EmbeddedVector<char, 256> trace_call_buf;
   i::SNPrintF(trace_call_buf,
               "function %s() {"
               "  fp = new FPGrabber();"
diff --git a/test/cctest/test-log.cc b/test/cctest/test-log.cc
index dcbb486927..c54768679b 100644
--- a/test/cctest/test-log.cc
+++ b/test/cctest/test-log.cc
@@ -42,8 +42,8 @@
 #include "src/utils/version.h"
 #include "test/cctest/cctest.h"
 
+using v8::base::EmbeddedVector;
 using v8::internal::Address;
-using v8::internal::EmbeddedVector;
 using v8::internal::Logger;
 
 namespace {
@@ -276,13 +276,15 @@ namespace {
 class SimpleExternalString : public v8::String::ExternalStringResource {
  public:
   explicit SimpleExternalString(const char* source)
-      : utf_source_(i::OwnedVector<uint16_t>::Of(i::CStrVector(source))) {}
+      : utf_source_(
+            v8::base::OwnedVector<uint16_t>::Of(v8::base::CStrVector(source))) {
+  }
   ~SimpleExternalString() override = default;
   size_t length() const override { return utf_source_.size(); }
   const uint16_t* data() const override { return utf_source_.begin(); }
 
  private:
-  i::OwnedVector<uint16_t> utf_source_;
+  v8::base::OwnedVector<uint16_t> utf_source_;
 };
 
 }  // namespace
@@ -348,7 +350,7 @@ UNINITIALIZED_TEST(LogCallbacks) {
 #if USES_FUNCTION_DESCRIPTORS
     ObjMethod1_entry = *FUNCTION_ENTRYPOINT_ADDRESS(ObjMethod1_entry);
 #endif
-    i::EmbeddedVector<char, 100> suffix_buffer;
+    v8::base::EmbeddedVector<char, 100> suffix_buffer;
     i::SNPrintF(suffix_buffer, ",0x%" V8PRIxPTR ",1,method1", ObjMethod1_entry);
     CHECK(logger.ContainsLine(
         {"code-creation,Callback,-2,", std::string(suffix_buffer.begin())}));
@@ -392,7 +394,7 @@ UNINITIALIZED_TEST(LogAccessorCallbacks) {
 #if USES_FUNCTION_DESCRIPTORS
     Prop1Getter_entry = *FUNCTION_ENTRYPOINT_ADDRESS(Prop1Getter_entry);
 #endif
-    EmbeddedVector<char, 100> prop1_getter_record;
+    v8::base::EmbeddedVector<char, 100> prop1_getter_record;
     i::SNPrintF(prop1_getter_record, ",0x%" V8PRIxPTR ",1,get prop1",
                 Prop1Getter_entry);
     CHECK(logger.ContainsLine({"code-creation,Callback,-2,",
@@ -402,7 +404,7 @@ UNINITIALIZED_TEST(LogAccessorCallbacks) {
 #if USES_FUNCTION_DESCRIPTORS
     Prop1Setter_entry = *FUNCTION_ENTRYPOINT_ADDRESS(Prop1Setter_entry);
 #endif
-    EmbeddedVector<char, 100> prop1_setter_record;
+    v8::base::EmbeddedVector<char, 100> prop1_setter_record;
     i::SNPrintF(prop1_setter_record, ",0x%" V8PRIxPTR ",1,set prop1",
                 Prop1Setter_entry);
     CHECK(logger.ContainsLine({"code-creation,Callback,-2,",
@@ -412,7 +414,7 @@ UNINITIALIZED_TEST(LogAccessorCallbacks) {
 #if USES_FUNCTION_DESCRIPTORS
     Prop2Getter_entry = *FUNCTION_ENTRYPOINT_ADDRESS(Prop2Getter_entry);
 #endif
-    EmbeddedVector<char, 100> prop2_getter_record;
+    v8::base::EmbeddedVector<char, 100> prop2_getter_record;
     i::SNPrintF(prop2_getter_record, ",0x%" V8PRIxPTR ",1,get prop2",
                 Prop2Getter_entry);
     CHECK(logger.ContainsLine({"code-creation,Callback,-2,",
@@ -430,7 +432,7 @@ UNINITIALIZED_TEST(LogVersion) {
     ScopedLoggerInitializer logger(isolate);
     logger.StopLogging();
 
-    i::EmbeddedVector<char, 100> line_buffer;
+    v8::base::EmbeddedVector<char, 100> line_buffer;
     i::SNPrintF(line_buffer, "%d,%d,%d,%d,%d", i::Version::GetMajor(),
                 i::Version::GetMinor(), i::Version::GetBuild(),
                 i::Version::GetPatch(), i::Version::IsCandidate());
@@ -1189,7 +1191,7 @@ UNINITIALIZED_TEST(BuiltinsNotLoggedAsLazyCompile) {
 
     i::Handle<i::Code> builtin = logger.i_isolate()->builtins()->code_handle(
         i::Builtin::kBooleanConstructor);
-    i::EmbeddedVector<char, 100> buffer;
+    v8::base::EmbeddedVector<char, 100> buffer;
 
     // Should only be logged as "Builtin" with a name, never as "LazyCompile".
     i::SNPrintF(buffer, ",0x%" V8PRIxPTR ",%d,BooleanConstructor",
diff --git a/test/cctest/test-object.cc b/test/cctest/test-object.cc
index 33acd05c15..36cbfd3b3a 100644
--- a/test/cctest/test-object.cc
+++ b/test/cctest/test-object.cc
@@ -20,7 +20,7 @@ static void CheckObject(Isolate* isolate, Handle<Object> obj,
   Handle<String> print_string = String::Flatten(
       isolate,
       Handle<String>::cast(Object::NoSideEffectsToString(isolate, obj)));
-  CHECK(print_string->IsOneByteEqualTo(CStrVector(string)));
+  CHECK(print_string->IsOneByteEqualTo(base::CStrVector(string)));
 }
 
 static void CheckSmi(Isolate* isolate, int value, const char* string) {
diff --git a/test/cctest/test-parsing.cc b/test/cctest/test-parsing.cc
index 2d56b72a8f..71874c1f59 100644
--- a/test/cctest/test-parsing.cc
+++ b/test/cctest/test-parsing.cc
@@ -981,7 +981,7 @@ void TestScanRegExp(const char* re_source, const char* expected) {
   i::DisallowGarbageCollection no_alloc;
   i::String::FlatContent content = val->GetFlatContent(no_alloc);
   CHECK(content.IsOneByte());
-  i::Vector<const uint8_t> actual = content.ToOneByteVector();
+  base::Vector<const uint8_t> actual = content.ToOneByteVector();
   for (int i = 0; i < actual.length(); i++) {
     CHECK_NE('\0', expected[i]);
     CHECK_EQ(expected[i], actual[i]);
@@ -1118,11 +1118,11 @@ TEST(ScopeUsesArgumentsSuperThis) {
       int kProgramByteSize = static_cast<int>(strlen(surroundings[j].prefix) +
                                               strlen(surroundings[j].suffix) +
                                               strlen(source_data[i].body));
-      i::ScopedVector<char> program(kProgramByteSize + 1);
+      base::ScopedVector<char> program(kProgramByteSize + 1);
       i::SNPrintF(program, "%s%s%s", surroundings[j].prefix,
                   source_data[i].body, surroundings[j].suffix);
       i::Handle<i::String> source =
-          factory->NewStringFromUtf8(i::CStrVector(program.begin()))
+          factory->NewStringFromUtf8(base::CStrVector(program.begin()))
               .ToHandleChecked();
       i::Handle<i::Script> script = factory->NewScript(source);
       i::UnoptimizedCompileState compile_state(isolate);
@@ -1185,7 +1185,7 @@ static void CheckParsesToNumber(const char* source) {
   full_source += "; }";
 
   i::Handle<i::String> source_code =
-      factory->NewStringFromUtf8(i::CStrVector(full_source.c_str()))
+      factory->NewStringFromUtf8(base::CStrVector(full_source.c_str()))
           .ToHandleChecked();
 
   i::Handle<i::Script> script = factory->NewScript(source_code);
@@ -1491,7 +1491,7 @@ TEST(ScopePositions) {
     int kSuffixByteLen = static_cast<int>(strlen(source_data[i].outer_suffix));
     int kProgramSize = kPrefixLen + kInnerLen + kSuffixLen;
     int kProgramByteSize = kPrefixByteLen + kInnerByteLen + kSuffixByteLen;
-    i::ScopedVector<char> program(kProgramByteSize + 1);
+    base::ScopedVector<char> program(kProgramByteSize + 1);
     i::SNPrintF(program, "%s%s%s",
                          source_data[i].outer_prefix,
                          source_data[i].inner_source,
@@ -1499,7 +1499,7 @@ TEST(ScopePositions) {
 
     // Parse program source.
     i::Handle<i::String> source =
-        factory->NewStringFromUtf8(i::CStrVector(program.begin()))
+        factory->NewStringFromUtf8(base::CStrVector(program.begin()))
             .ToHandleChecked();
     CHECK_EQ(source->length(), kProgramSize);
     i::Handle<i::Script> script = factory->NewScript(source);
@@ -1550,7 +1550,7 @@ TEST(DiscardFunctionBody) {
   for (int i = 0; discard_sources[i]; i++) {
     const char* source = discard_sources[i];
     i::Handle<i::String> source_code =
-        factory->NewStringFromUtf8(i::CStrVector(source)).ToHandleChecked();
+        factory->NewStringFromUtf8(base::CStrVector(source)).ToHandleChecked();
     i::Handle<i::Script> script = factory->NewScript(source_code);
     i::UnoptimizedCompileState compile_state(isolate);
     i::UnoptimizedCompileFlags flags =
@@ -1768,7 +1768,7 @@ void TestParserSync(const char* source, const ParserFlag* varying_flags,
   i::Handle<i::String> str =
       CcTest::i_isolate()
           ->factory()
-          ->NewStringFromUtf8(Vector<const char>(source, strlen(source)))
+          ->NewStringFromUtf8(base::Vector<const char>(source, strlen(source)))
           .ToHandleChecked();
   for (int bits = 0; bits < (1 << varying_flags_length); bits++) {
     base::EnumSet<ParserFlag> flags;
@@ -1842,7 +1842,7 @@ TEST(ParserSync) {
                            static_cast<int>(strlen("label: for (;;) {  }"));
 
         // Plug the source code pieces together.
-        i::ScopedVector<char> program(kProgramSize + 1);
+        base::ScopedVector<char> program(kProgramSize + 1);
         int length = i::SNPrintF(program,
             "label: for (;;) { %s%s%s%s }",
             context_data[i][0],
@@ -1942,7 +1942,7 @@ void RunParserSyncTest(
       int kProgramSize = kPrefixLen + kStatementLen + kSuffixLen;
 
       // Plug the source code pieces together.
-      i::ScopedVector<char> program(kProgramSize + 1);
+      base::ScopedVector<char> program(kProgramSize + 1);
       int length = i::SNPrintF(program,
                                "%s%s%s",
                                context_data[i][0],
@@ -3341,7 +3341,7 @@ TEST(SerializationOfMaybeAssignmentFlag) {
       "};"
       "h();";
 
-  i::ScopedVector<char> program(Utf8LengthHelper(src) + 1);
+  base::ScopedVector<char> program(Utf8LengthHelper(src) + 1);
   i::SNPrintF(program, "%s", src);
   i::Handle<i::String> source = factory->InternalizeUtf8String(program.begin());
   source->PrintOn(stdout);
@@ -3391,7 +3391,7 @@ TEST(IfArgumentsArrayAccessedThenParametersMaybeAssigned) {
       "  }"
       "f(0);";
 
-  i::ScopedVector<char> program(Utf8LengthHelper(src) + 1);
+  base::ScopedVector<char> program(Utf8LengthHelper(src) + 1);
   i::SNPrintF(program, "%s", src);
   i::Handle<i::String> source = factory->InternalizeUtf8String(program.begin());
   source->PrintOn(stdout);
@@ -3547,7 +3547,7 @@ TEST(InnerAssignment) {
         int inner_len = Utf8LengthHelper(inner);
 
         int len = prefix_len + outer_len + midfix_len + inner_len + suffix_len;
-        i::ScopedVector<char> program(len + 1);
+        base::ScopedVector<char> program(len + 1);
 
         i::SNPrintF(program, "%s%s%s%s%s", prefix, outer, midfix, inner,
                     suffix);
@@ -3670,8 +3670,8 @@ TEST(MaybeAssignedParameters) {
     bool assigned = tests[i].arg_assigned;
     const char* source = tests[i].source;
     for (unsigned allow_lazy = 0; allow_lazy < 2; ++allow_lazy) {
-      i::ScopedVector<char> program(Utf8LengthHelper(source) +
-                                    Utf8LengthHelper(suffix) + 1);
+      base::ScopedVector<char> program(Utf8LengthHelper(source) +
+                                       Utf8LengthHelper(suffix) + 1);
       i::SNPrintF(program, "%s%s", source, suffix);
       std::unique_ptr<i::ParseInfo> info;
       printf("%s\n", program.begin());
@@ -11490,7 +11490,7 @@ TEST(NoPessimisticContextAllocation) {
       int len = prefix_len + inner_function_len + params_len + source_len +
                 suffix_len;
 
-      i::ScopedVector<char> program(len + 1);
+      base::ScopedVector<char> program(len + 1);
       i::SNPrintF(program, "%s", prefix);
       i::SNPrintF(program + prefix_len, inner_function, inners[i].params,
                   inners[i].source);
@@ -12063,7 +12063,7 @@ TEST(LexicalLoopVariable) {
   auto TestProgram = [isolate](const char* program, TestCB test) {
     i::Factory* const factory = isolate->factory();
     i::Handle<i::String> source =
-        factory->NewStringFromUtf8(i::CStrVector(program)).ToHandleChecked();
+        factory->NewStringFromUtf8(base::CStrVector(program)).ToHandleChecked();
     i::Handle<i::Script> script = factory->NewScript(source);
     i::UnoptimizedCompileState compile_state(isolate);
     i::UnoptimizedCompileFlags flags =
diff --git a/test/cctest/test-profile-generator.cc b/test/cctest/test-profile-generator.cc
index aec85635b5..c53631f53b 100644
--- a/test/cctest/test-profile-generator.cc
+++ b/test/cctest/test-profile-generator.cc
@@ -723,10 +723,10 @@ TEST(Issue51919) {
   CpuProfilesCollection collection(CcTest::i_isolate());
   CpuProfiler profiler(CcTest::i_isolate());
   collection.set_cpu_profiler(&profiler);
-  i::EmbeddedVector<char*,
-      CpuProfilesCollection::kMaxSimultaneousProfiles> titles;
+  base::EmbeddedVector<char*, CpuProfilesCollection::kMaxSimultaneousProfiles>
+      titles;
   for (int i = 0; i < CpuProfilesCollection::kMaxSimultaneousProfiles; ++i) {
-    i::Vector<char> title = i::Vector<char>::New(16);
+    base::Vector<char> title = v8::base::Vector<char>::New(16);
     i::SNPrintF(title, "%d", i);
     CHECK_EQ(CpuProfilingStatus::kStarted,
              collection.StartProfiling(title.begin()));
diff --git a/test/cctest/test-regexp.cc b/test/cctest/test-regexp.cc
index 8862580fb0..be9607da0c 100644
--- a/test/cctest/test-regexp.cc
+++ b/test/cctest/test-regexp.cc
@@ -543,10 +543,11 @@ static RegExpNode* Compile(const char* input, bool multiline, bool unicode,
                                                &compile_data))
     return nullptr;
   Handle<String> pattern = isolate->factory()
-                               ->NewStringFromUtf8(CStrVector(input))
+                               ->NewStringFromUtf8(base::CStrVector(input))
                                .ToHandleChecked();
-  Handle<String> sample_subject =
-      isolate->factory()->NewStringFromUtf8(CStrVector("")).ToHandleChecked();
+  Handle<String> sample_subject = isolate->factory()
+                                      ->NewStringFromUtf8(base::CStrVector(""))
+                                      .ToHandleChecked();
   RegExp::CompileForTesting(isolate, zone, &compile_data, flags, pattern,
                             sample_subject, is_one_byte);
   return compile_data.node;
@@ -788,7 +789,7 @@ TEST(MacroAssemblerNativeSimpleUC16) {
   const uc16 input_data[6] = {'f', 'o', 'o',
                               'f', 'o', static_cast<uc16>(0x2603)};
   Handle<String> input =
-      factory->NewStringFromTwoByte(Vector<const uc16>(input_data, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(input_data, 6))
           .ToHandleChecked();
   Handle<SeqTwoByteString> seq_input = Handle<SeqTwoByteString>::cast(input);
   Address start_adr = seq_input->GetCharsAddress();
@@ -804,8 +805,9 @@ TEST(MacroAssemblerNativeSimpleUC16) {
 
   const uc16 input_data2[9] = {
       'b', 'a', 'r', 'b', 'a', 'r', 'b', 'a', static_cast<uc16>(0x2603)};
-  input = factory->NewStringFromTwoByte(Vector<const uc16>(input_data2, 9))
-              .ToHandleChecked();
+  input =
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(input_data2, 9))
+          .ToHandleChecked();
   seq_input = Handle<SeqTwoByteString>::cast(input);
   start_adr = seq_input->GetCharsAddress();
 
@@ -928,7 +930,7 @@ TEST(MacroAssemblerNativeBackReferenceUC16) {
 
   const uc16 input_data[6] = {'f', 0x2028, 'o', 'o', 'f', 0x2028};
   Handle<String> input =
-      factory->NewStringFromTwoByte(Vector<const uc16>(input_data, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(input_data, 6))
           .ToHandleChecked();
   Handle<SeqTwoByteString> seq_input = Handle<SeqTwoByteString>::cast(input);
   Address start_adr = seq_input->GetCharsAddress();
@@ -1059,7 +1061,7 @@ TEST(MacroAssemblerNativeRegisters) {
                              6);
 
   uc16 foo_chars[3] = {'f', 'o', 'o'};
-  Vector<const uc16> foo(foo_chars, 3);
+  base::Vector<const uc16> foo(foo_chars, 3);
 
   enum registers { out1, out2, out3, out4, out5, out6, sp, loop_cnt };
   Label fail;
@@ -1269,7 +1271,7 @@ TEST(MacroAssembler) {
 
   const uc16 str1[] = {'f', 'o', 'o', 'b', 'a', 'r'};
   Handle<String> f1_16 =
-      factory->NewStringFromTwoByte(Vector<const uc16>(str1, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(str1, 6))
           .ToHandleChecked();
 
   CHECK_EQ(IrregexpInterpreter::SUCCESS,
@@ -1284,7 +1286,7 @@ TEST(MacroAssembler) {
 
   const uc16 str2[] = {'b', 'a', 'r', 'f', 'o', 'o'};
   Handle<String> f2_16 =
-      factory->NewStringFromTwoByte(Vector<const uc16>(str2, 6))
+      factory->NewStringFromTwoByte(base::Vector<const uc16>(str2, 6))
           .ToHandleChecked();
 
   std::memset(captures, 0, sizeof(captures));
@@ -1395,7 +1397,7 @@ TEST(UncanonicalizeEquivalence) {
 #endif
 
 static void TestRangeCaseIndependence(Isolate* isolate, CharacterRange input,
-                                      Vector<CharacterRange> expected) {
+                                      base::Vector<CharacterRange> expected) {
   Zone zone(CcTest::i_isolate()->allocator(), ZONE_NAME);
   int count = expected.length();
   ZoneList<CharacterRange>* list =
@@ -1413,7 +1415,7 @@ static void TestRangeCaseIndependence(Isolate* isolate, CharacterRange input,
 static void TestSimpleRangeCaseIndependence(Isolate* isolate,
                                             CharacterRange input,
                                             CharacterRange expected) {
-  EmbeddedVector<CharacterRange, 1> vector;
+  base::EmbeddedVector<CharacterRange, 1> vector;
   vector[0] = expected;
   TestRangeCaseIndependence(isolate, input, vector);
 }
diff --git a/test/cctest/test-sampler-api.cc b/test/cctest/test-sampler-api.cc
index 179caa86cd..2e9a069d3f 100644
--- a/test/cctest/test-sampler-api.cc
+++ b/test/cctest/test-sampler-api.cc
@@ -23,10 +23,10 @@ class Sample {
   const_iterator end() const { return &data_[data_.length()]; }
 
   int size() const { return data_.length(); }
-  v8::internal::Vector<void*>& data() { return data_; }
+  v8::base::Vector<void*>& data() { return data_; }
 
  private:
-  v8::internal::EmbeddedVector<void*, kFramesLimit> data_;
+  v8::base::EmbeddedVector<void*, kFramesLimit> data_;
 };
 
 
diff --git a/test/cctest/test-serialize.cc b/test/cctest/test-serialize.cc
index 5fbc9600e1..1abdfa10e9 100644
--- a/test/cctest/test-serialize.cc
+++ b/test/cctest/test-serialize.cc
@@ -75,8 +75,8 @@ void DisableAlwaysOpt() {
 // A convenience struct to simplify management of the blobs required to
 // deserialize an isolate.
 struct StartupBlobs {
-  Vector<const byte> startup;
-  Vector<const byte> read_only;
+  base::Vector<const byte> startup;
+  base::Vector<const byte> read_only;
 
   void Dispose() {
     startup.Dispose();
@@ -135,11 +135,12 @@ class TestSerializer {
   }
 };
 
-static Vector<const byte> WritePayload(const Vector<const byte>& payload) {
+static base::Vector<const byte> WritePayload(
+    const base::Vector<const byte>& payload) {
   int length = payload.length();
   byte* blob = NewArray<byte>(length);
   memcpy(blob, payload.begin(), length);
-  return Vector<const byte>(const_cast<const byte*>(blob), length);
+  return base::Vector<const byte>(const_cast<const byte*>(blob), length);
 }
 
 namespace {
@@ -189,9 +190,10 @@ static StartupBlobs Serialize(v8::Isolate* isolate) {
           WritePayload(read_only_snapshot.RawData())};
 }
 
-Vector<const char> ConstructSource(Vector<const char> head,
-                                   Vector<const char> body,
-                                   Vector<const char> tail, int repeats) {
+base::Vector<const char> ConstructSource(base::Vector<const char> head,
+                                         base::Vector<const char> body,
+                                         base::Vector<const char> tail,
+                                         int repeats) {
   size_t source_length = head.size() + body.size() * repeats + tail.size();
   char* source = NewArray<char>(source_length);
   CopyChars(source, head.begin(), head.length());
@@ -201,7 +203,7 @@ Vector<const char> ConstructSource(Vector<const char> head,
   }
   CopyChars(source + head.length() + repeats * body.length(), tail.begin(),
             tail.length());
-  return VectorOf(source, source_length);
+  return base::VectorOf(source, source_length);
 }
 
 static v8::Isolate* Deserialize(const StartupBlobs& blobs) {
@@ -218,7 +220,7 @@ static void SanityCheck(v8::Isolate* v8_isolate) {
 #endif
   CHECK(isolate->global_object()->IsJSObject());
   CHECK(isolate->native_context()->IsContext());
-  isolate->factory()->InternalizeString(StaticCharVector("Empty"));
+  isolate->factory()->InternalizeString(base::StaticCharVector("Empty"));
 }
 
 void TestStartupSerializerOnceImpl() {
@@ -319,9 +321,9 @@ UNINITIALIZED_TEST(StartupSerializerTwiceRunScript) {
   FreeCurrentEmbeddedBlob();
 }
 
-static void SerializeContext(Vector<const byte>* startup_blob_out,
-                             Vector<const byte>* read_only_blob_out,
-                             Vector<const byte>* context_blob_out) {
+static void SerializeContext(base::Vector<const byte>* startup_blob_out,
+                             base::Vector<const byte>* read_only_blob_out,
+                             base::Vector<const byte>* context_blob_out) {
   v8::Isolate* v8_isolate = TestSerializer::NewIsolateInitialized();
   Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);
   Heap* heap = isolate->heap();
@@ -389,9 +391,9 @@ static void SerializeContext(Vector<const byte>* startup_blob_out,
 
 UNINITIALIZED_TEST(SnapshotCompression) {
   DisableAlwaysOpt();
-  Vector<const byte> startup_blob;
-  Vector<const byte> read_only_blob;
-  Vector<const byte> context_blob;
+  base::Vector<const byte> startup_blob;
+  base::Vector<const byte> read_only_blob;
+  base::Vector<const byte> context_blob;
   SerializeContext(&startup_blob, &read_only_blob, &context_blob);
   SnapshotData original_snapshot_data(context_blob);
   SnapshotData compressed =
@@ -407,9 +409,9 @@ UNINITIALIZED_TEST(SnapshotCompression) {
 
 UNINITIALIZED_TEST(ContextSerializerContext) {
   DisableAlwaysOpt();
-  Vector<const byte> startup_blob;
-  Vector<const byte> read_only_blob;
-  Vector<const byte> context_blob;
+  base::Vector<const byte> startup_blob;
+  base::Vector<const byte> read_only_blob;
+  base::Vector<const byte> context_blob;
   SerializeContext(&startup_blob, &read_only_blob, &context_blob);
 
   StartupBlobs blobs = {startup_blob, read_only_blob};
@@ -451,9 +453,9 @@ UNINITIALIZED_TEST(ContextSerializerContext) {
   FreeCurrentEmbeddedBlob();
 }
 
-static void SerializeCustomContext(Vector<const byte>* startup_blob_out,
-                                   Vector<const byte>* read_only_blob_out,
-                                   Vector<const byte>* context_blob_out) {
+static void SerializeCustomContext(base::Vector<const byte>* startup_blob_out,
+                                   base::Vector<const byte>* read_only_blob_out,
+                                   base::Vector<const byte>* context_blob_out) {
   v8::Isolate* v8_isolate = TestSerializer::NewIsolateInitialized();
   Isolate* isolate = reinterpret_cast<Isolate*>(v8_isolate);
   {
@@ -482,9 +484,10 @@ static void SerializeCustomContext(Vector<const byte>* startup_blob_out,
           "var p = 0;"
           "(async ()=>{ p = await 42; })();");
 
-      Vector<const char> source = ConstructSource(
-          StaticCharVector("function g() { return [,"), StaticCharVector("1,"),
-          StaticCharVector("];} a = g(); b = g(); b.push(1);"), 100000);
+      base::Vector<const char> source = ConstructSource(
+          base::StaticCharVector("function g() { return [,"),
+          base::StaticCharVector("1,"),
+          base::StaticCharVector("];} a = g(); b = g(); b.push(1);"), 100000);
       v8::MaybeLocal<v8::String> source_str =
           v8::String::NewFromUtf8(v8_isolate, source.begin(),
                                   v8::NewStringType::kNormal, source.length());
@@ -542,9 +545,9 @@ static void SerializeCustomContext(Vector<const byte>* startup_blob_out,
 
 UNINITIALIZED_TEST(ContextSerializerCustomContext) {
   DisableAlwaysOpt();
-  Vector<const byte> startup_blob;
-  Vector<const byte> read_only_blob;
-  Vector<const byte> context_blob;
+  base::Vector<const byte> startup_blob;
+  base::Vector<const byte> read_only_blob;
+  base::Vector<const byte> context_blob;
   SerializeCustomContext(&startup_blob, &read_only_blob, &context_blob);
 
   StartupBlobs blobs = {startup_blob, read_only_blob};
@@ -1520,10 +1523,10 @@ UNINITIALIZED_TEST(CustomSnapshotDataBlobImmortalImmovableRoots) {
   // Flood the startup snapshot with shared function infos. If they are
   // serialized before the immortal immovable root, the root will no longer end
   // up on the first page.
-  Vector<const char> source =
-      ConstructSource(StaticCharVector("var a = [];"),
-                      StaticCharVector("a.push(function() {return 7});"),
-                      StaticCharVector("\0"), 10000);
+  base::Vector<const char> source =
+      ConstructSource(base::StaticCharVector("var a = [];"),
+                      base::StaticCharVector("a.push(function() {return 7});"),
+                      base::StaticCharVector("\0"), 10000);
 
   DisableEmbeddedBlobRefcounting();
   v8::StartupData data = CreateSnapshotDataBlob(source.begin());
@@ -1608,10 +1611,10 @@ TEST(CodeSerializerWithProfiler) {
   const char* source = "1 + 1";
 
   Handle<String> orig_source = isolate->factory()
-                                   ->NewStringFromUtf8(CStrVector(source))
+                                   ->NewStringFromUtf8(base::CStrVector(source))
                                    .ToHandleChecked();
   Handle<String> copy_source = isolate->factory()
-                                   ->NewStringFromUtf8(CStrVector(source))
+                                   ->NewStringFromUtf8(base::CStrVector(source))
                                    .ToHandleChecked();
   CHECK(!orig_source.is_identical_to(copy_source));
   CHECK(orig_source->Equals(*copy_source));
@@ -1650,10 +1653,10 @@ void TestCodeSerializerOnePlusOneImpl(bool verify_builtins_count = true) {
   const char* source = "1 + 1";
 
   Handle<String> orig_source = isolate->factory()
-                                   ->NewStringFromUtf8(CStrVector(source))
+                                   ->NewStringFromUtf8(base::CStrVector(source))
                                    .ToHandleChecked();
   Handle<String> copy_source = isolate->factory()
-                                   ->NewStringFromUtf8(CStrVector(source))
+                                   ->NewStringFromUtf8(base::CStrVector(source))
                                    .ToHandleChecked();
   CHECK(!orig_source.is_identical_to(copy_source));
   CHECK(orig_source->Equals(*copy_source));
@@ -1717,7 +1720,7 @@ TEST(CodeSerializerPromotedToCompilationCache) {
   const char* source = "1 + 1";
 
   Handle<String> src = isolate->factory()
-                           ->NewStringFromUtf8(CStrVector(source))
+                           ->NewStringFromUtf8(base::CStrVector(source))
                            .ToHandleChecked();
   ScriptData* cache = nullptr;
 
@@ -1748,10 +1751,10 @@ TEST(CodeSerializerInternalizedString) {
   const char* source = "'string1'";
 
   Handle<String> orig_source = isolate->factory()
-                                   ->NewStringFromUtf8(CStrVector(source))
+                                   ->NewStringFromUtf8(base::CStrVector(source))
                                    .ToHandleChecked();
   Handle<String> copy_source = isolate->factory()
-                                   ->NewStringFromUtf8(CStrVector(source))
+                                   ->NewStringFromUtf8(base::CStrVector(source))
                                    .ToHandleChecked();
   CHECK(!orig_source.is_identical_to(copy_source));
   CHECK(orig_source->Equals(*copy_source));
@@ -1808,11 +1811,11 @@ TEST(CodeSerializerLargeCodeObject) {
   // code. Don't even bother generating optimized code to avoid timeouts.
   FLAG_always_opt = false;
 
-  Vector<const char> source = ConstructSource(
-      StaticCharVector("var j=1; if (j == 0) {"),
-      StaticCharVector(
+  base::Vector<const char> source = ConstructSource(
+      base::StaticCharVector("var j=1; if (j == 0) {"),
+      base::StaticCharVector(
           "for (let i of Object.prototype) for (let k = 0; k < 0; ++k);"),
-      StaticCharVector("} j=7; j"), 2000);
+      base::StaticCharVector("} j=7; j"), 2000);
   Handle<String> source_str =
       isolate->factory()->NewStringFromUtf8(source).ToHandleChecked();
 
@@ -1865,10 +1868,10 @@ TEST(CodeSerializerLargeCodeObjectWithIncrementalMarking) {
 
   v8::HandleScope scope(CcTest::isolate());
 
-  Vector<const char> source = ConstructSource(
-      StaticCharVector("var j=1; if (j == 0) {"),
-      StaticCharVector("for (var i = 0; i < Object.prototype; i++);"),
-      StaticCharVector("} j=7; var s = 'happy_hippo'; j"), 20000);
+  base::Vector<const char> source = ConstructSource(
+      base::StaticCharVector("var j=1; if (j == 0) {"),
+      base::StaticCharVector("for (var i = 0; i < Object.prototype; i++);"),
+      base::StaticCharVector("} j=7; var s = 'happy_hippo'; j"), 20000);
   Handle<String> source_str =
       isolate->factory()->NewStringFromUtf8(source).ToHandleChecked();
 
@@ -1937,12 +1940,12 @@ TEST(CodeSerializerLargeStrings) {
 
   v8::HandleScope scope(CcTest::isolate());
 
-  Vector<const char> source_s = ConstructSource(
-      StaticCharVector("var s = \""), StaticCharVector("abcdef"),
-      StaticCharVector("\";"), 1000000);
-  Vector<const char> source_t = ConstructSource(
-      StaticCharVector("var t = \""), StaticCharVector("uvwxyz"),
-      StaticCharVector("\"; s + t"), 999999);
+  base::Vector<const char> source_s = ConstructSource(
+      base::StaticCharVector("var s = \""), base::StaticCharVector("abcdef"),
+      base::StaticCharVector("\";"), 1000000);
+  base::Vector<const char> source_t = ConstructSource(
+      base::StaticCharVector("var t = \""), base::StaticCharVector("uvwxyz"),
+      base::StaticCharVector("\"; s + t"), 999999);
   Handle<String> source_str =
       f->NewConsString(f->NewStringFromUtf8(source_s).ToHandleChecked(),
                        f->NewStringFromUtf8(source_t).ToHandleChecked())
@@ -1998,21 +2001,21 @@ TEST(CodeSerializerThreeBigStrings) {
   const int32_t length_of_b = kMaxRegularHeapObjectSize / 2;
   const int32_t length_of_c = kMaxRegularHeapObjectSize / 2;
 
-  Vector<const char> source_a =
-      ConstructSource(StaticCharVector("var a = \""), StaticCharVector("a"),
-                      StaticCharVector("\";"), length_of_a);
+  base::Vector<const char> source_a = ConstructSource(
+      base::StaticCharVector("var a = \""), base::StaticCharVector("a"),
+      base::StaticCharVector("\";"), length_of_a);
   Handle<String> source_a_str =
       f->NewStringFromUtf8(source_a).ToHandleChecked();
 
-  Vector<const char> source_b =
-      ConstructSource(StaticCharVector("var b = \""), StaticCharVector("b"),
-                      StaticCharVector("\";"), length_of_b);
+  base::Vector<const char> source_b = ConstructSource(
+      base::StaticCharVector("var b = \""), base::StaticCharVector("b"),
+      base::StaticCharVector("\";"), length_of_b);
   Handle<String> source_b_str =
       f->NewStringFromUtf8(source_b).ToHandleChecked();
 
-  Vector<const char> source_c =
-      ConstructSource(StaticCharVector("var c = \""), StaticCharVector("c"),
-                      StaticCharVector("\";"), length_of_c);
+  base::Vector<const char> source_c = ConstructSource(
+      base::StaticCharVector("var c = \""), base::StaticCharVector("c"),
+      base::StaticCharVector("\";"), length_of_c);
   Handle<String> source_c_str =
       f->NewStringFromUtf8(source_c).ToHandleChecked();
 
@@ -2136,9 +2139,10 @@ TEST(CodeSerializerExternalString) {
       "o.one_byte = 7;          \n"
       "o.two_byte = 8;          \n"
       "o.one_byte + o.two_byte; \n";
-  Handle<String> source_string = isolate->factory()
-                                     ->NewStringFromUtf8(CStrVector(source))
-                                     .ToHandleChecked();
+  Handle<String> source_string =
+      isolate->factory()
+          ->NewStringFromUtf8(base::CStrVector(source))
+          .ToHandleChecked();
 
   Handle<JSObject> global(isolate->context().global_object(), isolate);
   ScriptData* cache = nullptr;
@@ -2183,9 +2187,9 @@ TEST(CodeSerializerLargeExternalString) {
   v8::HandleScope scope(CcTest::isolate());
 
   // Create a huge external internalized string to use as variable name.
-  Vector<const char> string =
-      ConstructSource(StaticCharVector(""), StaticCharVector("abcdef"),
-                      StaticCharVector(""), 999999);
+  base::Vector<const char> string = ConstructSource(
+      base::StaticCharVector(""), base::StaticCharVector("abcdef"),
+      base::StaticCharVector(""), 999999);
   Handle<String> name = f->NewStringFromUtf8(string).ToHandleChecked();
   SerializerOneByteResource one_byte_resource(
       reinterpret_cast<const char*>(string.begin()), string.length());
@@ -2250,7 +2254,7 @@ TEST(CodeSerializerExternalScriptName) {
       "a.reduce(function(x, y) { return x + y }, 0)";
 
   Handle<String> source_string =
-      f->NewStringFromUtf8(CStrVector(source)).ToHandleChecked();
+      f->NewStringFromUtf8(base::CStrVector(source)).ToHandleChecked();
 
   const SerializerOneByteResource one_byte_resource("one_byte", 8);
   Handle<String> name =
@@ -4014,7 +4018,7 @@ TEST(WeakArraySerializationInCodeCache) {
   const char* source = "function foo() { }";
 
   Handle<String> src = isolate->factory()
-                           ->NewStringFromUtf8(CStrVector(source))
+                           ->NewStringFromUtf8(base::CStrVector(source))
                            .ToHandleChecked();
   ScriptData* cache = nullptr;
 
diff --git a/test/cctest/test-strings.cc b/test/cctest/test-strings.cc
index 633319f431..7e484eb4ab 100644
--- a/test/cctest/test-strings.cc
+++ b/test/cctest/test-strings.cc
@@ -161,7 +161,8 @@ static void InitializeBuildingBlocks(Handle<String>* building_blocks,
           buf[j] = rng->next(0x10000);
         }
         building_blocks[i] =
-            factory->NewStringFromTwoByte(Vector<const uc16>(buf, len))
+            factory
+                ->NewStringFromTwoByte(v8::base::Vector<const uc16>(buf, len))
                 .ToHandleChecked();
         for (int j = 0; j < len; j++) {
           CHECK_EQ(buf[j], building_blocks[i]->Get(j));
@@ -174,7 +175,7 @@ static void InitializeBuildingBlocks(Handle<String>* building_blocks,
           buf[j] = rng->next(0x80);
         }
         building_blocks[i] =
-            factory->NewStringFromOneByte(OneByteVector(buf, len))
+            factory->NewStringFromOneByte(v8::base::OneByteVector(buf, len))
                 .ToHandleChecked();
         for (int j = 0; j < len; j++) {
           CHECK_EQ(buf[j], building_blocks[i]->Get(j));
@@ -848,9 +849,10 @@ TEST(DeepOneByte) {
   for (int i = 0; i < kDeepOneByteDepth; i++) {
     foo[i] = "foo "[i % 4];
   }
-  Handle<String> string =
-      factory->NewStringFromOneByte(OneByteVector(foo, kDeepOneByteDepth))
-          .ToHandleChecked();
+  Handle<String> string = factory
+                              ->NewStringFromOneByte(v8::base::OneByteVector(
+                                  foo, kDeepOneByteDepth))
+                              .ToHandleChecked();
   Handle<String> foo_string = factory->NewStringFromStaticChars("foo");
   for (int i = 0; i < kDeepOneByteDepth; i += 10) {
     string = factory->NewConsString(string, foo_string).ToHandleChecked();
@@ -1350,14 +1352,14 @@ TEST(SliceFromCons) {
 
 class OneByteVectorResource : public v8::String::ExternalOneByteStringResource {
  public:
-  explicit OneByteVectorResource(i::Vector<const char> vector)
+  explicit OneByteVectorResource(v8::base::Vector<const char> vector)
       : data_(vector) {}
   ~OneByteVectorResource() override = default;
   size_t length() const override { return data_.length(); }
   const char* data() const override { return data_.begin(); }
 
  private:
-  i::Vector<const char> data_;
+  v8::base::Vector<const char> data_;
 };
 
 TEST(InternalizeExternal) {
@@ -1372,7 +1374,7 @@ TEST(InternalizeExternal) {
   Factory* factory = isolate->factory();
   // This won't leak; the external string mechanism will call Dispose() on it.
   OneByteVectorResource* resource =
-      new OneByteVectorResource(i::Vector<const char>("prop-1234", 9));
+      new OneByteVectorResource(v8::base::Vector<const char>("prop-1234", 9));
   {
     v8::HandleScope scope(CcTest::isolate());
     v8::Local<v8::String> ext_string =
@@ -1400,7 +1402,7 @@ TEST(SliceFromExternal) {
   Factory* factory = CcTest::i_isolate()->factory();
   v8::HandleScope scope(CcTest::isolate());
   OneByteVectorResource resource(
-      i::Vector<const char>("abcdefghijklmnopqrstuvwxyz", 26));
+      v8::base::Vector<const char>("abcdefghijklmnopqrstuvwxyz", 26));
   Handle<String> string =
       factory->NewExternalStringFromOneByte(&resource).ToHandleChecked();
   CHECK(string->IsExternalString());
@@ -1650,21 +1652,23 @@ TEST(InvalidExternalString) {
   }
 }
 
-#define INVALID_STRING_TEST(FUN, TYPE)                                         \
-  TEST(StringOOM##FUN) {                                                       \
-    CcTest::InitializeVM();                                                    \
-    LocalContext context;                                                      \
-    Isolate* isolate = CcTest::i_isolate();                                    \
-    STATIC_ASSERT(String::kMaxLength < kMaxInt);                               \
-    static const int invalid = String::kMaxLength + 1;                         \
-    HandleScope scope(isolate);                                                \
-    Vector<TYPE> dummy = Vector<TYPE>::New(invalid);                           \
-    memset(dummy.begin(), 0x0, dummy.length() * sizeof(TYPE));                 \
-    CHECK(isolate->factory()->FUN(Vector<const TYPE>::cast(dummy)).is_null()); \
-    memset(dummy.begin(), 0x20, dummy.length() * sizeof(TYPE));                \
-    CHECK(isolate->has_pending_exception());                                   \
-    isolate->clear_pending_exception();                                        \
-    dummy.Dispose();                                                           \
+#define INVALID_STRING_TEST(FUN, TYPE)                                   \
+  TEST(StringOOM##FUN) {                                                 \
+    CcTest::InitializeVM();                                              \
+    LocalContext context;                                                \
+    Isolate* isolate = CcTest::i_isolate();                              \
+    STATIC_ASSERT(String::kMaxLength < kMaxInt);                         \
+    static const int invalid = String::kMaxLength + 1;                   \
+    HandleScope scope(isolate);                                          \
+    v8::base::Vector<TYPE> dummy = v8::base::Vector<TYPE>::New(invalid); \
+    memset(dummy.begin(), 0x0, dummy.length() * sizeof(TYPE));           \
+    CHECK(isolate->factory()                                             \
+              ->FUN(v8::base::Vector<const TYPE>::cast(dummy))           \
+              .is_null());                                               \
+    memset(dummy.begin(), 0x20, dummy.length() * sizeof(TYPE));          \
+    CHECK(isolate->has_pending_exception());                             \
+    isolate->clear_pending_exception();                                  \
+    dummy.Dispose();                                                     \
   }
 
 INVALID_STRING_TEST(NewStringFromUtf8, char)
@@ -1758,7 +1762,7 @@ TEST(ExternalStringIndexOf) {
     size_t len = strlen(buf);                                                  \
     Handle<String> main_string =                                               \
         factory                                                                \
-            ->NewStringFromOneByte(Vector<const uint8_t>(                      \
+            ->NewStringFromOneByte(v8::base::Vector<const uint8_t>(            \
                 reinterpret_cast<const uint8_t*>(buf), len))                   \
             .ToHandleChecked();                                                \
     if (FLAG_single_generation) {                                              \
@@ -1775,7 +1779,9 @@ TEST(ExternalStringIndexOf) {
                                static_cast<int>(len - 2))                      \
                            .ToHandleChecked();                                 \
     Handle<String> expected_string =                                           \
-        factory->NewStringFromUtf8(Vector<const char>(buf + 2, len - 2))       \
+        factory                                                                \
+            ->NewStringFromUtf8(                                               \
+                v8::base::Vector<const char>(buf + 2, len - 2))                \
             .ToHandleChecked();                                                \
     CHECK(s->Equals(*expected_string));                                        \
   }
diff --git a/test/cctest/test-strtod.cc b/test/cctest/test-strtod.cc
index 2076b5b4ec..740815df77 100644
--- a/test/cctest/test-strtod.cc
+++ b/test/cctest/test-strtod.cc
@@ -41,20 +41,20 @@ namespace internal {
 namespace test_strtod {
 
 static double StrtodChar(const char* str, int exponent) {
-  return Strtod(CStrVector(str), exponent);
+  return Strtod(base::CStrVector(str), exponent);
 }
 
 TEST(Strtod) {
-  Vector<const char> vector;
+  base::Vector<const char> vector;
 
-  vector = CStrVector("0");
+  vector = base::CStrVector("0");
   CHECK_EQ(0.0, Strtod(vector, 1));
   CHECK_EQ(0.0, Strtod(vector, 2));
   CHECK_EQ(0.0, Strtod(vector, -2));
   CHECK_EQ(0.0, Strtod(vector, -999));
   CHECK_EQ(0.0, Strtod(vector, +999));
 
-  vector = CStrVector("1");
+  vector = base::CStrVector("1");
   CHECK_EQ(1.0, Strtod(vector, 0));
   CHECK_EQ(10.0, Strtod(vector, 1));
   CHECK_EQ(100.0, Strtod(vector, 2));
@@ -73,7 +73,7 @@ TEST(Strtod) {
   CHECK_EQ(1e-25, Strtod(vector, -25));
   CHECK_EQ(1e-39, Strtod(vector, -39));
 
-  vector = CStrVector("2");
+  vector = base::CStrVector("2");
   CHECK_EQ(2.0, Strtod(vector, 0));
   CHECK_EQ(20.0, Strtod(vector, 1));
   CHECK_EQ(200.0, Strtod(vector, 2));
@@ -92,7 +92,7 @@ TEST(Strtod) {
   CHECK_EQ(2e-25, Strtod(vector, -25));
   CHECK_EQ(2e-39, Strtod(vector, -39));
 
-  vector = CStrVector("9");
+  vector = base::CStrVector("9");
   CHECK_EQ(9.0, Strtod(vector, 0));
   CHECK_EQ(90.0, Strtod(vector, 1));
   CHECK_EQ(900.0, Strtod(vector, 2));
@@ -111,7 +111,7 @@ TEST(Strtod) {
   CHECK_EQ(9e-25, Strtod(vector, -25));
   CHECK_EQ(9e-39, Strtod(vector, -39));
 
-  vector = CStrVector("12345");
+  vector = base::CStrVector("12345");
   CHECK_EQ(12345.0, Strtod(vector, 0));
   CHECK_EQ(123450.0, Strtod(vector, 1));
   CHECK_EQ(1234500.0, Strtod(vector, 2));
@@ -133,7 +133,7 @@ TEST(Strtod) {
   CHECK_EQ(12345e-25, Strtod(vector, -25));
   CHECK_EQ(12345e-39, Strtod(vector, -39));
 
-  vector = CStrVector("12345678901234");
+  vector = base::CStrVector("12345678901234");
   CHECK_EQ(12345678901234.0, Strtod(vector, 0));
   CHECK_EQ(123456789012340.0, Strtod(vector, 1));
   CHECK_EQ(1234567890123400.0, Strtod(vector, 2));
@@ -155,7 +155,7 @@ TEST(Strtod) {
   CHECK_EQ(12345678901234e-25, Strtod(vector, -25));
   CHECK_EQ(12345678901234e-39, Strtod(vector, -39));
 
-  vector = CStrVector("123456789012345");
+  vector = base::CStrVector("123456789012345");
   CHECK_EQ(123456789012345.0, Strtod(vector, 0));
   CHECK_EQ(1234567890123450.0, Strtod(vector, 1));
   CHECK_EQ(12345678901234500.0, Strtod(vector, 2));
@@ -388,9 +388,7 @@ static int CompareBignumToDiyFp(const Bignum& bignum_digits,
   return Bignum::Compare(bignum, other);
 }
 
-
-static bool CheckDouble(Vector<const char> buffer,
-                        int exponent,
+static bool CheckDouble(base::Vector<const char> buffer, int exponent,
                         double to_check) {
   DiyFp lower_boundary;
   DiyFp upper_boundary;
@@ -421,7 +419,6 @@ static bool CheckDouble(Vector<const char> buffer,
   }
 }
 
-
 // Copied from v8.cc and adapted to make the function deterministic.
 static uint32_t DeterministicRandom() {
   // Random number generator using George Marsaglia's MWC algorithm.
@@ -455,7 +452,7 @@ TEST(RandomStrtod) {
       }
       int exponent = DeterministicRandom() % (25*2 + 1) - 25 - length;
       buffer[pos] = '\0';
-      Vector<const char> vector(buffer, pos);
+      base::Vector<const char> vector(buffer, pos);
       double strtod_result = Strtod(vector, exponent);
       CHECK(CheckDouble(vector, exponent, strtod_result));
     }
@@ -468,7 +465,7 @@ TEST(RandomStrtod) {
       }
       int exponent = DeterministicRandom() % (308*2 + 1) - 308 - length;
       buffer[pos] = '\0';
-      Vector<const char> vector(buffer, pos);
+      base::Vector<const char> vector(buffer, pos);
       double strtod_result = Strtod(vector, exponent);
       CHECK(CheckDouble(vector, exponent, strtod_result));
     }
diff --git a/test/cctest/test-transitions.cc b/test/cctest/test-transitions.cc
index 9e179b4662..ee5134bfba 100644
--- a/test/cctest/test-transitions.cc
+++ b/test/cctest/test-transitions.cc
@@ -149,7 +149,7 @@ TEST(TransitionArray_DifferentFieldNames) {
   CHECK(map0->raw_transitions()->IsSmi());
 
   for (int i = 0; i < PROPS_COUNT; i++) {
-    EmbeddedVector<char, 64> buffer;
+    base::EmbeddedVector<char, 64> buffer;
     SNPrintF(buffer, "prop%d", i);
     Handle<String> name = factory->InternalizeUtf8String(buffer.begin());
     Handle<Map> map =
@@ -241,7 +241,7 @@ TEST(TransitionArray_SameFieldNamesDifferentAttributes) {
 
   // Some number of fields.
   for (int i = 0; i < PROPS_COUNT; i++) {
-    EmbeddedVector<char, 64> buffer;
+    base::EmbeddedVector<char, 64> buffer;
     SNPrintF(buffer, "prop%d", i);
     Handle<String> name = factory->InternalizeUtf8String(buffer.begin());
     Handle<Map> map =
diff --git a/test/cctest/test-types.cc b/test/cctest/test-types.cc
index 0b05dff6b8..848b8ebb63 100644
--- a/test/cctest/test-types.cc
+++ b/test/cctest/test-types.cc
@@ -277,8 +277,8 @@ struct Tests {
     Handle<String> s1 = fac->NewStringFromAsciiChecked("a");
     CHECK(T.Constant(s1).Is(T.InternalizedString));
     const uc16 two_byte[1] = {0x2603};
-    Handle<String> s2 =
-        fac->NewTwoByteInternalizedString(Vector<const uc16>(two_byte, 1), 1);
+    Handle<String> s2 = fac->NewTwoByteInternalizedString(
+        base::Vector<const uc16>(two_byte, 1), 1);
     CHECK(T.Constant(s2).Is(T.InternalizedString));
 
     // Typing of special constants
diff --git a/test/cctest/test-utils.cc b/test/cctest/test-utils.cc
index 3abab9430d..e065316891 100644
--- a/test/cctest/test-utils.cc
+++ b/test/cctest/test-utils.cc
@@ -102,7 +102,8 @@ TEST(BitSetComputer) {
   const int words = 750;
   CHECK_EQ(words, TwoBits::word_count(3000));
   const int offset = 10;
-  Vector<unsigned char> buffer = Vector<unsigned char>::New(offset + words);
+  base::Vector<unsigned char> buffer =
+      base::Vector<unsigned char>::New(offset + words);
   memset(buffer.begin(), 0, sizeof(unsigned char) * buffer.length());
   for (int i = 0; i < words; i++) {
     const int index = TwoBits::index(offset, i);
@@ -127,9 +128,9 @@ TEST(SNPrintF) {
   int length = static_cast<int>(strlen(s));
   for (int i = 1; i < length * 2; i++) {
     static const char kMarker = static_cast<char>(42);
-    Vector<char> buffer = Vector<char>::New(i + 1);
+    base::Vector<char> buffer = base::Vector<char>::New(i + 1);
     buffer[i] = kMarker;
-    int n = SNPrintF(Vector<char>(buffer.begin(), i), "%s", s);
+    int n = SNPrintF(base::Vector<char>(buffer.begin(), i), "%s", s);
     CHECK(n <= i);
     CHECK(n == length || n == -1);
     CHECK_EQ(0, strncmp(buffer.begin(), s, i - 1));
@@ -199,7 +200,7 @@ TEST(Collector) {
   const int kSequentialSize = 1000;
   const int kBlockSize = 7;
   for (int loop = 0; loop < kLoops; loop++) {
-    Vector<int> block = collector.AddBlock(7, 0xBADCAFE);
+    base::Vector<int> block = collector.AddBlock(7, 0xBADCAFE);
     for (int i = 0; i < kSequentialSize; i++) {
       collector.Add(i);
     }
@@ -207,7 +208,7 @@ TEST(Collector) {
       block[i] = i * 7;
     }
   }
-  Vector<int> result = collector.ToVector();
+  base::Vector<int> result = collector.ToVector();
   CHECK_EQ(kLoops * (kBlockSize + kSequentialSize), result.length());
   for (int i = 0; i < kLoops; i++) {
     int offset = i * (kSequentialSize + kBlockSize);
@@ -234,13 +235,13 @@ TEST(SequenceCollector) {
     for (int j = 0; j < seq_length; j++) {
       collector.Add(j);
     }
-    Vector<int> sequence = collector.EndSequence();
+    base::Vector<int> sequence = collector.EndSequence();
     for (int j = 0; j < seq_length; j++) {
       CHECK_EQ(j, sequence[j]);
     }
     total_length += seq_length;
   }
-  Vector<int> result = collector.ToVector();
+  base::Vector<int> result = collector.ToVector();
   CHECK_EQ(total_length, result.length());
   int offset = 0;
   for (int loop = 0; loop < kLoops; loop++) {
@@ -259,8 +260,8 @@ TEST(SequenceCollectorRegression) {
   collector.StartSequence();
   collector.Add('0');
   collector.AddBlock(
-      i::Vector<const char>("12345678901234567890123456789012", 32));
-  i::Vector<char> seq = collector.EndSequence();
+      base::Vector<const char>("12345678901234567890123456789012", 32));
+  base::Vector<char> seq = collector.EndSequence();
   CHECK_EQ(0, strncmp("0123456789012345678901234567890123", seq.begin(),
                       seq.length()));
 }
diff --git a/test/cctest/test-version.cc b/test/cctest/test-version.cc
index 4ba87083de..87f32ec694 100644
--- a/test/cctest/test-version.cc
+++ b/test/cctest/test-version.cc
@@ -49,8 +49,8 @@ static void CheckVersion(int major, int minor, int build, int patch,
                          const char* embedder, bool candidate,
                          const char* expected_version_string,
                          const char* expected_generic_soname) {
-  static v8::internal::EmbeddedVector<char, 128> version_str;
-  static v8::internal::EmbeddedVector<char, 128> soname_str;
+  static v8::base::EmbeddedVector<char, 128> version_str;
+  static v8::base::EmbeddedVector<char, 128> soname_str;
 
   // Test version without specific SONAME.
   SetVersion(major, minor, build, patch, embedder, candidate, "");
diff --git a/test/cctest/wasm/test-c-wasm-entry.cc b/test/cctest/wasm/test-c-wasm-entry.cc
index 472eb80a68..dae8048ece 100644
--- a/test/cctest/wasm/test-c-wasm-entry.cc
+++ b/test/cctest/wasm/test-c-wasm-entry.cc
@@ -165,10 +165,13 @@ TEST(TestCWasmEntryArgPassing_AllTypes) {
         return 0. + a + b + c + d;
       });
 
-  Vector<const int32_t> test_values_i32 = compiler::ValueHelper::int32_vector();
-  Vector<const int64_t> test_values_i64 = compiler::ValueHelper::int64_vector();
-  Vector<const float> test_values_f32 = compiler::ValueHelper::float32_vector();
-  Vector<const double> test_values_f64 =
+  base::Vector<const int32_t> test_values_i32 =
+      compiler::ValueHelper::int32_vector();
+  base::Vector<const int64_t> test_values_i64 =
+      compiler::ValueHelper::int64_vector();
+  base::Vector<const float> test_values_f32 =
+      compiler::ValueHelper::float32_vector();
+  base::Vector<const double> test_values_f64 =
       compiler::ValueHelper::float64_vector();
   size_t max_len =
       std::max(std::max(test_values_i32.size(), test_values_i64.size()),
diff --git a/test/cctest/wasm/test-compilation-cache.cc b/test/cctest/wasm/test-compilation-cache.cc
index de5ba717f6..68a55290fc 100644
--- a/test/cctest/wasm/test-compilation-cache.cc
+++ b/test/cctest/wasm/test-compilation-cache.cc
@@ -58,13 +58,13 @@ class StreamTester {
   }
 
   void OnBytesReceived(const uint8_t* start, size_t length) {
-    stream_->OnBytesReceived(Vector<const uint8_t>(start, length));
+    stream_->OnBytesReceived(base::Vector<const uint8_t>(start, length));
   }
 
   void FinishStream() { stream_->Finish(); }
 
   void SetCompiledModuleBytes(const uint8_t* start, size_t length) {
-    stream_->SetCompiledModuleBytes(Vector<const uint8_t>(start, length));
+    stream_->SetCompiledModuleBytes(base::Vector<const uint8_t>(start, length));
   }
 
  private:
@@ -87,7 +87,7 @@ ZoneBuffer GetValidModuleBytes(Zone* zone, uint8_t n) {
   return buffer;
 }
 
-std::shared_ptr<NativeModule> SyncCompile(Vector<const uint8_t> bytes) {
+std::shared_ptr<NativeModule> SyncCompile(base::Vector<const uint8_t> bytes) {
   ErrorThrower thrower(CcTest::i_isolate(), "Test");
   auto enabled_features = WasmFeatures::FromIsolate(CcTest::i_isolate());
   auto wire_bytes = ModuleWireBytes(bytes.begin(), bytes.end());
@@ -213,7 +213,8 @@ TEST(TestStreamingAndSyncCache) {
 
   // Compile the same module synchronously to make sure we don't deadlock
   // waiting for streaming compilation to finish.
-  auto full_bytes = OwnedVector<uint8_t>::New(kPrefixSize + kFunctionSize);
+  auto full_bytes =
+      base::OwnedVector<uint8_t>::New(kPrefixSize + kFunctionSize);
   memcpy(full_bytes.begin(), kPrefix, kPrefixSize);
   memcpy(full_bytes.begin() + kPrefixSize, kFunctionA, kFunctionSize);
   auto native_module_sync = SyncCompile(full_bytes.as_vector());
diff --git a/test/cctest/wasm/test-gc.cc b/test/cctest/wasm/test-gc.cc
index 5fc670cc71..72646dae70 100644
--- a/test/cctest/wasm/test-gc.cc
+++ b/test/cctest/wasm/test-gc.cc
@@ -4,8 +4,8 @@
 
 #include <stdint.h>
 
+#include "src/base/vector.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 #include "src/wasm/module-decoder.h"
 #include "src/wasm/struct-types.h"
 #include "src/wasm/wasm-arguments.h"
@@ -69,7 +69,7 @@ class WasmGCTester {
                               std::initializer_list<byte> code) {
     WasmFunctionBuilder* fun = builder_.AddFunction(sig);
     fun->EmitCode(code.begin(), static_cast<uint32_t>(code.size()));
-    builder_.AddExport(CStrVector(name), fun);
+    builder_.AddExport(base::CStrVector(name), fun);
   }
 
   MaybeHandle<Object> CallExportedFunction(const char* name, int argc,
diff --git a/test/cctest/wasm/test-grow-memory.cc b/test/cctest/wasm/test-grow-memory.cc
index d3ad66aa4b..a984fc9706 100644
--- a/test/cctest/wasm/test-grow-memory.cc
+++ b/test/cctest/wasm/test-grow-memory.cc
@@ -23,7 +23,7 @@ using v8::internal::testing::ManuallyExternalizedBuffer;
 
 namespace {
 void ExportAsMain(WasmFunctionBuilder* f) {
-  f->builder()->AddExport(CStrVector("main"), f);
+  f->builder()->AddExport(base::CStrVector("main"), f);
 }
 #define EMIT_CODE_WITH_END(f, code)  \
   do {                               \
diff --git a/test/cctest/wasm/test-liftoff-inspection.cc b/test/cctest/wasm/test-liftoff-inspection.cc
index 96df9d5252..377b1f24b5 100644
--- a/test/cctest/wasm/test-liftoff-inspection.cc
+++ b/test/cctest/wasm/test-liftoff-inspection.cc
@@ -56,9 +56,9 @@ class LiftoffCompileEnvironment {
 
     // Check that the generated code matches.
     auto code1 =
-        VectorOf(result1.code_desc.buffer, result1.code_desc.instr_size);
+        base::VectorOf(result1.code_desc.buffer, result1.code_desc.instr_size);
     auto code2 =
-        VectorOf(result2.code_desc.buffer, result2.code_desc.instr_size);
+        base::VectorOf(result2.code_desc.buffer, result2.code_desc.instr_size);
     CHECK_EQ(code1, code2);
     CHECK_EQ(detected1, detected2);
   }
@@ -75,7 +75,7 @@ class LiftoffCompileEnvironment {
     std::unique_ptr<DebugSideTable> debug_side_table_via_compilation;
     auto result = ExecuteLiftoffCompilation(
         CcTest::i_isolate()->allocator(), &env, test_func.body, 0,
-        kForDebugging, nullptr, &detected, VectorOf(breakpoints),
+        kForDebugging, nullptr, &detected, base::VectorOf(breakpoints),
         &debug_side_table_via_compilation);
     CHECK(result.succeeded());
 
@@ -138,7 +138,7 @@ class LiftoffCompileEnvironment {
     // declaration and the trailing "end" opcode).
     NativeModule* native_module = code->native_module();
     auto* function = &native_module->module()->functions[code->index()];
-    Vector<const uint8_t> function_wire_bytes =
+    base::Vector<const uint8_t> function_wire_bytes =
         native_module->wire_bytes().SubVector(function->code.offset(),
                                               function->code.end_offset());
 
diff --git a/test/cctest/wasm/test-run-wasm-bulk-memory.cc b/test/cctest/wasm/test-run-wasm-bulk-memory.cc
index 52e979c6a2..a56f35b35f 100644
--- a/test/cctest/wasm/test-run-wasm-bulk-memory.cc
+++ b/test/cctest/wasm/test-run-wasm-bulk-memory.cc
@@ -50,7 +50,7 @@ WASM_EXEC_TEST(MemoryInit) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
   const byte data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-  r.builder().AddPassiveDataSegment(ArrayVector(data));
+  r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   BUILD(r,
         WASM_MEMORY_INIT(0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                          WASM_LOCAL_GET(2)),
@@ -86,7 +86,7 @@ WASM_EXEC_TEST(MemoryInitOutOfBoundsData) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
   const byte data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-  r.builder().AddPassiveDataSegment(ArrayVector(data));
+  r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   BUILD(r,
         WASM_MEMORY_INIT(0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                          WASM_LOCAL_GET(2)),
@@ -107,7 +107,7 @@ WASM_EXEC_TEST(MemoryInitOutOfBounds) {
   WasmRunner<uint32_t, uint32_t, uint32_t, uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
   const byte data[kWasmPageSize] = {};
-  r.builder().AddPassiveDataSegment(ArrayVector(data));
+  r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   BUILD(r,
         WASM_MEMORY_INIT(0, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1),
                          WASM_LOCAL_GET(2)),
@@ -315,7 +315,7 @@ WASM_EXEC_TEST(DataDropTwice) {
   WasmRunner<uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
   const byte data[] = {0};
-  r.builder().AddPassiveDataSegment(ArrayVector(data));
+  r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   BUILD(r, WASM_DATA_DROP(0), kExprI32Const, 0);
 
   CHECK_EQ(0, r.Call());
@@ -326,7 +326,7 @@ WASM_EXEC_TEST(DataDropThenMemoryInit) {
   WasmRunner<uint32_t> r(execution_tier);
   r.builder().AddMemory(kWasmPageSize);
   const byte data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
-  r.builder().AddPassiveDataSegment(ArrayVector(data));
+  r.builder().AddPassiveDataSegment(base::ArrayVector(data));
   BUILD(r, WASM_DATA_DROP(0),
         WASM_MEMORY_INIT(0, WASM_I32V_1(0), WASM_I32V_1(1), WASM_I32V_1(2)),
         kExprI32Const, 0);
diff --git a/test/cctest/wasm/test-run-wasm-js.cc b/test/cctest/wasm/test-run-wasm-js.cc
index c2b628d526..6a82070b9f 100644
--- a/test/cctest/wasm/test-run-wasm-js.cc
+++ b/test/cctest/wasm/test-run-wasm-js.cc
@@ -57,7 +57,7 @@ ManuallyImportedJSFunction CreateJSSelector(FunctionSig* sig, int which) {
   CHECK_LT(which, static_cast<int>(sig->parameter_count()));
   CHECK_LT(static_cast<int>(sig->parameter_count()), kMaxParams);
 
-  i::EmbeddedVector<char, 256> source;
+  base::EmbeddedVector<char, 256> source;
   char param = 'a' + which;
   SNPrintF(source, "(function(%s) { return %c; })",
            formals[sig->parameter_count()], param);
diff --git a/test/cctest/wasm/test-run-wasm-module.cc b/test/cctest/wasm/test-run-wasm-module.cc
index 353f746784..bb8957c735 100644
--- a/test/cctest/wasm/test-run-wasm-module.cc
+++ b/test/cctest/wasm/test-run-wasm-module.cc
@@ -67,7 +67,7 @@ void TestModuleException(Zone* zone, WasmModuleBuilder* builder) {
 }
 
 void ExportAsMain(WasmFunctionBuilder* f) {
-  f->builder()->AddExport(CStrVector("main"), f);
+  f->builder()->AddExport(base::CStrVector("main"), f);
 }
 
 #define EMIT_CODE_WITH_END(f, code)  \
diff --git a/test/cctest/wasm/test-run-wasm-relaxed-simd.cc b/test/cctest/wasm/test-run-wasm-relaxed-simd.cc
index 214dc3c5d8..6eb33ade6b 100644
--- a/test/cctest/wasm/test-run-wasm-relaxed-simd.cc
+++ b/test/cctest/wasm/test-run-wasm-relaxed-simd.cc
@@ -77,8 +77,8 @@ static constexpr FMOperation<T> qfma_array[] = {
      std::numeric_limits<T>::quiet_NaN(), std::numeric_limits<T>::quiet_NaN()}};
 
 template <typename T>
-static constexpr Vector<const FMOperation<T>> qfma_vector() {
-  return ArrayVector(qfma_array<T>);
+static constexpr base::Vector<const FMOperation<T>> qfma_vector() {
+  return base::ArrayVector(qfma_array<T>);
 }
 
 // Fused Multiply-Subtract performs a - b * c.
@@ -101,8 +101,8 @@ static constexpr FMOperation<T> qfms_array[]{
      std::numeric_limits<T>::quiet_NaN(), std::numeric_limits<T>::quiet_NaN()}};
 
 template <typename T>
-static constexpr Vector<const FMOperation<T>> qfms_vector() {
-  return ArrayVector(qfms_array<T>);
+static constexpr base::Vector<const FMOperation<T>> qfms_vector() {
+  return base::ArrayVector(qfms_array<T>);
 }
 
 // Fused results only when fma3 feature is enabled, and running on TurboFan or
diff --git a/test/cctest/wasm/test-run-wasm-simd.cc b/test/cctest/wasm/test-run-wasm-simd.cc
index ab8366cf9b..2b417f0955 100644
--- a/test/cctest/wasm/test-run-wasm-simd.cc
+++ b/test/cctest/wasm/test-run-wasm-simd.cc
@@ -21,12 +21,12 @@
 #include "src/base/overflowing-math.h"
 #include "src/base/safe_conversions.h"
 #include "src/base/utils/random-number-generator.h"
+#include "src/base/vector.h"
 #include "src/codegen/cpu-features.h"
 #include "src/codegen/machine-type.h"
 #include "src/common/globals.h"
 #include "src/flags/flags.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 #include "src/wasm/compilation-environment.h"
 #include "src/wasm/value-type.h"
 #include "src/wasm/wasm-constants.h"
@@ -2136,8 +2136,8 @@ static constexpr SwizzleTestArgs swizzle_test_args[] = {
      {16, 17, 18, 19, 20, 124, 125, 126, 127, -1, -2, -3, -4, -5, -6, -7},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}};
 
-static constexpr Vector<const SwizzleTestArgs> swizzle_test_vector =
-    ArrayVector(swizzle_test_args);
+static constexpr base::Vector<const SwizzleTestArgs> swizzle_test_vector =
+    base::ArrayVector(swizzle_test_args);
 
 WASM_SIMD_TEST(I8x16Swizzle) {
   // RunBinaryLaneOpTest set up the two globals to be consecutive integers,
diff --git a/test/cctest/wasm/test-run-wasm-wrappers.cc b/test/cctest/wasm/test-run-wasm-wrappers.cc
index 355cd5df72..d082f02c51 100644
--- a/test/cctest/wasm/test-run-wasm-wrappers.cc
+++ b/test/cctest/wasm/test-run-wasm-wrappers.cc
@@ -78,7 +78,7 @@ TEST(WrapperBudget) {
     // Define the Wasm function.
     TestSignatures sigs;
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_ii());
-    f->builder()->AddExport(CStrVector("main"), f);
+    f->builder()->AddExport(base::CStrVector("main"), f);
     byte code[] = {WASM_I32_MUL(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
                    WASM_END};
     f->EmitCode(code, sizeof(code));
@@ -124,7 +124,7 @@ TEST(WrapperReplacement) {
     // Define the Wasm function.
     TestSignatures sigs;
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_i());
-    f->builder()->AddExport(CStrVector("main"), f);
+    f->builder()->AddExport(base::CStrVector("main"), f);
     byte code[] = {WASM_LOCAL_GET(0), WASM_END};
     f->EmitCode(code, sizeof(code));
 
@@ -195,17 +195,17 @@ TEST(EagerWrapperReplacement) {
     // while the other one (id) won't.
     TestSignatures sigs;
     WasmFunctionBuilder* add = builder->AddFunction(sigs.i_ii());
-    add->builder()->AddExport(CStrVector("add"), add);
+    add->builder()->AddExport(base::CStrVector("add"), add);
     byte add_code[] = {WASM_I32_ADD(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
                        WASM_END};
     add->EmitCode(add_code, sizeof(add_code));
     WasmFunctionBuilder* mult = builder->AddFunction(sigs.i_ii());
-    mult->builder()->AddExport(CStrVector("mult"), mult);
+    mult->builder()->AddExport(base::CStrVector("mult"), mult);
     byte mult_code[] = {WASM_I32_MUL(WASM_LOCAL_GET(0), WASM_LOCAL_GET(1)),
                         WASM_END};
     mult->EmitCode(mult_code, sizeof(mult_code));
     WasmFunctionBuilder* id = builder->AddFunction(sigs.i_i());
-    id->builder()->AddExport(CStrVector("id"), id);
+    id->builder()->AddExport(base::CStrVector("id"), id);
     byte id_code[] = {WASM_LOCAL_GET(0), WASM_END};
     id->EmitCode(id_code, sizeof(id_code));
 
@@ -303,7 +303,7 @@ TEST(WrapperReplacement_IndirectExport) {
 
     // Export a table of indirect functions.
     uint32_t table_index = builder->AllocateIndirectFunctions(2);
-    builder->AddExport(CStrVector("exported_table"), kExternalTable, 0);
+    builder->AddExport(base::CStrVector("exported_table"), kExternalTable, 0);
     // Point from the exported table to the Wasm function.
     builder->SetIndirectFunction(0, function_index);
 
diff --git a/test/cctest/wasm/test-run-wasm.cc b/test/cctest/wasm/test-run-wasm.cc
index 8a2dac14fb..4d6d7810db 100644
--- a/test/cctest/wasm/test-run-wasm.cc
+++ b/test/cctest/wasm/test-run-wasm.cc
@@ -3616,7 +3616,7 @@ WASM_EXEC_TEST(IndirectNullTyped) {
 template <typename ctype>
 void BinOpOnDifferentRegisters(
     TestExecutionTier execution_tier, ValueType type,
-    Vector<const ctype> inputs, WasmOpcode opcode,
+    base::Vector<const ctype> inputs, WasmOpcode opcode,
     std::function<ctype(ctype, ctype, bool*)> expect_fn) {
   static constexpr int kMaxNumLocals = 8;
   for (int num_locals = 1; num_locals < kMaxNumLocals; ++num_locals) {
@@ -3696,50 +3696,53 @@ static constexpr int64_t kSome64BitInputs[] = {
 
 WASM_EXEC_TEST(I32AddOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32Add,
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32Add,
       [](int32_t lhs, int32_t rhs, bool* trap) { return lhs + rhs; });
 }
 
 WASM_EXEC_TEST(I32SubOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32Sub,
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32Sub,
       [](int32_t lhs, int32_t rhs, bool* trap) { return lhs - rhs; });
 }
 
 WASM_EXEC_TEST(I32MulOnDifferentRegisters) {
-  BinOpOnDifferentRegisters<int32_t>(execution_tier, kWasmI32,
-                                     ArrayVector(kSome32BitInputs), kExprI32Mul,
-                                     [](int32_t lhs, int32_t rhs, bool* trap) {
-                                       return base::MulWithWraparound(lhs, rhs);
-                                     });
+  BinOpOnDifferentRegisters<int32_t>(
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32Mul, [](int32_t lhs, int32_t rhs, bool* trap) {
+        return base::MulWithWraparound(lhs, rhs);
+      });
 }
 
 WASM_EXEC_TEST(I32ShlOnDifferentRegisters) {
-  BinOpOnDifferentRegisters<int32_t>(execution_tier, kWasmI32,
-                                     ArrayVector(kSome32BitInputs), kExprI32Shl,
-                                     [](int32_t lhs, int32_t rhs, bool* trap) {
-                                       return base::ShlWithWraparound(lhs, rhs);
-                                     });
+  BinOpOnDifferentRegisters<int32_t>(
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32Shl, [](int32_t lhs, int32_t rhs, bool* trap) {
+        return base::ShlWithWraparound(lhs, rhs);
+      });
 }
 
 WASM_EXEC_TEST(I32ShrSOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32ShrS,
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32ShrS,
       [](int32_t lhs, int32_t rhs, bool* trap) { return lhs >> (rhs & 31); });
 }
 
 WASM_EXEC_TEST(I32ShrUOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32ShrU,
-      [](int32_t lhs, int32_t rhs, bool* trap) {
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32ShrU, [](int32_t lhs, int32_t rhs, bool* trap) {
         return static_cast<uint32_t>(lhs) >> (rhs & 31);
       });
 }
 
 WASM_EXEC_TEST(I32DivSOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32DivS,
-      [](int32_t lhs, int32_t rhs, bool* trap) {
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32DivS, [](int32_t lhs, int32_t rhs, bool* trap) {
         *trap = rhs == 0;
         return *trap ? 0 : lhs / rhs;
       });
@@ -3747,8 +3750,8 @@ WASM_EXEC_TEST(I32DivSOnDifferentRegisters) {
 
 WASM_EXEC_TEST(I32DivUOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32DivU,
-      [](uint32_t lhs, uint32_t rhs, bool* trap) {
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32DivU, [](uint32_t lhs, uint32_t rhs, bool* trap) {
         *trap = rhs == 0;
         return *trap ? 0 : lhs / rhs;
       });
@@ -3756,8 +3759,8 @@ WASM_EXEC_TEST(I32DivUOnDifferentRegisters) {
 
 WASM_EXEC_TEST(I32RemSOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32RemS,
-      [](int32_t lhs, int32_t rhs, bool* trap) {
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32RemS, [](int32_t lhs, int32_t rhs, bool* trap) {
         *trap = rhs == 0;
         return *trap || rhs == -1 ? 0 : lhs % rhs;
       });
@@ -3765,8 +3768,8 @@ WASM_EXEC_TEST(I32RemSOnDifferentRegisters) {
 
 WASM_EXEC_TEST(I32RemUOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int32_t>(
-      execution_tier, kWasmI32, ArrayVector(kSome32BitInputs), kExprI32RemU,
-      [](uint32_t lhs, uint32_t rhs, bool* trap) {
+      execution_tier, kWasmI32, base::ArrayVector(kSome32BitInputs),
+      kExprI32RemU, [](uint32_t lhs, uint32_t rhs, bool* trap) {
         *trap = rhs == 0;
         return *trap ? 0 : lhs % rhs;
       });
@@ -3774,50 +3777,53 @@ WASM_EXEC_TEST(I32RemUOnDifferentRegisters) {
 
 WASM_EXEC_TEST(I64AddOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64Add,
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64Add,
       [](int64_t lhs, int64_t rhs, bool* trap) { return lhs + rhs; });
 }
 
 WASM_EXEC_TEST(I64SubOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64Sub,
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64Sub,
       [](int64_t lhs, int64_t rhs, bool* trap) { return lhs - rhs; });
 }
 
 WASM_EXEC_TEST(I64MulOnDifferentRegisters) {
-  BinOpOnDifferentRegisters<int64_t>(execution_tier, kWasmI64,
-                                     ArrayVector(kSome64BitInputs), kExprI64Mul,
-                                     [](int64_t lhs, int64_t rhs, bool* trap) {
-                                       return base::MulWithWraparound(lhs, rhs);
-                                     });
+  BinOpOnDifferentRegisters<int64_t>(
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64Mul, [](int64_t lhs, int64_t rhs, bool* trap) {
+        return base::MulWithWraparound(lhs, rhs);
+      });
 }
 
 WASM_EXEC_TEST(I64ShlOnDifferentRegisters) {
-  BinOpOnDifferentRegisters<int64_t>(execution_tier, kWasmI64,
-                                     ArrayVector(kSome64BitInputs), kExprI64Shl,
-                                     [](int64_t lhs, int64_t rhs, bool* trap) {
-                                       return base::ShlWithWraparound(lhs, rhs);
-                                     });
+  BinOpOnDifferentRegisters<int64_t>(
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64Shl, [](int64_t lhs, int64_t rhs, bool* trap) {
+        return base::ShlWithWraparound(lhs, rhs);
+      });
 }
 
 WASM_EXEC_TEST(I64ShrSOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64ShrS,
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64ShrS,
       [](int64_t lhs, int64_t rhs, bool* trap) { return lhs >> (rhs & 63); });
 }
 
 WASM_EXEC_TEST(I64ShrUOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64ShrU,
-      [](int64_t lhs, int64_t rhs, bool* trap) {
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64ShrU, [](int64_t lhs, int64_t rhs, bool* trap) {
         return static_cast<uint64_t>(lhs) >> (rhs & 63);
       });
 }
 
 WASM_EXEC_TEST(I64DivSOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64DivS,
-      [](int64_t lhs, int64_t rhs, bool* trap) {
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64DivS, [](int64_t lhs, int64_t rhs, bool* trap) {
         *trap = rhs == 0 ||
                 (rhs == -1 && lhs == std::numeric_limits<int64_t>::min());
         return *trap ? 0 : lhs / rhs;
@@ -3826,8 +3832,8 @@ WASM_EXEC_TEST(I64DivSOnDifferentRegisters) {
 
 WASM_EXEC_TEST(I64DivUOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64DivU,
-      [](uint64_t lhs, uint64_t rhs, bool* trap) {
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64DivU, [](uint64_t lhs, uint64_t rhs, bool* trap) {
         *trap = rhs == 0;
         return *trap ? 0 : lhs / rhs;
       });
@@ -3835,8 +3841,8 @@ WASM_EXEC_TEST(I64DivUOnDifferentRegisters) {
 
 WASM_EXEC_TEST(I64RemSOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64RemS,
-      [](int64_t lhs, int64_t rhs, bool* trap) {
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64RemS, [](int64_t lhs, int64_t rhs, bool* trap) {
         *trap = rhs == 0;
         return *trap || rhs == -1 ? 0 : lhs % rhs;
       });
@@ -3844,8 +3850,8 @@ WASM_EXEC_TEST(I64RemSOnDifferentRegisters) {
 
 WASM_EXEC_TEST(I64RemUOnDifferentRegisters) {
   BinOpOnDifferentRegisters<int64_t>(
-      execution_tier, kWasmI64, ArrayVector(kSome64BitInputs), kExprI64RemU,
-      [](uint64_t lhs, uint64_t rhs, bool* trap) {
+      execution_tier, kWasmI64, base::ArrayVector(kSome64BitInputs),
+      kExprI64RemU, [](uint64_t lhs, uint64_t rhs, bool* trap) {
         *trap = rhs == 0;
         return *trap ? 0 : lhs % rhs;
       });
diff --git a/test/cctest/wasm/test-streaming-compilation.cc b/test/cctest/wasm/test-streaming-compilation.cc
index 639bc66336..ab9fa788c2 100644
--- a/test/cctest/wasm/test-streaming-compilation.cc
+++ b/test/cctest/wasm/test-streaming-compilation.cc
@@ -4,10 +4,10 @@
 
 #include "include/libplatform/libplatform.h"
 #include "src/api/api-inl.h"
+#include "src/base/vector.h"
 #include "src/init/v8.h"
 #include "src/objects/managed.h"
 #include "src/objects/objects-inl.h"
-#include "src/utils/vector.h"
 #include "src/wasm/module-decoder.h"
 #include "src/wasm/streaming-decoder.h"
 #include "src/wasm/wasm-engine.h"
@@ -213,13 +213,13 @@ class StreamTester {
   bool IsPromisePending() { return state_ == CompilationState::kPending; }
 
   void OnBytesReceived(const uint8_t* start, size_t length) {
-    stream_->OnBytesReceived(Vector<const uint8_t>(start, length));
+    stream_->OnBytesReceived(base::Vector<const uint8_t>(start, length));
   }
 
   void FinishStream() { stream_->Finish(); }
 
   void SetCompiledModuleBytes(const uint8_t* start, size_t length) {
-    stream_->SetCompiledModuleBytes(Vector<const uint8_t>(start, length));
+    stream_->SetCompiledModuleBytes(base::Vector<const uint8_t>(start, length));
   }
 
   Zone* zone() { return &zone_; }
@@ -302,7 +302,7 @@ ZoneBuffer GetValidCompiledModuleBytes(v8::Isolate* isolate, Zone* zone,
   i::wasm::WasmSerializer serializer(native_module.get());
   size_t size = serializer.GetSerializedNativeModuleSize();
   std::vector<byte> buffer(size);
-  CHECK(serializer.SerializeNativeModule(VectorOf(buffer)));
+  CHECK(serializer.SerializeNativeModule(base::VectorOf(buffer)));
   ZoneBuffer result(zone, size);
   result.write(buffer.data(), size);
   return result;
@@ -1092,7 +1092,7 @@ STREAM_TEST(TestModuleWithImportedFunction) {
   ZoneBuffer buffer(tester.zone());
   TestSignatures sigs;
   WasmModuleBuilder builder(tester.zone());
-  builder.AddImport(ArrayVector("Test"), sigs.i_iii());
+  builder.AddImport(base::ArrayVector("Test"), sigs.i_iii());
   {
     WasmFunctionBuilder* f = builder.AddFunction(sigs.i_iii());
     uint8_t code[] = {kExprLocalGet, 0, kExprEnd};
@@ -1345,7 +1345,7 @@ STREAM_TEST(TestProfilingMidStreaming) {
     WasmFunctionBuilder* f = builder.AddFunction(sigs.v_v());
     uint8_t code[] = {kExprEnd};
     f->EmitCode(code, arraysize(code));
-    builder.AddExport(VectorOf("foo", 3), f);
+    builder.AddExport(base::VectorOf("foo", 3), f);
     builder.WriteTo(&buffer);
   }
 
diff --git a/test/cctest/wasm/test-wasm-metrics.cc b/test/cctest/wasm/test-wasm-metrics.cc
index b55b971b71..ea230a2641 100644
--- a/test/cctest/wasm/test-wasm-metrics.cc
+++ b/test/cctest/wasm/test-wasm-metrics.cc
@@ -278,7 +278,7 @@ COMPILE_TEST(TestEventMetrics) {
 
   WasmModuleBuilder* builder = zone.New<WasmModuleBuilder>(&zone);
   WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
-  f->builder()->AddExport(CStrVector("main"), f);
+  f->builder()->AddExport(base::CStrVector("main"), f);
   byte code[] = {WASM_I32V_2(0)};
   f->EmitCode(code, sizeof(code));
   f->Emit(kExprEnd);
diff --git a/test/cctest/wasm/test-wasm-serialization.cc b/test/cctest/wasm/test-wasm-serialization.cc
index 2f8f92b803..d612e70db9 100644
--- a/test/cctest/wasm/test-wasm-serialization.cc
+++ b/test/cctest/wasm/test-wasm-serialization.cc
@@ -43,7 +43,7 @@ class WasmSerializationTest {
     WasmFunctionBuilder* f = builder->AddFunction(sigs.i_i());
     byte code[] = {WASM_LOCAL_GET(0), kExprI32Const, 1, kExprI32Add, kExprEnd};
     f->EmitCode(code, sizeof(code));
-    builder->AddExport(CStrVector(kFunctionName), f);
+    builder->AddExport(base::CStrVector(kFunctionName), f);
 
     builder->WriteTo(buffer);
   }
@@ -62,10 +62,10 @@ class WasmSerializationTest {
   }
 
   MaybeHandle<WasmModuleObject> Deserialize(
-      Vector<const char> source_url = {}) {
+      base::Vector<const char> source_url = {}) {
     return DeserializeNativeModule(CcTest::i_isolate(),
-                                   VectorOf(serialized_bytes_),
-                                   VectorOf(wire_bytes_), source_url);
+                                   base::VectorOf(serialized_bytes_),
+                                   base::VectorOf(wire_bytes_), source_url);
   }
 
   void DeserializeAndRun() {
@@ -74,7 +74,7 @@ class WasmSerializationTest {
     CHECK(Deserialize().ToHandle(&module_object));
     {
       DisallowGarbageCollection assume_no_gc;
-      Vector<const byte> deserialized_module_wire_bytes =
+      base::Vector<const byte> deserialized_module_wire_bytes =
           module_object->native_module()->wire_bytes();
       CHECK_EQ(deserialized_module_wire_bytes.size(), wire_bytes_.size());
       CHECK_EQ(memcmp(deserialized_module_wire_bytes.begin(),
@@ -204,7 +204,7 @@ TEST(DeserializeWithSourceUrl) {
     HandleScope scope(CcTest::i_isolate());
     const std::string url = "http://example.com/example.wasm";
     Handle<WasmModuleObject> module_object;
-    CHECK(test.Deserialize(VectorOf(url)).ToHandle(&module_object));
+    CHECK(test.Deserialize(base::VectorOf(url)).ToHandle(&module_object));
     String url_str = String::cast(module_object->script().name());
     CHECK_EQ(url, url_str.ToCString().get());
   }
diff --git a/test/cctest/wasm/test-wasm-shared-engine.cc b/test/cctest/wasm/test-wasm-shared-engine.cc
index d6d9e40a04..54aaed61ad 100644
--- a/test/cctest/wasm/test-wasm-shared-engine.cc
+++ b/test/cctest/wasm/test-wasm-shared-engine.cc
@@ -106,7 +106,7 @@ ZoneBuffer* BuildReturnConstantModule(Zone* zone, int constant) {
   ZoneBuffer* buffer = zone->New<ZoneBuffer>(zone);
   WasmModuleBuilder* builder = zone->New<WasmModuleBuilder>(zone);
   WasmFunctionBuilder* f = builder->AddFunction(sigs.i_v());
-  f->builder()->AddExport(CStrVector("main"), f);
+  f->builder()->AddExport(base::CStrVector("main"), f);
   byte code[] = {WASM_I32V_2(constant)};
   f->EmitCode(code, sizeof(code));
   f->Emit(kExprEnd);
diff --git a/test/cctest/wasm/wasm-run-utils.cc b/test/cctest/wasm/wasm-run-utils.cc
index 6fdcdc4842..14049ee930 100644
--- a/test/cctest/wasm/wasm-run-utils.cc
+++ b/test/cctest/wasm/wasm-run-utils.cc
@@ -142,7 +142,8 @@ uint32_t TestingModuleBuilder::AddFunction(const FunctionSig* sig,
             test_module_->num_imported_functions +
                 test_module_->num_declared_functions);
   if (name) {
-    Vector<const byte> name_vec = Vector<const byte>::cast(CStrVector(name));
+    base::Vector<const byte> name_vec =
+        base::Vector<const byte>::cast(base::CStrVector(name));
     test_module_->lazily_generated_names.AddForTesting(
         index, {AddBytes(name_vec), static_cast<uint32_t>(name_vec.length())});
   }
@@ -222,14 +223,15 @@ void TestingModuleBuilder::AddIndirectFunctionTable(
   instance_object_->set_tables(*new_tables);
 }
 
-uint32_t TestingModuleBuilder::AddBytes(Vector<const byte> bytes) {
-  Vector<const uint8_t> old_bytes = native_module_->wire_bytes();
+uint32_t TestingModuleBuilder::AddBytes(base::Vector<const byte> bytes) {
+  base::Vector<const uint8_t> old_bytes = native_module_->wire_bytes();
   uint32_t old_size = static_cast<uint32_t>(old_bytes.size());
   // Avoid placing strings at offset 0, this might be interpreted as "not
   // set", e.g. for function names.
   uint32_t bytes_offset = old_size ? old_size : 1;
   size_t new_size = bytes_offset + bytes.size();
-  OwnedVector<uint8_t> new_bytes = OwnedVector<uint8_t>::New(new_size);
+  base::OwnedVector<uint8_t> new_bytes =
+      base::OwnedVector<uint8_t>::New(new_size);
   if (old_size > 0) {
     memcpy(new_bytes.start(), old_bytes.begin(), old_size);
   } else {
@@ -254,7 +256,8 @@ uint32_t TestingModuleBuilder::AddException(const FunctionSig* sig) {
   return index;
 }
 
-uint32_t TestingModuleBuilder::AddPassiveDataSegment(Vector<const byte> bytes) {
+uint32_t TestingModuleBuilder::AddPassiveDataSegment(
+    base::Vector<const byte> bytes) {
   uint32_t index = static_cast<uint32_t>(test_module_->data_segments.size());
   DCHECK_EQ(index, test_module_->data_segments.size());
   DCHECK_EQ(index, data_segment_starts_.size());
@@ -337,9 +340,9 @@ Handle<WasmInstanceObject> TestingModuleBuilder::InitInstanceObject() {
                                                           kUsesLiftoff);
   auto native_module = isolate_->wasm_engine()->NewNativeModule(
       isolate_, enabled_features_, test_module_, code_size_estimate);
-  native_module->SetWireBytes(OwnedVector<const uint8_t>());
+  native_module->SetWireBytes(base::OwnedVector<const uint8_t>());
   native_module->compilation_state()->set_compilation_id(0);
-  constexpr Vector<const char> kNoSourceUrl{"", 0};
+  constexpr base::Vector<const char> kNoSourceUrl{"", 0};
   Handle<Script> script = isolate_->wasm_engine()->GetOrCreateScript(
       isolate_, native_module, kNoSourceUrl);
 
@@ -409,7 +412,7 @@ WasmFunctionWrapper::WasmFunctionWrapper(Zone* zone, int num_params)
 
 void WasmFunctionWrapper::Init(CallDescriptor* call_descriptor,
                                MachineType return_type,
-                               Vector<MachineType> param_types) {
+                               base::Vector<MachineType> param_types) {
   DCHECK_NOT_NULL(call_descriptor);
   DCHECK_EQ(signature_->parameter_count(), param_types.length() + 1);
 
@@ -486,7 +489,7 @@ Handle<Code> WasmFunctionWrapper::GetWrapperCode(Isolate* isolate) {
       r.LowerGraph();
     }
 
-    OptimizedCompilationInfo info(ArrayVector("testing"), graph()->zone(),
+    OptimizedCompilationInfo info(base::ArrayVector("testing"), graph()->zone(),
                                   CodeKind::C_WASM_ENTRY);
     code_ = compiler::Pipeline::GenerateCodeForTesting(
         &info, isolate, call_descriptor, graph(),
@@ -524,7 +527,7 @@ void WasmFunctionCompiler::Build(const byte* start, const byte* end) {
 
   CHECK_GE(kMaxInt, end - start);
   int len = static_cast<int>(end - start);
-  function_->code = {builder_->AddBytes(Vector<const byte>(start, len)),
+  function_->code = {builder_->AddBytes(base::Vector<const byte>(start, len)),
                      static_cast<uint32_t>(len)};
 
   if (interpreter_) {
@@ -533,13 +536,13 @@ void WasmFunctionCompiler::Build(const byte* start, const byte* end) {
     return;
   }
 
-  Vector<const uint8_t> wire_bytes = builder_->instance_object()
-                                         ->module_object()
-                                         .native_module()
-                                         ->wire_bytes();
+  base::Vector<const uint8_t> wire_bytes = builder_->instance_object()
+                                               ->module_object()
+                                               .native_module()
+                                               ->wire_bytes();
 
   CompilationEnv env = builder_->CreateCompilationEnv();
-  ScopedVector<uint8_t> func_wire_bytes(function_->code.length());
+  base::ScopedVector<uint8_t> func_wire_bytes(function_->code.length());
   memcpy(func_wire_bytes.begin(), wire_bytes.begin() + function_->code.offset(),
          func_wire_bytes.length());
 
@@ -599,7 +602,7 @@ WasmFunctionCompiler::~WasmFunctionCompiler() = default;
 
 /* static */
 FunctionSig* WasmRunnerBase::CreateSig(Zone* zone, MachineType return_type,
-                                       Vector<MachineType> param_types) {
+                                       base::Vector<MachineType> param_types) {
   int return_count = return_type.IsNone() ? 0 : 1;
   int param_count = param_types.length();
 
diff --git a/test/cctest/wasm/wasm-run-utils.h b/test/cctest/wasm/wasm-run-utils.h
index a922250507..187b0179b7 100644
--- a/test/cctest/wasm/wasm-run-utils.h
+++ b/test/cctest/wasm/wasm-run-utils.h
@@ -207,11 +207,11 @@ class TestingModuleBuilder {
                                 uint32_t table_size,
                                 ValueType table_type = kWasmFuncRef);
 
-  uint32_t AddBytes(Vector<const byte> bytes);
+  uint32_t AddBytes(base::Vector<const byte> bytes);
 
   uint32_t AddException(const FunctionSig* sig);
 
-  uint32_t AddPassiveDataSegment(Vector<const byte> bytes);
+  uint32_t AddPassiveDataSegment(base::Vector<const byte> bytes);
   uint32_t AddPassiveElementSegment(const std::vector<uint32_t>& entries);
 
   WasmFunction* GetFunctionAt(int index) {
@@ -301,14 +301,14 @@ class WasmFunctionWrapper : private compiler::GraphAndBuilders {
   WasmFunctionWrapper(Zone* zone, int num_params);
 
   void Init(CallDescriptor* call_descriptor, MachineType return_type,
-            Vector<MachineType> param_types);
+            base::Vector<MachineType> param_types);
 
   template <typename ReturnType, typename... ParamTypes>
   void Init(CallDescriptor* call_descriptor) {
     std::array<MachineType, sizeof...(ParamTypes)> param_machine_types{
         {MachineTypeForC<ParamTypes>()...}};
-    Vector<MachineType> param_vec(param_machine_types.data(),
-                                  param_machine_types.size());
+    base::Vector<MachineType> param_vec(param_machine_types.data(),
+                                        param_machine_types.size());
     Init(call_descriptor, MachineTypeForC<ReturnType>(), param_vec);
   }
 
@@ -462,8 +462,8 @@ class WasmRunnerBase : public InitializedHandleScope {
   static FunctionSig* CreateSig(Zone* zone) {
     std::array<MachineType, sizeof...(ParamTypes)> param_machine_types{
         {MachineTypeForC<ParamTypes>()...}};
-    Vector<MachineType> param_vec(param_machine_types.data(),
-                                  param_machine_types.size());
+    base::Vector<MachineType> param_vec(param_machine_types.data(),
+                                        param_machine_types.size());
     return CreateSig(zone, MachineTypeForC<ReturnType>(), param_vec);
   }
 
@@ -506,7 +506,7 @@ class WasmRunnerBase : public InitializedHandleScope {
 
  private:
   static FunctionSig* CreateSig(Zone* zone, MachineType return_type,
-                                Vector<MachineType> param_types);
+                                base::Vector<MachineType> param_types);
 
  protected:
   wasm::WasmCodeRefScope code_ref_scope_;
diff --git a/test/common/wasm/wasm-module-runner.cc b/test/common/wasm/wasm-module-runner.cc
index 770b320dfd..50d5879217 100644
--- a/test/common/wasm/wasm-module-runner.cc
+++ b/test/common/wasm/wasm-module-runner.cc
@@ -42,10 +42,10 @@ MaybeHandle<WasmInstanceObject> CompileAndInstantiateForTesting(
       isolate, thrower, module.ToHandleChecked(), {}, {});
 }
 
-OwnedVector<WasmValue> MakeDefaultInterpreterArguments(Isolate* isolate,
-                                                       const FunctionSig* sig) {
+base::OwnedVector<WasmValue> MakeDefaultInterpreterArguments(
+    Isolate* isolate, const FunctionSig* sig) {
   size_t param_count = sig->parameter_count();
-  auto arguments = OwnedVector<WasmValue>::New(param_count);
+  auto arguments = base::OwnedVector<WasmValue>::New(param_count);
 
   for (size_t i = 0; i < param_count; ++i) {
     switch (sig->GetParam(i).kind()) {
@@ -83,10 +83,10 @@ OwnedVector<WasmValue> MakeDefaultInterpreterArguments(Isolate* isolate,
   return arguments;
 }
 
-OwnedVector<Handle<Object>> MakeDefaultArguments(Isolate* isolate,
-                                                 const FunctionSig* sig) {
+base::OwnedVector<Handle<Object>> MakeDefaultArguments(Isolate* isolate,
+                                                       const FunctionSig* sig) {
   size_t param_count = sig->parameter_count();
-  auto arguments = OwnedVector<Handle<Object>>::New(param_count);
+  auto arguments = base::OwnedVector<Handle<Object>>::New(param_count);
 
   for (size_t i = 0; i < param_count; ++i) {
     switch (sig->GetParam(i).kind()) {
diff --git a/test/common/wasm/wasm-module-runner.h b/test/common/wasm/wasm-module-runner.h
index cf1f74756c..398c522600 100644
--- a/test/common/wasm/wasm-module-runner.h
+++ b/test/common/wasm/wasm-module-runner.h
@@ -101,15 +101,15 @@ WasmInterpretationResult InterpretWasmModule(
 
 // Generate an array of default arguments for the given signature, to be used in
 // the interpreter.
-OwnedVector<WasmValue> MakeDefaultInterpreterArguments(Isolate* isolate,
-                                                       const FunctionSig* sig);
+base::OwnedVector<WasmValue> MakeDefaultInterpreterArguments(
+    Isolate* isolate, const FunctionSig* sig);
 
 // Generate an array of default arguments for the given signature, to be used
 // when calling compiled code. Make sure that the arguments match the ones
 // returned by {MakeDefaultInterpreterArguments}, otherwise fuzzers will report
 // differences between interpreter and compiled code.
-OwnedVector<Handle<Object>> MakeDefaultArguments(Isolate* isolate,
-                                                 const FunctionSig* sig);
+base::OwnedVector<Handle<Object>> MakeDefaultArguments(Isolate* isolate,
+                                                       const FunctionSig* sig);
 
 // Install function map, module symbol for testing
 void SetupIsolateForWasmModule(Isolate* isolate);
diff --git a/test/fuzzer/inspector-fuzzer.cc b/test/fuzzer/inspector-fuzzer.cc
index 60d074418e..c617248db6 100644
--- a/test/fuzzer/inspector-fuzzer.cc
+++ b/test/fuzzer/inspector-fuzzer.cc
@@ -16,11 +16,11 @@
 #include "src/base/platform/platform.h"
 #include "src/base/platform/time.h"
 #include "src/base/small-vector.h"
+#include "src/base/vector.h"
 #include "src/flags/flags.h"
 #include "src/heap/read-only-heap.h"
 #include "src/libplatform/default-platform.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 #include "test/inspector/frontend-channel.h"
 #include "test/inspector/isolate-data.h"
 #include "test/inspector/task-runner.h"
@@ -541,7 +541,7 @@ class InspectorExtension : public IsolateData::SetupGlobalTask {
   }
 };
 
-using CharVector = v8::internal::Vector<const char>;
+using CharVector = v8::base::Vector<const char>;
 
 constexpr auto kMaxExecutionSeconds = v8::base::TimeDelta::FromSeconds(2);
 
diff --git a/test/fuzzer/multi-return.cc b/test/fuzzer/multi-return.cc
index 58b4510160..aef21d8793 100644
--- a/test/fuzzer/multi-return.cc
+++ b/test/fuzzer/multi-return.cc
@@ -239,7 +239,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   }
   callee.Return(static_cast<int>(desc->ReturnCount()), returns.get());
 
-  OptimizedCompilationInfo info(ArrayVector("testing"), &zone,
+  OptimizedCompilationInfo info(base::ArrayVector("testing"), &zone,
                                 CodeKind::FOR_TESTING);
   Handle<Code> code =
       Pipeline::GenerateCodeForTesting(&info, i_isolate, desc, callee.graph(),
@@ -285,7 +285,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   caller.Return(ret);
 
   // Call the wrapper.
-  OptimizedCompilationInfo wrapper_info(ArrayVector("wrapper"), &zone,
+  OptimizedCompilationInfo wrapper_info(base::ArrayVector("wrapper"), &zone,
                                         CodeKind::FOR_TESTING);
   Handle<Code> wrapper_code =
       Pipeline::GenerateCodeForTesting(
diff --git a/test/fuzzer/parser.cc b/test/fuzzer/parser.cc
index a02e52c626..2075075ab4 100644
--- a/test/fuzzer/parser.cc
+++ b/test/fuzzer/parser.cc
@@ -75,7 +75,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   if (size > INT_MAX) return 0;
   v8::internal::MaybeHandle<v8::internal::String> source =
       factory->NewStringFromOneByte(
-          v8::internal::Vector<const uint8_t>(data, static_cast<int>(size)));
+          v8::base::Vector<const uint8_t>(data, static_cast<int>(size)));
   if (source.is_null()) return 0;
 
   v8::internal::Handle<v8::internal::Script> script =
diff --git a/test/fuzzer/regexp.cc b/test/fuzzer/regexp.cc
index c7b2f146d2..3b8750c6aa 100644
--- a/test/fuzzer/regexp.cc
+++ b/test/fuzzer/regexp.cc
@@ -39,7 +39,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   CHECK(!i_isolate->has_pending_exception());
   if (size > INT_MAX) return 0;
   i::MaybeHandle<i::String> maybe_source = factory->NewStringFromOneByte(
-      i::Vector<const uint8_t>(data, static_cast<int>(size)));
+      v8::base::Vector<const uint8_t>(data, static_cast<int>(size)));
   i::Handle<i::String> source;
   if (!maybe_source.ToHandle(&source)) {
     i_isolate->clear_pending_exception();
@@ -56,10 +56,14 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
   CHECK(!i_isolate->has_pending_exception());
   i::Handle<i::RegExpMatchInfo> results_array = factory->NewRegExpMatchInfo();
   i::Handle<i::String> one_byte =
-      factory->NewStringFromOneByte(i::Vector<const uint8_t>(one_byte_array, 6))
+      factory
+          ->NewStringFromOneByte(
+              v8::base::Vector<const uint8_t>(one_byte_array, 6))
           .ToHandleChecked();
   i::Handle<i::String> two_byte =
-      factory->NewStringFromTwoByte(i::Vector<const i::uc16>(two_byte_array, 6))
+      factory
+          ->NewStringFromTwoByte(
+              v8::base::Vector<const i::uc16>(two_byte_array, 6))
           .ToHandleChecked();
 
   i::Handle<i::JSRegExp> regexp;
diff --git a/test/fuzzer/wasm-code.cc b/test/fuzzer/wasm-code.cc
index e5d3bbe8e7..00a66b2dcf 100644
--- a/test/fuzzer/wasm-code.cc
+++ b/test/fuzzer/wasm-code.cc
@@ -19,7 +19,7 @@ namespace fuzzer {
 
 class WasmCodeFuzzer : public WasmExecutionFuzzer {
   bool GenerateModule(
-      Isolate* isolate, Zone* zone, Vector<const uint8_t> data,
+      Isolate* isolate, Zone* zone, base::Vector<const uint8_t> data,
       ZoneBuffer* buffer, int32_t* num_args,
       std::unique_ptr<WasmValue[]>* interpreter_args,
       std::unique_ptr<Handle<Object>[]>* compiler_args) override {
@@ -29,7 +29,7 @@ class WasmCodeFuzzer : public WasmExecutionFuzzer {
     f->EmitCode(data.begin(), static_cast<uint32_t>(data.size()));
     uint8_t end_opcode = kExprEnd;
     f->EmitCode(&end_opcode, 1);
-    builder.AddExport(CStrVector("main"), f);
+    builder.AddExport(base::CStrVector("main"), f);
 
     builder.SetMaxMemorySize(32);
     builder.WriteTo(buffer);
diff --git a/test/fuzzer/wasm-compile.cc b/test/fuzzer/wasm-compile.cc
index 0fd2cdd247..13c6e137e1 100644
--- a/test/fuzzer/wasm-compile.cc
+++ b/test/fuzzer/wasm-compile.cc
@@ -37,10 +37,10 @@ constexpr int kMaxReturns = 15;
 constexpr int kMaxExceptions = 4;
 
 class DataRange {
-  Vector<const uint8_t> data_;
+  base::Vector<const uint8_t> data_;
 
  public:
-  explicit DataRange(Vector<const uint8_t> data) : data_(data) {}
+  explicit DataRange(base::Vector<const uint8_t> data) : data_(data) {}
   DataRange(const DataRange&) = delete;
   DataRange& operator=(const DataRange&) = delete;
 
@@ -116,9 +116,9 @@ class WasmGenerator {
   class V8_NODISCARD BlockScope {
    public:
     BlockScope(WasmGenerator* gen, WasmOpcode block_type,
-               Vector<const ValueType> param_types,
-               Vector<const ValueType> result_types,
-               Vector<const ValueType> br_types, bool emit_end = true)
+               base::Vector<const ValueType> param_types,
+               base::Vector<const ValueType> result_types,
+               base::Vector<const ValueType> br_types, bool emit_end = true)
         : gen_(gen), emit_end_(emit_end) {
       gen->blocks_.emplace_back(br_types.begin(), br_types.end());
       if (param_types.size() == 0 && result_types.size() == 0) {
@@ -157,8 +157,8 @@ class WasmGenerator {
     bool emit_end_;
   };
 
-  void block(Vector<const ValueType> param_types,
-             Vector<const ValueType> return_types, DataRange* data) {
+  void block(base::Vector<const ValueType> param_types,
+             base::Vector<const ValueType> return_types, DataRange* data) {
     BlockScope block_scope(this, kExprBlock, param_types, return_types,
                            return_types);
     ConsumeAndGenerate(param_types, return_types, data);
@@ -166,11 +166,11 @@ class WasmGenerator {
 
   template <ValueKind T>
   void block(DataRange* data) {
-    block({}, VectorOf({ValueType::Primitive(T)}), data);
+    block({}, base::VectorOf({ValueType::Primitive(T)}), data);
   }
 
-  void loop(Vector<const ValueType> param_types,
-            Vector<const ValueType> return_types, DataRange* data) {
+  void loop(base::Vector<const ValueType> param_types,
+            base::Vector<const ValueType> return_types, DataRange* data) {
     BlockScope block_scope(this, kExprLoop, param_types, return_types,
                            param_types);
     ConsumeAndGenerate(param_types, return_types, data);
@@ -178,13 +178,14 @@ class WasmGenerator {
 
   template <ValueKind T>
   void loop(DataRange* data) {
-    loop({}, VectorOf({ValueType::Primitive(T)}), data);
+    loop({}, base::VectorOf({ValueType::Primitive(T)}), data);
   }
 
   enum IfType { kIf, kIfElse };
 
-  void if_(Vector<const ValueType> param_types,
-           Vector<const ValueType> return_types, IfType type, DataRange* data) {
+  void if_(base::Vector<const ValueType> param_types,
+           base::Vector<const ValueType> return_types, IfType type,
+           DataRange* data) {
     // One-armed "if" are only valid if the input and output types are the same.
     DCHECK_IMPLIES(type == kIf, param_types == return_types);
     Generate(kWasmI32, data);
@@ -202,7 +203,8 @@ class WasmGenerator {
     static_assert(T == kVoid || type == kIfElse,
                   "if without else cannot produce a value");
     if_({},
-        T == kVoid ? Vector<ValueType>{} : VectorOf({ValueType::Primitive(T)}),
+        T == kVoid ? base::Vector<ValueType>{}
+                   : base::VectorOf({ValueType::Primitive(T)}),
         type, data);
   }
 
@@ -216,9 +218,9 @@ class WasmGenerator {
     // to the caller.
     uint8_t delegate_target = data->get<uint8_t>() % (try_blocks_.size() + 1);
 
-    Vector<const ValueType> return_type_vec = return_type.kind() == kVoid
-                                                  ? Vector<ValueType>{}
-                                                  : VectorOf(&return_type, 1);
+    base::Vector<const ValueType> return_type_vec =
+        return_type.kind() == kVoid ? base::Vector<ValueType>{}
+                                    : base::VectorOf(&return_type, 1);
     BlockScope block_scope(this, kExprTry, {}, return_type_vec, return_type_vec,
                            !is_delegate);
     int control_depth = static_cast<int>(blocks_.size()) - 1;
@@ -229,8 +231,9 @@ class WasmGenerator {
     for (int i = 0; i < num_catch; ++i) {
       const FunctionSig* exception_type =
           builder_->builder()->GetExceptionType(i);
-      auto exception_type_vec = VectorOf(exception_type->parameters().begin(),
-                                         exception_type->parameter_count());
+      auto exception_type_vec =
+          base::VectorOf(exception_type->parameters().begin(),
+                         exception_type->parameter_count());
       builder_->EmitWithU32V(kExprCatch, i);
       ConsumeAndGenerate(exception_type_vec, return_type_vec, data);
     }
@@ -255,8 +258,8 @@ class WasmGenerator {
     try_block_helper(ValueType::Primitive(T), data);
   }
 
-  void any_block(Vector<const ValueType> param_types,
-                 Vector<const ValueType> return_types, DataRange* data) {
+  void any_block(base::Vector<const ValueType> param_types,
+                 base::Vector<const ValueType> return_types, DataRange* data) {
     uint8_t block_type = data->get<uint8_t>() % 4;
     switch (block_type) {
       case 0:
@@ -283,7 +286,7 @@ class WasmGenerator {
     const uint32_t target_block = data->get<uint32_t>() % blocks_.size();
     const auto break_types = blocks_[target_block];
 
-    Generate(VectorOf(break_types), data);
+    Generate(base::VectorOf(break_types), data);
     builder_->EmitWithI32V(
         kExprBr, static_cast<uint32_t>(blocks_.size()) - 1 - target_block);
   }
@@ -293,17 +296,18 @@ class WasmGenerator {
     // There is always at least the block representing the function body.
     DCHECK(!blocks_.empty());
     const uint32_t target_block = data->get<uint32_t>() % blocks_.size();
-    const auto break_types = VectorOf(blocks_[target_block]);
+    const auto break_types = base::VectorOf(blocks_[target_block]);
 
     Generate(break_types, data);
     Generate(kWasmI32, data);
     builder_->EmitWithI32V(
         kExprBrIf, static_cast<uint32_t>(blocks_.size()) - 1 - target_block);
-    ConsumeAndGenerate(break_types,
-                       wanted_kind == kVoid
-                           ? Vector<ValueType>{}
-                           : VectorOf({ValueType::Primitive(wanted_kind)}),
-                       data);
+    ConsumeAndGenerate(
+        break_types,
+        wanted_kind == kVoid
+            ? base::Vector<ValueType>{}
+            : base::VectorOf({ValueType::Primitive(wanted_kind)}),
+        data);
   }
 
   // TODO(eholk): make this function constexpr once gcc supports it
@@ -586,9 +590,10 @@ class WasmGenerator {
       }
       return;
     }
-    auto return_types = VectorOf(sig->returns().begin(), sig->return_count());
+    auto return_types =
+        base::VectorOf(sig->returns().begin(), sig->return_count());
     auto wanted_types =
-        VectorOf(&wanted_kind, wanted_kind == kWasmVoid ? 0 : 1);
+        base::VectorOf(&wanted_kind, wanted_kind == kWasmVoid ? 0 : 1);
     ConsumeAndGenerate(return_types, wanted_types, data);
   }
 
@@ -712,7 +717,7 @@ class WasmGenerator {
     } else {
       int tag = data->get<uint8_t>() % builder_->builder()->NumExceptions();
       FunctionSig* exception_sig = builder_->builder()->GetExceptionType(tag);
-      Vector<const ValueType> exception_types(
+      base::Vector<const ValueType> exception_types(
           exception_sig->parameters().begin(),
           exception_sig->parameter_count());
       Generate(exception_types, data);
@@ -791,9 +796,9 @@ class WasmGenerator {
   }
 
   std::vector<ValueType> GenerateTypes(DataRange* data);
-  void Generate(Vector<const ValueType> types, DataRange* data);
-  void ConsumeAndGenerate(Vector<const ValueType> parameter_types,
-                          Vector<const ValueType> return_types,
+  void Generate(base::Vector<const ValueType> types, DataRange* data);
+  void ConsumeAndGenerate(base::Vector<const ValueType> parameter_types,
+                          base::Vector<const ValueType> return_types,
                           DataRange* data);
   bool HasSimd() { return has_simd_; }
 
@@ -1533,7 +1538,8 @@ std::vector<ValueType> WasmGenerator::GenerateTypes(DataRange* data) {
   return types;
 }
 
-void WasmGenerator::Generate(Vector<const ValueType> types, DataRange* data) {
+void WasmGenerator::Generate(base::Vector<const ValueType> types,
+                             DataRange* data) {
   // Maybe emit a multi-value block with the expected return type. Use a
   // non-default value to indicate block generation to avoid recursion when we
   // reach the end of the data.
@@ -1542,8 +1548,8 @@ void WasmGenerator::Generate(Vector<const ValueType> types, DataRange* data) {
     GeneratorRecursionScope rec_scope(this);
     if (!recursion_limit_reached()) {
       const auto param_types = GenerateTypes(data);
-      Generate(VectorOf(param_types), data);
-      any_block(VectorOf(param_types), types, data);
+      Generate(base::VectorOf(param_types), data);
+      any_block(base::VectorOf(param_types), types, data);
       return;
     }
   }
@@ -1560,8 +1566,8 @@ void WasmGenerator::Generate(Vector<const ValueType> types, DataRange* data) {
   // Split the types in two halves and recursively generate each half.
   // Each half is non empty to ensure termination.
   size_t split_index = data->get<uint8_t>() % (types.size() - 1) + 1;
-  Vector<const ValueType> lower_half = types.SubVector(0, split_index);
-  Vector<const ValueType> upper_half =
+  base::Vector<const ValueType> lower_half = types.SubVector(0, split_index);
+  base::Vector<const ValueType> upper_half =
       types.SubVector(split_index, types.size());
   DataRange first_range = data->split();
   Generate(lower_half, &first_range);
@@ -1569,9 +1575,9 @@ void WasmGenerator::Generate(Vector<const ValueType> types, DataRange* data) {
 }
 
 // Emit code to match an arbitrary signature.
-void WasmGenerator::ConsumeAndGenerate(Vector<const ValueType> param_types,
-                                       Vector<const ValueType> return_types,
-                                       DataRange* data) {
+void WasmGenerator::ConsumeAndGenerate(
+    base::Vector<const ValueType> param_types,
+    base::Vector<const ValueType> return_types, DataRange* data) {
   if (param_types.size() == 0) {
     Generate(return_types, data);
     return;
@@ -1617,7 +1623,7 @@ FunctionSig* GenerateSig(Zone* zone, DataRange* data, SigKind sig_kind) {
 
 class WasmCompileFuzzer : public WasmExecutionFuzzer {
   bool GenerateModule(
-      Isolate* isolate, Zone* zone, Vector<const uint8_t> data,
+      Isolate* isolate, Zone* zone, base::Vector<const uint8_t> data,
       ZoneBuffer* buffer, int32_t* num_args,
       std::unique_ptr<WasmValue[]>* interpreter_args,
       std::unique_ptr<Handle<Object>[]>* compiler_args) override {
@@ -1668,12 +1674,12 @@ class WasmCompileFuzzer : public WasmExecutionFuzzer {
 
       WasmGenerator gen(f, function_signatures, globals, mutable_globals,
                         &function_range);
-      Vector<const ValueType> return_types(sig->returns().begin(),
-                                           sig->return_count());
+      base::Vector<const ValueType> return_types(sig->returns().begin(),
+                                                 sig->return_count());
       gen.Generate(return_types, &function_range);
       if (!CheckHardwareSupportsSimd() && gen.HasSimd()) return false;
       f->Emit(kExprEnd);
-      if (i == 0) builder.AddExport(CStrVector("main"), f);
+      if (i == 0) builder.AddExport(base::CStrVector("main"), f);
     }
 
     builder.AllocateIndirectFunctions(num_functions);
diff --git a/test/fuzzer/wasm-fuzzer-common.cc b/test/fuzzer/wasm-fuzzer-common.cc
index fa33a898a2..8cdd212918 100644
--- a/test/fuzzer/wasm-fuzzer-common.cc
+++ b/test/fuzzer/wasm-fuzzer-common.cc
@@ -55,7 +55,7 @@ void InterpretAndExecuteModule(i::Isolate* isolate,
     return;
   }
 
-  OwnedVector<WasmValue> arguments =
+  base::OwnedVector<WasmValue> arguments =
       testing::MakeDefaultInterpreterArguments(isolate, main_function->sig());
 
   // Now interpret.
@@ -83,7 +83,7 @@ void InterpretAndExecuteModule(i::Isolate* isolate,
               .ToHandle(&instance));
   }
 
-  OwnedVector<Handle<Object>> compiled_args =
+  base::OwnedVector<Handle<Object>> compiled_args =
       testing::MakeDefaultArguments(isolate, main_function->sig());
 
   bool exception = false;
@@ -298,7 +298,7 @@ void GenerateTestCase(Isolate* isolate, ModuleWireBytes wire_bytes,
   }
 
   for (const WasmFunction& func : module->functions) {
-    Vector<const uint8_t> func_code = wire_bytes.GetFunctionBytes(&func);
+    base::Vector<const uint8_t> func_code = wire_bytes.GetFunctionBytes(&func);
     os << "// Generate function " << (func.func_index + 1) << " (out of "
        << module->functions.size() << ").\n";
 
@@ -362,7 +362,7 @@ void OneTimeEnableStagedWasmFeatures(v8::Isolate* isolate) {
   static EnableStagedWasmFeatures one_time_enable_staged_features(isolate);
 }
 
-void WasmExecutionFuzzer::FuzzWasmModule(Vector<const uint8_t> data,
+void WasmExecutionFuzzer::FuzzWasmModule(base::Vector<const uint8_t> data,
                                          bool require_valid) {
   v8_fuzzer::FuzzerSupport* support = v8_fuzzer::FuzzerSupport::Get();
   v8::Isolate* isolate = support->GetIsolate();
diff --git a/test/fuzzer/wasm-fuzzer-common.h b/test/fuzzer/wasm-fuzzer-common.h
index 04350e3d80..e570215310 100644
--- a/test/fuzzer/wasm-fuzzer-common.h
+++ b/test/fuzzer/wasm-fuzzer-common.h
@@ -38,13 +38,14 @@ void OneTimeEnableStagedWasmFeatures(v8::Isolate* isolate);
 class WasmExecutionFuzzer {
  public:
   virtual ~WasmExecutionFuzzer() = default;
-  void FuzzWasmModule(Vector<const uint8_t> data, bool require_valid = false);
+  void FuzzWasmModule(base::Vector<const uint8_t> data,
+                      bool require_valid = false);
 
   virtual size_t max_input_size() const { return 512; }
 
  protected:
   virtual bool GenerateModule(
-      Isolate* isolate, Zone* zone, Vector<const uint8_t> data,
+      Isolate* isolate, Zone* zone, base::Vector<const uint8_t> data,
       ZoneBuffer* buffer, int32_t* num_args,
       std::unique_ptr<WasmValue[]>* interpreter_args,
       std::unique_ptr<Handle<Object>[]>* compiler_args) = 0;
diff --git a/test/inspector/inspector-test.cc b/test/inspector/inspector-test.cc
index 86e790136b..b04d2958ae 100644
--- a/test/inspector/inspector-test.cc
+++ b/test/inspector/inspector-test.cc
@@ -15,10 +15,10 @@
 #include "include/v8.h"
 #include "src/base/platform/platform.h"
 #include "src/base/small-vector.h"
+#include "src/base/vector.h"
 #include "src/flags/flags.h"
 #include "src/heap/read-only-heap.h"
 #include "src/utils/utils.h"
-#include "src/utils/vector.h"
 #include "test/inspector/frontend-channel.h"
 #include "test/inspector/isolate-data.h"
 #include "test/inspector/task-runner.h"
diff --git a/test/inspector/isolate-data.cc b/test/inspector/isolate-data.cc
index 465c138e07..df4e62951e 100644
--- a/test/inspector/isolate-data.cc
+++ b/test/inspector/isolate-data.cc
@@ -4,8 +4,8 @@
 
 #include "test/inspector/isolate-data.h"
 
+#include "src/base/vector.h"
 #include "src/inspector/test-interface.h"
-#include "src/utils/vector.h"
 #include "test/inspector/task-runner.h"
 #include "test/inspector/utils.h"
 
diff --git a/test/inspector/isolate-data.h b/test/inspector/isolate-data.h
index 535dad3ad1..eb6ed56ef7 100644
--- a/test/inspector/isolate-data.h
+++ b/test/inspector/isolate-data.h
@@ -13,7 +13,7 @@
 #include "include/v8.h"
 #include "src/base/macros.h"
 #include "src/base/platform/platform.h"
-#include "src/utils/vector.h"
+#include "src/base/vector.h"
 
 namespace v8 {
 namespace internal {
diff --git a/test/inspector/task-runner.h b/test/inspector/task-runner.h
index 61bb225692..db99f15e22 100644
--- a/test/inspector/task-runner.h
+++ b/test/inspector/task-runner.h
@@ -13,8 +13,8 @@
 #include "include/v8.h"
 #include "src/base/macros.h"
 #include "src/base/platform/platform.h"
+#include "src/base/vector.h"
 #include "src/utils/locked-queue-inl.h"
-#include "src/utils/vector.h"
 #include "test/inspector/isolate-data.h"
 
 namespace v8 {
diff --git a/test/unittests/BUILD.gn b/test/unittests/BUILD.gn
index f47b499413..c115daa047 100644
--- a/test/unittests/BUILD.gn
+++ b/test/unittests/BUILD.gn
@@ -229,6 +229,7 @@ v8_source_set("unittests_sources") {
     "base/template-utils-unittest.cc",
     "base/threaded-list-unittest.cc",
     "base/utils/random-number-generator-unittest.cc",
+    "base/vector-unittest.cc",
     "base/vlq-base64-unittest.cc",
     "base/vlq-unittest.cc",
     "codegen/aligned-slot-allocator-unittest.cc",
@@ -386,7 +387,6 @@ v8_source_set("unittests_sources") {
     "utils/detachable-vector-unittest.cc",
     "utils/locked-queue-unittest.cc",
     "utils/utils-unittest.cc",
-    "utils/vector-unittest.cc",
     "zone/zone-allocator-unittest.cc",
     "zone/zone-chunk-list-unittest.cc",
     "zone/zone-unittest.cc",
diff --git a/test/unittests/utils/vector-unittest.cc b/test/unittests/base/vector-unittest.cc
similarity index 69%
rename from test/unittests/utils/vector-unittest.cc
rename to test/unittests/base/vector-unittest.cc
index 6f7d6ccac3..8984e678bd 100644
--- a/test/unittests/utils/vector-unittest.cc
+++ b/test/unittests/base/vector-unittest.cc
@@ -2,53 +2,54 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "src/base/vector.h"
+
 #include <algorithm>
 
-#include "src/utils/utils.h"
 #include "testing/gmock-support.h"
 #include "testing/gtest-support.h"
 
 namespace v8 {
-namespace internal {
+namespace base {
 
 TEST(VectorTest, Factories) {
-  auto vec = CStrVector("foo");
+  auto vec = base::CStrVector("foo");
   EXPECT_EQ(3u, vec.size());
   EXPECT_EQ(0, memcmp(vec.begin(), "foo", 3));
 
-  vec = ArrayVector("foo");
+  vec = base::ArrayVector("foo");
   EXPECT_EQ(4u, vec.size());
   EXPECT_EQ(0, memcmp(vec.begin(), "foo\0", 4));
 
-  vec = CStrVector("foo\0\0");
+  vec = base::CStrVector("foo\0\0");
   EXPECT_EQ(3u, vec.size());
   EXPECT_EQ(0, memcmp(vec.begin(), "foo", 3));
 
-  vec = CStrVector("");
+  vec = base::CStrVector("");
   EXPECT_EQ(0u, vec.size());
 
-  vec = CStrVector("\0");
+  vec = base::CStrVector("\0");
   EXPECT_EQ(0u, vec.size());
 }
 
 // Test operator== and operator!= on different Vector types.
 TEST(VectorTest, Equals) {
-  auto foo1 = CStrVector("foo");
-  auto foo2 = ArrayVector("ffoo") + 1;
+  auto foo1 = base::CStrVector("foo");
+  auto foo2 = base::ArrayVector("ffoo") + 1;
   EXPECT_EQ(4u, foo2.size());  // Includes trailing '\0'.
   foo2.Truncate(foo2.size() - 1);
   // This is a requirement for the test.
   EXPECT_NE(foo1.begin(), foo2.begin());
   EXPECT_EQ(foo1, foo2);
 
-  // Compare Vector<char> against Vector<const char>.
+  // Compare base::Vector<char> against base::Vector<const char>.
   char arr1[] = {'a', 'b', 'c'};
   char arr2[] = {'a', 'b', 'c'};
   char arr3[] = {'a', 'b', 'd'};
-  Vector<char> vec1_char = ArrayVector(arr1);
-  Vector<const char> vec1_const_char = vec1_char;
-  Vector<char> vec2_char = ArrayVector(arr2);
-  Vector<char> vec3_char = ArrayVector(arr3);
+  base::Vector<char> vec1_char = base::ArrayVector(arr1);
+  base::Vector<const char> vec1_const_char = vec1_char;
+  base::Vector<char> vec2_char = base::ArrayVector(arr2);
+  base::Vector<char> vec3_char = base::ArrayVector(arr3);
   EXPECT_NE(vec1_char.begin(), vec2_char.begin());
   // Note: We directly call operator== and operator!= here (without EXPECT_EQ or
   // EXPECT_NE) to have full control over the arguments.
@@ -61,37 +62,37 @@ TEST(VectorTest, Equals) {
 }
 
 TEST(OwnedVectorConstruction, Equals) {
-  auto int_vec = OwnedVector<int>::New(4);
+  auto int_vec = base::OwnedVector<int>::New(4);
   EXPECT_EQ(4u, int_vec.size());
   auto find_non_zero = [](int i) { return i != 0; };
   EXPECT_EQ(int_vec.end(),
             std::find_if(int_vec.begin(), int_vec.end(), find_non_zero));
 
   constexpr int kInit[] = {4, 11, 3};
-  auto init_vec1 = OwnedVector<int>::Of(kInit);
+  auto init_vec1 = base::OwnedVector<int>::Of(kInit);
   // Note: {const int} should also work: We initialize the owned vector, but
   // afterwards it's non-modifyable.
-  auto init_vec2 = OwnedVector<const int>::Of(ArrayVector(kInit));
-  EXPECT_EQ(init_vec1.as_vector(), ArrayVector(kInit));
+  auto init_vec2 = base::OwnedVector<const int>::Of(base::ArrayVector(kInit));
+  EXPECT_EQ(init_vec1.as_vector(), base::ArrayVector(kInit));
   EXPECT_EQ(init_vec1.as_vector(), init_vec2.as_vector());
 }
 
 // Test that the constexpr factory methods work.
 TEST(VectorTest, ConstexprFactories) {
   static constexpr int kInit1[] = {4, 11, 3};
-  static constexpr auto kVec1 = ArrayVector(kInit1);
+  static constexpr auto kVec1 = base::ArrayVector(kInit1);
   STATIC_ASSERT(kVec1.size() == 3);
   EXPECT_THAT(kVec1, testing::ElementsAreArray(kInit1));
 
-  static constexpr auto kVec2 = VectorOf(kInit1, 2);
+  static constexpr auto kVec2 = base::VectorOf(kInit1, 2);
   STATIC_ASSERT(kVec2.size() == 2);
   EXPECT_THAT(kVec2, testing::ElementsAre(4, 11));
 
   static constexpr const char kInit3[] = "foobar";
-  static constexpr auto kVec3 = StaticCharVector(kInit3);
+  static constexpr auto kVec3 = base::StaticCharVector(kInit3);
   STATIC_ASSERT(kVec3.size() == 6);
   EXPECT_THAT(kVec3, testing::ElementsAreArray(kInit3, kInit3 + 6));
 }
 
-}  // namespace internal
+}  // namespace base
 }  // namespace v8
diff --git a/test/unittests/heap/local-factory-unittest.cc b/test/unittests/heap/local-factory-unittest.cc
index bd8e5db0a7..692bb65281 100644
--- a/test/unittests/heap/local-factory-unittest.cc
+++ b/test/unittests/heap/local-factory-unittest.cc
@@ -39,8 +39,8 @@ namespace {
 std::vector<uint16_t> DecodeUtf8(const std::string& string) {
   if (string.empty()) return {};
 
-  auto utf8_data =
-      Vector<const uint8_t>::cast(VectorOf(string.data(), string.length()));
+  auto utf8_data = base::Vector<const uint8_t>::cast(
+      base::VectorOf(string.data(), string.length()));
   Utf8Decoder decoder(utf8_data);
 
   std::vector<uint16_t> utf16(decoder.utf16_length());
@@ -70,8 +70,9 @@ class LocalFactoryTest : public TestWithIsolateAndZone {
 
     // Normally this would be an external string or whatever, we don't have to
     // worry about it for now.
-    source_string_ =
-        factory()->NewStringFromUtf8(CStrVector(source)).ToHandleChecked();
+    source_string_ = factory()
+                         ->NewStringFromUtf8(base::CStrVector(source))
+                         .ToHandleChecked();
 
     parse_info_.set_character_stream(
         ScannerStream::ForTesting(utf16_source.data(), utf16_source.size()));
@@ -117,7 +118,7 @@ class LocalFactoryTest : public TestWithIsolateAndZone {
 };
 
 TEST_F(LocalFactoryTest, OneByteInternalizedString_IsAddedToStringTable) {
-  Vector<const uint8_t> string_vector = StaticOneByteVector("foo");
+  base::Vector<const uint8_t> string_vector = base::StaticOneByteVector("foo");
 
   Handle<String> string;
   {
@@ -129,7 +130,7 @@ TEST_F(LocalFactoryTest, OneByteInternalizedString_IsAddedToStringTable) {
     string = local_isolate()->heap()->NewPersistentHandle(local_string);
   }
 
-  EXPECT_TRUE(string->IsOneByteEqualTo(CStrVector("foo")));
+  EXPECT_TRUE(string->IsOneByteEqualTo(base::CStrVector("foo")));
   EXPECT_TRUE(string->IsInternalizedString());
 
   Handle<String> same_string = isolate()
@@ -145,7 +146,7 @@ TEST_F(LocalFactoryTest, OneByteInternalizedString_IsAddedToStringTable) {
 }
 
 TEST_F(LocalFactoryTest, OneByteInternalizedString_DuplicateIsDeduplicated) {
-  Vector<const uint8_t> string_vector = StaticOneByteVector("foo");
+  base::Vector<const uint8_t> string_vector = base::StaticOneByteVector("foo");
 
   Handle<String> string_1;
   Handle<String> string_2;
@@ -161,7 +162,7 @@ TEST_F(LocalFactoryTest, OneByteInternalizedString_DuplicateIsDeduplicated) {
     string_2 = local_isolate()->heap()->NewPersistentHandle(local_string_2);
   }
 
-  EXPECT_TRUE(string_1->IsOneByteEqualTo(CStrVector("foo")));
+  EXPECT_TRUE(string_1->IsOneByteEqualTo(base::CStrVector("foo")));
   EXPECT_TRUE(string_1->IsInternalizedString());
   EXPECT_EQ(*string_1, *string_2);
 }
@@ -181,7 +182,7 @@ TEST_F(LocalFactoryTest, AstRawString_IsInternalized) {
     string = local_isolate()->heap()->NewPersistentHandle(raw_string->string());
   }
 
-  EXPECT_TRUE(string->IsOneByteEqualTo(CStrVector("foo")));
+  EXPECT_TRUE(string->IsOneByteEqualTo(base::CStrVector("foo")));
   EXPECT_TRUE(string->IsInternalizedString());
 }
 
@@ -244,7 +245,7 @@ TEST_F(LocalFactoryTest, LazyFunction) {
   Handle<SharedFunctionInfo> lazy_sfi = shared;
 
   EXPECT_EQ(lazy_sfi->function_literal_id(), 1);
-  EXPECT_TRUE(lazy_sfi->Name().IsOneByteEqualTo(CStrVector("lazy")));
+  EXPECT_TRUE(lazy_sfi->Name().IsOneByteEqualTo(base::CStrVector("lazy")));
   EXPECT_FALSE(lazy_sfi->is_compiled());
   EXPECT_TRUE(lazy_sfi->HasUncompiledDataWithoutPreparseData());
 }
@@ -271,7 +272,7 @@ TEST_F(LocalFactoryTest, EagerFunction) {
   Handle<SharedFunctionInfo> eager_sfi = shared;
 
   EXPECT_EQ(eager_sfi->function_literal_id(), 1);
-  EXPECT_TRUE(eager_sfi->Name().IsOneByteEqualTo(CStrVector("eager")));
+  EXPECT_TRUE(eager_sfi->Name().IsOneByteEqualTo(base::CStrVector("eager")));
   EXPECT_FALSE(eager_sfi->HasUncompiledData());
   // TODO(leszeks): Add compilation support and enable these checks.
   // EXPECT_TRUE(eager_sfi->is_compiled());
@@ -302,8 +303,8 @@ TEST_F(LocalFactoryTest, ImplicitNameFunction) {
   Handle<SharedFunctionInfo> implicit_name_sfi = shared;
 
   EXPECT_EQ(implicit_name_sfi->function_literal_id(), 1);
-  EXPECT_TRUE(
-      implicit_name_sfi->Name().IsOneByteEqualTo(CStrVector("implicit_name")));
+  EXPECT_TRUE(implicit_name_sfi->Name().IsOneByteEqualTo(
+      base::CStrVector("implicit_name")));
 }
 
 TEST_F(LocalFactoryTest, GCDuringPublish) {
@@ -330,8 +331,8 @@ TEST_F(LocalFactoryTest, GCDuringPublish) {
   Handle<SharedFunctionInfo> implicit_name_sfi = shared;
 
   EXPECT_EQ(implicit_name_sfi->function_literal_id(), 1);
-  EXPECT_TRUE(
-      implicit_name_sfi->Name().IsOneByteEqualTo(CStrVector("implicit_name")));
+  EXPECT_TRUE(implicit_name_sfi->Name().IsOneByteEqualTo(
+      base::CStrVector("implicit_name")));
 }
 
 }  // namespace internal
diff --git a/test/unittests/objects/osr-optimized-code-cache-unittest.cc b/test/unittests/objects/osr-optimized-code-cache-unittest.cc
index 03db6baeb9..8e90a44a43 100644
--- a/test/unittests/objects/osr-optimized-code-cache-unittest.cc
+++ b/test/unittests/objects/osr-optimized-code-cache-unittest.cc
@@ -26,7 +26,7 @@ const char* code_template_string =
     "%%OptimizeFunctionOnNextCall(f%d);"
     "f%d(); f%d;";
 
-void GetSource(i::ScopedVector<char>* source, int index) {
+void GetSource(base::ScopedVector<char>* source, int index) {
   i::SNPrintF(*source, code_template_string, index, index, index, index, index,
               index, index);
 }
@@ -44,7 +44,7 @@ TEST_F(TestWithNativeContext, AddCodeToEmptyCache) {
 
   i::FLAG_allow_natives_syntax = true;
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   GetSource(&source, 0);
   Handle<JSFunction> function = RunJS<JSFunction>(source.begin());
   Isolate* isolate = function->GetIsolate();
@@ -77,7 +77,7 @@ TEST_F(TestWithNativeContext, GrowCodeCache) {
 
   i::FLAG_allow_natives_syntax = true;
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   GetSource(&source, 0);
   Handle<JSFunction> function = RunJS<JSFunction>(source.begin());
   Isolate* isolate = function->GetIsolate();
@@ -120,7 +120,7 @@ TEST_F(TestWithNativeContext, FindCachedEntry) {
 
   i::FLAG_allow_natives_syntax = true;
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   GetSource(&source, 0);
   Handle<JSFunction> function = RunJS<JSFunction>(source.begin());
   Isolate* isolate = function->GetIsolate();
@@ -134,7 +134,7 @@ TEST_F(TestWithNativeContext, FindCachedEntry) {
                                             BytecodeOffset(bailout_id));
   }
 
-  i::ScopedVector<char> source1(1024);
+  base::ScopedVector<char> source1(1024);
   GetSource(&source1, 1);
   Handle<JSFunction> function1 = RunJS<JSFunction>(source1.begin());
   Handle<SharedFunctionInfo> shared1(function1->shared(), isolate);
@@ -166,7 +166,7 @@ TEST_F(TestWithNativeContext, MaxCapacityCache) {
 
   i::FLAG_allow_natives_syntax = true;
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   GetSource(&source, 0);
   Handle<JSFunction> function = RunJS<JSFunction>(source.begin());
   Isolate* isolate = function->GetIsolate();
@@ -185,7 +185,7 @@ TEST_F(TestWithNativeContext, MaxCapacityCache) {
   EXPECT_EQ(osr_cache->length(), kMaxLength);
 
   // Add an entry to reach max capacity.
-  i::ScopedVector<char> source1(1024);
+  base::ScopedVector<char> source1(1024);
   GetSource(&source1, 1);
   Handle<JSFunction> function1 = RunJS<JSFunction>(source1.begin());
   Handle<SharedFunctionInfo> shared1(function1->shared(), isolate);
@@ -209,7 +209,7 @@ TEST_F(TestWithNativeContext, MaxCapacityCache) {
   EXPECT_EQ(smi.value(), bailout_id);
 
   // Add an entry beyond max capacity.
-  i::ScopedVector<char> source2(1024);
+  base::ScopedVector<char> source2(1024);
   GetSource(&source2, 2);
   Handle<JSFunction> function2 = RunJS<JSFunction>(source2.begin());
   Handle<SharedFunctionInfo> shared2(function2->shared(), isolate);
@@ -237,7 +237,7 @@ TEST_F(TestWithNativeContext, ReuseClearedEntry) {
 
   i::FLAG_allow_natives_syntax = true;
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   GetSource(&source, 0);
   Handle<JSFunction> function = RunJS<JSFunction>(source.begin());
   Isolate* isolate = function->GetIsolate();
@@ -263,7 +263,7 @@ TEST_F(TestWithNativeContext, ReuseClearedEntry) {
   osr_cache->Set(clear_index2 + OSROptimizedCodeCache::kCachedCodeOffset,
                  HeapObjectReference::ClearedValue(isolate));
 
-  i::ScopedVector<char> source1(1024);
+  base::ScopedVector<char> source1(1024);
   GetSource(&source1, 1);
   Handle<JSFunction> function1 = RunJS<JSFunction>(source1.begin());
   Handle<SharedFunctionInfo> shared1(function1->shared(), isolate);
@@ -286,7 +286,7 @@ TEST_F(TestWithNativeContext, ReuseClearedEntry) {
   osr_cache->Get(index + OSROptimizedCodeCache::kOsrIdOffset)->ToSmi(&smi);
   EXPECT_EQ(smi.value(), bailout_id);
 
-  i::ScopedVector<char> source2(1024);
+  base::ScopedVector<char> source2(1024);
   GetSource(&source2, 2);
   Handle<JSFunction> function2 = RunJS<JSFunction>(source2.begin());
   Handle<SharedFunctionInfo> shared2(function2->shared(), isolate);
@@ -314,7 +314,7 @@ TEST_F(TestWithNativeContext, EvictDeoptedEntriesNoCompact) {
 
   i::FLAG_allow_natives_syntax = true;
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   GetSource(&source, 0);
   Handle<JSFunction> function = RunJS<JSFunction>(source.begin());
   Isolate* isolate = function->GetIsolate();
@@ -322,7 +322,7 @@ TEST_F(TestWithNativeContext, EvictDeoptedEntriesNoCompact) {
   Handle<SharedFunctionInfo> shared(function->shared(), isolate);
   Handle<Code> code(function->code(), isolate);
 
-  i::ScopedVector<char> source1(1024);
+  base::ScopedVector<char> source1(1024);
   GetSource(&source1, 1);
   Handle<JSFunction> deopt_function = RunJS<JSFunction>(source1.begin());
   Handle<SharedFunctionInfo> deopt_shared(deopt_function->shared(), isolate);
@@ -373,7 +373,7 @@ TEST_F(TestWithNativeContext, EvictDeoptedEntriesCompact) {
 
   i::FLAG_allow_natives_syntax = true;
 
-  i::ScopedVector<char> source(1024);
+  base::ScopedVector<char> source(1024);
   GetSource(&source, 0);
   Handle<JSFunction> function = RunJS<JSFunction>(source.begin());
   Isolate* isolate = function->GetIsolate();
@@ -381,7 +381,7 @@ TEST_F(TestWithNativeContext, EvictDeoptedEntriesCompact) {
   Handle<SharedFunctionInfo> shared(function->shared(), isolate);
   Handle<Code> code(function->code(), isolate);
 
-  i::ScopedVector<char> source1(1024);
+  base::ScopedVector<char> source1(1024);
   GetSource(&source1, 1);
   Handle<JSFunction> deopt_function = RunJS<JSFunction>(source1.begin());
   Handle<SharedFunctionInfo> deopt_shared(deopt_function->shared(), isolate);
diff --git a/test/unittests/objects/value-serializer-unittest.cc b/test/unittests/objects/value-serializer-unittest.cc
index 8cbce76b76..0b8679a8de 100644
--- a/test/unittests/objects/value-serializer-unittest.cc
+++ b/test/unittests/objects/value-serializer-unittest.cc
@@ -2603,7 +2603,7 @@ class ValueSerializerTestWithWasm : public ValueSerializerTest {
     i::MaybeHandle<i::JSObject> compiled =
         i_isolate()->wasm_engine()->SyncCompile(
             i_isolate(), enabled_features, &thrower,
-            i::wasm::ModuleWireBytes(i::ArrayVector(kIncrementerWasm)));
+            i::wasm::ModuleWireBytes(base::ArrayVector(kIncrementerWasm)));
     CHECK(!thrower.error());
     return Local<WasmModuleObject>::Cast(
         Utils::ToLocal(compiled.ToHandleChecked()));
diff --git a/test/unittests/strings/unicode-unittest.cc b/test/unittests/strings/unicode-unittest.cc
index a294704e33..1627f7fb1f 100644
--- a/test/unittests/strings/unicode-unittest.cc
+++ b/test/unittests/strings/unicode-unittest.cc
@@ -6,9 +6,9 @@
 #include <string>
 #include <vector>
 
+#include "src/base/vector.h"
 #include "src/strings/unicode-decoder.h"
 #include "src/strings/unicode-inl.h"
-#include "src/utils/vector.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace v8 {
@@ -27,7 +27,7 @@ void DecodeNormally(const std::vector<byte>& bytes,
 
 void DecodeUtf16(const std::vector<uint8_t>& bytes,
                  std::vector<unibrow::uchar>* output) {
-  auto utf8_data = Vector<const uint8_t>::cast(VectorOf(bytes));
+  auto utf8_data = base::Vector<const uint8_t>::cast(base::VectorOf(bytes));
   Utf8Decoder decoder(utf8_data);
 
   std::vector<uint16_t> utf16(decoder.utf16_length());
diff --git a/test/unittests/utils/utils-unittest.cc b/test/unittests/utils/utils-unittest.cc
index d6c67d039d..8f82b2f65b 100644
--- a/test/unittests/utils/utils-unittest.cc
+++ b/test/unittests/utils/utils-unittest.cc
@@ -111,26 +111,37 @@ TYPED_TEST(UtilsTest, SaturateAdd) {
 }
 
 TYPED_TEST(UtilsTest, PassesFilterTest) {
-  EXPECT_TRUE(PassesFilter(CStrVector("abcdefg"), CStrVector("abcdefg")));
-  EXPECT_TRUE(PassesFilter(CStrVector("abcdefg"), CStrVector("abcdefg*")));
-  EXPECT_TRUE(PassesFilter(CStrVector("abcdefg"), CStrVector("abc*")));
-  EXPECT_TRUE(PassesFilter(CStrVector("abcdefg"), CStrVector("*")));
-  EXPECT_TRUE(PassesFilter(CStrVector("abcdefg"), CStrVector("-~")));
-  EXPECT_TRUE(PassesFilter(CStrVector("abcdefg"), CStrVector("-abcdefgh")));
-  EXPECT_TRUE(PassesFilter(CStrVector("abdefg"), CStrVector("-")));
-  EXPECT_FALSE(PassesFilter(CStrVector("abcdefg"), CStrVector("-abcdefg")));
-  EXPECT_FALSE(PassesFilter(CStrVector("abcdefg"), CStrVector("-abcdefg*")));
-  EXPECT_FALSE(PassesFilter(CStrVector("abcdefg"), CStrVector("-abc*")));
-  EXPECT_FALSE(PassesFilter(CStrVector("abcdefg"), CStrVector("-*")));
-  EXPECT_FALSE(PassesFilter(CStrVector("abcdefg"), CStrVector("~")));
-  EXPECT_FALSE(PassesFilter(CStrVector("abcdefg"), CStrVector("")));
-  EXPECT_FALSE(PassesFilter(CStrVector("abcdefg"), CStrVector("abcdefgh")));
-
-  EXPECT_TRUE(PassesFilter(CStrVector(""), CStrVector("")));
-  EXPECT_TRUE(PassesFilter(CStrVector(""), CStrVector("*")));
-  EXPECT_FALSE(PassesFilter(CStrVector(""), CStrVector("-")));
-  EXPECT_FALSE(PassesFilter(CStrVector(""), CStrVector("-*")));
-  EXPECT_FALSE(PassesFilter(CStrVector(""), CStrVector("a")));
+  EXPECT_TRUE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("abcdefg")));
+  EXPECT_TRUE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("abcdefg*")));
+  EXPECT_TRUE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("abc*")));
+  EXPECT_TRUE(PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("*")));
+  EXPECT_TRUE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("-~")));
+  EXPECT_TRUE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("-abcdefgh")));
+  EXPECT_TRUE(PassesFilter(base::CStrVector("abdefg"), base::CStrVector("-")));
+  EXPECT_FALSE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("-abcdefg")));
+  EXPECT_FALSE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("-abcdefg*")));
+  EXPECT_FALSE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("-abc*")));
+  EXPECT_FALSE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("-*")));
+  EXPECT_FALSE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("~")));
+  EXPECT_FALSE(PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("")));
+  EXPECT_FALSE(
+      PassesFilter(base::CStrVector("abcdefg"), base::CStrVector("abcdefgh")));
+
+  EXPECT_TRUE(PassesFilter(base::CStrVector(""), base::CStrVector("")));
+  EXPECT_TRUE(PassesFilter(base::CStrVector(""), base::CStrVector("*")));
+  EXPECT_FALSE(PassesFilter(base::CStrVector(""), base::CStrVector("-")));
+  EXPECT_FALSE(PassesFilter(base::CStrVector(""), base::CStrVector("-*")));
+  EXPECT_FALSE(PassesFilter(base::CStrVector(""), base::CStrVector("a")));
 }
 
 TEST(UtilsTest, IsInBounds) {
diff --git a/test/unittests/wasm/function-body-decoder-unittest.cc b/test/unittests/wasm/function-body-decoder-unittest.cc
index 37ba2365e7..e8a9311f58 100644
--- a/test/unittests/wasm/function-body-decoder-unittest.cc
+++ b/test/unittests/wasm/function-body-decoder-unittest.cc
@@ -208,8 +208,8 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
 
   enum AppendEnd : bool { kAppendEnd, kOmitEnd };
 
-  Vector<const byte> PrepareBytecode(Vector<const byte> code,
-                                     AppendEnd append_end) {
+  base::Vector<const byte> PrepareBytecode(base::Vector<const byte> code,
+                                           AppendEnd append_end) {
     size_t locals_size = local_decls.Size();
     size_t total_size =
         code.size() + locals_size + (append_end == kAppendEnd ? 1 : 0);
@@ -229,16 +229,18 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
   }
 
   template <size_t N>
-  Vector<const byte> CodeToVector(const byte (&code)[N]) {
-    return ArrayVector(code);
+  base::Vector<const byte> CodeToVector(const byte (&code)[N]) {
+    return base::ArrayVector(code);
   }
 
-  Vector<const byte> CodeToVector(
+  base::Vector<const byte> CodeToVector(
       const std::initializer_list<const byte>& code) {
-    return VectorOf(&*code.begin(), code.size());
+    return base::VectorOf(&*code.begin(), code.size());
   }
 
-  Vector<const byte> CodeToVector(Vector<const byte> vec) { return vec; }
+  base::Vector<const byte> CodeToVector(base::Vector<const byte> vec) {
+    return vec;
+  }
 
   // Prepends local variable declarations and renders nice error messages for
   // verification failures.
@@ -246,7 +248,7 @@ class FunctionBodyDecoderTestBase : public WithZoneMixin<BaseTest> {
   void Validate(bool expected_success, const FunctionSig* sig, Code&& raw_code,
                 AppendEnd append_end = kAppendEnd,
                 const char* message = nullptr) {
-    Vector<const byte> code =
+    base::Vector<const byte> code =
         PrepareBytecode(CodeToVector(std::forward<Code>(raw_code)), append_end);
 
     // Validate the code.
@@ -407,9 +409,9 @@ TEST_F(FunctionBodyDecoderTest, Int32Const_off_end) {
   byte code[] = {kExprI32Const, 0xAA, 0xBB, 0xCC, 0x44};
 
   for (size_t size = 1; size <= 4; ++size) {
-    ExpectFailure(sigs.i_i(), VectorOf(code, size), kAppendEnd);
+    ExpectFailure(sigs.i_i(), base::VectorOf(code, size), kAppendEnd);
     // Should also fail without the trailing 'end' opcode.
-    ExpectFailure(sigs.i_i(), VectorOf(code, size), kOmitEnd);
+    ExpectFailure(sigs.i_i(), base::VectorOf(code, size), kOmitEnd);
   }
 }
 
@@ -587,7 +589,7 @@ TEST_F(FunctionBodyDecoderTest, BlockN) {
     buffer[0] = kExprBlock;
     buffer[1] = kVoidCode;
     buffer[i + 2] = kExprEnd;
-    ExpectValidates(sigs.v_i(), VectorOf(buffer, i + 3), kAppendEnd);
+    ExpectValidates(sigs.v_i(), base::VectorOf(buffer, i + 3), kAppendEnd);
   }
 }
 
@@ -732,8 +734,8 @@ TEST_F(FunctionBodyDecoderTest, BlockN_off_end) {
   byte code[] = {WASM_BLOCK(kExprNop, kExprNop, kExprNop, kExprNop)};
   ExpectValidates(sigs.v_v(), code);
   for (size_t i = 1; i < arraysize(code); i++) {
-    ExpectFailure(sigs.v_v(), VectorOf(code, i), kAppendEnd);
-    ExpectFailure(sigs.v_v(), VectorOf(code, i), kOmitEnd);
+    ExpectFailure(sigs.v_v(), base::VectorOf(code, i), kAppendEnd);
+    ExpectFailure(sigs.v_v(), base::VectorOf(code, i), kOmitEnd);
   }
 }
 
@@ -1210,8 +1212,8 @@ TEST_F(FunctionBodyDecoderTest, If_off_end) {
   static const byte kCode[] = {
       WASM_IF_ELSE(WASM_LOCAL_GET(0), WASM_LOCAL_GET(0), WASM_LOCAL_GET(0))};
   for (size_t len = 3; len < arraysize(kCode); len++) {
-    ExpectFailure(sigs.i_i(), VectorOf(kCode, len), kAppendEnd);
-    ExpectFailure(sigs.i_i(), VectorOf(kCode, len), kOmitEnd);
+    ExpectFailure(sigs.i_i(), base::VectorOf(kCode, len), kAppendEnd);
+    ExpectFailure(sigs.i_i(), base::VectorOf(kCode, len), kOmitEnd);
   }
 }
 
@@ -1815,7 +1817,7 @@ TEST_F(FunctionBodyDecoderTest, IncompleteIndirectReturnCall) {
   builder.InitializeTable(wasm::kWasmVoid);
 
   static byte code[] = {kExprReturnCallIndirect};
-  ExpectFailure(sig, ArrayVector(code), kOmitEnd);
+  ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
 TEST_F(FunctionBodyDecoderTest, MultiReturn) {
@@ -1999,7 +2001,7 @@ TEST_F(FunctionBodyDecoderTest, IncompleteIndirectCall) {
   builder.InitializeTable(wasm::kWasmVoid);
 
   static byte code[] = {kExprCallIndirect};
-  ExpectFailure(sig, ArrayVector(code), kOmitEnd);
+  ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
 TEST_F(FunctionBodyDecoderTest, IncompleteStore) {
@@ -2008,7 +2010,7 @@ TEST_F(FunctionBodyDecoderTest, IncompleteStore) {
   builder.InitializeTable(wasm::kWasmVoid);
 
   static byte code[] = {kExprI32StoreMem};
-  ExpectFailure(sig, ArrayVector(code), kOmitEnd);
+  ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
 TEST_F(FunctionBodyDecoderTest, IncompleteI8x16Shuffle) {
@@ -2019,7 +2021,7 @@ TEST_F(FunctionBodyDecoderTest, IncompleteI8x16Shuffle) {
 
   static byte code[] = {kSimdPrefix,
                         static_cast<byte>(kExprI8x16Shuffle & 0xff)};
-  ExpectFailure(sig, ArrayVector(code), kOmitEnd);
+  ExpectFailure(sig, base::ArrayVector(code), kOmitEnd);
 }
 
 TEST_F(FunctionBodyDecoderTest, SimpleImportCalls) {
@@ -2693,8 +2695,8 @@ TEST_F(FunctionBodyDecoderTest, BrTableSubtyping) {
 TEST_F(FunctionBodyDecoderTest, BrTable_off_end) {
   static byte code[] = {B1(WASM_BR_TABLE(WASM_LOCAL_GET(0), 0, BR_TARGET(0)))};
   for (size_t len = 1; len < sizeof(code); len++) {
-    ExpectFailure(sigs.i_i(), VectorOf(code, len), kAppendEnd);
-    ExpectFailure(sigs.i_i(), VectorOf(code, len), kOmitEnd);
+    ExpectFailure(sigs.i_i(), base::VectorOf(code, len), kAppendEnd);
+    ExpectFailure(sigs.i_i(), base::VectorOf(code, len), kOmitEnd);
   }
 }
 
@@ -3273,7 +3275,8 @@ TEST_F(FunctionBodyDecoderTest, MemoryInitInvalid) {
   byte code[] = {WASM_MEMORY_INIT(0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
                  WASM_END};
   for (size_t i = 0; i <= arraysize(code); ++i) {
-    Validate(i == arraysize(code), sigs.v_v(), VectorOf(code, i), kOmitEnd);
+    Validate(i == arraysize(code), sigs.v_v(), base::VectorOf(code, i),
+             kOmitEnd);
   }
 }
 
@@ -3346,7 +3349,8 @@ TEST_F(FunctionBodyDecoderTest, TableInitInvalid) {
   byte code[] = {WASM_TABLE_INIT(0, 0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
                  WASM_END};
   for (size_t i = 0; i <= arraysize(code); ++i) {
-    Validate(i == arraysize(code), sigs.v_v(), VectorOf(code, i), kOmitEnd);
+    Validate(i == arraysize(code), sigs.v_v(), base::VectorOf(code, i),
+             kOmitEnd);
   }
 }
 
@@ -3366,7 +3370,8 @@ TEST_F(FunctionBodyDecoderTest, TableInitDeclarativeElem) {
   byte code[] = {WASM_TABLE_INIT(0, 0, WASM_ZERO, WASM_ZERO, WASM_ZERO),
                  WASM_END};
   for (size_t i = 0; i <= arraysize(code); ++i) {
-    Validate(i == arraysize(code), sigs.v_v(), VectorOf(code, i), kOmitEnd);
+    Validate(i == arraysize(code), sigs.v_v(), base::VectorOf(code, i),
+             kOmitEnd);
   }
 }
 
diff --git a/test/unittests/wasm/streaming-decoder-unittest.cc b/test/unittests/wasm/streaming-decoder-unittest.cc
index 4f5811f8f6..9553ff643c 100644
--- a/test/unittests/wasm/streaming-decoder-unittest.cc
+++ b/test/unittests/wasm/streaming-decoder-unittest.cc
@@ -21,7 +21,7 @@ struct MockStreamingResult {
   size_t num_sections = 0;
   size_t num_functions = 0;
   WasmError error;
-  OwnedVector<uint8_t> received_bytes;
+  base::OwnedVector<uint8_t> received_bytes;
 
   bool ok() const { return !error.has_error(); }
 
@@ -33,7 +33,7 @@ class MockStreamingProcessor : public StreamingProcessor {
   explicit MockStreamingProcessor(MockStreamingResult* result)
       : result_(result) {}
 
-  bool ProcessModuleHeader(Vector<const uint8_t> bytes,
+  bool ProcessModuleHeader(base::Vector<const uint8_t> bytes,
                            uint32_t offset) override {
     Decoder decoder(bytes.begin(), bytes.end());
     uint32_t magic_word = decoder.consume_u32("wasm magic");
@@ -50,7 +50,8 @@ class MockStreamingProcessor : public StreamingProcessor {
   }
 
   // Process all sections but the code section.
-  bool ProcessSection(SectionCode section_code, Vector<const uint8_t> bytes,
+  bool ProcessSection(SectionCode section_code,
+                      base::Vector<const uint8_t> bytes,
                       uint32_t offset) override {
     ++result_->num_sections;
     return true;
@@ -64,7 +65,7 @@ class MockStreamingProcessor : public StreamingProcessor {
   }
 
   // Process a function body.
-  bool ProcessFunctionBody(Vector<const uint8_t> bytes,
+  bool ProcessFunctionBody(base::Vector<const uint8_t> bytes,
                            uint32_t offset) override {
     ++result_->num_functions;
     return true;
@@ -73,7 +74,7 @@ class MockStreamingProcessor : public StreamingProcessor {
   void OnFinishedChunk() override {}
 
   // Finish the processing of the stream.
-  void OnFinishedStream(OwnedVector<uint8_t> bytes) override {
+  void OnFinishedStream(base::OwnedVector<uint8_t> bytes) override {
     result_->received_bytes = std::move(bytes);
   }
 
@@ -85,8 +86,8 @@ class MockStreamingProcessor : public StreamingProcessor {
 
   void OnAbort() override {}
 
-  bool Deserialize(Vector<const uint8_t> module_bytes,
-                   Vector<const uint8_t> wire_bytes) override {
+  bool Deserialize(base::Vector<const uint8_t> module_bytes,
+                   base::Vector<const uint8_t> wire_bytes) override {
     return false;
   }
 
@@ -96,8 +97,8 @@ class MockStreamingProcessor : public StreamingProcessor {
 
 class WasmStreamingDecoderTest : public ::testing::Test {
  public:
-  void ExpectVerifies(Vector<const uint8_t> data, size_t expected_sections,
-                      size_t expected_functions) {
+  void ExpectVerifies(base::Vector<const uint8_t> data,
+                      size_t expected_sections, size_t expected_functions) {
     for (int split = 0; split <= data.length(); ++split) {
       MockStreamingResult result;
       auto stream = StreamingDecoder::CreateAsyncStreamingDecoder(
@@ -112,7 +113,7 @@ class WasmStreamingDecoderTest : public ::testing::Test {
     }
   }
 
-  void ExpectFailure(Vector<const uint8_t> data, uint32_t error_offset,
+  void ExpectFailure(base::Vector<const uint8_t> data, uint32_t error_offset,
                      const char* message) {
     for (int split = 0; split <= data.length(); ++split) {
       MockStreamingResult result;
@@ -142,32 +143,32 @@ TEST_F(WasmStreamingDecoderTest, IncompleteModuleHeader) {
     MockStreamingResult result;
     auto stream = StreamingDecoder::CreateAsyncStreamingDecoder(
         std::make_unique<MockStreamingProcessor>(&result));
-    stream->OnBytesReceived(VectorOf(data, 1));
+    stream->OnBytesReceived(base::VectorOf(data, 1));
     stream->Finish();
     EXPECT_FALSE(result.ok());
   }
   for (uint32_t length = 1; length < sizeof(data); ++length) {
-    ExpectFailure(VectorOf(data, length), length - 1,
+    ExpectFailure(base::VectorOf(data, length), length - 1,
                   "unexpected end of stream");
   }
 }
 
 TEST_F(WasmStreamingDecoderTest, MagicAndVersion) {
   const uint8_t data[] = {U32_LE(kWasmMagic), U32_LE(kWasmVersion)};
-  ExpectVerifies(ArrayVector(data), 0, 0);
+  ExpectVerifies(base::ArrayVector(data), 0, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, BadMagic) {
   for (uint32_t x = 1; x; x <<= 1) {
     const uint8_t data[] = {U32_LE(kWasmMagic ^ x), U32_LE(kWasmVersion)};
-    ExpectFailure(ArrayVector(data), 0, "expected wasm magic");
+    ExpectFailure(base::ArrayVector(data), 0, "expected wasm magic");
   }
 }
 
 TEST_F(WasmStreamingDecoderTest, BadVersion) {
   for (uint32_t x = 1; x; x <<= 1) {
     const uint8_t data[] = {U32_LE(kWasmMagic), U32_LE(kWasmVersion ^ x)};
-    ExpectFailure(ArrayVector(data), 4, "expected wasm version");
+    ExpectFailure(base::ArrayVector(data), 4, "expected wasm version");
   }
 }
 
@@ -184,7 +185,7 @@ TEST_F(WasmStreamingDecoderTest, OneSection) {
       0x0,                   // 5
       0x0                    // 6
   };
-  ExpectVerifies(ArrayVector(data), 1, 0);
+  ExpectVerifies(base::ArrayVector(data), 1, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, OneSection_b) {
@@ -201,7 +202,7 @@ TEST_F(WasmStreamingDecoderTest, OneSection_b) {
       0x0,                   // 5
       0x0                    // 6
   };
-  ExpectVerifies(ArrayVector(data), 1, 0);
+  ExpectVerifies(base::ArrayVector(data), 1, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, OneShortSection) {
@@ -215,7 +216,7 @@ TEST_F(WasmStreamingDecoderTest, OneShortSection) {
       0x0,                   // Payload
       0x0                    // 2
   };
-  ExpectVerifies(ArrayVector(data), 1, 0);
+  ExpectVerifies(base::ArrayVector(data), 1, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, OneShortSection_b) {
@@ -229,7 +230,7 @@ TEST_F(WasmStreamingDecoderTest, OneShortSection_b) {
       0x0,                   // Payload
       0x0                    // 2
   };
-  ExpectVerifies(ArrayVector(data), 1, 0);
+  ExpectVerifies(base::ArrayVector(data), 1, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, OneEmptySection) {
@@ -239,7 +240,7 @@ TEST_F(WasmStreamingDecoderTest, OneEmptySection) {
       0x1,                   // Section ID
       0x0                    // Section Length
   };
-  ExpectVerifies(ArrayVector(data), 1, 0);
+  ExpectVerifies(base::ArrayVector(data), 1, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, OneSectionNotEnoughPayload1) {
@@ -254,7 +255,7 @@ TEST_F(WasmStreamingDecoderTest, OneSectionNotEnoughPayload1) {
       0x0,                   // 4
       0x0                    // 5
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
                 "unexpected end of stream");
 }
 
@@ -266,7 +267,7 @@ TEST_F(WasmStreamingDecoderTest, OneSectionNotEnoughPayload2) {
       0x6,                   // Section Length
       0x0                    // Payload
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
                 "unexpected end of stream");
 }
 
@@ -281,7 +282,8 @@ TEST_F(WasmStreamingDecoderTest, OneSectionInvalidLength) {
       0x80,                  // --
       0x80,                  // --
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1, "expected section length");
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
+                "expected section length");
 }
 
 TEST_F(WasmStreamingDecoderTest, TwoLongSections) {
@@ -306,7 +308,7 @@ TEST_F(WasmStreamingDecoderTest, TwoLongSections) {
       0x0,                   // 6
       0x0                    // 7
   };
-  ExpectVerifies(ArrayVector(data), 2, 0);
+  ExpectVerifies(base::ArrayVector(data), 2, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, TwoShortSections) {
@@ -321,7 +323,7 @@ TEST_F(WasmStreamingDecoderTest, TwoShortSections) {
       0x0,                   // Payload
       0x0,                   // 2
   };
-  ExpectVerifies(ArrayVector(data), 2, 0);
+  ExpectVerifies(base::ArrayVector(data), 2, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, TwoSectionsShortLong) {
@@ -341,7 +343,7 @@ TEST_F(WasmStreamingDecoderTest, TwoSectionsShortLong) {
       0x0,                   // 6
       0x0                    // 7
   };
-  ExpectVerifies(ArrayVector(data), 2, 0);
+  ExpectVerifies(base::ArrayVector(data), 2, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, TwoEmptySections) {
@@ -353,7 +355,7 @@ TEST_F(WasmStreamingDecoderTest, TwoEmptySections) {
       0x2,                   // Section ID
       0x0                    // Section Length
   };
-  ExpectVerifies(ArrayVector(data), 2, 0);
+  ExpectVerifies(base::ArrayVector(data), 2, 0);
 }
 
 TEST_F(WasmStreamingDecoderTest, OneFunction) {
@@ -371,7 +373,7 @@ TEST_F(WasmStreamingDecoderTest, OneFunction) {
       0x0,                   // 5
       0x0,                   // 6
   };
-  ExpectVerifies(ArrayVector(data), 0, 1);
+  ExpectVerifies(base::ArrayVector(data), 0, 1);
 }
 
 TEST_F(WasmStreamingDecoderTest, OneShortFunction) {
@@ -384,7 +386,7 @@ TEST_F(WasmStreamingDecoderTest, OneShortFunction) {
       0x1,                   // Function Length
       0x0,                   // Function
   };
-  ExpectVerifies(ArrayVector(data), 0, 1);
+  ExpectVerifies(base::ArrayVector(data), 0, 1);
 }
 
 TEST_F(WasmStreamingDecoderTest, EmptyFunction) {
@@ -396,7 +398,7 @@ TEST_F(WasmStreamingDecoderTest, EmptyFunction) {
       0x1,                   // Number of Functions
       0x0,                   // Function Length  -- ERROR
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
                 "invalid function length (0)");
 }
 
@@ -423,7 +425,7 @@ TEST_F(WasmStreamingDecoderTest, TwoFunctions) {
       0x0,                   // 6
       0x0,                   // 7
   };
-  ExpectVerifies(ArrayVector(data), 0, 2);
+  ExpectVerifies(base::ArrayVector(data), 0, 2);
 }
 
 TEST_F(WasmStreamingDecoderTest, TwoFunctions_b) {
@@ -444,7 +446,7 @@ TEST_F(WasmStreamingDecoderTest, TwoFunctions_b) {
       0x0,                   // 6
       0x0,                   // 7
   };
-  ExpectVerifies(ArrayVector(data), 0, 2);
+  ExpectVerifies(base::ArrayVector(data), 0, 2);
 }
 
 TEST_F(WasmStreamingDecoderTest, CodeSectionLengthZero) {
@@ -454,7 +456,7 @@ TEST_F(WasmStreamingDecoderTest, CodeSectionLengthZero) {
       kCodeSectionCode,      // Section ID
       0x0,                   // Section Length
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
                 "code section cannot have size 0");
 }
 
@@ -476,7 +478,7 @@ TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooHigh) {
       0x1,                   // Function Length
       0x0,                   // Function
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
                 "not all code section bytes were used");
 }
 
@@ -488,7 +490,7 @@ TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooHighZeroFunctions) {
       0xD,                   // Section Length
       0x0,                   // Number of Functions
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
                 "not all code section bytes were used");
 }
 
@@ -510,7 +512,7 @@ TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooLow) {
       0x1,                   // Function Length      <8> -- ERROR
       0x0,                   // Function
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 2,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 2,
                 "read past code section end");
 }
 
@@ -534,7 +536,7 @@ TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooLowEndsInNumFunctions) {
       0x1,                   // Function Length
       0x0,                   // Function
   };
-  ExpectFailure(ArrayVector(data), 12, "invalid code section length");
+  ExpectFailure(base::ArrayVector(data), 12, "invalid code section length");
 }
 
 TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooLowEndsInFunctionLength) {
@@ -559,7 +561,7 @@ TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooLowEndsInFunctionLength) {
       0x1,                   // Function Length
       0x0,                   // Function
   };
-  ExpectFailure(ArrayVector(data), 15, "read past code section end");
+  ExpectFailure(base::ArrayVector(data), 15, "read past code section end");
 }
 
 TEST_F(WasmStreamingDecoderTest, NumberOfFunctionsTooHigh) {
@@ -580,7 +582,7 @@ TEST_F(WasmStreamingDecoderTest, NumberOfFunctionsTooHigh) {
       0x1,                   // Function Length
       0x0,                   // Function
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 1,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 1,
                 "unexpected end of stream");
 }
 
@@ -599,7 +601,7 @@ TEST_F(WasmStreamingDecoderTest, NumberOfFunctionsTooLow) {
       0x1,                   // Function Length
       0x0                    // Function
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 3,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 3,
                 "not all code section bytes were used");
 }
 
@@ -618,7 +620,7 @@ TEST_F(WasmStreamingDecoderTest, TwoCodeSections) {
       0x1,                   // Function Length
       0x0,                   // Function
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 5,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 5,
                 "code section can only appear once");
 }
 
@@ -637,7 +639,7 @@ TEST_F(WasmStreamingDecoderTest, UnknownSection) {
       0x1,                   // Name
       0x0,                   // Content
   };
-  ExpectVerifies(ArrayVector(data), 1, 1);
+  ExpectVerifies(base::ArrayVector(data), 1, 1);
 }
 
 TEST_F(WasmStreamingDecoderTest, UnknownSectionSandwich) {
@@ -660,7 +662,7 @@ TEST_F(WasmStreamingDecoderTest, UnknownSectionSandwich) {
       0x1,                   // Function Length
       0x0,                   // Function
   };
-  ExpectFailure(ArrayVector(data), sizeof(data) - 5,
+  ExpectFailure(base::ArrayVector(data), sizeof(data) - 5,
                 "code section can only appear once");
 }
 
diff --git a/test/unittests/wasm/trap-handler-x64-unittest.cc b/test/unittests/wasm/trap-handler-x64-unittest.cc
index 5f5b711f45..545a8d22b6 100644
--- a/test/unittests/wasm/trap-handler-x64-unittest.cc
+++ b/test/unittests/wasm/trap-handler-x64-unittest.cc
@@ -22,15 +22,14 @@
 #include "include/v8-wasm-trap-handler-win.h"
 #endif
 #include "src/base/page-allocator.h"
+#include "src/base/vector.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/macro-assembler-inl.h"
 #include "src/execution/simulator.h"
 #include "src/objects/backing-store.h"
 #include "src/trap-handler/trap-handler.h"
 #include "src/utils/allocation.h"
-#include "src/utils/vector.h"
 #include "src/wasm/wasm-engine.h"
-
 #include "test/common/assembler-tester.h"
 #include "test/unittests/test-utils.h"
 
diff --git a/test/wasm-api-tests/callbacks.cc b/test/wasm-api-tests/callbacks.cc
index fc321e96dc..8df770732a 100644
--- a/test/wasm-api-tests/callbacks.cc
+++ b/test/wasm-api-tests/callbacks.cc
@@ -43,15 +43,15 @@ class WasmCapiCallbacksTest : public WasmCapiTest {
     // Build the following function:
     // int32 stage1(int32 arg0) { return stage2(arg0); }
     uint32_t stage2_index =
-        builder()->AddImport(CStrVector("stage2"), wasm_i_i_sig());
+        builder()->AddImport(base::CStrVector("stage2"), wasm_i_i_sig());
     byte code[] = {WASM_CALL_FUNCTION(stage2_index, WASM_LOCAL_GET(0))};
-    AddExportedFunction(CStrVector("stage1"), code, sizeof(code));
+    AddExportedFunction(base::CStrVector("stage1"), code, sizeof(code));
 
     stage2_ = Func::make(store(), cpp_i_i_sig(), Stage2, this);
   }
 
   Func* stage2() { return stage2_.get(); }
-  void AddExportedFunction(Vector<const char> name, byte code[],
+  void AddExportedFunction(base::Vector<const char> name, byte code[],
                            size_t code_size) {
     WasmCapiTest::AddExportedFunction(name, code, code_size, wasm_i_i_sig());
   }
@@ -66,7 +66,7 @@ TEST_F(WasmCapiCallbacksTest, Trap) {
   // Build the following function:
   // int32 stage3_trap(int32 arg0) { unreachable(); }
   byte code[] = {WASM_UNREACHABLE};
-  AddExportedFunction(CStrVector("stage3_trap"), code, sizeof(code));
+  AddExportedFunction(base::CStrVector("stage3_trap"), code, sizeof(code));
 
   Extern* imports[] = {stage2()};
   Instantiate(imports);
@@ -81,9 +81,9 @@ TEST_F(WasmCapiCallbacksTest, GC) {
   // Build the following function:
   // int32 stage3_to4(int32 arg0) { return stage4(arg0); }
   uint32_t stage4_index =
-      builder()->AddImport(CStrVector("stage4"), wasm_i_i_sig());
+      builder()->AddImport(base::CStrVector("stage4"), wasm_i_i_sig());
   byte code[] = {WASM_CALL_FUNCTION(stage4_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("stage3_to4"), code, sizeof(code));
+  AddExportedFunction(base::CStrVector("stage3_to4"), code, sizeof(code));
 
   i::Isolate* isolate =
       reinterpret_cast<::wasm::StoreImpl*>(store())->i_isolate();
@@ -134,7 +134,7 @@ TEST_F(WasmCapiTest, Recursion) {
   //   return fibonacci_c(arg0 - 1) + fibonacci_c(arg0 - 2);
   // }
   uint32_t fibo_c_index =
-      builder()->AddImport(CStrVector("fibonacci_c"), wasm_i_i_sig());
+      builder()->AddImport(base::CStrVector("fibonacci_c"), wasm_i_i_sig());
   byte code_fibo[] = {
       WASM_IF(WASM_I32_EQ(WASM_LOCAL_GET(0), WASM_ZERO),
               WASM_RETURN1(WASM_ZERO)),
@@ -145,7 +145,7 @@ TEST_F(WasmCapiTest, Recursion) {
           WASM_CALL_FUNCTION(fibo_c_index, WASM_LOCAL_GET(0)),
           WASM_CALL_FUNCTION(fibo_c_index,
                              WASM_I32_SUB(WASM_LOCAL_GET(0), WASM_ONE))))};
-  AddExportedFunction(CStrVector("fibonacci_wasm"), code_fibo,
+  AddExportedFunction(base::CStrVector("fibonacci_wasm"), code_fibo,
                       sizeof(code_fibo), wasm_i_i_sig());
 
   own<Func> fibonacci = Func::make(store(), cpp_i_i_sig(), FibonacciC, this);
@@ -192,8 +192,8 @@ TEST_F(WasmCapiTest, DirectCallCapiFunction) {
                             kWasmExternRef, kWasmI32,      kWasmI64, kWasmF32,
                             kWasmF64,       kWasmExternRef};
   FunctionSig wasm_sig(5, 5, wasm_types);
-  int func_index = builder()->AddImport(CStrVector("func"), &wasm_sig);
-  builder()->ExportImportedFunction(CStrVector("func"), func_index);
+  int func_index = builder()->AddImport(base::CStrVector("func"), &wasm_sig);
+  builder()->ExportImportedFunction(base::CStrVector("func"), func_index);
   Instantiate(imports);
   int32_t a0 = 42;
   int64_t a1 = 0x1234c0ffee;
diff --git a/test/wasm-api-tests/finalize.cc b/test/wasm-api-tests/finalize.cc
index 5d4ba867f2..08e894d81f 100644
--- a/test/wasm-api-tests/finalize.cc
+++ b/test/wasm-api-tests/finalize.cc
@@ -66,7 +66,8 @@ void RunInStore(Store* store, ZoneBuffer* wire_bytes, int iterations) {
 TEST_F(WasmCapiTest, InstanceFinalization) {
   // Add a dummy function: f(x) { return x; }
   byte code[] = {WASM_RETURN1(WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("f"), code, sizeof(code), wasm_i_i_sig());
+  AddExportedFunction(base::CStrVector("f"), code, sizeof(code),
+                      wasm_i_i_sig());
   Compile();
   g_instances_finalized = 0;
   g_functions_finalized = 0;
@@ -117,8 +118,9 @@ void FinalizeHostData(void* data) {
 }  // namespace
 
 TEST_F(WasmCapiTest, CapiFunctionLifetimes) {
-  uint32_t func_index = builder()->AddImport(CStrVector("f"), wasm_i_i_sig());
-  builder()->ExportImportedFunction(CStrVector("f"), func_index);
+  uint32_t func_index =
+      builder()->AddImport(base::CStrVector("f"), wasm_i_i_sig());
+  builder()->ExportImportedFunction(base::CStrVector("f"), func_index);
   Compile();
   own<Instance> instance;
   void* kHostData = reinterpret_cast<void*>(1234);
diff --git a/test/wasm-api-tests/globals.cc b/test/wasm-api-tests/globals.cc
index e606eed1e6..7f693d9ceb 100644
--- a/test/wasm-api-tests/globals.cc
+++ b/test/wasm-api-tests/globals.cc
@@ -15,32 +15,32 @@ TEST_F(WasmCapiTest, Globals) {
   const bool kImmutable = false;
 
   // Define imported and exported globals in the module.
-  const uint32_t cfi_index =
-      builder()->AddGlobalImport(CStrVector("const f32"), kWasmF32, kImmutable);
-  const uint32_t cii_index =
-      builder()->AddGlobalImport(CStrVector("const i64"), kWasmI64, kImmutable);
-  const uint32_t vfi_index =
-      builder()->AddGlobalImport(CStrVector("var f32"), kWasmF32, kMutable);
-  const uint32_t vii_index =
-      builder()->AddGlobalImport(CStrVector("var i64"), kWasmI64, kMutable);
+  const uint32_t cfi_index = builder()->AddGlobalImport(
+      base::CStrVector("const f32"), kWasmF32, kImmutable);
+  const uint32_t cii_index = builder()->AddGlobalImport(
+      base::CStrVector("const i64"), kWasmI64, kImmutable);
+  const uint32_t vfi_index = builder()->AddGlobalImport(
+      base::CStrVector("var f32"), kWasmF32, kMutable);
+  const uint32_t vii_index = builder()->AddGlobalImport(
+      base::CStrVector("var i64"), kWasmI64, kMutable);
   const int kNumImported = 4;
 
   const uint32_t cfe_index =
-      kNumImported + builder()->AddExportedGlobal(kWasmF32, kImmutable,
-                                                  WasmInitExpr(5.f),
-                                                  CStrVector("const f32"));
+      kNumImported +
+      builder()->AddExportedGlobal(kWasmF32, kImmutable, WasmInitExpr(5.f),
+                                   base::CStrVector("const f32"));
   const uint32_t cie_index =
-      kNumImported + builder()->AddExportedGlobal(kWasmI64, kImmutable,
-                                                  WasmInitExpr(int64_t{6}),
-                                                  CStrVector("const i64"));
+      kNumImported + builder()->AddExportedGlobal(
+                         kWasmI64, kImmutable, WasmInitExpr(int64_t{6}),
+                         base::CStrVector("const i64"));
   const uint32_t vfe_index =
       kNumImported + builder()->AddExportedGlobal(kWasmF32, kMutable,
                                                   WasmInitExpr(7.f),
-                                                  CStrVector("var f32"));
+                                                  base::CStrVector("var f32"));
   const uint32_t vie_index =
       kNumImported + builder()->AddExportedGlobal(kWasmI64, kMutable,
                                                   WasmInitExpr(int64_t{8}),
-                                                  CStrVector("var i64"));
+                                                  base::CStrVector("var i64"));
 
   // Define functions for inspecting globals.
   ValueType f32_type[] = {kWasmF32};
@@ -48,46 +48,46 @@ TEST_F(WasmCapiTest, Globals) {
   FunctionSig return_f32(1, 0, f32_type);
   FunctionSig return_i64(1, 0, i64_type);
   byte gcfi[] = {WASM_GLOBAL_GET(cfi_index)};
-  AddExportedFunction(CStrVector("get const f32 import"), gcfi, sizeof(gcfi),
-                      &return_f32);
+  AddExportedFunction(base::CStrVector("get const f32 import"), gcfi,
+                      sizeof(gcfi), &return_f32);
   byte gcii[] = {WASM_GLOBAL_GET(cii_index)};
-  AddExportedFunction(CStrVector("get const i64 import"), gcii, sizeof(gcii),
-                      &return_i64);
+  AddExportedFunction(base::CStrVector("get const i64 import"), gcii,
+                      sizeof(gcii), &return_i64);
   byte gvfi[] = {WASM_GLOBAL_GET(vfi_index)};
-  AddExportedFunction(CStrVector("get var f32 import"), gvfi, sizeof(gvfi),
-                      &return_f32);
+  AddExportedFunction(base::CStrVector("get var f32 import"), gvfi,
+                      sizeof(gvfi), &return_f32);
   byte gvii[] = {WASM_GLOBAL_GET(vii_index)};
-  AddExportedFunction(CStrVector("get var i64 import"), gvii, sizeof(gvii),
-                      &return_i64);
+  AddExportedFunction(base::CStrVector("get var i64 import"), gvii,
+                      sizeof(gvii), &return_i64);
 
   byte gcfe[] = {WASM_GLOBAL_GET(cfe_index)};
-  AddExportedFunction(CStrVector("get const f32 export"), gcfe, sizeof(gcfe),
-                      &return_f32);
+  AddExportedFunction(base::CStrVector("get const f32 export"), gcfe,
+                      sizeof(gcfe), &return_f32);
   byte gcie[] = {WASM_GLOBAL_GET(cie_index)};
-  AddExportedFunction(CStrVector("get const i64 export"), gcie, sizeof(gcie),
-                      &return_i64);
+  AddExportedFunction(base::CStrVector("get const i64 export"), gcie,
+                      sizeof(gcie), &return_i64);
   byte gvfe[] = {WASM_GLOBAL_GET(vfe_index)};
-  AddExportedFunction(CStrVector("get var f32 export"), gvfe, sizeof(gvfe),
-                      &return_f32);
+  AddExportedFunction(base::CStrVector("get var f32 export"), gvfe,
+                      sizeof(gvfe), &return_f32);
   byte gvie[] = {WASM_GLOBAL_GET(vie_index)};
-  AddExportedFunction(CStrVector("get var i64 export"), gvie, sizeof(gvie),
-                      &return_i64);
+  AddExportedFunction(base::CStrVector("get var i64 export"), gvie,
+                      sizeof(gvie), &return_i64);
 
   // Define functions for manipulating globals.
   FunctionSig param_f32(0, 1, f32_type);
   FunctionSig param_i64(0, 1, i64_type);
   byte svfi[] = {WASM_GLOBAL_SET(vfi_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("set var f32 import"), svfi, sizeof(svfi),
-                      &param_f32);
+  AddExportedFunction(base::CStrVector("set var f32 import"), svfi,
+                      sizeof(svfi), &param_f32);
   byte svii[] = {WASM_GLOBAL_SET(vii_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("set var i64 import"), svii, sizeof(svii),
-                      &param_i64);
+  AddExportedFunction(base::CStrVector("set var i64 import"), svii,
+                      sizeof(svii), &param_i64);
   byte svfe[] = {WASM_GLOBAL_SET(vfe_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("set var f32 export"), svfe, sizeof(svfe),
-                      &param_f32);
+  AddExportedFunction(base::CStrVector("set var f32 export"), svfe,
+                      sizeof(svfe), &param_f32);
   byte svie[] = {WASM_GLOBAL_SET(vie_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("set var i64 export"), svie, sizeof(svie),
-                      &param_i64);
+  AddExportedFunction(base::CStrVector("set var i64 export"), svie,
+                      sizeof(svie), &param_i64);
 
   // Create imported globals.
   own<GlobalType> const_f32_type =
diff --git a/test/wasm-api-tests/hostref.cc b/test/wasm-api-tests/hostref.cc
index d75f0e8ab7..fb6181b26a 100644
--- a/test/wasm-api-tests/hostref.cc
+++ b/test/wasm-api-tests/hostref.cc
@@ -32,28 +32,28 @@ TEST_F(WasmCapiTest, HostRef) {
   FunctionSig r_v_sig(1, 0, rr_reps);
   FunctionSig v_ir_sig(0, 2, ir_reps);
   FunctionSig r_i_sig(1, 1, ri_reps);
-  uint32_t func_index = builder()->AddImport(CStrVector("f"), &r_r_sig);
+  uint32_t func_index = builder()->AddImport(base::CStrVector("f"), &r_r_sig);
   const bool kMutable = true;
   uint32_t global_index = builder()->AddExportedGlobal(
       kWasmExternRef, kMutable, WasmInitExpr::RefNullConst(HeapType::kExtern),
-      CStrVector("global"));
+      base::CStrVector("global"));
   uint32_t table_index = builder()->AddTable(kWasmExternRef, 10);
-  builder()->AddExport(CStrVector("table"), kExternalTable, table_index);
+  builder()->AddExport(base::CStrVector("table"), kExternalTable, table_index);
   byte global_set_code[] = {WASM_GLOBAL_SET(global_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("global.set"), global_set_code,
+  AddExportedFunction(base::CStrVector("global.set"), global_set_code,
                       sizeof(global_set_code), &v_r_sig);
   byte global_get_code[] = {WASM_GLOBAL_GET(global_index)};
-  AddExportedFunction(CStrVector("global.get"), global_get_code,
+  AddExportedFunction(base::CStrVector("global.get"), global_get_code,
                       sizeof(global_get_code), &r_v_sig);
   byte table_set_code[] = {
       WASM_TABLE_SET(table_index, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
-  AddExportedFunction(CStrVector("table.set"), table_set_code,
+  AddExportedFunction(base::CStrVector("table.set"), table_set_code,
                       sizeof(table_set_code), &v_ir_sig);
   byte table_get_code[] = {WASM_TABLE_GET(table_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("table.get"), table_get_code,
+  AddExportedFunction(base::CStrVector("table.get"), table_get_code,
                       sizeof(table_get_code), &r_i_sig);
   byte func_call_code[] = {WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("func.call"), func_call_code,
+  AddExportedFunction(base::CStrVector("func.call"), func_call_code,
                       sizeof(func_call_code), &r_r_sig);
 
   own<FuncType> func_type =
diff --git a/test/wasm-api-tests/memory.cc b/test/wasm-api-tests/memory.cc
index 3b0ccc0840..43da93b357 100644
--- a/test/wasm-api-tests/memory.cc
+++ b/test/wasm-api-tests/memory.cc
@@ -14,21 +14,21 @@ using ::wasm::MemoryType;
 TEST_F(WasmCapiTest, Memory) {
   builder()->SetMinMemorySize(2);
   builder()->SetMaxMemorySize(3);
-  builder()->AddExport(CStrVector("memory"), kExternalMemory, 0);
+  builder()->AddExport(base::CStrVector("memory"), kExternalMemory, 0);
 
   ValueType i32_type[] = {kWasmI32, kWasmI32};
   FunctionSig return_i32(1, 0, i32_type);
   FunctionSig param_i32_return_i32(1, 1, i32_type);
   FunctionSig param_i32_i32(0, 2, i32_type);
   byte size_code[] = {WASM_MEMORY_SIZE};
-  AddExportedFunction(CStrVector("size"), size_code, sizeof(size_code),
+  AddExportedFunction(base::CStrVector("size"), size_code, sizeof(size_code),
                       &return_i32);
   byte load_code[] = {WASM_LOAD_MEM(MachineType::Int8(), WASM_LOCAL_GET(0))};
-  AddExportedFunction(CStrVector("load"), load_code, sizeof(load_code),
+  AddExportedFunction(base::CStrVector("load"), load_code, sizeof(load_code),
                       &param_i32_return_i32);
   byte store_code[] = {WASM_STORE_MEM(MachineType::Int8(), WASM_LOCAL_GET(0),
                                       WASM_LOCAL_GET(1))};
-  AddExportedFunction(CStrVector("store"), store_code, sizeof(store_code),
+  AddExportedFunction(base::CStrVector("store"), store_code, sizeof(store_code),
                       &param_i32_i32);
 
   byte data[] = {0x1, 0x2, 0x3, 0x4};
diff --git a/test/wasm-api-tests/multi-return.cc b/test/wasm-api-tests/multi-return.cc
index d2eda0d204..51fdfbfe0f 100644
--- a/test/wasm-api-tests/multi-return.cc
+++ b/test/wasm-api-tests/multi-return.cc
@@ -27,11 +27,11 @@ TEST_F(WasmCapiTest, MultiReturn) {
   ValueType reps[] = {kWasmI32, kWasmI64, kWasmI64, kWasmI32,
                       kWasmI32, kWasmI64, kWasmI64, kWasmI32};
   FunctionSig sig(4, 4, reps);
-  uint32_t func_index = builder()->AddImport(CStrVector("f"), &sig);
+  uint32_t func_index = builder()->AddImport(base::CStrVector("f"), &sig);
   byte code[] = {WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0),
                                     WASM_LOCAL_GET(2), WASM_LOCAL_GET(1),
                                     WASM_LOCAL_GET(3))};
-  AddExportedFunction(CStrVector("g"), code, sizeof(code), &sig);
+  AddExportedFunction(base::CStrVector("g"), code, sizeof(code), &sig);
 
   ownvec<ValType> types =
       ownvec<ValType>::make(ValType::make(I32), ValType::make(I64),
diff --git a/test/wasm-api-tests/reflect.cc b/test/wasm-api-tests/reflect.cc
index 1a9d6fbfbe..80a85aa23a 100644
--- a/test/wasm-api-tests/reflect.cc
+++ b/test/wasm-api-tests/reflect.cc
@@ -38,16 +38,16 @@ TEST_F(WasmCapiTest, Reflect) {
   ValueType types[] = {kWasmI32, kWasmExternRef, kWasmI32,
                        kWasmI64, kWasmF32,       kWasmF64};
   FunctionSig sig(2, 4, types);
-  AddExportedFunction(CStrVector(kFuncName), code, sizeof(code), &sig);
+  AddExportedFunction(base::CStrVector(kFuncName), code, sizeof(code), &sig);
 
   builder()->AddExportedGlobal(kWasmF64, false, WasmInitExpr(0.0),
-                               CStrVector(kGlobalName));
+                               base::CStrVector(kGlobalName));
 
   builder()->AllocateIndirectFunctions(12);
-  builder()->AddExport(CStrVector(kTableName), kExternalTable, 0);
+  builder()->AddExport(base::CStrVector(kTableName), kExternalTable, 0);
 
   builder()->SetMinMemorySize(1);
-  builder()->AddExport(CStrVector(kMemoryName), kExternalMemory, 0);
+  builder()->AddExport(base::CStrVector(kMemoryName), kExternalMemory, 0);
 
   Instantiate(nullptr);
 
diff --git a/test/wasm-api-tests/serialize.cc b/test/wasm-api-tests/serialize.cc
index a8718402c6..1b82b47884 100644
--- a/test/wasm-api-tests/serialize.cc
+++ b/test/wasm-api-tests/serialize.cc
@@ -21,9 +21,10 @@ own<Trap> Callback(const Val args[], Val results[]) {
 
 TEST_F(WasmCapiTest, Serialize) {
   FunctionSig sig(0, 0, nullptr);
-  uint32_t callback_index = builder()->AddImport(CStrVector("callback"), &sig);
+  uint32_t callback_index =
+      builder()->AddImport(base::CStrVector("callback"), &sig);
   byte code[] = {WASM_CALL_FUNCTION0(callback_index)};
-  AddExportedFunction(CStrVector("run"), code, sizeof(code), &sig);
+  AddExportedFunction(base::CStrVector("run"), code, sizeof(code), &sig);
   Compile();
 
   vec<byte_t> serialized = module()->serialize();
diff --git a/test/wasm-api-tests/startup-errors.cc b/test/wasm-api-tests/startup-errors.cc
index d2187e569a..26fdbfc6c7 100644
--- a/test/wasm-api-tests/startup-errors.cc
+++ b/test/wasm-api-tests/startup-errors.cc
@@ -21,7 +21,7 @@ TEST_F(WasmCapiTest, StartupErrors) {
   start_func->EmitCode(code, static_cast<uint32_t>(sizeof(code)));
   start_func->Emit(kExprEnd);
   builder()->MarkStartFunction(start_func);
-  builder()->AddImport(CStrVector("dummy"), &sig);
+  builder()->AddImport(base::CStrVector("dummy"), &sig);
   Compile();
   own<Trap> trap;
 
diff --git a/test/wasm-api-tests/table.cc b/test/wasm-api-tests/table.cc
index fea6140c06..e96ad5f0a1 100644
--- a/test/wasm-api-tests/table.cc
+++ b/test/wasm-api-tests/table.cc
@@ -39,18 +39,20 @@ void ExpectResult(int expected, const Func* func, int arg1, int arg2) {
 TEST_F(WasmCapiTest, Table) {
   builder()->AllocateIndirectFunctions(2);
   builder()->SetMaxTableSize(10);
-  builder()->AddExport(CStrVector("table"), kExternalTable, 0);
+  builder()->AddExport(base::CStrVector("table"), kExternalTable, 0);
   const uint32_t sig_i_i_index = builder()->AddSignature(wasm_i_i_sig());
   ValueType reps[] = {kWasmI32, kWasmI32, kWasmI32};
   FunctionSig call_sig(1, 2, reps);
   byte call_code[] = {
       WASM_CALL_INDIRECT(sig_i_i_index, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
-  AddExportedFunction(CStrVector("call_indirect"), call_code, sizeof(call_code),
-                      &call_sig);
+  AddExportedFunction(base::CStrVector("call_indirect"), call_code,
+                      sizeof(call_code), &call_sig);
   byte f_code[] = {WASM_LOCAL_GET(0)};
-  AddExportedFunction(CStrVector("f"), f_code, sizeof(f_code), wasm_i_i_sig());
+  AddExportedFunction(base::CStrVector("f"), f_code, sizeof(f_code),
+                      wasm_i_i_sig());
   byte g_code[] = {WASM_I32V_1(42)};
-  AddExportedFunction(CStrVector("g"), g_code, sizeof(g_code), wasm_i_i_sig());
+  AddExportedFunction(base::CStrVector("g"), g_code, sizeof(g_code),
+                      wasm_i_i_sig());
   // Set table[1] to {f}, which has function index 1.
   builder()->SetIndirectFunction(1, 1);
 
diff --git a/test/wasm-api-tests/threads.cc b/test/wasm-api-tests/threads.cc
index 7f80ca1e66..c85a773f0d 100644
--- a/test/wasm-api-tests/threads.cc
+++ b/test/wasm-api-tests/threads.cc
@@ -61,14 +61,14 @@ TEST_F(WasmCapiTest, Threads) {
   ValueType i32_type[] = {kWasmI32};
   FunctionSig param_i32(0, 1, i32_type);
   uint32_t callback_index =
-      builder()->AddImport(CStrVector("callback"), &param_i32);
+      builder()->AddImport(base::CStrVector("callback"), &param_i32);
   uint32_t global_index =
-      builder()->AddGlobalImport(CStrVector("id"), kWasmI32, false);
+      builder()->AddGlobalImport(base::CStrVector("id"), kWasmI32, false);
 
   byte code[] = {
       WASM_CALL_FUNCTION(callback_index, WASM_GLOBAL_GET(global_index))};
   FunctionSig empty_sig(0, 0, nullptr);
-  AddExportedFunction(CStrVector("run"), code, sizeof(code), &empty_sig);
+  AddExportedFunction(base::CStrVector("run"), code, sizeof(code), &empty_sig);
   Compile();
   own<Shared<Module>> shared = module()->share();
 
diff --git a/test/wasm-api-tests/traps.cc b/test/wasm-api-tests/traps.cc
index 3cc4089ae9..c56952ca3a 100644
--- a/test/wasm-api-tests/traps.cc
+++ b/test/wasm-api-tests/traps.cc
@@ -38,12 +38,14 @@ TEST_F(WasmCapiTest, Traps) {
   FLAG_experimental_wasm_eh = true;
   ValueType i32_type[] = {kWasmI32};
   FunctionSig sig(1, 0, i32_type);
-  uint32_t callback_index = builder()->AddImport(CStrVector("callback"), &sig);
+  uint32_t callback_index =
+      builder()->AddImport(base::CStrVector("callback"), &sig);
   byte code[] = {WASM_CALL_FUNCTION0(callback_index)};
-  AddExportedFunction(CStrVector("callback"), code, sizeof(code), &sig);
+  AddExportedFunction(base::CStrVector("callback"), code, sizeof(code), &sig);
 
   byte code2[] = {WASM_CALL_FUNCTION0(3)};
-  AddExportedFunction(CStrVector("unreachable"), code2, sizeof(code2), &sig);
+  AddExportedFunction(base::CStrVector("unreachable"), code2, sizeof(code2),
+                      &sig);
   // The first constant is a 4-byte dummy so that the {unreachable} trap
   // has a more interesting offset. This is called by code2.
   byte code3[] = {WASM_I32V_3(0), WASM_UNREACHABLE, WASM_I32V_1(1)};
@@ -52,7 +54,8 @@ TEST_F(WasmCapiTest, Traps) {
   // Check that traps returned from a C callback are uncatchable in Wasm.
   byte code4[] = {WASM_TRY_CATCH_ALL_T(
       kWasmI32, WASM_CALL_FUNCTION0(callback_index), WASM_I32V(42))};
-  AddExportedFunction(CStrVector("uncatchable"), code4, sizeof(code4), &sig);
+  AddExportedFunction(base::CStrVector("uncatchable"), code4, sizeof(code4),
+                      &sig);
 
   own<FuncType> func_type =
       FuncType::make(ownvec<ValType>::make(),
diff --git a/test/wasm-api-tests/wasm-api-test.h b/test/wasm-api-tests/wasm-api-test.h
index b74b927622..434dcf7690 100644
--- a/test/wasm-api-tests/wasm-api-test.h
+++ b/test/wasm-api-tests/wasm-api-test.h
@@ -71,7 +71,7 @@ class WasmCapiTest : public ::testing::Test {
     exports_ = instance_->exports();
   }
 
-  void AddExportedFunction(Vector<const char> name, byte code[],
+  void AddExportedFunction(base::Vector<const char> name, byte code[],
                            size_t code_size, FunctionSig* sig) {
     WasmFunctionBuilder* fun = builder()->AddFunction(sig);
     fun->EmitCode(code, static_cast<uint32_t>(code_size));
diff --git a/third_party/inspector_protocol/crdtp/json_platform_v8.cc b/third_party/inspector_protocol/crdtp/json_platform_v8.cc
index 97f80b4fc5..a973a7292d 100644
--- a/third_party/inspector_protocol/crdtp/json_platform_v8.cc
+++ b/third_party/inspector_protocol/crdtp/json_platform_v8.cc
@@ -7,8 +7,8 @@
 #include "json_platform.h"
 
 #include <cmath>
+#include "../../../src/base/vector.h"
 #include "../../../src/numbers/conversions.h"
-#include "../../../src/utils/vector.h"
 
 namespace v8_crdtp {
 namespace json {
@@ -22,7 +22,7 @@ bool StrToD(const char* str, double* result) {
 
 // Prints |value| in a format suitable for JSON.
 std::string DToStr(double value) {
-  v8::internal::ScopedVector<char> buffer(
+  v8::base::ScopedVector<char> buffer(
       v8::internal::kDoubleToCStringMinBufferSize);
   const char* str = v8::internal::DoubleToCString(value, buffer);
   return (str == nullptr) ? "" : std::string(str);
-- 
2.35.1

